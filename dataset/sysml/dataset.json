[
  {
    "nl": "The system needs to be able to define the basic information of vehicles, including vehicle mass, current status, engine, and driver, etc. The vehicle status should be able to describe gear setting and accelerator pedal position. Each vehicle should have one engine component and can be associated with a driver. The system should also support independent modeling and management of engine and personnel components. Through this system, users can comprehensively track and manage key parameters and operating status of vehicles, thereby supporting subsequent business analysis and operational needs.",
    "design": "package 'VehicleDefinition' {\n\tprivate import ScalarValues::*;\n\tpart def Vehicle {\n\t\tattribute mass : Real;\n\t\tattribute status : VehicleStatus;\n\t\tpart eng : Engine;\n\t\tref part driver : Person;\n\t}\n\tattribute def VehicleStatus {\n\t\tattribute gearSetting : Integer;\n\t\tattribute acceleratorPosition : Real;\n\t}\n\tpart def Engine;\t\n\tpart def Person;\n}",
    "domain": "Vehicle Traffic",
    "grammar": "Attribute",
    "diagram": "dataset/sysml/samples/01/design.png"
  },
  {
    "nl": "This system is designed to model various types of vehicles. Vehicles are mainly divided into two categories: manually operated vehicles and powered vehicles. Manually operated vehicles are driven by personnel, with each vehicle corresponding to a single driver; powered vehicles are equipped with engines as their source of power. In addition, certain vehicles are both manually operated and equipped with engines, and are classified as manually operated powered vehicles. The system also includes two entities, Personnel and Engine, which are used to describe drivers and power devices of vehicles, respectively. Through this model, the relationships among personnel, vehicles, and their power devices in various vehicle types can be fully represented.",
    "design": "package 'VehicleType' {\n\tabstract part def Vehicle;\n\tpart def HumanDrivenVehicle specializes Vehicle {\n\t\tref part driver : Person;\n\t}\n\tpart def PoweredVehicle :> Vehicle {\n\t\tpart eng : Engine;\n\t}\n\tpart def HumanDrivenPoweredVehicle :> \n\t\tHumanDrivenVehicle, PoweredVehicle;\n\tpart def Engine;\t\n\tpart def Person;\n}",
    "domain": "Vehicle Traffic",
    "grammar": "Generalization",
    "diagram": "dataset/sysml/samples/02/design.png"
  },
  {
    "nl": "The system needs to define and describe a vehicle structure, in which each vehicle is composed of multiple components. A vehicle consists of major components such as one engine, one transmission, and four wheels. These components are all subclasses of vehicle components. The overall vehicle structure should reflect the compositional relationships and quantity requirements among the various components—for example, a vehicle must be equipped with exactly four wheels, as well as one engine and one transmission. The system should also support extensibility for both vehicle and component types, in order to accommodate different vehicle configurations and component varieties, thereby better meeting the needs of automotive structure design and management.",
    "design": "package 'VehicleDefinition' {\n\tpart def Vehicle {\n\t\tpart parts : VehiclePart[*];\n\t\tpart eng : Engine subsets parts;\n\t\tpart trans : Transmission subsets parts;\n\t\tpart wheels : Wheel[4] :> parts;\n\t}\n\tabstract part def VehiclePart;\n\tpart def Engine :> VehiclePart;\n\tpart def Transmission :> VehiclePart;\n\tpart def Wheel :> VehiclePart;\n}",
    "domain": "Vehicle Traffic",
    "grammar": "Subsetting",
    "diagram": "dataset/sysml/samples/03/design.png"
  },
  {
    "nl": "The system must be able to define and distinguish between different types of vehicles, including small vehicles and large vehicles, with each category equipped with a specific type of engine. All vehicles are equipped with an engine component: small vehicles must be equipped with a small engine, which contains 4 cylinders, while large vehicles must be equipped with a large engine, which contains 6 cylinders. Each engine contains a functional subsystem composed of a specific number of cylinders to meet the actual requirements of the vehicle's power system. By strictly classifying vehicle types and the specifications of their key components, the system ensures the adaptability and reliability of each type of vehicle in terms of structure and performance.",
    "design": "package 'VehicleDefinition' {\n\tpart def Vehicle {\n\t\tpart eng : Engine;\n\t}\n\tpart def SmallVehicle :> Vehicle {\n\t\tpart smallEng : SmallEngine redefines eng;\n\t}\n\tpart def BigVehicle :> Vehicle {\n\t\tpart bigEng : BigEngine :>> eng;\n\t}\n\tpart def Engine {\n\t\tpart cyl : Cylinder[4..6];\n\t}\n\tpart def SmallEngine :> Engine {\n\t\tpart redefines cyl[4];\n\t}\n\tpart def BigEngine :> Engine {\n\t\tpart redefines cyl[6];\n\t}\n\tpart def Cylinder;\n}",
    "domain": "Vehicle Traffic",
    "grammar": "Redefinition",
    "diagram": "dataset/sysml/samples/04/design.png"
  },
  {
    "nl": "The traffic signal system includes a traffic signal component that represents the current color state of the traffic light, with the colors being green, yellow, and red. Additionally, the system defines a specific traffic signal component that is in the green state, indicating that it is always in the \"go\" state. The above model supports the explicit indication of the traffic light's color, helping to facilitate orderly traffic flow and management.",
    "design": "package 'TrafficLightDefinition' {\n\tprivate import ScalarValues::Real;\n\tenum def TrafficLightColor {\n\t\tenum green;\n\t\tenum yellow;\n\t\tenum red;\n\t}\n\tpart def TrafficLight {\n\t\tattribute currentColor : TrafficLightColor;\n\t}\n\tpart def TrafficLightGo specializes TrafficLight {\n\t\tattribute redefines currentColor = TrafficLightColor::green;\n\t}\n}",
    "domain": "Vehicle Traffic",
    "grammar": "Enumeration",
    "diagram": "dataset/sysml/samples/05/design.png"
  },
  {
    "nl": "The system needs to implement an information classification management mechanism based on the “traffic light” principle. Information is divided into three levels: “Unclassified,” “Confidential,” and “Secret,” each corresponding to a code and a color: unclassified information uses the code “uncl” and is marked in green; confidential information uses the code “conf” and is marked in yellow; and secret information uses the code “secr” and is marked in red. In addition, the system must also support grade classification. Grade levels include A, B, C, D, and F, which correspond to 4.0, 3.0, 2.0, 1.0, and 0.0 points, respectively. The classification of different types of information and the scores for grades must be clearly defined and distinguished in the system, so that users can easily and intuitively identify various categories of information and grades during operation and management.",
    "design": "package 'TrafficLightDefinition' {\n\tprivate import ScalarValues::*;\n\tenum def TrafficLightColor {\n\t\tenum green;\n\t\tenum yellow;\n\t\tenum red;\n\t}\n\tattribute def ClassificationLevel {\n\t\tattribute code : String;\n\t\tattribute color : TrafficLightColor;\n\t}\n\tenum def ClassificationKind specializes ClassificationLevel {\n\t\tunclassified {\n\t\t\t:>> code = \"uncl\";\n\t\t\t:>> color = TrafficLightColor::green;\n\t\t}\n\t\tconfidential {\n\t\t\t:>> code = \"conf\";\n\t\t\t:>> color = TrafficLightColor::yellow;\n\t\t}\n\t\tsecret {\n\t\t\t:>> code = \"secr\";\n\t\t\t:>> color = TrafficLightColor::red;\n\t\t}\n\t}\n\tenum def GradePoints :> Real {\n\t\tA = 4.0;\n\t\tB = 3.0;\n\t\tC = 2.0;\n\t\tD = 1.0;\n\t\tF = 0.0;\n\t}\n}",
    "domain": "Confidentiality and security",
    "grammar": "Enumeration",
    "diagram": "dataset/sysml/samples/06/design.png"
  },
  {
    "nl": "This system mainly includes two types of vehicles: small vehicles and large vehicles. Each type is equipped with an engine, and each engine consists of several cylinders. The engine of a small vehicle has 4 cylinders, while the engine of a large vehicle has 6 cylinders. Each cylinder, as a fundamental component of the engine, plays a key role in the engine's normal operation and the vehicle’s power output. This design supports engine configurations with 4 to 6 cylinders to meet the performance requirements of different vehicle types.",
    "design": "package 'VehicleDefinition' {\n\tpart def Vehicle {\n\t\tpart eng : Engine;\n\t}\n\tpart def Engine {\n\t\tpart cyl : Cylinder[4..6];\n\t}\n\tpart def Cylinder;\t\n\tpart smallVehicle : Vehicle {\n\t\tpart redefines eng {\n\t\t\tpart redefines cyl[4];\n\t\t}\n\t}\n\tpart bigVehicle : Vehicle {\n\t\tpart redefines eng {\n\t\t\tpart redefines cyl[6];\n\t\t}\n\t}\n}",
    "domain": "Vehicle Traffic",
    "grammar": "Part",
    "diagram": "dataset/sysml/samples/07/design.png"
  },
  {
    "nl": "The system needs to support vehicle modeling. Each vehicle should include quality attributes and be able to specify driver information, as well as be equipped with an independent fuel tank. The fuel tank must be able to store a specific type of fuel. In addition, the system should have the capability to define and manage basic information such as fuel and personnel, in order to provide necessary data support for the vehicle model. Overall, there should be clear associations between each element to ensure a comprehensive description of vehicles and their components.",
    "design": "package 'VehicleDefinition' {\n\tprivate import ScalarValues::*;\n\titem def Fuel;\n\titem def Person;\n\tpart def Vehicle {\n\t\tattribute mass : Real;\n\t\tref item driver : Person;\n\t\tpart fuelTank {\n\t\t\titem fuel: Fuel;\n\t\t}\t\t\n\t}\t\n}",
    "domain": "Vehicle Traffic",
    "grammar": "Item",
    "diagram": "dataset/sysml/samples/08/design.png"
  },
  {
    "nl": "This system is designed to describe the structure of an automobile wheel assembly. The system includes components such as the wheel bearing unit, tire, bead, hub, rim, bolt mounting hole, hub, threaded hole, and bolt connection. The tire is sealed and fastened by pressing its two beads onto the two rims of the hub. Multiple mounting holes are provided on the hub, which are connected to the threaded holes on the hub using bolts, thereby ensuring a reliable connection between the hub and the tire assembly. This model provides a detailed description of the specific relationships and connection methods between each component, thus offering structural-level support for the design, assembly, and maintenance of the wheel assembly and further helping to ensure the structural strength and safety of the wheel.",
    "design": "package 'WheelAssemblyStructure' {\n\tpart def WheelHubAssembly;\n\tpart def WheelAssembly;\n\tpart def Tire;\n\tpart def TireBead;\n\tpart def Wheel;\n\tpart def TireMountingRim;\n\tpart def LugBoltMountingHole;\n\tpart def Hub;\n\tpart def LugBoltThreadableHole;\n\tpart def LugBoltJoint;\n\tconnection def PressureSeat {\n\t\tend bead : TireBead[1];\n\t\tend mountingRim : TireMountingRim[1];\n\t}\n\tpart wheelHubAssembly : WheelHubAssembly {\n\t\t\n\t\tpart wheel : WheelAssembly[1] {\n\t\t\tpart t : Tire[1] {\n\t\t\t\tpart bead : TireBead[2];\t\t\t\n\t\t\t}\n\t\t\tpart w: Wheel[1] {\n\t\t\t\tpart rim : TireMountingRim[2];\n\t\t\t\tpart mountingHoles : LugBoltMountingHole[5];\n\t\t\t}\t\t\t\t\t\t\n\t\t\tconnection : PressureSeat \n\t\t\t\tconnect bead references t.bead \n\t\t\t\tto mountingRim references w.rim;\t\t\n\t\t}\n\t\tpart lugBoltJoints : LugBoltJoint[0..5];\n\t\tpart hub : Hub[1] {\n\t\t\tpart h : LugBoltThreadableHole[5];\n\t\t}\n\t\tconnect lugBoltJoints[0..1] to wheel.w.mountingHoles[1];\n\t\tconnect lugBoltJoints[0..1] to hub.h[1];\n\t}\n}",
    "domain": "Vehicle Traffic",
    "grammar": "Connection",
    "diagram": "dataset/sysml/samples/09/design.png"
  },
  {
    "nl": "This system is designed to achieve effective management of fuel flow. It consists of two main components: the fuel tank assembly and the engine. The fuel tank supplies fuel to the engine through a dedicated port, and can also receive excess fuel returned from the engine. Throughout the entire fuel transfer process, temperature information can be detected and transmitted at the interface to ensure the safety and efficiency of fuel supply. Users can obtain real-time data on fuel supply, return flow, and related temperature parameters, enabling visualized monitoring and precise control of fuel flow status. This effectively meets the engine's requirements for fuel management during operation.",
    "design": "package 'FuelFlowManagement' {\n\tattribute def Temp;\n\tpart def Fuel;\n\tport def FuelOutPort {\n\t\tattribute temperature : Temp;\n\t\tout item fuelSupply : Fuel;\n\t\tin item fuelReturn : Fuel;\n\t}\n\tport def FuelInPort {\n\t\tattribute temperature : Temp;\n\t\tin item fuelSupply : Fuel;\n\t\tout item fuelReturn : Fuel;\n\t}\n\tpart def FuelTankAssembly {\n\t\tport fuelTankPort : FuelOutPort;\n\t}\n\tpart def Engine {\n\t\tport engineFuelPort : FuelInPort;\n\t}\n}",
    "domain": "Aerospace",
    "grammar": "Port",
    "diagram": "dataset/sysml/samples/10/design.png"
  },
  {
    "nl": "This system is designed for modeling configuration variants of vehicles. The core components include the complete vehicle, front and rear axles, and tires, with key attributes such as mass defined for each. The default vehicle mass is set to 1750 kg and consists of one front axle and one rear axle, each of which is equipped with two ordered tires. The system supports variant modeling; for example, in the vehicle configuration named \"vehicle1_c1,\" the total vehicle mass can be further increased to 2000 kg, and the front axle can be replaced with a dedicated front axle featuring a steering angle. Meanwhile, specific instances of the front axle, rear axle, and tires can be renamed and managed to meet the requirements of various vehicle configurations. The model requires that the attributes of each component can be explicitly defined, inherited, and overridden, allowing users to flexibly configure various vehicle structures and to provide detailed descriptions and management of specific variants. This supports the needs of different configuration scenarios in actual vehicle design and assembly processes.",
    "design": "package 'Vehicle Configuration Variant Modeling {\n\tprivate import SI::kg;\n\tpackage Definitions {\t\n\t\tpart def Vehicle {\n\t\t\tattribute mass :> ISQ::mass;\n\t\t}\t\t\n\t\tpart def AxleAssembly;\t\t\n\t\tpart def Axle { \n\t\t\tattribute mass :> ISQ::mass;\n\t\t}\t\n\t\tpart def FrontAxle :> Axle { \n\t\t\tattribute steeringAngle: ScalarValues::Real;\n\t\t}\t\n\t\tpart def Wheel;\t\n\t}\n\tpackage Usages {\n\t\tprivate import Definitions::*;\n\t\tpart vehicle1: Vehicle {\n\t\t\tattribute mass redefines Vehicle::mass default = 1750 [kg] {\n\t\t\tdoc\n\t\t\t/*\n\t\t\t * The mass attribute is redefined to give it a default value.\n\t\t\t */\n\t\t\t}\t\n\t\t\tpart frontAxleAssembly: AxleAssembly {\n\t\t\t\tpart frontAxle: Axle;\t\t\t\n\t\t\t\tpart frontWheel: Wheel[2] ordered;\n\t\t\t}\t\t\n\t\t\tpart rearAxleAssembly: AxleAssembly {\n\t\t\t\tpart rearAxle: Axle;\n\t\t\t\tpart rearWheel: Wheel[2] ordered;\n\t\t\t}\t\t\n\t\t}\n\t\tpart vehicle1_c1 :> vehicle1 {\n\t\t\t/*\n\t\t\t * 'vehicle1_c1' is a specialization of 'vehicle1' (technically \n\t\t\t * a subset). It inherits all the parts of 'vehicle1' and\n\t\t\t * only needs to specify additional or redefined parts.\n\t\t\t */\n\t\t\tattribute mass redefines vehicle1::mass = 2000 [kg] {\n\t\t\t\t/*\n\t\t\t\t * The mass is further redefined to override the default value\n\t\t\t\t * with a bound value for 'vehicle_c1'.\n\t\t\t\t */\n\t\t\t}\t\n\t\t\tpart frontAxleAssembly_c1 redefines frontAxleAssembly {\n\t\t\t\tpart frontAxle_c1: FrontAxle redefines frontAxle {\n\t\t\t\t\t/*\n\t\t\t\t\t * 'frontAxle_c1' redefines 'frontAxleAssembly'::'frontAxle'\n\t\t\t\t\t * to give it a new name and the specialized type\n\t\t\t\t\t * 'FrontAxle'.\n\t\t\t\t\t */\n\t\t\t\t}\n\t\t\t\t/*\n\t\t\t\t * 'frontWheel' is inherited from 'vehicle1'::'frontAxleAssembly',\n\t\t\t\t * allowing it to be used in the following part declarations.\n\t\t\t\t */\n\t\t\t\tpart frontWheel_1 subsets frontWheel = frontWheel#(1);\n\t\t\t\tpart frontWheel_2 subsets frontWheel = frontWheel#(2);\n\t\t\t}\n\t\t\tpart rearAxleAssembly_c1 redefines rearAxleAssembly {\n\t\t\t\tpart rearAxle_c1 redefines rearAxle {\n\t\t\t\t\t/*\n\t\t\t\t\t * 'rearAxle_c1' redefines 'rearAxleAssembly'::'rearAxle'\n\t\t\t\t\t * to give it a new name. It inherits the type 'Axle'\n\t\t\t\t\t * from the redefined part.\n\t\t\t\t\t */\n\t\t\t\t}\t\n\t\t\t\tpart rearWheel_1 subsets rearWheel = rearWheel#(1);\n\t\t\t\tpart rearWheel_2 subsets rearWheel = rearWheel#(2);\n\t\t\t}\t\t\n\t\t}\n\t}\n}",
    "domain": "Vehicle Traffic",
    "grammar": "Part",
    "diagram": "dataset/sysml/samples/100/design.png"
  },
  {
    "nl": "This system aims to model the coupling system between a vehicle and a trailer. The system consists of one vehicle and one trailer, which are connected via a coupling mechanism (such as a tow hitch or ball connector). The vehicle itself does not directly possess a coupling ball but instead connects by referencing the ball within the hitch component. This means that the vehicle can physically connect to any compatible hitch without the need for a dedicated built-in component. Similarly, the trailer is bound to the connector in the hitch component by reference, allowing for their physical interfacing. This design ensures the reusability and flexible combination of each component, facilitating quick adaptation and assembly of various vehicle and trailer models. Furthermore, when disconnecting or removing components, individual parts can be independently detached without affecting the normal operation of other components. This enhances the modularity of the coupling system and simplifies maintenance.",
    "design": "package 'VehicleTrailerCouplingSystemModeling' {\n\tpackage Definitions {\n\t\tpart def Vehicle;\n\t\tpart def Trailer;\n\t\tpart def TrailerHitch;\n\t\tpart def HitchBall;\n\t\tpart def TrailerCoupler;\n\t}\n\tpackage Usages {\n\t\tprivate import Definitions::*;\n\t\tpart vehicle_trailer_system {\n\t\t\tpart vehicle1_c1: Vehicle {\n\t\t\t\tref hitchBall : HitchBall {\n\t\t\t\t\t/*\n\t\t\t\t\t * 'vehicle1_c1'::'hitchBall' is a reference property that\n\t\t\t\t\t * references a hitch ball that is not part of this vehicle. \n\t\t\t\t\t * If 'vehicle1_c1' is removed or destroyed, this does not\n\t\t\t\t\t * effect the hitchBall referenced here.\n\t\t\t\t\t */\n\t\t\t\t}\n\t\t\t}\n\t\t\tbind vehicle1_c1.hitchBall = trailerHitch.hitchBall {\n\t\t\t\t/*\n\t\t\t\t * This is a binding connector between the 'hitchBall' in 'vehicle1_c1'\n\t\t\t\t * and the 'hitchBall' in 'trailerHitch'.\n\t\t\t\t */\t\t\t\n\t\t\t}\n\t\t\tpart trailerHitch: TrailerHitch {\t\t\t\t\n\t\t\t\tpart hitchBall: HitchBall;\n\t\t\t\tpart trailerCoupler: TrailerCoupler;\n\t\t\t}\n\t\t\tpart trailer1: Trailer {\n\t\t\t\tref trailerCoupler : TrailerCoupler = trailerHitch.trailerCoupler {\n\t\t\t\t\t/*\n\t\t\t\t\t * This is a shorthand for a binding connector between the\n\t\t\t\t\t * 'trailerCoupler' here and the 'trailerCoupler' in 'trailerHitch'.\n\t\t\t\t\t * The binding connector is now contained within the 'trailer1'\n\t\t\t\t\t * part, though, rather than being at the system level. \n\t\t\t\t\t */\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n}",
    "domain": "Vehicle Traffic",
    "grammar": "Part",
    "diagram": "dataset/sysml/samples/101/design.png"
  },
  {
    "nl": "The system requirements are described as follows: This project aims to design and model a typical vehicle power transmission system, mainly including the engine, transmission (gearbox), clutch, driveshaft, rear axle assembly (including differential and left/right half-shafts), wheels, and the interface for interaction with the road surface. The engine receives control signals via a fuel command port and is coupled to the transmission through power and clutch ports. Power is transmitted via the driveshaft to the rear axle assembly. The rear axle assembly includes a differential that connects separately to the left and right half-shafts, delivering power to the rear wheels through interfaces between the shafts and wheels. Each rear wheel is equipped with interfaces to both the rear axle and the road, enabling power output to the ground. The interfaces between the internal components of the system are clearly defined, allowing for flexible combination and hierarchical decomposition at various levels and within major assemblies. This supports port and component binding, redefinition, and multi-level nesting, ensuring clear transmission of power and command flows among the components. The system is designed to be modular and reconfigurable, meeting the needs of vehicle dynamics modeling, simulation, and subsequent optimization design. It enables end users to understand, adjust, and expand the relationships and functions of various vehicle power components with ease.",
    "design": "package 'VehiclePowertrainSystem' {\n\tpublic import Definitions::*;\n\tpublic import Usages::*;\n\tpackage Definitions {\t\t\n\t\tport def FuelCmdPort;\n\t\tport def DrivePwrPort;\n\t\tport def ClutchPort;\n\t\tport def ShaftPort_a;\n\t\tport def ShaftPort_b;\n\t\tport def ShaftPort_c;\n\t\tport def ShaftPort_d;\n\t\tport def DiffPort;\n\t\tport def AxlePort;\n\t\tport def AxleToWheelPort;\n\t\tport def WheelToAxlePort;\n\t\tport def WheelToRoadPort;\n\t\tport def VehicleToRoadPort {\n\t\t\t/*\n\t\t\t * A port definition can have nested ports.\n\t\t\t */\n\t\t\tport wheelToRoadPort: WheelToRoadPort[2];\n\t\t}\n\t\tpart def VehicleA { \n\t\t\tport fuelCmdPort: FuelCmdPort;\n\t\t\tport vehicleToRoadPort: VehicleToRoadPort;\n\t\t}\n\t\tpart def AxleAssembly;\t\t\n\t\tpart def RearAxleAssembly :> AxleAssembly { \n\t\t\tport shaftPort_d: ShaftPort_d;\n\t\t}\n\t\tpart def Axle;\n\t\tpart def RearAxle :> Axle;\n\t\tpart def HalfAxle { \n\t\t\tport axleToDiffPort: AxlePort;\n\t\t\tport axleToWheelPort: AxleToWheelPort;\n\t\t}\n\t\tpart def Engine { \n\t\t\tport fuelCmdPort: FuelCmdPort;\n\t\t\tport drivePwrPort: DrivePwrPort;\n\t\t}\n\t\tpart def Transmission { \n\t\t\tport clutchPort: ClutchPort;\n\t\t\tport shaftPort_a: ShaftPort_a;\n\t\t}\n\t\tpart def Driveshaft { \n\t\t\tport shaftPort_b: ShaftPort_b;\n\t\t\tport shaftPort_c: ShaftPort_c;\n\t\t}\t\n\t\tpart def Differential {\n\t\t\t/*\n\t\t\t * Ports do not have to be defined on part defs.\n\t\t\t * They can be added directly to their usages.\n\t\t\t */\n\t\t}\n\t\tpart def Wheel;\n\t\tinterface def EngineToTransmissionInterface {\n\t\t\t/*\n\t\t\t * The ends of an interface definition are always ports.\n\t\t\t */\n\t\t\n\t\t\tend drivePwrPort: DrivePwrPort;\n\t\t\tend clutchPort: ClutchPort;\n\t\t}\n\t\tinterface def DriveshaftInterface {\n\t\t\tend shaftPort_a: ShaftPort_a;\n\t\t\tend shaftPort_d: ShaftPort_d;\t\n\t\t\tref driveshaft: Driveshaft {\n\t\t\t\t/*\n\t\t\t\t * 'driveshaft' is a reference to the driveshaft that will\n\t\t\t\t * act as the \"interface medium\" for this interface.\n\t\t\t\t */\n\t\t\t}\n\t\t\tconnect shaftPort_a to driveshaft.shaftPort_b {\n\t\t\t\t/*\n\t\t\t\t * The two ends of 'DriveShaftInterface' are always connected\n\t\t\t\t * via the referenced 'driveshaft'.\n\t\t\t\t */\n\t\t\t}\n\t\t\tconnect driveshaft.shaftPort_c to shaftPort_d;\n\t\t}\n\t}\n\tpackage Usages {\n\t\tpart vehicle1_c1: VehicleA {\t\n\t\t\tbind fuelCmdPort = engine.fuelCmdPort;\n\t\t\tpart engine: Engine;\n\t\t\tinterface :EngineToTransmissionInterface\n\t\t\t\tconnect engine.drivePwrPort to transmission.clutchPort {\n\t\t\t\t/*\n\t\t\t\t * A usage of an interface definition connects two ports relative to \n\t\t\t\t * a containing context.\n\t\t\t\t */\n\t\t\t}\n\t\t\tpart transmission: Transmission;\n\t\t\tpart driveshaft: Driveshaft {\n\t\t\t\t/*\n\t\t\t\t * This 'driveshaft' is the part of 'vehicle1_c1' that will act as the\n\t\t\t\t * interface medium in the following 'DriveshaftInterface' usage.\n\t\t\t\t */\n\t\t\t}\n\t\t\tinterface :DriveshaftInterface\n\t\t\t\tconnect transmission.shaftPort_a to rearAxleAssembly.shaftPort_d {\n\t\t\t\t\tref :>> driveshaft = vehicle1_c1.driveshaft {\n\t\t\t\t\t\t/*\n\t\t\t\t\t\t * The reference property from 'DriveshaftInterface' is redefined\n\t\t\t\t\t\t * in order to bind it to the appropriate part of 'vehicle1_c1'.\n\t\t\t\t\t\t */\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\tpart rearAxleAssembly: RearAxleAssembly {\n\t\t\t\tbind shaftPort_d = differential.shaftPort_d;\n\t\t\t\tpart differential: Differential {\n\t\t\t\t\tport shaftPort_d: ShaftPort_d {\n\t\t\t\t\t\t/*\n\t\t\t\t\t\t * If the part def has no ports, then they can be defined directly in\n\t\t\t\t\t\t * a usage of the part def.\n\t\t\t\t\t\t */\n\t\t\t\t\t}\n\t\t\t\t\tport leftDiffPort: DiffPort;\n\t\t\t\t\tport rightDiffPort: DiffPort;\n\t\t\t\t}\n\t\t\t\tinterface differential.leftDiffPort to rearAxle.leftHalfAxle.axleToDiffPort {\n\t\t\t\t\t/*\n\t\t\t\t\t * A connection can be to a port that is arbitrarily deeply nested, on either end. \n\t\t\t\t\t */\n\t\t\t\t}\n\t\t\t\tinterface differential.rightDiffPort to rearAxle.rightHalfAxle.axleToDiffPort;\n\t\t\t\tpart rearAxle: RearAxle {\n\t\t\t\t\tpart leftHalfAxle: HalfAxle;\n\t\t\t\t\tpart rightHalfAxle: HalfAxle;\n\t\t\t\t}\n\t\t\t\tconnect rearAxle.leftHalfAxle.axleToWheelPort to leftWheel.wheelToAxlePort;\n\t\t\t\tconnect rearAxle.rightHalfAxle.axleToWheelPort to rightWheel.wheelToAxlePort;\n\t\t\t\tpart rearWheel: Wheel[2] ordered;\n\t\t\t\t/* The two rear wheels of 'rearAxleAssembly' must be given\n\t\t\t\t * their own names in order to be referenced in connections.\n\t\t\t\t * \n\t\t\t\t * (\":>\" is a shorthand here for \"subsets\".)\n\t\t\t\t */\n\t\t\t\tpart leftWheel :> rearWheel = rearWheel#(1) {\n\t\t\t\t\tport wheelToAxlePort: WheelToAxlePort;\n\t\t\t\t\tport wheelToRoadPort: WheelToRoadPort;\n\t\t\t\t}\n\t\t\t\tpart rightWheel :> rearWheel = rearWheel#(2) {\n\t\t\t\t\tport wheelToAxlePort: WheelToAxlePort;\n\t\t\t\t\tport wheelToRoadPort: WheelToRoadPort;\n\t\t\t\t}\n\t\t\t}\n\t\t\tbind rearAxleAssembly.leftWheel.wheelToRoadPort = \n\t\t\t\t vehicleToRoadPort.leftWheelToRoadPort;\t \n\t\t\tbind rearAxleAssembly.rightWheel.wheelToRoadPort = \n\t\t\t\t vehicleToRoadPort.rightWheelToRoadPort;\n\t\t\tport vehicleToRoadPort redefines VehicleA::vehicleToRoadPort {\n\t\t\t\tport leftWheelToRoadPort :> wheelToRoadPort = wheelToRoadPort#(1);\n\t\t\t\tport rightWheelToRoadPort :> wheelToRoadPort = wheelToRoadPort#(2);\n\t\t\t}\n\t\t}\n\t}\n}",
    "domain": "Vehicle Traffic",
    "grammar": "Part",
    "diagram": "dataset/sysml/samples/102/design.png"
  },
  {
    "nl": "This system aims to achieve integrated management of multi-architecture systems, involving communication and collaboration among multiple subsystems and components. The system is decomposed into two main architectural breakdowns:\n\nIn the first decomposition, the system is divided into two subsystems: b11 and b12. Subsystem b11 contains components c1 and c2, where c1 and c2 are connected via signal ports, and the interface pe is bound to the pb port of c1. Subsystem b12 contains components c3 and c4, with the interface pf bound to the pd port of c3. Furthermore, communication between b11 and b12 is realized through interfaces pe and pf.\n\nIn the second decomposition, the system is assembled via two major modules, b21 and b22. Both b21 and b22 reuse the c-level components defined in a11 by referencing and sharing c1, c2, c3, and c4. This enables the reorganization of signal connections and reuse of ports between modules.\n\nOverall, the design objective of this system is to standardize the interface binding and signal connection among components. Through flexible composition and reuse mechanisms, the system enhances the flexibility and integration efficiency of the overall architecture, meeting the requirements for multi-level component interoperability in complex system architectures.",
    "design": "package 'Multi-ArchitectureSystemIntegration' {\n\tpart def A1;\n\tpart def B11 {\n\t\tport pe;\n\t}\n\tpart def B12 {\n\t\tport pf;\n\t}\n\tpart def B21 {\n\t\tport pg;\n\t}\n\tpart def B22 {\n\t\tport ph;\n\t}\n\tpart def C1 {\n\t\tport pa;\n\t\tport pb;\n\t}\t\n\tpart def C2 {\n\t\tport pc;\n\t}\n\tpart def C3 {\n\t\tport pd;\n\t}\n\tpart def C4;\n\tpart a11: A1 {\n\tdoc\n\t/*\n\t * Decomposition 1 - Subsystems b11, b12\n\t */\n\t\tpart b11: B11 {\n\t\t\tpart c1: C1;\t\t\t\n\t\t\tpart c2: C2;\t\n\t\t\tconnect c1.pa to c2.pc;\n\t\t\tport :>> pe = c1.pb {\n\t\t\t\tdoc\n\t\t\t\t/*\n\t\t\t\t * This combines the definition of a port with a binding\n\t\t\t\t * connector. (It is the same notation used to bind a\n\t\t\t\t * attribute to a attribute property or a reference to a reference\n\t\t\t\t * property.)\n\t\t\t\t */\n\t\t\t}\n\t\t}\n\t\tpart b12: B12 {\n\t\t\tpart c3: C3;\t\t\t\n\t\t\tpart c4: C4;\t\n\t\t\tport :>> pf = c3.pd;\n\t\t}\n\t\tconnect b11.pe to b12.pf;\n\t}\n\tpart a12: A1 {\n\t\tdoc\n\t\t/*\n\t\t * Decomposition 2 - Assemblies b21, b22\n\t\t */\n\t\tpart b21: B21 {\n\t\t\t/*\n\t\t\t * The c-level entities are already composite parts within\n\t\t\t * a11, so they cannot also be composite parts within a12.\n\t\t\t */ \n\t\t\tref c1: C1 = a11.b11.c1;\t\t\t\n\t\t\tref c3: C3 = a11.b12.c3;\n\t\t\tconnect c1.pb to c3.pd;\n\t\t\tport :>> pg = c1.pa;\n\t\t}\n\t\tpart b22: B22 {\n\t\t\tref c2: C2 = a11.b11.c2;\t\t\t\n\t\t\tref c4: C4 = a11.b12.c4;\t\n\t\t\tport :>> ph = c2.pc;\n\t\t}\n\t}\n}",
    "domain": "Systems Engineering",
    "grammar": "Part",
    "diagram": "dataset/sysml/samples/103/design.png"
  },
  {
    "nl": "This system is designed to implement the functional architecture of an automotive powertrain, including the input of fuel commands, engine start-stop control, and support for power transmission and distribution. Users can control the system’s power output through fuel commands. Once the engine is ignited and started, the system generates engine torque according to the fuel command. The torque is then sequentially amplified from the engine to the transmission, transmitted to the driveshaft, and finally distributed to the left and right wheels, thus enabling control of the vehicle’s driving force. Additionally, users can shut down the engine via a command, triggering the cessation of the system’s powertrain. During engine shutdown, generation and transmission of driving force will likewise be suspended, ensuring safe and intelligent operation of the system.",
    "design": "package 'VehiclePowertrainFunctionalArchitecture' {\n\tpublic import Definitions::*;\n\tpublic import Usages::*;\n\tpackage Definitions {\n\t\talias Torque for ISQ::TorqueValue {\n\t\t}\n\t\tattribute def FuelCmd;\n\t\tattribute def EngineStart;\n\t\tattribute def EngineOff;\n\t\taction def 'Generate Torque' { in fuelCmd: FuelCmd; out engineTorque: Torque; }\n\t\taction def 'Amplify Torque' { in engineTorque: Torque; out transmissionTorque: Torque; }\n\t\taction def 'Transfer Torque' { in transmissionTorque: Torque; out driveshaftTorque: Torque; }\n\t\taction def 'Distribute Torque' { in driveShaftTorque: Torque; out wheelTorque1: Torque; out wheelTorque2: Torque; }\n\t\taction def 'Provide Power' { in fuelCmd: FuelCmd; out wheelTorque1: Torque; out wheelTorque2: Torque; }\n\t}\n\tpackage Usages {\n\t\taction 'provide power': 'Provide Power'{\n\t\t\tin fuelCmd: FuelCmd;\n\t\t\tout wheelTorque1: Torque; \n\t\t\tout wheelTorque2: Torque;\n\t\t\tbind 'generate torque'.fuelCmd = fuelCmd {\n\t\t\t}\n\t\t\taction 'generate torque': 'Generate Torque' {\n\t\t\t}\n\t\t\t\n\t\t\tflow 'generate torque'.engineTorque \n\t\t\t    to 'amplify torque'.engineTorque {\n\t\t\t}\n\t\t\taction 'amplify torque': 'Amplify Torque';\n\t\t\tflow 'amplify torque'.transmissionTorque \n\t\t\t    to 'transfer torque'.transmissionTorque;\n\t\t\taction 'transfer torque': 'Transfer Torque';\n\t\t\tflow 'transfer torque'.driveshaftTorque \n\t\t\t    to 'distribute torque'.driveShaftTorque;\n\t\t\taction 'distribute torque': 'Distribute Torque';\n\t\t\tbind wheelTorque1 = 'distribute torque'.wheelTorque1;\n\t\t\tbind wheelTorque2 = 'distribute torque'.wheelTorque2;\n\t\t\tfirst start then continue {\n\t\t\t}\n\t\t\tmerge continue {\n\t\t\t}\n\t\t\tfirst continue then engineStarted;\n\t\t\taction engineStarted accept engineStart: EngineStart {\n\t\t\t}\t\t\t\n\t\t\tfirst engineStarted then engineStopped;\n\t\t\taction engineStopped accept engineOff: EngineOff;\t\n\t\t\tfirst engineStopped then continue;\n\t\t\tfirst engineStarted then 'generate torque';\n\t\t\tfirst engineStarted then 'amplify torque';\n\t\t\tfirst engineStarted then 'transfer torque';\n\t\t\tfirst engineStarted then 'distribute torque';\n\t\t\tfirst 'generate torque' then engineStopped;\n\t\t\tfirst 'amplify torque' then engineStopped;\t\t\n\t\t\tfirst 'transfer torque' then engineStopped;\t\t\n\t\t\tfirst 'distribute torque' then engineStopped;\t\t\n\t\t}\n\t}\n}",
    "domain": "Vehicle Traffic",
    "grammar": "Function-based Behavior",
    "diagram": "dataset/sysml/samples/104/design.png"
  },
  {
    "nl": "This system is designed to implement the control logic of an automotive powertrain. Its main functions are as follows: Upon receiving a fuel control command, the system sequentially starts the engine and generates torque according to the predetermined order. The generated torque is then successively amplified, transmitted, and distributed, delivering power stage by stage to the vehicle’s drive wheels to ensure normal driving. When a stall signal is detected, the relevant operational processes will be halted as required. The system supports engine start and shutdown control, as well as the entire power transmission process from fuel commands to actual wheel output torque, ensuring efficient and coordinated power delivery. It provides users with a reliable power response and handling experience.",
    "design": "package 'VehiclePowertrainControlLogic' {\n\tpublic import Definitions::*;\n\tpublic import Usages::*;\n\tpackage Definitions {\n\t\talias Torque for ISQ::TorqueValue;\n\t\tattribute def FuelCmd;\n\t\tattribute def EngineStart;\n\t\tattribute def EngineOff;\n\t\taction def 'Generate Torque' { in fuelCmd: FuelCmd; out engineTorque: Torque; }\n\t\taction def 'Amplify Torque' { in engineTorque: Torque; out transmissionTorque: Torque; }\n\t\taction def 'Transfer Torque' { in transmissionTorque: Torque; out driveshaftTorque: Torque; }\n\t\taction def 'Distribute Torque' { in driveShaftTorque: Torque; out wheelTorque1: Torque; out wheelTorque2: Torque; }\n\t\taction def 'Provide Power' { in fuelCmd: FuelCmd; out wheelTorque1: Torque; out wheelTorque2: Torque; }\n\t}\n\tpackage Usages {\n\t\taction 'provide power': 'Provide Power'{\n\t\t\tin fuelCmd: FuelCmd;\n\t\t\tout wheelTorque1: Torque; \n\t\t\tout wheelTorque2: Torque;\n\t\t\taction 'generate torque': 'Generate Torque'{\n\t\t\t\tin fuelCmd = 'provide power'::fuelCmd;\n\t\t\t}\n\t\t\tflow 'generate torque'.engineTorque \n\t\t\t    to 'amplify torque'.engineTorque;\n\t\t\taction 'amplify torque': 'Amplify Torque';\n\t\t\tflow 'amplify torque'.transmissionTorque \n\t\t\t    to 'transfer torque'.transmissionTorque;\n\t\t\taction 'transfer torque': 'Transfer Torque';\n\t\t\tflow 'transfer torque'.driveshaftTorque \n\t\t\t    to 'distribute torque'.driveShaftTorque;\n\t\t\taction 'distribute torque': 'Distribute Torque';\n\t\t\tfirst start;\n\t\t\tthen merge continue;\t\n\t\t\tthen action engineStarted accept engineStart: EngineStart;\t\t\t\n\t\t\tthen action engineStopped accept engineOff: EngineOff;\t\n\t\t\tthen continue;\n\t\t\tfirst engineStarted then 'generate torque';\n\t\t\tfirst engineStarted then 'amplify torque';\n\t\t\tfirst engineStarted then 'transfer torque';\n\t\t\tfirst engineStarted then 'distribute torque';\n\t\t\tfirst 'generate torque' then engineStopped;\t\t\n\t\t\tfirst 'amplify torque' then engineStopped;\t\t\n\t\t\tfirst 'transfer torque' then engineStopped;\t\t\n\t\t\tfirst 'distribute torque' then engineStopped;\t\t\n\t\t}\n\t}\n}",
    "domain": "Vehicle Traffic",
    "grammar": "Function-based Behavior",
    "diagram": "dataset/sysml/samples/105/design.png"
  },
  {
    "nl": "This system can achieve integrated management of the vehicle powertrain system according to the driver's fuel input command. When the engine start signal is activated, the system first generates the corresponding engine output torque based on the fuel command, then amplifies and transmits the torque sequentially through the transmission, and subsequently distributes the torque to each wheel, thereby achieving effective management and distribution of the vehicle's output power. When the engine shutdown signal is triggered, the relevant power output process is terminated. This entire process ensures that the vehicle performs automatic control accurately and efficiently in terms of power demand response, torque transmission, and power distribution, thereby enhancing the driving experience and improving energy efficiency.",
    "design": "package 'VehiclePowertrainOperationalModeManagement' {\n\tpublic import Definitions::*;\n\tpublic import Usages::*;\n\tpackage Definitions {\n\t\talias Torque for ISQ::TorqueValue;\n\t\tattribute def FuelCmd;\n\t\tattribute def EngineStart;\n\t\tattribute def EngineOff;\n\t\taction def 'Generate Torque' { in fuelCmd: FuelCmd; out engineTorque: Torque; }\n\t\taction def 'Amplify Torque' { in engineTorque: Torque; out transmissionTorque: Torque; }\n\t\taction def 'Transfer Torque' { in transmissionTorque: Torque; out driveshaftTorque: Torque; }\n\t\taction def 'Distribute Torque' { in driveShaftTorque: Torque; out wheelTorque1: Torque; out wheelTorque2: Torque; }\n\t\taction def 'Provide Power' { in fuelCmd: FuelCmd; out wheelTorque1: Torque; out wheelTorque2: Torque; }\n\t}\n\tpackage Usages {\n\t\taction 'provide power': 'Provide Power' {\n\t\t\tin fuelCmd: FuelCmd; \n\t\t\tout wheelTorque1: Torque; \n\t\t\tout wheelTorque2: Torque;\n\t\t\tloop {\n\t\t\t\taccept engineStart : EngineStart;\n\t\t\t\tthen action {\n\t\t\t\t\taction 'generate torque': 'Generate Torque' {\n\t\t\t\t\t\tin fuelCmd = 'provide power'::fuelCmd;\n\t\t\t\t\t\tout engineTorque: Torque;\n\t\t\t\t\t}\n\t\t\t\t\tflow 'generate torque'.engineTorque \n\t\t\t\t\t    to 'amplify torque'.engineTorque;\n\t\t\t\t\taction 'amplify torque': 'Amplify Torque' {\n\t\t\t\t\t\tin engineTorque: Torque;\n\t\t\t\t\t\tout transmissionTorque: Torque;\n\t\t\t\t\t}\n\t\t\t\t\tflow 'amplify torque'.transmissionTorque \n\t\t\t\t\t    to 'transfer torque'.transmissionTorque;\n\t\t\t\t\taction 'transfer torque': 'Transfer Torque' {\n\t\t\t\t\t\tin transmissionTorque: Torque; \n\t\t\t\t\t\tout driveshaftTorque: Torque;\n\t\t\t\t\t}\n\t\t\t\t\tflow 'transfer torque'.driveshaftTorque \n\t\t\t\t\t    to 'distribute torque'.driveshaftTorque;\n\t\t\t\t\taction 'distribute torque': 'Distribute Torque' {\n\t\t\t\t\t\tin driveshaftTorque: Torque;\n\t\t\t\t\t\tout wheelTorque1: Torque;\n\t\t\t\t\t\tout wheelTorque2: Torque;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tthen action accept engineOff : EngineOff;\n\t\t\t}\t\n\t\t}\n\t}\n}",
    "domain": "Vehicle Traffic",
    "grammar": "Function-based Behavior",
    "diagram": "dataset/sysml/samples/106/design.png"
  },
  {
    "nl": "This system is designed to implement a power connection and disconnection mechanism between a vehicle and a trailer. The vehicle and the trailer each possess independent structural frames; a hitch ball is installed on the vehicle frame, while a trailer coupler is installed on the trailer frame. The system enables the vehicle and the trailer to be “connected” or “disconnected” via the hitching mechanism, and allows users to safely and reliably connect the trailer to the vehicle when needed, or disengage it. This achieves a flexible combination and separation, meeting user requirements for vehicle and trailer power coupling functions in various scenarios.",
    "design": "package 'VehicleTrailerDynamicCouplingSystem' {\n\tpart def Vehicle;\n\tpart def VehicleFrame;\n\tpart def HitchBall;\n\tpart def TrailerCoupler;\n\tpart def Trailer;\n\tpart def TrailerFrame;\n\tconnection def TrailerHitch {\n\t\tend hitch : HitchBall;\n\t\tend coupler : TrailerCoupler;\n\t}\n\tpart 'vehicle-trailer system' {\n\t\tpart vehicle : Vehicle {\n\t\t\tpart vehicleFrame : VehicleFrame {\n\t\t\t\tpart hitch : HitchBall;\n\t\t\t}\n\t\t}\n\t\tconnection trailerHitch : TrailerHitch[0..1]\n\t\t\tconnect vehicle.vehicleFrame.hitch to trailer.trailerFrame.coupler;\n\t\tpart trailer : Trailer {\n\t\t\tpart trailerFrame : TrailerFrame {\n\t\t\t\tpart coupler : TrailerCoupler;\n\t\t\t}\n\t\t}\n\t\taction {\n\t\t\taction 'connect trailer to vehicle'\n\t\t\t\tassign 'vehicle-trailer system'.trailerHitch := TrailerHitch();\n\t\t\tthen action 'destroy connection of trailer to vehicle' : \n\t\t\t\tOccurrenceFunctions::destroy {\n\t\t\t\tinout occ = 'vehicle-trailer system'.trailerHitch;\n\t\t\t}\n\t\t\tthen action 'disconnect trailer from vehicle'\n\t\t\t\tassign 'vehicle-trailer system'.trailerHitch := null;\n\t\t}\t\n\t}\t\n}",
    "domain": "Vehicle Traffic",
    "grammar": "Function-based Behavior",
    "diagram": "dataset/sysml/samples/107/design.png"
  },
  {
    "nl": "This system is designed to manage the connection status between a vehicle and a trailer. The system includes one vehicle and one trailer. The vehicle is equipped with a chassis and a tow ball, while the trailer features a coupler and a trailer frame. The system enables the vehicle to connect to or disconnect from the trailer by means of the tow ball on the vehicle’s chassis and the coupler on the trailer’s frame, thus facilitating the hitching and unhitching operations between the trailer and the vehicle. Users can conveniently connect or disconnect the trailer via the system, ensuring that the trailer can be safely and reliably coupled to the vehicle when needed, and can be smoothly detached when not required, thereby enhancing the convenience and safety of vehicle-trailer combinations.",
    "design": "package 'VehicleTrailerConnectionStateManagement' {\n\tpart def Vehicle;\n\tpart def VehicleFrame;\n\tpart def HitchBall;\n\tpart def TrailerCoupler;\n\tpart def Trailer;\n\tpart def TrailerFrame;\n\tconnection def TrailerHitch {\n\t\tend hitch : HitchBall;\n\t\tend coupler : TrailerCoupler;\n\t}\n\tpart 'vehicle-trailer system' {\t\n\t\tpart vehicle : Vehicle {\n\t\t\tpart vehicleFrame : VehicleFrame {\n\t\t\t\tpart hitch : HitchBall;\n\t\t\t}\n\t\t}\n\t\tconnection trailerHitch : TrailerHitch[0..1]\n\t\t\tconnect vehicle.vehicleFrame.hitch to trailer.trailerFrame.coupler;\n\t\tpart trailer : Trailer {\n\t\t\tpart trailerFrame : TrailerFrame {\n\t\t\t\tpart coupler : TrailerCoupler;\n\t\t\t}\n\t\t}\n\t\tperform action {\n\t\t\taction 'connect trailer to vehicle' {\n\t\t\t\tabstract ref :>> trailerHitch[1];\n\t\t\t}\n\t\t\tthen action 'disconnect trailer from vehicle' {\n\t\t\t\tabstract ref :>> trailerHitch[0];\t\t\n\t\t\t}\n\t\t}\n\t}\n}",
    "domain": "Vehicle Traffic",
    "grammar": "Function-based Behavior",
    "diagram": "dataset/sysml/samples/108/design.png"
  },
  {
    "nl": "This system is designed to implement a dynamic connection reference model between a vehicle and a towed trailer. The vehicle section comprises a chassis equipped with a tow ball device; the trailer section includes a trailer chassis and a coupler mechanism. The coupler mechanism is able to engage or disengage with the tow ball through its internal structure. Users should be able to connect and disconnect the trailer to and from the vehicle (i.e., hitching and unhitching operations). When connected, the trailer’s coupler should securely latch onto the vehicle’s tow ball, while disconnection should allow the two to separate smoothly, thereby achieving safe and convenient trailer attachment and detachment functionality.",
    "design": "package 'DynamicTrailerCouplingReferenceModel' {\n\tpart def Vehicle;\n\tpart def VehicleFrame;\n\tpart def HitchBall;\n\tpart def Trailer;\n\tpart def TrailerFrame;\n\tpart def TrailerCoupler;\n\tpart vehicle : Vehicle {\n\t\tpart vehicleFrame : VehicleFrame {\n\t\t\tpart hitch : HitchBall;\n\t\t}\n\t}\n\tpart trailer : Trailer {\n\t\tpart trailerFrame : TrailerFrame {\n\t\t\tpart coupler : TrailerCoupler {\n\t\t\t\tref part hitch : HitchBall;\n\t\t\t}\n\t\t}\t\t\n\t}\t\t\n\taction {\n\t\taction 'connect trailer to vehicle'\n\t\t\tassign trailer.trailerFrame.coupler.hitch := vehicle.vehicleFrame.hitch;\n\t\tthen action 'disconnect trailer from vehicle'\n\t\t\tassign trailer.trailerFrame.coupler.hitch := null;\n\t}\n}",
    "domain": "Vehicle Traffic",
    "grammar": "Function-based Behavior",
    "diagram": "dataset/sysml/samples/109/design.png"
  },
  {
    "nl": "This system is designed to describe the fuel system of motor vehicles, including the fuel supply and return process between the fuel tank assembly and the engine. As the fuel supply port, the fuel tank is capable of providing fuel to the engine, while the engine can also return a portion of the fuel to the fuel tank, ensuring the circulation and utilization of fuel. During the fuel flow process, the system can monitor key parameters such as temperature to ensure the safety and efficiency of fuel supply. The entire fuel system is designed to support interface connections between different components, ensuring smooth and well-integrated fuel supply routes, and meeting the requirements for stability and reliability of fuel supply during vehicle operation.",
    "design": "package 'VehicleFuelSystem' {\n\tattribute def Temp;\n\tpart def Fuel;\n\tport def FuelOutPort {\n\t\tattribute temperature : Temp;\n\t\tout item fuelSupply : Fuel;\n\t\tin item fuelReturn : Fuel;\n\t}\n\tport def FuelInPort {\n\t\tattribute temperature : Temp;\n\t\tin item fuelSupply : Fuel;\n\t\tout item fuelReturn : Fuel;\n\t}\n\tpart def FuelTankAssembly {\n\t\tport fuelTankPort : FuelOutPort;\n\t}\n\tpart def Engine {\n\t\tport engineFuelPort : FuelInPort;\n\t}\n\tpart def Vehicle;\n\tinterface def FuelInterface {\n\t\tend supplierPort : FuelOutPort;\n\t\tend consumerPort : FuelInPort;\n\t}\n\tpart vehicle : Vehicle {\t\n\t\tpart tankAssy : FuelTankAssembly;\t\t\n\t\tpart eng : Engine;\n\t\tinterface : FuelInterface connect \n\t\t\tsupplierPort ::> tankAssy.fuelTankPort to \n\t\t\tconsumerPort ::> eng.engineFuelPort;\n\t} \n}",
    "domain": "Vehicle Traffic",
    "grammar": "Interface",
    "diagram": "dataset/sysml/samples/11/design.png"
  },
  {
    "nl": "This system is designed to provide vehicles with efficient fuel delivery services. The system includes a storage tank as the initial fuel reservoir, from which fuel is extracted and delivered to vehicles via a fuel pump. Inside the vehicle, there is a fuel tank used to receive and store the delivered fuel, as well as to monitor both the maximum capacity and the current fuel level in real-time. The flow path of the fuel is clear and controllable: it is output from the storage tank, passes through the fuel pump, and ultimately enters the vehicle’s fuel tank, thus realizing end-to-end fuel management—from storage, to delivery, to usage. The system focuses on the transfer and quantity changes of fuel at each stage, ensuring that vehicles can obtain the required fuel in a timely, safe, and accurate manner to meet normal operation needs.",
    "design": "package 'VehicleFuelDeliverySystem' {\n\tprivate import ScalarValues::Real;\n\tpublic import Definitions::*;\n\tpublic import Usages::*;\n\tpackage Definitions {\n\t\titem def Fuel;\n\t\tport def FuelPort {\n\t\t\tout item fuel: Fuel;\n\t\t}\n\t\tpart def Pump {\n\t\t\tport fuelInPort : ~FuelPort;\n\t\t\tport fuelOutPort : FuelPort;\n\t\t}\n\t\tpart def StorageTank {\n\t\t\tport fuelOutPort : FuelPort;\n\t\t}\n\t\tpart def FuelTank {\n\t\t\tport fuelInPort : ~FuelPort;\n\t\t}\n\t\tpart def Vehicle {\n\t\t\tport fuelInPort : ~FuelPort;\n\t\t}\n\t\taction def PumpFuel {\n\t\t\tin fuelIn : Fuel;\n\t\t\tout fuelOut : Fuel;\n\t\t}\n\t}\n\tpackage Usages {\t\n\t\tpart context {\n\t\t\tpart storageTank : StorageTank;\n\t\t\tflow of  fuel : Fuel\n\t\t\t\tfrom storageTank.fuelOutPort.fuel to pump.fuelInPort.fuel {\t\t\t\n\t\t\t}\n\t\t\tpart pump : Pump {\n\t\t\t\tperform action pumpFuel : PumpFuel {\n\t\t\t\t\tin fuelIn = fuelInPort.fuel;\n\t\t\t\t\tout fuelOut = fuelOutPort.fuel;\n\t\t\t\t}\n\t\t\t}\n\t\t\tflow of fuel : Fuel\n\t\t\t\tfrom pump.fuelOutPort.fuel to vehicle.fuelInPort.fuel;\n\t\t\tpart vehicle : Vehicle {\n\t\t\t\tflow fuelInPort.fuel to fuelTank.fuel {\t\t\t\t\n\t\t\t\t}\n\t\t\t\tpart fuelTank : FuelTank {\n\t\t\t\t\tattribute volumeMax : Real;\n\t\t\t\t\tattribute fuelLevel : Real = fuel.volume / volumeMax;\t\n\t\t\t\t\titem fuel : Fuel {\n\t\t\t\t\t\tattribute volume : Real;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n}",
    "domain": "Vehicle Traffic",
    "grammar": "Function-based Behavior",
    "diagram": "dataset/sysml/samples/110/design.png"
  },
  {
    "nl": "This system aims to implement a model of the automobile assembly process, requiring sequential completion of gearbox and engine assembly on the final assembly line. Specifically, the assembly process starts with a vehicle assembly without a gearbox and engine; first, the gearbox is installed onto the vehicle assembly to produce an assembly without an engine, and then the engine is installed onto the vehicle with the gearbox, ultimately forming a fully assembled vehicle. During this process, each assembly step must have clear inputs and outputs, and the fully assembled vehicle should have independent, functional gearbox and engine units, enabling further functionalities such as power delivery. This model focuses on reflecting the sequence of final assembly, the interrelation between assembled components, and the integrity of the complete vehicle after assembly, ensuring the assembly process is standardized, orderly, and efficient, thus meeting the practical requirements of automobile manufacturing and production.",
    "design": "package 'VehicleAssemblyProcessModeling' {\n\tpublic import Definitions::*;\n\tpackage Definitions {\n\t\titem def VehicleAssembly;\n\t\titem def AssembledVehicle :> VehicleAssembly;\n\t\tpart def Vehicle :> AssembledVehicle;\t\t\n\t\tpart def Transmission;\n\t\tpart def Engine;\t\t\n\t}\n\tpackage Usages {\t\n\t\tpart AssemblyLine {\n\t\t\tperform action 'assemble vehicle' {\n\t\t\t\taction 'assemble transmission into vehicle' {\n\t\t\t\t\tin item 'vehicle assy without transmission or engine' : VehicleAssembly;\t\t\t\t\t\n\t\t\t\t\tin item transmission : Transmission {\n\t\t\t\t\t}\n\t\t\t\t\tout item 'vehicle assy without engine' : VehicleAssembly = 'vehicle assy without transmission or engine' {\t\t\t\t\t\t\n\t\t\t\t\t\tpart transmission : Transmission = 'assemble transmission into vehicle'.transmission {\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tflow 'assemble transmission into vehicle'.'vehicle assy without engine' \n\t\t\t\t    to 'assemble engine into vehicle'.'vehicle assy without engine';\n\t\t\t\taction 'assemble engine into vehicle' {\n\t\t\t\t\tin item 'vehicle assy without engine' : VehicleAssembly {\n\t\t\t\t\t\tpart transmission : Transmission;\n\t\t\t\t\t}\n\t\t\t\t\tin item engine : Engine;\n\t\t\t\t\tout item assembledVehicle : AssembledVehicle = 'vehicle assy without engine' {\n\t\t\t\t\t\tpart engine : Engine = 'assemble engine into vehicle'.engine;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tbind 'assemble vehicle'.'assemble engine into vehicle'.assembledVehicle = vehicle;\n\t\t\tpart vehicle : Vehicle {\n\t\t\t\tpart transmission: Transmission;\n\t\t\t\tpart engine: Engine;\n\t\t\t\tperform action providePower;\n\t\t\t}\n\t\t}\n\t}\n}",
    "domain": "Vehicle Traffic",
    "grammar": "Function-based Behavior",
    "diagram": "dataset/sysml/samples/111/design.png"
  },
  {
    "nl": "This system is designed to manage and control the start-up, operation, health monitoring, and related automatic control logic of a vehicle (VehicleA). The vehicle should support multiple operating states, including Off, Starting, Running, and Health Management states. During the start-up process, the vehicle can only transition from the Off state to the Starting state when the brake pedal is pressed and a start signal is received; subsequently, it enters the Running state upon receiving a vehicle-on signal. Once switched to the Running state, the system will automatically perform self-checks, supply power to the vehicle, and automatically apply the parking brake when exiting this state. The system also features self-perception of health, being capable of real-time detection and output of the vehicle’s temperature; when the temperature exceeds a safety threshold, the system will switch the vehicle to a degraded mode and send an over-temperature signal to the controller. The system also supports Maintenance and Degraded states, and can return to the Normal state upon receipt of a restore-to-normal signal. Meanwhile, the vehicle controller has its own operation state management and can switch the vehicle’s main control states in response to start-up and shut-down signals. The design of this system emphasizes automated response, health monitoring, and safety control to ensure that the vehicle operates in a safe, controllable, and maintainable state.",
    "design": "package '5-State-based Behavior-1' {\n\tprivate import ScalarValues::*;\n\tprivate import ISQ::*;\n\tprivate import '3a-Function-based Behavior-1'::*;\n\tpackage Definitions {\n\t\tpart def VehicleA {\n\t\t\tperform action 'provide power': 'Provide Power';\n\t\t\texhibit state 'vehicle states': 'Vehicle States';\n\t\t}\n\t\tpart def VehicleController {\n\t\t\texhibit state 'controller states': 'Controller States';\n\t\t}\n\t\tstate def 'Vehicle States';\n\t\tstate def 'Controller States';\t\n\t\taction def 'Perform Self Test';\n\t\taction def 'Apply Parking Brake';\n\t\taction def 'Sense Temperature' { out temp: TemperatureValue; }\n\t\tattribute def 'Vehicle Start Signal';\n\t\tattribute def 'Vehicle On Signal';\n\t\tattribute def 'Vehicle Off Signal';\n\t\tattribute def 'Start Signal';\n\t\tattribute def 'Off Signal';\n\t\tattribute def 'Over Temp';\n\t\tattribute def 'Return to Normal';\n\t}\n\tpackage Usages {\n\t\tprivate import Definitions::*;\n\t\taction 'perform self test': 'Perform Self Test';\n\t\taction 'apply parking brake': 'Apply Parking Brake';\n\t\taction 'sense temperature': 'Sense Temperature';\n\t\tstate 'vehicle states': 'Vehicle States' parallel {\n\t\t\tref vehicle : VehicleA;\n\t\t\tstate 'operational states' {\t\t\t\n\t\t\t\tentry action initial {\n\t\t\t\t}\n\t\t\t\ttransition initial then off;\n\t\t\t\tstate off;\n\t\t\t\ttransition 'off-starting'\n\t\t\t\t\tfirst off\n\t\t\t\t\taccept 'Vehicle Start Signal' \n\t\t\t\t\tif vehicle1_c1.'brake pedal depressed'\n\t\t\t\t\tdo send 'Start Signal'() to vehicle1_c1.vehicleController\n\t\t\t\t\tthen starting {\t\t\t\t\t\n\t\t\t\t\t}\t\n\t\t\t\tstate starting;\n\t\t\t\ttransition 'starting-on'\n\t\t\t\t\tfirst starting\n\t\t\t\t\taccept 'Vehicle On Signal'\n\t\t\t\t\tthen on;\n\t\t\t\tstate on {\t\t\t\t\n\t\t\t\t\tentry 'perform self test';\n\t\t\t\t\tdo 'provide power';\n\t\t\t\t\texit 'apply parking brake';\n\t\t\t\t}\n\t\t\t\ttransition 'on-off'\n\t\t\t\t\tfirst on\n\t\t\t\t\taccept 'Vehicle Off Signal'\n\t\t\t\t\tthen off;\n\t\t\t}\n\t\t\tstate 'health states' {\t\t\t\n\t\t\t\tentry action initial;\n\t\t\t\tdo 'sense temperature' { out temp; \n\t\t\t\t}\n\t\t\t\ttransition initial then normal;\n\t\t\t\tstate normal;\n\t\t\t\ttransition 'normal-maintenance'\n\t\t\t\t\tfirst normal\n\t\t\t\t\taccept at vehicle1_c1.maintenanceTime\n\t\t\t\t\tthen maintenance;\n\t\t\t\ttransition 'normal-degraded'\n\t\t\t\t\tfirst normal\n\t\t\t\t\taccept when 'sense temperature'.temp > vehicle1_c1.Tmax\n\t\t\t\t\tdo send 'Over Temp'() to vehicle1_c1.vehicleController \n\t\t\t\t\tthen degraded;\n\t\t\t\tstate maintenance;\n\t\t\t\ttransition 'maintenance-normal'\n\t\t\t\t\tfirst maintenance\n\t\t\t\t\taccept 'Return to Normal'\n\t\t\t\t\tthen normal;\n\t\t\t\tstate degraded;\n\t\t\t\ttransition 'degraded-normal'\n\t\t\t\t\tfirst degraded\n\t\t\t\t\taccept 'Return to Normal'\n\t\t\t\t\tthen normal;\n\t\t\t}\n\t\t}\n\t\tstate 'controller states': 'Controller States' parallel {\n\t\t\tstate 'operational controller states' {\n\t\t\t\tentry action initial; \n\t\t\t\ttransition initial then off;\n\t\t\t\tstate off;\n\t\t\t\ttransition 'off-on'\n\t\t\t\t\tfirst off\n\t\t\t\t\taccept 'Start Signal'\n\t\t\t\t\tthen on;\n\t\t\t\tstate on;\n\t\t\t\ttransition 'on-off'\n\t\t\t\t\tfirst on\n\t\t\t\t\taccept 'Off Signal'\n\t\t\t\t\tthen off;\n\t\t\t}\n\t\t}\t\t\n\t\tpart vehicle1_c1: VehicleA {\n\t\t\tport fuelCmdPort {\n\t\t\t\tin fuelCmd: FuelCmd;\n\t\t\t}\n\t\t\tattribute 'brake pedal depressed': Boolean;\t\t\n\t\t\tattribute maintenanceTime: Time::DateTime;\n\t\t\tattribute Tmax: TemperatureValue;\n\t\t\tperform 'provide power' :>> VehicleA::'provide power' {\t\t\t\n\t\t\t\tin fuelCmd = fuelCmdPort.fuelCmd;\n\t\t\t}\n\t\t\texhibit 'vehicle states' :>> VehicleA::'vehicle states' {\n\t\t\t}\t\n\t\t\t//*\n\t\t\t// The above is semantically equivalent to:\n\t\t\tref state 'vehicle states' :> Usages::'vehicle states', exhibitedStates\n\t\t\t\t:>> VehicleA::'vehicle states';\t\t\n\t\t\t// For a composite state performance within the vehicle, replace the above with:\n\t\t\tstate 'vehicle states' :>> Usages::'vehicle states', VehicleA::'vehicle states';\n\t\t\t*/\n\t\t\tpart vehicleController: VehicleController {\n\t\t\t\texhibit 'controller states' :>> VehicleController::'controller states';\n\t\t\t}\t\t\t\n\t\t}\n\t}\n}",
    "domain": "Vehicle Traffic",
    "grammar": "State-based Behavior",
    "diagram": "dataset/sysml/samples/112/design.png"
  },
  {
    "nl": "This system is designed to enable automated modeling of vehicle behavior, primarily comprising two core components: the vehicle and the vehicle controller. The vehicle is capable of autonomously managing its operation and health status under different conditions. Normally, the vehicle only initiates the startup process from the shutdown state when both the brake pedal is pressed and a start signal is received; after meeting these requirements, it completes self-inspection and power supply procedures. The system can sense temperature in real time, and when overheating is detected, it automatically sends a warning signal to the vehicle controller, switches the vehicle status to degraded mode, and ensures safety. Health management also includes regular maintenance and fault recovery mechanisms to ensure timely maintenance and restoration from abnormal states to normal. The vehicle controller receives and processes various control and status signals from the vehicle, enabling automatic control operations such as starting and shutting down. The overall system supports configuration of attributes such as fuel, maintenance intervals, and temperature thresholds, thereby achieving intelligent, safe, and efficient management of vehicle operation processes.",
    "design": "package 'AutomotiveBehaviorModeling' {\n\tprivate import ScalarValues::*;\n\tprivate import ISQ::*;\n\tpackage Definitions {\n\t\tpart def VehicleA {\n\t\t\tperform action 'provide power': 'Provide Power';\n\t\t\texhibit state 'vehicle states': 'Vehicle States';\n\t\t}\n\t\tpart def VehicleController {\n\t\t\texhibit state 'controller states': 'Controller States';\n\t\t}\n\t\tstate def 'Vehicle States';\n\t\tstate def 'Controller States';\t\n\t\taction def 'Provide Power';\n\t\taction def 'Perform Self Test';\n\t\taction def 'Apply Parking Brake';\n\t\taction def 'Sense Temperature' { out temp: TemperatureValue; }\n\t\tattribute def FuelCmd;\n\t\tattribute def 'Vehicle Start Signal';\n\t\tattribute def 'Vehicle On Signal';\n\t\tattribute def 'Vehicle Off Signal';\n\t\tattribute def 'Start Signal';\n\t\tattribute def 'Off Signal';\n\t\tattribute def 'Over Temp';\n\t\tattribute def 'Return to Normal';\n\t}\n\tpackage Usages {\n\t\tprivate import Definitions::*;\t\t \n\t\taction 'provide power': 'Provide Power';\n\t\taction 'perform self test': 'Perform Self Test';\n\t\taction 'apply parking brake': 'Apply Parking Brake';\n\t\taction 'sense temperature': 'Sense Temperature';\n\t\tstate 'vehicle states': 'Vehicle States' parallel {\n\t\t\tstate 'operational states' {\t\t\t\n\t\t\t\tentry action initial {\n\t\t\t\t}\n\t\t\t\ttransition initial then off;\n\t\t\t\tstate off;\n\t\t\t\ttransition 'off-starting'\n\t\t\t\t\tfirst off\n\t\t\t\t\taccept 'Vehicle Start Signal' \n\t\t\t\t\tif vehicle1_c1.'brake pedal depressed'\n\t\t\t\t\tdo send 'Start Signal'() to vehicle1_c1.vehicleController\n\t\t\t\t\tthen starting {\t\t\t\t\t\n\t\t\t\t}\n\t\t\t\tstate starting;\n\t\t\t\ttransition 'starting-on'\n\t\t\t\t\tfirst starting\n\t\t\t\t\taccept 'Vehicle On Signal'\n\t\t\t\t\tthen on;\n\t\t\t\tstate on {\t\t\t\t\n\t\t\t\t\tentry 'perform self test';\n\t\t\t\t\tdo 'provide power';\n\t\t\t\t\texit 'apply parking brake';\n\t\t\t\t}\n\t\t\t\ttransition 'on-off'\n\t\t\t\t\tfirst on\n\t\t\t\t\taccept 'Vehicle Off Signal'\n\t\t\t\t\tthen off;\n\t\t\t}\n\t\t\tstate 'health states' {\t\t\t\n\t\t\t\tentry action initial;\n\t\t\t\tdo 'sense temperature' { out temp; \n\t\t\t\t}\n\t\t\t\ttransition initial then normal;\n\t\t\t\tstate normal;\n\t\t\t\ttransition 'normal-maintenance'\n\t\t\t\t\tfirst normal\n\t\t\t\t\taccept at vehicle1_c1.maintenanceTime\n\t\t\t\t\tthen maintenance;\n\t\t\t\ttransition 'normal-degraded'\n\t\t\t\t\tfirst normal\n\t\t\t\t\taccept when 'sense temperature'.temp > vehicle1_c1.Tmax\n\t\t\t\t\tdo send 'Over Temp'() to vehicle1_c1.vehicleController \n\t\t\t\t\tthen degraded;\n\t\t\t\tstate maintenance;\n\t\t\t\ttransition 'maintenance-normal'\n\t\t\t\t\tfirst maintenance\n\t\t\t\t\taccept 'Return to Normal'\n\t\t\t\t\tthen normal;\n\t\t\t\tstate degraded;\n\t\t\t\ttransition 'degraded-normal'\n\t\t\t\t\tfirst degraded\n\t\t\t\t\taccept 'Return to Normal'\n\t\t\t\t\tthen normal;\n\t\t\t}\n\t\t}\n\t\tstate 'controller states': 'Controller States' parallel {\n\t\t\tstate 'operational controller states' {\n\t\t\t\tentry action initial; \t\t\n\t\t\t\ttransition initial then off;\n\t\t\t\tstate off;\n\t\t\t\ttransition 'off-on'\n\t\t\t\t\tfirst off\n\t\t\t\t\taccept 'Start Signal'\n\t\t\t\t\tthen on;\n\t\t\t\tstate on;\n\t\t\t\ttransition 'on-off'\n\t\t\t\t\tfirst on\n\t\t\t\t\taccept 'Off Signal'\n\t\t\t\t\tthen off;\n\t\t\t}\n\t\t}\t\t\n\t\tpart vehicle1_c1: VehicleA {\n\t\t\tport fuelCmdPort {\n\t\t\t\tin fuelCmd: FuelCmd;\n\t\t\t}\n\t\t\tattribute 'brake pedal depressed': Boolean;\t\t\n\t\t\tattribute maintenanceTime: Time::DateTime;\n\t\t\tattribute Tmax: TemperatureValue;\n\t\t\tperform 'provide power' :>> VehicleA::'provide power' {\t\t\t\n\t\t\t\tin fuelCmd = fuelCmdPort.fuelCmd;\n\t\t\t}\n\t\t\t\n\t\t\texhibit 'vehicle states' :>> VehicleA::'vehicle states' {\n\t\t\t}\n\t\t\t//*\n\t\t\t// The above is semantically equivalent to:\n\t\t\tref state 'vehicle states' :> Usages::'vehicle states', exhibitedStates\n\t\t\t\t:>> VehicleA::'vehicle states';\t\t\n\t\t\t// For a composite state performance within the vehicle, replace the above with:\n\t\t\tstate 'vehicle states' :>> Usages::'vehicle states', VehicleA::'vehicle states';\n\t\t\t*/\n\t\t\tpart vehicleController: VehicleController {\n\t\t\t\texhibit 'controller states' :>> VehicleController::'controller states';\n\t\t\t}\t\t\t\n\t\t}\n\t}\n}",
    "domain": "Vehicle Traffic",
    "grammar": "State-based Behavior",
    "diagram": "dataset/sysml/samples/113/design.png"
  },
  {
    "nl": "This system is designed for spatiotemporal simulation of the dynamic behavior of vehicles on roads at different moments. Users can define parameters such as the vehicle’s mass, position, velocity, and acceleration, and, combined with the road’s slope (angle) and surface friction coefficient, depict the state of the vehicle and the road at specific time points. The system supports snapshot recording at multiple moments within the simulation time series, enabling tracking of the vehicle’s state transitions from start-up (on state), through the driving process, to shutdown (off state). This provides detailed data to support vehicle dynamics analysis and road adaptability assessment, helping users predict vehicle performance under specific road and time conditions in a virtual environment.",
    "design": "package 'VehicleDynamicsTemporalSimulation' {\n\tprivate import ScalarValues::Real;\n\tprivate import Time::DateTime;\n\tprivate import ISQ::*;\n\tpackage 'Part Definitions' {\t\n\t\tpart def 'Temporal-Spatial Reference' {\n\t\t\tattribute referenceTime : DateTime;\n\t\t\tattribute referenceCoordinateSystem;\n\t\t}\n\t\tpart def VehicleRoadContext {\n\t\t\tattribute t : TimeValue;\n\t\t}\n\t\tpart def VehicleA {\n\t\t\tattribute mass : MassValue;\n\t\t\tattribute position : Real;\n\t\t\tattribute velocity : Real;\n\t\t\tattribute acceleration : Real;\n\t\t\texhibit state vehicleStates {\n\t\t\t\tentry; then on;\n\t\t\t\tstate on;\n\t\t\t\tthen off;\n\t\t\t\tstate off;\n\t\t\t}\n\t\t}\n\t\tpart def Road {\n\t\t\tattribute angle : Real;\n\t\t\tattribute surfaceFriction : Real;\n\t\t}\n\t}\n\tpackage 'Individual Definitions' {\n\t\tprivate import 'Part Definitions'::*;\n\t\tindividual def 'Temporal-Spatial Reference_ID1' :> 'Temporal-Spatial Reference';\n\t\tindividual def VehicleRoadContext_ID1 :> VehicleRoadContext;\n\t\tindividual def VehicleA_ID1 :> VehicleA;\n\t\tindividual def Road_ID1 :> Road;\n\t}\n\tpackage Values {\t\n\t\tattribute t0 : TimeValue;\n\t\tattribute t1 : TimeValue;\n\t\tattribute tn : TimeValue;\n\t\tattribute m : MassValue;\n\t\tattribute p0 : Real;\n\t\tattribute p1 : Real;\n\t\tattribute pn : Real;\n\t\tattribute v0 : Real;\n\t\tattribute v1 : Real;\n\t\tattribute vn : Real;\n\t\tattribute a0 : Real;\n\t\tattribute a1 : Real;\n\t\tattribute an : Real;\n\t\tattribute theta0 : Real;\n\t\tattribute theta1 : Real;\n\t\tattribute thetan : Real;\n\t\tattribute sf0 : Real;\n\t\tattribute sf1 : Real;\n\t\tattribute sfn : Real;\n\t}\n\tpackage 'Individuals and Snapshots' {\n\t\tprivate import 'Individual Definitions'::*;\n\t\tprivate import Values::*;\t\n\t\tindividual reference : 'Temporal-Spatial Reference_ID1' {\n\t\t\tsnapshot context_t0 : VehicleRoadContext_ID1 {\n\t\t\t\t:>> t = t0 {\n\t\t\t\t}\n\t\t\t\tsnapshot vehicle_ID1_t0 : VehicleA_ID1 {\n\t\t\t\t\t:>> mass = m;\n\t\t\t\t\t:>> position = p0;\n\t\t\t\t\t:>> velocity = v0;\n\t\t\t\t\t:>> acceleration = a0;\n\t\t\t\t\texhibit vehicleStates.on {\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tsnapshot road_ID1_t0 : Road_ID1 {\n\t\t\t\t\t:>> angle = theta0;\n\t\t\t\t\t:>> surfaceFriction = sf0;\n\t\t\t\t}\n\t\t\t}\n\t\t\tsnapshot context_t1 : VehicleRoadContext_ID1 {\n\t\t\t\t:>> t = t1;\t\n\t\t\t\tsnapshot vehicle_ID1_t1 : VehicleA_ID1 {\n\t\t\t\t\t:>> mass = m;\n\t\t\t\t\t:>> position = p1;\n\t\t\t\t\t:>> velocity = v1;\n\t\t\t\t\t:>> acceleration = a1;\n\t\t\t\t\texhibit vehicleStates.on;\n\t\t\t\t}\n\t\t\t\tsnapshot road_ID1_t1 : Road_ID1 {\n\t\t\t\t\t:>> angle = theta1;\n\t\t\t\t\t:>> surfaceFriction = sf1;\n\t\t\t\t}\n\t\t\t}\n\t\t\tsnapshot context_tn : VehicleRoadContext_ID1 {\n\t\t\t\t:>> t = tn;\n\t\t\t\tsnapshot vehicle_ID1_tn : VehicleA_ID1 {\n\t\t\t\t\t:>> mass = m;\n\t\t\t\t\t:>> position = pn;\n\t\t\t\t\t:>> velocity = vn;\n\t\t\t\t\t:>> acceleration = an;\n\t\t\t\t\texhibit vehicleStates.off;\n\t\t\t\t}\n\t\t\t\tsnapshot road_ID1_tn : Road_ID1 {\n\t\t\t\t\t:>> angle = theta1;\n\t\t\t\t\t:>> surfaceFriction = sfn;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n}",
    "domain": "Vehicle Traffic",
    "grammar": "Individual and Snapshot",
    "diagram": "dataset/sysml/samples/114/design.png"
  },
  {
    "nl": "This system is designed to provide multiple configuration management solutions for automotive products. The automobile, as the main system, can select different subsystem configurations according to various needs and conditions. The system mainly includes two configurable components: Subsystem A and Subsystem B. Subsystem A offers two configuration options: one consisting of Component 1 and Component 2, and the other consisting of Component 2 and Component 3. Similarly, Subsystem B also has two configuration options: one consisting of Component 4 and Component 5, and the other consisting of Component 5 and Component 6. When configuring a vehicle, users can choose different implementations of the above subsystems as needed, but must comply with the following constraint: if the second configuration of Subsystem A is selected, then Subsystem B must select the third configuration, or Subsystem A must not be the second configuration. In addition, the system comes with two predefined vehicle configurations, namely Configuration A and Configuration B. Configuration A adopts the first implementation of Subsystem A (Component 1 and Component 2) together with the third implementation of Subsystem B (Component 4 and Component 5). Configuration B adopts the second implementation of Subsystem A (Component 2 and Component 3) combined with the third implementation of Subsystem B (Component 4 and Component 5). This system model supports flexible product customization, meeting different user needs while ensuring the rationality and consistency among configurations.",
    "design": "package 'VehicleConfigurationVariantManagement' {\n\tpart def Vehicle;\n\tpart part1;\n\tpart part2;\n\tpart part3;\n\tpart part4;\n\tpart part5;\n\tpart part6;\n\tabstract part anyVehicleConfig : Vehicle {\n\t\tvariation part subsystemA {\n\t\t\tvariant part subsystem1 {\n\t\t\t\tpart :>> part1;\n\t\t\t\tpart :>> part2;\n\t\t\t}\n\t\t\tvariant part subsystem2 {\n\t\t\t\tpart :>> part2;\n\t\t\t\tpart :>> part3;\n\t\t\t}\n\t\t}\n\t\tvariation part subsystemB {\n\t\t\tvariant part subsystem3 {\n\t\t\t\tpart :>> part4;\n\t\t\t\tpart :>> part5;\n\t\t\t}\n\t\t\tvariant part subsystem4 {\n\t\t\t\tpart :>> part5;\n\t\t\t\tpart :>> part6;\n\t\t\t}\n\t\t}\n\t\tassert constraint {\n\t\t\tsubsystemA != subsystemA.subsystem2 | \n\t\t\tsubsystemB == subsystemB::subsystem3\n\t\t}\n\t}\n\tpart vehicleConfigA :> anyVehicleConfig {\t\t\n\t\tpart :>> subsystemA = subsystemA.subsystem1;\n\t\tpart :>> subsystemB = subsystemB::subsystem3;\n\t}\n\tpart VehicleConfigB :> anyVehicleConfig {\n\t\tpart :>> subsystemA = subsystemA.subsystem2;\n\t\tpart :>> subsystemB = subsystemB.subsystem3;\n\t}\n}",
    "domain": "Vehicle Traffic",
    "grammar": "Variant Configuration",
    "diagram": "dataset/sysml/samples/115/design.png"
  },
  {
    "nl": "This system is designed to provide configurable capabilities for a modular vehicle platform, supporting the flexible combination and variant selection of different subsystems and components. The system comprises multiple components and subsystems. Users can allocate various components—such as part1, part2, part3 (with port p1), part4, part5 (with port p2 and behavioral variants), and part6—to different subsystems and vehicle configurations according to their requirements. Through the abstract definitions of Subsystem A and Subsystem B, the system respectively supports different variants in terms of the quantity and types of internal components, and allows flexible interconnection between subsystem ports to ensure functional interoperability between Subsystem A and Subsystem B. Configuration schemes, such as VehicleConfigA and VehicleConfigB, support scenario-specific selection and implementation, enabling parameter, behavior, and structural customization at both the subsystem and component levels, while system-level constraints ensure the consistency and rationality of configurations. Ultimately, this system provides a flexible and scalable configuration foundation for the diverse needs of vehicle platforms, enabling end users and engineers to quickly generate vehicle system configurations that meet various functional requirements according to practical use cases.",
    "design": "package 'ModularVehiclePlatformConfiguration' {\n\taction doX;\n\taction doY;\n\tpart part1;\n\tpart part2;\n\tpart part3 {\n\t\tport p1;\n\t}\n\tpart part4;\n\tpart part5 {\n\t\tport p2;\n\t\tvariation perform action doXorY {\n\t\t\tvariant perform doX;\n\t\t\tvariant perform doY;\n\t\t}\n\t}\n\tpart part6;\n\tabstract part def SubsystemA {\n\t\tabstract part :>> part3[0..1];\n\t}\n\tabstract part def SubsystemB {\n\t\tabstract part :>> part5[1];\t\t\n\t}\n\tpart anyVehicleConfig {\t\n\t\tvariation part subsystemA : SubsystemA {\n\t\t\tvariant part subsystem1 : SubsystemA {\n\t\t\t\tpart :>> part1[1];\n\t\t\t\tpart :>> part2[1];\n\t\t\t}\n\t\t\tvariant part subsystem2 : SubsystemA {\n\t\t\t\tpart :>> part2[1];\n\t\t\t\tpart :>> part3[1];\n\t\t\t}\n\t\t}\n\t\tvariation part subsystemB : SubsystemB {\n\t\t\tvariant part subsystem3 : SubsystemB {\n\t\t\t\tpart :>> part4[1];\n\t\t\t\tpart :>> part5[1];\n\t\t\t}\n\t\t\tvariant part subsystem4 : SubsystemB {\n\t\t\t\tpart :>> part5[1];\n\t\t\t\tpart :>> part6[1];\n\t\t\t}\n\t\t}\n\t\tconnect subsystemA.part3.p1[0..1] to subsystemB.part5.p2[1];\n\t\tassert constraint {\n\t\t\tsubsystemA != subsystemA.subsystem2 | \n\t\t\tsubsystemB == subsystemB.subsystem3\n\t\t}\n\t}\n\tpart vehicleConfigA :> anyVehicleConfig {\t\t\n\t\tpart :>> subsystemA = subsystemA.subsystem1;\n\t\tpart :>> subsystemB = subsystemB.subsystem3 {\n\t\t\tpart :>> part5 {\n\t\t\t\tperform action :>> doXorY = doX;\n\t\t\t}\n\t\t}\n\t}\n\tpart VehicleConfigB :> anyVehicleConfig {\n\t\tpart :>> subsystemA = subsystemA.subsystem2;\n\t\tpart :>> subsystemB = subsystemB.subsystem4 {\n\t\t\tpart :>> part5 {\n\t\t\t\tperform action :>> doXorY = doY;\n\t\t\t}\n\t\t}\n\t}\n}",
    "domain": "Vehicle Traffic",
    "grammar": "Variant Configuration",
    "diagram": "dataset/sysml/samples/116/design.png"
  },
  {
    "nl": "This system is designed to provide flexible solutions for vehicle product line configuration, capable of automatically matching suitable combinations of engines, transmissions, and wheels based on different performance requirements and user preferences. For example, when high performance is required, the system will configure a 6-cylinder engine, automatic transmission, and wide-rim wheels, ensuring compatibility among these components. For standard performance requirements, a combination of a 4-cylinder engine, manual transmission, and narrow-rim wheels is offered. The system enforces a series of configuration constraints to ensure that each configuration scheme meets vehicle performance and component compatibility requirements, preventing unreasonable combinations. Ultimately, it enables customized vehicles tailored to individual user needs. Additionally, the system supports the selection of multiple vehicle model variants, allowing enterprises to quickly respond to market demands and achieve flexible expansion and management of their product lines.",
    "design": "package 'VehicleProductLineConfigurationSystem' {\n\tprivate import RequirementsModel::*;\n\tprivate import DesignModel::*;\n\tprivate import VariantDefinitions::*;\n\tprivate import ControlFunctions::forAll;\n\tpackage RequirementsModel {\n\t\trequirement def EnginePerformanceRequirement;\n\t\trequirement highPerformanceRequirement : EnginePerformanceRequirement;\n\t\trequirement normalPerformanceRequirement : EnginePerformanceRequirement;\n\t}\n\tpackage DesignModel {\n\t\tpart def Vehicle;\n\t\tpart def Engine;\n\t\tpart def Transmission;\n\t\tpart def Clutch;\n\t\tpart def Driveshaft;\n\t\tpart def RearAxleAssembly;\n\t\tpart def Wheel;\n\t\tport def FuelCmdPort;\n\t\tport def ClutchPort;\n\t\tport def ShaftPort_b;\n\t\tport def ShaftPort_c;\n\t\tport def ShaftPort_d;\n\t\tport def VehicleToRoadPort;\n\t\tport def WheelToRoadPort;\n\t\tpart vehicle : Vehicle {\n\t\t\tport fuelCmdPort;\n\t\t\tbind fuelCmdPort = engine.fuelCmdPort;\n\t\t\tpart engine : Engine[1] {\n\t\t\t\tport fuelCmdPort : FuelCmdPort;\n\t\t\t}\n\t\t\tpart transmission : Transmission[1] {\n\t\t\t\tpart clutch: Clutch[1] {\n\t\t\t\t\tport clutchPort : ClutchPort;\n\t\t\t\t}\n\t\t\t}\n\t\t\tpart driveshaft : Driveshaft[1] {\n\t\t\t\tport shaftPort_b : ShaftPort_b;\n\t\t\t\tport shaftPort_c : ShaftPort_c;\n\t\t\t}\n\t\t\tpart rearAxleAssembly : RearAxleAssembly {\n\t\t\t\tpart rearWheels : Wheel[2] {\n\t\t\t\t\tport wheelToRoadPort : WheelToRoadPort;\n\t\t\t\t}\n\t\t\t}\n\t\t\tport vehicleToRoadPort : VehicleToRoadPort {\n\t\t\t\tport wheelToRoadPort : WheelToRoadPort[2];\n\t\t\t}\n\t\t}\n\t}\n\tpackage VariantDefinitions {\n\t\tpart def '4CylEngine' :> Engine;\n\t\tpart def '6CylEngine' :> Engine;\n\t\tpart def ManualTransmission :> Transmission;\n\t\tpart def AutomaticTransmission :> Transmission;\n\t\tpart def ManualClutch :> Clutch;\n\t\tpart def AutomaticClutch :> Clutch;\n\t\tport def ManualClutchPort :> ClutchPort;\n\t\tport def AutomaticClutchPort :> ClutchPort;\n\t\tpart def NarrowRimWheel :> Wheel;\n\t\tpart def WideRimWheel :> Wheel;\t\t\n\t}\n\tpackage VariabilityModel {\n\t\tpart anyVehicleConfig :> vehicle {\n\t\t\tvariation requirement engineRqtChoice : EnginePerformanceRequirement {\n\t\t\t\tvariant highPerformanceRequirement;\n\t\t\t\tvariant normalPerformanceRequirement;\n\t\t\t}\n\t\t\tvariation part engineChoice :>> engine {\n\t\t\t\tvariant part '4cylEngine' : '4CylEngine';\n\t\t\t\tvariant part '6cylEngine' : '6CylEngine';\n\t\t\t}\n\t\t\tsatisfy engineRqtChoice by engineChoice;\n\t\t\tassert constraint 'engine choice constraint' {\n\t\t\t\tif engineRqtChoice == engineRqtChoice::highPerformanceRequirement? \n\t\t\t\t\tengineChoice == engineChoice::'6cylEngine' \n\t\t\t\telse\n\t\t\t\t\tengineChoice == engineChoice::'4cylEngine'\n\t\t\t}\n\t\t\tvariation part transmissionChoice :>> transmission {\n\t\t\t\tvariant part manualTransmission : ManualTransmission {\n\t\t\t\t\tpart :>> clutch : ManualClutch {\n\t\t\t\t\t\tport :>> clutchPort : ManualClutchPort;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tvariant part automaticTransmission : AutomaticTransmission {\n\t\t\t\t\tpart :>> clutch : AutomaticClutch {\n\t\t\t\t\t\tport :>> clutchPort : AutomaticClutchPort;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tassert constraint 'engine-transmission selection constraint' {\n\t\t\t\t(engineChoice == engineChoice::'4cylEngine' and transmissionChoice == transmissionChoice::manualTransmission) xor\n\t\t\t\t(engineChoice == engineChoice::'6cylEngine' and transmissionChoice == transmissionChoice::automaticTransmission)\n\t\t\t}\n\t\t\tpart :>> rearAxleAssembly {\n\t\t\t\tvariation part rearWheelChoice :>> rearWheels {\n\t\t\t\t\tvariant part narrowRimWheel : NarrowRimWheel;\n\t\t\t\t\tvariant part wideRimWheel : WideRimWheel;\n\t\t\t\t}\n\t\t\t}\n\t\t\tassert constraint 'engine-wheel selection constraint' {\n\t\t\t\t(engineChoice == engineChoice::'4cylEngine' and \n\t\t\t\t\trearAxleAssembly.rearWheelChoice->forAll {in ref w; w == rearAxleAssembly::rearWheelChoice::narrowRimWheel}) xor\n\t\t\t\t(engineChoice == engineChoice::'6cylEngine' and \n\t\t\t\t\trearAxleAssembly.rearWheelChoice->forAll {in ref w; w == rearAxleAssembly::rearWheelChoice::wideRimWheel})\n\t\t\t}\t\n\t\t}\n\t\tvariation part vehicleChoice :> anyVehicleConfig {\n\t\t\tvariant part vehicle_c1;\n\t\t\tvariant part vehicle_c2;\n\t\t}\t\n\t}\n}",
    "domain": "Vehicle Traffic",
    "grammar": "Variant Configuration",
    "diagram": "dataset/sysml/samples/117/design.png"
  },
  {
    "nl": "This system is intended to define and manage the primary specifications and performance requirements related to automobiles, covering aspects such as vehicle mass, fuel status, powertrain, and reliability. For example, the system must support the definition and management of vehicles with different mass grades (such as 2000 kg and 2500 kg). Each vehicle should reflect its actual mass and comply with the corresponding maximum mass limitations to prevent overloading. The system must also regulate fuel status, such as requiring some vehicles to meet mass requirements when fully fueled, while others are accepted in an empty-fuel state.  \n\nIn terms of the powertrain, vehicles must have power delivery functionality, requiring the engine to output torque and be effectively connected to the transmission via a drive interface to ensure reliable power transfer. For specific models, requirements also include tracking and fulfilling reliability, ensuring that vehicles possess specified performance and durability throughout their lifecycle.  \n\nThe entire system is structured to define vehicles, engines, transmissions, and their key interfaces, and decomposes, allocates, and validates each requirement. This supports standardized management and quality control of vehicles throughout the processes of design, testing, and practical application.",
    "design": "package 'AutomotiveSpecificationSystem' {\n\tprivate import ScalarValues::Real;\n\tprivate import ISQ::*;\n\tprivate import SI::*;\n\tpublic import 'Vehicle Usages'::*;\n\tpublic import 'Vehicle Requirements'::*;\n\tpackage 'Vehicle Definitions' {\n\t\tpart def Vehicle {\n\t\t\tattribute mass: MassValue;\n\t\t\tattribute fuelLevel: Real;\n\t\t\tattribute fuelTankCapacity: Real;\n\t\t}\n\t\tpart def Engine {\n\t\t\tport drivePwrPort: DrivePwrPort;\n\t\t\tperform action 'generate torque': 'Generate Torque';\n\t\t}\n\t\tpart def Transmission {\n\t\t\tport clutchPort: ClutchPort;\n\t\t}\n\t\tport def DrivePwrPort;\n\t\tport def ClutchPort;\n\t\tinterface def EngineToTransmissionInterface {\n\t\t\tend drivePwrPort: DrivePwrPort;\n\t\t\tend clutchPort: ClutchPort;\n\t\t}\n\t\taction def 'Generate Torque';\n\t}\n\tpackage 'Vehicle Usages' {\n\t\tpublic import 'Vehicle Definitions'::*;\n\t\taction 'provide power' {\n\t\t\taction 'generate torque' { /* ... */ }\n\t\t\t//...\n\t\t}\n\t\tpart vehicle1_c1: Vehicle {\n\t\t\tattribute :>> mass = 2000 [kg];\n\t\t\tperform 'provide power';\t\n\t\t\tpart engine_v1: Engine {\n\t\t\t\tport :>> drivePwrPort;\n\t\t\t\tperform 'provide power'.'generate torque' :>> 'generate torque';\n\t\t\t}\n\t\t\tpart transmission: Transmission {\n\t\t\t\tport :>> clutchPort;\n\t\t\t}\n\t\t\tinterface engineToTransmission: EngineToTransmissionInterface\n\t\t\t\tconnect engine_v1.drivePwrPort to transmission.clutchPort;\n\t\t}\n\t\tpart vehicle1_c2: Vehicle {\n\t\t\tattribute :>> mass = 2500 [kg];\n\t\t}\n\t}\n\tpackage 'Vehicle Requirements' {\t\n\t\tpublic import 'Vehicle Definitions'::*;\n\t\trequirement def <'1'> MassLimitationRequirement {\n\t\t\tattribute massActual: MassValue;\n\t\t\tattribute massReqd: MassValue;\n\t\t\trequire constraint {\n\t\t\t\t massActual <= massReqd \n\t\t\t }\n\t\t}\n\t\trequirement def <'2'> ReliabilityRequirement;\n\t\trequirement <'1.1'> vehicleMass1: MassLimitationRequirement {\n\t\t\tsubject vehicle : Vehicle {\n\t\t\t}\n\t\t\tattribute :>> massActual: MassValue = vehicle.mass {\n\t\t\t}\n\t\t\tattribute :>> massReqd = 2000 [kg] {\n\t\t\t}\n\t\t\tassume constraint fuelConstraint {\n\t\t\t\tvehicle.fuelLevel >= vehicle.fuelTankCapacity\n\t\t\t}\n\t\t}\n\t\trequirement <'2.1'> vehicleMass2: MassLimitationRequirement {\n\t\t\tsubject vehicle : Vehicle;\n\t\t\tattribute :>> massActual: MassValue = vehicle.mass;\n\t\t\tattribute :>> massReqd = 2500 [kg];\n\t\t\tassume constraint fuelConstraint {\n\t\t\t\tvehicle.fuelLevel == 0.0\n\t\t\t}\n\t\t}\n\t\trequirement <'2.2'> vehicleReliability2: ReliabilityRequirement {\n\t\t\tsubject vehicle : Vehicle;\n\t\t}\n\t\trequirement <'3.1'> drivePowerInterface {\n\t\t\tsubject drivePwrPort: DrivePwrPort;\n\t\t}\n\t\trequirement <'3.2'> torqueGeneration {\n\t\t\tsubject generateTorque: 'Generate Torque';\n\t\t}\n\t}\n\tpart 'vehicle1_c1 Specification Context' {\n\t\tprivate import 'vehicle1-c1 Specification'::*;\n\t\tprivate import 'engine-v1 Specification'::*;\n\t\trequirement 'vehicle1-c1 Specification' {\t\t\n\t\t\tsubject vehicle : Vehicle;\n\t\t\trequirement references vehicleMass1 {\t\t\t\n\t\t\t}\n\t\t}\n\t\trequirement 'engine-v1 Specification' {\n\t\t\tsubject engine : Engine;\n\t\t\trequire torqueGeneration {\n\t\t\t\tin :>> generateTorque = engine.'generate torque';\n\t\t\t}\n\t\t\trequire drivePowerInterface {\n\t\t\t\tin :>> drivePwrPort = engine.drivePwrPort; \n\t\t\t}\n\t\t}\n\t\tsatisfy 'vehicle1-c1 Specification' by vehicle1_c1 {\n\t\t}\n\t\tsatisfy 'engine-v1 Specification' by vehicle1_c1.engine_v1;\n\t}\n\tpart 'vehicle1_c2 Specification Context' {\n\t\tprivate import 'vehicle1-c2 Specification'::*;\n\t\trequirement 'vehicle1-c2 Specification' {\n\t\t\tsubject vehicle : Vehicle;\n\t\t\trequire vehicleMass2;\n\t\t\trequire vehicleReliability2;\n\t\t}\n\t\tsatisfy 'vehicle1-c2 Specification' by vehicle1_c2;\n\t}\n}",
    "domain": "Vehicle Traffic",
    "grammar": "Requirement",
    "diagram": "dataset/sysml/samples/118/design.png"
  },
  {
    "nl": "This system is designed to verify vehicle mass compliance to ensure that the actual mass of the tested vehicles does not exceed the specified maximum permissible mass. Specifically, each participating vehicle must have its actual mass measured using weighing equipment operated by a test operator. The system then compares the measured mass with the required value (e.g., a maximum permissible mass of 2,500 kilograms). If the vehicle's actual mass is less than or equal to the strictly defined upper limit, it is considered compliant; otherwise, it is deemed non-compliant. The system supports sequential testing and result determination for multiple vehicles, providing a reliable and automated solution for compliance management of vehicle-related product quality.",
    "design": "package 'VehicleMassComplianceVerification' {\n\tprivate import VerificationCases::*;\n\tprivate import Definitions::*;\n\tpackage Definitions {\n\t\trequirement def <'2'> MassRequirement {\n\t\t\tattribute massActual :> ISQ::mass;\n\t\t\tattribute massReqd :> ISQ::mass;\n\t\t\trequire constraint { massActual <= massReqd }\n\t\t}\n\t\tpart def Vehicle {\n\t\t\tattribute mass :> ISQ::mass;\n\t\t}\n\t\tpart def MassVerificationSystem;\n\t\tpart def Scale;\n\t\tpart def TestOperator;\n\t\tindividual def TestVehicle1 :> Vehicle;\n\t\tindividual def TestVehicle2 :> Vehicle;\n\t\tindividual def TestSystem :> MassVerificationSystem;\n\t\tverification def MassTest {\n\t\t\tobjective massVerificationObjective {\n\t\t\t\tverify requirement massRequirement : MassRequirement;\n\t\t\t}\n\t\t}\n\t}\n\tpackage Usages {\n\t\trequirement <'2.1'> vehicleMassRequirement : MassRequirement {\n\t\t\tsubject vehicle : Vehicle;\n\t\t\t:>> massActual = vehicle.mass;\t\t\n\t\t\t:>> massReqd = 2500 [SI::kg];\n\t\t}\n\t\tpart vehicle1_c2 : Vehicle {\n\t\t}\n\t\tverification vehicleMassTest : MassTest {\n\t\t\tsubject testVehicle : Vehicle;\n\t\t\tobjective vehicleMassVerificationObjective {\n\t\t\t\tverify vehicleMassRequirement :>> massRequirement;\n\t\t\t}\n\t\t\taction collectData {\n\t\t\t\tin part testVehicle : Vehicle = vehicleMassTest.testVehicle;\n\t\t\t\tout massMeasured :> ISQ::mass;\n\t\t\t}\n\t\t\taction processData {\n\t\t\t\tin massMeasured :> ISQ::mass = collectData.massMeasured;\n\t\t\t\tout massProcessed :> ISQ::mass;\n\t\t\t}\n\t\t\taction evaluateData {\n\t\t\t\tin massProcessed :> ISQ::mass = processData.massProcessed;\n\t\t\t\tout verdict : VerdictKind = \n\t\t\t\t\tPassIf(vehicleMassRequirement(vehicle = testVehicle(mass = massProcessed)));\n\t\t\t}\n\t\t\treturn verdict : VerdictKind = evaluateData.verdict;\n\t\t}\n\t\tpart massVerificationSystem : MassVerificationSystem {\n\t\t\tperform vehicleMassTest {\n\t\t\t\tin part :>> testVehicle = vehicleUnderTest;\n\t\t\t}\n\t\t\tref part vehicleUnderTest : Vehicle;\n\t\t\tpart testOperator : TestOperator;\n\t\t\tpart scale : Scale {\n\t\t\t\tperform vehicleMassTest.collectData {\n\t\t\t\t\tin part :>> testVehicle;\n\t\t\t\t\tmeasurement = testVehicle.mass;\n\t\t\t\t\tout :>> massMeasured = measurement;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tindividual testSystem : TestSystem :> massVerificationSystem {\n\t\t\ttimeslice test1 {\n\t\t\t\tref individual :>> vehicleUnderTest : TestVehicle1 :> vehicle1_c2 {\n\t\t\t\t\t:>> mass = 2500 [SI::kg];\n\t\t\t\t}\n\t\t\t}\n\t\t\tthen timeslice test2 {\n\t\t\t\tref individual :>> vehicleUnderTest : TestVehicle2 :> vehicle1_c2 {\n\t\t\t\t\t:>> mass = 2500 [SI::kg];\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n}",
    "domain": "Vehicle Traffic",
    "grammar": "Verification",
    "diagram": "dataset/sysml/samples/119/design.png"
  },
  {
    "nl": "This system is designed to implement a water supply network that delivers hot and cold water from a main supply pipe (SpigotBank) through corresponding interfaces (Spigot) to one or more faucets (Faucet). Each faucet is equipped with hot and cold water inlets (FaucetInlet). The system is required to reliably deliver hot and cold water from the respective outlets of the main supply pipe to the corresponding inlets of all downstream faucets, ensuring simultaneous supply to multiple water usage points. Additionally, the system must guarantee correct connection and smooth transmission of the hot and cold water pipelines, thereby meeting the basic requirements for distributed hot and cold water supply in various settings.",
    "design": "package 'WaterDelivery' {\n\tport def SpigotBank;\n\tport def Spigot;\n\tport def Faucet;\n\tport def FaucetInlet;\n\tinterface def WaterDelivery {\n\t\tend suppliedBy : SpigotBank[1] {\n\t\t\tport hot : Spigot;\n\t\t\tport cold : Spigot;\n\t\t}\n\t\tend deliveredTo : Faucet[1..*] {\n\t\t\tport hot : FaucetInlet;\n\t\t\tport cold : FaucetInlet;\n\t\t}\n\t\tconnect suppliedBy.hot to deliveredTo.hot;\n\t\tconnect suppliedBy.cold to deliveredTo.cold;\n\t}\n}",
    "domain": "Water resource transportation",
    "grammar": "Interface",
    "diagram": "dataset/sysml/samples/12/design.png"
  },
  {
    "nl": "This system is designed to model and analyze the quality attributes of vehicles, enabling effective management of both the entire vehicle and its key components (including the engine, transmission, front axle assembly, and rear axle assembly). Users can input quality data for each component, and the system will automatically aggregate and calculate the total mass of the vehicle, providing a data foundation for quality analysis. The system also supports the definition of quality analysis requirements and the formulation of analysis use cases. Based on set analysis objectives, it can automatically generate analysis tasks and plans, achieving comprehensive evaluation and requirements tracking for vehicle quality. Ultimately, the system provides scientific support for vehicle design and performance optimization, improving overall development efficiency and product performance.",
    "design": "package 'VehicleMassProperty' {\n\tprivate import ISQ::*;\n\tprivate import SI::*;\n\tprivate import NumericalFunctions::*;\n\tpackage VehicleDesignModel {\n\t\tpart def Vehicle {\n\t\t\tmass : MassValue;\n\t\t}\n\t\tpart vehicle {\n\t\t\t:>> mass : MassValue = sum((\n\t\t\t\tvehicle.engine.mass, \n\t\t\t\tvehicle.transmission.mass, \n\t\t\t\tvehicle.frontAxleAssembly.mass, \n\t\t\t\tvehicle.rearAxleAssembly.mass\n\t\t\t));\n\t\t\tpart engine {\n\t\t\t\tmass : MassValue;\n\t\t\t}\n\t\t\tpart transmission {\n\t\t\t    mass : MassValue;\n\t\t\t}\n\t\t\tpart frontAxleAssembly {\n\t\t\t\tmass : MassValue;\n\t\t\t}\n\t\t\tpart rearAxleAssembly {\n\t\t\t\tmass : MassValue;\n\t\t\t}\n\t\t}\n\t}\n\tpackage VehicleAnalysisModel {\n\t\tprivate import VehicleDesignModel::Vehicle;\n\t\trequirement def MassAnalysisObjective {\n\t\t\tsubject mass : MassValue;\n\t\t}\n\t\tanalysis def MassAnalysisCase {\n\t\t\tsubject vehicle : Vehicle;\n\t\t\tobjective : MassAnalysisObjective;\n\t\t\tvehicle.mass\n\t\t}\n\t\tanalysis def AnalysisPlan {\n\t\t\tsubject vehicle : Vehicle;\t\t\t\n\t\t\tobjective {\n\t\t\t}\n\t\t\tanalysis massAnalysisCase : MassAnalysisCase {\n\t\t\t \treturn mass; \n\t\t\t }\n\t\t}\n\t\tpart massAnalysisContext {\n\t\t\tanalysis analysisPlan : AnalysisPlan {\n\t\t\t\tsubject vehicle = VehicleDesignModel::vehicle;\n\t\t\t}\n\t\t}\n\t}\n}",
    "domain": "Vehicle Traffic",
    "grammar": "Analysis and Trade",
    "diagram": "dataset/sysml/samples/120/design.png"
  },
  {
    "nl": "This system aims to provide optimal solutions for vehicle powertrain configuration, focusing primarily on the trade-off analysis of engine types to select the engine configuration that performs best across multiple key performance indicators, including power, mass, efficiency, reliability, and cost. The system supports modeling of various engine structures (such as four-cylinder engines, six-cylinder engines, etc.), and is capable of automatically assembling related components, including cylinders, pistons, connecting rods, and crankshafts. A multi-attribute trade-off analysis method is used, and, through a pre-defined evaluation model, the system comprehensively assesses the performance data of different engine schemes. Based on the evaluation results, it automatically recommends the optimal engine solution, ensuring the best balance between vehicle performance and economy. At the same time, it allows users to view explanations on the rationality of the engine selection, ensuring decision transparency and traceability.",
    "design": "package 'EngineConfigurationTradeoff' {\n\tprivate import ScalarValues::Real;\n\tprivate import TradeStudies::*;\n\tprivate import Definitions::*;\n\tprivate import Usages::*;\n\tpackage Definitions {\n\t\tpart def Vehicle;\n\t\tpart def Engine {\n\t\t\tpower : ISQ::PowerValue;\n\t\t\tmass : ISQ::MassValue;\n\t\t\tefficiency : Real;\n\t\t\treliability : Real;\n\t\t\tcost : Real;\n\t\t}\n\t\tpart def Piston;\n\t\tpart def Cylinder;\n\t\tpart def ConnectingRod;\n\t\tpart def CrankShaft;\n\t\tpart def '4CylCrankShaft' :> CrankShaft;\n\t\tpart def '6CylCrankShaft' :> CrankShaft;\n\t}\n\tpackage Usages {\n\t\tpart engine : Engine {\n\t\t\tpart cyl[*] : Cylinder {\n\t\t\t\tpart p[1] : Piston;\n\t\t\t\tpart rod[1] : ConnectingRod;\n\t\t\t}\n\t\t\tpart cs : CrankShaft;\n\t\t}\n\t\tvariation part engineChoice :> engine {\n\t\t\tvariant part '4cylEngine' {\n\t\t\t\tpart :>> cyl[4];\n\t\t\t\tpart :>> cs : '4CylCrankShaft';\n\t\t\t}\n\t\t\tvariant part '6cylEngine' {\n\t\t\t\tpart :>> cyl[6];\n\t\t\t\tpart :>> cs : '6CylCrankShaft';\n\t\t\t}\n\t\t}\n\t\tpart vehicle : Vehicle {\n\t\t\tpart engine[1] :> engineChoice = engineChoice::'6cylEngine' {\n\t\t\t\tassert constraint engineSelectionRational { \n\t\t\t\t\tengine == Analysis::engineTradeStudy.selectedAlternative\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tpackage Analysis {\n\t\tcalc def EngineEvaluation {\n\t\t\tin power : ISQ::PowerValue;\n\t\t\tin mass : ISQ::MassValue; \n\t\t\tin efficiency : Real; \n\t\t\tin cost : Real;\n\t\t\treturn evaluation : Real;\n\t\t}\t\n\t\tanalysis engineTradeStudy : TradeStudy {\n\t\t\tsubject : Engine[1..*] = all engineChoice;\n\t\t\tobjective : MaximizeObjective;\n\t\t\tcalc :>> evaluationFunction {\n\t\t\t\tin part anEngine :>> alternative : Engine;\n\t\t\t\tcalc powerRollup { in engine = anEngine; return power:>ISQ::power; }\n\t\t\t\tcalc massRollup { in engine = anEngine; return mass:>ISQ::mass; }\n\t\t\t\tcalc efficiencyRollup { in engine = anEngine; return efficiency: Real; }\n\t\t\t\tcalc costRollup { in engine = anEngine; return cost: Real; }\n\t\t\t\treturn :>> result : Real = EngineEvaluation(\n\t\t\t\t\tpowerRollup.power, massRollup.mass, efficiencyRollup.efficiency, costRollup.cost\n\t\t\t\t);\n\t\t\t}\n\t\t\treturn part :>> selectedAlternative : Engine;\n\t\t}\n\t}\n}",
    "domain": "Vehicle Traffic",
    "grammar": "Analysis and Trade",
    "diagram": "dataset/sysml/samples/121/design.png"
  },
  {
    "nl": "This system is designed to ensure that vehicle fuel economy meets relevant regulatory and performance requirements. Under urban driving conditions, the vehicle’s range per gallon must not be less than 25 miles; under highway conditions, it must not be less than 30 miles. Fuel economy is measured in \"miles per gallon,\" based on the US customary gallon (231 cubic inches). Fuel economy tests are conducted with the vehicle assuming an additional load of 1,000 pounds, under standard urban and highway driving scenarios respectively. The measured fuel economy must meet the minimum requirements stated above. The system models and analyzes key parameters such as vehicle powertrain, load, and operating conditions, supporting fuel consumption assessment under various conditions to ensure that the designed vehicle can achieve the regulatory fuel economy targets for both urban and highway scenarios.",
    "design": "package 'VehicleFuelEfficiencyCompliance' {\n\tprivate import ScalarValues::*;\n\tprivate import Quantities::*;\n\tprivate import MeasurementReferences::*;\n\tprivate import ISQ::*;\n\tprivate import USCustomaryUnits::*;\n\tattribute distancePerVolume : ScalarQuantityValue = length / volume;\t\n\tattribute gallon : MeasurementUnit = 231.0 * 'in'^3;\n\tpackage FuelEconomyRequirementsModel {\n\t\trequirement def FuelEconomyRequirement {\n\t\t\tattribute actualFuelEconomy :> distancePerVolume;\n\t\t\tattribute requiredFuelEconomy :> distancePerVolume;\n\t\t\trequire constraint { actualFuelEconomy >= requiredFuelEconomy }\n\t\t}\n\t\trequirement cityFuelEconomyRequirement : FuelEconomyRequirement {\n\t\t\t:>> requiredFuelEconomy = 25 [mi/gallon];\n\t\t}\n\t\trequirement highwayFuelEconomyRequirement : FuelEconomyRequirement {\n\t\t\t:>> requiredFuelEconomy = 30 [mi/gallon];\n\t\t}\n\t}\n\tpackage VehicleDesignModel {\n\t\tpart def Vehicle {\n\t\t\tattribute fuelEconomy_city :> distancePerVolume;\n\t\t\tattribute fuelEconomy_highway :> distancePerVolume;\n\t\t\tattribute cargoWeight : MassValue;\n\t\t}\n\t\tpart def Engine;\n\t\tpart def Transmission;\n\t\tpart vehicle1_c1 : Vehicle {\n\t\t\tpart engine : Engine;\n\t\t\tpart transmission : Transmission {\n\t\t\t\texhibit state transmissionState {\n\t\t\t\t\tentry; then '1stGear';\n\t\t\t\t\tstate '1stGear';\n\t\t\t\t\tthen '2ndGear';\n\t\t\t\t\tstate '2ndGear';\n\t\t\t\t\tthen '3rdGear';\n\t\t\t\t\tstate '3rdGear';\n\t\t\t\t\tthen '4thGear';\n\t\t\t\t\tstate '4thGear';\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tpackage FuelEconomyAnalysisModel {\n\t\tprivate import VehicleDesignModel::*;\n\t\tprivate import FuelEconomyRequirementsModel::*;\n\t\tattribute def ScenarioState {\n\t\t\tposition : LengthValue;\n\t\t\tvelocity : SpeedValue;\n\t\t\tacceleration : AccelerationValue;\n\t\t\tinclineAngle : AngularMeasureValue;\n\t\t}\n\t\tabstract calc def NominalScenario { \n\t\t\tin t : TimeValue; \n\t\t\treturn : ScenarioState;\n\t\t}\n\t\tcalc cityScenario : NominalScenario;\n\t\tcalc highwayScenario : NominalScenario;\n\t\tanalysis def FuelEconomyAnalysis {\n\t\t\tsubject vehicle : Vehicle;\n\t\t\tin calc scenario : NominalScenario;\n\t\t\tin requirement fuelEconomyRequirement : FuelEconomyRequirement;\n\t\t\treturn calculatedFuelEconomy : ScalarQuantityValue;\n\t\t\tobjective fuelEconomyAnalysisObjective {\n\t\t\t\t assume constraint {\n\t\t\t\t }\n\t\t\t\t require fuelEconomyRequirement {\n\t\t\t\t \t:>> actualFuelEconomy = calculatedFuelEconomy;\n\t\t\t\t }\n\t\t\t}\n\t\t\taction dynamicsAnalysis {\n\t\t\t}\n\t\t\taction fuelConsumptionAnalysis {\n\t\t\t}\n\t\t}\n\t\trequirement vehicleFuelEconomyRequirementsGroup {\n\t\t\tsubject vehicle : Vehicle;\n\t\t\trequirement vehicleFuelEconomyRequirement_city :> cityFuelEconomyRequirement {\n\t\t\t\t:>> actualFuelEconomy = vehicle.fuelEconomy_city;\n\t\t\t\tassume constraint { vehicle.cargoWeight == 1000 [lb] }\n\t\t\t}\n\t\t\trequirement vehicleFuelEconomyRequirement_highway :> highwayFuelEconomyRequirement {\n\t\t\t\t:>> actualFuelEconomy = vehicle.fuelEconomy_highway;\n\t\t\t\tassume constraint { vehicle.cargoWeight == 1000 [lb] }\n\t\t\t}\n\t\t}\n\t\tpart analysisContext {\n\t\t\tanalysis cityFuelEconomyAnalysis : FuelEconomyAnalysis {\n\t\t\t\tsubject vehicle = vehicle1_c1;\n\t\t\t\tin calc scenario = cityScenario;\n\t\t\t\tin requirement fuelEconomyRequirement = cityFuelEconomyRequirement;\n\t\t\t} \n\t\t\tanalysis highwayFuelEconomyAnalysis : FuelEconomyAnalysis {\n\t\t\t\tsubject vehicle = vehicle1_c1;\n\t\t\t\tin calc scenario = highwayScenario;\n\t\t\t\tin requirement fuelEconomyRequirement = highwayFuelEconomyRequirement;\n\t\t\t}\n\t\t\tpart vehicle1_c1_analysized :> vehicle1_c1 {\n\t\t\t\t:>> fuelEconomy_city = cityFuelEconomyAnalysis.calculatedFuelEconomy;\n\t\t\t\t:>> fuelEconomy_highway = highwayFuelEconomyAnalysis.calculatedFuelEconomy;\n\t\t\t}\t\t\n\t\t\tsatisfy vehicleFuelEconomyRequirementsGroup by vehicle1_c1_analysized;\n\t\t}\n\t\t\n\t}\n}",
    "domain": "Vehicle Traffic",
    "grammar": "Analysis and Trade",
    "diagram": "dataset/sysml/samples/122/design.png"
  },
  {
    "nl": "This system is designed to simulate and analyze the longitudinal (straight-line) dynamic characteristics of vehicle motion. Users can input vehicle mass parameters, initial position, initial velocity, and a set of segmented power output data. Based on the input power and operating conditions, the system will successively calculate the vehicle’s acceleration, velocity, and position at each moment using dynamic equations with a specified time step. It will then output the sequences of acceleration, velocity variation, and displacement throughout the vehicle's entire motion process. This provides data support and a decision-making basis for applications such as vehicle performance analysis, control strategy development, and driving behavior evaluation.",
    "design": "package 'VehicleLongitudinalDynamicsSimulation' {\n\tprivate import ISQ::*;\n\tpackage VehicleModel {\n\t\tpart def Vehicle {\n\t\t\tattribute mass :> ISQ::mass;\n\t\t}\n\t}\n\tpackage DynamicsModel {\n\t    calc def Acceleration {\n\t    \tin p : PowerValue;\n\t    \tin m : MassValue;\n\t    \tin v : SpeedValue;\n\t    \treturn : AccelerationValue = p / (m * v);\n\t    }\n\t    calc def Velocity {\n\t    \tin v0 : SpeedValue; \n\t    \tin a : AccelerationValue; \n\t    \tin dt : TimeValue;\n\t    \treturn : SpeedValue = v0 + a * dt;\n\t    }\n\t    calc def Position {\n\t    \tin x0 : LengthValue;\n\t    \tin v : SpeedValue; \n\t    \tin dt : TimeValue;\n\t    \treturn : LengthValue = x0 + v * dt;\n\t    }\n\t    action def StraightLineDynamics {\n\t        in power : PowerValue;\n\t        in mass : MassValue;\n\t        in delta_t : TimeValue;\n\t        in x_in : LengthValue;\n\t        in v_in : SpeedValue;\n\t        out x_out : LengthValue = Position(x_in, v_in, delta_t);\n\t        out v_out : SpeedValue = Velocity(v_in, a_out, delta_t);\n\t        out a_out : AccelerationValue = Acceleration(power, mass, v_in);\n\t    }\n\t}\n\tpackage AnalysisModel {\n\t\tprivate import VehicleModel::*;\n\t\tprivate import DynamicsModel::*;\n\t\tprivate import SampledFunctions::*;\n\t\tprivate import ScalarValues::Natural;\n\t\tprivate import SequenceFunctions::*;\n\t\tanalysis def DynamicsAnalysis {\n\t\t\tsubject vehicle : Vehicle;\n\t\t\tin attribute powerProfile :> ISQ::power[*];\n\t\t\tin attribute initialPosition :> ISQ::length;\n\t\t\tin attribute initialSpeed :> ISQ::speed;\n\t\t\tin attribute deltaT :> ISQ::time;\n\t\t\treturn attribute accelerationProfile :> ISQ::acceleration[*] := ();\n\t\t\tprivate attribute position := initialPosition;\n\t\t\tprivate attribute speed := initialSpeed;\n\t\t\tfor i in 1..powerProfile->size()-1 {\n\t\t\t\tperform action dynamics : StraightLineDynamics {\n\t\t\t\t\tin power = powerProfile#(i);\n\t\t\t\t\tin mass = vehicle.mass;\n\t\t\t\t\tin delta_t = deltaT;\n\t\t\t\t\tin x_in = position;\n\t\t\t\t\tin v_in = speed;\n\t\t\t\t}\n\t\t\t\tthen assign position := dynamics.x_out;\n\t\t\t\tthen assign speed := dynamics.v_out;\n\t\t\t\tthen assign accelerationProfile := accelerationProfile->including(dynamics.a_out);\n\t\t\t}\n\t\t}\n\t}\n}",
    "domain": "Vehicle Traffic",
    "grammar": "Analysis and Trade",
    "diagram": "dataset/sysml/samples/123/design.png"
  },
  {
    "nl": "The vehicle system model describes a car with a total mass of 2,500 kg, whose structure comprises front and rear axle assemblies. The front axle assembly has a mass of 150 kg and consists of two front wheels and a front axle; the front axle is characterized by properties of mass and steering angle. The rear axle assembly has a mass of 250 kg and consists of two rear wheels and a rear axle; the rear axle is characterized by a mass property. The model aims to illustrate the structural relationships and mass distribution of the vehicle components, providing system engineers with a reference for vehicle structure breakdown and definition of component attributes. This facilitates overall mass allocation, component decomposition, as well as subsequent detailed modeling of functions and performance during the design and analysis process.",
    "design": "package 'VehicleArchitectureStructuralViewpoint' {\n\tpackage SystemModel {\n\t\tprivate import SI::*;\n\t\tpart def Vehicle;\n\t\tpart def AxleAssembly;\n\t\tpart def Axle;\n\t\tpart def Wheel;\n\t\tpart vehicle : Vehicle {\n\t\t\tattribute mass :> ISQ::mass = 2500[SI::kg];\n\t\t\tpart frontAxleAssembly : AxleAssembly[1] {\n\t\t\t\tattribute mass :> ISQ::mass = 150[kg];\n\t\t\t\tpart frontWheel : Wheel[2];\n\t\t\t\tpart frontAxle : Axle[1] {\n\t\t\t\t\tattribute mass;\n\t\t\t\t\tattribute steeringAngle;\n\t\t\t\t}\n\t\t\t}\n\t\t\tpart rearAxleAssembly : AxleAssembly[1] {\n\t\t\t\tattribute mass :> ISQ::mass = 250[kg];\n\t\t\t\tpart rearWheel : Wheel[2];\n\t\t\t\tpart rearAxle : Axle[1] {\n\t\t\t\t\tattribute mass;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tpackage ViewModel {\n\t\tprivate import Views::*;\n\t\tpart 'systems engineer';\n\t\tconcern 'system breakdown' {\n\t\t\tstakeholder :>> 'systems engineer';\n\t\t}\n\t\tviewpoint 'system structure perspective' {\t\t\n\t\t\tframe 'system breakdown';\n\t\t}\n\t\tview 'system structure generation' {\n\t\t\tsatisfy 'system structure perspective';\n\t\t\texpose SystemModel::vehicle::**[@SysML::PartUsage];\n\t\t\trender asElementTable {\n\t\t\t\tview :>> columnView[1] {\n\t\t\t\t\trender asTextualNotation;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n}",
    "domain": "Vehicle Traffic",
    "grammar": "View and Viewpoint",
    "diagram": "dataset/sysml/samples/124/design.png"
  },
  {
    "nl": "This system is designed to manage and display vehicle safety and security-related features and components, ensuring that users can intuitively understand the safety and security configurations of the entire vehicle and its constituent parts. The vehicle includes components such as seat belts, airbags, and alarm devices. Among these, seat belts and bumpers are mandatory safety features, while airbags and anti-lock braking systems are optional safety features. Additionally, the vehicle is equipped with security devices such as alarms and keyless entry systems. The system is capable of filtering and organizing all vehicle-related components based on safety or security features, and visualizing them in forms such as tree structures or tables. This enables end users to quickly review the safety configurations of the whole vehicle and its sub-systems, clearly distinguishing between mandatory and non-mandatory safety functions, thereby achieving comprehensive management and transparent display of the vehicle’s safety and security features.",
    "design": "private import Views::*; \npackage 'VehicleSafetyandSecurityFeatureManagement' {\n\tprivate import ScalarValues::*;\n\tpackage AnnotationDefinitions {\t\n\t\tmetadata def Safety {\n\t\t\tattribute isMandatory : Boolean;\n\t\t}\n\t\tmetadata def Security;\n\t}\n\tpackage PartsTree {\n\t\tpublic import AnnotationDefinitions::*;\n\t\tpart vehicle {\n\t\t\tpart interior {\n\t\t\t\tpart alarm {@Security;}\n\t\t\t\tpart seatBelt[2] {@Safety{isMandatory = true;}}\n\t\t\t\tpart frontSeat[2];\n\t\t\t\tpart driverAirBag {@Safety{isMandatory = false;}}\n\t\t\t}\n\t\t\tpart bodyAssy {\n\t\t\t\tpart body;\n\t\t\t\tpart bumper {@Safety{isMandatory = true;}}\n\t\t\t\tpart keylessEntry {@Security;}\n\t\t\t}\n\t\t\tpart wheelAssy {\n\t\t\t\tpart wheel[2];\n\t\t\t\tpart antilockBrakes[2] {@Safety{isMandatory = false;}}\n\t\t\t}\n\t\t}\n\t}\n\tpackage ViewDefinitions {\t\n\t\tpublic import AnnotationDefinitions::*;\n\t\tview def SafetyFeatureView {\n\t\t\t/* Parts that contribute to safety. */\t\t\n\t\t\tfilter @Safety;\n\t\t\trender asTreeDiagram;\n\t\t}\n\t\tview def SafetyOrSecurityFeatureView {\n\t\t\t/* Parts that contribute to safety OR security. */\t\t \n\t\t\tfilter @Safety | @Security;\n\t\t}\t\n\t}\n\tpackage Views {\n\t\tprivate import ViewDefinitions::*;\n\t\tprivate import PartsTree::vehicle;\n\t\tview vehicleSafetyFeatureView : SafetyFeatureView {\n\t\t\texpose vehicle::**;\n\t\t}\n\t\tview vehicleMandatorySafetyFeatureView :> vehicleSafetyFeatureView {\n\t\t\tfilter Safety::isMandatory;\n\t\t}\n\t\tview vehicleMandatorySafetyFeatureViewStandalone {\n\t\t\texpose vehicle::**[@Safety and Safety::isMandatory];\n\t\t\trender asElementTable;\n\t\t}\t\n\t}\n}",
    "domain": "Vehicle Traffic",
    "grammar": "View and Viewpoint",
    "diagram": "dataset/sysml/samples/125/design.png"
  },
  {
    "nl": "This system adopts a layered architecture, including the application layer, service layer, and data layer. The application layer needs to use the functionalities provided by the service layer, while the service layer relies on the data layer to retrieve and store data. The system should possess three core attributes: x, y, and z, where attribute z depends on attributes x and y. The entire system must ensure clear division of responsibilities and dependencies between layers, guaranteeing smooth data flow and functional calls.",
    "design": "package 'LayeredSystemDependency' {\n\tpackage 'Application Layer';\n\tpackage 'Service Layer';\n\tpackage 'Data Layer';\n\tdependency Use from 'Application Layer' to 'Service Layer';\n\tdependency from 'Service Layer' to 'Data Layer';\n\tattribute x;\n\tattribute y;\n\tattribute z;\n\tdependency z to x, y;\n}",
    "domain": "Information Management",
    "grammar": "Dependency",
    "diagram": "dataset/sysml/samples/126/design.png"
  },
  {
    "nl": "This system is designed to realize the torque generation function within the powertrain system. The system should include relevant components capable of generating torque, and it is required that the torque produced during operation must be greater than zero newton-meters to ensure driving capability. During the design and implementation process, the logic layer's torque generator function should be effectively allocated and mapped to the physical layer of the powertrain (including actual components such as the engine), thereby ensuring the actual generation and transmission of torque to meet the overall vehicle power output requirements.",
    "design": "package 'PowertrainFunctionComponentAllocation' {\n\tprivate import SI::*;\n\tprivate import RequirementModel::*;\n\tprivate import LogicalModel::*;\n\tprivate import PhysicalModel::*;\n\tpackage RequirementModel {\n\t\trequirement torqueGeneration {\n\t\t\tsubject generator: TorqueGenerator;\n\t\t\trequire constraint { \n\t\t\t\t generator.generateTorque.torque > 0.0 [N*m]\n\t\t\t}\n\t\t}\n\t}\n\tpackage LogicalModel {\n\t\taction def GenerateTorque { out torque :> ISQ::torque; }\n\t\tpart def LogicalElement;\n\t\tpart def TorqueGenerator :> LogicalElement {\n\t\t\tperform action generateTorque : GenerateTorque;\n\t\t}\t\n\t\taction providePower {\n\t\t\taction generateTorque : GenerateTorque;\n\t\t}\n\t\tpart torqueGenerator : TorqueGenerator {\n\t\t\tperform providePower.generateTorque :>> generateTorque;\n\t\t}\n\t\tsatisfy torqueGeneration by torqueGenerator;\t\t\t\n\t}\n\tpackage PhysicalModel {\n\t\tpart def PhysicalElement;\n\t\tpart def PowerTrain :> PhysicalElement;\n\t\tpart powerTrain : PowerTrain {\n\t\t\tpart engine {\n\t\t\t\tperform providePower.generateTorque;\n\t\t\t}\n\t\t}\n\t}\n\tallocation def LogicalToPhysical {\n\t\tend logical : LogicalElement;\n\t\tend physical : PhysicalElement;\n\t}\n\tallocation torqueGenAlloc : LogicalToPhysical \n\t\tallocate logical ::> torqueGenerator to physical ::> powerTrain {\n\t\tallocate torqueGenerator.generateTorque to powerTrain.engine.generateTorque;\t\t\n\t}\n}",
    "domain": "Vehicle Traffic",
    "grammar": "Dependency",
    "diagram": "dataset/sysml/samples/127/design.png"
  },
  {
    "nl": "The system must be capable of transmitting and outputting power, and logically should have the ability to provide power as well as generate torque. The system should include a torque generator component responsible for generating torque. At the physical level, the system must include a powertrain, which should contain an engine responsible for the actual execution of torque generation. The function of the system’s torque generator should be able to be mapped and implemented onto the engine within the powertrain, achieving effective correspondence and allocation between logical functions and physical implementation.",
    "design": "package 'PowertrainFunctiontoComponentMapping' {\n\tprivate import LogicalModel::*;\n\tprivate import PhysicalModel::*;\n\tpackage LogicalModel {\n\t\taction providePower {\n\t\t\taction generateTorque;\n\t\t}\n\t\tpart torqueGenerator {\n\t\t\tperform providePower.generateTorque;\n\t\t}\n\t}\n\tpackage PhysicalModel {\n\t\tpart powerTrain {\n\t\t\tpart engine {\n\t\t\t\tperform providePower.generateTorque;\n\t\t\t}\n\t\t}\n\t}\n\tallocate torqueGenerator to powerTrain {\n\t\tallocate torqueGenerator.generateTorque to powerTrain.engine.generateTorque;\n\t}\n}",
    "domain": "Vehicle Traffic",
    "grammar": "Dependency",
    "diagram": "dataset/sysml/samples/128/design.png"
  },
  {
    "nl": "This Vehicle Safety and Anti-theft Function Catalogue is intended to standardize the basic configuration requirements for key vehicle components in terms of safety and anti-theft performance. The vehicle must be equipped with the following safety and security features: At a minimum, basic safety components such as front seat belts and bumpers must be installed on the body and interior to ensure the fundamental personal safety of occupants. Certain components, such as the driver’s airbag and anti-lock braking system, are characterized as safety features but may or may not be mandatory depending on specific configurations. Meanwhile, the vehicle should also be equipped with security components such as an alarm system and a keyless entry system, so as to enhance the overall security and protective capability of the vehicle. The catalogue distinguishes and describes all components that affect safety, all components that affect anti-theft, components that affect both safety and anti-theft, as well as all mandatory safety components, in order to meet regulatory requirements and users’ needs for the most basic safety and protection functions of the vehicle.",
    "design": "package 'VehicleSafetyandSecurityFeatureCatalog' {\n\tprivate import ScalarValues::*;\n\tprivate import AnnotationDefinitions::*;\n\tprivate import PartsTree::*;\n\tpackage AnnotationDefinitions {\n\t\tmetadata def Safety {\n\t\t\tattribute isMandatory : Boolean;\n\t\t}\n\t\tmetadata def Security;\n\t}\n\tpackage PartsTree {\n\t\tpart vehicle {\n\t\t\tpart interior {\n\t\t\t\tpart alarm {@Security;}\n\t\t\t\tpart seatBelt[2] {@Safety{isMandatory = true;}}\n\t\t\t\tpart frontSeat[2];\n\t\t\t\tpart driverAirBag {@Safety{isMandatory = false;}}\n\t\t\t}\n\t\t\tpart bodyAssy {\n\t\t\t\tpart body;\n\t\t\t\tpart bumper {@Safety{isMandatory = true;}}\n\t\t\t\tpart keylessEntry {@Security;}\n\t\t\t}\n\t\t\tpart wheelAssy {\n\t\t\t\tpart wheel[2];\n\t\t\t\tpart antilockBrakes[2] {@Safety{isMandatory = false;}}\n\t\t\t}\n\t\t}\n\t}\n\tpackage 'Safety Features' {\n\t\t/* Parts that contribute to safety. */\t\t\n\t\tprivate import vehicle::**;\n\t\tfilter @Safety;\n\t}\n\tpackage 'Security Features' {\n\t\t/* Parts that contribute to security. */\t\t\n\t\tprivate import vehicle::**;\n\t\tfilter @Security;\n\t}\n\tpackage 'Safety & Security Features' {\n\t\t/* Parts that contribute to safety OR security. */\t\t \n\t\tprivate import vehicle::**;\n\t\tfilter @Safety or @Security;\n\t}\n\tpackage 'Mandatory Safety Features' {\n\t\t/* Parts that contribute to safety AND are mandatory. */\n\t\tprivate import vehicle::**;\n\t\tfilter @Safety and Safety::isMandatory;\n\t}\n}",
    "domain": "Vehicle Traffic",
    "grammar": "Model Constrainment",
    "diagram": "dataset/sysml/samples/129/design.png"
  },
  {
    "nl": "This system is designed to provide complete fuel supply and return management functions for vehicles. The vehicle is equipped with a fuel system composed of a fuel tank assembly, which integrates both the fuel pump and the fuel tank. The fuel pump is responsible for pressurizing fuel from the tank and delivering it to various fuel-consuming units within the vehicle, while allowing unused fuel to return to the tank via the return line. The system must monitor and transmit real-time fuel temperature information to ensure the safety and efficiency of fuel transport. The overall fuel flow path and interface definitions are clearly specified, and both data and fuel flow between components are strictly bound according to the design, thereby achieving reliable fuel supply and effective return management.",
    "design": "package 'VehicleFuelSystem' {\n\tpart def Vehicle;\n\tpart def FuelPump;\n\tpart def FuelTank;\n\tattribute def Temp;\n\tpart def Fuel;\n\tport def FuelOutPort {\n\t\tattribute temperature : Temp;\n\t\tout item fuelSupply : Fuel;\n\t\tin item fuelReturn : Fuel;\n\t}\n\tpart def FuelTankAssembly {\n\t\tport fuelTankPort : FuelOutPort;\n\t}\n\tpart vehicle : Vehicle {\t\n\t\tpart tank : FuelTankAssembly {\n\t\t\tport redefines fuelTankPort {\n\t\t\t\tout item redefines fuelSupply;\n\t\t\t\tin item redefines fuelReturn;\n\t\t\t}\n\t\t\tbind fuelTankPort.fuelSupply = pump.pumpOut;\n\t\t\tbind fuelTankPort.fuelReturn = tank.fuelIn;\n\t\t\tpart pump : FuelPump {\n\t\t\t\tout item pumpOut : Fuel;\n\t\t\t\tin item pumpIn : Fuel;\n\t\t\t}\n\t\t\tpart tank : FuelTank {\n\t\t\t\tout item fuelOut : Fuel;\n\t\t\t\tin item fuelIn : Fuel;\n\t\t\t}\n\t\t}\n\t} \n}",
    "domain": "Vehicle Traffic",
    "grammar": "Binding Connector",
    "diagram": "dataset/sysml/samples/13/design.png"
  },
  {
    "nl": "The system proposes the following requirements for the safety and security compliance configurations of a vehicle: The vehicle interior must be equipped with two seat belts, which are mandatory safety features. An airbag should also be installed in the cockpit, but its application is not mandatory. Additionally, an anti-theft alarm device should be installed inside the vehicle to enhance security protection. The vehicle body must be equipped with a bumper, which is a required safety component, and is also required to have a keyless entry system to improve security performance. The chassis structure is to be fitted with two wheels and equipped with two sets of anti-lock braking systems, although the installation of such braking systems is not mandatory. All the aforementioned components related to safety and security are subject to identification and classification management by the system to ensure compliance with regulations regarding critical safety and security functions, thereby enhancing the vehicle’s overall safety and security features.",
    "design": "package 'VehicleSafetyandSecurityComplianceCatalog' {\n\tprivate import ScalarValues::*;\n\tprivate import AnnotationDefinitions::*;\n\tprivate import PartsTree::*;\n\tpackage AnnotationDefinitions {\n\t\tmetadata def Safety {\n\t\t\tattribute isMandatory : Boolean;\n\t\t}\n\t\tmetadata def Security;\n\t}\n\tpackage PartsTree {\n\t\tpart vehicle {\n\t\t\tpart interior {\n\t\t\t\tpart alarm {@Security;}\n\t\t\t\tpart seatBelt[2] {@Safety{isMandatory = true;}}\n\t\t\t\tpart frontSeat[2];\n\t\t\t\tpart driverAirBag {@Safety{isMandatory = false;}}\n\t\t\t}\n\t\t\tpart bodyAssy {\n\t\t\t\tpart body;\n\t\t\t\tpart bumper {@Safety{isMandatory = true;}}\n\t\t\t\tpart keylessEntry {@Security;}\n\t\t\t}\n\t\t\tpart wheelAssy {\n\t\t\t\tpart wheel[2];\n\t\t\t\tpart antilockBrakes[2] {@Safety{isMandatory = false;}}\n\t\t\t}\n\t\t}\n\t}\n\tpackage 'Safety Features' {\t\n\t\tprivate import vehicle::**[@Safety];\n\t}\n\tpackage 'Security Features' {\t\t\n\t\tprivate import vehicle::**[@Security];\n\t}\n\tpackage 'Safety & Security Features' {\t\t \n\t\tprivate import vehicle::**[@Safety or @Security];\n\t}\n\tpackage 'Mandatory Saftey Features' {\n\t\tprivate import vehicle::**[@Safety and Safety::isMandatory];\n\t}\n}",
    "domain": "Vehicle Traffic",
    "grammar": "Model Constrainment",
    "diagram": "dataset/sysml/samples/130/design.png"
  },
  {
    "nl": "The vehicle safety and security component system mainly includes the vehicle’s interior and body assembly parts. The interior is equipped with an alarm system, seat belts, front row seats, and a driver’s airbag, while the body assembly comprises the vehicle body, bumper, and keyless entry system. The safety features are primarily reflected in the configuration of seat belts, airbags, and bumpers, which enhance the protection of the driver and passengers during driving. The security features are realized through the installation of an onboard alarm and a keyless entry system, providing support for anti-theft and convenient access for users. The system integrates safety and security functions, aiming to offer users comprehensive safety protection and a convenient user experience.",
    "design": "package 'VehicleSafetyandSecurityComponentRegistry' {\n\tpart vehicle1_c1 {\n\t\tpart interior {\n\t\t\tpart alarm;\n\t\t\tpart seatBelt[2];\n\t\t\tpart frontSeat[2];\n\t\t\tpart driverAirBag;\n\t\t}\n\t\tpart bodyAssy {\n\t\t\tpart body;\n\t\t\tpart bumper;\n\t\t\tpart keylessEntry;\n\t\t}\n\t}\n\tpackage 'Safety Features' {\n\t\tprivate import vehicle1_c1::interior::seatBelt;\n\t\tprivate import vehicle1_c1::interior::driverAirBag;\n\t\tprivate import vehicle1_c1::bodyAssy::bumper;\t\t\n\t}\n\tpackage 'Security Features' {\n\t\tprivate import vehicle1_c1::interior::alarm;\n\t\tprivate import vehicle1_c1::bodyAssy::keylessEntry;\n\t}\n\tpackage 'Safety & Security Features' {\n\t\tprivate import 'Safety Features'::*;\n\t\tprivate import 'Security Features'::*;\n\t}\n}",
    "domain": "Vehicle Traffic",
    "grammar": "Model Constrainment",
    "diagram": "dataset/sysml/samples/131/design.png"
  },
  {
    "nl": "The system is required to classify and label each component to meet information security management requirements. Every component must be clearly assigned a security classification level, such as \"Unclassified,\" \"Confidential,\" or \"Secret.\" When a component is marked as \"Confidential,\" the system should be able to recognize and display its corresponding classification attribute, thereby enabling effective differentiation and protection of sensitive information during system operation and document management.",
    "design": "package 'SecurityMetadataExtensions' {\n\tprivate import 'User Defined Extensions'::*;\n\tpackage 'User Defined Extensions' {\n\t\tenum def ClassificationLevel {\n\t\t\tuncl;\n\t\t\tconf;\n\t\t\tsecret;\n\t\t}\n\t\tmetadata def Classified {\n\t\t\tref :>> annotatedElement : SysML::PartUsage;\n\t\t\tattribute classificationLevel : ClassificationLevel[1];\n\t\t}\n\t}\n\tpart part_X {\n\t\tmetadata Classified {\n\t\t\tclassificationLevel = ClassificationLevel::conf;\n\t\t}\n\t}\n\tpart part_Y {\n\t\t@Classified {\n\t\t\tclassificationLevel = ClassificationLevel::conf;\n\t\t}\n\t}\n}",
    "domain": "Confidentiality and security",
    "grammar": "Language Extension",
    "diagram": "dataset/sysml/samples/132/design.png"
  },
  {
    "nl": "This system is designed to implement a typical automotive Electronic Control Unit (ECU) communication and control model, encompassing key components such as the Vehicle Control Unit (VCU) and the Engine Control Unit (ECU). Internal vehicle communication is carried out via the CAN bus, with the Vehicle Control Unit and Engine Control Unit each connected to the CAN bus through their respective Bus Interfaces (BusIF). This enables monitoring and control of both vehicle and engine states. Additionally, the system reserves interfaces for sensor data exchange to support future functional expansion. The entire model aims to reflect the physical connections and information flow among the main modules of modern automotive electronic control systems, ensuring reliable and efficient collaboration among vehicle subsystems, and meeting the comprehensive requirements for safety and performance at the vehicle level.",
    "design": "package 'AutomotiveECUModeling' {\n\tpackage LibraryModel {\n\t\tpart def ECU;\n\t}\n\tpackage UserModel {\t\n\t\tpackage Definitions {\n\t\t\tprivate import LibraryModel::*;\n\t\t\tpart def VehicleControlUnit :> ECU;\n\t\t\tpart def EngineControlUnit :> ECU;\n\t\t\tpart def Vehicle;\n\t\t\tpart def Engine;\n\t\t\tpart def CanBus;\n\t\t\tport def BusIF;\n\t\t}\n\t\tpackage Usages {\n\t\t\tprivate import Definitions::*;\n\t\t\tpart vehicle1: Vehicle {\n\t\t\t\tpart vehicleControlUnit : VehicleControlUnit {\n\t\t\t\t\tport busIF: ~BusIF;\n\t\t\t\t}\n\t\t\t\tconnect vehicleControlUnit.busIF to canBus.vehicleControlIF;\n\t\t\t\tpart canBus: CanBus {\n\t\t\t\t\tport vehicleControlIF: BusIF;\n\t\t\t\t\tport engineControlIF: BusIF;\n\t\t\t\t\tport sensorIF: BusIF;\t\t\t\t\t\n\t\t\t\t}\n\t\t\t\tconnect engine.engineControlUnit.busIF to canBus.engineControlIF;\n\t\t\t\tpart engine: Engine {\n\t\t\t\t\tpart engineControlUnit: EngineControlUnit {\n\t\t\t\t\t\tport busIF: ~BusIF;\n\t\t\t\t\t}\t\t\t\t\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n}",
    "domain": "Vehicle Traffic",
    "grammar": "Language Extension",
    "diagram": "dataset/sysml/samples/133/design.png"
  },
  {
    "nl": "This system is designed to ensure high reliability and safety of the blood glucose meter during use. When the battery is depleted or cannot be charged, the system should be able to automatically detect the battery status and promptly alert the user to prevent failure to measure blood glucose levels due to battery issues, as well as potential treatment delays resulting from such failures. To prevent the aforementioned failure scenarios, the system requires the implementation of preventive measures for battery status, and it must have appropriate alarm and emergency response mechanisms in case of abnormalities in the blood glucose measurement function. Furthermore, the related system requirements have undergone rigorous approval, and management measures have been established for key risk scenarios to ensure that patients can receive timely, continuous, and safe therapeutic support under all circumstances.",
    "design": "package 'MedicalDeviceFMEAFramework' {\n\tprivate import ScalarValues::*;\n\tlibrary package FMEALibrary {\n\t\tabstract occurrence def Situation;\n\t\tabstract occurrence situations : Situation[*] nonunique;\n\t\toccurrence def Cause :> Situation {\n\t\t\tattribute occurs[0..1]: Real;\n\t\t}\n\t\tabstract occurrence causes : Cause[*] nonunique;\n\t\toccurrence def FailureMode :> Situation {\n\t\t\tattribute detected[0..1]: Real;\n\t\t}\n\t\tabstract occurrence failureModes : FailureMode[*] nonunique;\n\t\toccurrence def Effect :> Situation {\n\t\t\tattribute severity[0..1]: String;\n\t\t}\n\t\tabstract occurrence effects : Effect[*] nonunique;\n\t\titem def FMEAItem :> Situation {\n\t\t\tattribute RPN: Real[0..1];\n\t\t\toccurrence :>> causes;\n\t\t\toccurrence :>> failureModes;\n\t\t\toccurrence :>> effects;\n\t\t}\n\t\tabstract item fmeaItems : FMEAItem[*] nonunique;\t\n\t\tconnection def Causation :> Occurrences::HappensBefore {\n\t\t\tend cause[*]: Situation;\n\t\t\tend effect[*]: Situation;\n\t\t}\n\t\tabstract connection causations : Causation[*] nonunique;\n\t\trequirement def FMEARequirement;\n\t\tabstract requirement fmeaRequirements : FMEARequirement[*] nonunique;\n\t\trequirement def RequirementWithSIL :> FMEARequirement {\n\t\t\tattribute sil: SIL;\n\t\t}\n\t\tenum def SIL { A; B; C; }\n\t\tconnection def Violation {\n\t\t\tend sit[*]: Situation;\n\t\t\tend req[*]: FMEARequirement;\n\t\t}\n\t\tabstract connection violations : Violation[*] nonunique;\n\t\tabstract connection def ControllingMeasure {\n\t\t\tend sit[*]: Situation;\n\t\t\tend req[*]: FMEARequirement;\n\t\t}\n\t\tconnection def Prevention :> ControllingMeasure;\n\t\tabstract connection preventions : Prevention[*] nonunique;\n\t\tconnection def Mitigation :> ControllingMeasure;\n\t\tabstract connection mitigations : Mitigation[*] nonunique;\n\t}\n\tlibrary package FMEAMetadata {\n\t\tprivate import Metaobjects::SemanticMetadata;\n\t\tprivate import FMEALibrary::*;\n\t\tenum def Status {\n\t\t\tApproved;\n\t\t\tNotApproved;\n\t\t}\n\t\tmetadata def StatusHolder {\n\t\t\tstatus: Status;\n\t\t}\n\t\tmetadata def <situation> SituationMetadata :> SemanticMetadata {\n\t\t\t:>> baseType default situations meta SysML::Usage;\n\t\t}\n\t\tmetadata def <cause> CauseMetadata :> SituationMetadata {\n\t\t\t:>> baseType = causes meta SysML::Usage;\n\t\t}\n\t\tmetadata def <failure> FailureModeMetadata :> SituationMetadata {\n\t\t\t:>> baseType = failureModes meta SysML::Usage;\n\t\t}\n\t\tmetadata def <effect> EffectMetadata :> SituationMetadata {\n\t\t\t:>> baseType = effects meta SysML::Usage;\n\t\t}\n\t\tmetadata def <fmea> FMEAItemMetadata :> SituationMetadata {\n\t\t\t:> annotatedElement : SysML::ItemDefinition;\n\t\t\t:> annotatedElement : SysML::ItemUsage;\n\t\t\t:>> baseType = fmeaItems meta SysML::Usage;\n\t\t}\n\t\tmetadata def <causation> CausationMetadata :> SemanticMetadata {\n\t\t\t:>> annotatedElement : SysML::SuccessionAsUsage;\n\t\t\t:>> baseType = causations meta SysML::Usage;\n\t\t}\n\t\tmetadata def <fmeaspec> FMEARequirementMetadata :> SemanticMetadata {\n\t\t\t:>> annotatedElement : SysML::RequirementUsage;\n\t\t\t:>> baseType = fmeaRequirements meta SysML::Usage;\n\t\t}\n\t\tmetadata def <violation> ViolationMetadata :> SemanticMetadata {\n\t\t\t:>> annotatedElement : SysML::ConnectionUsage;\n\t\t\t:>> baseType = violations meta SysML::Usage;\n\t\t}\n\t\tabstract metadata def ControllingMeasureMetadata :> SemanticMetadata {\n\t\t\t:>> annotatedElement : SysML::ConnectionUsage;\n\t\t}\n\t\tmetadata def <prevention> PreventionMetadata :> ControllingMeasureMetadata {\n\t\t\t:>> baseType = preventions meta SysML::Usage;\n\t\t}\n\t\tmetadata def <mitigation> MitigationMetadata :> ControllingMeasureMetadata {\n\t\t\t:>> baseType = mitigations meta SysML::Usage;\n\t\t}\n\t}\n\tpackage FMEAUserModel {\n\t\tprivate import FMEALibrary::*;\n\t\tprivate import FMEAMetadata::*;\n\t\t#fmeaspec requirement req1 {\n\t\t}\n\t\t#fmeaspec requirement req2 {\n\t\t}\n\t\t#fmeaspec requirement req3: RequirementWithSIL {\n\t\t\t@StatusHolder { status = Status::Approved; }\n\t\t\tdoc /* Alarm when battery has sank */\n\t\t\t:>> sil = SIL::A;\n\t\t}\n\t\t#fmea item def 'Glucose FMEA Item' {\n\t\t\t#prevention connect 'battery depleted' to req1;\n\t\t\t#cause occurrence 'battery depleted' {\n\t\t\t\t:>> occurs = 0.005;\n\t\t\t}\n\t\t\t#causation first 'battery depleted' then 'battery cannot be charged';\n\t\t\t#failure occurrence 'battery cannot be charged' {\n\t\t\t\t:>> detected = 0.013;\n\t\t\t}\n\t\t\t#causation first 'battery cannot be charged' then 'glucose level undetected';\n\t\t\t#effect occurrence 'glucose level undetected';\n\t\t\t#causation first 'glucose level undetected' then 'therapy delay';\n\t\t\t#effect occurrence 'therapy delay' {\n\t\t\t\t:>> severity = \"High\";\n\t\t\t}\n\t\t}\n\t\t#violation connect 'Glucose Meter in Use' to req2;\n\t\t#mitigation connect 'Glucose Meter in Use' to req3;\n\t\t#fmea item 'Glucose Meter in Use' : 'Glucose FMEA Item' {\n\t\t\tpart 'glucose meter' {\n\t\t\t\tevent 'glucose level undetected'[*];\n\t\t\t\tpart battery {\n\t\t\t\t\tevent 'battery depleted'[*];\n\t\t\t\t\tevent 'battery cannot be charged'[*];\n\t\t\t\t}\n\t\t\t\tpart pump;\n\t\t\t\tpart reservoir;\n\t\t\t}\n\t\t\tpart patient {\n\t\t\t\tevent 'therapy delay'[*];\n\t\t\t}\n\t\t}\n\t}\n}",
    "domain": "Medical Health",
    "grammar": "Language Extension",
    "diagram": "dataset/sysml/samples/134/design.png"
  },
  {
    "nl": "The system is required to provide a set of standard and precise constants for scientific computing and simulation applications, including mathematical constants, fundamental physical constants, and context-specific parameters. Specifically, the system should have built-in commonly used mathematical constants such as Euler’s number e and pi π, with numerical precision up to 20 decimal places. At the same time, it should integrate typical physical constants, including the precisely defined speed of light in vacuum, the fine-structure constant, and the electron-to-proton mass ratio, with clear SI unit annotations. Additionally, the system should support scenario-based constants, such as standard gravitational acceleration on Earth and the amplifier gain coefficient in specific products (e.g., Model X). All constants should be easily accessible and verifiable by the system, in order to meet the high standards of scientific computation and engineering domains.",
    "design": "package 'ScientificReferenceConstants' {\n    private import MeasurementReferences::*;\n    private import SI::*;\n    private import RealFunctions::*;\n    package 'Mathematical Constants' {\n        attribute e: Real {\n        \tassert constraint { round(e * 1E20) == 271828182845904523536.0 }\n        }\n        attribute pi: Real {\n        \tassert constraint { round(pi * 1E20) == 314159265358979323846.0 }\n        }\n    }\n    package 'Fundamental Physical Constants' {    \n        attribute 'fine structure constant'      : DimensionOneValue = 7.2973525693E-3[one];  \n        attribute 'electron to proton mass ratio': DimensionOneValue = 5.44617021487E-4[one]; \n        attribute 'speed of light in vacuum'     : SpeedValue = 299792458[m/s];    \n    }\n    package 'Global Context' {\n        attribute 'nominal earth gravitational acceleration': AccelerationValue = 9.80665['m/s²'];\n    }\n    package 'Model X Context' {\n        attribute 'amplifier gain': DimensionOneValue = 3.5[one];\n    }\n}",
    "domain": "Simulation Calculation",
    "grammar": "Expression",
    "diagram": "dataset/sysml/samples/135/design.png"
  },
  {
    "nl": "The system needs to establish a specification model for automotive components, capable of describing relevant attribute information for car tires. Each tire should include parameters such as the manufacturer name, rim diameter, and width. The rim diameter should be represented as a real number indicating the length, the manufacturer should be identified by a string, and the width should be an integer value. Additionally, the system should be able to instantiate and distinguish tires of different brands and specifications. For example, it should be able to generate a tire data instance with the manufacturer as Michelin, a rim diameter of 18.0, and a width of 245 as a French tire. This will provide clear and structured fundamental data support for the selection, configuration, and management of vehicle components.",
    "design": "package 'AutomotiveComponentSpecificationModel' {\n\tprivate import ScalarValues::*;\n    attribute def LengthValue :> Real {\n\t}\n    part def Tire {\n    \tattribute manufacturer: String;\n        attribute hubDiameter: LengthValue;\n        attribute width: Integer;\n    }\n    part frenchTire: Tire {\n    \tattribute :>> manufacturer = \"Michelin\";\n    \tattribute :>> hubDiameter = 18.0;\n    \tattribute :>> width = 245;\n    }\n}",
    "domain": "Vehicle Traffic",
    "grammar": "Expression",
    "diagram": "dataset/sysml/samples/136/design.png"
  },
  {
    "nl": "The system requires the definition of an automotive component model, which includes a vehicle and its front wheels. The vehicle has a mass of 1200 kilograms and a length of 4.82 meters. Each vehicle is equipped with a pair of left and right front wheels. For each wheel, the hub diameter must be specified as 18 inches and the width as 245 millimeters, with the outer diameter of the wheel determined by both the hub diameter and the tire height. In addition, each wheel must be fitted with a tire. All dimensions and units must support both International System of Units (SI) and United States customary units (Imperial) conversions. This model aims to provide fundamental data structures for the standardized design and simulation of automotive parts.",
    "design": "package 'AutomotiveComponents' {\n    private import SI::*;\n    private import USCustomaryUnits::*;\n    part def Vehicle_1 {\n        attribute mass: MassValue = 1200 [kg];\n        attribute length: LengthValue = 4.82 [m];\n        part leftFrontWheel : Wheel;\n        part rightFrontWheel : Wheel;\n    }\n    part def Wheel {\n    \tattribute hubDiameter: LengthValue = 18 ['in'];\n        attribute width: LengthValue = 245 [mm];\n        attribute outerDiameter: LengthValue = (hubDiameter + 2 * tire.height) [mm] {\n        }\n        part tire: Tire[1];\n    }\n    part def Tire {\n    }\n}",
    "domain": "Vehicle Traffic",
    "grammar": "Expression",
    "diagram": "dataset/sysml/samples/137/design.png"
  },
  {
    "nl": "This system is used to configure the vehicle's powertrain, including the engine and transmission. The vehicle can be equipped with either a four-cylinder engine or a six-cylinder engine, and can be paired with either a manual transmission or an automatic transmission. Each vehicle must select one type of engine and one type of transmission. If the vehicle is a high-performance model, it must be equipped with a six-cylinder engine; otherwise, a four-cylinder engine must be used. In addition, there are only two valid powertrain combinations: either a four-cylinder engine with a manual transmission, or a six-cylinder engine with an automatic transmission. No other combinations are permitted.",
    "design": "package 'VehiclePowertrainConfig' {\n\tprivate import ScalarValues::*;\n\tpart def Engine;\n\tpart def '4CylEngine' :> Engine;\n\tpart def '6CylEngine' :> Engine;\n\tpart def Transmission;\n\tpart def ManualTransmission :> Transmission;\n\tpart def AutomaticTransmission :> Transmission;\n\tpart def Vehicle {\n\t\tattribute isHighPerformance: Boolean;\n\t\tpart engine: Engine[1];\n\t\tpart transmission: Transmission[1];\n\t\tassert constraint {\n\t\t\tif isHighPerformance? engine istype '6CylEngine'\n\t\t\telse engine istype '4CylEngine'\n\t\t}\n\t\tassert constraint {\n\t\t\t(engine istype '4CylEngine' and \n\t\t\t transmission istype ManualTransmission) xor\n\t\t\t(engine istype '6CylEngine' and\n\t\t\t transmission istype AutomaticTransmission)\n\t\t}\n\t}\n}",
    "domain": "Vehicle Traffic",
    "grammar": "Expression",
    "diagram": "dataset/sysml/samples/138/design.png"
  },
  {
    "nl": "This system is used for modeling the structural and functional constraints of automotive components, where a car comprises several wheels and related parts. The vehicle has a total mass of 1200 kilograms and a length of 4.82 meters, and is equipped with multiple wheel assemblies. Each wheel assembly consists of a set of tires and the corresponding brake disc. A single wheel is composed of a rim and a tire, with the rim diameter being 18 inches, tire width 245 millimeters, and tire height 45 millimeters, based on which the outer diameter is calculated. The default tread depth of the tire is 6.0 millimeters, and it must not be less than 3.5 millimeters to comply with road safety regulations. The brake disc assembly installed on each wheel assembly has a radius of 95 millimeters, and the system requires that the brake disc diameter (i.e., twice the radius) of each wheel assembly must be less than the outer diameter of the corresponding wheel, ensuring proper installation and safety clearance between components. The system also enforces related constraints to ensure that all wheel assemblies meet the fitment requirements between the brake disc and rim, thereby safeguarding overall safety and performance.",
    "design": "package 'AutomotiveComponentRules' {\n\tprivate import ControlFunctions::forAll;\n\tprivate import SI::*;\n\tprivate import SI::*;\n    private import USCustomaryUnits::*;\n    part def Vehicle_1 {\n        attribute mass: MassValue = 1200 [kg];\n        attribute length: LengthValue = 4.82 [m];\n        part leftFrontWheel : Wheel;\n        part rightFrontWheel : Wheel;\n    }\n    part def Wheel {\n    \tattribute hubDiameter: LengthValue = 18 ['in'];\n        attribute width: LengthValue = 245 [mm];\n        attribute outerDiameter: LengthValue = (hubDiameter + 2 * tire.height) [mm] {\n\t        doc\n\t        /*\n\t         * This binds 'outDiameter' to the result of a computed attribute.\n\t         * There is no need to mark it as \"derived\".\n\t         */\n        }\n        part tire: Tire[1];\n    }\n    part def Tire {\n    \tattribute profileDepth: LengthValue default 6.0 [mm];\n        constraint hasLegalProfileDepth {profileDepth >= 3.5 [mm]}\n    \tattribute height: LengthValue = 45 [mm];\n    }\n\tconstraint def DiscBrakeConstraint {\n\t\tin wheelAssy : WheelAssy[4];\n\t\twheelAssy->forAll {in ref w: WheelAssy; \n\t\t\t2 * w.discBrakeAssy.radius < w.wheel.outerDiameter\n\t\t}\n\t}\n\tconstraint def DiscBrakeFitConstraint_Alt {\n\t\tin discBrakeAssy : DiscBrakeAssy[1];\n\t\tin wheel : Wheel[1];\t\n\t\t2 * discBrakeAssy.radius < wheel.outerDiameter\n\t}\n\tpart def Vehicle_2 {\n\t\tattribute mass : MassValue[1] = 1200 [kg];\n\t\tattribute length : LengthValue[1] = 4.82 [m];\n\t\tpart wheelAssy : WheelAssy[4];\n\t\tconstraint discBrakeConstraint : DiscBrakeConstraint {\n\t\t\tin wheelAssy = Vehicle_2::wheelAssy;\n\t\t}\n\t}\n\tpart def WheelAssy {\n\t\tpart wheel : Wheel[1];\n\t\tpart discBrakeAssy : DiscBrakeAssy[1];\n\t\tassert constraint discBrakeFitConstraint_Alt: DiscBrakeFitConstraint_Alt {\n\t\t\tin discBrakeAssy = WheelAssy::discBrakeAssy;\n\t\t\tin wheel = WheelAssy::wheel;\n\t\t}\n\t}\n\tpart def DiscBrakeAssy {\n\t\tattribute radius : LengthValue[1] = 95 [mm];\n\t}\n}",
    "domain": "Vehicle Traffic",
    "grammar": "Expression",
    "diagram": "dataset/sysml/samples/139/design.png"
  },
  {
    "nl": "This system is used for the automotive fuel system and covers the requirements for components such as the fuel tank assembly, fuel pump, and fuel tank. The fuel tank assembly provides an outlet interface for fuel (including a return function), enabling the delivery of fuel to the engine or other components, as well as the reception of returned fuel. The fuel pump, installed inside the fuel tank assembly, serves to pump fuel from the fuel tank and supply it to the engine, while also being capable of receiving returned fuel. The system is able to monitor and transmit fuel temperature information. It is required that fuel can circulate efficiently and safely among all components, meeting the vehicle's overall requirements for fuel supply and return functions, and ensuring normal fuel supply to the engine.",
    "design": "package 'VehicleFuelSystem' {\n\tpart def Vehicle;\n\tpart def FuelPump;\n\tpart def FuelTank;\n\tattribute def Temp;\n\tpart def Fuel;\n\tport def FuelOutPort {\n\t\tattribute temperature : Temp;\n\t\tout item fuelSupply : Fuel;\n\t\tin item fuelReturn : Fuel;\n\t}\n\tpart def FuelTankAssembly {\n\t\tport fuelTankPort : FuelOutPort;\n\t}\n\tpart vehicle : Vehicle {\t\n\t\tpart tank : FuelTankAssembly {\n\t\t\tport redefines fuelTankPort {\n\t\t\t\tout item redefines fuelSupply;\n\t\t\t\tin item redefines fuelReturn;\n\t\t\t}\n\t\t\tpart pump : FuelPump {\n\t\t\t\tout item pumpOut : Fuel = fuelTankPort.fuelSupply;\n\t\t\t\tin item pumpIn : Fuel;\n\t\t\t}\n\t\t\tpart tank : FuelTank {\n\t\t\t\tout item fuelOut : Fuel;\n\t\t\t\tin item fuelIn : Fuel = fuelTankPort.fuelReturn;\n\t\t\t}\n\t\t}\n\t} \n}",
    "domain": "Vehicle Traffic",
    "grammar": "Binding Connector",
    "diagram": "dataset/sysml/samples/14/design.png"
  },
  {
    "nl": "The system must be capable of supporting and managing data and units related to physical quantities, and is required to cover various base physical quantities in the International System of Quantities (ISQ), such as length, mass, time, electric current, temperature, amount of substance, and luminous intensity. The system should also allow for corresponding import and extension. It must ensure accurate representation of relevant physical quantities and consistency of information, facilitating physical quantity data processing and unit conversion operations in subsequent engineering or scientific development. The system must meet users' diverse requirements for managing physical quantity systems.",
    "design": "package 'PhysicalQuantitiesSystem' {\n    private import ISQ::*;\n}",
    "domain": "Information Management",
    "grammar": "Expression",
    "diagram": "dataset/sysml/samples/140/design.png"
  },
  {
    "nl": "This system is designed to provide a standardized unit system library that supports the interoperability and adaptation between the International System of Quantities (ISQ) and United States Customary Units (USCustomaryUnits). The goal is to enable users to conveniently manage, convert, and apply various units of physical quantities, effectively reducing confusion and errors caused by inconsistent units. At the same time, the system must ensure the accuracy and authoritative standardization of all unit types, meeting the measurement needs of engineering, scientific research, and daily life. This will enhance the efficiency and reliability of data processing and communication.",
    "design": "package 'UnitSystemsStandard' {\n    private import ISQ::*;\n    private import USCustomaryUnits::*;\n}",
    "domain": "Information Management",
    "grammar": "Expression",
    "diagram": "dataset/sysml/samples/141/design.png"
  },
  {
    "nl": "This system is used to verify and validate the parameters of the car headlamp tilt adjustment knob, ensuring that the adjusted beam tilt angle falls within a reasonable range. Specifically, the tilt angle of the headlamp beam (measured in degrees) must be between 50 degrees and 80 degrees; any value outside this range does not comply with safety and regulatory standards. The system adopts the International System of Units (SI) and standard real number constants (such as pi and Euler’s number e) to ensure precision and consistency in calculations, thereby achieving scientific and reliable management of the headlamp beam adjustment knob functionality.",
    "design": "package 'AutomotiveParameterValidation' {\n\tprivate import ISQ::*;\n\tprivate import SI::*;\n\t private import MeasurementReferences::*;\n    private import SI::*;\n    private import RealFunctions::*;\n    package 'Mathematical Constants' {\n\t    doc\n\t    /*\n\t     * Standard mathematical constants\n\t     * \n\t     * Irrational constants cannot be represented exactly with finite precision.\n\t     * However, they can be required to be implemented with a attribute that is accurate\n\t     * to at least a certain precision.\n\t     * \n\t     * (The decimal literals here should be interpreted as being fixed point and exact.)\n\t     */\n        attribute e: Real {\n        \tassert constraint { round(e * 1E20) == 271828182845904523536.0 }\n        }\n        attribute pi: Real {\n        \tassert constraint { round(pi * 1E20) == 314159265358979323846.0 }\n        }\n    }\n\tpart def HeadLightsTiltKnob {\n\t\tattribute headLightsTile : LightBeamTiltAngleValue[1];\n\t}\n\tattribute def LightBeamTiltAngleValue :> PlaneAngleValue {\n\t\tattribute angle: LightBeamTiltAngleValue :>> self {\n\t\t}\n\t\tassert constraint { angle >= 50 ['°'] and angle <= 80 ['°'] }\n\t}\n}",
    "domain": "Vehicle Traffic",
    "grammar": "Expression",
    "diagram": "dataset/sysml/samples/142/design.png"
  },
  {
    "nl": "The system needs to support the management of several core data types, including unsigned integers and unsigned floating-point numbers, both of which must be non-negative. The system should also be capable of handling basic data types such as date-time, string, and boolean values. The system must provide color labeling for status conditions, with “red”, “yellow”, and “green” respectively representing different status levels (e.g., severity levels such as critical, warning, and normal), and automatically associate each level with the corresponding color. The system should also be able to describe physical dimensions, in particular, support a diameter parameter measured in millimeters, with selectable options of “Small (60 mm)”, “Medium (70 mm)”, and “Large (80 mm)”, and a default initial value set to Small. Overall, the system’s data types should be designed for future extensibility and ensure correct enforcement of value constraints and the logic that associates statuses with their corresponding colors.",
    "design": "package 'CoreDataTypes' {\n\tprivate import ScalarValues::Integer {\n\t}\n\tprivate import ScalarValues::Natural;\n\tattribute def UnsignedInteger :> Natural {\t\n\t}\n\tprivate import ScalarValues::Real {\n\t}\n\tattribute def UnsignedReal :> Real {\n\t\tattribute x: Real :>> self;\n\t\tassert constraint { x >= 0.0 }\n\t}\n\tprivate import ScalarValues::String {\n\t}\n\tprivate import ScalarValues::Boolean {\n\t}\n\tprivate import Time::DateTime;\n\tenum def ConditionColor {\t\n\t\tenum red;\n\t\tenum yellow;\n\t\tenum green;\n\t}\n\tattribute def ConditionLevel {\n\t\tattribute associatedColor : ConditionColor;\n\t}\n\tenum def SeverityEnum :> ConditionLevel {\n\t\tdanger { \n\t\t\t:>> associatedColor = ConditionColor::red;\n\t\t}\n\t\twarning { \n\t\t\t:>> associatedColor = ConditionColor::yellow;\n\t\t}\n\t\tnormal { \n\t\t\t:>> associatedColor = ConditionColor::green;\n\t\t}\n\t}\n\tattribute def Diameter :> ISQ::LengthValue;\t\n\tenum def DiameterChoice :> Diameter {\n\t\tsmall = 60 [SI::mm];\n\t\tmedium = 70 [SI::mm];\n\t\tlarge = 80 [SI::mm];\n\t}\t\n\tattribute aperatureDiameter: DiameterChoice = DiameterChoice::small;\n}",
    "domain": "Information Management",
    "grammar": "Expression",
    "diagram": "dataset/sysml/samples/143/design.png"
  },
  {
    "nl": "The system needs to be able to manage spare parts, personnel, and various related collection types. For spare parts, it should support archiving and management in the form of Bags, with each element in a Bag being a spare part. For integers, the system should support storage in the form of Lists, where each list item is an integer value. For strings, the system should be able to manage strings as Sets. For personnel, the system should support management using OrderedSets, with each element being of the Person type. Additionally, the system should support nested collection management, such as storing a List composed of multiple personnel sets (Set<Person>). For real numbers (Real), the system should allow processing in the form of fixed-length arrays (with a length of 4). All these collection data structures should support integration and interaction with other business functions to facilitate flexible retrieval and use of related information.",
    "design": "package 'CollectionTypes' {\n\tprivate import ScalarValues::*;\n\tprivate import Collections::*;\n\tpart def SparePart;\n\tpart def Person;\n\tattribute def 'Bag<SparePart>' :> Bag {\n\t\tref part :>> elements: SparePart;\n\t}\n\tattribute def 'List<Integer>' :> List {\n\t\tvalue :>> elements: Integer;\n\t}\n\tattribute def 'Set<String>' :> Set {\n\t\tattribute :>> elements: String;\n\t}\n\tattribute def 'OrderedSet<Person>' :> OrderedSet {\n\t\tref part :>> elements: Person;\n\t}\n\tattribute def 'List<Set<Person>>' :> List {\n\t\tattribute :>> elements: Set {\n\t\t\tref part :>> elements: Person;\n\t\t}\n\t}\n\tattribute def 'Array<Real>[4]' :> Array {\n\t\tattribute :>> elements: Real;\n\t\tattribute :>> dimensions = 4;\n\t}\n}",
    "domain": "Information Management",
    "grammar": "Expression",
    "diagram": "dataset/sysml/samples/144/design.png"
  },
  {
    "nl": "The system needs to support a structured description of tire information. Each tire entry should include the manufacturer name, rim diameter, tire width, as well as optional installation position information (i.e., a coordinate vector in three-dimensional space). The rim diameter should be expressed in inches, which is the commonly used unit in the United States. The system should be able to distinguish between tires from different manufacturers and with different specifications, for example, a French Michelin brand tire with an 18-inch rim diameter and a width of 245, and be able to record all the aforementioned attributes completely. At the same time, the system should possess data scalability to accommodate future additions of other brands, sizes, and installation information.",
    "design": "package 'StructuredDataTypes' {\n\tprivate import ScalarValues::*;\n\tprivate import USCustomaryUnits::'in';\n    attribute def PositionVector {\n        attribute x: Real[1];\n        attribute y: Real[1];\n        attribute z: Real[1];\n    }\n    attribute def LengthValue :> Real;\n    attribute def TireInfo {\n    \tattribute manufacturer: String;\n        attribute hubDiameter: LengthValue;\n        attribute width: Integer;\n        attribute placement: PositionVector[0..1];\n    }\n    attribute frenchTireInfo: TireInfo {\n    \tattribute :>> manufacturer = \"Michelin\";\n    \tattribute :>> hubDiameter = 18.0['in'];\n    \tattribute :>> width = 245;\n    }\n}",
    "domain": "Information Management",
    "grammar": "Expression",
    "diagram": "dataset/sysml/samples/145/design.png"
  },
  {
    "nl": "The system is required to sample and record the trajectory of the spacecraft during the ascent phase. The system should use the mission liftoff time as the reference time zero, measured in seconds, and be able to take the UTC liftoff time of the mission (for example, 22:42:32.924534 on August 23, 2020) as the reference time. The system should collect key parameters including the position and velocity of the spacecraft at different time points. Each set of sampled data must associate a specific time point with the corresponding position and velocity data. Both the three-dimensional position and velocity should be described in a Cartesian coordinate system, with units of meters and meters per second, respectively. The system should record multiple sampling points during the ascent phase, with each sampling point containing explicit information on time, position, and velocity, in order to provide accurate data support for subsequent trajectory analysis and performance evaluation.",
    "design": "package 'AerospaceTrajectorySampling' {\n\tprivate import SampledFunctions::SampledFunction;\n\tprivate import SampledFunctions::SamplePair;\n\tprivate import Collections::Array;\n\tprivate import ISQ::*;\n\tprivate import SI::*;\n\tprivate import MeasurementReferences::*;\n\tprivate import Time::*;\n\tattribute def MissionElapsedTimeScale :> TimeScale {\n\t\t:>> unit = s;\n\t\tattribute :>> definitionalEpoch {\n\t\t\t:>> num = 0;\n\t\t\t:>> definition = \"time instant zero at launch\";\n\t\t}\n\t\tattribute definitionalEpochInUTC : Iso8601DateTime;\n\t\tattribute :>> transformation : CoordinateFramePlacement {\n\t\t\t:>> source = UTC;\n\t\t\t:>> origin = definitionalEpochInUTC;\n\t\t\t:>> basisDirections = 1 [UTC];\n\t\t}\n  }\n\n\tattribute mets: MissionElapsedTimeScale { \n\t\t:>> definitionalEpochInUTC { :>> val = \"2020-08-23T22:42:32.924534Z\";}\t\t\n\t}\n\tattribute def MissionElapsedTimeValue :> TimeInstantValue {\n\t \t:>> mRef = mets; \n\t}\n\n\tattribute spatialCF: CartesianSpatial3dCoordinateFrame[1] {\n\t   :>> mRefs = (m, m, m);\n\t}\n\tattribute velocityCF: CartesianVelocity3dCoordinateFrame[1] = spatialCF/s;\n\tattribute def PositionAndVelocity {\n\t\tattribute position : CartesianPosition3dVector[1];\n\t\tattribute velocity : CartesianVelocity3dVector[1];\n\t}\n\tattribute def AscentProfile :> SampledFunction {\n\t\tattribute def AscentSample :> SamplePair {\n\t\t\tattribute :>> domainValue: MissionElapsedTimeValue[1];\n\t\t\tattribute :>> rangeValue: PositionAndVelocity[1];\n\t\t}\n\t\tattribute :>> samples: AscentSample[*] ordered;\n\t}\n\tattribute ascentProfile1: AscentProfile {\n\t\tattribute sample1: AscentSample { :>> domainValue = 0.0 [mets]; :>> rangeValue = pv1;\n\t\t\tattribute pv1: PositionAndVelocity {:>> position = (0, 0, 0) [spatialCF]; :>> velocity = (0, 0, 0) [velocityCF]; } }\n\t\tattribute sample2: AscentSample { :>> domainValue = 2.5 [mets]; :>> rangeValue = pv1;\n\t\t\tattribute pv1: PositionAndVelocity {:>> position = (0.01, 0.03, 8.6) [spatialCF]; :>> velocity = (0, 0, 5.5) [velocityCF]; } }\n\t\tattribute sample3: AscentSample { :>> domainValue = 5.1 [mets]; :>> rangeValue = pv1;\n\t\t\tattribute pv1: PositionAndVelocity {:>> position = (0.04, 0.12, 18.6) [spatialCF]; :>> velocity = (0.05, 0.03, 25.3) [velocityCF]; } }\n\t\tattribute :>> samples = (sample1, sample2, sample3);\n\t}\n}",
    "domain": "Aerospace",
    "grammar": "Expression",
    "diagram": "dataset/sysml/samples/146/design.png"
  },
  {
    "nl": "This system is designed to support the modeling and management requirements of alloy-related properties and their constituent metals in the field of materials science. The system can define and manage the basic characteristics of different substances, materials, and metals, such as atomic mass, and can clearly represent the mass fractions of component materials in alloys. In addition, the system supports standardized modeling of important mechanical properties—for example, tensile strength—allowing the use of derived SI units (such as newtons per square millimeter) for expression. The same alloy can be composed of two or more materials combined according to specified mass fractions, and the system provides detailed recording of each component material, its mass fraction, and the overall tensile strength of the alloy. The system enables the creation of instances for common metals (such as iron, carbon, manganese) and typical alloys (such as steel 980), assigning scientific units and real or standard values to their properties. With this system, users can conveniently view, edit, and expand the composition and property data of metallic materials and alloys, thus providing a data foundation and support for scenarios such as scientific research, engineering design, and quality control.",
    "design": "package 'MaterialScienceBase' {\n\tprivate import ScalarValues::Real;\n\tprivate import Quantities::*;\n\tprivate import MeasurementReferences::*;\n\tprivate import SI::*;\n    attribute def AtomicMassValue :> MassValue;\n\tattribute def TensileStrengthUnit :> DerivedUnit {\n        private attribute lengthPF: QuantityPowerFactor[1] { :>> quantity = isq.L; :>> exponent = -1; }\n        private attribute massPF: QuantityPowerFactor[1] { :>> quantity = isq.M; :>> exponent = 1; }\n        private attribute durationPF: QuantityPowerFactor[1] { :>> quantity = isq.T; :>> exponent = -2; }\n        attribute :>> quantityDimension { :>> quantityPowerFactors = (lengthPF, massPF, durationPF); }\t\t\n\t}\n    attribute def TensileStrengthValue :> ScalarQuantityValue {\n\t\tattribute :>> num: Real;\n    \tattribute :>> mRef: TensileStrengthUnit;\n    }\n    attribute <'N/mm²'> 'newton per square millimetre' : TensileStrengthUnit = N / mm^2;\n    part def Substance;\n    part def Material :> Substance;\n    part def Metal :> Material {\n        attribute atomicMass: AtomicMassValue[1];\n    }\n    attribute def MaterialFraction {\n        ref material: Material[1]; \n        attribute massFraction: MassFractionValue[1];\n    }\n    attribute def MassFractionValue :> DimensionOneValue;    \n    part def Alloy :> Material {\n        attribute fractions: MaterialFraction[2..*];\n    }\n    individual def Iron :> Metal {\n        attribute :>> atomicMass = 55.845 [Da];\n    }\n    individual def Carbon :> Metal {\n        attribute atomicMass :>> Metal::atomicMass = 12.011[Da];\n    }\n    individual def Manganese :> Metal {\n        attribute atomicMass :>> Metal::atomicMass = 54.938[Da];\n    }\n    individual def Steel_980 :> Alloy {\n        attribute fraction1 :> fractions {\n        \tref :>> material : Iron;\n        \tattribute :>> massFraction = 0.9862[one];\n        }\n        attribute fraction2 :> fractions {\n        \tref :>> material : Carbon;\n        \tattribute :>> massFraction = 0.9862[one];\n        }\n        attribute fraction3 :> fractions {\n        \tref :>> material : Manganese;\n        \tattribute :>> massFraction = 0.9862[one];\n        }\n        attribute tensileStrength: TensileStrengthValue = 980['N/mm²'];\n    }\n}",
    "domain": "Energy materials",
    "grammar": "Expression",
    "diagram": "dataset/sysml/samples/147/design.png"
  },
  {
    "nl": "The engineering materials database system should be capable of modeling and managing various types of engineering materials, including metals and their alloys. The system should support the description of fundamental properties of materials, such as atomic mass, compositional information, and mechanical property indicators. For metals and alloys, the system must be able to define their detailed compositional information, including the mass fraction of each constituent material. Regarding mechanical properties, the system should support standardized and dimensional management of parameters such as tensile strength, and be able to represent and convert them using commonly used engineering units (e.g., Newtons per square millimeter). Taking high-strength steel Steel_980 as an example, the system should accurately record the mass fractions of its components such as iron, carbon, and manganese, as well as its overall tensile strength, to facilitate subsequent material selection, evaluation, and application. Overall, the system aims to provide end users with an intuitive, standardized, and flexible data management approach, enabling convenient data entry, querying, and comparison of engineering materials, thereby improving the efficiency and scientific rigor of materials engineering research, development, and application.",
    "design": "package 'EngineeringMaterialsLibrary' {\n\tprivate import ScalarValues::*;\n\tprivate import Quantities::*;\n\tprivate import MeasurementReferences::*;\n\tprivate import SI::*;\n    attribute def AtomicMassValue :> MassValue;\n\tattribute def TensileStrengthUnit :> DerivedUnit {\n        private attribute lengthPF: QuantityPowerFactor[1] { :>> quantity = isq.L; :>> exponent = -1; }\n        private attribute massPF: QuantityPowerFactor[1] { :>> quantity = isq.M; :>> exponent = 1; }\n        private attribute durationPF: QuantityPowerFactor[1] { :>> quantity = isq.T; :>> exponent = -2; }\n        attribute :>> quantityDimension { :>> quantityPowerFactors = (lengthPF, massPF, durationPF); }\t\t\n\t}\n    attribute def TensileStrengthValue :> ScalarQuantityValue {\n\t\tattribute :>> num: Real;\n    \tattribute :>> mRef: TensileStrengthUnit;\n    }\n    attribute <'N/mm²'> 'newton per square millimetre' : TensileStrengthUnit = N / mm^2;\n    attribute def Substance;\n\tattribute def Material :> Substance;\n    attribute def Metal :> Material {\n        attribute atomicMass: AtomicMassValue[1];\n    }\n    attribute def Alloy :> Material {\n        attribute fractions: MaterialFraction[2..*];\n    }\n    attribute def MaterialFraction {\n        attribute material: Material[1]; \n        attribute massFraction: MassFractionValue[1];\n    }\n    attribute def MassFractionValue :> DimensionOneValue;    \n    attribute Iron: Metal { :>> atomicMass = 55.845[Da]; }\n    attribute Carbon: Metal { :>> atomicMass = 12.011[Da]; }\n    attribute Manganese: Metal { :>> atomicMass = 54.938[Da]; }\n    attribute Steel_980: Alloy {\n        private attribute fraction1: MaterialFraction { :>> material = Iron; :>> massFraction = 0.9862[one]; }\n        private attribute fraction2: MaterialFraction { :>> material = Carbon; :>> massFraction = 0.0018[one]; }\n        private attribute fraction3: MaterialFraction { :>> material = Manganese; :>> massFraction = 0.012[one]; }\n    \tattribute :>> fractions = (fraction1, fraction2, fraction3);\n        attribute tensileStrength: TensileStrengthValue = 980 ['N/mm²'];\n    } \n}",
    "domain": "Information Management",
    "grammar": "Expression",
    "diagram": "dataset/sysml/samples/148/design.png"
  },
  {
    "nl": "The system needs to implement a typical Publish-Subscribe (Pub-Sub) message interaction model, supporting message producers to publish messages on specific topics to the server, while consumers can subscribe to topics of interest through the server. The system requires that when a producer publishes a new message, the server is able to promptly receive the published information and, according to the existing topic subscription relationships, distribute and deliver the message to the corresponding subscribers, ensuring that subscribers can accurately and promptly receive the message content of the topics they follow. Users only need to declare the topics they wish to subscribe to, without needing to know the specific publishers or other subscribers. The entire process must feature clear management and efficient processing of message subscription, publishing, and distribution flows.",
    "design": "package 'PubSubInteractionModel' {\n\tprivate import ScalarValues::*;\n\tprivate import PayloadDefinitions::*;\n\tpackage PayloadDefinitions {\n\t    item def Subscribe {\n\t    \tattribute topic : String;\n\t    \tref part subscriber;\n\t    }\n\t\titem def Publish {\n\t\t\tattribute topic : String;\n\t\t\tref publication;\n\t\t}\n\t\titem def Deliver {\n\t\t\tref publication;\n\t\t}\n\t}\n\toccurrence def PubSubSequence {\n\t\tpart producer[1] {\n\t\t\tevent occurrence publish_source_event;\n\t\t}\n\t\tmessage publish_message of Publish[1] from producer.publish_source_event to server.publish_target_event;\n\t\tpart server[1] {\n\t\t\tevent occurrence subscribe_target_event;\n\t\t\tthen event occurrence publish_target_event;\n\t\t\tthen event occurrence deliver_source_event;\n\t\t}\n\t\tmessage subscribe_message of Subscribe[1] from consumer.subscribe_source_event to server.subscribe_target_event;\n\t\tmessage deliver_message of Deliver[1] from server.deliver_source_event to consumer.deliver_target_event;\n\t\tpart consumer[1] {\n\t\t\tevent occurrence subscribe_source_event;\n\t\t\tthen event occurrence deliver_target_event;\n\t\t}\n\t}\n}",
    "domain": "Network Communication",
    "grammar": "SequenceModeling",
    "diagram": "dataset/sysml/samples/149/design.png"
  },
  {
    "nl": "This system is designed to describe the basic structure and operating principles of a vehicle fuel system. The vehicle is equipped with a fuel tank assembly and an engine, which are connected through fuel lines to facilitate fuel supply and return. The fuel tank assembly is responsible for supplying fuel to the engine, and after combustion and usage, the engine returns the unused portion of the fuel back to the fuel tank. Throughout the entire fuel flow process, the system can monitor and transmit information on the fuel temperature to ensure operational safety and system efficiency. This fuel system design ensures that the vehicle receives a continuous and stable fuel supply during operation, effectively recycles excess fuel, and optimizes resource utilization.",
    "design": "package 'VehicleFuelSystem' {\n\tpart def Vehicle;\n\tattribute def Temp;\n\tpart def Fuel;\n\tport def FuelOutPort {\n\t\tattribute temperature : Temp;\n\t\tout item fuelSupply : Fuel;\n\t\tin item fuelReturn : Fuel;\n\t}\n\tport def FuelInPort {\n\t\tattribute temperature : Temp;\n\t\tin item fuelSupply : Fuel;\n\t\tout item fuelReturn : Fuel;\n\t}\n\tpart def FuelTankAssembly {\n\t\tport fuelTankPort : FuelOutPort;\n\t}\n\tpart def Engine {\n\t\tport engineFuelPort : FuelInPort;\n\t}\n\tpart vehicle : Vehicle {\n\t\tpart tankAssy : FuelTankAssembly;\n\t\tpart eng : Engine;\n\t\tflow of Fuel\n\t\t  from tankAssy.fuelTankPort.fuelSupply\n\t\t\tto eng.engineFuelPort.fuelSupply;\n\t\tflow of Fuel\n\t\t  from eng.engineFuelPort.fuelReturn\n\t\t\tto tankAssy.fuelTankPort.fuelReturn;\n\t} \n}",
    "domain": "Vehicle Traffic",
    "grammar": "Flow Connection",
    "diagram": "dataset/sysml/samples/15/design.png"
  },
  {
    "nl": "This system aims to implement a typical publish-subscribe message flow architecture, consisting of three main participants: producers, server, and consumers. The system requires that producers can publish topic messages to the server, while consumers can subscribe to specific topics via the server. Upon successful subscription, when a new message related to the topic is published, the server needs to push and deliver the message to all consumers who have subscribed to that topic. The entire process includes consumers sending subscription requests to the server, producers publishing messages to the server, and after receiving the messages, the server sending them to all corresponding subscribers, thus achieving reliable message publishing and distribution and ensuring efficient information exchange between different users.",
    "design": "package 'PubSubMessagingFlow' {\n\tprivate import ScalarValues::*;\n\tprivate import PayloadDefinitions::*;\n\tpackage PayloadDefinitions {\n\t    item def Subscribe {\n\t    \tattribute topic : String;\n\t    \tref part subscriber;\n\t    }\n\t\titem def Publish {\n\t\t\tattribute topic : String;\n\t\t\tref publication;\n\t\t}\n\t\titem def Deliver {\n\t\t\tref publication;\n\t\t}\n\t}\n\toccurrence def PubSubSequence {\n\t\tpart producer[1] {\n\t\t\tevent publish_message.source;\n\t\t}\n\t\tmessage publish_message of Publish[1];\n\t\tpart server[1] {\n\t\t\tevent subscribe_message.target;\n\t\t\tthen event publish_message.target;\n\t\t\tthen event deliver_message.source;\n\t\t}\n\t\tmessage subscribe_message of Subscribe[1];\n\t\tmessage deliver_message of Deliver[1];\n\t\tpart consumer[1] {\n\t\t\tevent subscribe_message.source;\n\t\t\tthen event deliver_message.target;\n\t\t}\n\t}\n}",
    "domain": "Network Communication",
    "grammar": "SequenceModeling",
    "diagram": "dataset/sysml/samples/150/design.png"
  },
  {
    "nl": "This system is designed to provide transportation services for users. Users (the driver and up to four passengers) can enter the vehicle, and the driver is responsible for operating the vehicle to complete travel tasks. During vehicle use, if the fuel level falls below 10% of the maximum tank capacity, the driver may go to a gas station to refuel, thus ensuring the vehicle can continue operating. Environmental factors will also be taken into account throughout the process. After transportation is completed, all individuals exit the vehicle safely. This system focuses on facilitating user boarding, timely refueling during the journey, and ensuring the smooth boarding and alighting of passengers and the driver, thereby guaranteeing an efficient and safe travel experience.",
    "design": "package 'TransportationUseCases' {\n\tpart def Vehicle;\n\tpart def Person;\n\tpart def Environment;\n\tpart def 'Fuel Station';\n\tuse case 'provide transportation' {\n\t\tsubject vehicle : Vehicle;\n\t\tactor driver : Person;\n\t\tactor passengers : Person[0..4];\n\t\tactor environment : Environment;\n\t\tobjective {\n\t\t}\n\t\tref :>> start {\n\t\t\tassert constraint {\n\t\t\t}\n\t\t}\n\t\tfirst start;\n\t\tthen include 'enter vehicle' {\n\t\t\tactor :>> driver = 'provide transportation'::driver;\n\t\t\tactor :>> passengers = 'provide transportation'::passengers;\n\t\t}\n\t\tthen use case 'drive vehicle' {\n\t\t\tinclude 'add fuel'[0..*] {\n\t\t\t\tactor :>> fueler = driver;\n\t\t\t\tref :>> start {\n\t\t\t\t\tdoc /* Fuel level < 10% max fuel */\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tthen include 'exit vehicle' {\n\t\t\tactor :>> driver = 'provide transportation'::driver;\n\t\t\tactor :>> passengers = 'provide transportation'::passengers;\n\t\t}\n\t\tthen done;\n\t\tref :>> done {\n\t\t\tassert constraint {\n\t\t\t}\n\t\t}\n\t}\n\tuse case 'enter vehicle' {\n\t\tsubject vehicle : Vehicle;\n\t\tactor driver : Person;\n\t\tactor passengers : Person[0..4];\n\t}\n\tuse case 'exit vehicle' {\n\t\tsubject vehicle : Vehicle;\n\t\tactor driver : Person;\n\t\tactor passengers : Person[0..4];\n\t}\n\tuse case 'add fuel' {\n\t\tsubject vehicle : Vehicle;\n\t\tactor fueler : Person;\n\t\tactor 'fuel station' : 'Fuel Station';\n\t}\n}",
    "domain": "Vehicle Traffic",
    "grammar": "SequenceModeling",
    "diagram": "dataset/sysml/samples/151/design.png"
  },
  {
    "nl": "This system is designed to provide fuel supply and return management functions for vehicles. The system consists of a fuel tank assembly and an engine unit. The fuel tank supplies fuel to the engine through a fuel outlet port that connects to the engine’s fuel inlet port, and can also receive fuel return from the engine. Port information includes attributes such as fuel temperature, ensuring that relevant parameters can be monitored in real time during both supply and return processes. The engine and fuel tank are connected via fuel interfaces, enabling both forward flow (supply) and reverse flow (return) of fuel to meet the engine’s normal operation requirements and ensure an efficient fuel circulation system. The design objective of this system is to ensure that the vehicle engine can continuously and reliably obtain the required fuel, while also supporting fuel return processing, thereby improving the intelligence and safety of the overall vehicle fuel management.",
    "design": "package 'VehicleFuelSystem' {\n\tprivate import 'Port Example'::*;\n\tattribute def Temp;\n\tpart def Fuel;\n\tport def FuelOutPort {\n\t\tattribute temperature : Temp;\n\t\tout item fuelSupply : Fuel;\n\t\tin item fuelReturn : Fuel;\n\t}\n\tport def FuelInPort {\n\t\tattribute temperature : Temp;\n\t\tin item fuelSupply : Fuel;\n\t\tout item fuelReturn : Fuel;\n\t}\n\tpart def FuelTankAssembly {\n\t\tport fuelTankPort : FuelOutPort;\n\t}\n\tpart def Engine {\n\t\tport engineFuelPort : FuelInPort;\n\t}\n\tpart def Vehicle;\n\tinterface def FuelInterface {\n\t\tend supplierPort : FuelOutPort;\n\t\tend consumerPort : FuelInPort;\n\t\tflow supplierPort.fuelSupply to consumerPort.fuelSupply;\t\t\t\n\t\tflow consumerPort.fuelReturn to supplierPort.fuelReturn;\n\t}\n\tpart vehicle : Vehicle {\t\n\t\tpart tankAssy : FuelTankAssembly;\t\t\n\t\tpart eng : Engine;\n\t\tinterface : FuelInterface connect \n\t\t\tsupplierPort ::> tankAssy.fuelTankPort to \n\t\t\tconsumerPort ::> eng.engineFuelPort;\n\t} \n}",
    "domain": "Vehicle Traffic",
    "grammar": "Flow Connection",
    "diagram": "dataset/sysml/samples/16/design.png"
  },
  {
    "nl": "This system is used for vehicle fuel system management and is required to achieve efficient supply and return of fuel. The system consists of two core components: the Fuel Tank Assembly and the Engine. Fuel must flow from the fuel tank to the engine through the fuel supply port, while the engine can also return unused fuel back to the fuel tank. Each fuel interface should provide the current temperature information of the fuel to facilitate subsequent monitoring and regulation. The system should ensure efficient fuel flow and information tracking during both supply and return processes, meeting the requirements for reliability, safety, and monitoring of fuel delivery during normal vehicle operation.",
    "design": "package 'VehicleFuelSystem' {\n\tattribute def Temp;\n\tpart def Fuel;\n\tport def FuelOutPort {\n\t\tattribute temperature : Temp;\n\t\tout item fuelSupply : Fuel;\n\t\tin item fuelReturn : Fuel;\n\t}\n\tport def FuelInPort {\n\t\tattribute temperature : Temp;\n\t\tin item fuelSupply : Fuel;\n\t\tout item fuelReturn : Fuel;\n\t}\n\tpart def FuelTankAssembly {\n\t\tport fuelTankPort : FuelOutPort;\n\t}\n\tpart def Engine {\n\t\tport engineFuelPort : FuelInPort;\n\t}\n\tpart def Vehicle;\n\tflow def FuelFlow {\n\t\tref :>> payload : Fuel;\n\t\tend port supplierPort : FuelOutPort;\n\t\tend port consumerPort : FuelInPort;\n\t}\n\tpart vehicle : Vehicle {\n\t\tpart tankAssy : FuelTankAssembly;\n\t\tpart eng : Engine;\n\t\tflow : FuelFlow\n\t\t  from tankAssy.fuelTankPort.fuelSupply\n\t\t\tto eng.engineFuelPort.fuelSupply;\n\t} \n}",
    "domain": "Vehicle Traffic",
    "grammar": "Flow Connection",
    "diagram": "dataset/sysml/samples/17/design.png"
  },
  {
    "nl": "The system should enable users to obtain photos from real-world scenes. Specifically, after a user selects a scene they wish to capture, the system should first automatically perform focusing for the selected scene and generate an intermediate image. Next, based on the focused image, the system should capture and output the final photo. Ultimately, users can directly obtain photos that meet their requirements from the selected scene, while the system completes the focusing and shooting processes automatically in the background, without requiring manual intervention at each step.",
    "design": "package 'PhotographyWorkflow' {\n\titem def Scene;\n\titem def Image;\n\titem def Picture;\n\taction def Focus { in scene : Scene; out image : Image; }\n\taction def Shoot { in image: Image; out picture : Picture; }\t\n\taction def TakePicture { in scene : Scene; out picture : Picture;\n\t\tbind focus.scene = scene;\n\t\taction focus: Focus { in scene; out image; }\n\t\tflow from focus.image to shoot.image;\n\t\taction shoot: Shoot { in image; out picture; }\n\t\tbind shoot.picture = picture;\n\t}\n}",
    "domain": "Photography Technique",
    "grammar": "Action Definition",
    "diagram": "dataset/sysml/samples/18/design.png"
  },
  {
    "nl": "This system is designed to support the photography workflow, enabling the complete process from focusing on a scene to producing the final image. The user first selects or sets a scene to be photographed; the system then automatically performs focusing on the selected scene and generates an intermediate image. Subsequently, the system carries out the shooting operation based on the focused image, thereby outputting the final photograph. The entire workflow is completed sequentially through the two steps of “Focusing” and “Shooting,” ensuring that the image has achieved clear focus before shooting and resulting in high-quality photo output. The system operation process is concise and coherent, enabling users to efficiently obtain the desired photographs.",
    "design": "package 'PhotographyWorkflow' {\n\titem def Scene;\n\titem def Image;\n\titem def Picture;\n\taction def Focus { in scene : Scene; out image : Image; }\n\taction def Shoot { in image: Image; out picture : Picture; }\t\t\t\n\taction def TakePicture {\n\t\tin item scene : Scene;\n\t\tout item picture : Picture;\n\t\taction focus: Focus {\n\t\t\tin item scene = TakePicture::scene;\n\t\t\tout item image;\n\t\t}\n\t\tflow from focus.image to shoot.image;\n\t\tthen action shoot: Shoot {\n\t\t\tin item;\n\t\t\tout item picture = TakePicture::picture;\n\t\t}\n\t}\n}",
    "domain": "Photography Technique",
    "grammar": "Action Definition",
    "diagram": "dataset/sysml/samples/19/design.png"
  },
  {
    "nl": "This system is designed to support photography workflows, allowing users to frame and capture a scene. First, the user selects a specific scene, and the system performs a focusing process on the selected scene to generate an image. Then, based on this image, the system carries out the shooting process to produce a final photograph. The overall workflow automatically completes the focusing and shooting steps, ensuring that users can conveniently convert the scenes they see into high-quality photographs without manually handling intermediate image processing and conversion tasks.",
    "design": "package 'PhotographyWorkflow' {\n\titem def Scene;\n\titem def Image;\n\titem def Picture;\n\taction def Focus { in scene : Scene; out image : Image; }\n\taction def Shoot { in image: Image; out picture : Picture; }\t\n\taction def TakePicture {\n\t\tin item scene : Scene;\n\t\tout item picture : Picture;\n\t\tbind focus.scene = scene;\n\t\taction focus: Focus { in scene; out image; }\n\t\tflow from focus.image to shoot.image;\n\t\tfirst focus then shoot;\n\t\taction shoot: Shoot { in image; out picture; }\n\t\tbind shoot.picture = picture;\n\t}\n}",
    "domain": "Photography Technique",
    "grammar": "Action Definition",
    "diagram": "dataset/sysml/samples/20/design.png"
  },
  {
    "nl": "This system is designed to automate the photography process. Users only need to provide a shooting scene, and the system will first perform focus processing on the scene to generate an image suitable for shooting. It will then convert the image into a photograph through a shooting operation. The entire process is seamlessly integrated, requiring no in-depth user intervention in focusing or shooting details. This simplifies the photography workflow, helping users obtain the final photograph easily and efficiently.",
    "design": "package 'PhotographyWorkflow' {\n\titem def Scene;\n\titem def Image;\n\titem def Picture;\n\taction def Focus { in scene : Scene; out image : Image; }\n\taction def Shoot { in image: Image; out picture : Picture; }\t\n\taction def TakePicture {\n\t\tin item scene : Scene;\n\t\tout item picture : Picture;\n\t\tbind focus.scene = scene;\n\t\taction focus: Focus { in scene; out image; }\n\t\tsuccession flow from focus.image to shoot.image;\n\t\taction shoot: Shoot { in image; out picture; }\n\t\tbind shoot.picture = picture;\n\t}\n}",
    "domain": "Photography Technique",
    "grammar": "Action Definition",
    "diagram": "dataset/sysml/samples/21/design.png"
  },
  {
    "nl": "In this system, users can complete the entire photography process—from composition to imaging to photo output—through a software package called \"PhotographyWorkflow.\" When a user needs to take a photograph, the system first focuses (Focus) on the captured scene (Scene) to generate a frame of image (Image). The system then performs a shooting (Shoot) operation on the focused image to ultimately produce a photograph (Picture). Users only need to input the desired scene to be photographed; the system will automatically complete the focusing and imaging operations and directly output the required photograph, thereby realizing an automated and streamlined photography workflow.",
    "design": "package 'PhotographyWorkflow' {\n\tpart def Scene;\n\tpart def Image;\n\tpart def Picture;\n\taction def Focus { in scene : Scene; out image : Image; }\n\taction def Shoot { in image: Image; out picture : Picture; }\t\n\taction def TakePicture { in scene : Scene; out picture : Picture; }\n\taction takePicture : TakePicture {\n\t\tin item scene;\n\t\tout item picture;\n\t\taction focus : Focus {\n\t\t\tin item scene = takePicture::scene; \n\t\t\tout item image;\n\t\t}\n\t\tflow from focus.image to shoot.image;\n\t\taction shoot : Shoot {\n\t\t\tin item; \n\t\t\tout item picture = takePicture::picture;\n\t\t}\n\t}\n}",
    "domain": "Photography Technique",
    "grammar": "Action",
    "diagram": "dataset/sysml/samples/22/design.png"
  },
  {
    "nl": "This system is designed to support the photography workflow, allowing users to select a scene and capture it as a photograph. In the shooting process, the selected scene is first focused to ensure optimal image sharpness. If the camera detects that the focus is clear, it will proceed to take the photo, generating the final image. The entire process automatically performs focusing and shooting operations in sequence, providing users with a convenient one-click shooting experience while ensuring the clarity and quality of the photos.",
    "design": "package 'PhotographyWorkflow' {\n\tpart def Scene;\n\tpart def Image {\n\t\tisWellFocused: ScalarValues::Boolean;\n\t}\n\tpart def Picture;\n\taction def Focus { in scene : Scene; out image : Image; }\n\taction def Shoot { in image: Image; out picture : Picture; }\t\n\taction def TakePicture { in scene : Scene; out picture : Picture; }\n\taction takePicture : TakePicture {\n\t\tin item scene;\n\t\tout item picture;\n\t\taction focus : Focus {\n\t\t\tin item scene = takePicture::scene; \n\t\t\tout item image;\n\t\t}\t\n\t\tfirst focus \n\t\t\tif focus.image.isWellFocused then shoot;\n\t\tflow from focus.image to shoot.image;\n\t\taction shoot : Shoot {\n\t\t\tin item; \n\t\t\tout item picture = takePicture::picture;\n\t\t}\n\t}\n}",
    "domain": "Photography Technique",
    "grammar": "Conditional Succession",
    "diagram": "dataset/sysml/samples/23/design.png"
  },
  {
    "nl": "This system is designed to support users in a workflow for capturing high-quality photographs. Users can select a scene, after which the system first performs focusing on the scene and generates an image that is then evaluated for focus quality. If the image is determined to be well-focused, the system proceeds with the shooting operation, converting the focused image into a photograph and ultimately producing the final photo required by the user. The entire shooting process is automatically linked from scene input to photo output, ensuring that shooting only takes place when the focus is appropriate, thereby improving the clarity and quality of the resulting photographs.",
    "design": "package 'PhotographyWorkflow' {\n\tpart def Scene;\n\tpart def Image {\n\t\tisWellFocused: ScalarValues::Boolean;\n\t}\n\tpart def Picture;\n\taction def Focus { in scene : Scene; out image : Image; }\n\taction def Shoot { in image: Image; out picture : Picture; }\t\n\taction def TakePicture { in scene : Scene; out picture : Picture; }\n\taction takePicture : TakePicture {\n\t\tin item scene;\n\t\tout item picture;\n\t\taction focus : Focus {\n\t\t\tin item scene = takePicture::scene; \n\t\t\tout item image;\n\t\t}\n\t\tif focus.image.isWellFocused then shoot;\n\t\tflow from focus.image to shoot.image;\n\t\taction shoot : Shoot {\n\t\t\tin item image; \n\t\t\tout item picture = takePicture::picture;\n\t\t}\n\t}\n}",
    "domain": "Photography Technique",
    "grammar": "Conditional Succession",
    "diagram": "dataset/sysml/samples/24/design.png"
  },
  {
    "nl": "This system is designed to implement a complete photography workflow. The user only needs to trigger the \"take photo\" operation once, and the system will automatically complete all subsequent steps. First, the system acquires the current shooting scene and inputs it into the focus function, automatically performing the focusing process to generate an image. Then, based on the obtained image, the system executes the shooting operation to produce the final photograph. After the shooting is finished, the system immediately displays the resulting photo, enabling the user to intuitively view the shooting result. The entire process is seamlessly integrated by the system, without requiring manual intervention from the user at each step, greatly improving the convenience and smoothness of photography.",
    "design": "package 'PhotographyWorkflow' {\n\tpart def Scene;\n\tpart def Image;\n\tpart def Picture;\n\taction def Focus { in item scene : Scene; out item image : Image; }\n\taction def Shoot { in item image : Image; out item picture : Picture; }\n\taction def Display { in item picture : Picture; }\n\taction def TakePicture;\n\taction takePicture : TakePicture {\n\t\tfirst start;\n\t\tthen merge continue;\n\t\tthen action trigger {\n\t\t\tout item scene : Scene;\n\t\t}\n\t\tflow from trigger.scene to focus.scene;\n\t\tthen action focus : Focus {\n\t\t\tin item scene;\n\t\t\tout item image;\n\t\t}\n\t\tflow from focus.image to shoot.image;\n\t\tthen action shoot : Shoot {\n\t\t\tin item image ;\n\t\t\tout item picture;\n\t\t}\n\t\tflow from shoot.picture to display.picture;\n\t\tthen action display : Display {\n\t\t\tin item picture;\n\t\t}\n\t\tthen continue;\t\n\t}\n}",
    "domain": "Photography Technique",
    "grammar": "Control Structure",
    "diagram": "dataset/sysml/samples/25/design.png"
  },
  {
    "nl": "This system is designed to provide automatic braking control functions for vehicles. When the user turns the vehicle key to the start position, the system is automatically activated and continuously monitors the status of the brake pedal as well as traction information such as road adhesion. By detecting the brake pressure generated when the driver presses the brake pedal and evaluating traction variations under different road conditions, the system can intelligently adjust the brake pressure and modulation frequency during the braking process. This ensures that the vehicle achieves safe and reliable braking performance under various operating conditions, thereby enhancing driving safety and comfort. The entire process is automatically monitored and dynamically regulated without user intervention, ensuring that the braking system always operates in its optimal state.",
    "design": "package 'VehicleBrakeControl' {\n\tprivate import ScalarValues::*;\n\tattribute def TurnKeyToOn;\n\tattribute def BrakePressure;\n\taction def MonitorBrakePedal { out pressure : BrakePressure; }\n\taction def MonitorTraction { out modFreq : Real; }\n\taction def Braking { in brakePressure : BrakePressure; in modulationFrequency : Real; }\n\taction def Brake {\n\t\taction TurnOn;\n\t\tthen fork;\n\t\t\tthen monitorBrakePedal;\n\t\t\tthen monitorTraction;\n\t\t\tthen braking;\n\t\taction monitorBrakePedal : MonitorBrakePedal {\n\t\t\tout brakePressure;\n\t\t}\n\t\tthen joinNode;\n\t\taction monitorTraction : MonitorTraction {\n\t\t\tout modulationFrequency;\n\t\t}\n\t\tthen joinNode;\n\t\tflow from monitorBrakePedal.brakePressure to braking.brakePressure;\n\t\tflow from monitorTraction.modulationFrequency to braking.modulationFrequency; \n\t\taction braking : Braking {\n\t\t\tin brakePressure; \n\t\t\tin modulationFrequency;\n\t\t}\n\t\tthen joinNode;\n\t\tjoin joinNode;\n\t\tthen done;\n\t}\n}",
    "domain": "Vehicle Traffic",
    "grammar": "Control Structure",
    "diagram": "dataset/sysml/samples/26/design.png"
  },
  {
    "nl": "This system is designed for automatic monitoring and control of the battery charging process, ensuring that the battery can be safely and efficiently fully charged. The battery charging control system needs to monitor the current battery level in real time, automatically supplying charge when the battery level is below 100%; when the battery level reaches or exceeds 100%, the charging process is automatically terminated without manual intervention. The core functions of this system include battery capacity monitoring, automatic charging, and charging termination control, aiming to ensure healthy charging of the battery and to enhance convenience and safety of use.",
    "design": "package 'BatteryChargingControl' {\n\tprivate import ScalarValues::*;\n\tattribute def BatteryCharged;\n\tpart battery;\n\tpart powerSystem;\n\taction def MonitorBattery { out charge : Real; }\n\taction def AddCharge { in charge : Real; }\n\taction def EndCharging;\n\taction def ChargeBattery {\n\t\tfirst start;\n\t\tthen merge continueCharging;\n\t\tthen action monitor : MonitorBattery {\n\t\t\tout batteryCharge : Real;\n\t\t}\n\t\tthen decide;\n\t\t\tif monitor.batteryCharge < 100 then addCharge;\n\t\t\tif monitor.batteryCharge >= 100 then endCharging;\n\t\taction addCharge : AddCharge {\n\t\t\tin charge = monitor.batteryCharge;\n\t\t}\n\t\tthen continueCharging;\n\t\taction endCharging : EndCharging;\n\t\tthen done;\n\t}\n}",
    "domain": "Energy materials",
    "grammar": "Control Structure",
    "diagram": "dataset/sysml/samples/27/design.png"
  },
  {
    "nl": "This system is designed to implement continuous monitoring and control during the battery charging process. Once charging begins, the system continuously monitors the current battery level (displayed as a percentage). If the battery level is below 100%, it will automatically replenish the battery. This cycle repeats until the battery level reaches or exceeds 100%, at which point the system automatically terminates the charging process. The entire charging operation is fully automated, requiring no manual intervention, thereby ensuring the battery is safely and reliably fully charged while preventing overcharging.",
    "design": "package 'LoopBasedCharging' {\n\tprivate import ScalarValues::*;\n\tattribute def BatteryCharged;\n\tpart battery;\n\tpart powerSystem;\n\taction def MonitorBattery { out charge : Real; }\n\taction def AddCharge { in charge : Real; }\n\taction def EndCharging;\n\taction def ChargeBattery {\n\t\tloop action charging {\n\t\t\taction monitor : MonitorBattery {\n\t\t\t\tout charge;\n\t\t\t}\n\t\t\tthen if monitor.charge < 100 {\n\t\t\t\taction addCharge : AddCharge {\n\t\t\t\t\tin charge = monitor.charge;\n\t\t\t\t}\n\t\t\t}\t\t\t\t\n\t\t} until charging.monitor.charge >= 100;\n\t\tthen action endCharging : EndCharging;\n\t\tthen done;\n\t}\n}",
    "domain": "Energy materials",
    "grammar": "Control Structure",
    "diagram": "dataset/sysml/samples/28/design.png"
  },
  {
    "nl": "This system is designed to implement a camera function capable of taking photos of various scenes. The system includes automatic focusing on objects within the scene and the imaging process. When the user selects a scene, the camera first obtains a clear and realistic image through the autofocus subsystem. Afterwards, the imaging subsystem captures this image as a photograph. All photos taken are recorded and saved by the system. Users do not need to concern themselves with the internal technical details; they only need to select or confirm the scene to be photographed, and the camera will automatically complete the focusing and imaging operations to generate high-quality photos for the user.",
    "design": "package Camera {\n\tprivate import 'Action Decomposition'::*;\n\tpart def Scene;\n\tpart def Image;\n\tpart def Picture;\n\tpart def Camera;\n\tpart def FocusingSubsystem;\n\tpart def ImagingSubsystem;\n\tpart camera : Camera {\n\t\tref item scene : Scene;\n\t\tpart photos : Picture[*];\n\t\tpart autoFocus {\n\t\t\tin ref item scene : Scene = camera::scene;\t\t\n\t\t\tout ref item realImage : Image;\n\t\t}\n\t\tflow autoFocus.realImage to imager.focusedImage;\n\t\tpart imager {\n\t\t\tin item focusedImage : Image;\t\t\n\t\t\tout item photo : Picture :> photos;\n\t\t}\n\t}\n}",
    "domain": "Photography Technique",
    "grammar": "Control Structure",
    "diagram": "dataset/sysml/samples/29/design.png"
  },
  {
    "nl": "This system is designed to implement the shooting process of a digital camera, enabling users to complete the entire procedure from viewfinding and focusing to imaging with a single, simple operation. Users only need to select the shooting scene; the camera will then automatically focus on the selected scene and generate an image that meets the requirements, after which the imaging module will capture and produce the final photo. The entire shooting process is fully automated without the need for users to manually adjust the focus or initiate imaging. All functional modules collaborate to complete the entire process of shooting and image acquisition, ensuring an efficient and convenient shooting experience and outputting high-quality photos.",
    "design": "package 'PhotoCaptureWorkflow' {\n\tpart def Scene;\n\tpart def Image;\n\tpart def Picture;\n\taction def Focus { in scene : Scene; out image : Image; }\n\taction def Shoot { in image: Image; out picture : Picture; }\t\n\taction def TakePicture { in scene : Scene; out picture : Picture; }\n\taction takePicture : TakePicture {\n\t\tin item scene;\n\t\tout item picture;\n\t\taction focus : Focus {\n\t\t\tin item scene = takePicture::scene; \n\t\t\tout item image;\n\t\t}\n\t\tflow from focus.image to shoot.image;\n\t\taction shoot : Shoot {\n\t\t\tin item; \n\t\t\tout item picture = takePicture::picture;\n\t\t}\n\t}\n\tpart def Camera;\n\tpart def AutoFocus;\n\tpart def Imager;\n\tpart camera : Camera {\n\t\tperform action takePhoto[*] ordered \n\t\t\treferences takePicture;\n\t\tpart f : AutoFocus {\n\t\t\tperform takePhoto.focus;\t\t\t\n\t\t}\n\t\tpart i : Imager {\n\t\t\tperform takePhoto.shoot;\n\t\t}\t\t\n\t}\n}",
    "domain": "Photography Technique",
    "grammar": "Action",
    "diagram": "dataset/sysml/samples/30/design.png"
  },
  {
    "nl": "This system is designed to simulate a vehicle with a known mass moving along a one-dimensional straight path, predicting its position over time based on a given time-varying power input sequence. Users are required to provide the vehicle's mass, initial position, initial velocity, the time interval of each simulation step, as well as the power input at each time step. The system sequentially calculates the vehicle's speed and position at each moment according to the input data, and outputs the trajectory of the vehicle's position at each time step. This helps users analyze the vehicle's motion behavior under different power inputs.",
    "design": "package 'KinematicMotionSimulation' {\n\tprivate import SequenceFunctions::*;\n    action def StraightLineDynamics {\n        in power : ISQ::PowerValue;\n        in mass : ISQ::MassValue;\n        in delta_t : ISQ::TimeValue;\n        in x_in : ISQ::LengthValue;\n        in v_in : ISQ::SpeedValue;\n        out x_out : ISQ::LengthValue;\n        out v_out : ISQ::SpeedValue;\n    }\n\taction def ComputeMotion {\n\t\tin attribute powerProfile :> ISQ::power[*];\n\t\tin attribute vehicleMass :> ISQ::mass;\n\t\tin attribute initialPosition :> ISQ::length;\n\t\tin attribute initialSpeed :> ISQ::speed;\n\t\tin attribute deltaT :> ISQ::time;\n\t\tout attribute positions :> ISQ::length[*] := ( );\n\t\tprivate attribute position := initialPosition;\n\t\tprivate attribute speed := initialSpeed;\n\t\tfor i in 1..powerProfile->size() {\n\t\t\tperform action dynamics : StraightLineDynamics {\n\t\t\t\tin power = powerProfile#(i);\n\t\t\t\tin mass = vehicleMass;\n\t\t\t\tin delta_t = deltaT;\n\t\t\t\tin x_in = position;\n\t\t\t\tin v_in = speed;\n\t\t\t\tout x_out;\n\t\t\t\tout v_out;\n\t\t\t}\n\t\t\tthen assign position := dynamics.x_out;\n\t\t\tthen assign speed := dynamics.v_out;\n\t\t\tthen assign positions := positions->including(position);\n\t\t}\n\t}\n}",
    "domain": "Simulation Calculation",
    "grammar": "Assignment Action",
    "diagram": "dataset/sysml/samples/31/design.png"
  },
  {
    "nl": "This system is designed to implement basic camera shooting and display functionality. While framing, the user can input the current scene into the system. The system first performs a focusing process on the scene to obtain an image; then, it captures the obtained image to generate a photo. Finally, the system automatically displays the captured photo on the screen, allowing the user to view the shooting result immediately. The entire process ensures that scene processing, image generation, and photo display are seamlessly and automatically integrated. The user only needs to perform a simple shooting operation to obtain a complete experience of photographing and viewing the result.",
    "design": "package 'CameraMessagingSystem' {\n\titem def Scene;\n\titem def Image;\n\titem def Picture;\n\tattribute def Show {\n\t\titem picture : Picture;\n\t}\n\taction def Focus { in item scene : Scene; out item image : Image; }\n\taction def Shoot { in item image : Image; out item picture : Picture; }\n\taction def TakePicture;\n\taction screen;\n\taction takePicture : TakePicture {\n\t\taction trigger accept scene : Scene;\n\t\tthen action focus : Focus {\n\t\t\tin item scene = trigger.scene;\n\t\t\tout item image;\n\t\t}\n\t\tflow from focus.image to shoot.image;\n\t\tthen action shoot : Shoot {\n\t\t\tin item image; \n\t\t\tout item picture;\n\t\t}\n\t\tthen send Show(shoot.picture) to screen;\n\t}\n}",
    "domain": "Photography Technique",
    "grammar": "Message",
    "diagram": "dataset/sysml/samples/32/design.png"
  },
  {
    "nl": "The system is designed to implement a camera information processing workflow. When a user selects a scene through the camera’s viewfinder (viewPort), the system first focuses on the scene to obtain an image (Image). This image is then captured to generate a photograph (Picture). After the photograph is generated, the system displays it on the screen via the display port (displayPort). The user does not need to be concerned with specific technical details during operation and only needs to complete scene selection and shooting. The system will automatically handle the processes of focusing, capturing, and displaying the photograph.",
    "design": "package 'CameraMessagingSystem' {\n\titem def Scene;\n\titem def Image;\n\titem def Picture;\n\tattribute def Show {\n\t\titem picture : Picture;\n\t}\n\taction def Focus { in item scene : Scene; out item image : Image; }\n\taction def Shoot { in item image : Image; out item picture : Picture; }\n\taction def TakePicture;\n\tpart screen {\n\t\tport displayPort;\n\t}\n\tpart camera {\n\t\tport viewPort;\n\t\tport displayPort;\n\t\taction takePicture : TakePicture {\n\t\t\taction trigger accept scene : Scene via viewPort;\n\t\t\tthen action focus : Focus {\n\t\t\t\tin item scene = trigger.scene;\n\t\t\t\tout item image;\n\t\t\t}\n\t\t\tflow from focus.image to shoot.image;\n\t\t\tthen action shoot : Shoot {\n\t\t\t\tin item image; \n\t\t\t\tout item picture;\n\t\t\t}\n\t\t\tthen send Show(shoot.picture) via displayPort;\n\t\t}\n\t}\n}",
    "domain": "Photography Technique",
    "grammar": "Message",
    "diagram": "dataset/sysml/samples/33/design.png"
  },
  {
    "nl": "The system needs to be capable of managing multiple sensors and support monitoring and updating the status of these sensors. When the system detects that any sensor is in a ready state, it should automatically perform an update operation on that sensor. The system should be able to automatically traverse all registered sensors and promptly process and maintain each sensor that meets the ready condition, thereby ensuring that all available sensors are kept up-to-date. This will enhance the overall responsiveness and reliability of the system.",
    "design": "package 'OpaqueSensorManager' {\n\tpart def Sensor {\n\t\tattribute ready : ScalarValues::Boolean;\n\t}\n\taction def UpdateSensors {\n\t\tin sensors : Sensor[*];\n\t\tlanguage \"Alf\" \n\t\t\t/* \n\t\t\t * for (sensor in sensors) {\n\t\t\t *     if (sensor.ready) {\n\t\t\t *         Update(sensor);\n\t\t\t *     }\n\t\t\t * }\n\t\t\t */\n\t}\n}",
    "domain": "Embedded device",
    "grammar": "Opaque Action",
    "diagram": "dataset/sysml/samples/34/design.png"
  },
  {
    "nl": "This system is used to manage the start-up and shutdown states of a vehicle. The vehicle is initially in the off state. Upon receiving a \"vehicle start signal,\" the vehicle switches to the \"starting\" state. Subsequently, when a \"vehicle power-on signal\" is received, the vehicle transitions to the \"on\" state. At any time, if a \"vehicle shutdown signal\" is received, the vehicle state switches back to the \"off\" state. The system must, according to the above logic, reliably ensure that the vehicle state responds appropriately to the corresponding control signals, and safely and sequentially transitions between each state.",
    "design": "package 'VehicleStateManagement' {\n\tattribute def VehicleStartSignal;\n\tattribute def VehicleOnSignal;\n\tattribute def VehicleOffSignal;\n\tstate def VehicleStates {\n\t\tentry; then off;\n\t\tstate off;\n\t\ttransition off_to_starting\n\t\t\tfirst off\n\t\t\taccept VehicleStartSignal \n\t\t\tthen starting;\n\t\tstate starting;\n\t\ttransition starting_to_on\n\t\t\tfirst starting\n\t\t\taccept VehicleOnSignal\n\t\t\tthen on;\n\t\tstate on;\n\t\ttransition on_to_off\n\t\t\tfirst on\n\t\t\taccept VehicleOffSignal\n\t\t\tthen off;\n\t}\n}",
    "domain": "Vehicle Traffic",
    "grammar": "State Definition",
    "diagram": "dataset/sysml/samples/35/design.png"
  },
  {
    "nl": "This system is primarily used to manage the operational status of a vehicle, enabling the vehicle to automatically switch states according to different control signals. When entering the system for the first time, the vehicle is in the \"off\" state. If a \"VehicleStartSignal\" is received at this time, the system will switch to the \"starting\" state. Next, upon receiving a \"VehicleOnSignal,\" the system will enter the \"on\" (running) state. During vehicle operation, as soon as a \"VehicleOffSignal\" is received, the vehicle status will return to the \"off\" state. This entire process realizes automatic state management from shut down, through starting, to running, and then back to shut down, allowing users to comprehensively control and monitor the vehicle.",
    "design": "package 'VehicleStateManagement' {\n\tattribute def VehicleStartSignal;\n\tattribute def VehicleOnSignal;\n\tattribute def VehicleOffSignal;\n\tstate def VehicleStates {\n\t\tentry; then off;\n\t\tstate off;\n\t\taccept VehicleStartSignal \n\t\t\tthen starting;\n\t\tstate starting;\n\t\taccept VehicleOnSignal\n\t\t\tthen on;\n\t\tstate on;\n\t\taccept VehicleOffSignal\n\t\t\tthen off;\n\t}\n}",
    "domain": "Vehicle Traffic",
    "grammar": "State Definition",
    "diagram": "dataset/sysml/samples/36/design.png"
  },
  {
    "nl": "This system is designed to manage the power status of a vehicle, enabling automatic switching between different operating states according to various control signals. When the user sends a vehicle start command, the system switches the vehicle from the off state to the start phase, and upon receiving the vehicle started signal, it enters the vehicle powered-on state. During the powered-on period, the system automatically performs self-diagnosis operations and continuously supplies power to various functional units of the vehicle. When the user issues a vehicle shutdown command, the system automatically executes safety operations such as parking brake engagement and returns the vehicle to the off state to cut off the power supply, ensuring safety. This entire process realizes intelligent control and state management of the vehicle's power supply, thereby enhancing the convenience and safety of vehicle use.",
    "design": "package 'VehiclePowerManagement' {\n\tattribute def VehicleStartSignal;\n\tattribute def VehicleOnSignal;\n\tattribute def VehicleOffSignal;\n\tpart def Vehicle;\n\taction performSelfTest { in vehicle : Vehicle; }\n\tstate def VehicleStates { in operatingVehicle : Vehicle; }\n\tstate vehicleStates : VehicleStates {\n\t\tin operatingVehicle : Vehicle;\n\t\tentry; then off;\n\t\tstate off;\n\t\taccept VehicleStartSignal \n\t\t\tthen starting;\n\t\tstate starting;\n\t\taccept VehicleOnSignal\n\t\t\tthen on;\n\t\tstate on {\n\t\t\tentry performSelfTest{ in vehicle = operatingVehicle; }\n\t\t\tdo action providePower { /* ... */ }\n\t\t\texit action applyParkingBrake { /* ... */ }\n\t\t}\n\t\taccept VehicleOffSignal\n\t\t\tthen off;\n\t}\t\n}",
    "domain": "Vehicle Traffic",
    "grammar": "State",
    "diagram": "dataset/sysml/samples/37/design.png"
  },
  {
    "nl": "The system shall be capable of managing the vehicle’s start-up, operation, and shutdown processes. When the user issues a vehicle start signal while the vehicle is in the shutdown state, the vehicle should enter the start-up state. Upon receiving a vehicle started signal, the system shall set the vehicle status to running. If the user issues a vehicle shutdown signal during operation, the vehicle status shall return to shutdown. The system must accurately respond to the corresponding signals, enabling automatic switching among the three main states—shutdown, start-up, and running—so that the user can conveniently and safely control the vehicle’s start and stop processes.",
    "design": "package 'VehiclePowerManagement' {\n\tattribute def VehicleStartSignal;\n\tattribute def VehicleOnSignal;\n\tattribute def VehicleOffSignal;\n\tstate def VehicleStates;\n\tstate vehicleStates : VehicleStates {\n\t\tentry; then off;\n\t\tstate off;\n\t\taccept VehicleStartSignal \n\t\t\tthen starting;\n\t\tstate starting;\n\t\taccept VehicleOnSignal\n\t\t\tthen on;\n\t\tstate on;\n\t\taccept VehicleOffSignal\n\t\t\tthen off;\n\t}\n}",
    "domain": "Vehicle Traffic",
    "grammar": "State",
    "diagram": "dataset/sysml/samples/38/design.png"
  },
  {
    "nl": "This system is designed to implement power management for vehicles. The vehicle has multiple operating states, including Off, Start, and On. Under normal circumstances, the vehicle remains in the Off state. The user can switch the vehicle from the Off state to the Start state by issuing a start signal. Once the startup is complete and the vehicle receives an On signal, it transitions to the On state. While in the On state, the user can switch the vehicle back to the Off state by issuing an off signal. The system must ensure that the vehicle’s operating state can be switched accurately and promptly in accordance with the various control signals issued by the user, thus meeting the power management needs during daily use. Meanwhile, the system also reserves functionality for health state management to allow for future expansion of vehicle health monitoring capabilities.",
    "design": "package 'VehiclePowerManagement' {\n\tattribute def VehicleStartSignal;\n\tattribute def VehicleOnSignal;\n\tattribute def VehicleOffSignal;\n\tstate def VehicleStates;\n\tstate vehicleStates : VehicleStates parallel {\n\t\tstate operationalStates {\n\t\t\tentry; then off;\n\t\t\tstate off;\n\t\t\taccept VehicleStartSignal \n\t\t\t\tthen starting;\n\t\t\tstate starting;\n\t\t\taccept VehicleOnSignal\n\t\t\t\tthen on;\n\t\t\tstate on;\n\t\t\taccept VehicleOffSignal\n\t\t\t\tthen off;\n\t\t}\n\t\tstate healthStates { \n\t\t\t/* ... */\n\t\t}\n\t}\n}",
    "domain": "Vehicle Traffic",
    "grammar": "State",
    "diagram": "dataset/sysml/samples/39/design.png"
  },
  {
    "nl": "This system is designed to enable intelligent monitoring and management of vehicle health status. During normal operation, the system automatically senses the current vehicle temperature and compares it with the preset maximum allowable temperature. If the vehicle temperature exceeds the maximum allowable value, the system promptly sends an over-temperature warning to the vehicle controller and switches the vehicle health status to \"degraded\" mode; when the temperature returns to a safe range, the status automatically reverts to normal. In addition, the vehicle undergoes periodic maintenance at scheduled intervals. When the specified maintenance time is reached, the system automatically enters maintenance status, and after maintenance is completed, the next maintenance cycle time is updated. After the maintenance status has lasted for 48 hours, the vehicle automatically returns to normal operating status. This system operates automatically, helping users to detect and address vehicle over-temperature and maintenance needs in a timely manner, thereby enhancing the safety and reliability of vehicle operation and reducing manual intervention.",
    "design": "package 'VehicleHealthMonitoring' {\n\tprivate import ISQ::TemperatureValue;\n\tprivate import ISQ::DurationValue;\n\tprivate import Time::TimeInstantValue;\n\tprivate import SI::h;\n\tattribute def OverTemp;\n\tpart def Vehicle {\n\t\tattribute maintenanceTime : TimeInstantValue;\n\t\tattribute maintenanceInterval : DurationValue;\n\t\tattribute maxTemperature : TemperatureValue;\n\t}\n\tpart def VehicleController;\n\taction senseTemperature { out temp : TemperatureValue; }\n\tstate healthStates {\n\t\tin vehicle : Vehicle;\n\t\tin controller : VehicleController;\n\t\tentry; then normal;\n\t\tdo senseTemperature;\n\t\tstate normal;\n\t\taccept at vehicle.maintenanceTime\n\t\t\tthen maintenance;\n\t\taccept when senseTemperature.temp > vehicle.maxTemperature\n\t\t\tdo send OverTemp() to controller \n\t\t\tthen degraded;\n\t\tstate maintenance {\n\t\t\tentry assign vehicle.maintenanceTime := vehicle.maintenanceTime + vehicle.maintenanceInterval;\n\t\t}\n\t\taccept after 48 [h]\n\t\t\tthen normal;\n\t\tstate degraded;\n\t\taccept when senseTemperature.temp <= vehicle.maxTemperature\n\t\t\tthen normal;\n\t}\n}",
    "domain": "Vehicle Traffic",
    "grammar": "Transition",
    "diagram": "dataset/sysml/samples/40/design.png"
  },
  {
    "nl": "The system implements a server that exhibits timed clock behavior. The server features a local clock and a port for receiving requests. After startup, the server initially enters the “off” state and requires a “start” command received through the request port to transition into the waiting state. In the waiting state, the server can receive “request” messages, upon which it switches to the response state. In the response state, the server waits for five minutes before reverting back to the waiting state. Additionally, every day at 11:59:00, the server automatically switches back to the off state. The system supports multiple periodic request and response cycles within a single day and can automatically manage its power state according to the preset schedule, thereby ensuring controllable response timing and orderly service operations.",
    "design": "package 'TimedClockBehavior' {\n\tprivate import ScalarValues::String;\n\titem def Start;\n\titem def Request;\n\tpart def Server {\n\t\tpart :>> localClock = Time::Clock();\n\t\tattribute today : String;\n\t\tport requestPort;\n\t\tstate ServerBehavior {\n\t\t\tentry; then off;\n\t\t\tstate off;\n\t\t\taccept Start via requestPort\n\t\t\t\tthen waiting;\n\t\t\tstate waiting;\n\t\t\taccept request : Request via requestPort\n\t\t\t\tthen responding;\n\t\t\taccept at Time::Iso8601DateTime(today + \"11:59:00\")\n\t\t\t\tthen off;\n\t\t\tstate responding;\n\t\t\taccept after 5 [SI::min]\n\t\t\t\tthen waiting;\n\t\t}\n\t}\n}",
    "domain": "Network Communication",
    "grammar": "Transition",
    "diagram": "dataset/sysml/samples/41/design.png"
  },
  {
    "nl": "This system is used to control the vehicle’s start-stop process. The vehicle is initially in the off state. Upon receiving a \"start signal,\" it enters the start process. During startup, the system will only respond to the \"power-on signal\" after detecting that the brake pedal has been depressed, and will simultaneously send a start signal to the controller. Once the vehicle enters the operating state, it will automatically perform a self-check and continuously supply power to the vehicle. When a \"stop signal\" is received, the process returns the vehicle to the off state. Upon leaving the operating state, the parking brake will be automatically applied to ensure parking safety. The overall system is designed to ensure the safety and reliability of the vehicle’s start-stop process, as well as coordinated control with the controller.",
    "design": "package 'VehicleControlSignals' {\n\tattribute def VehicleStartSignal;\n\tattribute def VehicleOnSignal;\n\tattribute def VehicleOffSignal;\n\tattribute def ControllerStartSignal;\n\tpart def Vehicle {\n\t\tbrakePedalDepressed : ScalarValues::Boolean;\n\t}\n\tpart def VehicleController;\n\taction performSelfTest { in vehicle : Vehicle; }\n\tstate def VehicleStates;\n\tstate vehicleStates : VehicleStates {\n\t\tin operatingVehicle : Vehicle;\n\t\tin controller : VehicleController;\n\t\tentry; then off;\n\t\tstate off;\n\t\taccept VehicleStartSignal \n\t\t\tthen starting;\n\t\tstate starting;\n\t\taccept VehicleOnSignal\n\t\t\tif operatingVehicle.brakePedalDepressed\n\t\t\tdo send ControllerStartSignal() to controller\n\t\t\tthen on;\n\t\tstate on {\n\t\t\tentry performSelfTest{ in vehicle = operatingVehicle; }\n\t\t\tdo action providePower { /* ... */ }\n\t\t\texit action applyParkingBrake { /* ... */ }\n\t\t}\n\t\taccept VehicleOffSignal\n\t\t\tthen off;\n\t}\n}",
    "domain": "Vehicle Traffic",
    "grammar": "Transition",
    "diagram": "dataset/sysml/samples/42/design.png"
  },
  {
    "nl": "This system is used for controlling vehicle start-stop and status management, enabling automated control of vehicle start-up, operation, and shutdown. When the driver prepares to start the vehicle, the system is initially in the off state and enters the start-up process upon receiving the vehicle start signal. If the brake pedal is depressed and a vehicle-on signal is received, the system will send a start control signal to the vehicle controller, allowing the vehicle to formally enter the \"started\" state. While the vehicle is in the started state, the system will automatically perform a self-check and continuously supply power to the vehicle; when the vehicle needs to be shut down, the system receives a shutdown signal, switches the vehicle state to off, and ensures that the parking brake is applied before shutdown to ensure safety. The entire process ensures that the vehicle can only be started and operated under the correct conditions, and that safety measures are automatically taken during shutdown, effectively improving the convenience and safety of vehicle operation.",
    "design": "package 'VehicleStateControlSystem' {\n\tprivate import 'Transition Actions'::*;\n\tattribute def VehicleStartSignal;\n\tattribute def VehicleOnSignal;\n\tattribute def VehicleOffSignal;\n\tattribute def ControllerStartSignal;\n\tpart def Vehicle {\n\t\tbrakePedalDepressed : ScalarValues::Boolean;\n\t}\n\tpart def VehicleController;\n\taction performSelfTest { in vehicle : Vehicle; }\n\tstate def VehicleStates;\n\tstate vehicleStates : VehicleStates {\n\t\tin operatingVehicle : Vehicle;\n\t\tin controller : VehicleController;\n\t\tentry; then off;\n\t\tstate off;\n\t\taccept VehicleStartSignal \n\t\t\tthen starting;\n\t\tstate starting;\n\t\taccept VehicleOnSignal\n\t\t\tif operatingVehicle.brakePedalDepressed\n\t\t\tdo send ControllerStartSignal() to controller\n\t\t\tthen on;\n\t\tstate on {\n\t\t\tentry performSelfTest{ in vehicle = operatingVehicle; }\n\t\t\tdo action providePower { /* ... */ }\n\t\t\texit action applyParkingBrake { /* ... */ }\n\t\t}\n\t\taccept VehicleOffSignal\n\t\t\tthen off;\n\t}\n\tpart vehicle : Vehicle {\n\t\tpart vehicleController : VehicleController;\n\t\texhibit vehicleStates {\n\t\t\tin operatingVehicle = vehicle;\n\t\t\tin controller = vehicleController;\n\t\t}\n\t}\n}",
    "domain": "Vehicle Traffic",
    "grammar": "State",
    "diagram": "dataset/sysml/samples/43/design.png"
  },
  {
    "nl": "This system is a cruise control system, mainly composed of the driver, cruise controller, speedometer, engine, and vehicle, among other components. The driver activates the cruise function by sending a command to set the desired speed. The cruise controller inside the vehicle receives this set-speed command and subsequently obtains the actual vehicle speed information from the speedometer. Based on these inputs, the cruise controller generates and sends corresponding fuel control commands to the engine. The speedometer collects the real-time speed of the vehicle and transmits this information to the cruise controller, while the engine adjusts its output according to the received fuel control commands to ensure the vehicle travels at the set speed. The aforementioned modules exchange information through events to realize the cruise control function as expected by the driver.",
    "design": "package 'CruiseControlEventFlow' {\t\n\tpart def Driver;\n\tpart def CruiseController;\n\tpart def Speedometer;\n\tpart def Engine;\n\tpart def Vehicle;\n\tpart driver : Driver {\n\t\tevent occurrence setSpeedSent;\n\t}\n\tpart vehicle : Vehicle {\n\t\tpart cruiseController : CruiseController {\n\t\t\tevent occurrence setSpeedReceived;\t\t\n\t\t\tthen event occurrence sensedSpeedReceived;\t\t\n\t\t\tthen event occurrence fuelCommandSent;\n\t\t}\n\t\tpart speedometer : Speedometer {\n\t\t\tevent occurrence sensedSpeedSent;\n\t\t}\n\t\tpart engine : Engine {\n\t\t\tevent occurrence fuelCommandReceived;\n\t\t}\n\t}\n}",
    "domain": "Vehicle Traffic",
    "grammar": "Occurrence",
    "diagram": "dataset/sysml/samples/44/design.png"
  },
  {
    "nl": "This system is designed to implement the cruise control function for vehicles. The driver can send a set speed command to the cruise controller through operation. After receiving the set speed, the cruise controller acquires the real-time vehicle speed information from the speedometer. Subsequently, the cruise controller generates a corresponding throttle control command based on the difference between the actual vehicle speed and the set speed, and sends this command to the engine system to adjust the vehicle's power output, thereby achieving automatic control of the vehicle speed. The entire process realizes the automatic response to the driver's intent, improving driving comfort and safety.",
    "design": "package 'CruiseControlProtocol' {\n\tpart def Driver;\n\tpart def CruiseController;\n\tpart def Speedometer;\n\tpart def Engine;\n\tpart def Vehicle;\n\tpart driver : Driver {\n\t\tevent occurrence setSpeedSent;\n\t}\n\tpart vehicle : Vehicle {\n\t\tpart cruiseController : CruiseController {\n\t\t\tevent occurrence setSpeedReceived;\t\t\n\t\t\tthen event occurrence sensedSpeedReceived;\t\t\n\t\t\tthen event occurrence fuelCommandSent;\n\t\t}\n\t\tpart speedometer : Speedometer {\n\t\t\tevent occurrence sensedSpeedSent;\n\t\t}\n\t\tpart engine : Engine {\n\t\t\tevent occurrence fuelCommandReceived;\n\t\t}\n\t}\n\titem def SetSpeed;\n\titem def SensedSpeed;\n\titem def FuelCommand;\n\toccurrence def CruiseControlInteraction {\t\t\n\t\tref part :>> driver;\t\t\n\t\tref part :>> vehicle;\n\t\tmessage setSpeedMessage of SetSpeed \n\t\t\tfrom driver.setSpeedSent to vehicle.cruiseController.setSpeedReceived;\n\t\tmessage sensedSpeedMessage of SensedSpeed \n\t\t\tfrom vehicle.speedometer.sensedSpeedSent to vehicle.cruiseController.sensedSpeedReceived;\n\t\tmessage fuelCommandMessage of FuelCommand \n\t\t\tfrom vehicle.cruiseController.fuelCommandSent to vehicle.engine.fuelCommandReceived;\n\t\tfirst setSpeedMessage then sensedSpeedMessage;\n\t}\n}",
    "domain": "Vehicle Traffic",
    "grammar": "Occurrence",
    "diagram": "dataset/sysml/samples/45/design.png"
  },
  {
    "nl": "This system is designed to implement an automotive cruise control function. The driver sends a set speed command to the system via the in-vehicle control interface. After receiving this command, the cruise controller compares the set speed with the current vehicle speed information provided by the speed sensor (speedometer). Upon obtaining the current vehicle speed, the cruise controller calculates the difference between the set speed and the actual speed, generates the corresponding throttle control command, and sends it to the engine. This adjusts the engine output to maintain or reach the set speed. Throughout this process, the driver, cruise controller, speedometer, and engine work together through message transmission. As a result, after the driver sets the target speed, the vehicle can automatically maintain that speed without the driver needing to continuously operate the accelerator pedal.",
    "design": "package 'CruiseControlProtocol' {\n\tpart def Driver;\n\tpart def CruiseController;\n\tpart def Speedometer;\n\tpart def Engine;\n\tpart def Vehicle;\n\tpart driver : Driver {\n\t\tevent occurrence setSpeedSent;\n\t}\n\tpart vehicle : Vehicle {\n\t\tpart cruiseController : CruiseController {\n\t\t\tevent occurrence setSpeedReceived;\t\t\n\t\t\tthen event occurrence sensedSpeedReceived;\t\t\n\t\t\tthen event occurrence fuelCommandSent;\n\t\t}\n\t\tpart speedometer : Speedometer {\n\t\t\tevent occurrence sensedSpeedSent;\n\t\t}\n\t\tpart engine : Engine {\n\t\t\tevent occurrence fuelCommandReceived;\n\t\t}\n\t}\n\titem def SetSpeed;\n\titem def SensedSpeed;\n\titem def FuelCommand;\n\toccurrence def CruiseControlInteraction {\n\t\tref part driver : Driver {\n\t\t\tevent setSpeedMessage.sourceEvent;\n\t\t}\n\t\tref part vehicle : Vehicle {\n\t\t\tpart cruiseController : CruiseController {\n\t\t\t\tevent setSpeedMessage.targetEvent;\t\t\n\t\t\t\tthen event sensedSpeedMessage.targetEvent;\t\t\n\t\t\t\tthen event fuelCommandMessage.sourceEvent;\n\t\t\t}\n\t\t\tpart speedometer : Speedometer {\n\t\t\t\tevent sensedSpeedMessage.sourceEvent;\n\t\t\t}\n\t\t\tpart engine : Engine {\n\t\t\t\tevent fuelCommandMessage.targetEvent;\n\t\t\t}\n\t\t}\n\t\tmessage setSpeedMessage of SetSpeed;\t\n\t\tthen message sensedSpeedMessage of SensedSpeed;\n\t\tmessage fuelCommandMessage of FuelCommand;\n\t}\n}",
    "domain": "Vehicle Traffic",
    "grammar": "Occurrence",
    "diagram": "dataset/sysml/samples/46/design.png"
  },
  {
    "nl": "This system is designed to implement automotive cruise control functionality. When the driver wishes to set the vehicle’s cruising speed, they can send a command specifying the desired speed. Upon receiving this command, the vehicle’s cruise controller calculates and sends appropriate throttle control instructions to the engine based on real-time speed information from the speedometer. This enables the automatic adjustment and maintenance of the vehicle at the set cruising speed.\n\nThe system workflow includes promptly collecting and transmitting the driver’s speed setting request, real-time sensing and feedback of the vehicle speed, and intelligent throttle adjustment by the cruise controller to the engine. The system aims to ensure convenience and comfort for the driver during operation while enabling the vehicle to automatically cruise at the preset speed with accuracy and smoothness.",
    "design": "package 'CruiseControlSystemRealization' {\n\tpart def Driver;\n\tpart def CruiseController;\n\tpart def Speedometer;\n\tpart def Engine;\n\tpart def Vehicle;\n\tpart driver : Driver {\n\t\tevent occurrence setSpeedSent;\n\t}\n\tpart vehicle : Vehicle {\n\t\tpart cruiseController : CruiseController {\n\t\t\tevent occurrence setSpeedReceived;\t\t\n\t\t\tthen event occurrence sensedSpeedReceived;\t\t\n\t\t\tthen event occurrence fuelCommandSent;\n\t\t}\n\t\tpart speedometer : Speedometer {\n\t\t\tevent occurrence sensedSpeedSent;\n\t\t}\n\t\tpart engine : Engine {\n\t\t\tevent occurrence fuelCommandReceived;\n\t\t}\n\t}\n\titem def SetSpeed;\n\titem def SensedSpeed;\n\titem def FuelCommand;\n\toccurrence def CruiseControlInteraction {\t\t\n\t\tref part :>> driver;\t\t\n\t\tref part :>> vehicle;\n\t\tmessage setSpeedMessage of SetSpeed \n\t\t\tfrom driver.setSpeedSent to vehicle.cruiseController.setSpeedReceived;\n\t\tmessage sensedSpeedMessage of SensedSpeed \n\t\t\tfrom vehicle.speedometer.sensedSpeedSent to vehicle.cruiseController.sensedSpeedReceived;\n\t\tmessage fuelCommandMessage of FuelCommand \n\t\t\tfrom vehicle.cruiseController.fuelCommandSent to vehicle.engine.fuelCommandReceived;\n\t\tfirst setSpeedMessage then sensedSpeedMessage;\n\t}\n\tpart driver_a : Driver {\n\t\taction driverBehavior {\n\t\t\taction sendSetSpeed send SetSpeed() to vehicle_a;\n\t\t}\n\t}\n\tpart vehicle_a : Vehicle {\n\t\tpart cruiseController_a : CruiseController {\n\t\t\taction controllerBehavior {\n\t\t\t\taction receiveSetSpeed accept SetSpeed via vehicle_a;\n\t\t\t\tthen action receiveSensedSpeed accept SensedSpeed via cruiseController_a;\n\t\t\t\tthen action sendFuelCommand send FuelCommand() to engine_a;\n\t\t\t}\n\t\t}\t\n\t\tpart speedometer_a : Speedometer {\n\t\t\taction speedometerBehavior {\n\t\t\t\taction sendSensedSpeed send SensedSpeed() to cruiseController_a;\n\t\t\t}\n\t\t}\n\t\tpart engine_a : Engine {\n\t\t\taction engineBehavior {\n\t\t\t\taction receiveFuelCommand accept FuelCommand via engine_a;\n\t\t\t}\n\t\t}\n\t}\n\toccurrence cruiseControlInteraction_a : CruiseControlInteraction {\n\t\tpart :>> driver :>> driver_a {\n\t\t\tevent driverBehavior.sendSetSpeed[1] :>> setSpeedSent;\n\t\t}\t\n\t\tpart :>> vehicle :>> vehicle_a {\n\t\t\tpart :>> cruiseController :>> cruiseController_a {\n\t\t\t\tevent controllerBehavior.receiveSetSpeed[1] :>> setSpeedReceived;\n\t\t\t\tevent controllerBehavior.receiveSensedSpeed[1] :>> sensedSpeedReceived;\n\t\t\t\tevent controllerBehavior.sendFuelCommand[1] :>> fuelCommandSent;\n\t\t\t}\n\t\t\tpart :>> speedometer :>> speedometer_a {\n\t\t\t\tevent speedometerBehavior.sendSensedSpeed[1] :>> sensedSpeedSent;\n\t\t\t}\n\t\t\tpart :>> engine :>> engine_a {\n\t\t\t\tevent engineBehavior.receiveFuelCommand[1] :>> fuelCommandReceived;\n\t\t\t}\n\t\t}\n\t\tmessage :>> setSpeedMessage = driver_a.driverBehavior.sendSetSpeed.sentMessage;\n\t\tmessage :>> sensedSpeedMessage = vehicle_a.speedometer_a.speedometerBehavior.sendSensedSpeed.sentMessage;\n\t\tmessage :>> fuelCommandMessage = vehicle_a.cruiseController_a.controllerBehavior.sendFuelCommand.sentMessage;\n\t}\n}",
    "domain": "Vehicle Traffic",
    "grammar": "Occurrence",
    "diagram": "dataset/sysml/samples/47/design.png"
  },
  {
    "nl": "This system aims to implement an automotive cruise control function that enables the driver to set a target speed through the cruise control interface. The vehicle can automatically detect the current speed and, based on the set target speed, automatically adjust the engine output to maintain steady vehicle speed. When the driver sends a set speed command via the cruise control interface, the instruction is transmitted to the vehicle's cruise controller. The vehicle obtains real-time actual speed information via a speed sensor, and the detected speed information is fed back to the cruise controller. The cruise controller compares the set speed with the actual speed and automatically generates corresponding engine fuel control commands, which are sent to the engine to adjust the vehicle's power so that the driving speed remains as close as possible to the target speed set by the driver. Each component of the system exchanges information such as set speed, speed sensing, and fuel control efficiently and accurately via data ports, ensuring simple driver operation and reliable system operation, and effectively fulfilling the requirements for automatic cruise control.",
    "design": "package 'CruiseControlPort' {\n\tpart def Driver;\n\tpart def CruiseController;\n\tpart def Speedometer;\n\tpart def Engine;\n\tpart def Vehicle;\n\tpart driver : Driver {\n\t\tevent occurrence setSpeedSent;\n\t}\n\tpart vehicle : Vehicle {\n\t\tpart cruiseController : CruiseController {\n\t\t\tevent occurrence setSpeedReceived;\t\t\n\t\t\tthen event occurrence sensedSpeedReceived;\t\t\n\t\t\tthen event occurrence fuelCommandSent;\n\t\t}\n\t\tpart speedometer : Speedometer {\n\t\t\tevent occurrence sensedSpeedSent;\n\t\t}\n\t\tpart engine : Engine {\n\t\t\tevent occurrence fuelCommandReceived;\n\t\t}\n\t}\n\titem def SetSpeed;\n\titem def SensedSpeed;\n\titem def FuelCommand;\n\toccurrence def CruiseControlInteraction {\t\t\n\t\tref part :>> driver;\t\t\n\t\tref part :>> vehicle;\n\t\tmessage setSpeedMessage of SetSpeed \n\t\t\tfrom driver.setSpeedSent to vehicle.cruiseController.setSpeedReceived;\n\t\tmessage sensedSpeedMessage of SensedSpeed \n\t\t\tfrom vehicle.speedometer.sensedSpeedSent to vehicle.cruiseController.sensedSpeedReceived;\n\t\tmessage fuelCommandMessage of FuelCommand \n\t\t\tfrom vehicle.cruiseController.fuelCommandSent to vehicle.engine.fuelCommandReceived;\n\t\tfirst setSpeedMessage then sensedSpeedMessage;\n\t}\n\tpart driver_b : Driver {\n\t\tport setSpeedPort {\n\t\t\tout setSpeed : SetSpeed;\n\t\t}\n\t}\n\tinterface driverToVehicleInterface connect driver_b.setSpeedPort to vehicle_b.setSpeedPort {\n\t\tflow setSpeedFlow of SetSpeed \n\t\t\tfrom driver_b.setSpeedPort.setSpeed to vehicle_b.setSpeedPort.setSpeed;\n\t}\n\tpart vehicle_b : Vehicle {\n\t\tport setSpeedPort {\n\t\t\tin setSpeed : SetSpeed;\n\t\t}\n\t\tbind setSpeedPort = cruiseController_b.setSpeedPort;\n\t\tpart cruiseController_b : CruiseController {\n\t\t\tport setSpeedPort {\n\t\t\t\tin setSpeed : SetSpeed;\n\t\t\t}\n\t\t\tport sensedSpeedPort {\n\t\t\t\tin sensedSpeed : SensedSpeed;\n\t\t\t}\n\t\t\tport fuelCommandPort {\n\t\t\t\tout fuelCommand : FuelCommand;\n\t\t\t}\n\t\t}\n\t\tflow sensedSpeedFlow of SensedSpeed \n\t\t\tfrom speedometer_b.sensedSpeedPort.sensedSpeed to cruiseController_b.sensedSpeedPort.sensedSpeed;\n\t\tpart speedometer_b : Speedometer {\n\t\t\tport sensedSpeedPort {\n\t\t\t\tout sensedSpeed : SensedSpeed;\n\t\t\t}\n\t\t}\n\t\tflow fuelCommandFlow of FuelCommand \n\t\t\tfrom cruiseController_b.fuelCommandPort.fuelCommand to engine_b.fuelCommandPort.fuelCommand;\n\t\tpart engine_b : Engine {\n\t\t\tport fuelCommandPort {\n\t\t\t\tin fuelCommand : FuelCommand;\n\t\t\t}\n\t\t}\n\t}\n\toccurrence cruiseControlInteraction_b : CruiseControlInteraction {\n\t\tpart :>> driver :>> driver_b {\n\t\t\tport :>> setSpeedPort {\n\t\t\t\tevent driver::setSpeedSent; \n\t\t\t}\n\t\t}\n\t\tpart :>> vehicle :>> vehicle_b {\n\t\t\tpart :>> cruiseController :>> cruiseController_b {\n\t\t\t\tport :>> setSpeedPort {\n\t\t\t\t\tevent cruiseController::setSpeedReceived;\n\t\t\t\t}\n\t\t\t}\n\t\t\tpart :>> speedometer :>> speedometer_b {\n\t\t\t\tport :>> sensedSpeedPort {\n\t\t\t\t\tevent speedometer::sensedSpeedSent;\n\t\t\t\t}\n\t\t\t}\n\t\t\tpart :>> engine :>> engine_b {\n\t\t\t\tport :>> fuelCommandPort {\n\t\t\t\t\tevent engine::fuelCommandReceived;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tmessage :>> setSpeedMessage = driverToVehicleInterface.setSpeedFlow;\n\t\tmessage :>> sensedSpeedMessage = vehicle_b.sensedSpeedFlow;\n\t\tmessage :>> fuelCommandMessage = vehicle_b.fuelCommandFlow;\n\t}\n}",
    "domain": "Vehicle Traffic",
    "grammar": "Occurrence",
    "diagram": "dataset/sysml/samples/48/design.png"
  },
  {
    "nl": "This system is designed to provide a message interaction mechanism for vehicles equipped with cruise control functionality. Drivers can send set speed commands, which are first processed by the cruise controller upon receipt. The cruise controller then reads real-time speed information from the speed sensor (speedometer). Based on the difference between the set speed and the actual speed, the cruise controller calculates and generates a fuel control command. This fuel control command is first transmitted to the engine controller for processing, after which the engine controller forwards the command to the engine to ultimately control fuel flow and achieve speed adjustment and stabilization. Throughout the entire process, each system component communicates and collaborates via standardized message interfaces, thereby ensuring reliable, efficient, and safe operation of the cruise control function.",
    "design": "package 'VehicleMessagePayload' {\n\tpart def Driver;\n\tpart def CruiseController;\n\tpart def Speedometer;\n\tpart def Engine;\n\tpart def Vehicle;\n\tpart driver : Driver {\n\t\tevent occurrence setSpeedSent;\n\t}\n\tpart vehicle : Vehicle {\n\t\tpart cruiseController : CruiseController {\n\t\t\tevent occurrence setSpeedReceived;\t\t\n\t\t\tthen event occurrence sensedSpeedReceived;\t\t\n\t\t\tthen event occurrence fuelCommandSent;\n\t\t}\n\t\tpart speedometer : Speedometer {\n\t\t\tevent occurrence sensedSpeedSent;\n\t\t}\n\t\tpart engine : Engine {\n\t\t\tevent occurrence fuelCommandReceived;\n\t\t}\n\t}\n\titem def SetSpeed;\n\titem def SensedSpeed;\n\titem def FuelCommand {\n\t\tattribute fuelFlow : ScalarValues::Real;\n\t}\n\tpart def EngineController;\n\tpart vehicle1 :> vehicle {\n\t\tpart engineController : EngineController {\n\t\t\tevent occurrence fuelCommandReceived;\n\t\t\tthen event occurrence fuelCommandForwarded;\n\t\t}\n\t}\n\toccurrence def CruiseControlInteraction {\t\t\n\t\tref part :>> driver;\t\t\n\t\tref part vehicle :>> vehicle1;\n\t\tmessage setSpeedMessage of SetSpeed \n\t\t\tfrom driver.setSpeedSent to vehicle.cruiseController.setSpeedReceived;\n\t\tthen message sensedSpeedMessage of SensedSpeed \n\t\t\tfrom vehicle.speedometer.sensedSpeedSent to vehicle.cruiseController.sensedSpeedReceived;\n\t\tthen message fuelCommandMessage of fuelCommand : FuelCommand \n\t\t\tfrom vehicle.cruiseController.fuelCommandSent to vehicle.engineController.fuelCommandReceived;\n\t\tthen message fuelCommandForwardingMessage of fuelCommand : FuelCommand = fuelCommandMessage.fuelCommand\n\t\t\tfrom vehicle.engineController.fuelCommandForwarded to vehicle.engine.fuelCommandReceived;\n\t}\n}",
    "domain": "Vehicle Traffic",
    "grammar": "Occurrence",
    "diagram": "dataset/sysml/samples/49/design.png"
  },
  {
    "nl": "This system is designed to manage and track the entire lifecycle of a vehicle. First, a vehicle will go through the assembly and delivery stages. The specific delivery date must be recorded at the time of delivery for each vehicle. After delivery, the vehicle may undergo multiple ownership changes, each of which requires clearly recording the owner's information and ensuring that each stage can be traced to a unique owner. During each ownership period, different drivers can be tracked and recorded; each driving operation must specify the actual driver. When the vehicle reaches the end-of-use stage, its scrapping (or de-registration) information should also be recorded. The entire system should be able to accurately and comprehensively record and manage all lifecycle-related data from vehicle assembly, delivery, ownership transfer, driving details to final scrapping, and should support inquiry and traceability of relevant information.",
    "design": "package 'VehicleLifecycleTemporalModel' {\n\tattribute def Date;\n\titem def Person;\n\tpart def Vehicle {\n\t\ttimeslice assembly;\n\t\tfirst assembly then delivery;\n\t\tsnapshot delivery {\n\t\t\tattribute deliveryDate : Date;\n\t\t}\n\t\tthen timeslice ownership[0..*] ordered {\n\t\t\tsnapshot sale = start;\n\t\t\tref item owner : Person[1];\n\t\t\ttimeslice driven[0..*] {\n\t\t\t\tref item driver : Person[1];\n\t\t\t}\n\t\t}\n\t\tsnapshot junked = done;\n\t}\n}",
    "domain": "Vehicle Traffic",
    "grammar": "Occurrence",
    "diagram": "dataset/sysml/samples/50/design.png"
  },
  {
    "nl": "This system model describes the composition and basic attributes of a vehicle. The vehicle possesses attributes such as mass and operational status; its operational status includes gear setting and accelerator pedal position. The vehicle consists of an engine and a driver, with the driver being an external reference. The vehicle also contains multiple wheels, such as the left front wheel and right front wheel. In the model, a specific vehicle instance identified as “vehicle_1” is defined, where its left front and right front wheels are associated and described under different time snapshots to facilitate tracking of component status changes over time. This system model supports the management and tracking of vehicle structure, operational status, and key components, making it convenient for users to understand the system and for subsequent functional extensions.",
    "design": "package 'VehicleComposition' {\n\tprivate import ScalarValues::*;\n\tpart def Vehicle {\n\t\tattribute mass : Real;\n\t\tattribute status : VehicleStatus;\n\t\tpart eng : Engine;\n\t\tref part driver : Person;\n\t}\n\tattribute def VehicleStatus {\n\t\tattribute gearSetting : Integer;\n\t\tattribute acceleratorPosition : Real;\n\t}\n\tpart def Engine;\t\n\tpart def Person;\n\tpart def Wheel;\n\tindividual part def Vehicle_1 :> Vehicle {\n\t\tpart leftFrontWheel : Wheel;\n\t\tpart rightFrontWheel : Wheel;\n\t}\n\tindividual part def Wheel_1 :> Wheel;\n\tindividual part vehicle_1 : Vehicle_1 {\n\t\tsnapshot part vehicle_1_t0 {\n\t\t\tsnapshot leftFrontWheel_t0 : Wheel_1 :>> leftFrontWheel;\n\t\t}\n\t\tthen snapshot part vehicle_1_t1 {\n\t\t\tsnapshot rightFrontWheel_t1 : Wheel_1 :>> rightFrontWheel;\n\t\t}\n\t}\n}",
    "domain": "Vehicle Traffic",
    "grammar": "Individual",
    "diagram": "dataset/sysml/samples/51/design.png"
  },
  {
    "nl": "This system is used to describe a composite system comprising vehicles, engines, and drivers, in which each vehicle possesses attributes such as mass and state. The state of a vehicle includes gear setting and accelerator pedal position. The system provides a specific vehicle instance, \"Vehicle_1,\" which has different attributes at two different time points: at the initial moment, the vehicle mass is 2000 kg, the gear is set to 0, and the accelerator position is 0.0; at the next moment, the vehicle mass changes to 1500 kg, the gear is adjusted to 2, and the accelerator position is adjusted to 0.5. The entire system supports describing the relationships among key vehicle components as well as the evolution of their attributes over time, so as to facilitate modeling and analysis of vehicle operational states.",
    "design": "package 'VehicleComposition' {\n\tprivate import ScalarValues::*;\n\tpart def Vehicle {\n\t\tattribute mass : Real;\n\t\tattribute status : VehicleStatus;\n\t\tpart eng : Engine;\n\t\tref part driver : Person;\n\t}\n\tattribute def VehicleStatus {\n\t\tattribute gearSetting : Integer;\n\t\tattribute acceleratorPosition : Real;\n\t}\n\tpart def Engine;\t\n\tpart def Person;\n\tindividual part def Vehicle_1 :> Vehicle {\n\t\tsnapshot part vehicle_1_t0 {\n\t\t\t:>> mass = 2000.0;\n\t\t\t:>> status {\n\t\t\t\t:>> gearSetting = 0;\n\t\t\t\t:>> acceleratorPosition = 0.0;\n\t\t\t}\n\t\t}\n\t\tsnapshot part vehicle_1_t1 {\n\t\t\t:>> mass = 1500.0;\n\t\t\t:>> status {\n\t\t\t\t:>> gearSetting = 2;\n\t\t\t\t:>> acceleratorPosition = 0.5;\n\t\t\t}\n\t\t}\n\t\tfirst vehicle_1_t0 then vehicle_1_t1;\n\t}\n}",
    "domain": "Vehicle Traffic",
    "grammar": "Individual",
    "diagram": "dataset/sysml/samples/52/design.png"
  },
  {
    "nl": "The system is designed to model a vehicle, which possesses certain properties such as mass and current state, including gear position and throttle pedal position. The vehicle also contains an engine as one of its components and can be assigned a driver. Two drivers are defined in the system: Alice and Bob. The vehicle’s attribute values change across different time slices; for example, in the initial state, its mass is 2000 kg, the gear is in neutral, and the throttle is at zero. Subsequently, the mass changes to 1500 kg, the gear shifts to second, and the throttle pedal position becomes 0.5. The system also describes that the vehicle is driven by Alice in the first time slice, and that Bob takes over as the driver in the second time slice. The overall model supports the expression and tracking of dynamic vehicle attributes as well as the process of switching drivers.",
    "design": "package ''VehicleComposition' {\n\tprivate import ScalarValues::*;\n\tpart def Vehicle {\n\t\tattribute mass : Real;\n\t\tattribute status : VehicleStatus;\n\t\tpart eng : Engine;\n\t\tref part driver : Person;\n\t}\n\tattribute def VehicleStatus {\n\t\tattribute gearSetting : Integer;\n\t\tattribute acceleratorPosition : Real;\n\t}\n\tpart def Engine;\t\n\tpart def Person;\n\tindividual part def Vehicle_1 :> Vehicle {\n\t\tsnapshot part vehicle_1_t0 {\n\t\t\t:>> mass = 2000.0;\n\t\t\t:>> status {\n\t\t\t\t:>> gearSetting = 0;\n\t\t\t\t:>> acceleratorPosition = 0.0;\n\t\t\t}\n\t\t}\n\t\tsnapshot part vehicle_1_t1 {\n\t\t\t:>> mass = 1500.0;\n\t\t\t:>> status {\n\t\t\t\t:>> gearSetting = 2;\n\t\t\t\t:>> acceleratorPosition = 0.5;\n\t\t\t}\n\t\t}\n\t\tfirst vehicle_1_t0 then vehicle_1_t1;\n\t}\n\tindividual item def Alice :> Person;\n\tindividual item def Bob :> Person;\n\tindividual : Vehicle_1 {\n\t\ttimeslice aliceDriving {\n\t\t\tref individual item :>> driver : Alice;\n\t\t\tsnapshot :>> start {\n\t\t\t\t:>> mass = 2000.0;\n\t\t\t}\n\t\t\tsnapshot :>> done {\n\t\t\t\t:>> mass = 1500.0;\n\t\t\t}\t\t\t\n\t\t}\n\t\tthen timeslice bobDriving {\n\t\t\tref individual item :>> driver : Bob;\n\t\t}\n\t}\n}",
    "domain": "Vehicle Traffic",
    "grammar": "Individual",
    "diagram": "dataset/sysml/samples/53/design.png"
  },
  {
    "nl": "This system is designed to perform hierarchical modeling and aggregation of the quality (mass) information of vehicles and their components, facilitating automatic calculation and management of the total vehicle mass. In the system, each object with a quantifiable mass can either be a simple component or a composite object assembled from other components. Every component contains its own mass information and can automatically aggregate the total mass of itself and all its subcomponents. For example, the total mass of a complete vehicle includes the body itself as well as all parts such as the engine, transmission, and other components. Core components such as the engine and transmission are explicitly defined and assigned under the whole vehicle, and their data can be individually specified. Through this model, users can quickly acquire the total mass of a specific vehicle, while the numbering and weight information of any component can be clearly recorded, achieving transparency, automated statistics, and traceability of vehicle mass.",
    "design": "package 'VehicleMassAggregation' {\n\tprivate import ScalarValues::*;\n\tprivate import NumericalFunctions::*;\n\tpart def MassedThing {\n\t\tattribute simpleMass :> ISQ::mass; \n\t\tattribute totalMass :> ISQ::mass;\n\t}\n\tpart simpleThing : MassedThing {\n\t\tattribute :>> totalMass = simpleMass;\n\t}\n\tpart compositeThing : MassedThing {\n\t\tpart subcomponents: MassedThing[*];\t\t\n\t\tattribute :>> totalMass =\n\t\t\tsimpleMass + sum(subcomponents.totalMass); \n\t}\n\tpart def CarPart :> MassedThing {\t\t\t\n\t\tattribute serialNumber: String;\n\t}\n\tpart car: CarPart :> compositeThing {\t\n\t\tattribute vin :>> serialNumber;\n\t\tpart carParts: CarPart[*] :>> subcomponents;\n\t\tpart engine :> simpleThing, carParts {\n\t\t\t//...\n\t\t}\n\t\tpart transmission :> simpleThing, carParts {\n\t\t\t//...\n\t\t}\n\t}\n\tprivate import SI::kg;\n\tpart c :> car {\n\t\tattribute :>> simpleMass = 1000[kg];\n\t\tpart :>> engine {\n\t\t\tattribute :>> simpleMass = 100[kg];\n\t\t}\n\t\tpart redefines transmission {\n\t\t\tattribute :>> simpleMass = 50[kg];\n\t\t}\t\n\t}\n\t// c::totalMass --> 1150.0[kg]\n}",
    "domain": "Vehicle Traffic",
    "grammar": "Expression",
    "diagram": "dataset/sysml/samples/54/design.png"
  },
  {
    "nl": "This system is designed for comprehensive management and calculation of the quality (mass) of vehicles and their components. Each vehicle is composed of multiple components with measurable mass, and each component is defined with a simple mass attribute. The total mass of a vehicle equals its own mass plus the combined mass of all its components. The system supports recursive composition of components and mass filtering; for example, it is possible to set a threshold so that only subcomponents with mass no less than a specified value are counted. Each vehicle component has a unique serial number, while the complete vehicle has a unique Vehicle Identification Number (VIN), and key subcomponents such as the engine and transmission can be specifically defined along with their masses. In practical application scenarios, users can input mass data for each main component, and the system will automatically summarize the information, providing a clear and straightforward overview of the total vehicle mass. This enables precise mass management for vehicles and their constituent components.",
    "design": "package 'VehicleMassAggregation' {\n\tprivate import ScalarValues::*;\n\tprivate import NumericalFunctions::*;\n\tpart def MassedThing {\n\t\tattribute simpleMass :> ISQ::mass; \n\t\tattribute totalMass :> ISQ::mass default simpleMass;\n\t}\n\tpart compositeThing : MassedThing {\n\t\tpart subcomponents: MassedThing[*];\t\t\n\t\tattribute :>> totalMass default\n\t\t\tsimpleMass + sum(subcomponents.totalMass); \n\t}\n\tpart filteredMassThing :> compositeThing {\n\t\tattribute minMass :> ISQ::mass;\t\t\n\t\tattribute :>> totalMass =\n\t\t\tsimpleMass + sum(subcomponents.totalMass.?{in p:>ISQ::mass; p >= minMass});\n\t}\n\tpart def CarPart :> MassedThing {\t\t\t\n\t\tattribute serialNumber: String;\n\t}\n\tpart car: CarPart :> compositeThing {\t\n\t\tattribute vin :>> serialNumber;\n\t\tpart carParts: CarPart[*] :>> subcomponents;\n\t\tpart engine :> carParts {\n\t\t\t//...\n\t\t}\n\t\tpart transmission :> carParts {\n\t\t\t//...\n\t\t}\n\t}\n\tprivate import SI::kg;\n\tpart c :> car {\n\t\tattribute :>> simpleMass = 1000[kg];\n\t\tpart :>> engine {\n\t\t\tattribute :>> simpleMass = 100[kg];\n\t\t}\n\t\tpart redefines transmission {\n\t\t\tattribute :>> simpleMass = 50[kg];\n\t\t}\t\n\t}\n\t// c::totalMass --> 1150.0[kg]\n}",
    "domain": "Vehicle Traffic",
    "grammar": "Expression",
    "diagram": "dataset/sysml/samples/55/design.png"
  },
  {
    "nl": "This system is used for the quality aggregation management of objects with mass attributes. Each object has a basic mass attribute (simpleMass) and a total mass attribute (totalMass). For the most basic object (simpleThing), its total mass is equal to its own basic mass. For a composite object (compositeThing), it can contain several subcomponents, each of which is an object with mass. Its total mass is the sum of its own basic mass and the total mass of all its subcomponents. The system can automatically calculate and aggregate the mass of components at all levels of the composite, achieving hierarchical management and statistics of mass.",
    "design": "package MassRollup{\n\tprivate import NumericalFunctions::*;\n\tpart def MassedThing {\n\t\tattribute simpleMass :> ISQ::mass; \n\t\tattribute totalMass :> ISQ::mass;\n\t}\n\tpart simpleThing : MassedThing {\n\t\tattribute :>> totalMass = simpleMass;\n\t}\n\tpart compositeThing : MassedThing {\n\t\tpart subcomponents: MassedThing[*];\t\t\n\t\tattribute :>> totalMass =\n\t\t\tsimpleMass + sum(subcomponents.totalMass); \n\t}\n}",
    "domain": "Simulation Calculation",
    "grammar": "Expression",
    "diagram": "dataset/sysml/samples/56/design.png"
  },
  {
    "nl": "This system is used for the aggregation and management of the mass of objects with mass attributes. Each object has a basic mass and can also contain several subcomponents. The system can automatically calculate the total mass, including all subcomponents. For supported composite objects, the total mass equals the sum of the object's own basic mass and the full mass of all its subcomponents. In addition, the system supports mass-based filtering and aggregation of components; that is, a minimum mass threshold can be set so that only subcomponents whose mass is not less than this threshold are counted. In this case, the total mass is the sum of the object's own mass and the mass of all subcomponents that meet the specified minimum mass requirement. This system is suitable for hierarchical decomposition and overall mass control of complex products or equipment structures, enabling users to flexibly aggregate mass information from different dimensions according to actual needs.",
    "design": "package MassRollup {\n\tprivate import NumericalFunctions::*;\n\tpart def MassedThing {\n\t\tattribute simpleMass :> ISQ::mass; \n\t\tattribute totalMass :> ISQ::mass default simpleMass;\n\t}\n\tpart compositeThing : MassedThing {\n\t\tpart subcomponents: MassedThing[*];\t\t\n\t\tattribute :>> totalMass default\n\t\t\tsimpleMass + sum(subcomponents.totalMass); \n\t}\n\tpart filteredMassThing :> compositeThing {\n\t\tattribute minMass :> ISQ::mass;\t\t\n\t\tattribute :>> totalMass =\n\t\t\tsimpleMass + sum(subcomponents.totalMass.?{in p:>ISQ::mass; p >= minMass});\n\t}\n}",
    "domain": "Simulation Calculation",
    "grammar": "Expression",
    "diagram": "dataset/sysml/samples/57/design.png"
  },
  {
    "nl": "The system must be capable of calculating the core parameters of vehicle dynamics, including the vehicle's power output, acceleration, speed, and position under various operating conditions. It should accurately calculate the vehicle’s actual available power output based on key input parameters such as wheel power, aerodynamic drag coefficient, friction coefficient, vehicle mass, and speed. Additionally, the system should be able to deduce the vehicle’s acceleration based on effective power, mass, and current speed, and utilize the obtained acceleration, initial speed, and time to calculate the vehicle’s speed at any given moment. Furthermore, the system should have the capability to estimate vehicle displacement based on speed and time, helping end-users comprehensively analyze and predict the dynamic performance of the vehicle under specific operating conditions. The overall requirements emphasize high accuracy, clear logical relationships between parameters, and results that are convenient for practical engineering applications.",
    "design": "package 'VehicleDynamicsCoreCalculations' {\n\tprivate import ScalarValues::Real;\n\tprivate import ISQ::*;\n\tcalc def Power { in whlpwr : PowerValue; in Cd : Real; in Cf : Real; in tm : MassValue; in v : SpeedValue;\n\t\tattribute drag = Cd * v;\n\t\tattribute friction = Cf * tm * v;\n\t\treturn : PowerValue = whlpwr - drag - friction;\n\t}\n\tcalc def Acceleration { in tp: PowerValue; in tm : MassValue; in v : SpeedValue;\n\t\treturn : AccelerationValue = tp / (tm * v);\n\t}\n\tcalc def Velocity { in dt : TimeValue; in v0 : SpeedValue; in a : AccelerationValue;\n\t\treturn : SpeedValue = v0 + a * dt;\n \t}\n\tcalc def Position { in dt : TimeValue; in x0 : LengthValue; in v : SpeedValue;\n\t\treturn : LengthValue = x0 + v * dt;\n\t}\n}",
    "domain": "Vehicle Traffic",
    "grammar": "Calculation",
    "diagram": "dataset/sysml/samples/58/design.png"
  },
  {
    "nl": "This system is designed to simulate and compute the dynamic behavior of vehicles during straight-line driving, taking into account influencing factors such as aerodynamic drag and rolling resistance. By utilizing the wheel-end output power and the total vehicle mass, the system dynamically calculates the vehicle's acceleration, speed, and position. Given the initial speed and position, as well as a specified time step, and by comprehensively considering parameters such as the aerodynamic drag coefficient and rolling resistance coefficient, the system first determines the available driving power under current conditions, then calculates the vehicle's acceleration accordingly, and further derives the new speed and position of the vehicle at the end of the time step. The system allows users to flexibly set key parameters and can provide accurate physical modeling and computational foundations for applications such as straight-line driving performance analysis, energy consumption simulation, and driving strategy optimization.",
    "design": "package 'VehicleDynamicsCalculation' {\n\tprivate import ScalarValues::Real;\n\tprivate import ISQ::*;\n\tcalc def Power { in whlpwr : PowerValue; in Cd : Real; in Cf : Real; in tm : MassValue; in v : SpeedValue;\n\t\tattribute drag = Cd * v;\n\t\tattribute friction = Cf * tm * v;\n\t\treturn : PowerValue = whlpwr - drag - friction;\n\t}\n\tcalc def Acceleration { in tp: PowerValue; in tm : MassValue; in v : SpeedValue;\n\t\treturn : AccelerationValue = tp / (tm * v);\n\t}\n\tcalc def Velocity { in dt : TimeValue; in v0 : SpeedValue; in a : AccelerationValue;\n\t\treturn : SpeedValue = v0 + a * dt;\n \t}\n\tcalc def Position { in dt : TimeValue; in x0 : LengthValue; in v : SpeedValue;\n\t\treturn : LengthValue = x0 + v * dt;\n\t}\n\tpart def VehicleDynamics {\n\t\tattribute C_d : Real;\n\t\tattribute C_f : Real;\n\t\tattribute wheelPower : PowerValue;\n\t\tattribute mass : MassValue;\n\t\taction straightLineDynamics {\n\t\t\tin delta_t : TimeValue;\n\t\t\tin v_in : SpeedValue;\n\t\t\tin x_in : LengthValue;\n\t\t\tout v_out : SpeedValue = vel.v;\n\t\t\tout x_out : LengthValue = pos.x;\n\t\t\tcalc acc : Acceleration {\n\t\t\t\tin tp = Power(wheelPower, C_d, C_f, mass, v_in);\n\t\t\t\tin tm = mass;\n\t\t\t\tin v = v_in;\n\t\t\t\treturn a;\n\t\t\t}\n\t\t\tcalc vel : Velocity {\n\t\t\t\tin dt = delta_t;\n\t\t\t\tin v0 = v_in;\n\t\t\t\tin a = acc.a;\n\t\t\t\treturn v;\n\t\t\t}\n\t\t\tcalc pos : Position {\n\t\t\t\tin dt = delta_t;\n\t\t\t\tin x0 = x_in;\n\t\t\t\tin v0 = vel.v;\n\t\t\t\treturn x;\t\n\t\t\t}\n\t\t}\n\t} \n}",
    "domain": "Vehicle Traffic",
    "grammar": "Calculation",
    "diagram": "dataset/sysml/samples/59/design.png"
  },
  {
    "nl": "This system is designed to model and compute the vehicle's driving dynamics. Based on user input parameters such as vehicle mass, wheel power, aerodynamic drag coefficient, and rolling resistance coefficient, together with initial speed and position, the system automatically calculates and updates the vehicle's speed and position at each time step. The system comprehensively accounts for the effects of air resistance and frictional resistance on vehicle dynamics and uses this information to predict the vehicle's velocity, acceleration, displacement, and other dynamic states over time. This assists end users in analyzing vehicle performance under different operating conditions, thereby enabling the automation and efficient management of vehicle dynamics simulation.",
    "design": "package 'VehicleDynamicsCalculation' {\n\tprivate import ScalarValues::Real;\n\tprivate import ISQ::*;\n\tcalc def Power { in whlpwr : PowerValue; in Cd : Real; in Cf : Real; in tm : MassValue; in v : SpeedValue;\n\t\tattribute drag = Cd * v;\n\t\tattribute friction = Cf * tm * v;\n\t\treturn : PowerValue = whlpwr - drag - friction;\n\t}\n\tcalc def Acceleration { in tp: PowerValue; in tm : MassValue; in v : SpeedValue;\n\t\treturn : AccelerationValue = tp / (tm * v);\n\t}\n\tcalc def Velocity { in dt : TimeValue; in v0 : SpeedValue; in a : AccelerationValue;\n\t\treturn : SpeedValue = v0 + a * dt;\n \t}\n\tcalc def Position { in dt : TimeValue; in x0 : LengthValue; in v : SpeedValue;\n\t\treturn : LengthValue = x0 + v * dt;\n\t}\n\tattribute def DynamicState {\n\t\tattribute v: SpeedValue;\n\t\tattribute x: LengthValue;\n\t}\n\tpart def VehicleDynamics {\n\t\tattribute C_d : Real;\n\t\tattribute C_f : Real;\n\t\tattribute wheelPower : PowerValue;\n\t\tattribute mass : MassValue;\t\n\t\tcalc updateState { \n\t\t\tin delta_t : TimeValue; \n\t\t\tin currState : DynamicState;\n\t\t\tattribute totalPower : PowerValue = Power(wheelPower, C_d, C_f, mass, currState.v);\n\t\t\treturn attribute newState : DynamicState {\n\t\t\t\t:>> v = Velocity(delta_t, currState.v, Acceleration(totalPower, mass, currState.v));\n\t\t\t\t:>> x = Position(delta_t, currState.x, currState.v);\n\t\t\t}\n\t\t}\n\t} \n}",
    "domain": "Vehicle Traffic",
    "grammar": "Calculation",
    "diagram": "dataset/sysml/samples/60/design.png"
  },
  {
    "nl": "This system is designed to describe and calculate the longitudinal dynamic constraints and state changes of a vehicle moving in a straight line. Users are required to provide the initial position, initial velocity, vehicle mass, wheel-end drive power, and time interval at a specific moment. Based on the input power, drag coefficient, friction coefficient, and other parameters, the system can automatically calculate the vehicle’s acceleration, final velocity, and final position within the given time interval. During the computation, the system comprehensively considers the effects of air resistance, frictional resistance, and other factors, and solves the dynamic equations under relevant constraints to ensure the physical consistency and accuracy of the motion simulation. This system is suitable for scenarios involving linear uniformly accelerated motion, and can meet the basic needs for vehicle dynamic performance simulation and analysis. It provides a computational basis for vehicle system dynamics modeling and performance evaluation.",
    "design": "package 'VehicleLongitudinalDynamicsConstraints' {\n\tprivate import ISQ::*;\n\tprivate import ScalarValues::Real;\n\tprivate import ISQ::*;\n\tcalc def Power { in whlpwr : PowerValue; in Cd : Real; in Cf : Real; in tm : MassValue; in v : SpeedValue;\n\t\tattribute drag = Cd * v;\n\t\tattribute friction = Cf * tm * v;\n\t\treturn : PowerValue = whlpwr - drag - friction;\n\t}\n\tcalc def Acceleration { in tp: PowerValue; in tm : MassValue; in v : SpeedValue;\n\t\treturn : AccelerationValue = tp / (tm * v);\n\t}\n\tcalc def Velocity { in dt : TimeValue; in v0 : SpeedValue; in a : AccelerationValue;\n\t\treturn : SpeedValue = v0 + a * dt;\n \t}\n\tcalc def Position { in dt : TimeValue; in x0 : LengthValue; in v : SpeedValue;\n\t\treturn : LengthValue = x0 + v * dt;\n\t}\n\tconstraint def StraightLineDynamicsEquations {\n\t\tin p : PowerValue;\n\t\tin m : MassValue;\n\t\tin dt : TimeValue;\n\t\tin x_i : LengthValue;\n\t\tin v_i : SpeedValue;\n\t\tin x_f : LengthValue;\n\t\tin v_f : SpeedValue;\n\t\tin a : AccelerationValue;\n\t\tattribute v_avg : SpeedValue = (v_i + v_f)/2;\n\t\ta == Acceleration(p, m, v_avg) and\n\t\tv_f == Velocity(dt, v_i, a) and\n\t\tx_f == Position(dt, x_i, v_avg)\n\t}\n\taction def StraightLineDynamics {\n\t\tin power : PowerValue;\n\t\tin mass : MassValue;\n\t\tin delta_t : TimeValue;\n\t\tin x_in : LengthValue;\n\t\tin v_in : SpeedValue;\n\t\tout x_out : LengthValue;\n\t\tout v_out : SpeedValue;\n\t\tout a_out : AccelerationValue;\n\t    assert constraint dynamics : StraightLineDynamicsEquations {\n\t\t\tin p = power;\n\t\t\tin m = mass;\n\t\t\tin dt = delta_t;\n\t\t\tin x_i = x_in;\n\t\t\tin v_i = v_in;\n\t\t\tin x_f = x_out;\n\t\t\tin v_f = v_out;\n\t\t\tin a = a_out;\n\t    }\n\t}\n}",
    "domain": "Vehicle Traffic",
    "grammar": "Constraint",
    "diagram": "dataset/sysml/samples/61/design.png"
  },
  {
    "nl": "This system is designed to restrict and manage the vehicle’s total mass, ensuring that the overall vehicle weight does not exceed the maximum permitted limit of 2,500 kilograms. The vehicle consists of a chassis, an engine, and a gearbox, each with its own mass parameter. The system will automatically calculate the total mass of the chassis, engine, and gearbox, and check whether this total complies with the requirement of not exceeding 2,500 kilograms. If the combined mass of the chassis, engine, and gearbox exceeds the specified limit, the system will issue an overweight warning, ensuring that the vehicle design meets the relevant weight regulations.",
    "design": "package 'VehicleMassBudgetingConstraints' {\n\tprivate import ISQ::*;\n\tprivate import SI::*;\n\tprivate import NumericalFunctions::*;\n\tpart def Engine;\n\tpart def Transmission;\n\tconstraint def MassConstraint {\n\t\tin partMasses : MassValue[0..*];\n\t\tin massLimit : MassValue;\n\t\tsum(partMasses) <= massLimit\n\t}\n\tpart def Vehicle {\n\t\tassert constraint massConstraint : MassConstraint {\n\t\t\tin partMasses = (chassisMass, engine.mass, transmission.mass);\n\t\t\tin massLimit = 2500[kg];\n\t\t}\t\n\t\tattribute chassisMass : MassValue;\n\t\tpart engine : Engine {\n\t\t\tattribute mass : MassValue;\n\t\t}\n\t\tpart transmission : Engine {\n\t\t\tattribute mass : MassValue;\n\t\t}\n\t}\t\n}",
    "domain": "Vehicle Traffic",
    "grammar": "Constraint",
    "diagram": "dataset/sysml/samples/62/design.png"
  },
  {
    "nl": "This system is designed to budget and constrain the mass of a vehicle, ensuring that the total mass of the complete vehicle—including major components such as the chassis, engine, and transmission—does not exceed 2,500 kilograms. The system requires the actual mass of each component to be entered and uniformly measured using the international unit of kilograms. It will automatically calculate the sum of the component masses and compare the result with the specified mass limit; if the total mass exceeds the limit, the design requirements are not met. Furthermore, as critical components of the vehicle, the masses of the engine and the transmission must be separately recorded and managed. This ensures that, during the preliminary design stage, vehicle curb weight can be effectively controlled through these constraints, providing a fundamental basis for subsequent performance design and energy consumption optimization.",
    "design": "package 'VehicleMassBudgetingConstraints' {\n\tprivate import ISQ::*;\n\tprivate import SI::*;\n\tprivate import NumericalFunctions::*;\n\tpart def Engine;\n\tpart def Transmission;\n\tconstraint def MassConstraint {\n\t\tin partMasses : MassValue[0..*];\n\t\tin massLimit : MassValue;\n\t}\n\tconstraint massConstraint : MassConstraint {\n\t\tin partMasses : MassValue[0..*];\n\t\tin massLimit : MassValue;\t\t\n\t\tsum(partMasses) <= massLimit\n\t}\n\tpart def Vehicle {\n\t\tassert massConstraint {\n\t\t\tin partMasses = (chassisMass, engine.mass, transmission.mass);\n\t\t\tin massLimit = 2500[kg];\n\t\t}\t\n\t\tattribute chassisMass : MassValue;\n\t\tpart engine : Engine {\n\t\t\tattribute mass : MassValue;\n\t\t}\n\t\tpart transmission : Engine {\n\t\t\tattribute mass : MassValue;\n\t\t}\n\t}\t\n}",
    "domain": "Vehicle Traffic",
    "grammar": "Constraint",
    "diagram": "dataset/sysml/samples/63/design.png"
  },
  {
    "nl": "This system is designed to manage and regulate vehicle mass in compliance with relevant standards. A vehicle consists of three parts: the chassis, the engine, and the transmission, each with its own mass. The system requires that the total mass of the complete vehicle (i.e., the sum of the masses of the chassis, engine, and transmission) must not exceed 2,500 kilograms in order to meet vehicle mass compliance requirements. The system is capable of receiving the actual mass data of each component and automatically verifying whether their total exceeds the specified upper mass limit, thus ensuring that vehicle design and manufacturing conform to the applicable standards and regulatory requirements regarding mass. This mechanism helps ensure that the vehicle meets requirements concerning safety, performance, and regulatory compliance.",
    "design": "package 'VehicleMassComplianceSystem' {\n\tprivate import ISQ::*;\n\tprivate import SI::*;\n\tprivate import NumericalFunctions::*;\n\tpart def Engine;\n\tpart def Transmission;\n\tconstraint def MassConstraint {\n\t\tin partMasses : MassValue[0..*];\n\t\tin massLimit : MassValue;\n\t\tsum(partMasses) <= massLimit\n\t}\n\tpart def Vehicle {\n\t\tconstraint massConstraint : MassConstraint {\n\t\t\tin partMasses = (chassisMass, engine.mass, transmission.mass);\n\t\t\tin massLimit = 2500[kg];\n\t\t}\n\t\tattribute chassisMass : MassValue;\n\t\tpart engine : Engine {\n\t\t\tattribute mass : MassValue;\n\t\t}\n\t\tpart transmission : Engine {\n\t\t\tattribute mass : MassValue;\n\t\t}\n\t}\n}",
    "domain": "Vehicle Traffic",
    "grammar": "Constraint",
    "diagram": "dataset/sysml/samples/64/design.png"
  },
  {
    "nl": "This system is designed to ensure that the combined weight of the main vehicle components (including the chassis, engine, and transmission) does not exceed 2,500 kilograms. The system must be able to accurately record and manage the weight of each component, with the weight data for the chassis, engine, and transmission all required as inputs. The system should automatically sum the weights of these components, and when the total weight exceeds the specified limit, it must provide a warning or impose restrictions to ensure that the designed vehicle’s total weight complies with relevant regulatory requirements, thereby ensuring product legality, compliance, and safety.",
    "design": "package 'VehicleMassComplianceSystem' {\n\tprivate import ISQ::*;\n\tprivate import SI::*;\n\tprivate import NumericalFunctions::*;\n\tpart def Engine;\n\tpart def Transmission;\n\tconstraint def MassConstraint {\n\t\tattribute partMasses : MassValue[0..*];\n\t\tattribute massLimit : MassValue;\n\t\tsum(partMasses) <= massLimit\n\t}\n\tpart def Vehicle {\n\t\tconstraint massConstraint : MassConstraint {\n\t\t\tredefines partMasses = (chassisMass, engine.mass, transmission.mass);\n\t\t\tredefines massLimit = 2500[kg];\n\t\t}\n\t\tattribute chassisMass : MassValue;\n\t\tpart engine : Engine {\n\t\t\tattribute mass : MassValue;\n\t\t}\n\t\tpart transmission : Engine {\n\t\t\tattribute mass : MassValue;\n\t\t}\n\t}\n}",
    "domain": "Vehicle Traffic",
    "grammar": "Constraint",
    "diagram": "dataset/sysml/samples/65/design.png"
  },
  {
    "nl": "This system is designed to describe and constrain the composition and mass requirements of a vehicle. The vehicle consists of three main components: the chassis, the engine, and the transmission, each with its own mass attribute. The system requires that the total mass of all vehicle components must not exceed 2,500 kilograms. In addition, the dynamic behavior of the vehicle is considered: the system supports modeling the vehicle's dynamic constraints under known initial velocity, final velocity, mass, applied force, and over a given period of time, ensuring that the mass must be greater than zero, and that the physical relationship among force, time, and change in velocity is satisfied. Through these constraints, the system can be used during vehicle design to verify the rationality of total mass and dynamic performance.",
    "design": "package 'VehicleSystemConstraint' {\n\tprivate import SI::*;\n\tprivate import ISQ::*;\n\tprivate import NumericalFunctions::*;\n\tpart def Engine;\n\tpart def Transmission;\n\tconstraint def MassConstraint {\n\t\tin partMasses : MassValue[0..*];\n\t\tin massLimit : MassValue;\n\t\tsum(partMasses) <= massLimit\n\t}\n\tpart def Vehicle {\n\t\tconstraint massConstraint : MassConstraint {\n\t\t\tin partMasses = (chassisMass, engine.mass, transmission.mass);\n\t\t\tin massLimit = 2500[kg];\n\t\t}\n\t\tattribute chassisMass : MassValue;\n\t\tpart engine : Engine {\n\t\t\tattribute mass : MassValue;\n\t\t}\n\t\tpart transmission : Engine {\n\t\t\tattribute mass : MassValue;\n\t\t}\n\t}\n\tpart vehicle1 : Vehicle {\n\t\tattribute totalMass : MassValue;\t\t\t\n\t\tassert constraint {totalMass == chassisMass + engine.mass + transmission.mass}\t\n\t}\n\tpart vehicle2 : Vehicle {\n\t\tattribute totalMass : MassValue = chassisMass + engine.mass + transmission.mass;\n\t}\n\tconstraint def Dynamics {\n\t\tin mass: MassValue;\n\t\tin initialSpeed : SpeedValue;\n\t\tin finalSpeed : SpeedValue;\n\t\tin deltaT : TimeValue;\n\t\tin force : ForceValue;\n\t\tforce * deltaT == mass * (finalSpeed - initialSpeed) and\n\t\tmass > 0[kg]\n\t}\n}",
    "domain": "Vehicle Traffic",
    "grammar": "Constraint",
    "diagram": "dataset/sysml/samples/66/design.png"
  },
  {
    "nl": "This system is designed to manage and monitor the maintenance schedule of vehicles. For each vehicle, a specific time for the next maintenance and a fixed maintenance interval will be set, and the maximum allowed temperature will be recorded. The system will automatically determine whether the vehicle has reached the maintenance time. Once the scheduled maintenance time is reached, the vehicle status will switch to \"under maintenance.\" The system requires that the actual maintenance start time must be later than the scheduled maintenance time, and the maintenance must be initiated within 2 seconds after the previous healthy state ends. The duration of the maintenance must not exceed 48 hours. After the maintenance is completed, the vehicle’s next maintenance time will be automatically postponed according to the maintenance interval, and its health status will be restored to normal.",
    "design": "package 'VehicleMaintenanceTimingConstraints' {\n\tprivate import ISQ::TemperatureValue;\n\tprivate import ISQ::DurationValue;\n\tprivate import Time::TimeInstantValue;\n\tprivate import Time::TimeOf;\n\tprivate import Time::DurationOf;\n\tprivate import SI::h;\n\tprivate import SI::s;\n\tattribute def MaintenanceDone;\n\tpart def Vehicle {\n\t\tattribute maintenanceTime : TimeInstantValue;\n\t\tattribute maintenanceInterval : DurationValue;\n\t\tattribute maxTemperature : TemperatureValue;\n\t}\n\tstate healthStates {\n\t\tin vehicle : Vehicle;\n\t\tentry; then normal;\n\t\tstate normal;\n\t\taccept at vehicle.maintenanceTime\n\t\t\tthen maintenance;\n\t\tstate maintenance {\n\t\t\tassert constraint { TimeOf(maintenance) > vehicle.maintenanceTime }\n\t\t\tassert constraint { TimeOf(maintenance) - TimeOf(normal.done) < 2 [s] }\n\t\t\tentry assign vehicle.maintenanceTime := vehicle.maintenanceTime + vehicle.maintenanceInterval;\n\t\t}\n\t\taccept MaintenanceDone\n\t\t\tthen normal;\n\t\tconstraint { DurationOf(maintenance) <= 48 [h] }\n\t}\n}",
    "domain": "Vehicle Traffic",
    "grammar": "Constraint",
    "diagram": "dataset/sysml/samples/67/design.png"
  },
  {
    "nl": "The system requires that the total mass of the vehicle (including curb weight and fuel mass) must not exceed the specified maximum mass limit, and the fuel mass must be a positive value. In addition, the engine must be able to generate corresponding torque according to the speed curve, and the torque produced by the engine must be effectively transmitted to the transmission through the clutch interface to ensure that power is smoothly delivered to the vehicle’s drive system.",
    "design": "package 'VehicleSystemRequirementsSpecification' {\n\tprivate import ISQ::*;\n\tprivate import SI::*;\n\trequirement def MassLimitationRequirement {\n\t\tdoc /* The actual mass shall be less than or equal to the required mass. */\n\t\tattribute massActual: MassValue;\n\t\tattribute massReqd: MassValue;\n\t\trequire constraint { massActual <= massReqd }\n\t}\n\tpart def Vehicle {\n\t\tattribute dryMass: MassValue;\n\t\tattribute fuelMass: MassValue;\n\t\tattribute fuelFullMass: MassValue;\n\t}\n\trequirement def <'1'> VehicleMassLimitationRequirement :> MassLimitationRequirement {\n\t\tdoc /* The total mass of a vehicle shall be less than or equal to the required mass. */\n\t\tsubject vehicle : Vehicle;\n\t\tattribute redefines massActual = vehicle.dryMass + vehicle.fuelMass;\n\t\tassume constraint { vehicle.fuelMass > 0[kg] }\n\t}\n\tport def ClutchPort;\n\taction def GenerateTorque;\n\trequirement def <'2'> DrivePowerInterface {\n\t\tdoc /* The engine shall transfer its generated torque to the transmission via the clutch interface. */\n\t\tsubject clutchPort: ClutchPort;\n\t}\n\trequirement def <'3'> TorqueGeneration {\n\t\tdoc /* The engine shall generate torque as a function of RPM as shown in Table 1. */\n\t\tsubject generateTorque: GenerateTorque;\n\t}\n}",
    "domain": "Vehicle Traffic",
    "grammar": "Requirement",
    "diagram": "dataset/sysml/samples/68/design.png"
  },
  {
    "nl": "The system imposes the following requirements on the vehicle and its key components: With a full fuel tank, the vehicle’s total mass must not exceed 2000 kg, while with an empty fuel tank, the total mass must not exceed 1500 kg. This ensures that the sum of the vehicle’s dry mass and fuel mass meets the maximum allowable mass under different operating conditions. Additionally, the engine must be capable of transmitting its generated torque to the transmission via the clutch interface, and the engine is required to deliver the necessary torque according to the speed-torque curve (see Table 1). Overall, the system aims to regulate vehicle mass control, as well as the interface and performance of the powertrain, thereby ensuring the safety of vehicle design and the effectiveness of power transmission.",
    "design": "package 'VehicleSystemRequirements' {\n\tprivate import ISQ::*;\n\tprivate import SI::*;\n\trequirement def MassLimitationRequirement {\n\t\tdoc /* The actual mass shall be less than or equal to the required mass. */\n\t\tattribute massActual: MassValue;\n\t\tattribute massReqd: MassValue;\n\t\trequire constraint { massActual <= massReqd }\n\t}\n\tpart def Vehicle {\n\t\tattribute dryMass: MassValue;\n\t\tattribute fuelMass: MassValue;\n\t\tattribute fuelFullMass: MassValue;\n\t}\n\trequirement def <'1'> VehicleMassLimitationRequirement :> MassLimitationRequirement {\n\t\tdoc /* The total mass of a vehicle shall be less than or equal to the required mass. */\n\t\tsubject vehicle : Vehicle;\n\t\tattribute redefines massActual = vehicle.dryMass + vehicle.fuelMass;\n\t\tassume constraint { vehicle.fuelMass > 0[kg] }\n\t}\n\tport def ClutchPort;\n\taction def GenerateTorque;\n\trequirement def <'2'> DrivePowerInterface {\n\t\tdoc /* The engine shall transfer its generated torque to the transmission via the clutch interface. */\n\t\tsubject clutchPort: ClutchPort;\n\t}\t\n\trequirement def <'3'> TorqueGeneration {\n\t\tdoc /* The engine shall generate torque as a function of RPM as shown in Table 1. */\n\t\tsubject generateTorque: GenerateTorque;\n\t}\n\trequirement <'1.1'> fullVehicleMassLimit : VehicleMassLimitationRequirement {\n\t\tsubject vehicle : Vehicle;\n\t\tattribute :>> massReqd = 2000[kg];\n\t\tassume constraint {\n\t\t\tdoc /* Full tank is full. */\n\t\t\tvehicle.fuelMass == vehicle.fuelFullMass\n\t\t}\n\t}\n\trequirement <'1.2'> emptyVehicleMassLimit : VehicleMassLimitationRequirement {\n\t\tsubject vehicle : Vehicle;\n\t\tattribute :>> massReqd = 1500[kg];\n\t\tassume constraint {\n\t\t\tdoc /* Full tank is empty. */\n\t\t\tvehicle.fuelMass == 0[kg]\n\t\t}\n\t}\n\tpart def Engine {\n\t\tport clutchPort: ClutchPort;\n\t\tperform action generateTorque: GenerateTorque;\n\t}\n\trequirement vehicleSpecification {\n\t\tdoc /* Overall vehicle requirements group */\n\t\tsubject vehicle : Vehicle;\n\t\trequire fullVehicleMassLimit;\n\t\trequire emptyVehicleMassLimit;\n\t}\n\trequirement engineSpecification {\n\t\tdoc /* Engine power requirements group */\n\t\tsubject engine : Engine;\n\t\trequirement drivePowerInterface : DrivePowerInterface {\n\t\t\tsubject = engine.clutchPort;\n\t\t}\n\t\trequirement torqueGeneration : TorqueGeneration {\n\t\t\tsubject = engine.generateTorque;\t\n\t\t}\n\t}\n}",
    "domain": "Vehicle Traffic",
    "grammar": "Requirement",
    "diagram": "dataset/sysml/samples/69/design.png"
  },
  {
    "nl": "The system model of this project primarily outlines the basic requirements for a vehicle and its engine. The vehicle's total mass must not exceed 2000 kilograms when fully fueled, and should not be higher than 1500 kilograms when empty. The engine must be capable of effectively transmitting its generated torque to the transmission system through a clutch interface, and the torque generated by the engine should vary with speed, conforming to the relevant performance table specifications. The design of both the vehicle and its engine must meet these critical requirements for mass and power interface to ensure overall vehicle performance and safety.",
    "design": "package 'VehicleRequirementsSatisfaction' {\n\tprivate import ISQ::*;\n\tprivate import SI::*;\n\trequirement def MassLimitationRequirement {\n\t\tdoc /* The actual mass shall be less than or equal to the required mass. */\n\t\tattribute massActual: MassValue;\n\t\tattribute massReqd: MassValue;\n\t\trequire constraint { massActual <= massReqd }\n\t}\n\tpart def Vehicle {\n\t\tattribute dryMass: MassValue;\n\t\tattribute fuelMass: MassValue;\n\t\tattribute fuelFullMass: MassValue;\n\t}\n\trequirement def <'1'> VehicleMassLimitationRequirement :> MassLimitationRequirement {\n\t\tdoc /* The total mass of a vehicle shall be less than or equal to the required mass. */\n\t\tsubject vehicle : Vehicle;\n\t\tattribute redefines massActual = vehicle.dryMass + vehicle.fuelMass;\n\t\tassume constraint { vehicle.fuelMass > 0[kg] }\n\t}\n\tport def ClutchPort;\n\taction def GenerateTorque;\n\trequirement def <'2'> DrivePowerInterface {\n\t\tdoc /* The engine shall transfer its generated torque to the transmission via the clutch interface. */\n\t\tsubject clutchPort: ClutchPort;\n\t}\n\trequirement def <'3'> TorqueGeneration {\n\t\tdoc /* The engine shall generate torque as a function of RPM as shown in Table 1. */\n\t\tsubject generateTorque: GenerateTorque;\n\t}\n\trequirement <'1.1'> fullVehicleMassLimit : VehicleMassLimitationRequirement {\n\t\tsubject vehicle : Vehicle;\n\t\tattribute :>> massReqd = 2000[kg];\n\t\t\n\t\tassume constraint {\n\t\t\tdoc /* Full tank is full. */\n\t\t\tvehicle.fuelMass == vehicle.fuelFullMass\n\t\t}\n\t}\n\trequirement <'1.2'> emptyVehicleMassLimit : VehicleMassLimitationRequirement {\n\t\tsubject vehicle : Vehicle;\n\t\tattribute :>> massReqd = 1500[kg];\n\t\t\n\t\tassume constraint {\n\t\t\tdoc /* Full tank is empty. */\n\t\t\tvehicle.fuelMass == 0[kg]\n\t\t}\n\t}\n\tpart def Engine {\n\t\tport clutchPort: ClutchPort;\n\t\tperform action generateTorque: GenerateTorque;\n\t}\n\trequirement vehicleSpecification {\n\t\tdoc /* Overall vehicle requirements group */\n\t\tsubject vehicle : Vehicle;\n\t\trequire fullVehicleMassLimit;\n\t\trequire emptyVehicleMassLimit;\n\t}\n\trequirement engineSpecification {\n\t\tdoc /* Engine power requirements group */\n\t\tsubject engine : Engine;\n\t\trequirement drivePowerInterface : DrivePowerInterface {\n\t\t\tsubject = engine.clutchPort;\n\t\t}\n\t\trequirement torqueGeneration : TorqueGeneration {\n\t\t\tsubject = engine.generateTorque;\t\n\t\t}\n\t}\n\taction 'provide power' {\n\t\taction 'generate torque' { }\n\t}\n\tpart vehicle_c1 : Vehicle {\n\t\tperform 'provide power';\t\t\n\t\tpart engine_v1: Engine {\n\t\t\tport :>> clutchPort;\n\t\t\tperform 'provide power'.'generate torque' :>> generateTorque;\n\t\t}\t\n\t}\n\tpart 'Vehicle c1 Design Context' {\t\n\t\tref vehicle_design :> vehicle_c1;\n\t\tsatisfy vehicleSpecification by vehicle_design;\n\t\tsatisfy engineSpecification by vehicle_design.engine_v1;\n\t}\n}",
    "domain": "Vehicle Traffic",
    "grammar": "Requirement",
    "diagram": "dataset/sysml/samples/70/design.png"
  },
  {
    "nl": "The system requires that the actual mass of the vehicle must not exceed the specified limit, with two specific operating conditions: when the fuel tank is full, the total vehicle mass must not exceed 2000 kg; when the fuel tank is empty, the total vehicle mass must not exceed 1500 kg. In both cases, the sum of the vehicle’s curb mass and the fuel mass is considered as the total vehicle mass for calculation purposes. The system also stipulates that the engine must be capable of generating the specified torque characteristics at various speeds, and that the generated torque must be effectively transmitted to the gearbox through the clutch interface to ensure smooth power delivery. The above requirements ensure that vehicle mass control and power transmission comply with design and safety standards.",
    "design": "package 'VehicleRequirementsSpecialization' {\n\tprivate import ISQ::*;\n\tprivate import SI::*;\n\trequirement def MassLimitationRequirement {\n\t\tdoc /* The actual mass shall be less than or equal to the required mass. */\n\t\tattribute massActual: MassValue;\n\t\tattribute massReqd: MassValue;\n\t\trequire constraint { massActual <= massReqd }\n\t}\n\tpart def Vehicle {\n\t\tattribute dryMass: MassValue;\n\t\tattribute fuelMass: MassValue;\n\t\tattribute fuelFullMass: MassValue;\n\t}\n\trequirement def <'1'> VehicleMassLimitationRequirement :> MassLimitationRequirement {\n\t\tdoc /* The total mass of a vehicle shall be less than or equal to the required mass. */\n\t\tsubject vehicle : Vehicle;\n\t\tattribute redefines massActual = vehicle.dryMass + vehicle.fuelMass;\n\t\tassume constraint { vehicle.fuelMass > 0[kg] }\n\t}\n\tport def ClutchPort;\n\taction def GenerateTorque;\n\trequirement def <'2'> DrivePowerInterface {\n\t\tdoc /* The engine shall transfer its generated torque to the transmission via the clutch interface. */\n\t\tsubject clutchPort: ClutchPort;\n\t}\t\n\trequirement def <'3'> TorqueGeneration {\n\t\tdoc /* The engine shall generate torque as a function of RPM as shown in Table 1. */\n\t\tsubject generateTorque: GenerateTorque;\n\t}\n\trequirement <'1.1'> fullVehicleMassLimit : VehicleMassLimitationRequirement {\n\t\tsubject vehicle : Vehicle;\n\t\tattribute :>> massReqd = 2000[kg];\n\t\tassume constraint {\n\t\t\tdoc /* Full tank is full. */\n\t\t\tvehicle.fuelMass == vehicle.fuelFullMass\n\t\t}\n\t}\n\trequirement <'1.2'> emptyVehicleMassLimit : VehicleMassLimitationRequirement {\n\t\tsubject vehicle : Vehicle;\n\t\tattribute :>> massReqd = 1500[kg];\t\n\t\tassume constraint {\n\t\t\tdoc /* Full tank is empty. */\n\t\t\tvehicle.fuelMass == 0[kg]\n\t\t}\n\t}\n}",
    "domain": "Vehicle Traffic",
    "grammar": "Requirement",
    "diagram": "dataset/sysml/samples/71/design.png"
  },
  {
    "nl": "This system is designed to analyze the dynamic performance of vehicles, focusing primarily on modeling and calculating the power demand, acceleration, speed, and position variations over time during straight-line driving. Users can set vehicle attributes (such as curb weight, payload, wheel diameter, transmission efficiency, and fuel economy under urban and highway conditions) as well as specific driving cycles (including time-stamped position and speed information) to analyze the required engine power, acceleration, and other dynamic parameters necessary to meet these conditions. Further, the system can calculate the vehicle’s fuel economy throughout the entire driving cycle. It supports compliance verification based on specified energy consumption targets (such as fuel consumption per 100 kilometers or miles per gallon), enabling users to check whether the vehicle can, for example, achieve a fuel economy of over 30 miles per gallon under given scenarios and vehicle configurations. The system features adjustable configuration options, allowing users to conveniently input various vehicle parameters and drive cycle scenarios to facilitate vehicle performance analysis and energy consumption assessment. This provides data support and decision-making references for vehicle design optimization and achievement of energy consumption targets.",
    "design": "package 'VehiclePerformanceAnalysis' {\n\tprivate import ScalarValues::Real;\n\tprivate import USCustomaryUnits::*;\n\tprivate import SequenceFunctions::size;\n\tprivate import Quantities::ScalarQuantityValue;\n\tprivate import ControlFunctions::*;\n\tprivate import ScalarValues::Positive;\n\tprivate import ISQ::*;\n\tcalc def Power { in whlpwr : PowerValue; in Cd : Real; in Cf : Real; in tm : MassValue; in v : SpeedValue;\n\t\tattribute drag = Cd * v;\n\t\tattribute friction = Cf * tm * v;\n\t\treturn : PowerValue = whlpwr - drag - friction;\n\t}\n\tcalc def Acceleration { in tp: PowerValue; in tm : MassValue; in v : SpeedValue;\n\t\treturn : AccelerationValue = tp / (tm * v);\n\t}\n\tcalc def Velocity { in dt : TimeValue; in v0 : SpeedValue; in a : AccelerationValue;\n\t\treturn : SpeedValue = v0 + a * dt;\n \t}\n\tcalc def Position { in dt : TimeValue; in x0 : LengthValue; in v : SpeedValue;\n\t\treturn : LengthValue = x0 + v * dt;\n\t}\n\tconstraint def StraightLineDynamicsEquations {\n\t\tin p : PowerValue;\n\t\tin m : MassValue;\n\t\tin dt : TimeValue;\n\t\tin x_i : LengthValue;\n\t\tin v_i : SpeedValue;\n\t\tin x_f : LengthValue;\n\t\tin v_f : SpeedValue;\n\t\tin a : AccelerationValue;\n\t\tattribute v_avg : SpeedValue = (v_i + v_f)/2;\n\t\ta == Acceleration(p, m, v_avg) and\n\t\tv_f == Velocity(dt, v_i, a) and\n\t\tx_f == Position(dt, x_i, v_avg)\n\t}\n\taction def StraightLineDynamics {\n\t\tin power : PowerValue;\n\t\tin mass : MassValue;\n\t\tin delta_t : TimeValue;\n\t\tin x_in : LengthValue;\n\t\tin v_in : SpeedValue;\n\t\tout x_out : LengthValue;\n\t\tout v_out : SpeedValue;\n\t\tout a_out : AccelerationValue;\n\t    assert constraint dynamics : StraightLineDynamicsEquations {\n\t\t\tin p = power;\n\t\t\tin m = mass;\n\t\t\tin dt = delta_t;\n\t\t\tin x_i = x_in;\n\t\t\tin v_i = v_in;\n\t\t\tin x_f = x_out;\n\t\t\tin v_f = v_out;\n\t\t\tin a = a_out;\n\t    }\n\t}\n\tattribute def DistancePerVolumeValue :> ScalarQuantityValue;\n\tpart def Vehicle {\n        attribute mass : MassValue;\n        attribute cargoMass : MassValue;\n        attribute wheelDiameter : LengthValue;\n        attribute driveTrainEfficiency : Real;\n        attribute fuelEconomy_city : DistancePerVolumeValue;\n        attribute fuelEconomy_highway : DistancePerVolumeValue;\n    }\n    attribute def WayPoint {\n\t\ttime : TimeValue;\n\t\tposition : LengthValue;\n\t\tspeed : SpeedValue;    \t\n\t}\n\tanalysis def FuelEconomyAnalysis {\n\t\tsubject vehicle : Vehicle;\n\t\tobjective fuelEconomyAnalysisObjective {\n\t\t\t/*\n\t\t\t * The objective of this analysis is to determine whether the\n\t\t\t * subject vehicle can satisfy the fuel economy requirement.\n\t\t\t */\t\t\n\t\t\tassume constraint {\n\t\t\t\tvehicle.wheelDiameter == 33 ['in'] &\n\t\t\t\tvehicle.driveTrainEfficiency == 0.4\n\t\t\t}\n\t\t\trequire constraint {\n\t\t\t\tfuelEconomyResult > 30 [mi / gal]\n\t\t\t}\n\t\t}\n\t\tin attribute scenario : WayPoint[*];\n\t\taction solveForPower {\n\t\t\tout power : PowerValue[*];\n\t\t\tout acceleration : AccelerationValue[*];\n\t\t\t/*\n\t\t\t * Solve for the required engine power as a function of time\n\t\t\t * to support the scenario.\n\t\t\t */\n\t\t\tassert constraint {\n\t\t\t\t(1..size(scenario)-1)->forAll {in i: Positive;\n\t\t\t\t\tStraightLineDynamicsEquations (\n\t\t\t\t\t\tpower#(i),\n\t\t\t\t\t\tvehicle.mass,\n\t\t\t\t\t\tscenario.time#(i+1) - scenario.time#(i),\n\t\t\t\t\t\tscenario.position#(i),\n\t\t\t\t\t\tscenario.speed#(i),\n\t\t\t\t\t\tscenario.position#(i+1),\n\t\t\t\t\t\tscenario.speed#(i+1),\n\t\t\t\t\t\tacceleration#(i+1)                    \n\t\t\t\t\t)\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tthen action solveForFuelConsumption {\n\t\t\tin power : PowerValue[*] = solveForPower.power;\n\t\t\tout fuelEconomy : DistancePerVolumeValue;\n\t\t\t/*\n\t\t\t * Solve the engine equations to determine how much fuel is\n\t\t\t * consumed.\n\t\t\t */\n\t\t}\n        return fuelEconomyResult : DistancePerVolumeValue = solveForFuelConsumption.fuelEconomy;\n\t}\n}",
    "domain": "Vehicle Traffic",
    "grammar": "Analysis",
    "diagram": "dataset/sysml/samples/72/design.png"
  },
  {
    "nl": "This system aims to perform simulation analysis on vehicle fuel economy. By setting different urban and highway driving scenarios, it calculates the actual fuel economy of vehicles under these conditions to verify whether they meet the requirement of exceeding 30 miles per gallon. Vehicle parameters include curb weight, load, wheel diameter, transmission efficiency, and others. Under given driving trajectories and speed variations, the model analyzes the required wheel power, applies vehicle dynamics to calculate acceleration and energy consumption, and further estimates the actual engine power demand. Ultimately, it determines the corresponding fuel consumption and fuel economy in terms of liters per 100 kilometers. Users can use these results to assess whether the vehicle design meets energy-saving, emissions reduction, and regulatory compliance requirements in real-world use scenarios.",
    "design": "package 'VehicleFuelEconomySimulation' {\n\tprivate import ScalarValues::Real;\n\tprivate import USCustomaryUnits::*;\n\tprivate import SequenceFunctions::size;\n\tprivate import Quantities::ScalarQuantityValue;\n\tprivate import ControlFunctions::*;\n\tprivate import ScalarValues::Positive;\n\tprivate import ISQ::*;\n\tcalc def Power { in whlpwr : PowerValue; in Cd : Real; in Cf : Real; in tm : MassValue; in v : SpeedValue;\n\t\tattribute drag = Cd * v;\n\t\tattribute friction = Cf * tm * v;\n\t\treturn : PowerValue = whlpwr - drag - friction;\n\t}\n\tcalc def Acceleration { in tp: PowerValue; in tm : MassValue; in v : SpeedValue;\n\t\treturn : AccelerationValue = tp / (tm * v);\n\t}\n\tcalc def Velocity { in dt : TimeValue; in v0 : SpeedValue; in a : AccelerationValue;\n\t\treturn : SpeedValue = v0 + a * dt;\n \t}\n\tcalc def Position { in dt : TimeValue; in x0 : LengthValue; in v : SpeedValue;\n\t\treturn : LengthValue = x0 + v * dt;\n\t}\n\tconstraint def StraightLineDynamicsEquations {\n\t\tin p : PowerValue;\n\t\tin m : MassValue;\n\t\tin dt : TimeValue;\n\t\tin x_i : LengthValue;\n\t\tin v_i : SpeedValue;\n\t\tin x_f : LengthValue;\n\t\tin v_f : SpeedValue;\n\t\tin a : AccelerationValue;\n\t\tattribute v_avg : SpeedValue = (v_i + v_f)/2;\n\t\ta == Acceleration(p, m, v_avg) and\n\t\tv_f == Velocity(dt, v_i, a) and\n\t\tx_f == Position(dt, x_i, v_avg)\n\t}\n\taction def StraightLineDynamics {\n\t\tin power : PowerValue;\n\t\tin mass : MassValue;\n\t\tin delta_t : TimeValue;\n\t\tin x_in : LengthValue;\n\t\tin v_in : SpeedValue;\n\t\tout x_out : LengthValue;\n\t\tout v_out : SpeedValue;\n\t\tout a_out : AccelerationValue;\n\t    assert constraint dynamics : StraightLineDynamicsEquations {\n\t\t\tin p = power;\n\t\t\tin m = mass;\n\t\t\tin dt = delta_t;\n\t\t\tin x_i = x_in;\n\t\t\tin v_i = v_in;\n\t\t\tin x_f = x_out;\n\t\t\tin v_f = v_out;\n\t\t\tin a = a_out;\n\t    }\n\t}\n\tattribute def DistancePerVolumeValue :> ScalarQuantityValue;\n\tpart def Vehicle {\n        attribute mass : MassValue;\n        attribute cargoMass : MassValue;\n        attribute wheelDiameter : LengthValue;\n        attribute driveTrainEfficiency : Real;\n        attribute fuelEconomy_city : DistancePerVolumeValue;\n        attribute fuelEconomy_highway : DistancePerVolumeValue;\n    }\n    attribute def WayPoint {\n\t\ttime : TimeValue;\n\t\tposition : LengthValue;\n\t\tspeed : SpeedValue;    \t\n\t}\n\tanalysis def FuelEconomyAnalysis {\n\t\tsubject vehicle : Vehicle;\n\t\tobjective fuelEconomyAnalysisObjective {\n\t\t\t/*\n\t\t\t * The objective of this analysis is to determine whether the\n\t\t\t * subject vehicle can satisfy the fuel economy requirement.\n\t\t\t */\t\t\n\t\t\tassume constraint {\n\t\t\t\tvehicle.wheelDiameter == 33 ['in'] &\n\t\t\t\tvehicle.driveTrainEfficiency == 0.4\n\t\t\t}\n\t\t\trequire constraint {\n\t\t\t\tfuelEconomyResult > 30 [mi / gal]\n\t\t\t}\n\t\t}\n\t\tin attribute scenario : WayPoint[*];\n\t\taction solveForPower {\n\t\t\tout power : PowerValue[*];\n\t\t\tout acceleration : AccelerationValue[*];\n\t\t\t/*\n\t\t\t * Solve for the required engine power as a function of time\n\t\t\t * to support the scenario.\n\t\t\t */\n\t\t\tassert constraint {\n\t\t\t\t(1..size(scenario)-1)->forAll {in i: Positive;\n\t\t\t\t\tStraightLineDynamicsEquations (\n\t\t\t\t\t\tpower#(i),\n\t\t\t\t\t\tvehicle.mass,\n\t\t\t\t\t\tscenario.time#(i+1) - scenario.time#(i),\n\t\t\t\t\t\tscenario.position#(i),\n\t\t\t\t\t\tscenario.speed#(i),\n\t\t\t\t\t\tscenario.position#(i+1),\n\t\t\t\t\t\tscenario.speed#(i+1),\n\t\t\t\t\t\tacceleration#(i+1)                    \n\t\t\t\t\t)\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tthen action solveForFuelConsumption {\n\t\t\tin power : PowerValue[*] = solveForPower.power;\n\t\t\tout fuelEconomy : DistancePerVolumeValue;\n\t\t\t/*\n\t\t\t * Solve the engine equations to determine how much fuel is\n\t\t\t * consumed.\n\t\t\t */\n\t\t}\n        return fuelEconomyResult : DistancePerVolumeValue = solveForFuelConsumption.fuelEconomy;\n\t}\n\n\tpart vehicleFuelEconomyAnalysisContext {\n\t\trequirement vehicleFuelEconomyRequirements {\n\t\t\tsubject vehicle : Vehicle;\n\t\t\t// ...\n\t\t}\n\t\tattribute cityScenario : WayPoint[*] = ( //* ... */ );\n\t\tattribute highwayScenario : WayPoint[*] = ( //* ... */ );\n\t\tanalysis cityAnalysis : FuelEconomyAnalysis {\n\t\t\tsubject vehicle = vehicle_c1;\n\t\t\tin scenario = cityScenario;\n\t\t}\n\t\tanalysis highwayAnalysis : FuelEconomyAnalysis {\n\t\t\tsubject vehicle = vehicle_c1;\n\t\t\tin scenario = highwayScenario;\n\t\t}\n\t\tpart vehicle_c1 : Vehicle {\n\t\t\t// ...\t\n\t\t\tattribute :>> fuelEconomy_city = cityAnalysis.fuelEconomyResult;\n\t\t\tattribute :>> fuelEconomy_highway = highwayAnalysis.fuelEconomyResult;\n\t\t}\n\t\tsatisfy vehicleFuelEconomyRequirements by vehicle_c1;\n\t}\n}",
    "domain": "Vehicle Traffic",
    "grammar": "Analysis",
    "diagram": "dataset/sysml/samples/73/design.png"
  },
  {
    "nl": "This system is designed to conduct a comprehensive selection analysis for various types of engines, including four-cylinder and six-cylinder engines. For each type of engine, the system will aggregate and calculate key performance indicators such as power, mass, efficiency, and cost. Based on these indicators, a unified evaluation function will be used to comprehensively assess each engine. Finally, according to the comprehensive evaluation results, the system will automatically screen and recommend the optimal engine selection from all candidates, thereby maximizing both engine performance and economic efficiency.",
    "design": "package 'EngineSelectionTradeStudy' {\n\tprivate import ScalarValues::Real;\n\tprivate import TradeStudies::*;\n\tpart def Engine;\n\tpart engine4cyl : Engine;\n\tpart engine6cyl : Engine;\n\tcalc def PowerRollup { in engine : Engine; return : ISQ::PowerValue; }\n\tcalc def MassRollup { in engine : Engine; return : ISQ::MassValue; }\n\tcalc def EfficiencyRollup { in engine : Engine; return : Real; }\n\tcalc def CostRollup { in engine : Engine; return : Real; }\n\tcalc def EngineEvaluation { \n\t\tin power : ISQ::PowerValue;\n\t\tin mass : ISQ::MassValue;\n\t\tin efficiency : Real;\n\t\tin cost : Real;\n\t\treturn evaluation : Real;\n\t\t// Compute evaluation...\n\t}\n\tanalysis engineTradeStudy : TradeStudy {\n\t\tsubject : Engine = (engine4cyl, engine6cyl);\n\t\tobjective : MaximizeObjective;\n\t\tcalc :>> evaluationFunction {\n\t\t\tin part anEngine :>> alternative : Engine;\n\t\t\tcalc powerRollup: PowerRollup { in engine = anEngine; return power; }\n\t\t\tcalc massRollup: MassRollup { in engine = anEngine; return mass; }\n\t\t\tcalc efficiencyRollup: EfficiencyRollup { in engine = anEngine; return efficiency; }\n\t\t\tcalc costRollup: CostRollup { in engine = anEngine; return cost; }\n\t\t\treturn :>> result : Real = EngineEvaluation(\n\t\t\t\tpowerRollup.power, massRollup.mass, efficiencyRollup.efficiency, costRollup.cost\n\t\t\t);\n\t\t}\n\t\treturn part :>> selectedAlternative : Engine;\n\t}\n}",
    "domain": "Vehicle Traffic",
    "grammar": "Analysis",
    "diagram": "dataset/sysml/samples/74/design.png"
  },
  {
    "nl": "To ensure that the quality of vehicles meets relevant requirements, the system needs to check the curb weight of each vehicle. The curb weight of each vehicle must be less than or equal to 2,500 kilograms. The relevant tests include collecting the actual weight data of the vehicle, processing the collected data, and using the processed data as the basis to determine whether the vehicle's weight meets the specified standards, ultimately producing a qualified or unqualified evaluation result. This process must have clear steps of data collection, processing, and evaluation to ensure the scientific and accurate detection of vehicle quality.",
    "design": "package 'VehicleMassComplianceVerification' {\n\tpart def Vehicle {\n\t\tattribute mass :> ISQ::mass;\n\t}\n\trequirement vehicleMassRequirement {\n\t\tsubject vehicle : Vehicle;\n\t\tin massActual :> ISQ::mass = vehicle.mass;\n\t\tdoc /* The vehicle mass shall be less than or equal to 2500 kg. */\n\t\t\n\t\trequire constraint { massActual <= 2500[SI::kg] }\n\t}\t\n\tverification def VehicleMassTest {\n\t\tprivate import VerificationCases::*;\n\t\tsubject testVehicle : Vehicle;\n\t\tobjective vehicleMassVerificationObjective {\n\t\t\t// The subject of the verify is automatically bound to 'testVehicle' here.\n\t\t\tverify vehicleMassRequirement;\n\t\t}\n\t\taction collectData {\n\t\t\tin part testVehicle : Vehicle = VehicleMassTest::testVehicle;\n\t\t\tout massMeasured :> ISQ::mass;\n\t\t}\n\t\taction processData {\n\t\t\tin massMeasured :> ISQ::mass = collectData.massMeasured;\n\t\t\tout massProcessed :> ISQ::mass;\n\t\t}\n\t\taction evaluateData {\n\t\t\tin massProcessed :> ISQ::mass = processData.massProcessed;\n\t\t\tout verdict : VerdictKind = \n\t\t\t\t// Check that 'testVehicle' statisfies 'vehicleMassRequirement' if its mass equals 'massProcessed'.\n\t\t\t\tPassIf(vehicleMassRequirement(vehicle = testVehicle(mass = massProcessed)));\n\t\t}\n\t\treturn verdict : VerdictKind = evaluateData.verdict;\n\t}\n}",
    "domain": "Vehicle Traffic",
    "grammar": "Verification",
    "diagram": "dataset/sysml/samples/75/design.png"
  },
  {
    "nl": "The system is designed to verify the mass of vehicles to ensure that the actual mass of each vehicle does not exceed 2,500 kilograms. Under this system, every vehicle to be inspected must undergo a mass inspection process to check whether its mass complies with the specified upper limit. The system consists of vehicles, weighing equipment, and a mass verification unit. It measures the current actual mass of the vehicle using the weighing equipment and processes and evaluates the measured data. If the inspected vehicle's mass is less than or equal to 2,500 kilograms, it is deemed qualified; if it exceeds this value, it is deemed unqualified. The entire mass verification process is carried out independently for each vehicle to ensure that all vehicles involved in verification comply with the relevant standards and regulatory requirements.",
    "design": "package 'VehicleMassVerificationTestSystem' {\n\tpart def Vehicle {\n\t\tattribute mass :> ISQ::mass;\n\t}\n\trequirement vehicleMassRequirement {\n\t\tsubject vehicle : Vehicle;\n\t\tin massActual :> ISQ::mass = vehicle.mass;\n\t\tdoc /* The vehicle mass shall be less than or equal to 2500 kg. */\n\t\trequire constraint { massActual <= 2500[SI::kg] }\n\t}\t\n\tverification def VehicleMassTest {\n\t\tprivate import VerificationCases::*;\n\t\tsubject testVehicle : Vehicle;\n\t\tobjective vehicleMassVerificationObjective {\n\t\t\t// The subject of the verify is automatically bound to 'testVehicle' here.\n\t\t\tverify vehicleMassRequirement;\n\t\t}\n\t\taction collectData {\n\t\t\tin part testVehicle : Vehicle = VehicleMassTest::testVehicle;\n\t\t\tout massMeasured :> ISQ::mass;\n\t\t}\n\t\taction processData {\n\t\t\tin massMeasured :> ISQ::mass = collectData.massMeasured;\n\t\t\tout massProcessed :> ISQ::mass;\n\t\t}\n\t\taction evaluateData {\n\t\t\tin massProcessed :> ISQ::mass = processData.massProcessed;\n\t\t\tout verdict : VerdictKind = \n\t\t\t\t// Check that 'testVehicle' statisfies 'vehicleMassRequirement' if its mass equals 'massProcessed'.\n\t\t\t\tPassIf(vehicleMassRequirement(vehicle = testVehicle(mass = massProcessed)));\n\t\t}\n\t\treturn verdict : VerdictKind = evaluateData.verdict;\n\t}\n\tpart def MassVerificationSystem;\n\tpart def Scale;\n\tpart vehicleTestConfig : Vehicle {\n\t\t// ...\n\t}\n\tverification vehicleMassTest : VehicleMassTest {\n\t\tsubject testVehicle :> vehicleTestConfig;\n\t}\n\tpart massVerificationSystem : MassVerificationSystem {\n\t\tperform vehicleMassTest;\t\n\t\tpart scale : Scale {\n\t\t\tperform vehicleMassTest.collectData {\n\t\t\t\tin part :>> testVehicle;\n\t\t\t\t// In reality, this would be some more involved process.\n\t\t\t\tmeasurement = testVehicle.mass;\n\t\t\t\tout :>> massMeasured = measurement;\n\t\t\t}\n\t\t}\n\t}\t\t\n\tindividual def TestSystem :> MassVerificationSystem;\n\tindividual def TestVehicle1 :> Vehicle;\n\tindividual def TestVehicle2 :> Vehicle;\n\tindividual testSystem : TestSystem :> massVerificationSystem {\n\t\ttimeslice test1 {\n\t\t\tperform action :>> vehicleMassTest {\n\t\t\t\tin individual :>> testVehicle : TestVehicle1 {\n\t\t\t\t\t:>> mass = 2500[SI::kg];\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tthen timeslice test2 {\n\t\t\tperform action :>> vehicleMassTest {\n\t\t\t\tin individual :>> testVehicle : TestVehicle2 {\n\t\t\t\t\t:>> mass = 3000[SI::kg];\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n}",
    "domain": "Vehicle Traffic",
    "grammar": "Verification",
    "diagram": "dataset/sysml/samples/76/design.png"
  },
  {
    "nl": "The system is designed to provide end users with a convenient and efficient mode of transportation. It is capable of supporting a driver and up to four passengers sharing a vehicle, enabling them to travel safely and comfortably from the starting point to the destination. Users can freely enter and exit the vehicle, and the system should ensure that this process is simple and smooth. In addition, the system should fully consider and integrate surrounding environmental factors to ensure the safety and sustainability of the entire journey, while also being compatible with related infrastructure such as gas stations. The system’s operation should be centered on human needs, with a focus on ride experience and various conveniences, assisting passengers and drivers in smoothly completing all kinds of daily transportation tasks.",
    "design": "package 'TransportationScenario' {\n\tpart def Vehicle;\n\tpart def Person;\n\tpart def Environment;\n\tpart def 'Fuel Station';\n\tuse case def 'Provide Transportation' {\n\t\tsubject vehicle : Vehicle;\n\t\tactor driver : Person;\n\t\tactor passengers : Person[0..4];\n\t\tactor environment : Environment;\n\t\tobjective {\n\t\t\tdoc \n\t\t\t/* Transport driver and passengers from starting location \n\t\t\t * to ending location.\n\t\t\t */\n\t\t}\t\t\n\t}\n\tuse case def 'Enter Vehicle' {\n\t\tsubject vehicle : Vehicle;\n\t\tactor driver : Person;\n\t\tactor passengers : Person[0..4];\n\t}\n\tuse case def 'Exit Vehicle' {\n\t\tsubject vehicle : Vehicle;\n\t\tactor driver : Person;\n\t\tactor passengers : Person[0..4];\n\t}\n}",
    "domain": "Vehicle Traffic",
    "grammar": "Use Case",
    "diagram": "dataset/sysml/samples/77/design.png"
  },
  {
    "nl": "This system is designed to support comprehensive transportation scenarios, enabling a driver and up to four passengers to be safely transported from the starting point to the destination. Users first enter the vehicle, after which the driver operates the vehicle under the influence of environmental conditions, and may refuel at a gas station as needed to ensure a smooth journey. Upon arrival at the destination, the driver and passengers can safely exit the vehicle, thereby completing the entire transportation process. The system should ensure that interactions among all participants are simple and convenient, meeting the primary needs of daily transportation.",
    "design": "package 'CompleteTransportationScenario' {\n\tpart def Vehicle;\n\tpart def Person;\n\tpart def Environment;\n\tpart def 'Fuel Station';\n\tuse case def 'Provide Transportation' {\n\t\tsubject vehicle : Vehicle;\n\t\tactor driver : Person;\n\t\tactor passengers : Person[0..4];\n\t\tactor environment : Environment;\n\t\tobjective {\n\t\t\tdoc \n\t\t\t/* Transport driver and passengers from starting location \n\t\t\t * to ending location.\n\t\t\t */\n\t\t}\t\t\n\t}\n\tuse case def 'Enter Vehicle' {\n\t\tsubject vehicle : Vehicle;\n\t\tactor driver : Person;\n\t\tactor passengers : Person[0..4];\n\t}\n\tuse case def 'Exit Vehicle' {\n\t\tsubject vehicle : Vehicle;\n\t\tactor driver : Person;\n\t\tactor passengers : Person[0..4];\n\t}\n\tpart def 'Fuel Station';\n\tuse case 'provide transportation' : 'Provide Transportation' {\t\t\n\t\tfirst start;\n\t\tthen include use case 'enter vehicle' : 'Enter Vehicle' {\n\t\t\tactor :>> driver = 'provide transportation'::driver;\n\t\t\tactor :>> passengers = 'provide transportation'::passengers;\n\t\t}\n\t\tthen use case 'drive vehicle' {\n\t\t\tactor driver = 'provide transportation'::driver;\n\t\t\tactor environment = 'provide transportation'::environment;\t\n\t\t\tinclude 'add fuel'[0..*] { \n\t\t\t\tactor :>> fueler = driver;\n\t\t\t}\n\t\t}\n\t\tthen include use case 'exit vehicle' : 'Exit Vehicle' {\n\t\t\tactor :>> driver = 'provide transportation'::driver;\n\t\t\tactor :>> passengers = 'provide transportation'::passengers;\n\t\t}\n\t\tthen done;\t\t\n\t}\n\tuse case 'add fuel' {\n\t\tsubject vehicle : Vehicle;\n\t\tactor fueler : Person;\n\t\tactor 'fuel station' : 'Fuel Station';\n\t}\n}",
    "domain": "Vehicle Traffic",
    "grammar": "Use Case",
    "diagram": "dataset/sysml/samples/78/design.png"
  },
  {
    "nl": "This system is primarily designed for configuration management of the vehicle product line and aims to support the diverse requirements for engine and transmission combinations. Vehicles can be equipped with different types of engines, including four-cylinder and six-cylinder engines; the four-cylinder engine has 4 cylinders, while the six-cylinder engine has 6 cylinders. For each cylinder, the diameter can be selected as either small (70 mm) or large (100 mm). Vehicles can also choose between manual and automatic transmissions, but there are strict combination constraints: manual transmissions are only allowed when a four-cylinder engine is selected, and six-cylinder engines can only be paired with automatic transmissions; no other combinations are permitted. The system needs to flexibly support the creation of these variants while ensuring that each vehicle satisfies the above combination rules to guarantee the correctness and rationality of the product structure.",
    "design": "package 'VehicleProductLineConfiguration' {\n\tprivate import ScalarValues::Real;\n\tprivate import SI::mm;\n\tattribute def Diameter :> ISQ::LengthValue;\n    part def Cylinder {\n        attribute diameter : Diameter[1];\n    }\n    part def Engine {\n    \tpart cylinder : Cylinder[2..*];\n    }\n    part '4cylEngine' : Engine {\n    \tpart redefines cylinder[4];\n    }\n    part '6cylEngine' : Engine {\n    \tpart redefines cylinder[6];\n    }\n\tvariation attribute def DiameterChoices :> Diameter {\n\t\tvariant attribute diameterSmall = 70[mm];\n\t\tvariant attribute diameterLarge = 100[mm];\n\t}\n\tvariation part def EngineChoices :> Engine {\n\t\tvariant '4cylEngine';\n\t\tvariant '6cylEngine';\t\t\n\t}\n\tpart def Vehicle;\n\tpart def Transmission;\n\tpart manualTransmission;\n\tpart automaticTransmission;\n\tabstract part vehicleFamily : Vehicle {\n\t\tpart engine : EngineChoices[1];\n\t\tvariation part transmission : Transmission[1] {\n\t\t\tvariant manualTransmission;\n\t\t\tvariant automaticTransmission;\n\t\t}\n\t\tassert constraint {\n\t\t\t(engine == engine::'4cylEngine' and\n\t\t\t transmission == transmission::manualTransmission) xor\n\t\t\t(engine == engine::'6cylEngine' and \n\t\t\t transmission == transmission::automaticTransmission)\n\t\t}\t\n\t}\n\tpart vehicle4Cyl :> vehicleFamily {\n\t\tpart redefines engine = engine::'4cylEngine';\n\t\tpart redefines transmission = transmission::manualTransmission;\n\t}\n\tpart vehicle6Cyl :> vehicleFamily {\n\t\tpart redefines engine = engine::'6cylEngine';\n\t\tpart redefines transmission = transmission::manualTransmission;\n\t}\n}",
    "domain": "Vehicle Traffic",
    "grammar": "Variability",
    "diagram": "dataset/sysml/samples/79/design.png"
  },
  {
    "nl": "This system requires the design of a configurable engine, with a basic structure composed of multiple cylinders. The number of cylinders can be either 4 or 6. Each cylinder is available in two diameters: 70 mm and 100 mm, with the specific selection depending on actual requirements. In terms of engine configurations, the system should support at least two engine variants: a four-cylinder engine and a six-cylinder engine. Users can choose the appropriate combination of cylinder quantity and diameter according to different application scenarios, thereby enabling flexible adjustment of engine performance and size.",
    "design": "package 'EngineConfigurationVariants' {\n\tprivate import ScalarValues::Real;\n\tprivate import SI::mm;\n\tattribute def Diameter :> ISQ::LengthValue;\n    part def Cylinder {\n        attribute diameter : Diameter[1];\n    }\n    part def Engine {\n    \tpart cylinder : Cylinder[2..*];\n    }\n    part '4cylEngine' : Engine {\n    \tpart redefines cylinder[4];\n    }\n    part '6cylEngine' : Engine {\n    \tpart redefines cylinder[6];\n    }\n\tvariation attribute def DiameterChoices :> Diameter {\n\t\tvariant attribute diameterSmall = 70[mm];\n\t\tvariant attribute diameterLarge = 100[mm];\n\t}\n\tvariation part def EngineChoices :> Engine {\n\t\tvariant '4cylEngine';\n\t\tvariant '6cylEngine';\t\t\n\t}\t\n}",
    "domain": "Vehicle Traffic",
    "grammar": "Variability",
    "diagram": "dataset/sysml/samples/80/design.png"
  },
  {
    "nl": "The system is designed to describe an automotive configuration space, supporting combinations of different engines and transmission systems. Vehicles can be equipped with either a 4-cylinder or 6-cylinder engine, with each engine type containing the corresponding number of cylinders. Cylinder diameter is a key parameter and can be selected between two specifications: 70mm and 100mm. Each vehicle can only be fitted with one type of engine and one type of transmission system. The transmission can be either a manual or an automatic gearbox. Furthermore, the following constraints apply to concrete configurations: if the engine is a 4-cylinder, a manual transmission must be used; if the engine is a 6-cylinder, an automatic transmission must be used. This model provides users with a clear structure and constraints, enabling the flexible selection of vehicle components and parameters according to actual requirements.",
    "design": "package 'VehicleConfigurationSpace' {\n\tprivate import ScalarValues::Real;\n\tprivate import SI::mm;\n\tattribute def Diameter :> ISQ::LengthValue;\n    part def Cylinder {\n        attribute diameter : Diameter[1];\n    }\n    part def Engine {\n    \tpart cylinder : Cylinder[2..*];\n    }\n    part '4cylEngine' : Engine {\n    \tpart redefines cylinder[4];\n    }\n    part '6cylEngine' : Engine {\n    \tpart redefines cylinder[6];\n    }\n\tvariation attribute def DiameterChoices :> Diameter {\n\t\tvariant attribute diameterSmall = 70[mm];\n\t\tvariant attribute diameterLarge = 100[mm];\n\t}\n\tvariation part def EngineChoices :> Engine {\n\t\tvariant '4cylEngine';\n\t\tvariant '6cylEngine';\t\t\n\t}\n\tpart def Vehicle;\n\tpart def Transmission;\n\tpart manualTransmission;\n\tpart automaticTransmission;\n\tabstract part vehicleFamily : Vehicle {\n\t\tpart engine : EngineChoices[1];\n\t\tvariation part transmission : Transmission[1] {\n\t\t\tvariant manualTransmission;\n\t\t\tvariant automaticTransmission;\n\t\t}\n\t\tassert constraint {\n\t\t\t(engine == engine::'4cylEngine' and\n\t\t\t transmission == transmission::manualTransmission) xor\n\t\t\t(engine == engine::'6cylEngine' and \n\t\t\t transmission == transmission::automaticTransmission)\n\t\t}\t\n\t}\n}",
    "domain": "Vehicle Traffic",
    "grammar": "Variability",
    "diagram": "dataset/sysml/samples/81/design.png"
  },
  {
    "nl": "This system must be composed of a system assembly, which includes a computer subsystem and a storage subsystem. The software design section should define the message format and data format. The computer subsystem must be capable of utilizing and integrating all functions specified in the software design, while the storage subsystem must be able to access and be compatible with the message and data formats defined by the software. The software and hardware of the entire system must be able to work together seamlessly to ensure that the processes of information storage, transmission, and processing within the system are efficient, reliable, and compliant with the required data structure specifications.",
    "design": "package 'SoftwareHardwareDependencies' {\n\tpart 'System Assembly' {\n\t\tpart 'Computer Subsystem' {\n\t\t\t// ...\n\t\t}\n\t\tpart 'Storage Subsystem' {\n\t\t\t// ...\n\t\t}\n\t}\n\tpackage 'Software Design' {\n\t\titem def MessageSchema {\n\t\t\t// ...\n\t\t}\n\t\titem def DataSchema {\n\t\t\t// ...\n\t\t}\n\t}\n\tdependency from 'System Assembly'::'Computer Subsystem' to 'Software Design';\n\tdependency Schemata \n\t\tfrom 'System Assembly'::'Storage Subsystem' \n\t\tto 'Software Design'::MessageSchema, 'Software Design'::DataSchema;\n}",
    "domain": "Information Management",
    "grammar": "Dependency",
    "diagram": "dataset/sysml/samples/82/design.png"
  },
  {
    "nl": "This system is designed to achieve efficient allocation and management of the powertrain system. The powertrain system consists of a logical layer and a physical layer. In the logical layer, logical components are required to provide power and generate torque, among which the torque generator is responsible for converting power into torque. In the physical layer, there must be corresponding physical components to integrate these functions—for example, the power unit should be capable of both power output and torque generation. The system needs to ensure that the torque generator in the logical layer can be effectively mapped to the corresponding power unit (such as an engine) in the physical layer. Through this mapping relationship, all functional requirements can be accurately realized in the physical hardware, thus ensuring that the vehicle or equipment possesses power transmission and torque output capabilities, and meets the user's core demands for power performance.",
    "design": "package 'PowertrainAllocation' {\n\tpackage LogicalModel {\n\t\taction def ProvidePower;\n\t\taction def GenerateTorque;\n\t\tpart def LogicalElement;\n\t\tpart def TorqueGenerator :> LogicalElement;\n\t\taction providePower : ProvidePower {\n\t\t\taction generateTorque : GenerateTorque;\n\t\t}\n\t\tpart torqueGenerator : TorqueGenerator {\n\t\t\tperform providePower.generateTorque;\n\t\t}\n\t}\n\tpackage PhysicalModel {\n\t\tprivate import LogicalModel::*;\t\n\t\tpart def PhysicalElement;\n\t\tpart def PowerTrain :> PhysicalElement;\n\t\tpart powerTrain : PowerTrain {\n\t\t\tpart engine {\n\t\t\t\tperform providePower.generateTorque;\n\t\t\t}\n\t\t}\n\t\tallocation def LogicalToPhysical {\n\t\t\tend logical : LogicalElement;\n\t\t\tend physical : PhysicalElement;\n\t\t}\n\t\tallocation torqueGenAlloc : LogicalToPhysical allocate torqueGenerator to powerTrain;\n\t}\t\n}",
    "domain": "Vehicle Traffic",
    "grammar": "Functional Allocation",
    "diagram": "dataset/sysml/samples/83/design.png"
  },
  {
    "nl": "The system requires the power transmission system to provide power and generate torque. In the logical model, the system possesses the capability to deliver power and generate torque, which is specifically realized through the action of \"generating torque\" by the torque generator component, enabling the transfer and conversion of power. In the physical model, the powertrain includes the engine as a component, and the engine actually performs the function of generating torque. Ultimately, the model specifies that the logical-layer torque generator is to be allocated to the physical powertrain component, with the specific operation of generating torque further allocated to the engine within the powertrain. The system as a whole must ensure, through the above division and allocation, effective generation and management of power and torque to meet the practical requirements for power output during vehicle operation.",
    "design": "package 'PowertrainAllocation' {\n\tpackage LogicalModel {\n\t\taction def ProvidePower;\n\t\taction def GenerateTorque;\n\t\tpart def TorqueGenerator;\n\t\taction providePower : ProvidePower {\n\t\t\taction generateTorque : GenerateTorque;\n\t\t}\n\t\tpart torqueGenerator : TorqueGenerator {\n\t\t\tperform providePower.generateTorque;\n\t\t}\n\t}\n\tpackage PhysicalModel {\n\t\tprivate import LogicalModel::*;\n\t\tpart def PowerTrain;\n\t\tpart def Engine;\n\t\tpart powerTrain : PowerTrain {\n\t\t\tpart engine : Engine {\n\t\t\t\tperform providePower.generateTorque;\n\t\t\t}\n\t\t}\n\t\tallocate torqueGenerator to powerTrain {\n\t\t\tallocate torqueGenerator.generateTorque to powerTrain.engine.generateTorque;\n\t\t}\n\t}\n}",
    "domain": "Vehicle Traffic",
    "grammar": "Functional Allocation",
    "diagram": "dataset/sysml/samples/84/design.png"
  },
  {
    "nl": "This system is a vehicle feature annotation system, designed to identify and manage the safety and anti-theft (security and protection) configurations of various parts within a complete vehicle model. The vehicle should be equipped with basic safety features such as seat belts, driver airbags, and bumpers, as well as security features including anti-theft alarms and keyless entry systems. \n\nThe system structure covers two main assemblies: the interior and the body assembly. The interior includes components such as seat belts, front seats, driver airbag, and alarm system, while the body assembly includes the body shell, bumpers, and keyless entry device. The system must clearly indicate the distribution of these components within the vehicle structure and specify their respective safety or protection functions, so as to comprehensively meet requirements for automotive safety and protection, user convenience, and property security.",
    "design": "package 'AutomotiveFeatureTaggingSystem' {\n\tmetadata def SafetyFeature;\n\tmetadata def SecurityFeature {\n\t\t:> annotatedElement : SysML::PartDefinition;\n\t\t:> annotatedElement : SysML::PartUsage;\n\t}\n\tmetadata SafetyFeature about \n\t\tvehicle::interior::seatBelt,\n\t\tvehicle::interior::driverAirBag,\n\t\tvehicle::bodyAssy::bumper;\n\tmetadata SecurityFeature about\n\t\tvehicle::interior::alarm,\n\t\tvehicle::bodyAssy::keylessEntry;\n\tpart vehicle {\n\t\tpart interior {\n\t\t\tpart alarm;\n\t\t\tpart seatBelt[2];\n\t\t\tpart frontSeat[2];\n\t\t\tpart driverAirBag;\n\t\t}\n\t\tpart bodyAssy {\n\t\t\tpart body;\n\t\t\tpart bumper;\n\t\t\tpart keylessEntry;\n\t\t}\n\t}\n}",
    "domain": "Vehicle Traffic",
    "grammar": "Metadata",
    "diagram": "dataset/sysml/samples/85/design.png"
  },
  {
    "nl": "The system shall be capable of performing automated simulation and analysis of vehicle dynamic behavior. Users should be able to input the vehicle’s initial velocity, initial position, acceleration at a specific moment, and the time step. Through integration with the ModelCenter analysis tool, the system shall automatically calculate and output the vehicle’s velocity and position after the specified time step based on the given physical model. The system must ensure accurate data transfer and reliable output of simulation results, enabling users to conveniently obtain key dynamic parameters to support vehicle performance analysis and design optimization.",
    "design": "package 'VehicleDynamicsSimulation' {\n\taction computeDynamics {\n\t\tprivate import AnalysisTooling::*;\n\t\tmetadata ToolExecution {\n\t\t\ttoolName = \"ModelCenter\";\n\t\t\turi = \"aserv://localhost/Vehicle/Equation1\";\n\t\t}\n\t\tin dt : ISQ::TimeValue             { @ToolVariable { name = \"deltaT\"; } }\n\t\tin a : ISQ::AccelerationValue      { @ToolVariable { name = \"mass\"; } }\n\t\tin v_in : ISQ::SpeedValue          { @ToolVariable { name = \"v0\"; } }\n\t\tin x_in : ISQ::LengthValue         { @ToolVariable { name = \"x0\"; } }\n\t\tout v_out : ISQ::SpeedValue        { @ToolVariable { name = \"v\"; } }\n\t\tout x_out : ISQ::LengthValue       { @ToolVariable { name = \"x\"; } }\t\t\t\n\t}\n}",
    "domain": "Vehicle Traffic",
    "grammar": "Metadata",
    "diagram": "dataset/sysml/samples/86/design.png"
  },
  {
    "nl": "This system model describes the safety compliance requirements of a car. It requires that the interior must be equipped with two mandatory seat belts, and explicitly states that the driver’s airbag is not a mandatory requirement (optional). The bumper in the body section is set as a mandatory safety device, while the keyless entry system is not a required safety option. For the wheel assembly, the car is equipped with two wheels and includes an optional anti-lock braking system (ABS). The model specifically separates “safety-related components” and “mandatory safety components” into two packages: all components marked as safety-relevant (@Safety) are recorded in “Safety Features,” while only those that are both safety components and marked as mandatory (@Safety and isMandatory=true) appear in the category of “Mandatory Safety Features.” This clearly distinguishes which safety configurations are legally required for installation and which are optional. This model helps companies and users clearly understand the safety configuration requirements of vehicles, facilitating compliant design and procurement decisions.",
    "design": "package 'VehicleSafetyCompliance' {\n\tprivate import ScalarValues::Boolean;\n\tmetadata def Safety {\n\t\tattribute isMandatory : Boolean;\n\t}\n\tpart vehicle {\n\t\tpart interior {\n\t\t\tpart alarm;\n\t\t\tpart seatBelt[2] {@Safety{isMandatory = true;}}\n\t\t\tpart frontSeat[2];\n\t\t\tpart driverAirBag {@Safety{isMandatory = false;}}\n\t\t}\n\t\tpart bodyAssy {\n\t\t\tpart body;\n\t\t\tpart bumper {@Safety{isMandatory = true;}}\n\t\t\tpart keylessEntry;\n\t\t}\n\t\tpart wheelAssy {\n\t\t\tpart wheel[2];\n\t\t\tpart antilockBrakes[2] {@Safety{isMandatory = false;}}\n\t\t}\n\t}\n\tpackage 'Safety Features' {\n\t\t/* Parts that contribute to safety. */\t\t\n\t\tprivate import vehicle::**;\n\t\tfilter @Safety;\n\t}\n\tpackage 'Mandatory Safety Features' {\n\t\t/* Parts that contribute to safety AND are mandatory. */\n\t\tprivate import vehicle::**;\n\t\tfilter @Safety and Safety::isMandatory;\n\t}\n}",
    "domain": "Vehicle Traffic",
    "grammar": "Filtering",
    "diagram": "dataset/sysml/samples/87/design.png"
  },
  {
    "nl": "The vehicle safety compliance system requires that all components of the vehicle possess corresponding safety features, some of which are mandatory. The vehicle interior must be equipped with two seat belts, and both seat belts are required safety features. Additionally, the driver’s airbag is an optional safety feature and is not mandatory. For the vehicle body, a bumper is required as a mandatory safety component, while the keyless entry system is a non-mandatory configuration. In the chassis system, the number of tires is fixed, and the anti-lock braking system (ABS) is an optional safety feature. Furthermore, the system categorizes and manages all safety-related parts and further distinguishes which safety components are required by law or industry standards and which are non-mandatory configurations, ensuring that the vehicle meets fundamental safety standards while offering more optional safety functions.",
    "design": "package 'VehicleSafetyCompliance' {\n\tprivate import ScalarValues::Boolean;\n\tmetadata def Safety {\n\t\tattribute isMandatory : Boolean;\n\t}\n\tpart vehicle {\n\t\tpart interior {\n\t\t\tpart alarm;\n\t\t\tpart seatBelt[2] {@Safety{isMandatory = true;}}\n\t\t\tpart frontSeat[2];\n\t\t\tpart driverAirBag {@Safety{isMandatory = false;}}\n\t\t}\n\t\tpart bodyAssy {\n\t\t\tpart body;\n\t\t\tpart bumper {@Safety{isMandatory = true;}}\n\t\t\tpart keylessEntry;\n\t\t}\n\t\tpart wheelAssy {\n\t\t\tpart wheel[2];\n\t\t\tpart antilockBrakes[2] {@Safety{isMandatory = false;}}\n\t\t}\n\t}\n\tpackage 'Safety Features' {\n\t\t/* Parts that contribute to safety. */\t\t\n\t\tprivate import vehicle::**[@Safety];\n\t}\n\tpackage 'Mandatory Safety Features' {\n\t\t/* Parts that contribute to safety AND are mandatory. */\n\t\tprivate import vehicle::**[@Safety and Safety::isMandatory];\n\t}\n}",
    "domain": "Vehicle Traffic",
    "grammar": "Filtering",
    "diagram": "dataset/sysml/samples/88/design.png"
  },
  {
    "nl": "This system is designed for modeling and managing risks and failures. It is capable of identifying and describing various possible situations, the causes leading to their occurrence, and the potential failures that may result. The system should be able to record the probability of each cause and the severity level of each failure. By establishing causal relationships, it analyzes the sequence and impact mechanisms among different situations. In addition, the system should support comprehensive modeling of different risk scenarios, enabling users to evaluate and manage potential risks and failures in an all-round manner. This provides a basis for risk control and decision-making.",
    "design": "library package 'RiskandFailureModelingLibrary' {\n\tprivate import ScalarValues::Real;\n\tprivate import RiskMetadata::Level;\n\tabstract occurrence def Situation;\n\tabstract occurrence situations : Situation[*] nonunique;\n\tabstract occurrence def Cause {\n\t\tattribute probability : Real;\n\t}\n\tabstract occurrence causes : Cause[*] nonunique :> situations;\n\tabstract occurrence def Failure {\n\t\tattribute severity : Level;\n\t}\n\tabstract occurrence failures : Failure[*] nonunique :> situations;\n\tabstract connection def Causation :> Occurrences::HappensBefore {\n\t\tend cause : Situation[*];\n\t\tend effect : Situation[*];\n\t}\n\tabstract connection causations : Causation[*] nonunique;\n\titem def Scenario {\n\t\toccurrence :>> situations;\n\t\toccurrence :>> causes :> situations;\n\t\toccurrence :>> failures :> situations;\n\t}\n\titem scenarios : Scenario[*] nonunique;\n}",
    "domain": "Fault diagnosis",
    "grammar": "Language Extension",
    "diagram": "dataset/sysml/samples/89/design.png"
  },
  {
    "nl": "This system is designed for systematic risk metadata modeling and management across various scenarios, causes, and failures. Users can identify and describe different scenarios that may occur within the system. For each scenario, the specific causes and their probabilities of occurrence can be detailed, and possible failure types along with their severity levels can be associated. Furthermore, the system supports the description and tracking of causal relationships between scenarios, facilitating the understanding and analysis of risk propagation chains. On this basis, users can also combine a set of interrelated scenarios, causes, and failures to form complete risk scenarios, supporting risk analysis and decision-making. The system metadata is compatible with standard modeling languages, making it easy to integrate into larger systems engineering environments and enhancing the systematic capabilities of risk identification, analysis, and management.",
    "design": "library package 'SemanticRiskMetadata' {\n\tprivate import ScalarValues::Real;\n\tprivate import RiskMetadata::Level;\n\tabstract occurrence def Situation;\n\tabstract occurrence situations : Situation[*] nonunique;\n\tabstract occurrence def Cause {\n\t\tattribute probability : Real;\n\t}\n\tabstract occurrence causes : Cause[*] nonunique :> situations;\n\tabstract occurrence def Failure {\n\t\tattribute severity : Level;\n\t}\n\tabstract occurrence failures : Failure[*] nonunique :> situations;\n\tabstract connection def Causation :> Occurrences::HappensBefore {\n\t\tend cause : Situation[*];\n\t\tend effect : Situation[*];\n\t}\n\tabstract connection causations : Causation[*] nonunique;\n\titem def Scenario {\n\t\toccurrence :>> situations;\n\t\toccurrence :>> causes :> situations;\n\t\toccurrence :>> failures :> situations;\n\t}\n\titem scenarios : Scenario[*] nonunique;\n\tprivate import Metaobjects::SemanticMetadata;\n\tmetadata def situation :> SemanticMetadata {\n\t\t:>> baseType = situations meta SysML::Usage;\n\t}\n\tmetadata def cause :> SemanticMetadata {\n\t\t:>> baseType = causes meta SysML::Usage;\n\t}\n\tmetadata def failure :> SemanticMetadata {\n\t\t:>> baseType = failures meta SysML::Usage;\n\t}\n\tmetadata def causation :> SemanticMetadata {\n\t\t:>> baseType = causations meta SysML::Usage;\n\t}\n\tmetadata def scenario :> SemanticMetadata {\n\t\t:>> baseType = scenarios meta SysML::Usage;\n\t}\n}",
    "domain": "Fault diagnosis",
    "grammar": "Language Extension",
    "diagram": "dataset/sysml/samples/90/design.png"
  },
  {
    "nl": "This system is designed to identify and analyze potential risks and failure scenarios that may occur in the equipment. The equipment includes key components such as batteries, and it is required to continuously monitor the battery level during operation. When the probability of battery failure increases due to aging or other factors, the system must be able to detect such situations and identify the risk that “battery aging” may lead to “low battery level.” When the battery level falls below the set minimum threshold, the system should determine that the equipment is in a “low battery” state and further analyze the situation. If this state persists for a prolonged period without recovery, the device may automatically shut down, resulting in the failure consequence of “device shutdown.” For high-level failures that may cause the interruption of critical device functions, the system should assign an appropriate severity level in order to alert users and maintenance personnel, allowing timely intervention to mitigate potential risks and thus ensure the reliable operation of the equipment and the normal usage needs of the user.",
    "design": "package 'DeviceRiskandFailureAnalysis' {\n\tprivate import ScalarValues::Real;\n\tprivate import RiskMetadata::LevelEnum;\n\tprivate import RiskMetadata::Level;\n\tabstract occurrence def Situation;\n\tabstract occurrence situations : Situation[*] nonunique;\n\tabstract occurrence def Cause {\n\t\tattribute probability : Real;\n\t}\n\tabstract occurrence causes : Cause[*] nonunique :> situations;\n\tabstract occurrence def Failure {\n\t\tattribute severity : Level;\n\t}\n\tabstract occurrence failures : Failure[*] nonunique :> situations;\n\tabstract connection def Causation :> Occurrences::HappensBefore {\n\t\tend cause : Situation[*];\n\t\tend effect : Situation[*];\n\t}\n\tabstract connection causations : Causation[*] nonunique;\n\titem def Scenario {\n\t\toccurrence :>> situations;\n\t\toccurrence :>> causes :> situations;\n\t\toccurrence :>> failures :> situations;\n\t}\n\titem scenarios : Scenario[*] nonunique;\n\tprivate import Metaobjects::SemanticMetadata;\n\tmetadata def situation :> SemanticMetadata {\n\t\t:>> baseType = situations meta SysML::Usage;\n\t}\n\tmetadata def cause :> SemanticMetadata {\n\t\t:>> baseType = causes meta SysML::Usage;\n\t}\n\tmetadata def failure :> SemanticMetadata {\n\t\t:>> baseType = failures meta SysML::Usage;\n\t}\n\tmetadata def causation :> SemanticMetadata {\n\t\t:>> baseType = causations meta SysML::Usage;\n\t}\n\tmetadata def scenario :> SemanticMetadata {\n\t\t:>> baseType = scenarios meta SysML::Usage;\n\t}\n\tpart def Device {\n\t\tpart battery {\n\t\t\tattribute power : Real;\n\t\t}\n\t}\n\t#scenario def DeviceFailure {\n\t\tref device : Device;\n\t\tattribute minPower : Real;\n\t\t#cause 'battery old' {\n\t\t\t:>> probability = 0.01;\t\t\t\n\t\t}\t\n\t\t#causation first 'battery old' then 'power low';\n\t\t#situation 'power low' {\n\t\t\tconstraint { device.battery.power < minPower }\t\t\t\n\t\t}\n\t\t#causation first 'power low' then 'device shutoff';\n\t\t#failure 'device shutoff' {\n\t\t\t:>> severity = LevelEnum::high;\n\t\t}\n\t}\n}",
    "domain": "Fault diagnosis",
    "grammar": "Language Extension",
    "diagram": "dataset/sysml/samples/91/design.png"
  },
  {
    "nl": "The system must possess a clear capability for structural decomposition, namely, the ability to explicitly present a top-down hierarchical structure, dividing the system into multiple subsystems and components, and ensuring that the functions and capabilities of each level are fully covered. The interfaces between system components should be well defined, so that each component can be independently understood and analyzed while also collaborating effectively within the overall system. Furthermore, system engineers and parties involved in Independent Verification and Validation (IV&V) must be able to use this structural view to comprehend and verify the system’s integrity and modular design, thereby ensuring that the system's various functional and performance requirements are met.",
    "design": "package 'SystemArchitectureViewpoints' {\t\n\tpart def 'Systems Engineer';\n\tpart def 'IV&V';\n\tconcern 'system breakdown' {\n\t\tdoc /* \n\t\t * To ensure that a system covers all its required capabilities,\n\t\t * it is necessary to understand how it is broken down into\n\t\t * subsystems and components that provide those capabilities.\n\t\t */\n\t\tstakeholder se : 'Systems Engineer';\n\t\tstakeholder ivv : 'IV&V';\n\t}\n\tconcern 'modularity' {\n\t\tdoc /*\n\t\t * There should be well defined interfaces between the parts of\n\t\t * a system that allow each part to be understood individually,\n\t\t * as well as being part of the whole system.\n\t\t */\t \n\t\t stakeholder se : 'Systems Engineer';\n\t}\n\tviewpoint 'system structure perspective' {\t\t\n\t\tframe 'system breakdown';\n\t\tframe 'modularity';\t\n\t\trequire constraint {\n\t\t\tdoc /*\n\t\t\t * A system structure view shall show the hierarchical \n\t\t\t * part decomposition of a system, starting with a \n\t\t\t * specified root part.\n\t\t\t */\n\t\t}\n\t}\n}",
    "domain": "Systems Engineering",
    "grammar": "View",
    "diagram": "dataset/sysml/samples/92/design.png"
  },
  {
    "nl": "The system requires the functional and safety aspects to be decomposed and modularly managed within the automotive system architecture design. The overall system must be composed of several subsystems and components, with each component assuming specific functional and/or safety responsibilities. The decomposition should be clearly defined top-down, starting from a designated root component. Each part of the system must have clearly defined interfaces, ensuring both independent comprehensibility and overall integration.\n\nSafety-related components within the system must be structurally marked with their safety attributes. Among these, certain safety components are mandatory—such as seat belts and bumpers, which must be explicitly equipped—while others are optional, for example, driver airbags and anti-lock braking systems (ABS).\n\nThe system must also be able to distinctly display: \n- the hierarchical structure of all components, \n- all safety-related components along with their mandatory or optional status, and \n- a complete list of all non-safety components.\n\nThese views should be supported in both tree and tabular formats, so as to facilitate understanding, review, and traceability of the system structure and safety features by various stakeholders (such as system engineers and independent verification & validation personnel).",
    "design": "package 'AutomotiveSystemArchitectureSafetyViews' {\n\tprivate import Views::*;\n\tprivate import ScalarValues::Boolean;\n\tpart def 'Systems Engineer';\n\tpart def 'IV&V';\n\tconcern 'system breakdown' {\n\t\tdoc /* \n\t\t * To ensure that a system covers all its required capabilities,\n\t\t * it is necessary to understand how it is broken down into\n\t\t * subsystems and components that provide those capabilities.\n\t\t */\n\t\tstakeholder se : 'Systems Engineer';\n\t\tstakeholder ivv : 'IV&V';\n\t}\n\tconcern 'modularity' {\n\t\tdoc /*\n\t\t * There should be well defined interfaces between the parts of\n\t\t * a system that allow each part to be understood individually,\n\t\t * as well as being part of the whole system.\n\t\t */\t \n\t\t stakeholder se : 'Systems Engineer';\n\t}\n\tviewpoint 'system structure perspective' {\t\t\n\t\tframe 'system breakdown';\n\t\tframe 'modularity';\t\n\t\trequire constraint {\n\t\t\tdoc /*\n\t\t\t * A system structure view shall show the hierarchical \n\t\t\t * part decomposition of a system, starting with a \n\t\t\t * specified root part.\n\t\t\t */\n\t\t}\n\t}\n\tmetadata def Safety {\n\t\tattribute isMandatory : Boolean;\n\t}\n\tpart vehicle {\n\t\tpart interior {\n\t\t\tpart alarm;\n\t\t\tpart seatBelt[2] {@Safety{isMandatory = true;}}\n\t\t\tpart frontSeat[2];\n\t\t\tpart driverAirBag {@Safety{isMandatory = false;}}\n\t\t}\n\t\tpart bodyAssy {\n\t\t\tpart body;\n\t\t\tpart bumper {@Safety{isMandatory = true;}}\n\t\t\tpart keylessEntry;\n\t\t}\n\t\tpart wheelAssy {\n\t\t\tpart wheel[2];\n\t\t\tpart antilockBrakes[2] {@Safety{isMandatory = false;}}\n\t\t}\n\t}\n\tpackage 'Safety Features' {\n\t\t/* Parts that contribute to safety. */\t\t\n\t\tprivate import vehicle::**[@Safety];\n\t}\n\tpackage 'Mandatory Safety Features' {\n\t\t/* Parts that contribute to safety AND are mandatory. */\n\t\tprivate import vehicle::**[@Safety and Safety::isMandatory];\n\t}\n\tview def 'Part Structure View' {\n\t\tsatisfy 'system structure perspective';\t\t\n\t\tfilter @SysML::PartUsage;\n\t}\n\tview 'vehicle structure view' : 'Part Structure View' {\n\t\texpose vehicle::**;\n\t\trender asTreeDiagram;\n\t}\n\trendering asTextualNotationTable :> asElementTable {\n\t\tview :>> columnView[1] {\n\t\t\trender asTextualNotation;\n\t\t}\n\t}\n\tview 'vehicle tabular views' {\n\t\tview 'safety features view' : 'Part Structure View' {\n\t\t\texpose vehicle::**[@Safety];\n\t\t\trender asTextualNotationTable;\n\t\t}\n\t\tview 'non-safety features view' : 'Part Structure View' {\n\t\t\texpose vehicle::**[not (@Safety)];\n\t\t\trender asTextualNotationTable;\n\t\t}\n\t}\n}",
    "domain": "Vehicle Traffic",
    "grammar": "View",
    "diagram": "dataset/sysml/samples/93/design.png"
  },
  {
    "nl": "This system model aims to provide standardized definitions and annotations for fundamental concepts and elements in the automotive domain. In the model, automobile is designated as a core component, with the alias “Car” defined to facilitate communication and usage in various application scenarios. The model also includes comprehensive explanatory comments to help developers and users better understand the meaning and application context of each element. Additionally, the model associates relevant physical quantities such as “扭矩 (Torque)” to ensure standardized and consistent expression of automotive characteristics. The overall design emphasizes clarity and extensibility, enabling convenient development, integration, and maintenance of subsequent automotive-related systems.",
    "design": "package 'Automotive Domain Annotations' {\n\t/* This is a comment, which is a part of the model, \n\t * annotating (by default) it's owning namespace. */\n\tcomment Comment1 /* This is a named comment. */\n\tcomment about Automobile\n\t/* This is an unnamed comment, annotating an \n\t * explicitly specified element. \n\t */\n\tpart def Automobile;\n\talias Car for Automobile {\n\t\t/*\n\t\t * This is a comment annotating its owning\n\t\t * element.\n\t\t */\n\t}\t                         \n\t// This is a note. It is in the text, but not part \n\t// of the model.\n\talias Torque for ISQ::TorqueValue;\n}",
    "domain": "Vehicle Traffic",
    "grammar": "Package",
    "diagram": "dataset/sysml/samples/94/design.png"
  },
  {
    "nl": "This system aims to establish a document management platform related to automobiles. It can manage and record information and documentation about automobiles, allowing users to enter, query, and archive various types of information using “Automobile” as the core object. The system also provides “Car” as an alias for “Automobile,” enabling different user groups to perform searches and operations flexibly according to their own habits. In addition, the system supports compatibility with standard physical quantity systems, enabling unified referencing and management of physical quantities such as torque (e.g., TorqueValue under the ISQ standard) to enhance the professionalism and accuracy of documentation. The system allows explanatory documents to be added for different objects and their aliases, ensuring that information within the platform is clearly annotated and traceable. In this way, the platform better serves the documentation management and knowledge accumulation needs of users in the automotive industry.",
    "design": "package 'AutomotiveDocumentation' {\n\tdoc /* This is documentation of the owning \n\t     * package.\n\t     */\n\tpart def Automobile {\n\t\tdoc Document1 /* This documentation of Automobile. */\n\t}\n\talias Car for Automobile {\n\t\tdoc /* This is documentation of the alias. */\n\t}\n\talias Torque for ISQ::TorqueValue;\n}",
    "domain": "Vehicle Traffic",
    "grammar": "Package",
    "diagram": "dataset/sysml/samples/95/design.png"
  },
  {
    "nl": "The system needs to be capable of managing and representing information related to automobiles, with a particular emphasis on parameters associated with vehicle torque values. The system should support the representation of Automobile objects and allow users to refer to automobiles using the alias \"Car.\" It should also facilitate the handling and importing of basic physical quantities such as torque values (TorqueValue), and support the use of \"Torque\" as an alias for torque value. Furthermore, the system should be able to flexibly import and manage various scalar physical quantity data to meet the requirements of automobile-related data processing and modeling.",
    "design": "package 'ImportPackageExercise' {\n\tpublic import ISQ::TorqueValue;\n\tprivate import ScalarValues::*;\n\tprivate part def Automobile;\n\tpublic alias Car for Automobile;\t                         \n\talias Torque for ISQ::TorqueValue;\n}",
    "domain": "Vehicle Traffic",
    "grammar": "Package",
    "diagram": "dataset/sysml/samples/96/design.png"
  },
  {
    "nl": "The system involves the definition of vehicles, including basic vehicles, engines, and the configuration of engine cylinders. In standard vehicles, each engine contains 4 to 6 cylinders. For small vehicles, the engine is required to contain only 4 cylinders; for large vehicles, the engine needs to be equipped with 6 cylinders. The system should automatically select and configure the appropriate number of engine cylinders according to the vehicle size to meet the practical application requirements of different types of vehicles.",
    "design": "package 'VehicleDefinition' {\n\tpart def Vehicle;\t\n\tpart def Engine;\t\n\tpart def Cylinder;\n\tpart vehicle : Vehicle {\n\t\tpart eng : Engine {\n\t\t\tpart cyl : Cylinder[4..6];\n\t\t}\n\t}\n\tpart smallVehicle :> vehicle {\n\t\tpart redefines eng {\n\t\t\tpart redefines cyl[4];\n\t\t}\n\t}\n\tpart bigVehicle :> vehicle {\n\t\tpart redefines eng {\n\t\t\tpart redefines cyl[6];\n\t\t}\n\t}\n}",
    "domain": "Vehicle Traffic",
    "grammar": "Part",
    "diagram": "dataset/sysml/samples/97/design.png"
  },
  {
    "nl": "The system shall be capable of managing fuel flow, ensuring that fuel can be delivered from the fuel tank to the engine and supporting fuel return. During operation, the system shall monitor and manage the temperature of the fuel and realize fuel supply and return through fuel interfaces. The fuel tank and the engine shall be connected via standardized fuel interfaces to ensure the reliability and safety of fuel flow.",
    "design": "package 'FuelFlowManagement' {\n\tattribute def Temp;\n\tpart def Fuel;\n\tport def FuelPort {\n\t\tattribute temperature : Temp;\n\t\tout item fuelSupply : Fuel;\n\t\tin item fuelReturn : Fuel;\n\t}\n\tpart def FuelTank {\n\t\tport fuelTankPort : FuelPort;\n\t}\n\tpart def Engine {\n\t\tport engineFuelPort : ~FuelPort;\n\t}\n}",
    "domain": "Aerospace",
    "grammar": "Port",
    "diagram": "dataset/sysml/samples/98/design.png"
  },
  {
    "nl": "This system model describes a vehicle structural architecture, whose core components include the vehicle as a whole, axle assemblies, front/rear axles, and wheels. The vehicle itself possesses an attribute for mass, enabling explicit definition of the total vehicle mass (such as 1750 kg and 2000 kg in the examples). Each vehicle contains front and rear axle assemblies, each comprising specific axle components and two sequentially arranged wheels. The front axle can optionally be configured with a special type that features a steering angle parameter. In certain vehicle configurations, the left and right wheels on both the front and rear axles can be distinctly identified and named, thus supporting the individual recognition and control of each wheel. The entire model is designed to provide a clear and flexible hierarchical combination of components and attribute descriptions for vehicle structural design and configuration, facilitating the needs of vehicle design, assembly, and subsequent maintenance management.",
    "design": "package 'VehicleStructuralArchitectureModel' {\n\tprivate import SI::kg;\n\tpackage Definitions {\t\n\t\tpart def Vehicle {\n\t\t\tattribute mass :> ISQ::mass {\n\t\t\tdoc\n\t\t\t/*\n\t\t\t * The 'mass' attribute property is declared here to be a \n\t\t\t * specialization (subset) of the general 'mass' quantity \n\t\t\t * from the 'ISQ' (International System of Quantities) \n\t\t\t * library model.\n\t\t\t */\n\t\t\t}\n\t\t}\n\t\tpart def AxleAssembly;\t\t\n\t\tpart def Axle { \n\t\t\tattribute mass :> ISQ::mass;\n\t\t}\t\n\t\tpart def FrontAxle :> Axle { \n\t\t\tattribute steeringAngle: ScalarValues::Real;\n\t\t}\t\n\t\tpart def Wheel;\t\n\t}\n\tpackage Usages {\n\t\tprivate import Definitions::* {\n\t\t\t/*\n\t\t\t * A \"private\" private import makes the imported names private to the\n\t\t\t * imported package.\n\t\t\t */\n\t\t}\n\t\tpart vehicle1: Vehicle {\n\t\t\t/*\n\t\t\t * 'vehicle1' is a package-owned part of type Vehicle.\n\t\t\t */\n\t\t\tattribute mass redefines Vehicle::mass = 1750 [kg] {\n\t\t\t\t/*\n\t\t\t\t * This redefines the 'mass' attribute property from 'Vehicle' to \n\t\t\t\t * give it a fixed attribute.\n\t\t\t\t */\n\t\t\t}\n\t\t\tpart frontAxleAssembly: AxleAssembly {\n\t\t\t\t/*\n\t\t\t\t * 'frontAxleAssembly' is a nested part of part 'vehicle1'.\n\t\t\t\t * It is a composite part of the containing part.\n\t\t\t\t * \n\t\t\t\t * (And similarly for 'rearAxleAssembly'.)\n\t\t\t\t */\n\t\t\t\tpart frontAxle: Axle;\n\t\t\t\tpart frontWheel: Wheel[2] ordered {\n\t\t\t\t\t/*\n\t\t\t\t\t * 'frontWheel' is a nested part of type 'Wheel' with\n\t\t\t\t\t * multiplicity \"2\". This means that this axle assembly\n\t\t\t\t\t * must have exactly two wheels. However, there is still\n\t\t\t\t\t * only one 'frontWheel' part. The part is \"ordered\",\n\t\t\t\t\t * so that the first wheel can be distinguished from the\n\t\t\t\t\t * second.\n\t\t\t\t\t */\n\t\t\t\t}\n\t\t\t}\n\t\t\tpart rearAxleAssembly: AxleAssembly {\n\t\t\t\tpart rearAxle: Axle;\n\t\t\t\tpart rearWheel: Wheel[2] ordered;\n\t\t\t}\n\t\t}\n\t\tpart vehicle1_c1: Vehicle {\n\t\t\t/*\n\t\t\t * 'vehicle1_c1' is a modified copy of 'vehicle1'. There is no\n\t\t\t * connection between this copy and the original version in the\n\t\t\t * model.\n\t\t\t */\t\t\t\n\t\t\tattribute mass redefines Vehicle::mass = 2000 [kg] {\n\t\t\t\t/*\n\t\t\t\t * The mass attribute has been modified.\n\t\t\t\t */\n\t\t\t}\n\t\t\tpart frontAxleAssembly: AxleAssembly {\n\t\t\t\tpart frontAxle: FrontAxle {\n\t\t\t\t\t/*\n\t\t\t\t\t * The part 'frontAxle' has been modified to have type 'FrontAxle'.\n\t\t\t\t\t */\n\t\t\t\t}\n\t\t\t\tpart frontWheel: Wheel[2] ordered {\n\t\t\t\t\t/*\n\t\t\t\t\t * The parts 'frontWheel_1' and 'frontWheel_2' have been added\n\t\t\t\t\t * as subsets of 'frontWheel'. These are separate parts from\n\t\t\t\t\t * 'frontWheel', but essentially provide alternate names for\n\t\t\t\t\t * each of the two wheels, as given by their defining expressions.\n\t\t\t\t\t */\n\t\t\t\t}\n\t\t\t\tpart frontWheel_1 subsets frontWheel = frontWheel#(1);\n\t\t\t\tpart frontWheel_2 subsets frontWheel = frontWheel#(2);\n\t\t\t}\n\t\t\tpart rearAxleAssembly: AxleAssembly {\n\t\t\t\t/*\n\t\t\t\t * 'rearAxleAssembly' has also been modified to add subsetting parts\n\t\t\t\t * for 'rearWheel'.\n\t\t\t\t */\t\n\t\t\t\tpart rearAxle: Axle;\n\t\t\t\tpart rearWheel: Wheel[2] ordered;\n\t\t\t\tpart rearWheel_1 subsets rearWheel = rearWheel#(1);\n\t\t\t\tpart rearWheel_2 subsets rearWheel = rearWheel#(2);\n\t\t\t}\n\t\t}\n\t}\n}",
    "domain": "Vehicle Traffic",
    "grammar": "Part",
    "diagram": "dataset/sysml/samples/99/design.png"
  }
]