[
    "package VehicleManagementSystem {\n\n    part Vehicle {\n        attribute mass: Real;\n        attribute currentStatus: VehicleStatus;\n        part engine: Engine;\n        reference driver: Personnel[0..1];\n    }\n\n    part VehicleStatus {\n        attribute gearSetting: Integer;\n        attribute acceleratorPedalPosition: Real;\n    }\n\n    part Engine {\n        attribute engineId: String;\n        attribute power: Real;\n        attribute status: EngineStatus;\n    }\n\n    part EngineStatus {\n        attribute isRunning: Boolean;\n        attribute rpm: Real;\n    }\n\n    part Personnel {\n        attribute personnelId: String;\n        attribute name: String;\n        attribute role: String;\n    }\n\n    part VehicleManagement {\n        part vehicles: Vehicle[0..*];\n        part engines: Engine[0..*];\n        part personnel: Personnel[0..*];\n    }\n}",
    "package VehicleSystem {\n\n    entity Personnel;\n    entity Engine;\n\n    entity Vehicle;\n\n    entity ManuallyOperatedVehicle specializes Vehicle {\n        part driver: Personnel;\n    }\n\n    entity PoweredVehicle specializes Vehicle {\n        part engine: Engine;\n    }\n\n    entity ManuallyOperatedPoweredVehicle specializes ManuallyOperatedVehicle, PoweredVehicle;\n\n}",
    "package VehicleStructure {\n\n    // Abstract base for all vehicle components\n    abstract part VehicleComponent {}\n\n    // Engine component\n    part Engine specializes VehicleComponent {}\n\n    // Transmission component\n    part Transmission specializes VehicleComponent {}\n\n    // Wheel component\n    part Wheel specializes VehicleComponent {}\n\n    // Vehicle structure definition\n    part Vehicle {\n        // One engine per vehicle\n        part engine: Engine [1];\n\n        // One transmission per vehicle\n        part transmission: Transmission [1];\n\n        // Four wheels per vehicle\n        part wheels: Wheel [4];\n    }\n\n}",
    "package VehicleSystem {\n\n    part Vehicle {\n        part engine: Engine;\n    }\n\n    part SmallVehicle specializes Vehicle {\n        part engine: SmallEngine;\n    }\n\n    part LargeVehicle specializes Vehicle {\n        part engine: LargeEngine;\n    }\n\n    part Engine {\n        part cylinders: Cylinder[1..*];\n    }\n\n    part SmallEngine specializes Engine {\n        part cylinders: Cylinder[4];\n    }\n\n    part LargeEngine specializes Engine {\n        part cylinders: Cylinder[6];\n    }\n\n    part Cylinder {\n    }\n\n}",
    "package TrafficSignalSystem {\n\n    part TrafficSignalSystem {\n        part trafficSignal: TrafficSignal;\n    }\n\n    part TrafficSignal {\n        attribute color: TrafficSignalColor;\n    }\n\n    enum TrafficSignalColor {\n        literal green;\n        literal yellow;\n        literal red;\n    }\n\n    part GreenTrafficSignal specializes TrafficSignal {\n        attribute color: TrafficSignalColor = TrafficSignalColor::green;\n    }\n}",
    "package InformationClassificationManagement {\n\n    enum InformationLevel {\n        Unclassified,\n        Confidential,\n        Secret\n    }\n\n    enum InformationColor {\n        Green,\n        Yellow,\n        Red\n    }\n\n    enum InformationCode {\n        uncl,\n        conf,\n        secr\n    }\n\n    enum GradeLevel {\n        A,\n        B,\n        C,\n        D,\n        F\n    }\n\n    enum GradePoint {\n        _4_0,\n        _3_0,\n        _2_0,\n        _1_0,\n        _0_0\n    }\n\n    part InformationClassificationMechanism {\n        attribute informationLevel: InformationLevel;\n        attribute informationCode: InformationCode;\n        attribute informationColor: InformationColor;\n    }\n\n    part GradeClassificationMechanism {\n        attribute gradeLevel: GradeLevel;\n        attribute gradePoint: GradePoint;\n    }\n\n    mapping InformationLevelToCodeColor {\n        Unclassified -> (uncl, Green);\n        Confidential -> (conf, Yellow);\n        Secret -> (secr, Red);\n    }\n\n    mapping GradeLevelToPoint {\n        A -> _4_0;\n        B -> _3_0;\n        C -> _2_0;\n        D -> _1_0;\n        F -> _0_0;\n    }\n\n    part System {\n        part informationClassification: InformationClassificationMechanism;\n        part gradeClassification: GradeClassificationMechanism;\n    }\n}",
    "package VehicleSystem {\n\n    part VehicleSystem {\n        part vehicles: Vehicle[0..*];\n    }\n\n    abstract part Vehicle {\n        part engine: Engine;\n    }\n\n    part SmallVehicle specializes Vehicle {\n        part engine: SmallEngine;\n    }\n\n    part LargeVehicle specializes Vehicle {\n        part engine: LargeEngine;\n    }\n\n    abstract part Engine {\n        part cylinders: Cylinder[4..6];\n    }\n\n    part SmallEngine specializes Engine {\n        part cylinders: Cylinder[4];\n    }\n\n    part LargeEngine specializes Engine {\n        part cylinders: Cylinder[6];\n    }\n\n    part Cylinder {\n        // Fundamental component of Engine\n    }\n}",
    "package VehicleModeling {\n\n    part system {\n        part vehicles: Vehicle[*];\n        part fuels: Fuel[*];\n        part personnel: Personnel[*];\n    }\n\n    part Vehicle {\n        part qualityAttributes: QualityAttribute[*];\n        part driver: Personnel;\n        part fuelTank: FuelTank;\n    }\n\n    part QualityAttribute {\n        attribute name: String;\n        attribute value: String;\n    }\n\n    part FuelTank {\n        part fuel: Fuel;\n    }\n\n    part Fuel {\n        attribute type: String;\n        attribute description: String;\n    }\n\n    part Personnel {\n        attribute name: String;\n        attribute role: String;\n    }\n}",
    "package WheelAssembly {\n\n    part WheelAssembly {\n        part wheelBearingUnit: WheelBearingUnit;\n        part tire: Tire;\n        part hub: Hub;\n        part rim: Rim;\n        part boltMountingHole: BoltMountingHole[1..*];\n        part threadedHole: ThreadedHole[1..*];\n        part boltConnection: BoltConnection[1..*];\n    }\n\n    part WheelBearingUnit {}\n\n    part Tire {\n        part bead: Bead[2];\n    }\n\n    part Bead {}\n\n    part Hub {\n        part rim: Rim[2];\n        part boltMountingHole: BoltMountingHole[1..*];\n        part threadedHole: ThreadedHole[1..*];\n    }\n\n    part Rim {}\n\n    part BoltMountingHole {}\n\n    part ThreadedHole {}\n\n    part BoltConnection {}\n\n    association TireBeadToRim {\n        end tireBead: Bead;\n        end hubRim: Rim;\n        constraint \"Each bead of the tire is pressed onto a rim of the hub to seal and fasten the tire.\";\n    }\n\n    association HubMountingHoleToThreadedHole {\n        end mountingHole: BoltMountingHole;\n        end threadedHole: ThreadedHole;\n        constraint \"Each mounting hole on the hub is connected to a threaded hole using a bolt.\";\n    }\n\n    association BoltConnectionToHoles {\n        end bolt: BoltConnection;\n        end mountingHole: BoltMountingHole;\n        end threadedHole: ThreadedHole;\n        constraint \"Bolt connects the mounting hole and the threaded hole to ensure reliable connection.\";\n    }\n\n    association HubToTireAssembly {\n        end hub: Hub;\n        end tire: Tire;\n        constraint \"The hub and tire assembly are connected via beads, rims, mounting holes, threaded holes, and bolts.\";\n    }\n}",
    "package FuelManagementSystem {\n\n    part FuelTankAssembly {\n        port fuelOut: FuelPort\n        port fuelReturnIn: FuelPort\n        port tempSensor: TemperaturePort\n    }\n\n    part Engine {\n        port fuelIn: FuelPort\n        port fuelReturnOut: FuelPort\n        port tempSensor: TemperaturePort\n    }\n\n    interface FuelPort {\n        property flowRate: Real\n    }\n\n    interface TemperaturePort {\n        property temperature: Real\n    }\n\n    part UserInterface {\n        port dataIn: DataPort\n    }\n\n    interface DataPort {\n        property fuelSupplyRate: Real\n        property fuelReturnRate: Real\n        property interfaceTemperature: Real\n    }\n\n    connector FuelSupply {\n        end source: FuelTankAssembly.fuelOut\n        end target: Engine.fuelIn\n    }\n\n    connector FuelReturn {\n        end source: Engine.fuelReturnOut\n        end target: FuelTankAssembly.fuelReturnIn\n    }\n\n    connector TempDataTransfer {\n        end source: FuelTankAssembly.tempSensor\n        end target: Engine.tempSensor\n    }\n\n    connector UserDataFeed {\n        end source: Engine.fuelIn\n        end target: UserInterface.dataIn\n    }\n\n    requirement EffectiveFuelManagement {\n        text \"The system shall achieve effective management of fuel flow, including supply, return, and temperature monitoring, to ensure safety and efficiency.\"\n    }\n\n    requirement RealTimeMonitoring {\n        text \"The system shall provide users with real-time data on fuel supply, return flow, and temperature parameters for visualized monitoring and precise control.\"\n    }\n\n    requirement EngineFuelNeeds {\n        text \"The system shall meet the engine's requirements for fuel management during operation.\"\n    }\n}",
    "model VehicleConfigurationVariants {\n\n    // Abstract definition for all components\n    part VehicleComponent {\n        attribute mass: Real;\n    }\n\n    // Tire definition\n    part Tire extends VehicleComponent {\n        // Additional tire-specific attributes can be added here\n    }\n\n    // Axle definition\n    part Axle extends VehicleComponent {\n        // Each axle has two ordered tires\n        part tires: Tire[2];\n    }\n\n    // Front Axle definition (can be specialized)\n    part FrontAxle extends Axle {\n        // Additional front axle-specific attributes can be added here\n    }\n\n    // Rear Axle definition\n    part RearAxle extends Axle {\n        // Additional rear axle-specific attributes can be added here\n    }\n\n    // Dedicated Front Axle with steering angle (variant)\n    part DedicatedFrontAxle extends FrontAxle {\n        attribute steeringAngle: Real;\n    }\n\n    // Complete Vehicle definition\n    part Vehicle extends VehicleComponent {\n        attribute mass: Real = 1750; // default mass in kg\n        part frontAxle: FrontAxle;\n        part rearAxle: RearAxle;\n    }\n\n    // Variant configuration: vehicle1_c1\n    part vehicle1_c1 extends Vehicle {\n        attribute mass: Real = 2000; // overridden mass\n        part frontAxle: DedicatedFrontAxle; // replace front axle with dedicated variant\n        // Optionally, rename and manage specific instances\n        part frontAxle as dedicatedFrontAxle1: DedicatedFrontAxle;\n        part rearAxle as rearAxle1: RearAxle;\n        part frontAxle.tires as frontTire1: Tire;\n        part frontAxle.tires as frontTire2: Tire;\n        part rearAxle.tires as rearTire1: Tire;\n        part rearAxle.tires as rearTire2: Tire;\n    }\n\n}",
    "package CouplingSystem {\n\n   part Vehicle {\n      // Vehicle does not own a coupling ball; connects via reference to Hitch's ball\n      reference hitch: Hitch;\n   }\n\n   part Trailer {\n      // Trailer connects via reference to Hitch's connector\n      reference hitch: Hitch;\n   }\n\n   part Hitch {\n      part ball: CouplingBall;\n      part connector: TrailerConnector;\n   }\n\n   part CouplingBall {\n      // Represents the ball component of the hitch\n   }\n\n   part TrailerConnector {\n      // Represents the connector interface for the trailer\n   }\n\n   part CouplingSystem {\n      part vehicle: Vehicle;\n      part trailer: Trailer;\n      part hitch: Hitch;\n\n      // Bind vehicle and trailer to the same hitch instance\n      bind vehicle.hitch == hitch;\n      bind trailer.hitch == hitch;\n   }\n}",
    "package VehiclePowerTransmissionSystem {\n\n    part VehiclePowerTransmissionSystem {\n        part engine: Engine;\n        part transmission: Transmission;\n        part clutch: Clutch;\n        part driveshaft: Driveshaft;\n        part rearAxleAssembly: RearAxleAssembly;\n        part leftRearWheel: Wheel;\n        part rightRearWheel: Wheel;\n        part roadInterfaceLeft: RoadInterface;\n        part roadInterfaceRight: RoadInterface;\n\n        connect engine.powerPort to clutch.enginePort;\n        connect clutch.transmissionPort to transmission.inputPort;\n        connect transmission.outputPort to driveshaft.inputPort;\n        connect driveshaft.outputPort to rearAxleAssembly.inputPort;\n        connect rearAxleAssembly.leftHalfShaftPort to leftRearWheel.axlePort;\n        connect rearAxleAssembly.rightHalfShaftPort to rightRearWheel.axlePort;\n        connect leftRearWheel.roadPort to roadInterfaceLeft.wheelPort;\n        connect rightRearWheel.roadPort to roadInterfaceRight.wheelPort;\n    }\n\n    part Engine {\n        port powerPort: PowerPort;\n        port fuelCommandPort: CommandPort;\n    }\n\n    part Transmission {\n        port inputPort: PowerPort;\n        port outputPort: PowerPort;\n    }\n\n    part Clutch {\n        port enginePort: PowerPort;\n        port transmissionPort: PowerPort;\n    }\n\n    part Driveshaft {\n        port inputPort: PowerPort;\n        port outputPort: PowerPort;\n    }\n\n    part RearAxleAssembly {\n        part differential: Differential;\n        part leftHalfShaft: HalfShaft;\n        part rightHalfShaft: HalfShaft;\n\n        port inputPort: PowerPort;\n        port leftHalfShaftPort: PowerPort;\n        port rightHalfShaftPort: PowerPort;\n\n        connect inputPort to differential.inputPort;\n        connect differential.leftOutputPort to leftHalfShaft.inputPort;\n        connect differential.rightOutputPort to rightHalfShaft.inputPort;\n        connect leftHalfShaft.outputPort to leftHalfShaftPort;\n        connect rightHalfShaft.outputPort to rightHalfShaftPort;\n    }\n\n    part Differential {\n        port inputPort: PowerPort;\n        port leftOutputPort: PowerPort;\n        port rightOutputPort: PowerPort;\n    }\n\n    part HalfShaft {\n        port inputPort: PowerPort;\n        port outputPort: PowerPort;\n    }\n\n    part Wheel {\n        port axlePort: PowerPort;\n        port roadPort: PowerPort;\n    }\n\n    part RoadInterface {\n        port wheelPort: PowerPort;\n    }\n\n    interface PowerPort {}\n    interface CommandPort {}\n\n}",
    "system MultiArchitectureSystem {\n\n    // Interfaces\n    interface pe;\n    interface pf;\n\n    // Signal Ports\n    port pb : pe;\n    port pd : pf;\n    port sig1;\n    port sig2;\n\n    // Components\n    part c1 {\n        port pb : pe;\n        port sig1;\n    }\n\n    part c2 {\n        port sig2;\n    }\n\n    part c3 {\n        port pd : pf;\n        port sig1;\n    }\n\n    part c4 {\n        port sig2;\n    }\n\n    // First Decomposition: Subsystems b11 and b12\n    part b11 {\n        part c1_ref : c1;\n        part c2_ref : c2;\n\n        // Signal connection between c1 and c2\n        connect c1_ref.sig1 -> c2_ref.sig2;\n\n        // Interface binding\n        bind c1_ref.pb : pe;\n    }\n\n    part b12 {\n        part c3_ref : c3;\n        part c4_ref : c4;\n\n        // Interface binding\n        bind c3_ref.pd : pf;\n    }\n\n    // Communication between b11 and b12 via interfaces pe and pf\n    connect b11.c1_ref.pb <-> b12.c3_ref.pd;\n\n    // Second Decomposition: Modules b21 and b22, reusing c-level components\n    part b21 {\n        part c1_ref : c1;\n        part c2_ref : c2;\n\n        // Reorganized signal connection\n        connect c1_ref.sig1 -> c2_ref.sig2;\n    }\n\n    part b22 {\n        part c3_ref : c3;\n        part c4_ref : c4;\n\n        // Reorganized signal connection\n        connect c3_ref.sig1 -> c4_ref.sig2;\n    }\n\n    // Design Objective: Standardized interface binding and signal connection\n    // (Captured by interface, port, and connect/bind constructs above)\n}",
    "system PowertrainSystem {\n    \n    part user: User;\n    part engine: Engine;\n    part transmission: Transmission;\n    part driveshaft: Driveshaft;\n    part leftWheel: Wheel;\n    part rightWheel: Wheel;\n    part startStopController: StartStopController;\n\n    interface FuelCommand;\n    interface StartCommand;\n    interface StopCommand;\n    interface EngineTorque;\n    interface TransmissionTorque;\n    interface DriveshaftTorque;\n    interface WheelTorque;\n\n    user -> engine: FuelCommand;\n    user -> startStopController: StartCommand;\n    user -> startStopController: StopCommand;\n    startStopController -> engine: StartCommand;\n    startStopController -> engine: StopCommand;\n    engine -> transmission: EngineTorque;\n    transmission -> driveshaft: TransmissionTorque;\n    driveshaft -> leftWheel: DriveshaftTorque;\n    driveshaft -> rightWheel: DriveshaftTorque;\n    leftWheel -> : WheelTorque;\n    rightWheel -> : WheelTorque;\n\n    constraint EngineStart {\n        when (startStopController.receives(StartCommand)) {\n            engine.state = started;\n        }\n    }\n\n    constraint EngineStop {\n        when (startStopController.receives(StopCommand)) {\n            engine.state = stopped;\n            transmission.state = idle;\n            driveshaft.state = idle;\n            leftWheel.state = idle;\n            rightWheel.state = idle;\n        }\n    }\n\n    constraint TorqueGeneration {\n        when (engine.state == started && user.sends(FuelCommand)) {\n            engine.generates(EngineTorque according to FuelCommand);\n        }\n    }\n\n    constraint TorqueTransmission {\n        when (engine.state == started) {\n            transmission.amplifies(engine.EngineTorque);\n            driveshaft.transmits(transmission.TransmissionTorque);\n            leftWheel.receives(driveshaft.DriveshaftTorque);\n            rightWheel.receives(driveshaft.DriveshaftTorque);\n        }\n    }\n\n    constraint SafeShutdown {\n        when (engine.state == stopped) {\n            engine.EngineTorque = 0;\n            transmission.TransmissionTorque = 0;\n            driveshaft.DriveshaftTorque = 0;\n            leftWheel.WheelTorque = 0;\n            rightWheel.WheelTorque = 0;\n        }\n    }\n}\n\nblock User {\n    operation sendFuelCommand();\n    operation sendStartCommand();\n    operation sendStopCommand();\n}\n\nblock Engine {\n    state started;\n    state stopped;\n    operation generates(EngineTorque);\n}\n\nblock StartStopController {\n    operation receives(StartCommand);\n    operation receives(StopCommand);\n}\n\nblock Transmission {\n    state idle;\n    operation amplifies(EngineTorque);\n}\n\nblock Driveshaft {\n    state idle;\n    operation transmits(TransmissionTorque);\n}\n\nblock Wheel {\n    state idle;\n    operation receives(DriveshaftTorque);\n}",
    "system PowertrainControlSystem {\n\n    part engine : Engine;\n    part torqueGenerator : TorqueGenerator;\n    part torqueAmplifier : TorqueAmplifier;\n    part torqueTransmitter : TorqueTransmitter;\n    part torqueDistributor : TorqueDistributor;\n    part driveWheels : DriveWheels;\n    part controlLogic : ControlLogic;\n\n    interface FuelControlCommand;\n    interface StallSignal;\n    interface EngineStartCommand;\n    interface EngineShutdownCommand;\n    interface WheelOutputTorque;\n\n    input fuelControl : FuelControlCommand;\n    input stallSignal : StallSignal;\n    input engineStart : EngineStartCommand;\n    input engineShutdown : EngineShutdownCommand;\n    output wheelTorque : WheelOutputTorque;\n\n    connection fuelControl to controlLogic.fuelControl;\n    connection stallSignal to controlLogic.stallSignal;\n    connection engineStart to controlLogic.engineStart;\n    connection engineShutdown to controlLogic.engineShutdown;\n\n    connection controlLogic.engineStartSignal to engine.start;\n    connection controlLogic.engineShutdownSignal to engine.shutdown;\n\n    connection engine.torqueOutput to torqueGenerator.input;\n    connection torqueGenerator.torqueOutput to torqueAmplifier.input;\n    connection torqueAmplifier.torqueOutput to torqueTransmitter.input;\n    connection torqueTransmitter.torqueOutput to torqueDistributor.input;\n    connection torqueDistributor.torqueOutput to driveWheels.input;\n    connection driveWheels.outputTorque to wheelTorque;\n\n    constraint SequentialStart {\n        when fuelControl received {\n            controlLogic issues engineStartSignal;\n            engine starts;\n            torqueGenerator generates torque;\n        }\n    }\n\n    constraint PowerTransmissionSequence {\n        torqueGenerator.torqueOutput flows to torqueAmplifier;\n        torqueAmplifier.torqueOutput flows to torqueTransmitter;\n        torqueTransmitter.torqueOutput flows to torqueDistributor;\n        torqueDistributor.torqueOutput flows to driveWheels;\n    }\n\n    constraint StallHandling {\n        when stallSignal detected {\n            controlLogic halts operational processes as required;\n        }\n    }\n\n    constraint EngineControl {\n        controlLogic supports engine start and shutdown via commands;\n    }\n\n    constraint PowerDelivery {\n        from fuelControl to wheelTorque, power is delivered efficiently and coordinated;\n    }\n\n    constraint UserExperience {\n        system provides reliable power response and handling;\n    }\n}\n\nblock Engine {\n    input start;\n    input shutdown;\n    output torqueOutput;\n}\n\nblock TorqueGenerator {\n    input input;\n    output torqueOutput;\n}\n\nblock TorqueAmplifier {\n    input input;\n    output torqueOutput;\n}\n\nblock TorqueTransmitter {\n    input input;\n    output torqueOutput;\n}\n\nblock TorqueDistributor {\n    input input;\n    output torqueOutput;\n}\n\nblock DriveWheels {\n    input input;\n    output outputTorque;\n}\n\nblock ControlLogic {\n    input fuelControl;\n    input stallSignal;\n    input engineStart;\n    input engineShutdown;\n    output engineStartSignal;\n    output engineShutdownSignal;\n}",
    "system VehiclePowertrainManagementSystem {\n\n    part driver : Driver;\n    part engine : Engine;\n    part transmission : Transmission;\n    part wheels : Wheel[4];\n\n    interface FuelInputCommand;\n    interface EngineStartSignal;\n    interface EngineShutdownSignal;\n    interface EngineOutputTorque;\n    interface TransmissionOutputTorque;\n    interface WheelTorque;\n\n    driver.provides FuelInputCommand;\n    driver.provides EngineStartSignal;\n    driver.provides EngineShutdownSignal;\n\n    engine.requires FuelInputCommand;\n    engine.requires EngineStartSignal;\n    engine.requires EngineShutdownSignal;\n    engine.provides EngineOutputTorque;\n\n    transmission.requires EngineOutputTorque;\n    transmission.provides TransmissionOutputTorque;\n\n    wheels.requires WheelTorque;\n\n    flow fuelCommand : FuelInputCommand from driver to engine;\n    flow startSignal : EngineStartSignal from driver to engine;\n    flow shutdownSignal : EngineShutdownSignal from driver to engine;\n    flow engineTorque : EngineOutputTorque from engine to transmission;\n    flow transmissionTorque : TransmissionOutputTorque from transmission to wheels;\n\n    behavior PowertrainManagementProcess {\n        state Idle;\n        state EngineActive;\n        state PowerOutputTerminated;\n\n        transition Idle -> EngineActive when EngineStartSignal;\n        transition EngineActive -> PowerOutputTerminated when EngineShutdownSignal;\n        transition PowerOutputTerminated -> Idle when not EngineStartSignal and not EngineShutdownSignal;\n\n        action in EngineActive {\n            engine.generateTorque(fuelCommand);\n            transmission.amplifyAndTransmit(engineTorque);\n            wheels.distributeTorque(transmissionTorque);\n        }\n\n        action in PowerOutputTerminated {\n            engine.terminateOutput();\n            transmission.terminateOutput();\n            wheels.terminateTorque();\n        }\n    }\n\n    requirement IntegratedManagement {\n        text \"The system shall achieve integrated management of the vehicle powertrain system according to the driver's fuel input command.\";\n    }\n\n    requirement EngineStartProcess {\n        text \"When the engine start signal is activated, the system shall generate the corresponding engine output torque based on the fuel command, amplify and transmit the torque through the transmission, and distribute the torque to each wheel.\";\n    }\n\n    requirement EngineShutdownProcess {\n        text \"When the engine shutdown signal is triggered, the relevant power output process shall be terminated.\";\n    }\n\n    requirement AutomaticControl {\n        text \"The system shall ensure accurate and efficient automatic control in power demand response, torque transmission, and power distribution.\";\n    }\n\n    requirement EnhancedDrivingExperience {\n        text \"The system shall enhance the driving experience and improve energy efficiency.\";\n    }\n}",
    "package PowerConnectionSystem {\n\n    part Vehicle {\n        part frame: StructuralFrame;\n        part hitchBall: HitchBall;\n    }\n\n    part Trailer {\n        part frame: StructuralFrame;\n        part coupler: TrailerCoupler;\n    }\n\n    part PowerConnectionMechanism {\n        part hitchingMechanism: HitchingMechanism;\n    }\n\n    part StructuralFrame {}\n\n    part HitchBall {}\n\n    part TrailerCoupler {}\n\n    part HitchingMechanism {\n        port vehicleHitch: HitchBall;\n        port trailerCoupler: TrailerCoupler;\n        port connectionState: ConnectionState;\n    }\n\n    enum ConnectionState {\n        literal Connected;\n        literal Disconnected;\n    }\n\n    part User {}\n\n    part PowerConnectionSystem {\n        part vehicle: Vehicle;\n        part trailer: Trailer;\n        part powerConnectionMechanism: PowerConnectionMechanism;\n        part user: User;\n    }\n\n    requirement SafeConnection {\n        text \"The system shall enable users to safely connect the trailer to the vehicle via the hitching mechanism.\";\n    }\n\n    requirement ReliableConnection {\n        text \"The system shall enable users to reliably connect and disconnect the trailer and vehicle.\";\n    }\n\n    requirement FlexibleCombination {\n        text \"The system shall allow flexible combination and separation of vehicle and trailer.\";\n    }\n\n    requirement PowerCouplingFunction {\n        text \"The system shall provide power coupling functions between vehicle and trailer in various scenarios.\";\n    }\n\n}",
    "package VehicleTrailerConnectionSystem {\n\n    part VehicleTrailerConnectionSystem {\n        part vehicle: Vehicle;\n        part trailer: Trailer;\n    }\n\n    part Vehicle {\n        part chassis: Chassis;\n        part towBall: TowBall;\n    }\n\n    part Chassis {\n    }\n\n    part TowBall {\n    }\n\n    part Trailer {\n        part trailerFrame: TrailerFrame;\n        part coupler: Coupler;\n    }\n\n    part TrailerFrame {\n    }\n\n    part Coupler {\n    }\n\n    association VehicleHasTowBall {\n        end vehicle: Vehicle;\n        end towBall: TowBall;\n    }\n\n    association VehicleHasChassis {\n        end vehicle: Vehicle;\n        end chassis: Chassis;\n    }\n\n    association TrailerHasCoupler {\n        end trailer: Trailer;\n        end coupler: Coupler;\n    }\n\n    association TrailerHasFrame {\n        end trailer: Trailer;\n        end trailerFrame: TrailerFrame;\n    }\n\n    association TowBallOnChassis {\n        end towBall: TowBall;\n        end chassis: Chassis;\n    }\n\n    association CouplerOnTrailerFrame {\n        end coupler: Coupler;\n        end trailerFrame: TrailerFrame;\n    }\n\n    association Connection {\n        end towBall: TowBall;\n        end coupler: Coupler;\n    }\n\n    stateMachine ConnectionStatus {\n        state Disconnected;\n        state Connected;\n        transition connect: Disconnected -> Connected;\n        transition disconnect: Connected -> Disconnected;\n    }\n\n    requirement SafeReliableConnection {\n        text \"The system shall ensure that the trailer can be safely and reliably coupled to the vehicle when needed, and can be smoothly detached when not required.\";\n    }\n\n    requirement UserConvenience {\n        text \"Users shall be able to conveniently connect or disconnect the trailer via the system.\";\n    }\n}",
    "package DynamicConnectionReferenceModel {\n\n    part Vehicle {\n        part chassis: Chassis;\n        part towBall: TowBallDevice;\n    }\n\n    part Trailer {\n        part trailerChassis: TrailerChassis;\n        part coupler: CouplerMechanism;\n    }\n\n    part Chassis {\n    }\n\n    part TowBallDevice {\n    }\n\n    part TrailerChassis {\n    }\n\n    part CouplerMechanism {\n        attribute engaged: Boolean;\n        operation engage(towBall: TowBallDevice);\n        operation disengage();\n    }\n\n    association VehicleTrailerConnection {\n        end vehicle: Vehicle;\n        end trailer: Trailer;\n        constraint ConnectedWhenEngaged {\n            trailer.coupler.engaged == true implies\n                trailer.coupler is engaged with vehicle.towBall;\n        }\n    }\n\n    usecase HitchTrailer {\n        actor User;\n        input vehicle: Vehicle;\n        input trailer: Trailer;\n        action {\n            trailer.coupler.engage(vehicle.towBall);\n        }\n        postcondition {\n            trailer.coupler.engaged == true;\n        }\n    }\n\n    usecase UnhitchTrailer {\n        actor User;\n        input vehicle: Vehicle;\n        input trailer: Trailer;\n        action {\n            trailer.coupler.disengage();\n        }\n        postcondition {\n            trailer.coupler.engaged == false;\n        }\n    }\n\n    requirement SecureConnection {\n        text \"When connected, the trailer’s coupler shall securely latch onto the vehicle’s tow ball.\";\n        verify {\n            trailer.coupler.engaged == true implies\n                trailer.coupler is latched to vehicle.towBall;\n        }\n    }\n\n    requirement SmoothDisconnection {\n        text \"Disconnection shall allow the vehicle and trailer to separate smoothly for safe and convenient detachment.\";\n        verify {\n            trailer.coupler.engaged == false implies\n                vehicle and trailer are not physically connected;\n        }\n    }\n\n}",
    "package FuelSystem {\n\n    part FuelSystem {\n        part fuelTank: FuelTankAssembly;\n        part engine: Engine;\n        part supplyLine: FuelSupplyLine;\n        part returnLine: FuelReturnLine;\n        part monitor: FuelParameterMonitor;\n\n        connect fuelTank.supplyPort to supplyLine.inlet;\n        connect supplyLine.outlet to engine.supplyPort;\n        connect engine.returnPort to returnLine.inlet;\n        connect returnLine.outlet to fuelTank.returnPort;\n\n        connect monitor.sensorPort to supplyLine.monitorPort;\n        connect monitor.sensorPort to returnLine.monitorPort;\n    }\n\n    part FuelTankAssembly {\n        port supplyPort: FuelPort;\n        port returnPort: FuelPort;\n    }\n\n    part Engine {\n        port supplyPort: FuelPort;\n        port returnPort: FuelPort;\n    }\n\n    part FuelSupplyLine {\n        port inlet: FuelPort;\n        port outlet: FuelPort;\n        port monitorPort: MonitorPort;\n    }\n\n    part FuelReturnLine {\n        port inlet: FuelPort;\n        port outlet: FuelPort;\n        port monitorPort: MonitorPort;\n    }\n\n    part FuelParameterMonitor {\n        port sensorPort: MonitorPort;\n        attribute temperature: Real;\n    }\n\n    interface FuelPort {\n        attribute flowRate: Real;\n        attribute pressure: Real;\n    }\n\n    interface MonitorPort {\n        attribute temperature: Real;\n    }\n}",
    "package FuelDeliverySystem {\n\n    part StorageTank {\n        attribute maxCapacity: Real;\n        attribute currentLevel: Real;\n        out fuelOut: Fuel;\n    }\n\n    part FuelPump {\n        in fuelIn: Fuel;\n        out fuelOut: Fuel;\n        attribute flowRate: Real;\n        attribute isControllable: Boolean;\n    }\n\n    part VehicleFuelTank {\n        in fuelIn: Fuel;\n        attribute maxCapacity: Real;\n        attribute currentLevel: Real;\n        attribute isLevelMonitored: Boolean;\n    }\n\n    part Vehicle {\n        part fuelTank: VehicleFuelTank;\n    }\n\n    part FuelDeliverySystem {\n        part storageTank: StorageTank;\n        part fuelPump: FuelPump;\n        part vehicle: Vehicle;\n\n        connector storageToPump {\n            connect storageTank.fuelOut to fuelPump.fuelIn;\n        }\n\n        connector pumpToVehicle {\n            connect fuelPump.fuelOut to vehicle.fuelTank.fuelIn;\n        }\n    }\n\n    type Fuel {\n        attribute quantity: Real;\n    }\n}",
    "package AutomobileAssemblyProcess {\n\n    part VehicleAssembly {\n        attribute hasGearbox: Boolean = false;\n        attribute hasEngine: Boolean = false;\n    }\n\n    part Gearbox {\n        attribute isFunctional: Boolean = true;\n    }\n\n    part Engine {\n        attribute isFunctional: Boolean = true;\n    }\n\n    part FullyAssembledVehicle {\n        part gearbox: Gearbox;\n        part engine: Engine;\n        attribute isComplete: Boolean = true;\n    }\n\n    action InstallGearbox {\n        input vehicle: VehicleAssembly;\n        input gearbox: Gearbox;\n        output vehicleWithGearbox: VehicleAssembly;\n\n        constraint {\n            vehicle.hasGearbox == false;\n            vehicleWithGearbox.hasGearbox == true;\n            vehicleWithGearbox.hasEngine == false;\n        }\n    }\n\n    action InstallEngine {\n        input vehicleWithGearbox: VehicleAssembly;\n        input engine: Engine;\n        output fullyAssembledVehicle: FullyAssembledVehicle;\n\n        constraint {\n            vehicleWithGearbox.hasGearbox == true;\n            vehicleWithGearbox.hasEngine == false;\n            fullyAssembledVehicle.gearbox.isFunctional == true;\n            fullyAssembledVehicle.engine.isFunctional == true;\n            fullyAssembledVehicle.isComplete == true;\n        }\n    }\n\n    process FinalAssemblySequence {\n        step1: InstallGearbox;\n        step2: InstallEngine;\n\n        constraint {\n            step2.input.vehicleWithGearbox == step1.output.vehicleWithGearbox;\n        }\n    }\n}",
    "package VehicleA_System {\n\n    part VehicleA : Vehicle;\n\n    part Controller : VehicleController;\n\n    stateMachine VehicleA_OperationStateMachine {\n        state Off;\n        state Starting;\n        state Running;\n        state HealthManagement;\n        state Maintenance;\n        state Degraded;\n        state Normal;\n\n        transition Off_to_Starting {\n            source Off;\n            target Starting;\n            trigger (brakePedalPressed and startSignalReceived);\n        }\n\n        transition Starting_to_Running {\n            source Starting;\n            target Running;\n            trigger vehicleOnSignalReceived;\n        }\n\n        transition Running_to_HealthManagement {\n            source Running;\n            target HealthManagement;\n            effect {\n                performSelfChecks();\n                supplyPower();\n            }\n        }\n\n        transition Running_to_Degraded {\n            source Running;\n            target Degraded;\n            guard (vehicleTemperature > safetyThreshold);\n            effect {\n                sendOverTemperatureSignal();\n            }\n        }\n\n        transition Degraded_to_Normal {\n            source Degraded;\n            target Normal;\n            trigger restoreToNormalSignalReceived;\n        }\n\n        transition Running_to_Off {\n            source Running;\n            target Off;\n            effect {\n                applyParkingBrake();\n            }\n        }\n\n        transition Any_to_Maintenance {\n            source [Off, Starting, Running, HealthManagement, Degraded, Normal];\n            target Maintenance;\n            trigger maintenanceRequestReceived;\n        }\n\n        transition Maintenance_to_Normal {\n            source Maintenance;\n            target Normal;\n            trigger restoreToNormalSignalReceived;\n        }\n    }\n\n    part VehicleA {\n        stateMachine ref VehicleA_OperationStateMachine;\n        property brakePedalPressed : Boolean;\n        property startSignalReceived : Boolean;\n        property vehicleOnSignalReceived : Boolean;\n        property vehicleTemperature : Real;\n        property safetyThreshold : Real;\n        property overTemperatureSignal : Boolean;\n        property restoreToNormalSignalReceived : Boolean;\n        property maintenanceRequestReceived : Boolean;\n\n        operation performSelfChecks();\n        operation supplyPower();\n        operation applyParkingBrake();\n        operation sendOverTemperatureSignal();\n    }\n\n    part VehicleController {\n        property startUpSignal : Boolean;\n        property shutDownSignal : Boolean;\n        property mainControlState : MainControlStateKind;\n\n        enum MainControlStateKind {\n            Off;\n            Starting;\n            Running;\n            Maintenance;\n            Degraded;\n            Normal;\n        }\n\n        operation switchMainControlState(newState : MainControlStateKind);\n    }\n\n    interface HealthMonitoring {\n        property vehicleTemperature : Real;\n        property safetyThreshold : Real;\n        operation detectTemperature();\n        operation outputTemperature();\n    }\n\n    part VehicleA implements HealthMonitoring;\n\n}",
    "system AutomatedVehicleModelingSystem {\n    part vehicle : Vehicle;\n    part controller : VehicleController;\n    attribute fuel : FuelType;\n    attribute maintenanceInterval : Duration;\n    attribute temperatureThreshold : Temperature;\n}\n\nblock Vehicle {\n    attribute operationState : OperationState;\n    attribute healthStatus : HealthStatus;\n    attribute temperature : Temperature;\n    attribute lastMaintenance : DateTime;\n    attribute maintenanceDue : Boolean;\n    input brakePedalPressed : Boolean;\n    input startSignal : Boolean;\n    output warningSignal : Boolean;\n    output statusSignal : StatusSignal;\n    output controlSignal : ControlSignal;\n    operation startup();\n    operation shutdown();\n    operation selfInspection();\n    operation powerSupply();\n    operation switchToDegradedMode();\n    operation sendWarning();\n    operation performMaintenance();\n    operation recoverFromFault();\n    operation senseTemperature();\n}\n\nblock VehicleController {\n    input controlSignal : ControlSignal;\n    input statusSignal : StatusSignal;\n    input warningSignal : Boolean;\n    output startSignal : Boolean;\n    output shutdownSignal : Boolean;\n    operation processSignals();\n    operation controlStart();\n    operation controlShutdown();\n}\n\nenum OperationState {\n    Shutdown,\n    Starting,\n    Running,\n    Degraded\n}\n\nenum HealthStatus {\n    Normal,\n    Fault,\n    MaintenanceDue,\n    Recovering\n}\n\nenum FuelType {\n    Gasoline,\n    Diesel,\n    Electric,\n    Hybrid\n}\n\ntype Duration;\ntype Temperature;\ntype DateTime;\ntype StatusSignal;\ntype ControlSignal;\n\nconstraint VehicleStartup {\n    context vehicle : Vehicle;\n    (vehicle.operationState == OperationState.Shutdown)\n    and (vehicle.brakePedalPressed == true)\n    and (vehicle.startSignal == true)\n    implies {\n        vehicle.startup();\n        vehicle.selfInspection();\n        vehicle.powerSupply();\n    }\n}\n\nconstraint OverheatDetection {\n    context vehicle : Vehicle;\n    (vehicle.temperature > AutomatedVehicleModelingSystem.temperatureThreshold)\n    implies {\n        vehicle.sendWarning();\n        vehicle.switchToDegradedMode();\n        vehicle.warningSignal == true;\n    }\n}\n\nconstraint HealthManagement {\n    context vehicle : Vehicle;\n    (vehicle.maintenanceDue == true)\n    implies {\n        vehicle.performMaintenance();\n    }\n    (vehicle.healthStatus == HealthStatus.Fault)\n    implies {\n        vehicle.recoverFromFault();\n        vehicle.healthStatus == HealthStatus.Recovering;\n    }\n}\n\nconstraint ControllerProcessing {\n    context controller : VehicleController;\n    controller.processSignals();\n    (controller.startSignal == true)\n    implies {\n        controller.controlStart();\n    }\n    (controller.shutdownSignal == true)\n    implies {\n        controller.controlShutdown();\n    }\n}",
    "system SpatiotemporalVehicleSimulation {\n\n    part vehicle : Vehicle;\n    part road : Road;\n    part simulation : Simulation;\n    part user : User;\n\n    interface VehicleState {\n        attribute mass : Real;\n        attribute position : Vector3D;\n        attribute velocity : Vector3D;\n        attribute acceleration : Vector3D;\n        attribute state : VehicleOperationalState;\n    }\n\n    interface RoadState {\n        attribute slopeAngle : Real;\n        attribute frictionCoefficient : Real;\n    }\n\n    interface Snapshot {\n        attribute time : Real;\n        attribute vehicleState : VehicleState;\n        attribute roadState : RoadState;\n    }\n\n    part snapshots : Snapshot[*];\n\n    constraint VehicleStateTransition {\n        // Vehicle state transitions: on -> driving -> off\n        // (Details omitted for brevity)\n    }\n\n    constraint VehicleDynamics {\n        // Vehicle dynamics equations using mass, position, velocity, acceleration,\n        // road slope, and friction coefficient\n        // (Details omitted for brevity)\n    }\n\n    requirement SpatiotemporalSimulation {\n        text \"The system shall simulate the dynamic behavior of vehicles on roads at different moments, allowing users to define vehicle and road parameters, and record snapshots of vehicle and road states at multiple time points.\"\n    }\n\n    requirement StateTransitionTracking {\n        text \"The system shall support tracking of vehicle state transitions from start-up (on), through driving, to shutdown (off) within the simulation time series.\"\n    }\n\n    requirement DataSupport {\n        text \"The system shall provide detailed data to support vehicle dynamics analysis and road adaptability assessment, enabling prediction of vehicle performance under specific road and time conditions.\"\n    }\n}\n\nblock Vehicle {\n    attribute mass : Real;\n    attribute position : Vector3D;\n    attribute velocity : Vector3D;\n    attribute acceleration : Vector3D;\n    attribute state : VehicleOperationalState;\n}\n\nblock Road {\n    attribute slopeAngle : Real;\n    attribute frictionCoefficient : Real;\n}\n\nblock Simulation {\n    attribute startTime : Real;\n    attribute endTime : Real;\n    attribute timeStep : Real;\n}\n\nblock User {\n    // User interacts with simulation, defines parameters, and reviews results\n}\n\nenum VehicleOperationalState {\n    on;\n    driving;\n    off;\n}\n\ntype Vector3D {\n    attribute x : Real;\n    attribute y : Real;\n    attribute z : Real;\n}",
    "package AutomotiveConfigManagement {\n\n    part Automobile {\n        part subsystemA: SubsystemA;\n        part subsystemB: SubsystemB;\n    }\n\n    part SubsystemA {\n        feature config: SubsystemAConfig;\n    }\n\n    part SubsystemB {\n        feature config: SubsystemBConfig;\n    }\n\n    part Component1 {}\n    part Component2 {}\n    part Component3 {}\n    part Component4 {}\n    part Component5 {}\n    part Component6 {}\n\n    part SubsystemAConfig1 {\n        part component1: Component1;\n        part component2: Component2;\n    }\n\n    part SubsystemAConfig2 {\n        part component2: Component2;\n        part component3: Component3;\n    }\n\n    part SubsystemBConfig1 {\n        part component4: Component4;\n        part component5: Component5;\n    }\n\n    part SubsystemBConfig2 {\n        part component5: Component5;\n        part component6: Component6;\n    }\n\n    // Configuration options for SubsystemA\n    abstract part SubsystemAConfig;\n    specialize SubsystemAConfig1 specializes SubsystemAConfig;\n    specialize SubsystemAConfig2 specializes SubsystemAConfig;\n\n    // Configuration options for SubsystemB\n    abstract part SubsystemBConfig;\n    specialize SubsystemBConfig1 specializes SubsystemBConfig;\n    specialize SubsystemBConfig2 specializes SubsystemBConfig;\n\n    // Predefined vehicle configurations\n    part ConfigurationA {\n        part automobile: Automobile {\n            part subsystemA: SubsystemA {\n                config: SubsystemAConfig1;\n            }\n            part subsystemB: SubsystemB {\n                config: SubsystemBConfig1;\n            }\n        }\n    }\n\n    part ConfigurationB {\n        part automobile: Automobile {\n            part subsystemA: SubsystemA {\n                config: SubsystemAConfig2;\n            }\n            part subsystemB: SubsystemB {\n                config: SubsystemBConfig1;\n            }\n        }\n    }\n\n    // Constraint: If SubsystemA selects Config2, then SubsystemB must select Config2, or SubsystemA must not be Config2\n    constraint SubsystemConfigConstraint {\n        (automobile.subsystemA.config == SubsystemAConfig2) implies\n        (automobile.subsystemB.config == SubsystemBConfig2)\n    }\n}",
    "package ModularVehiclePlatform {\n\n    part Part1 {}\n\n    part Part2 {}\n\n    part Part3 {\n        port p1\n    }\n\n    part Part4 {}\n\n    part Part5 {\n        port p2\n        behavior variant VariantA {}\n        behavior variant VariantB {}\n    }\n\n    part Part6 {}\n\n    abstract part SubsystemA {\n        port aPort1\n        port aPort2\n        part[0..*] internalComponentA : Part1 or Part2 or Part3 or Part4 or Part5 or Part6\n    }\n\n    abstract part SubsystemB {\n        port bPort1\n        port bPort2\n        part[0..*] internalComponentB : Part1 or Part2 or Part3 or Part4 or Part5 or Part6\n    }\n\n    part VehicleConfigA {\n        part subsystemA : SubsystemA\n        part subsystemB : SubsystemB\n        constraint configConstraintA {\n            // Ensures valid combination of subsystems and components for VehicleConfigA\n        }\n    }\n\n    part VehicleConfigB {\n        part subsystemA : SubsystemA\n        part subsystemB : SubsystemB\n        constraint configConstraintB {\n            // Ensures valid combination of subsystems and components for VehicleConfigB\n        }\n    }\n\n    part ModularVehicleSystem {\n        part[1..*] subsystems : SubsystemA or SubsystemB\n        part[0..*] components : Part1 or Part2 or Part3 or Part4 or Part5 or Part6\n        part[0..*] vehicleConfigs : VehicleConfigA or VehicleConfigB\n        constraint systemLevelConstraint {\n            // Ensures configuration consistency and rationality\n        }\n    }\n\n    connector SubsystemA.aPort1 <-> SubsystemB.bPort1\n    connector SubsystemA.aPort2 <-> SubsystemB.bPort2\n\n}",
    "package VehicleProductLineConfig {\n\n    part VehicleProductLineConfigSystem {\n        part vehicleModels: VehicleModelVariant[1..*];\n        part configurationEngine: ConfigurationEngine[1];\n    }\n\n    part VehicleModelVariant {\n        part engine: Engine[1];\n        part transmission: Transmission[1];\n        part wheels: Wheels[1];\n        attribute performanceRequirement: PerformanceRequirement[1];\n        attribute userPreference: UserPreference[0..*];\n    }\n\n    part ConfigurationEngine {\n        operation configureVehicle(\n            in performance: PerformanceRequirement,\n            in preferences: UserPreference[0..*],\n            out vehicle: VehicleModelVariant\n        );\n        constraint configurationConstraints;\n    }\n\n    part Engine {\n        attribute type: EngineType[1];\n        attribute cylinderCount: Integer[1];\n    }\n\n    part Transmission {\n        attribute type: TransmissionType[1];\n    }\n\n    part Wheels {\n        attribute rimWidth: RimWidthType[1];\n    }\n\n    enum PerformanceRequirement {\n        HighPerformance,\n        StandardPerformance\n    }\n\n    enum UserPreference {\n        EcoFriendly,\n        Sporty,\n        Comfort,\n        Custom\n    }\n\n    enum EngineType {\n        Inline4,\n        V6\n    }\n\n    enum TransmissionType {\n        Manual,\n        Automatic\n    }\n\n    enum RimWidthType {\n        Narrow,\n        Wide\n    }\n\n    constraint configurationConstraints {\n        // High performance configuration\n        (vehicleModels.performanceRequirement == HighPerformance) implies (\n            vehicleModels.engine.cylinderCount == 6 and\n            vehicleModels.engine.type == V6 and\n            vehicleModels.transmission.type == Automatic and\n            vehicleModels.wheels.rimWidth == Wide\n        );\n        // Standard performance configuration\n        (vehicleModels.performanceRequirement == StandardPerformance) implies (\n            vehicleModels.engine.cylinderCount == 4 and\n            vehicleModels.engine.type == Inline4 and\n            vehicleModels.transmission.type == Manual and\n            vehicleModels.wheels.rimWidth == Narrow\n        );\n        // Component compatibility constraint\n        (vehicleModels.engine.type == V6) implies (vehicleModels.transmission.type == Automatic);\n        (vehicleModels.engine.type == Inline4) implies (vehicleModels.transmission.type == Manual);\n        // Prevent unreasonable combinations\n        not (\n            (vehicleModels.engine.cylinderCount == 6 and vehicleModels.transmission.type == Manual) or\n            (vehicleModels.engine.cylinderCount == 4 and vehicleModels.transmission.type == Automatic)\n        );\n    }\n\n}",
    "system AutomobileSpecificationSystem {\n\n    part vehicles: Vehicle[1..*];\n    part engines: Engine[1..*];\n    part transmissions: Transmission[1..*];\n\n    interface DriveInterface {\n        in torque: Torque;\n        out torque: Torque;\n    }\n\n    requirement VehicleMassRequirement {\n        description: \"Each vehicle shall reflect its actual mass and comply with the corresponding maximum mass limitations to prevent overloading.\";\n        verify vehicles.actualMass <= vehicles.maxAllowedMass;\n    }\n\n    requirement MassGradeDefinition {\n        description: \"The system shall support the definition and management of vehicles with different mass grades (e.g., 2000 kg, 2500 kg).\";\n        verify vehicles.massGrade in {2000 kg, 2500 kg};\n    }\n\n    requirement FuelStatusRequirement {\n        description: \"The system shall regulate fuel status, requiring some vehicles to meet mass requirements when fully fueled, while others are accepted in an empty-fuel state.\";\n        verify (vehicles.fuelStatus == 'full' implies vehicles.actualMass <= vehicles.maxAllowedMass) and\n               (vehicles.fuelStatus == 'empty' implies vehicles.actualMass <= vehicles.maxAllowedMass);\n    }\n\n    requirement PowerDeliveryRequirement {\n        description: \"Vehicles must have power delivery functionality, requiring the engine to output torque and be connected to the transmission via a drive interface.\";\n        verify engines.outputTorque is connected to transmissions.inputTorque via DriveInterface;\n    }\n\n    requirement ReliabilityRequirement {\n        description: \"For specific models, requirements include tracking and fulfilling reliability, ensuring specified performance and durability throughout lifecycle.\";\n        verify vehicles.reliability >= vehicles.requiredReliability;\n    }\n\n    allocate VehicleMassRequirement to vehicles;\n    allocate MassGradeDefinition to vehicles;\n    allocate FuelStatusRequirement to vehicles;\n    allocate PowerDeliveryRequirement to engines, transmissions;\n    allocate ReliabilityRequirement to vehicles;\n\n    validate VehicleMassRequirement by vehicles.massValidationTest;\n    validate MassGradeDefinition by vehicles.massGradeTest;\n    validate FuelStatusRequirement by vehicles.fuelStatusTest;\n    validate PowerDeliveryRequirement by engines.powerDeliveryTest;\n    validate ReliabilityRequirement by vehicles.reliabilityTest;\n}\n\nblock Vehicle {\n    attribute actualMass: Mass;\n    attribute maxAllowedMass: Mass;\n    attribute massGrade: Mass;\n    attribute fuelStatus: FuelStatus;\n    attribute reliability: Reliability;\n    attribute requiredReliability: Reliability;\n\n    part engine: Engine;\n    part transmission: Transmission;\n\n    operation massValidationTest();\n    operation massGradeTest();\n    operation fuelStatusTest();\n    operation reliabilityTest();\n}\n\nblock Engine {\n    attribute outputTorque: Torque;\n    operation powerDeliveryTest();\n    port driveOut: DriveInterface;\n}\n\nblock Transmission {\n    attribute inputTorque: Torque;\n    port driveIn: DriveInterface;\n}\n\ntype Mass = Real[kg];\ntype Torque = Real[Nm];\ntype Reliability = Real;\nenum FuelStatus { full, empty }\n",
    "package VehicleMassCompliance {\n\n    part Vehicle {\n        attribute actualMass: Real;\n        attribute isCompliant: Boolean;\n    }\n\n    part WeighingEquipment {\n        operation measureMass(vehicle: Vehicle): Real;\n    }\n\n    part TestOperator {\n        operation operate(equipment: WeighingEquipment, vehicle: Vehicle): Real;\n    }\n\n    part ComplianceSystem {\n        attribute maxPermissibleMass: Real = 2500.0;\n        part vehicles: Vehicle[*];\n        part weighingEquipment: WeighingEquipment;\n        part testOperator: TestOperator;\n\n        operation verifyCompliance(vehicle: Vehicle): Boolean {\n            measuredMass = testOperator.operate(weighingEquipment, vehicle);\n            vehicle.actualMass = measuredMass;\n            if (measuredMass <= maxPermissibleMass) {\n                vehicle.isCompliant = true;\n            } else {\n                vehicle.isCompliant = false;\n            }\n            return vehicle.isCompliant;\n        }\n\n        operation testAllVehicles(): Boolean[*] {\n            results: Boolean[*];\n            for (v in vehicles) {\n                result = verifyCompliance(v);\n                results.add(result);\n            }\n            return results;\n        }\n    }\n}",
    "package WaterSupplyNetwork {\n\n    part MainSupplyPipe : SpigotBank;\n    part Faucets : Faucet[1..*];\n\n    interface Spigot {\n        out hotWater : Water;\n        out coldWater : Water;\n    }\n\n    interface FaucetInlet {\n        in hotWater : Water;\n        in coldWater : Water;\n    }\n\n    part SpigotBank {\n        port hotSpigot : Spigot;\n        port coldSpigot : Spigot;\n    }\n\n    part Faucet {\n        port inlet : FaucetInlet;\n    }\n\n    connection HotWaterConnection {\n        from MainSupplyPipe.hotSpigot.hotWater;\n        to Faucets[*].inlet.hotWater;\n    }\n\n    connection ColdWaterConnection {\n        from MainSupplyPipe.coldSpigot.coldWater;\n        to Faucets[*].inlet.coldWater;\n    }\n\n    requirement ReliableDelivery {\n        text \"The system shall reliably deliver hot and cold water from the respective outlets of the main supply pipe to the corresponding inlets of all downstream faucets, ensuring simultaneous supply to multiple water usage points.\";\n    }\n\n    requirement CorrectConnection {\n        text \"The system shall guarantee correct connection and smooth transmission of the hot and cold water pipelines, meeting the requirements for distributed hot and cold water supply.\";\n    }\n\n    type Water;\n}",
    "package VehicleQualityAnalysisSystem {\n\n    part VehicleQualityAnalysisSystem {\n        part vehicle : Vehicle;\n        part user : User;\n        part qualityAnalysisModule : QualityAnalysisModule;\n        part requirementsModule : RequirementsModule;\n        part analysisTaskManager : AnalysisTaskManager;\n    }\n\n    part Vehicle {\n        part engine : Engine;\n        part transmission : Transmission;\n        part frontAxleAssembly : FrontAxleAssembly;\n        part rearAxleAssembly : RearAxleAssembly;\n        attribute totalMass : Mass;\n        attribute qualityAttributes : QualityAttributes;\n    }\n\n    part Engine {\n        attribute mass : Mass;\n        attribute qualityData : QualityData;\n    }\n\n    part Transmission {\n        attribute mass : Mass;\n        attribute qualityData : QualityData;\n    }\n\n    part FrontAxleAssembly {\n        attribute mass : Mass;\n        attribute qualityData : QualityData;\n    }\n\n    part RearAxleAssembly {\n        attribute mass : Mass;\n        attribute qualityData : QualityData;\n    }\n\n    part User {\n        operation inputQualityData(component : VehicleComponent, data : QualityData);\n        operation defineQualityAnalysisRequirement(requirement : QualityRequirement);\n        operation formulateAnalysisUseCase(useCase : AnalysisUseCase);\n    }\n\n    part QualityAnalysisModule {\n        operation aggregateComponentMasses();\n        operation calculateTotalVehicleMass();\n        operation analyzeQualityAttributes();\n        operation provideDataFoundation();\n    }\n\n    part RequirementsModule {\n        operation defineQualityAnalysisRequirement(requirement : QualityRequirement);\n        operation trackRequirements();\n    }\n\n    part AnalysisTaskManager {\n        operation generateAnalysisTasks(objectives : AnalysisObjectives);\n        operation generateAnalysisPlans();\n        operation evaluateVehicleQuality();\n    }\n\n    type Mass {\n        attribute value : Real;\n        attribute unit : String;\n    }\n\n    type QualityAttributes {\n        attribute reliability : Real;\n        attribute durability : Real;\n        attribute safety : Real;\n        attribute performance : Real;\n    }\n\n    type QualityData {\n        attribute attributeName : String;\n        attribute value : Real;\n    }\n\n    type QualityRequirement {\n        attribute description : String;\n        attribute targetValue : Real;\n    }\n\n    type AnalysisUseCase {\n        attribute name : String;\n        attribute description : String;\n    }\n\n    type AnalysisObjectives {\n        attribute objectiveName : String;\n        attribute description : String;\n    }\n\n    part VehicleComponent {\n        attribute name : String;\n        attribute mass : Mass;\n        attribute qualityData : QualityData;\n    }\n\n    requirement R1 \"The system shall enable users to input quality data for each vehicle component.\"\n    requirement R2 \"The system shall automatically aggregate and calculate the total mass of the vehicle.\"\n    requirement R3 \"The system shall provide a data foundation for quality analysis.\"\n    requirement R4 \"The system shall support the definition of quality analysis requirements.\"\n    requirement R5 \"The system shall support the formulation of analysis use cases.\"\n    requirement R6 \"The system shall automatically generate analysis tasks and plans based on analysis objectives.\"\n    requirement R7 \"The system shall achieve comprehensive evaluation and requirements tracking for vehicle quality.\"\n    requirement R8 \"The system shall provide scientific support for vehicle design and performance optimization.\"\n    requirement R9 \"The system shall improve overall development efficiency and product performance.\"\n\n    satisfies VehicleQualityAnalysisSystem -> R1;\n    satisfies VehicleQualityAnalysisSystem -> R2;\n    satisfies VehicleQualityAnalysisSystem -> R3;\n    satisfies VehicleQualityAnalysisSystem -> R4;\n    satisfies VehicleQualityAnalysisSystem -> R5;\n    satisfies VehicleQualityAnalysisSystem -> R6;\n    satisfies VehicleQualityAnalysisSystem -> R7;\n    satisfies VehicleQualityAnalysisSystem -> R8;\n    satisfies VehicleQualityAnalysisSystem -> R9;\n\n}",
    "package VehiclePowertrainConfigurationSystem {\n\n    part VehiclePowertrainConfigurationSystem {\n        part engineSelectionSubsystem: EngineSelectionSubsystem;\n        part engineModelingSubsystem: EngineModelingSubsystem;\n        part tradeoffAnalysisSubsystem: TradeoffAnalysisSubsystem;\n        part evaluationSubsystem: EvaluationSubsystem;\n        part recommendationSubsystem: RecommendationSubsystem;\n        part explanationSubsystem: ExplanationSubsystem;\n    }\n\n    part EngineSelectionSubsystem {\n        reference engineConfigurations: EngineConfiguration[1..*];\n        operation selectOptimalEngine();\n    }\n\n    part EngineModelingSubsystem {\n        operation modelEngineStructure();\n        part engineStructure: EngineStructure;\n    }\n\n    part TradeoffAnalysisSubsystem {\n        operation performTradeoffAnalysis();\n        reference keyPerformanceIndicators: KeyPerformanceIndicator[1..*];\n    }\n\n    part EvaluationSubsystem {\n        operation evaluateEngineSchemes();\n        reference evaluationModel: EvaluationModel;\n    }\n\n    part RecommendationSubsystem {\n        operation recommendOptimalEngine();\n        reference evaluationResults: EvaluationResult[1..*];\n    }\n\n    part ExplanationSubsystem {\n        operation provideSelectionExplanation();\n        reference selectionRationale: SelectionRationale;\n    }\n\n    part EngineConfiguration {\n        reference engineStructure: EngineStructure;\n        attribute power: Real;\n        attribute mass: Real;\n        attribute efficiency: Real;\n        attribute reliability: Real;\n        attribute cost: Real;\n    }\n\n    part EngineStructure {\n        part cylinders: Cylinder[1..*];\n        part pistons: Piston[1..*];\n        part connectingRods: ConnectingRod[1..*];\n        part crankshaft: Crankshaft;\n        attribute cylinderCount: Integer;\n        attribute engineType: String;\n    }\n\n    part Cylinder {}\n    part Piston {}\n    part ConnectingRod {}\n    part Crankshaft {}\n\n    part KeyPerformanceIndicator {\n        attribute name: String;\n        attribute value: Real;\n    }\n\n    part EvaluationModel {\n        operation assessPerformance(engineConfig: EngineConfiguration): EvaluationResult;\n    }\n\n    part EvaluationResult {\n        reference engineConfiguration: EngineConfiguration;\n        attribute score: Real;\n        attribute kpiResults: KeyPerformanceIndicator[1..*];\n    }\n\n    part SelectionRationale {\n        attribute explanationText: String;\n        reference evaluationResult: EvaluationResult;\n    }\n}",
    "system VehicleFuelEconomySystem {\n    \n    part vehicle: Vehicle;\n    part powertrain: Powertrain;\n    part load: Load;\n    part operatingConditions: OperatingConditions;\n    part fuelEconomyAssessment: FuelEconomyAssessment;\n    \n    requirement RegulatoryCompliance {\n        text \"The system shall ensure that vehicle fuel economy meets relevant regulatory and performance requirements.\"\n    }\n    \n    requirement UrbanFuelEconomy {\n        text \"Under urban driving conditions, the vehicle’s range per gallon must not be less than 25 miles.\"\n    }\n    \n    requirement HighwayFuelEconomy {\n        text \"Under highway driving conditions, the vehicle’s range per gallon must not be less than 30 miles.\"\n    }\n    \n    requirement FuelEconomyMeasurement {\n        text \"Fuel economy is measured in miles per gallon, based on the US customary gallon (231 cubic inches).\"\n    }\n    \n    requirement TestLoadCondition {\n        text \"Fuel economy tests are conducted with the vehicle assuming an additional load of 1,000 pounds, under standard urban and highway driving scenarios respectively.\"\n    }\n    \n    requirement FuelEconomyAssessmentRequirement {\n        text \"The measured fuel economy must meet the minimum requirements stated above.\"\n    }\n    \n    requirement ParameterModeling {\n        text \"The system models and analyzes key parameters such as vehicle powertrain, load, and operating conditions, supporting fuel consumption assessment under various conditions.\"\n    }\n    \n    requirement RegulatoryTargetAchievement {\n        text \"The system shall ensure that the designed vehicle can achieve the regulatory fuel economy targets for both urban and highway scenarios.\"\n    }\n    \n    satisfies RegulatoryCompliance;\n    satisfies UrbanFuelEconomy;\n    satisfies HighwayFuelEconomy;\n    satisfies FuelEconomyMeasurement;\n    satisfies TestLoadCondition;\n    satisfies FuelEconomyAssessmentRequirement;\n    satisfies ParameterModeling;\n    satisfies RegulatoryTargetAchievement;\n}\n\nblock Vehicle {\n    property powertrain: Powertrain;\n    property load: Load;\n    property operatingConditions: OperatingConditions;\n}\n\nblock Powertrain {\n    // Key powertrain parameters modeled here\n}\n\nblock Load {\n    property additionalLoad: Real = 1000; // pounds\n}\n\nblock OperatingConditions {\n    property scenario: ScenarioKind;\n}\n\nenum ScenarioKind {\n    urban,\n    highway\n}\n\nblock FuelEconomyAssessment {\n    property measuredFuelEconomy: Real; // miles per gallon\n    property testLoad: Real = 1000; // pounds\n    property testScenario: ScenarioKind;\n}\n\nconstraint UrbanFuelEconomyConstraint {\n    parameter measuredFuelEconomy: Real;\n    expression measuredFuelEconomy >= 25;\n}\n\nconstraint HighwayFuelEconomyConstraint {\n    parameter measuredFuelEconomy: Real;\n    expression measuredFuelEconomy >= 30;\n}\n\nunit USGallon {\n    definition 231 * inch^3;\n}\n\nunit MilesPerGallon {\n    definition mile / USGallon;\n}",
    "package VehicleLongitudinalDynamics {\n\n    part VehicleSimulationSystem {\n        part userInput: UserInput;\n        part dynamicsCalculator: DynamicsCalculator;\n        part outputGenerator: OutputGenerator;\n    }\n\n    part UserInput {\n        attribute vehicleMass: Real;\n        attribute initialPosition: Real;\n        attribute initialVelocity: Real;\n        attribute powerOutputData: PowerOutputSegment[1..*];\n        attribute timeStep: Real;\n    }\n\n    part PowerOutputSegment {\n        attribute startTime: Real;\n        attribute endTime: Real;\n        attribute power: Real;\n    }\n\n    part DynamicsCalculator {\n        reference input: UserInput;\n        attribute accelerationSequence: Real[1..*];\n        attribute velocitySequence: Real[1..*];\n        attribute positionSequence: Real[1..*];\n        operation calculateDynamics();\n    }\n\n    part OutputGenerator {\n        reference calculator: DynamicsCalculator;\n        attribute accelerationOutput: Real[1..*];\n        attribute velocityOutput: Real[1..*];\n        attribute displacementOutput: Real[1..*];\n        operation generateOutput();\n    }\n\n    requirement SimulateAndAnalyzeLongitudinalDynamics {\n        text \"The system shall simulate and analyze the longitudinal dynamic characteristics of vehicle motion using user-input parameters and segmented power output data, calculating acceleration, velocity, and position at each time step, and outputting the sequences for analysis and decision-making support.\";\n    }\n\n    requirement UserInputParameters {\n        text \"The system shall allow users to input vehicle mass, initial position, initial velocity, segmented power output data, and time step.\";\n    }\n\n    requirement DynamicCalculation {\n        text \"The system shall calculate acceleration, velocity, and position at each moment using dynamic equations based on input power and operating conditions.\";\n    }\n\n    requirement OutputSequences {\n        text \"The system shall output the sequences of acceleration, velocity variation, and displacement throughout the vehicle's motion process.\";\n    }\n\n    requirement ApplicationSupport {\n        text \"The system shall provide data support for vehicle performance analysis, control strategy development, and driving behavior evaluation.\";\n    }\n}",
    "model VehicleSystem {\n\n    part car: Car;\n\n}\n\nblock Car {\n\n    property totalMass: Mass = 2500 kg;\n\n    part frontAxleAssembly: FrontAxleAssembly;\n\n    part rearAxleAssembly: RearAxleAssembly;\n\n}\n\nblock FrontAxleAssembly {\n\n    property mass: Mass = 150 kg;\n\n    part frontLeftWheel: FrontWheel;\n\n    part frontRightWheel: FrontWheel;\n\n    part frontAxle: FrontAxle;\n\n}\n\nblock RearAxleAssembly {\n\n    property mass: Mass = 250 kg;\n\n    part rearLeftWheel: RearWheel;\n\n    part rearRightWheel: RearWheel;\n\n    part rearAxle: RearAxle;\n\n}\n\nblock FrontAxle {\n\n    property mass: Mass;\n\n    property steeringAngle: Angle;\n\n}\n\nblock RearAxle {\n\n    property mass: Mass;\n\n}\n\nblock FrontWheel {\n\n}\n\nblock RearWheel {\n\n}\n\ntype Mass = Real;\n\ntype Angle = Real;\n\nunit kg;\n\n}",
    "package VehicleSafetySecuritySystem {\n\n    part VehicleSystem {\n        part vehicle: Vehicle;\n        part userInterface: UserInterface;\n        part componentManager: ComponentManager;\n        part visualizationManager: VisualizationManager;\n    }\n\n    part Vehicle {\n        part seatBelt: SeatBelt;\n        part bumper: Bumper;\n        part airbag: Airbag;\n        part abs: AntiLockBrakingSystem;\n        part alarm: AlarmDevice;\n        part keylessEntry: KeylessEntrySystem;\n    }\n\n    part SeatBelt {\n        feature isMandatory: Boolean = true;\n        feature type: String;\n    }\n\n    part Bumper {\n        feature isMandatory: Boolean = true;\n        feature type: String;\n    }\n\n    part Airbag {\n        feature isMandatory: Boolean = false;\n        feature type: String;\n    }\n\n    part AntiLockBrakingSystem {\n        feature isMandatory: Boolean = false;\n        feature type: String;\n    }\n\n    part AlarmDevice {\n        feature isSecurity: Boolean = true;\n        feature type: String;\n    }\n\n    part KeylessEntrySystem {\n        feature isSecurity: Boolean = true;\n        feature type: String;\n    }\n\n    part ComponentManager {\n        operation filterByFeature(featureType: String): Component[];\n        operation organizeComponents(criteria: String): Component[];\n    }\n\n    part VisualizationManager {\n        operation displayAsTree(components: Component[]): Visualization;\n        operation displayAsTable(components: Component[]): Visualization;\n    }\n\n    part UserInterface {\n        operation reviewSafetyConfigurations(): void;\n        operation distinguishMandatoryFunctions(): void;\n        operation viewSecurityFeatures(): void;\n    }\n\n    part Component {\n        feature name: String;\n        feature isMandatory: Boolean;\n        feature isSecurity: Boolean;\n    }\n\n    part Visualization {\n        feature format: String;\n        feature content: String;\n    }\n}",
    "package LayeredSystem {\n\n    part system : System {\n        attribute x : Real;\n        attribute y : Real;\n        attribute z : Real;\n    }\n\n    part applicationLayer : ApplicationLayer;\n    part serviceLayer : ServiceLayer;\n    part dataLayer : DataLayer;\n\n    composition {\n        system -> applicationLayer;\n        system -> serviceLayer;\n        system -> dataLayer;\n    }\n\n    dependency {\n        applicationLayer -> serviceLayer;\n        serviceLayer -> dataLayer;\n    }\n\n    constraint zDependsOnXandY {\n        system.z = f(system.x, system.y);\n    }\n\n    constraint clearDivisionOfResponsibilities {\n        applicationLayer.responsibility = \"Application logic and user interaction\";\n        serviceLayer.responsibility = \"Business logic and service orchestration\";\n        dataLayer.responsibility = \"Data storage and retrieval\";\n    }\n\n    constraint smoothDataFlowAndFunctionalCalls {\n        applicationLayer.uses(serviceLayer);\n        serviceLayer.uses(dataLayer);\n    }\n\n    partDefinition System {\n        attribute x : Real;\n        attribute y : Real;\n        attribute z : Real;\n    }\n\n    partDefinition ApplicationLayer {\n        // Application-specific operations\n    }\n\n    partDefinition ServiceLayer {\n        // Service-specific operations\n    }\n\n    partDefinition DataLayer {\n        // Data-specific operations\n    }\n}",
    "package PowertrainTorqueGeneration {\n\n    import sysml::blocks;\n    import sysml::constraints;\n    import sysml::requirements;\n    import sysml::allocations;\n    import sysml::quantities;\n\n    requirement TorqueGenerationFunction {\n        text \"The system shall realize the torque generation function within the powertrain system.\"\n    }\n\n    requirement PositiveTorqueRequirement {\n        text \"The torque produced during operation must be greater than zero newton-meters to ensure driving capability.\"\n    }\n\n    requirement TorqueFunctionAllocation {\n        text \"The logic layer's torque generator function shall be allocated and mapped to the physical layer of the powertrain, including actual components such as the engine.\"\n    }\n\n    block PowertrainSystem {\n        part engine: Engine;\n        part torqueGenerator: TorqueGeneratorFunction;\n        part transmission: Transmission;\n        constraint torquePositive: PositiveTorqueConstraint;\n    }\n\n    block Engine {\n        attribute outputTorque: sysml::quantities::Torque;\n    }\n\n    block Transmission {\n        attribute inputTorque: sysml::quantities::Torque;\n        attribute outputTorque: sysml::quantities::Torque;\n    }\n\n    block TorqueGeneratorFunction {\n        attribute generatedTorque: sysml::quantities::Torque;\n    }\n\n    constraint PositiveTorqueConstraint {\n        parameter torque: sysml::quantities::Torque;\n        expression torque > 0 N*m;\n    }\n\n    allocation TorqueFunctionToEngine {\n        from TorqueGeneratorFunction;\n        to Engine;\n    }\n\n    allocation TorqueFunctionToTransmission {\n        from TorqueGeneratorFunction;\n        to Transmission;\n    }\n\n    satisfies PowertrainSystem -> TorqueGenerationFunction;\n    satisfies PowertrainSystem -> PositiveTorqueRequirement;\n    satisfies PowertrainSystem -> TorqueFunctionAllocation;\n\n    verify PowertrainSystem.torquePositive(torque=PowertrainSystem.engine.outputTorque);\n\n}",
    "package PowerSystem {\n\n    // Logical Functions\n    function transmitPower {}\n    function outputPower {}\n    function providePower {}\n    function generateTorque {}\n\n    // Logical Component\n    part TorqueGenerator {\n        performs generateTorque\n    }\n\n    // Physical Components\n    part Powertrain {\n        part Engine {\n            performs generateTorque\n        }\n    }\n\n    // System Definition\n    part System {\n        performs transmitPower\n        performs outputPower\n        performs providePower\n\n        part torqueGenerator: TorqueGenerator\n        part powertrain: Powertrain\n    }\n\n    // Allocation: Map logical function to physical implementation\n    allocate TorqueGenerator.generateTorque to Powertrain.Engine.generateTorque\n\n}",
    "package VehicleSafetyAndAntiTheftCatalogue {\n\n   part Vehicle {\n      part body : Body\n      part interior : Interior\n      part frontSeatBelt : FrontSeatBelt\n      part bumper : Bumper\n      part driverAirbag : DriverAirbag\n      part abs : AntiLockBrakingSystem\n      part alarmSystem : AlarmSystem\n      part keylessEntrySystem : KeylessEntrySystem\n   }\n\n   part Body {}\n   part Interior {}\n\n   part FrontSeatBelt {\n      conformsTo SafetyComponent\n      mandatory\n      allocatedTo [Body, Interior]\n   }\n\n   part Bumper {\n      conformsTo SafetyComponent\n      mandatory\n      allocatedTo Body\n   }\n\n   part DriverAirbag {\n      conformsTo SafetyComponent\n      optional\n      allocatedTo Interior\n   }\n\n   part AntiLockBrakingSystem {\n      conformsTo SafetyComponent\n      optional\n   }\n\n   part AlarmSystem {\n      conformsTo SecurityComponent\n      mandatory\n   }\n\n   part KeylessEntrySystem {\n      conformsTo SecurityComponent\n      mandatory\n   }\n\n   interface SafetyComponent {}\n   interface SecurityComponent {}\n\n   requirement BasicSafety {\n      description \"The vehicle must be equipped with basic safety components such as front seat belts and bumpers to ensure the fundamental personal safety of occupants.\"\n      verify FrontSeatBelt\n      verify Bumper\n   }\n\n   requirement OptionalSafetyFeatures {\n      description \"Certain components, such as the driver’s airbag and anti-lock braking system, are characterized as safety features but may or may not be mandatory depending on specific configurations.\"\n      verify DriverAirbag\n      verify AntiLockBrakingSystem\n   }\n\n   requirement SecurityFeatures {\n      description \"The vehicle should be equipped with security components such as an alarm system and a keyless entry system to enhance the overall security and protective capability of the vehicle.\"\n      verify AlarmSystem\n      verify KeylessEntrySystem\n   }\n\n   view SafetyComponents {\n      select part where conformsTo SafetyComponent\n   }\n\n   view SecurityComponents {\n      select part where conformsTo SecurityComponent\n   }\n\n   view MandatorySafetyComponents {\n      select part where conformsTo SafetyComponent and mandatory\n   }\n\n   view ComponentsAffectingSafety {\n      select part where conformsTo SafetyComponent\n   }\n\n   view ComponentsAffectingAntiTheft {\n      select part where conformsTo SecurityComponent\n   }\n\n   view ComponentsAffectingBoth {\n      select part where conformsTo SafetyComponent and conformsTo SecurityComponent\n   }\n}",
    "package FuelSystem {\n\n    part Vehicle {\n        part fuelSystem: FuelSystem;\n    }\n\n    part FuelSystem {\n        part fuelTankAssembly: FuelTankAssembly;\n        part fuelReturnLine: FuelReturnLine;\n        part fuelConsumingUnits: FuelConsumingUnits;\n        part fuelTemperatureSensor: FuelTemperatureSensor;\n\n        connector supplyLine: FuelFlowConnector {\n            end source: fuelTankAssembly.fuelPump;\n            end target: fuelConsumingUnits;\n        }\n\n        connector returnLine: FuelFlowConnector {\n            end source: fuelConsumingUnits;\n            end target: fuelReturnLine;\n        }\n\n        connector returnToTank: FuelFlowConnector {\n            end source: fuelReturnLine;\n            end target: fuelTankAssembly;\n        }\n\n        connector tempDataLine: DataFlowConnector {\n            end source: fuelTemperatureSensor;\n            end target: fuelSystem;\n        }\n    }\n\n    part FuelTankAssembly {\n        part fuelTank: FuelTank;\n        part fuelPump: FuelPump;\n    }\n\n    part FuelTank {}\n\n    part FuelPump {\n        operation pressurizeFuel();\n        operation deliverFuel();\n    }\n\n    part FuelReturnLine {}\n\n    part FuelConsumingUnits {}\n\n    part FuelTemperatureSensor {\n        operation monitorTemperature();\n        operation transmitTemperature();\n    }\n\n    interface FuelFlowConnector {\n        flow property fuel: Fuel;\n    }\n\n    interface DataFlowConnector {\n        flow property temperatureData: TemperatureData;\n    }\n\n    item type Fuel {}\n\n    item type TemperatureData {}\n\n}",
    "requirement VehicleSafetyAndSecurityCompliance {\n    description \"The system proposes requirements for the safety and security compliance configurations of a vehicle.\"\n}\n\npart Vehicle {\n    part interior: Interior\n    part cockpit: Cockpit\n    part body: Body\n    part chassis: Chassis\n}\n\npart Interior {\n    part seatBelt1: SeatBelt\n    part seatBelt2: SeatBelt\n    constraint seatBelt1_mandatory { seatBelt1.isInstalled = true }\n    constraint seatBelt2_mandatory { seatBelt2.isInstalled = true }\n}\n\npart Cockpit {\n    part airbag: Airbag\n    constraint airbag_optional { airbag.isInstalled in {true, false} }\n}\n\npart Body {\n    part bumper: Bumper\n    part keylessEntrySystem: KeylessEntrySystem\n    constraint bumper_mandatory { bumper.isInstalled = true }\n    constraint keylessEntrySystem_mandatory { keylessEntrySystem.isInstalled = true }\n    part antiTheftAlarm: AntiTheftAlarm\n    constraint antiTheftAlarm_mandatory { antiTheftAlarm.isInstalled = true }\n}\n\npart Chassis {\n    part wheel1: Wheel\n    part wheel2: Wheel\n    constraint wheel1_mandatory { wheel1.isInstalled = true }\n    constraint wheel2_mandatory { wheel2.isInstalled = true }\n    part abs1: AntiLockBrakingSystem\n    part abs2: AntiLockBrakingSystem\n    constraint abs_optional { abs1.isInstalled in {true, false} and abs2.isInstalled in {true, false} }\n}\n\npart SeatBelt {}\npart Airbag {}\npart Bumper {}\npart KeylessEntrySystem {}\npart AntiTheftAlarm {}\npart Wheel {}\npart AntiLockBrakingSystem {}\n\nrequirement SeatBeltMandatory {\n    description \"The vehicle interior must be equipped with two seat belts, which are mandatory safety features.\"\n    verify Vehicle.interior.seatBelt1.isInstalled = true\n    verify Vehicle.interior.seatBelt2.isInstalled = true\n}\n\nrequirement AirbagOptional {\n    description \"An airbag should also be installed in the cockpit, but its application is not mandatory.\"\n    verify Vehicle.cockpit.airbag.isInstalled in {true, false}\n}\n\nrequirement AntiTheftAlarmMandatory {\n    description \"An anti-theft alarm device should be installed inside the vehicle to enhance security protection.\"\n    verify Vehicle.body.antiTheftAlarm.isInstalled = true\n}\n\nrequirement BumperMandatory {\n    description \"The vehicle body must be equipped with a bumper, which is a required safety component.\"\n    verify Vehicle.body.bumper.isInstalled = true\n}\n\nrequirement KeylessEntrySystemMandatory {\n    description \"The vehicle body is required to have a keyless entry system to improve security performance.\"\n    verify Vehicle.body.keylessEntrySystem.isInstalled = true\n}\n\nrequirement WheelsMandatory {\n    description \"The chassis structure is to be fitted with two wheels.\"\n    verify Vehicle.chassis.wheel1.isInstalled = true\n    verify Vehicle.chassis.wheel2.isInstalled = true\n}\n\nrequirement ABSOptional {\n    description \"The chassis is to be equipped with two sets of anti-lock braking systems, although the installation of such braking systems is not mandatory.\"\n    verify Vehicle.chassis.abs1.isInstalled in {true, false}\n    verify Vehicle.chassis.abs2.isInstalled in {true, false}\n}\n\nrequirement SafetyAndSecurityIdentification {\n    description \"All aforementioned components related to safety and security are subject to identification and classification management by the system to ensure compliance with regulations regarding critical safety and security functions.\"\n}\n\nrequirement EnhancedSafetyAndSecurity {\n    description \"The system enhances the vehicle’s overall safety and security features by ensuring compliance with safety and security requirements.\"\n}",
    "package VehicleSafetySecurityComponentSystem {\n\n    part VehicleSafetySecurityComponentSystem {\n        part interior: Interior;\n        part bodyAssembly: BodyAssembly;\n        feature safetyFunction: SafetyFunction;\n        feature securityFunction: SecurityFunction;\n    }\n\n    part Interior {\n        part alarmSystem: AlarmSystem;\n        part seatBelts: SeatBelts;\n        part frontRowSeats: FrontRowSeats;\n        part driverAirbag: Airbag;\n    }\n\n    part BodyAssembly {\n        part vehicleBody: VehicleBody;\n        part bumper: Bumper;\n        part keylessEntrySystem: KeylessEntrySystem;\n    }\n\n    part AlarmSystem {\n        feature provides: SecurityFunction;\n    }\n\n    part SeatBelts {\n        feature provides: SafetyFunction;\n    }\n\n    part FrontRowSeats {\n    }\n\n    part Airbag {\n        feature provides: SafetyFunction;\n    }\n\n    part VehicleBody {\n    }\n\n    part Bumper {\n        feature provides: SafetyFunction;\n    }\n\n    part KeylessEntrySystem {\n        feature provides: SecurityFunction;\n    }\n\n    feature SafetyFunction {\n        description \"Enhances protection of driver and passengers during driving via seat belts, airbags, and bumpers.\";\n    }\n\n    feature SecurityFunction {\n        description \"Provides anti-theft and convenient access via alarm system and keyless entry system.\";\n    }\n}",
    "package InformationSecurityManagement {\n\n    enum SecurityClassificationLevel {\n        Unclassified,\n        Confidential,\n        Secret\n    }\n\n    part Component {\n        attribute classification: SecurityClassificationLevel;\n    }\n\n    requirement ClassifyAndLabelComponents {\n        text \"The system shall classify and label each component to meet information security management requirements.\"\n    }\n\n    requirement AssignSecurityClassificationLevel {\n        text \"Every component must be clearly assigned a security classification level, such as 'Unclassified,' 'Confidential,' or 'Secret.'\"\n    }\n\n    requirement RecognizeAndDisplayConfidentialClassification {\n        text \"When a component is marked as 'Confidential,' the system should be able to recognize and display its corresponding classification attribute, thereby enabling effective differentiation and protection of sensitive information during system operation and document management.\"\n    }\n\n    satisfy ClassifyAndLabelComponents by Component;\n    satisfy AssignSecurityClassificationLevel by Component.classification;\n    satisfy RecognizeAndDisplayConfidentialClassification by Component.classification;\n}",
    "package AutomotiveECUCommunicationSystem {\n\n    part VehicleControlUnit : VCU;\n    part EngineControlUnit : ECU;\n    part CANBus : CAN_Bus;\n\n    part VCU_BusIF : BusIF;\n    part ECU_BusIF : BusIF;\n\n    part VCU_SensorIF : SensorIF;\n    part ECU_SensorIF : SensorIF;\n\n    connect VehicleControlUnit.busPort to VCU_BusIF.unitPort;\n    connect VCU_BusIF.busPort to CANBus.nodePort[0];\n\n    connect EngineControlUnit.busPort to ECU_BusIF.unitPort;\n    connect ECU_BusIF.busPort to CANBus.nodePort[1];\n\n    connect VehicleControlUnit.sensorPort to VCU_SensorIF.unitPort;\n    connect EngineControlUnit.sensorPort to ECU_SensorIF.unitPort;\n\n}\n\nblock VCU {\n    port busPort : BusPort;\n    port sensorPort : SensorPort;\n}\n\nblock ECU {\n    port busPort : BusPort;\n    port sensorPort : SensorPort;\n}\n\nblock CAN_Bus {\n    port nodePort[2] : BusPort;\n}\n\nblock BusIF {\n    port unitPort : BusPort;\n    port busPort : BusPort;\n}\n\nblock SensorIF {\n    port unitPort : SensorPort;\n}\n\ninterface BusPort {\n    // Represents CAN bus communication interface\n}\n\ninterface SensorPort {\n    // Represents reserved sensor data interface\n}",
    "package BloodGlucoseMeterSystem {\n\n    requirement HighReliabilityAndSafety {\n        text \"The system shall ensure high reliability and safety of the blood glucose meter during use.\"\n    }\n\n    requirement BatteryStatusDetection {\n        text \"The system shall automatically detect the battery status when the battery is depleted or cannot be charged.\"\n    }\n\n    requirement UserAlertOnBatteryIssue {\n        text \"The system shall promptly alert the user to prevent failure to measure blood glucose levels due to battery issues.\"\n    }\n\n    requirement PreventiveMeasuresForBattery {\n        text \"The system shall implement preventive measures for battery status to prevent failure scenarios.\"\n    }\n\n    requirement AlarmAndEmergencyResponse {\n        text \"The system shall have appropriate alarm and emergency response mechanisms in case of abnormalities in the blood glucose measurement function.\"\n    }\n\n    requirement RiskManagement {\n        text \"The system requirements shall undergo rigorous approval, and management measures shall be established for key risk scenarios.\"\n    }\n\n    requirement ContinuousTherapeuticSupport {\n        text \"The system shall ensure that patients can receive timely, continuous, and safe therapeutic support under all circumstances.\"\n    }\n\n    satisfies HighReliabilityAndSafety\n    satisfies BatteryStatusDetection\n    satisfies UserAlertOnBatteryIssue\n    satisfies PreventiveMeasuresForBattery\n    satisfies AlarmAndEmergencyResponse\n    satisfies RiskManagement\n    satisfies ContinuousTherapeuticSupport\n\n}",
    "package ScientificConstantsSystem {\n\n    part system : System {\n        owns constantsLibrary : ConstantsLibrary\n    }\n\n    part ConstantsLibrary {\n        owns mathConstants : MathConstants\n        owns physicalConstants : PhysicalConstants\n        owns scenarioConstants : ScenarioConstants\n    }\n\n    part MathConstants {\n        attribute e : Real = 2.71828182845904523536\n        attribute pi : Real = 3.14159265358979323846\n    }\n\n    part PhysicalConstants {\n        attribute speedOfLight : Real = 299792458 [unit = \"m/s\"]\n        attribute fineStructureConstant : Real = 0.0072973525693\n        attribute electronToProtonMassRatio : Real = 0.000544617021487\n    }\n\n    part ScenarioConstants {\n        attribute standardGravitationalAcceleration : Real = 9.80665 [unit = \"m/s^2\"]\n        attribute amplifierGainCoefficient_ModelX : Real [unit = \"dimensionless\"]\n    }\n\n    requirement R1 {\n        text = \"The system shall provide standard and precise constants for scientific computing and simulation, including mathematical, physical, and scenario-based constants, with numerical precision up to 20 decimal places and clear SI unit annotations.\"\n    }\n\n    requirement R2 {\n        text = \"The system shall provide built-in mathematical constants e and pi with up to 20 decimal places.\"\n    }\n\n    requirement R3 {\n        text = \"The system shall provide physical constants: speed of light in vacuum, fine-structure constant, and electron-to-proton mass ratio, with SI unit annotations.\"\n    }\n\n    requirement R4 {\n        text = \"The system shall support scenario-based constants, such as standard gravitational acceleration on Earth and amplifier gain coefficient for Model X.\"\n    }\n\n    requirement R5 {\n        text = \"All constants shall be easily accessible and verifiable by the system.\"\n    }\n\n    satisfies system -> R1\n    satisfies mathConstants -> R2\n    satisfies physicalConstants -> R3\n    satisfies scenarioConstants -> R4\n    satisfies constantsLibrary -> R5\n\n}",
    "model AutomotiveComponentSpecification {\n\n   package TireSpecification {\n\n      type ManufacturerName : String;\n      type RimDiameter : Real;\n      type Width : Integer;\n\n      part Tire {\n         attribute manufacturer : ManufacturerName;\n         attribute rimDiameter : RimDiameter;\n         attribute width : Width;\n      }\n\n      instance MichelinTire : Tire {\n         manufacturer = \"Michelin\";\n         rimDiameter = 18.0;\n         width = 245;\n      }\n\n   }\n\n}",
    "model AutomotiveComponentModel {\n\n    import sysml::units::*;\n    import sysml::datatypes::*;\n\n    // Tire definition\n    part Tire {\n        // Additional tire properties can be added here\n    }\n\n    // Wheel definition\n    part Wheel {\n        attribute hubDiameter: Length = 18 * inch; // 18 inches\n        attribute width: Length = 245 * millimeter; // 245 mm\n        attribute tireHeight: Length; // To be specified per design\n\n        // Outer diameter is determined by hub diameter and tire height\n        attribute outerDiameter: Length = hubDiameter + (2 * tireHeight);\n\n        part tire: Tire;\n    }\n\n    // Vehicle definition\n    part Vehicle {\n        attribute mass: Mass = 1200 * kilogram; // 1200 kg\n        attribute length: Length = 4.82 * meter; // 4.82 m\n\n        // Front wheels: left and right\n        part frontLeftWheel: Wheel;\n        part frontRightWheel: Wheel;\n    }\n\n    // Top-level system definition\n    part AutomotiveComponent {\n        part vehicle: Vehicle;\n    }\n}",
    "model VehiclePowertrainConfig {\n\n    // Engine types\n    part type Engine {\n    }\n\n    part type FourCylinderEngine specializes Engine {\n    }\n\n    part type SixCylinderEngine specializes Engine {\n    }\n\n    // Transmission types\n    part type Transmission {\n    }\n\n    part type ManualTransmission specializes Transmission {\n    }\n\n    part type AutomaticTransmission specializes Transmission {\n    }\n\n    // Vehicle\n    part type Vehicle {\n        attribute isHighPerformance: Boolean;\n        part engine: Engine;\n        part transmission: Transmission;\n\n        constraint selectOneEngine {\n            (engine instanceOf FourCylinderEngine or engine instanceOf SixCylinderEngine)\n        }\n\n        constraint selectOneTransmission {\n            (transmission instanceOf ManualTransmission or transmission instanceOf AutomaticTransmission)\n        }\n\n        constraint highPerformanceEngine {\n            if isHighPerformance then\n                (engine instanceOf SixCylinderEngine)\n            else\n                (engine instanceOf FourCylinderEngine)\n        }\n\n        constraint validPowertrainCombinations {\n            ((engine instanceOf FourCylinderEngine and transmission instanceOf ManualTransmission) or\n             (engine instanceOf SixCylinderEngine and transmission instanceOf AutomaticTransmission))\n        }\n    }\n}",
    "model AutomotiveSystem {\n\n    part vehicle : Vehicle;\n\n}\n\nblock Vehicle {\n\n    attribute totalMass : kg = 1200;\n    attribute length : m = 4.82;\n\n    part wheelAssemblies : WheelAssembly[1..*];\n\n}\n\nblock WheelAssembly {\n\n    part wheels : Wheel[1..*];\n    part brakeDisc : BrakeDiscAssembly;\n\n    constraint brakeDiscDiameterLessThanWheelOuterDiameter {\n        brakeDisc.diameter < wheels[1].outerDiameter;\n    }\n\n    constraint fitmentRequirement {\n        brakeDisc.diameter < wheels[1].rim.diameter;\n    }\n\n}\n\nblock Wheel {\n\n    part rim : Rim;\n    part tire : Tire;\n\n    attribute outerDiameter : mm;\n\n    constraint calculateOuterDiameter {\n        outerDiameter = rim.diameter * 25.4 + 2 * tire.height;\n    }\n\n}\n\nblock Rim {\n\n    attribute diameter : in = 18;\n\n}\n\nblock Tire {\n\n    attribute width : mm = 245;\n    attribute height : mm = 45;\n    attribute treadDepth : mm = 6.0;\n\n    constraint treadDepthMinimum {\n        treadDepth >= 3.5;\n    }\n\n}\n\nblock BrakeDiscAssembly {\n\n    attribute radius : mm = 95;\n    attribute diameter : mm;\n\n    constraint calculateDiameter {\n        diameter = 2 * radius;\n    }\n\n}",
    "package AutomotiveFuelSystem {\n\n    part FuelSystem {\n        part fuelTankAssembly: FuelTankAssembly;\n        part fuelPump: FuelPump;\n        part fuelTank: FuelTank;\n        part engine: Engine;\n\n        interface fuelOutlet;\n        interface fuelReturn;\n\n        requirement FuelCirculation {\n            text \"Fuel shall circulate efficiently and safely among all components, meeting vehicle requirements for fuel supply and return, and ensuring normal fuel supply to the engine.\";\n        }\n\n        requirement FuelTemperatureMonitoring {\n            text \"The system shall monitor and transmit fuel temperature information.\";\n        }\n\n        satisfies FuelCirculation;\n        satisfies FuelTemperatureMonitoring;\n    }\n\n    part FuelTankAssembly {\n        interface outlet: fuelOutlet;\n        interface returnInlet: fuelReturn;\n\n        part fuelPump: FuelPump;\n        part fuelTank: FuelTank;\n\n        satisfies FuelTankAssemblyOutlet;\n    }\n\n    part FuelPump {\n        interface inlet: fuelReturn;\n        interface outlet: fuelOutlet;\n\n        satisfies FuelPumpSupply;\n        satisfies FuelPumpReturn;\n    }\n\n    part FuelTank {\n        interface outlet: fuelOutlet;\n        interface returnInlet: fuelReturn;\n    }\n\n    part Engine {\n        interface fuelInlet: fuelOutlet;\n        interface fuelReturn: fuelReturn;\n    }\n\n    requirement FuelTankAssemblyOutlet {\n        text \"The fuel tank assembly shall provide an outlet interface for fuel (including a return function), enabling delivery of fuel to the engine or other components, and reception of returned fuel.\";\n    }\n\n    requirement FuelPumpSupply {\n        text \"The fuel pump shall pump fuel from the fuel tank and supply it to the engine.\";\n    }\n\n    requirement FuelPumpReturn {\n        text \"The fuel pump shall be capable of receiving returned fuel.\";\n    }\n\n    connection FuelDelivery {\n        from FuelTankAssembly.outlet;\n        to Engine.fuelInlet;\n    }\n\n    connection FuelReturn {\n        from Engine.fuelReturn;\n        to FuelTankAssembly.returnInlet;\n    }\n\n    connection PumpToEngine {\n        from FuelPump.outlet;\n        to Engine.fuelInlet;\n    }\n\n    connection TankToPump {\n        from FuelTank.outlet;\n        to FuelPump.inlet;\n    }\n\n    connection ReturnToPump {\n        from FuelTankAssembly.returnInlet;\n        to FuelPump.inlet;\n    }\n\n    connection PumpToTank {\n        from FuelPump.outlet;\n        to FuelTank.outlet;\n    }\n\n    connection MonitorFuelTemperature {\n        from FuelSystem;\n        to FuelSystem;\n        description \"Monitors and transmits fuel temperature information.\";\n    }\n}",
    "package PhysicalQuantitySystem {\n\n    part system: System {\n        // The main system responsible for managing physical quantities and units\n    }\n\n    interface PhysicalQuantityManagement {\n        // Interface for supporting and managing data and units related to physical quantities\n        operation importPhysicalQuantity(quantity: PhysicalQuantity)\n        operation extendPhysicalQuantity(quantity: PhysicalQuantity)\n        operation convertUnit(quantity: PhysicalQuantity, fromUnit: Unit, toUnit: Unit): Real\n        operation ensureConsistency()\n        operation processQuantityData(data: QuantityData)\n    }\n\n    part isq: ISQ {\n        // International System of Quantities (ISQ) base quantities\n        part length: PhysicalQuantity\n        part mass: PhysicalQuantity\n        part time: PhysicalQuantity\n        part electricCurrent: PhysicalQuantity\n        part temperature: PhysicalQuantity\n        part amountOfSubstance: PhysicalQuantity\n        part luminousIntensity: PhysicalQuantity\n    }\n\n    part unitRepository: UnitRepository {\n        // Repository for units and unit conversion\n        operation addUnit(unit: Unit)\n        operation getUnit(name: String): Unit\n        operation convert(value: Real, fromUnit: Unit, toUnit: Unit): Real\n    }\n\n    part quantityDataProcessor: QuantityDataProcessor {\n        // Handles data processing for physical quantities\n        operation process(data: QuantityData)\n    }\n\n    part user: User {\n        // Represents users with diverse requirements\n        operation managePhysicalQuantitySystem(requirement: UserRequirement)\n    }\n\n    part physicalQuantitySystem: PhysicalQuantitySystem {\n        // Aggregates all parts and interfaces\n        ref system\n        ref isq\n        ref unitRepository\n        ref quantityDataProcessor\n        ref user\n        uses PhysicalQuantityManagement\n    }\n\n    type PhysicalQuantity {\n        attribute name: String\n        attribute value: Real\n        attribute unit: Unit\n    }\n\n    type Unit {\n        attribute name: String\n        attribute symbol: String\n        attribute conversionFactorToSI: Real\n    }\n\n    type QuantityData {\n        attribute quantities: PhysicalQuantity[]\n    }\n\n    type UserRequirement {\n        attribute description: String\n    }\n\n    type ISQ {\n        // Marker type for ISQ base quantities\n    }\n\n    type UnitRepository {\n        // Marker type for unit repository\n    }\n\n    type QuantityDataProcessor {\n        // Marker type for quantity data processor\n    }\n\n    type User {\n        // Marker type for user\n    }\n\n    type System {\n        // Marker type for the main system\n    }\n\n    type PhysicalQuantitySystem {\n        // Marker type for the overall physical quantity system\n    }\n}",
    "package UnitSystemLibrary {\n\n    part system: UnitSystemLibrarySystem;\n\n    part isq: ISQ;\n    part usCustomary: USCustomaryUnits;\n\n    part unitManager: UnitManager;\n    part unitConverter: UnitConverter;\n    part unitStandardizer: UnitStandardizer;\n\n    part user: User;\n\n    association system_has_isq {\n        end system: UnitSystemLibrarySystem;\n        end isq: ISQ;\n    }\n\n    association system_has_usCustomary {\n        end system: UnitSystemLibrarySystem;\n        end usCustomary: USCustomaryUnits;\n    }\n\n    association system_has_unitManager {\n        end system: UnitSystemLibrarySystem;\n        end unitManager: UnitManager;\n    }\n\n    association system_has_unitConverter {\n        end system: UnitSystemLibrarySystem;\n        end unitConverter: UnitConverter;\n    }\n\n    association system_has_unitStandardizer {\n        end system: UnitSystemLibrarySystem;\n        end unitStandardizer: UnitStandardizer;\n    }\n\n    association user_uses_system {\n        end user: User;\n        end system: UnitSystemLibrarySystem;\n    }\n\n    association unitManager_manages_units {\n        end unitManager: UnitManager;\n        end isq: ISQ;\n        end usCustomary: USCustomaryUnits;\n    }\n\n    association unitConverter_converts_between {\n        end unitConverter: UnitConverter;\n        end isq: ISQ;\n        end usCustomary: USCustomaryUnits;\n    }\n\n    association unitStandardizer_standardizes_units {\n        end unitStandardizer: UnitStandardizer;\n        end isq: ISQ;\n        end usCustomary: USCustomaryUnits;\n    }\n\n    requirement Interoperability {\n        text = \"The system shall support interoperability and adaptation between ISQ and USCustomaryUnits.\";\n    }\n\n    requirement UnitManagement {\n        text = \"The system shall enable users to manage, convert, and apply various units of physical quantities.\";\n    }\n\n    requirement AccuracyStandardization {\n        text = \"The system shall ensure accuracy and authoritative standardization of all unit types.\";\n    }\n\n    requirement MeasurementNeeds {\n        text = \"The system shall meet the measurement needs of engineering, scientific research, and daily life.\";\n    }\n\n    requirement EfficiencyReliability {\n        text = \"The system shall enhance the efficiency and reliability of data processing and communication.\";\n    }\n\n    satisfies system_satisfies_Interoperability {\n        subject system: UnitSystemLibrarySystem;\n        requirement Interoperability;\n    }\n\n    satisfies system_satisfies_UnitManagement {\n        subject system: UnitSystemLibrarySystem;\n        requirement UnitManagement;\n    }\n\n    satisfies system_satisfies_AccuracyStandardization {\n        subject system: UnitSystemLibrarySystem;\n        requirement AccuracyStandardization;\n    }\n\n    satisfies system_satisfies_MeasurementNeeds {\n        subject system: UnitSystemLibrarySystem;\n        requirement MeasurementNeeds;\n    }\n\n    satisfies system_satisfies_EfficiencyReliability {\n        subject system: UnitSystemLibrarySystem;\n        requirement EfficiencyReliability;\n    }\n\n    part physicalQuantity: PhysicalQuantity;\n\n    association isq_defines_physicalQuantities {\n        end isq: ISQ;\n        end physicalQuantity: PhysicalQuantity;\n    }\n\n    association usCustomary_defines_physicalQuantities {\n        end usCustomary: USCustomaryUnits;\n        end physicalQuantity: PhysicalQuantity;\n    }\n}",
    "package CarHeadlampTiltAdjustment {\n\n    import sysml::units;\n    import sysml::constraints;\n\n    unit deg : units::Angle = units::degree;\n\n    constant pi : Real = 3.141592653589793;\n    constant e : Real = 2.718281828459045;\n\n    interface HeadlampTiltAdjustmentKnob {\n        property beamTiltAngle : Real[unit=deg];\n    }\n\n    constraint HeadlampBeamTiltAngleRange {\n        input angle : Real[unit=deg];\n        assert angle >= 50.0 and angle <= 80.0;\n    }\n\n    requirement HeadlampBeamTiltAngleRequirement {\n        text \"The tilt angle of the headlamp beam (measured in degrees) must be between 50 degrees and 80 degrees; any value outside this range does not comply with safety and regulatory standards.\";\n        verify HeadlampBeamTiltAngleRange(angle => HeadlampTiltAdjustmentKnob.beamTiltAngle);\n    }\n\n    system CarHeadlampTiltAdjustmentSystem {\n        part knob : HeadlampTiltAdjustmentKnob;\n        satisfy HeadlampBeamTiltAngleRequirement;\n    }\n}",
    "model SystemDataTypes {\n\n    // Core Data Types\n    type UnsignedInteger {\n        constraint NonNegative: self >= 0;\n    }\n\n    type UnsignedFloat {\n        constraint NonNegative: self >= 0.0;\n    }\n\n    type DateTime;\n    type String;\n    type Boolean;\n\n    // Status Levels and Color Labeling\n    enum StatusLevel {\n        Critical,\n        Warning,\n        Normal\n    }\n\n    enum StatusColor {\n        Red,\n        Yellow,\n        Green\n    }\n\n    association StatusLevelToColor {\n        end statusLevel: StatusLevel;\n        end statusColor: StatusColor;\n        constraint Mapping: \n            (statusLevel == StatusLevel::Critical  and statusColor == StatusColor::Red) or\n            (statusLevel == StatusLevel::Warning   and statusColor == StatusColor::Yellow) or\n            (statusLevel == StatusLevel::Normal    and statusColor == StatusColor::Green);\n    }\n\n    // Physical Dimension: Diameter\n    enum DiameterOption {\n        Small,\n        Medium,\n        Large\n    }\n\n    type Diameter {\n        attribute value: UnsignedFloat;\n        attribute option: DiameterOption;\n        constraint OptionValueMapping:\n            (option == DiameterOption::Small  and value == 60.0) or\n            (option == DiameterOption::Medium and value == 70.0) or\n            (option == DiameterOption::Large  and value == 80.0);\n        default option = DiameterOption::Small;\n        default value = 60.0;\n    }\n\n    // System Data Type Container for Extensibility\n    type SystemDataType {\n        // Placeholder for future data types and extensions\n    }\n\n    // Value Constraint Enforcement\n    constraint AllUnsignedNonNegative:\n        // All UnsignedInteger and UnsignedFloat values must be non-negative\n        true; // Enforced by type constraints above\n\n    // Status-Color Association Logic\n    constraint StatusColorAssociation:\n        // Each status level is automatically associated with its color\n        true; // Enforced by StatusLevelToColor association\n\n}",
    "package SparePartsManagementSystem {\n\n   type Person;\n\n   part system : System;\n\n   block System {\n\n      // Spare parts managed as Bags\n      property spareParts : Bag<SparePart>;\n\n      // Personnel managed as OrderedSets\n      property personnel : OrderedSet<Person>;\n\n      // Integers managed as Lists\n      property integerLists : List<Integer>;\n\n      // Strings managed as Sets\n      property stringSets : Set<String>;\n\n      // Nested collection: List of Sets of Personnel\n      property personnelSetLists : List<Set<Person>>;\n\n      // Real numbers managed as fixed-length arrays (length 4)\n      property realArray : Array<Real>[4];\n\n      // Integration with business functions\n      property businessFunctions : Set<BusinessFunction>;\n\n      // Methods for flexible retrieval and use\n      operation retrieveSpareParts() : Bag<SparePart>;\n      operation retrievePersonnel() : OrderedSet<Person>;\n      operation retrieveIntegerLists() : List<Integer>;\n      operation retrieveStringSets() : Set<String>;\n      operation retrievePersonnelSetLists() : List<Set<Person>>;\n      operation retrieveRealArray() : Array<Real>[4];\n      operation interactWithBusinessFunction(bf : BusinessFunction);\n\n   }\n\n   type SparePart;\n\n   type BusinessFunction;\n\n}",
    "package TireInformationSystem {\n\n    import::sysml::units::*;\n    import::sysml::datatypes::*;\n\n    unit inch : LengthUnit;\n    \n    type ManufacturerName : String;\n    type RimDiameter : Real;\n    type TireWidth : Real;\n    type Coordinate3D : Tuple {\n        x : Real;\n        y : Real;\n        z : Real;\n    }\n\n    part Tire {\n        attribute manufacturer : ManufacturerName;\n        attribute rimDiameter : RimDiameter [unit=inch];\n        attribute width : TireWidth;\n        attribute installationPosition? : Coordinate3D;\n    }\n\n    part TireInformation {\n        attribute tires : Tire[0..*];\n    }\n}",
    "package SpacecraftAscentTrajectory {\n\n    import ScalarValues;\n    import SI;\n\n    type Time {\n        unit: SI::second;\n    }\n\n    type Position {\n        unit: SI::meter;\n        dimension: 3;\n    }\n\n    type Velocity {\n        unit: SI::meter_per_second;\n        dimension: 3;\n    }\n\n    part SpacecraftAscentTrajectoryRecorder {\n        attribute liftoffTimeUTC: String;\n        attribute referenceTimeZero: Time;\n        attribute trajectorySamples: TrajectorySampleSet;\n    }\n\n    part TrajectorySampleSet {\n        attribute samples: TrajectorySample[1..*];\n    }\n\n    part TrajectorySample {\n        attribute time: Time;\n        attribute position: Position;\n        attribute velocity: Velocity;\n    }\n\n    requirement RecordTrajectoryDuringAscent {\n        text \"The system shall sample and record the trajectory of the spacecraft during the ascent phase.\";\n        verify SpacecraftAscentTrajectoryRecorder;\n    }\n\n    requirement ReferenceTimeZero {\n        text \"The system shall use the mission liftoff time as the reference time zero, measured in seconds.\";\n        verify SpacecraftAscentTrajectoryRecorder.referenceTimeZero;\n    }\n\n    requirement AcceptLiftoffTimeUTC {\n        text \"The system shall be able to take the UTC liftoff time of the mission as the reference time.\";\n        verify SpacecraftAscentTrajectoryRecorder.liftoffTimeUTC;\n    }\n\n    requirement CollectKeyParameters {\n        text \"The system shall collect key parameters including the position and velocity of the spacecraft at different time points.\";\n        verify SpacecraftAscentTrajectoryRecorder.trajectorySamples.samples.position;\n        verify SpacecraftAscentTrajectoryRecorder.trajectorySamples.samples.velocity;\n    }\n\n    requirement AssociateTimeWithData {\n        text \"Each set of sampled data must associate a specific time point with the corresponding position and velocity data.\";\n        verify TrajectorySample;\n    }\n\n    requirement CartesianCoordinates {\n        text \"Both the three-dimensional position and velocity shall be described in a Cartesian coordinate system, with units of meters and meters per second, respectively.\";\n        verify Position;\n        verify Velocity;\n    }\n\n    requirement MultipleSamplingPoints {\n        text \"The system shall record multiple sampling points during the ascent phase, with each sampling point containing explicit information on time, position, and velocity.\";\n        verify TrajectorySampleSet.samples;\n    }\n\n    requirement DataSupportForAnalysis {\n        text \"The system shall provide accurate data support for subsequent trajectory analysis and performance evaluation.\";\n        verify SpacecraftAscentTrajectoryRecorder.trajectorySamples;\n    }\n}",
    "package MaterialsScienceAlloySystem {\n\n    unit Kilogram : si::kilogram;\n    unit Gram : si::gram;\n    unit Newton : si::newton;\n    unit SquareMillimeter : si::square_millimeter;\n    unit NewtonPerSquareMillimeter : si::newton / si::square_millimeter;\n\n    quantity AtomicMass {\n        unit : Kilogram;\n    }\n\n    quantity MassFraction {\n        unit : si::dimensionless;\n    }\n\n    quantity TensileStrength {\n        unit : NewtonPerSquareMillimeter;\n    }\n\n    type Substance {\n        property name : String;\n        property atomicMass : AtomicMass;\n    }\n\n    type Material specializes Substance {\n        // May include non-metallic materials\n    }\n\n    type Metal specializes Material {\n        // For metallic elements\n    }\n\n    type Alloy specializes Material {\n        property component : ComponentMaterial[2..*];\n        property tensileStrength : TensileStrength;\n    }\n\n    type ComponentMaterial {\n        property material : Material;\n        property massFraction : MassFraction;\n    }\n\n    instance Iron : Metal {\n        name = \"Iron\";\n        atomicMass = 55.845 * Gram;\n    }\n\n    instance Carbon : Metal {\n        name = \"Carbon\";\n        atomicMass = 12.011 * Gram;\n    }\n\n    instance Manganese : Metal {\n        name = \"Manganese\";\n        atomicMass = 54.938 * Gram;\n    }\n\n    instance Steel980 : Alloy {\n        name = \"Steel 980\";\n        component = { \n            ComponentMaterial {\n                material = Iron;\n                massFraction = 0.98;\n            },\n            ComponentMaterial {\n                material = Carbon;\n                massFraction = 0.015;\n            },\n            ComponentMaterial {\n                material = Manganese;\n                massFraction = 0.005;\n            }\n        };\n        tensileStrength = 980 * NewtonPerSquareMillimeter;\n    }\n}",
    "package EngineeringMaterialsDatabase {\n\n    part EngineeringMaterialsDatabaseSystem {\n        part materials: Material[0..*];\n        part users: User[0..*];\n    }\n\n    part User {\n        attribute name: String;\n    }\n\n    part Material {\n        attribute name: String;\n        attribute atomicMass: Real[0..1];\n        attribute compositionalInfo: CompositionalInformation[0..1];\n        attribute mechanicalProperties: MechanicalProperties[0..1];\n    }\n\n    part Metal extends Material {\n        attribute alloy: Boolean;\n        attribute detailedCompositionalInfo: DetailedCompositionalInformation[0..1];\n    }\n\n    part Alloy extends Metal {\n        attribute constituentMaterials: ConstituentMaterial[1..*];\n    }\n\n    part ConstituentMaterial {\n        attribute name: String;\n        attribute massFraction: Real; // e.g., 0.98 for 98%\n    }\n\n    part CompositionalInformation {\n        attribute description: String;\n    }\n\n    part DetailedCompositionalInformation {\n        part constituents: ConstituentMaterial[1..*];\n    }\n\n    part MechanicalProperties {\n        attribute tensileStrength: MechanicalPropertyIndicator[0..1];\n    }\n\n    part MechanicalPropertyIndicator {\n        attribute value: Real;\n        attribute unit: Unit;\n    }\n\n    part Unit {\n        attribute name: String;\n        attribute symbol: String;\n        attribute conversionFactorToSI: Real;\n    }\n\n    part Steel_980 extends Alloy {\n        attribute name = \"Steel_980\";\n        part constituents = {\n            ConstituentMaterial { name = \"Iron\"; massFraction = 0.97; },\n            ConstituentMaterial { name = \"Carbon\"; massFraction = 0.015; },\n            ConstituentMaterial { name = \"Manganese\"; massFraction = 0.015; }\n        };\n        part mechanicalProperties = MechanicalProperties {\n            tensileStrength = MechanicalPropertyIndicator {\n                value = 980;\n                unit = Unit { name = \"Newton per square millimeter\"; symbol = \"N/mm^2\"; conversionFactorToSI = 1.0e6; }\n            };\n        };\n    }\n}",
    "package PubSubSystem {\n\n    part system : System\n\n    block System {\n        part server : Server\n        part producers : Producer[1..*]\n        part consumers : Consumer[1..*]\n        part topics : Topic[1..*]\n    }\n\n    block Server {\n        part subscriptionManager : SubscriptionManager\n        part messageDistributor : MessageDistributor\n        port pubIn : MessagePublishPort\n        port subIn : SubscriptionRequestPort\n        port msgOut : MessageDeliveryPort\n    }\n\n    block Producer {\n        port publish : MessagePublishPort\n        reference topic : Topic\n    }\n\n    block Consumer {\n        port subscribe : SubscriptionRequestPort\n        port receive : MessageDeliveryPort\n        reference topic : Topic[1..*]\n    }\n\n    block Topic {\n        attribute name : String\n    }\n\n    block SubscriptionManager {\n        port subIn : SubscriptionRequestPort\n        reference topics : Topic[1..*]\n        reference consumers : Consumer[1..*]\n    }\n\n    block MessageDistributor {\n        port msgIn : MessagePublishPort\n        port msgOut : MessageDeliveryPort\n        reference topics : Topic[1..*]\n        reference consumers : Consumer[1..*]\n    }\n\n    interface MessagePublishPort {\n        in message : Message\n        in topic : Topic\n    }\n\n    interface SubscriptionRequestPort {\n        in topic : Topic\n        in consumer : Consumer\n    }\n\n    interface MessageDeliveryPort {\n        out message : Message\n        out topic : Topic\n    }\n\n    block Message {\n        attribute content : String\n        reference topic : Topic\n    }\n\n    constraint promptDelivery {\n        // When a producer publishes a message, the server promptly receives and distributes it to all subscribed consumers\n    }\n\n    constraint decoupledSubscription {\n        // Consumers subscribe to topics without knowledge of publishers or other subscribers\n    }\n\n    constraint efficientProcessing {\n        // The system efficiently manages subscription, publishing, and distribution flows\n    }\n\n    association ProducerPublishesToServer {\n        end producer : Producer\n        end server : Server\n        producer.publish -> server.pubIn\n    }\n\n    association ConsumerSubscribesToServer {\n        end consumer : Consumer\n        end server : Server\n        consumer.subscribe -> server.subIn\n    }\n\n    association ServerDeliversToConsumer {\n        end server : Server\n        end consumer : Consumer\n        server.msgOut -> consumer.receive\n    }\n\n    association ProducerReferencesTopic {\n        end producer : Producer\n        end topic : Topic\n        producer.topic -> topic\n    }\n\n    association ConsumerReferencesTopic {\n        end consumer : Consumer\n        end topic : Topic\n        consumer.topic -> topic\n    }\n\n}",
    "package VehicleFuelSystem {\n\n    part VehicleFuelSystem {\n        part fuelTank: FuelTankAssembly;\n        part engine: Engine;\n        part supplyLine: FuelLine;\n        part returnLine: FuelLine;\n        part tempMonitor: FuelTemperatureMonitor;\n\n        connect fuelTank.outlet to supplyLine.inlet;\n        connect supplyLine.outlet to engine.inlet;\n        connect engine.returnPort to returnLine.inlet;\n        connect returnLine.outlet to fuelTank.returnPort;\n        connect tempMonitor.sensorPort to supplyLine;\n        connect tempMonitor.transmitPort to VehicleFuelSystem;\n    }\n\n    part FuelTankAssembly {\n        port outlet: FuelPort;\n        port returnPort: FuelPort;\n        operation supplyFuel();\n        operation receiveReturnedFuel();\n    }\n\n    part Engine {\n        port inlet: FuelPort;\n        port returnPort: FuelPort;\n        operation combustFuel();\n        operation returnUnusedFuel();\n    }\n\n    part FuelLine {\n        port inlet: FuelPort;\n        port outlet: FuelPort;\n        operation transferFuel();\n    }\n\n    part FuelTemperatureMonitor {\n        port sensorPort: FuelLine;\n        port transmitPort: VehicleFuelSystem;\n        operation monitorTemperature();\n        operation transmitTemperatureData();\n    }\n\n    interface FuelPort {}\n\n}",
    "package PublishSubscribeSystem {\n\n    part system : PublishSubscribeArchitecture;\n\n    part def PublishSubscribeArchitecture {\n        part producers : Producer[1..*];\n        part server : Server;\n        part consumers : Consumer[1..*];\n    }\n\n    part def Producer {\n        operation publish(topic: Topic, message: Message) => (success: Boolean);\n    }\n\n    part def Consumer {\n        operation subscribe(topic: Topic) => (success: Boolean);\n        operation receive(message: Message);\n    }\n\n    part def Server {\n        operation receivePublish(producer: Producer, topic: Topic, message: Message);\n        operation receiveSubscribe(consumer: Consumer, topic: Topic);\n        operation deliverMessage(topic: Topic, message: Message);\n        part subscriptions : Subscription[0..*];\n    }\n\n    part def Subscription {\n        part topic : Topic;\n        part consumer : Consumer;\n    }\n\n    part def Topic {\n        attribute name : String;\n    }\n\n    part def Message {\n        attribute content : String;\n        part topic : Topic;\n    }\n\n    constraint ReliableDistribution {\n        // For every message published to a topic, all subscribed consumers receive the message\n        forall (m: Message, t: Topic, c: Consumer) \n            if (c subscribesTo t and m.topic = t) \n            then (c receives m);\n    }\n\n    constraint EfficientExchange {\n        // Information exchange between producers and consumers is efficient\n        // (Placeholder for efficiency constraint)\n        true;\n    }\n}",
    "package TransportationSystem {\n\n    part Vehicle {\n        attribute maxTankCapacity: Real;\n        attribute fuelLevel: Real;\n        attribute isOperating: Boolean;\n    }\n\n    part User {\n        attribute role: String; // \"driver\" or \"passenger\"\n    }\n\n    part Driver extends User {\n        attribute role: String = \"driver\";\n    }\n\n    part Passenger extends User {\n        attribute role: String = \"passenger\";\n    }\n\n    part GasStation {}\n\n    part Environment {\n        attribute factors: String;\n    }\n\n    part TransportationService {\n        part vehicle: Vehicle;\n        part driver: Driver;\n        part passengers: Passenger[0..4];\n        part environment: Environment;\n    }\n\n    action BoardVehicle {\n        input user: User;\n        input vehicle: Vehicle;\n        output boarded: Boolean;\n    }\n\n    action AlightVehicle {\n        input user: User;\n        input vehicle: Vehicle;\n        output alighted: Boolean;\n    }\n\n    action OperateVehicle {\n        input driver: Driver;\n        input vehicle: Vehicle;\n        input environment: Environment;\n        output travelCompleted: Boolean;\n    }\n\n    action RefuelVehicle {\n        input driver: Driver;\n        input vehicle: Vehicle;\n        input gasStation: GasStation;\n        output refueled: Boolean;\n    }\n\n    constraint FuelLow {\n        input vehicle: Vehicle;\n        output isLow: Boolean;\n        isLow = vehicle.fuelLevel < 0.1 * vehicle.maxTankCapacity;\n    }\n\n    scenario TransportationProcess {\n        part service: TransportationService;\n        // Boarding\n        BoardVehicle(user: service.driver, vehicle: service.vehicle);\n        for (p in service.passengers) {\n            BoardVehicle(user: p, vehicle: service.vehicle);\n        }\n        // Operation\n        while (not OperateVehicle(driver: service.driver, vehicle: service.vehicle, environment: service.environment).travelCompleted) {\n            if (FuelLow(vehicle: service.vehicle).isLow) {\n                RefuelVehicle(driver: service.driver, vehicle: service.vehicle, gasStation: GasStation{});\n            }\n            // Continue operation\n        }\n        // Alighting\n        for (p in service.passengers) {\n            AlightVehicle(user: p, vehicle: service.vehicle);\n        }\n        AlightVehicle(user: service.driver, vehicle: service.vehicle);\n    }\n}",
    "system FuelSupplyReturnManagementSystem {\n    part fuelTank: FuelTankAssembly;\n    part engine: EngineUnit;\n\n    connector fuelSupplyConnection: FuelInterface {\n        end tankPort: fuelTank.fuelOutletPort;\n        end enginePort: engine.fuelInletPort;\n    }\n\n    connector fuelReturnConnection: FuelInterface {\n        end enginePort: engine.fuelReturnPort;\n        end tankPort: fuelTank.fuelReturnPort;\n    }\n\n    requirement ContinuousReliableFuelSupply {\n        text \"The system shall ensure that the vehicle engine can continuously and reliably obtain the required fuel.\";\n    }\n\n    requirement FuelReturnProcessing {\n        text \"The system shall support fuel return processing from the engine to the fuel tank.\";\n    }\n\n    requirement RealTimeFuelParameterMonitoring {\n        text \"The system shall monitor relevant fuel parameters, including fuel temperature, in real time during both supply and return processes.\";\n    }\n\n    requirement EfficientFuelCirculation {\n        text \"The system shall enable efficient fuel circulation to improve intelligence and safety of vehicle fuel management.\";\n    }\n}\n\nblock FuelTankAssembly {\n    port fuelOutletPort: FuelPort;\n    port fuelReturnPort: FuelPort;\n}\n\nblock EngineUnit {\n    port fuelInletPort: FuelPort;\n    port fuelReturnPort: FuelPort;\n}\n\ninterface FuelInterface {\n    feature flowDirection: FlowDirection;\n}\n\nblock FuelPort {\n    attribute fuelTemperature: Real;\n}\n\nenum FlowDirection {\n    forward;\n    reverse;\n}",
    "package VehicleFuelSystem {\n\n    part VehicleFuelSystemManagementSystem {\n        part fuelTankAssembly: FuelTankAssembly;\n        part engine: Engine;\n\n        connector fuelSupply: FuelFlowConnector {\n            end source: fuelTankAssembly.supplyPort;\n            end target: engine.supplyPort;\n        }\n\n        connector fuelReturn: FuelFlowConnector {\n            end source: engine.returnPort;\n            end target: fuelTankAssembly.returnPort;\n        }\n    }\n\n    part FuelTankAssembly {\n        port supplyPort: FuelInterface;\n        port returnPort: FuelInterface;\n    }\n\n    part Engine {\n        port supplyPort: FuelInterface;\n        port returnPort: FuelInterface;\n    }\n\n    interface FuelInterface {\n        flow property fuelFlow: Fuel;\n        property fuelTemperature: Temperature;\n    }\n\n    part FuelFlowConnector {\n        end source: FuelInterface;\n        end target: FuelInterface;\n    }\n\n    type Fuel {\n        property massFlowRate: MassFlowRate;\n        property pressure: Pressure;\n    }\n\n    type Temperature {\n        property value: Real;\n        property unit: String;\n    }\n\n    type MassFlowRate {\n        property value: Real;\n        property unit: String;\n    }\n\n    type Pressure {\n        property value: Real;\n        property unit: String;\n    }\n\n    requirement EfficientFuelSupplyAndReturn {\n        text \"The system shall achieve efficient supply and return of fuel between the Fuel Tank Assembly and the Engine.\";\n    }\n\n    requirement FuelTemperatureMonitoring {\n        text \"Each fuel interface shall provide current temperature information of the fuel for monitoring and regulation.\";\n    }\n\n    requirement ReliableAndSafeOperation {\n        text \"The system shall ensure reliable, safe, and monitored fuel delivery during normal vehicle operation.\";\n    }\n}",
    "package PhotoCaptureSystem {\n\n    part User;\n    part Scene;\n    part PhotoCaptureSystem;\n\n    interface SelectScene {\n        in User user;\n        in Scene scene;\n        out Boolean sceneSelected;\n    }\n\n    interface AutoFocus {\n        in Scene scene;\n        out Image focusedImage;\n    }\n\n    interface CapturePhoto {\n        in Image focusedImage;\n        out Photo finalPhoto;\n    }\n\n    interface ObtainPhoto {\n        in User user;\n        in Photo finalPhoto;\n        out Boolean photoObtained;\n    }\n\n    part Image;\n    part Photo;\n\n    action SelectSceneAction {\n        input User user;\n        input Scene scene;\n        output Boolean sceneSelected;\n        do SelectScene(user, scene) -> sceneSelected;\n    }\n\n    action AutoFocusAction {\n        input Scene scene;\n        output Image focusedImage;\n        do AutoFocus(scene) -> focusedImage;\n    }\n\n    action CapturePhotoAction {\n        input Image focusedImage;\n        output Photo finalPhoto;\n        do CapturePhoto(focusedImage) -> finalPhoto;\n    }\n\n    action ObtainPhotoAction {\n        input User user;\n        input Photo finalPhoto;\n        output Boolean photoObtained;\n        do ObtainPhoto(user, finalPhoto) -> photoObtained;\n    }\n\n    behavior PhotoAcquisitionProcess {\n        input User user;\n        input Scene scene;\n        output Photo finalPhoto;\n        output Boolean photoObtained;\n\n        do {\n            Boolean sceneSelected;\n            Image focusedImage;\n\n            SelectSceneAction(user, scene) -> sceneSelected;\n            AutoFocusAction(scene) -> focusedImage;\n            CapturePhotoAction(focusedImage) -> finalPhoto;\n            ObtainPhotoAction(user, finalPhoto) -> photoObtained;\n        }\n    }\n\n    requirement R1 {\n        text \"The system shall enable users to obtain photos from real-world scenes.\";\n    }\n\n    requirement R2 {\n        text \"After a user selects a scene, the system shall automatically perform focusing for the selected scene and generate an intermediate image.\";\n    }\n\n    requirement R3 {\n        text \"Based on the focused image, the system shall capture and output the final photo.\";\n    }\n\n    requirement R4 {\n        text \"Users shall be able to directly obtain photos that meet their requirements from the selected scene, while the system completes the focusing and shooting processes automatically in the background, without requiring manual intervention at each step.\";\n    }\n\n    satisfies PhotoCaptureSystem -> R1, R2, R3, R4;\n    realizes PhotoAcquisitionProcess -> R1, R2, R3, R4;\n}",
    "package PhotographyWorkflow {\n\n    part system : System;\n\n    part user : User;\n\n    part scene : Scene;\n\n    part intermediateImage : Image;\n\n    part finalImage : Image;\n\n    action Focusing {\n        input scene : Scene;\n        output intermediateImage : Image;\n        precondition scene.isSelected;\n        postcondition intermediateImage.isFocused;\n    }\n\n    action Shooting {\n        input intermediateImage : Image;\n        output finalImage : Image;\n        precondition intermediateImage.isFocused;\n        postcondition finalImage.isProduced;\n    }\n\n    action SelectScene {\n        input user : User;\n        output scene : Scene;\n        postcondition scene.isSelected;\n    }\n\n    workflow PhotographyProcess {\n        step selectScene : SelectScene;\n        step focusing : Focusing;\n        step shooting : Shooting;\n\n        flow {\n            selectScene.output -> focusing.input;\n            focusing.output -> shooting.input;\n            shooting.output -> system.finalImage;\n        }\n\n        constraint {\n            focusing.precondition;\n            shooting.precondition;\n        }\n    }\n\n    requirement R1 \"The system shall enable the user to select or set a scene to be photographed.\";\n\n    requirement R2 \"The system shall automatically perform focusing on the selected scene and generate an intermediate image.\";\n\n    requirement R3 \"The system shall carry out the shooting operation based on the focused image, outputting the final photograph.\";\n\n    requirement R4 \"The workflow shall be completed sequentially through the steps of Focusing and Shooting.\";\n\n    requirement R5 \"The system shall ensure that the image is clearly focused before shooting.\";\n\n    requirement R6 \"The system shall produce high-quality photo output.\";\n\n    satisfy R1 by SelectScene;\n\n    satisfy R2 by Focusing;\n\n    satisfy R3 by Shooting;\n\n    satisfy R4 by PhotographyProcess;\n\n    satisfy R5 by Shooting.precondition;\n\n    satisfy R6 by Shooting.postcondition;\n\n}",
    "package PhotographyWorkflow {\n\n    part User\n    part PhotographySystem\n\n    interface Scene\n    interface Image\n    interface Photograph\n\n    action SelectScene {\n        in user: User\n        out scene: Scene\n    }\n\n    action FocusScene {\n        in scene: Scene\n        out image: Image\n    }\n\n    action ShootImage {\n        in image: Image\n        out photograph: Photograph\n    }\n\n    workflow PhotographyWorkflow {\n        input user: User\n        output photograph: Photograph\n\n        step selectScene: SelectScene {\n            user = input.user\n        }\n        step focusScene: FocusScene {\n            scene = selectScene.scene\n        }\n        step shootImage: ShootImage {\n            image = focusScene.image\n        }\n\n        output.photograph = shootImage.photograph\n    }\n\n    requirement SupportPhotographyWorkflow {\n        text \"The system shall support photography workflows, allowing users to frame and capture a scene.\"\n    }\n\n    requirement AutomaticFocusingAndShooting {\n        text \"The system shall automatically perform focusing and shooting steps to generate high-quality photographs from selected scenes.\"\n    }\n\n    requirement NoManualImageProcessing {\n        text \"The system shall not require users to manually handle intermediate image processing and conversion tasks.\"\n    }\n\n    satisfies PhotographySystem -> SupportPhotographyWorkflow\n    satisfies PhotographySystem -> AutomaticFocusingAndShooting\n    satisfies PhotographySystem -> NoManualImageProcessing\n\n}",
    "package PhotographyAutomation {\n\n    part User {\n    }\n\n    part PhotographySystem {\n        part SceneInput;\n        part FocusProcessor;\n        part ImageGenerator;\n        part ShootingOperator;\n        part PhotographOutput;\n    }\n\n    requirement AutomatePhotographyProcess {\n        text \"The system shall automate the photography process, requiring only a shooting scene from the user.\"\n    }\n\n    requirement FocusProcessing {\n        text \"The system shall perform focus processing on the provided scene to generate an image suitable for shooting.\"\n    }\n\n    requirement ShootingOperation {\n        text \"The system shall convert the generated image into a photograph through a shooting operation.\"\n    }\n\n    requirement SeamlessIntegration {\n        text \"The system shall integrate focus processing and shooting operation seamlessly, requiring no in-depth user intervention.\"\n    }\n\n    requirement SimplifiedWorkflow {\n        text \"The system shall simplify the photography workflow, enabling users to obtain the final photograph easily and efficiently.\"\n    }\n\n    interface ProvideScene {\n        in parameter scene;\n    }\n\n    interface OutputPhotograph {\n        out parameter photograph;\n    }\n\n    PhotographySystem {\n        input ProvideScene;\n        output OutputPhotograph;\n        part SceneInput;\n        part FocusProcessor;\n        part ImageGenerator;\n        part ShootingOperator;\n        part PhotographOutput;\n    }\n\n    User {\n        output ProvideScene;\n        input OutputPhotograph;\n    }\n\n    constraint NoUserIntervention {\n        text \"User intervention is not required for focus processing or shooting operation details.\"\n    }\n\n    satisfies PhotographySystem -> AutomatePhotographyProcess;\n    satisfies PhotographySystem -> FocusProcessing;\n    satisfies PhotographySystem -> ShootingOperation;\n    satisfies PhotographySystem -> SeamlessIntegration;\n    satisfies PhotographySystem -> SimplifiedWorkflow;\n    satisfies PhotographySystem -> NoUserIntervention;\n\n    flow {\n        User.ProvideScene -> PhotographySystem.SceneInput;\n        PhotographySystem.SceneInput -> PhotographySystem.FocusProcessor;\n        PhotographySystem.FocusProcessor -> PhotographySystem.ImageGenerator;\n        PhotographySystem.ImageGenerator -> PhotographySystem.ShootingOperator;\n        PhotographySystem.ShootingOperator -> PhotographySystem.PhotographOutput;\n        PhotographySystem.PhotographOutput -> User.OutputPhotograph;\n    }\n}",
    "package PhotographyWorkflow {\n\n    part User {\n    }\n\n    part PhotographyWorkflow {\n        part Focus {\n            input: Scene;\n            output: Image;\n        }\n        part Shoot {\n            input: Image;\n            output: Picture;\n        }\n        input: Scene;\n        output: Picture;\n    }\n\n    part Scene {\n    }\n\n    part Image {\n    }\n\n    part Picture {\n    }\n\n    requirement AutomatedPhotographyWorkflow {\n        text: \"Users can complete the entire photography process—from composition to imaging to photo output—through the PhotographyWorkflow software. Users only need to input the desired scene; the system automatically focuses, images, and outputs the required photograph.\"\n    }\n\n    satisfies PhotographyWorkflow -> AutomatedPhotographyWorkflow;\n\n    association UserToWorkflow {\n        end user: User;\n        end workflow: PhotographyWorkflow;\n    }\n\n    association WorkflowToScene {\n        end workflow: PhotographyWorkflow;\n        end scene: Scene;\n    }\n\n    association WorkflowToPicture {\n        end workflow: PhotographyWorkflow;\n        end picture: Picture;\n    }\n}",
    "package PhotographyWorkflow {\n\n    part User\n    part Camera\n    part Scene\n    part Photograph\n\n    interface SelectScene {\n        in User user\n        out Scene scene\n    }\n\n    interface FocusScene {\n        in Scene scene\n        out Boolean focusClear\n    }\n\n    interface CapturePhoto {\n        in Boolean focusClear\n        out Photograph photo\n    }\n\n    action PhotographyWorkflowProcess {\n        input User user\n        output Photograph photo\n\n        step selectScene: SelectScene {\n            user -> user\n            scene -> scene\n        }\n\n        step focusScene: FocusScene {\n            scene -> selectScene.scene\n            focusClear -> focusClear\n        }\n\n        step capturePhoto: CapturePhoto {\n            focusClear -> focusScene.focusClear\n            photo -> photo\n        }\n\n        constraint sequence {\n            selectScene precedes focusScene\n            focusScene precedes capturePhoto\n        }\n\n        constraint focusRequired {\n            capturePhoto.focusClear = true\n        }\n    }\n\n    requirement R1 {\n        text \"The system shall allow users to select a scene and capture it as a photograph.\"\n    }\n\n    requirement R2 {\n        text \"The system shall focus the selected scene before capturing the photograph to ensure optimal image sharpness.\"\n    }\n\n    requirement R3 {\n        text \"The system shall only capture the photograph if the focus is clear.\"\n    }\n\n    requirement R4 {\n        text \"The system shall perform focusing and shooting operations automatically in sequence.\"\n    }\n\n    requirement R5 {\n        text \"The system shall provide a one-click shooting experience ensuring clarity and quality of photos.\"\n    }\n\n    satisfies PhotographyWorkflowProcess -> R1\n    satisfies PhotographyWorkflowProcess -> R2\n    satisfies PhotographyWorkflowProcess -> R3\n    satisfies PhotographyWorkflowProcess -> R4\n    satisfies PhotographyWorkflowProcess -> R5\n}",
    "package PhotographWorkflow {\n\n    part User;\n    part Scene;\n    part FocusedImage;\n    part Photograph;\n    part Photo;\n\n    interface SceneInput {\n        in User user;\n        out Scene scene;\n    }\n\n    interface FocusOperation {\n        in Scene scene;\n        out FocusedImage focusedImage;\n    }\n\n    interface FocusQualityEvaluation {\n        in FocusedImage focusedImage;\n        out Boolean isWellFocused;\n    }\n\n    interface ShootingOperation {\n        in FocusedImage focusedImage;\n        out Photograph photograph;\n    }\n\n    interface PhotoOutput {\n        in Photograph photograph;\n        out Photo photo;\n    }\n\n    activity PhotographWorkflowProcess {\n        input User user;\n        output Photo photo;\n\n        action selectScene {\n            input User user;\n            output Scene scene;\n            call SceneInput(user: user, scene: scene);\n        }\n\n        action performFocusing {\n            input Scene scene;\n            output FocusedImage focusedImage;\n            call FocusOperation(scene: scene, focusedImage: focusedImage);\n        }\n\n        action evaluateFocus {\n            input FocusedImage focusedImage;\n            output Boolean isWellFocused;\n            call FocusQualityEvaluation(focusedImage: focusedImage, isWellFocused: isWellFocused);\n        }\n\n        action performShooting {\n            input FocusedImage focusedImage;\n            output Photograph photograph;\n            call ShootingOperation(focusedImage: focusedImage, photograph: photograph);\n        }\n\n        action outputPhoto {\n            input Photograph photograph;\n            output Photo photo;\n            call PhotoOutput(photograph: photograph, photo: photo);\n        }\n\n        flow {\n            selectScene.user = user;\n            performFocusing.scene = selectScene.scene;\n            evaluateFocus.focusedImage = performFocusing.focusedImage;\n            if evaluateFocus.isWellFocused {\n                performShooting.focusedImage = performFocusing.focusedImage;\n                outputPhoto.photograph = performShooting.photograph;\n                photo = outputPhoto.photo;\n            }\n        }\n    }\n}",
    "system PhotographyWorkflowSystem {\n\n    part user : User;\n    part camera : Camera;\n    part display : Display;\n\n    operation takePhoto();\n\n    behavior workflow {\n        start {\n            user -> camera.takePhoto();\n        }\n        step1 {\n            camera.acquireScene();\n        }\n        step2 {\n            camera.focus(scene);\n        }\n        step3 {\n            camera.shoot(focusedImage);\n        }\n        step4 {\n            camera.displayPhoto(photo);\n        }\n        finish {\n            display.show(photo);\n        }\n        flow {\n            start -> step1;\n            step1 -> step2;\n            step2 -> step3;\n            step3 -> step4;\n            step4 -> finish;\n        }\n    }\n}\n\nblock User {\n    operation triggerTakePhoto();\n}\n\nblock Camera {\n    operation takePhoto();\n    operation acquireScene() returns Scene;\n    operation focus(scene: Scene) returns FocusedImage;\n    operation shoot(focusedImage: FocusedImage) returns Photo;\n    operation displayPhoto(photo: Photo);\n}\n\nblock Display {\n    operation show(photo: Photo);\n}\n\ntype Scene;\ntype FocusedImage;\ntype Photo;",
    "system AutomaticBrakingControlSystem {\n    \n    part vehicle : Vehicle;\n    part brakePedal : BrakePedal;\n    part brakePressureSensor : BrakePressureSensor;\n    part tractionSensor : TractionSensor;\n    part brakeActuator : BrakeActuator;\n    part controlUnit : BrakingControlUnit;\n\n    requirement automaticActivation {\n        text \"When the user turns the vehicle key to the start position, the system is automatically activated.\";\n    }\n\n    requirement continuousMonitoring {\n        text \"The system continuously monitors the status of the brake pedal and traction information such as road adhesion.\";\n    }\n\n    requirement intelligentAdjustment {\n        text \"The system detects brake pressure generated by the driver and evaluates traction variations to intelligently adjust brake pressure and modulation frequency.\";\n    }\n\n    requirement safeReliableBraking {\n        text \"The system ensures safe and reliable braking performance under various operating conditions.\";\n    }\n\n    requirement automaticRegulation {\n        text \"The process is automatically monitored and dynamically regulated without user intervention, ensuring optimal braking system operation.\";\n    }\n\n    interface BrakePedalStatus {\n        out status : Boolean;\n    }\n\n    interface BrakePressure {\n        out pressure : Real;\n    }\n\n    interface TractionInfo {\n        out adhesion : Real;\n    }\n\n    interface BrakeControlCommand {\n        in pressureSetpoint : Real;\n        in modulationFrequency : Real;\n    }\n\n    brakePedal provides BrakePedalStatus;\n    brakePressureSensor provides BrakePressure;\n    tractionSensor provides TractionInfo;\n    brakeActuator provides BrakeControlCommand;\n\n    controlUnit uses BrakePedalStatus;\n    controlUnit uses BrakePressure;\n    controlUnit uses TractionInfo;\n    controlUnit controls BrakeControlCommand;\n\n    constraint optimalBrakingOperation {\n        text \"Braking system operates in optimal state by dynamically adjusting brake pressure and modulation frequency based on brake pedal status and traction information.\";\n    }\n}",
    "package BatteryChargingControlSystem {\n\n    part BatteryChargingControlSystem {\n        part battery: Battery;\n        part charger: Charger;\n        part controller: ChargingController;\n    }\n\n    part Battery {\n        attribute capacity: Percentage;\n        attribute isFullyCharged: Boolean;\n    }\n\n    part Charger {\n        attribute isSupplyingCharge: Boolean;\n        operation supplyCharge();\n        operation stopCharge();\n    }\n\n    part ChargingController {\n        reference battery: Battery;\n        reference charger: Charger;\n\n        operation monitorBatteryLevel();\n        operation controlCharging();\n    }\n\n    requirement SafeEfficientFullCharge {\n        text \"The system shall ensure the battery is safely and efficiently fully charged.\";\n    }\n\n    requirement RealTimeMonitoring {\n        text \"The system shall monitor the current battery level in real time.\";\n    }\n\n    requirement AutomaticCharging {\n        text \"The system shall automatically supply charge when the battery level is below 100%.\";\n    }\n\n    requirement AutomaticTermination {\n        text \"The system shall automatically terminate charging when the battery level reaches or exceeds 100%.\";\n    }\n\n    requirement NoManualIntervention {\n        text \"The system shall operate without manual intervention.\";\n    }\n\n    requirement HealthyCharging {\n        text \"The system shall ensure healthy charging of the battery.\";\n    }\n\n    requirement EnhancedConvenienceSafety {\n        text \"The system shall enhance convenience and safety of use.\";\n    }\n\n    function monitorBatteryCapacity() {\n        input battery: Battery;\n        output capacity: Percentage;\n    }\n\n    function automaticChargeControl() {\n        input battery: Battery;\n        input charger: Charger;\n        precondition battery.capacity < 100;\n        effect charger.supplyCharge();\n        postcondition battery.capacity increases;\n    }\n\n    function terminateCharging() {\n        input battery: Battery;\n        input charger: Charger;\n        precondition battery.capacity >= 100;\n        effect charger.stopCharge();\n        postcondition charger.isSupplyingCharge == false;\n    }\n}",
    "package BatteryChargingSystem {\n\n    part battery : Battery;\n    part charger : Charger;\n    part monitor : BatteryMonitor;\n    part controller : ChargingController;\n\n    interface BatteryLevelProvider {\n        property batteryLevel : Percentage;\n    }\n\n    interface ChargingControl {\n        operation startCharging();\n        operation stopCharging();\n    }\n\n    type Percentage {\n        property value : Real;\n        constraint [0.0 <= value and value <= 100.0];\n    }\n\n    part Battery {\n        property level : Percentage;\n    }\n\n    part Charger {\n        operation replenish();\n    }\n\n    part BatteryMonitor implements BatteryLevelProvider {\n        ref battery : Battery;\n        property batteryLevel : Percentage = battery.level;\n    }\n\n    part ChargingController implements ChargingControl {\n        ref monitor : BatteryMonitor;\n        ref charger : Charger;\n        ref battery : Battery;\n\n        stateMachine ChargingProcess {\n            state Idle {\n                transition to Charging when startCharging();\n            }\n            state Charging {\n                entry / charger.replenish();\n                transition to Terminated when monitor.batteryLevel.value >= 100.0;\n                transition to Charging when monitor.batteryLevel.value < 100.0;\n            }\n            state Terminated {\n                entry / stopCharging();\n            }\n            initial Idle;\n        }\n    }\n\n    requirement ContinuousMonitoring {\n        text \"The system shall continuously monitor the battery level during charging.\";\n    }\n\n    requirement AutomaticReplenishment {\n        text \"If the battery level is below 100%, the system shall automatically replenish the battery.\";\n    }\n\n    requirement TerminateAtFullCharge {\n        text \"The system shall terminate charging when the battery level reaches or exceeds 100%.\";\n    }\n\n    requirement FullyAutomated {\n        text \"The charging operation shall be fully automated, requiring no manual intervention.\";\n    }\n\n    requirement PreventOvercharging {\n        text \"The system shall prevent overcharging and ensure the battery is safely and reliably fully charged.\";\n    }\n\n    satisfy ContinuousMonitoring by monitor;\n    satisfy AutomaticReplenishment by controller;\n    satisfy TerminateAtFullCharge by controller;\n    satisfy FullyAutomated by controller;\n    satisfy PreventOvercharging by controller;\n\n}",
    "system CameraSystem {\n    part user: User;\n    part autofocus: AutofocusSubsystem;\n    part imaging: ImagingSubsystem;\n    part storage: PhotoStorage;\n    \n    interface selectScene;\n    interface confirmScene;\n    interface photoReady;\n    interface photoSaved;\n    \n    connection userSelectsScene {\n        from user.selectScene;\n        to autofocus.receiveSceneSelection;\n    }\n    connection autofocusToImaging {\n        from autofocus.imageReady;\n        to imaging.receiveFocusedImage;\n    }\n    connection imagingToStorage {\n        from imaging.photoCaptured;\n        to storage.savePhoto;\n    }\n    connection storageToUser {\n        from storage.photoSaved;\n        to user.photoReady;\n    }\n}\n\nblock User {\n    operation selectScene();\n    operation confirmScene();\n    reception photoReady();\n}\n\nblock AutofocusSubsystem {\n    reception receiveSceneSelection();\n    operation performAutofocus();\n    event imageReady();\n}\n\nblock ImagingSubsystem {\n    reception receiveFocusedImage();\n    operation capturePhoto();\n    event photoCaptured();\n}\n\nblock PhotoStorage {\n    reception savePhoto();\n    event photoSaved();\n}",
    "system ShootingCamera {\n    \n    part user: User;\n    part camera: Camera;\n\n    interface ShootingInterface {\n        operation selectScene(scene: Scene);\n        operation receivePhoto(photo: Photo);\n    }\n\n    part userInterface: UserInterface {\n        provides ShootingInterface;\n    }\n\n    part imagingModule: ImagingModule;\n    part focusModule: FocusModule;\n    part sceneRecognitionModule: SceneRecognitionModule;\n    part controlModule: ControlModule;\n\n    part photoStorage: PhotoStorage;\n\n    association userToUI between user and userInterface;\n    association cameraToUI between camera and userInterface;\n    association cameraToImaging between camera and imagingModule;\n    association cameraToFocus between camera and focusModule;\n    association cameraToSceneRecognition between camera and sceneRecognitionModule;\n    association cameraToControl between camera and controlModule;\n    association cameraToStorage between camera and photoStorage;\n\n    behavior ShootingProcess {\n        input scene: Scene;\n        output photo: Photo;\n\n        step userSelectsScene {\n            action userInterface.selectScene(scene);\n        }\n        step recognizeScene {\n            action sceneRecognitionModule.recognize(scene);\n        }\n        step autoFocus {\n            action focusModule.autoFocus(scene);\n        }\n        step captureImage {\n            action imagingModule.capture();\n        }\n        step storePhoto {\n            action photoStorage.store(photo);\n        }\n        step deliverPhoto {\n            action userInterface.receivePhoto(photo);\n        }\n\n        flow userSelectsScene -> recognizeScene -> autoFocus -> captureImage -> storePhoto -> deliverPhoto;\n    }\n\n    requirement AutomatedShooting {\n        text \"The camera shall enable users to complete the entire shooting process from viewfinding and focusing to imaging with a single, simple operation.\"\n    }\n\n    requirement SceneSelection {\n        text \"Users shall only need to select the shooting scene; the camera shall automatically focus and generate an image that meets the requirements.\"\n    }\n\n    requirement FullAutomation {\n        text \"The entire shooting process shall be fully automated without the need for users to manually adjust the focus or initiate imaging.\"\n    }\n\n    requirement ModuleCollaboration {\n        text \"All functional modules shall collaborate to complete the process of shooting and image acquisition, ensuring efficiency and convenience.\"\n    }\n\n    requirement HighQualityOutput {\n        text \"The system shall output high-quality photos.\"\n    }\n}\n\nblock User {}\nblock Camera {}\nblock UserInterface {}\nblock ImagingModule {\n    operation capture();\n}\nblock FocusModule {\n    operation autoFocus(scene: Scene);\n}\nblock SceneRecognitionModule {\n    operation recognize(scene: Scene);\n}\nblock ControlModule {}\nblock PhotoStorage {\n    operation store(photo: Photo);\n}\nblock Scene {}\nblock Photo {}",
    "package VehicleSimulation {\n\n    part vehicle : Vehicle;\n\n    part simulation : Simulation;\n\n    part user : User;\n\n    interface UserInput {\n        property mass : Real;\n        property initialPosition : Real;\n        property initialVelocity : Real;\n        property timeStep : Real;\n        property powerInputSequence : Sequence<Real>;\n    }\n\n    interface SimulationOutput {\n        property positionTrajectory : Sequence<Real>;\n    }\n\n    block Vehicle {\n        property mass : Real;\n        property position : Real;\n        property velocity : Real;\n    }\n\n    block Simulation {\n        property timeStep : Real;\n        property powerInputSequence : Sequence<Real>;\n        property positionTrajectory : Sequence<Real>;\n        property initialPosition : Real;\n        property initialVelocity : Real;\n        property mass : Real;\n\n        operation simulate() : Sequence<Real>;\n    }\n\n    block User {\n        property input : UserInput;\n        property output : SimulationOutput;\n    }\n\n    constraint PowerToAcceleration {\n        input mass : Real;\n        input velocity : Real;\n        input power : Real;\n        output acceleration : Real;\n        expression: acceleration = if velocity != 0 then power / (mass * velocity) else 0;\n    }\n\n    constraint UpdateVelocity {\n        input velocity : Real;\n        input acceleration : Real;\n        input timeStep : Real;\n        output newVelocity : Real;\n        expression: newVelocity = velocity + acceleration * timeStep;\n    }\n\n    constraint UpdatePosition {\n        input position : Real;\n        input velocity : Real;\n        input timeStep : Real;\n        output newPosition : Real;\n        expression: newPosition = position + velocity * timeStep;\n    }\n\n    association userProvidesInput between user and simulation {\n        user.input.mass = simulation.mass;\n        user.input.initialPosition = simulation.initialPosition;\n        user.input.initialVelocity = simulation.initialVelocity;\n        user.input.timeStep = simulation.timeStep;\n        user.input.powerInputSequence = simulation.powerInputSequence;\n    }\n\n    association simulationOutputsTrajectory between simulation and user {\n        simulation.positionTrajectory = user.output.positionTrajectory;\n    }\n\n}",
    "package CameraSystem {\n\n    part User\n    part Camera\n    part Screen\n\n    interface SceneInput {\n        in scene: Scene\n    }\n\n    interface PhotoOutput {\n        out photo: Photo\n    }\n\n    type Scene\n    type Image\n    type Photo\n\n    action Focus {\n        in scene: Scene\n        out image: Image\n    }\n\n    action Capture {\n        in image: Image\n        out photo: Photo\n    }\n\n    action Display {\n        in photo: Photo\n    }\n\n    action Shoot {\n        in scene: Scene\n        out photo: Photo\n    }\n\n    part User {\n        action ShootOperation {\n            out scene: Scene\n        }\n    }\n\n    part Camera {\n        action ProcessScene {\n            in scene: Scene\n            out image: Image\n        }\n        action GeneratePhoto {\n            in image: Image\n            out photo: Photo\n        }\n    }\n\n    part Screen {\n        action ShowPhoto {\n            in photo: Photo\n        }\n    }\n\n    flow ShootProcess {\n        User.ShootOperation -> Camera.ProcessScene\n        Camera.ProcessScene -> Camera.GeneratePhoto\n        Camera.GeneratePhoto -> Screen.ShowPhoto\n    }\n\n    system CameraSystem {\n        part user: User\n        part camera: Camera\n        part screen: Screen\n\n        flow shootProcess: ShootProcess {\n            user.ShootOperation -> camera.ProcessScene\n            camera.ProcessScene -> camera.GeneratePhoto\n            camera.GeneratePhoto -> screen.ShowPhoto\n        }\n    }\n}",
    "package CameraInformationProcessingWorkflow {\n\n    part user: User;\n    part camera: CameraSystem;\n\n    interface viewPort;\n    interface displayPort;\n\n    part screen: Screen {\n        port displayPort;\n    }\n\n    part viewFinder: ViewFinder {\n        port viewPort;\n    }\n\n    part image: Image;\n    part picture: Picture;\n\n    part workflow: CameraWorkflow {\n        ref user: User;\n        ref camera: CameraSystem;\n        ref viewFinder: ViewFinder;\n        ref image: Image;\n        ref picture: Picture;\n        ref screen: Screen;\n\n        action selectScene {\n            input user;\n            output viewFinder;\n        }\n\n        action focusScene {\n            input viewFinder;\n            output image;\n        }\n\n        action captureImage {\n            input image;\n            output picture;\n        }\n\n        action displayPicture {\n            input picture;\n            output screen;\n        }\n\n        behavior {\n            selectScene -> focusScene -> captureImage -> displayPicture;\n        }\n    }\n\n    part CameraSystem {\n        port viewPort;\n        port displayPort;\n        part viewFinder: ViewFinder;\n        part image: Image;\n        part picture: Picture;\n        part screen: Screen;\n    }\n\n    part User {\n        // User interacts only via scene selection and shooting\n    }\n\n    part ViewFinder {\n        port viewPort;\n    }\n\n    part Screen {\n        port displayPort;\n    }\n\n    part Image {\n        // Represents focused scene image\n    }\n\n    part Picture {\n        // Represents captured photograph\n    }\n}",
    "package SensorManagementSystem {\n\n    part System {\n        part sensors: Sensor[0..*];\n        operation monitorSensors();\n        operation updateSensor(s: Sensor);\n        operation traverseAndUpdateReadySensors();\n        operation processAndMaintainSensor(s: Sensor);\n        property responsiveness: Real;\n        property reliability: Real;\n    }\n\n    part Sensor {\n        property status: SensorStatus;\n        operation update();\n        operation isReady(): Boolean;\n    }\n\n    enum SensorStatus {\n        values = { READY, NOT_READY, UPDATING, ERROR }\n    }\n\n    constraint SystemCanManageMultipleSensors {\n        System.sensors->size() >= 0;\n    }\n\n    constraint SystemSupportsMonitoringAndUpdating {\n        System.monitorSensors() and System.updateSensor(s: Sensor);\n    }\n\n    constraint UpdateWhenSensorReady {\n        forall(s in System.sensors) {\n            if s.isReady() then System.updateSensor(s);\n        }\n    }\n\n    constraint TraverseAndMaintainReadySensors {\n        forall(s in System.sensors) {\n            if s.isReady() {\n                System.processAndMaintainSensor(s);\n            }\n        }\n    }\n\n    constraint AllAvailableSensorsUpToDate {\n        forall(s in System.sensors) {\n            if s.isReady() {\n                s.status = SensorStatus.UPDATING or s.status = SensorStatus.READY;\n            }\n        }\n    }\n\n    constraint ResponsivenessAndReliabilityEnhanced {\n        System.responsiveness > threshold and System.reliability > threshold;\n    }\n\n}",
    "package VehicleStateManagement {\n\n    stateMachine VehicleStateMachine {\n        state Off initial;\n        state Starting;\n        state On;\n\n        transition Off_to_Starting {\n            source Off;\n            target Starting;\n            trigger vehicle_start_signal;\n        }\n\n        transition Starting_to_On {\n            source Starting;\n            target On;\n            trigger vehicle_power_on_signal;\n        }\n\n        transition Any_to_Off {\n            source Off, Starting, On;\n            target Off;\n            trigger vehicle_shutdown_signal;\n        }\n    }\n\n    part vehicleStateManager : VehicleStateMachine;\n}",
    "package VehicleStatusManagement {\n\n    enum VehicleState {\n        off,\n        starting,\n        on\n    }\n\n    signal VehicleStartSignal\n    signal VehicleOnSignal\n    signal VehicleOffSignal\n\n    part VehicleStatusManager {\n        attribute currentState: VehicleState = VehicleState.off\n\n        receive VehicleStartSignal {\n            precondition currentState == VehicleState.off\n            postcondition currentState = VehicleState.starting\n        }\n\n        receive VehicleOnSignal {\n            precondition currentState == VehicleState.starting\n            postcondition currentState = VehicleState.on\n        }\n\n        receive VehicleOffSignal {\n            precondition currentState == VehicleState.on\n            postcondition currentState = VehicleState.off\n        }\n    }\n}",
    "system VehiclePowerManagementSystem {\n\n    part vehicle: Vehicle;\n    part powerController: PowerController;\n    part selfDiagnosisUnit: SelfDiagnosisUnit;\n    part functionalUnits: FunctionalUnit[1..*];\n\n    stateMachine PowerStateMachine {\n        state Off;\n        state StartPhase;\n        state PoweredOn;\n\n        transition Off_to_StartPhase {\n            source Off;\n            target StartPhase;\n            trigger userStartCommand: ControlSignal;\n            effect powerController.switchToStartPhase();\n        }\n\n        transition StartPhase_to_PoweredOn {\n            source StartPhase;\n            target PoweredOn;\n            trigger vehicleStartedSignal: ControlSignal;\n            effect powerController.switchToPoweredOn();\n        }\n\n        transition PoweredOn_to_Off {\n            source PoweredOn;\n            target Off;\n            trigger userShutdownCommand: ControlSignal;\n            effect powerController.executeSafetyOperations();\n        }\n    }\n\n    behavior powerController.switchToStartPhase() {\n        do vehicle.setState(StartPhase);\n    }\n\n    behavior powerController.switchToPoweredOn() {\n        do vehicle.setState(PoweredOn);\n        do selfDiagnosisUnit.performSelfDiagnosis();\n        do powerController.supplyPower(functionalUnits);\n    }\n\n    behavior powerController.executeSafetyOperations() {\n        do vehicle.engageParkingBrake();\n        do vehicle.setState(Off);\n        do powerController.cutOffPower(functionalUnits);\n    }\n\n    interface ControlSignal;\n\n    part userInterface: UserInterface {\n        provides ControlSignal;\n    }\n\n    part Vehicle {\n        attribute state: VehicleState;\n        operation setState(newState: VehicleState);\n        operation engageParkingBrake();\n    }\n\n    enum VehicleState {\n        Off,\n        StartPhase,\n        PoweredOn\n    }\n\n    part PowerController {\n        operation switchToStartPhase();\n        operation switchToPoweredOn();\n        operation executeSafetyOperations();\n        operation supplyPower(units: FunctionalUnit[1..*]);\n        operation cutOffPower(units: FunctionalUnit[1..*]);\n    }\n\n    part SelfDiagnosisUnit {\n        operation performSelfDiagnosis();\n    }\n\n    part FunctionalUnit {\n        attribute powered: Boolean;\n    }\n\n    part UserInterface {\n        operation sendStartCommand(): ControlSignal;\n        operation sendShutdownCommand(): ControlSignal;\n    }\n}",
    "package VehicleControlSystem {\n\n    part vehicle : Vehicle;\n\n    stateMachine VehicleLifecycle {\n        state Shutdown {\n            entry / vehicle.status = VehicleStatus::Shutdown;\n        }\n        state Startup {\n            entry / vehicle.status = VehicleStatus::Startup;\n        }\n        state Running {\n            entry / vehicle.status = VehicleStatus::Running;\n        }\n\n        initial -> Shutdown;\n\n        Shutdown -> Startup \n            when (user.startSignal and vehicle.status == VehicleStatus::Shutdown);\n\n        Startup -> Running \n            when (vehicle.startedSignal);\n\n        Running -> Shutdown \n            when (user.shutdownSignal and vehicle.status == VehicleStatus::Running);\n    }\n\n    part user : User;\n\n    block Vehicle {\n        property status : VehicleStatus;\n        property startedSignal : Boolean;\n    }\n\n    block User {\n        property startSignal : Boolean;\n        property shutdownSignal : Boolean;\n    }\n\n    enum VehicleStatus {\n        Shutdown,\n        Startup,\n        Running\n    }\n}",
    "package VehiclePowerManagement {\n\n    part vehicle : Vehicle;\n\n    block Vehicle {\n        part powerManager : PowerManager;\n        part healthManager : HealthManager;\n    }\n\n    block PowerManager {\n        stateMachine OperatingStateMachine {\n            state Off {\n                transition to Start when startSignal;\n            }\n            state Start {\n                transition to On when onSignal;\n            }\n            state On {\n                transition to Off when offSignal;\n            }\n            initial Off;\n        }\n        input startSignal : Boolean;\n        input onSignal : Boolean;\n        input offSignal : Boolean;\n        output currentState : OperatingState;\n    }\n\n    enum OperatingState {\n        Off,\n        Start,\n        On\n    }\n\n    block HealthManager {\n        // Reserved for future health state management functionality\n    }\n}",
    "system VehicleHealthManagementSystem {\n\n    part vehicle : Vehicle;\n    part controller : VehicleController;\n\n    property maxAllowableTemperature : Real;\n    property maintenanceInterval : Duration;\n    property maintenanceDuration : Duration = 48h;\n\n    stateMachine HealthStatusStateMachine {\n        state Normal;\n        state Degraded;\n        state Maintenance;\n\n        transition NormalToDegraded\n            from Normal\n            to Degraded\n            trigger when(vehicle.temperature > maxAllowableTemperature)\n            effect {\n                controller.sendWarning(\"OverTemperature\");\n            };\n\n        transition DegradedToNormal\n            from Degraded\n            to Normal\n            trigger when(vehicle.temperature <= maxAllowableTemperature);\n\n        transition AnyToMaintenance\n            from Normal, Degraded\n            to Maintenance\n            trigger when(vehicle.timeSinceLastMaintenance >= maintenanceInterval)\n            effect {\n                updateNextMaintenanceTime();\n            };\n\n        transition MaintenanceToNormal\n            from Maintenance\n            to Normal\n            trigger when(maintenanceElapsedTime() >= maintenanceDuration);\n    }\n\n    operation updateNextMaintenanceTime() {\n        vehicle.lastMaintenanceTime = now();\n        vehicle.nextMaintenanceTime = now() + maintenanceInterval;\n    }\n\n    operation maintenanceElapsedTime() : Duration {\n        return now() - vehicle.maintenanceStartTime;\n    }\n\n    constraint TemperatureMonitoring {\n        vehicle.temperature is sensed automatically;\n        vehicle.temperature is compared to maxAllowableTemperature;\n    }\n\n    constraint MaintenanceScheduling {\n        vehicle.maintenance is performed at intervals of maintenanceInterval;\n    }\n}\n\nblock Vehicle {\n    property temperature : Real;\n    property lastMaintenanceTime : Time;\n    property nextMaintenanceTime : Time;\n    property timeSinceLastMaintenance : Duration;\n    property maintenanceStartTime : Time;\n}\n\nblock VehicleController {\n    operation sendWarning(warningType : String);\n}",
    "package ServerSystem {\n\n    part server : Server;\n\n    interface RequestPort {\n        in start : StartCommand;\n        in request : RequestMessage;\n    }\n\n    interface StartCommand {}\n    interface RequestMessage {}\n\n    stateMachine ServerBehavior {\n        state off {\n            entry / doOffActions();\n            transition to waiting\n                when received(start) via requestPort;\n        }\n        state waiting {\n            entry / doWaitingActions();\n            transition to response\n                when received(request) via requestPort;\n        }\n        state response {\n            entry / startResponseTimer();\n            transition to waiting\n                after duration(5, minutes);\n        }\n        transition to off\n            from waiting, response\n            when atTime(11, 59, 0);\n    }\n\n    part Server {\n        part localClock : Clock;\n        port requestPort : RequestPort;\n        stateMachine behavior : ServerBehavior;\n    }\n\n    part Clock {\n        // Clock implementation details\n    }\n}",
    "system VehicleStartStopSystem {\n\n    part vehicle: Vehicle;\n    part controller: Controller;\n    part brakePedal: BrakePedal;\n    part parkingBrake: ParkingBrake;\n\n    stateMachine StartStopProcess {\n        state Off initial;\n        state StartProcess;\n        state Operating;\n        state Stopping;\n\n        transition Off_to_StartProcess from Off to StartProcess\n            trigger startSignal;\n\n        transition StartProcess_to_Operating from StartProcess to Operating\n            guard brakePedal.isDepressed and powerOnSignal\n            effect controller.receiveStartSignal();\n\n        transition Operating_to_Stopping from Operating to Stopping\n            trigger stopSignal;\n\n        transition Stopping_to_Off from Stopping to Off\n            effect parkingBrake.apply();\n    }\n\n    requirement Safety {\n        text \"The system shall ensure safety and reliability of the vehicle’s start-stop process.\";\n    }\n\n    requirement ControllerCoordination {\n        text \"The system shall coordinate control with the controller during the start-stop process.\";\n    }\n\n    behavior OperatingBehavior {\n        do {\n            vehicle.performSelfCheck();\n            vehicle.supplyPowerContinuously();\n        }\n    }\n\n    interface Signals {\n        in startSignal: Boolean;\n        in stopSignal: Boolean;\n        in powerOnSignal: Boolean;\n    }\n\n    part brakePedal: BrakePedal {\n        attribute isDepressed: Boolean;\n    }\n\n    part parkingBrake: ParkingBrake {\n        operation apply();\n    }\n\n    part controller: Controller {\n        operation receiveStartSignal();\n    }\n\n    part vehicle: Vehicle {\n        operation performSelfCheck();\n        operation supplyPowerContinuously();\n    }\n}",
    "package VehicleStartStopSystem {\n\n    part VehicleStartStopController {\n        stateMachine StartStopStateMachine {\n            state Off {\n                transition to StartUp\n                    when (vehicleStartSignalReceived);\n            }\n            state StartUp {\n                transition to Started\n                    when (brakePedalDepressed and vehicleOnSignalReceived)\n                    do {\n                        send(startControlSignal, vehicleController);\n                    };\n            }\n            state Started {\n                entry {\n                    perform(selfCheck);\n                    supplyPower(vehicle);\n                }\n                transition to Off\n                    when (shutdownSignalReceived)\n                    do {\n                        apply(parkingBrake);\n                    };\n            }\n        }\n    }\n\n    part VehicleController;\n    part Vehicle;\n    part BrakePedal;\n    part ParkingBrake;\n\n    signal vehicleStartSignalReceived;\n    signal vehicleOnSignalReceived;\n    signal shutdownSignalReceived;\n    signal startControlSignal;\n\n    action perform(selfCheck);\n    action supplyPower(vehicle: Vehicle);\n    action send(signal, target);\n    action apply(parkingBrake: ParkingBrake);\n\n    requirement R1: \"The system shall control vehicle start-stop and status management, enabling automated control of vehicle start-up, operation, and shutdown.\";\n    requirement R2: \"The system shall enter the start-up process upon receiving the vehicle start signal when in the off state.\";\n    requirement R3: \"If the brake pedal is depressed and a vehicle-on signal is received, the system shall send a start control signal to the vehicle controller, allowing the vehicle to enter the started state.\";\n    requirement R4: \"While in the started state, the system shall perform a self-check and continuously supply power to the vehicle.\";\n    requirement R5: \"When a shutdown signal is received, the system shall switch the vehicle state to off and ensure the parking brake is applied before shutdown.\";\n    requirement R6: \"The system shall ensure the vehicle can only be started and operated under the correct conditions, and that safety measures are automatically taken during shutdown.\";\n\n    satisfies VehicleStartStopController -> R1, R2, R3, R4, R5, R6;\n}",
    "package CruiseControlSystem {\n\n    part Driver\n    part CruiseController\n    part Speedometer\n    part Engine\n    part Vehicle\n\n    interface SetSpeedCommand\n    interface VehicleSpeedInfo\n    interface FuelControlCommand\n\n    // Driver sends set speed command to CruiseController\n    Driver -> CruiseController : SetSpeedCommand\n\n    // Speedometer sends vehicle speed info to CruiseController\n    Speedometer -> CruiseController : VehicleSpeedInfo\n\n    // CruiseController sends fuel control command to Engine\n    CruiseController -> Engine : FuelControlCommand\n\n    // Speedometer collects speed from Vehicle\n    Vehicle -> Speedometer : VehicleSpeedInfo\n\n    // Engine adjusts output to Vehicle\n    Engine -> Vehicle\n\n    // System composition\n    composition CruiseControlSystem {\n        part driver: Driver\n        part cruiseController: CruiseController\n        part speedometer: Speedometer\n        part engine: Engine\n        part vehicle: Vehicle\n\n        connect driver -> cruiseController : SetSpeedCommand\n        connect speedometer -> cruiseController : VehicleSpeedInfo\n        connect cruiseController -> engine : FuelControlCommand\n        connect vehicle -> speedometer : VehicleSpeedInfo\n        connect engine -> vehicle\n    }\n}",
    "package CruiseControlSystem {\n\n    part Vehicle {\n        part Speedometer\n        part EngineSystem\n    }\n\n    part CruiseController\n\n    part Driver\n\n    interface SetSpeedCommand {\n        property setSpeed : Real\n    }\n\n    interface VehicleSpeedInfo {\n        property vehicleSpeed : Real\n    }\n\n    interface ThrottleControlCommand {\n        property throttleValue : Real\n    }\n\n    Driver -> CruiseController : SetSpeedCommand\n    CruiseController -> Vehicle.Speedometer : VehicleSpeedInfo\n    CruiseController -> Vehicle.EngineSystem : ThrottleControlCommand\n\n    CruiseController {\n        property setSpeed : Real\n        property actualSpeed : Real\n        property throttleValue : Real\n\n        operation receiveSetSpeed(cmd : SetSpeedCommand) {\n            setSpeed = cmd.setSpeed\n        }\n\n        operation acquireVehicleSpeed(info : VehicleSpeedInfo) {\n            actualSpeed = info.vehicleSpeed\n        }\n\n        operation computeThrottle() {\n            throttleValue = setSpeed - actualSpeed\n        }\n\n        operation sendThrottleCommand() {\n            ThrottleControlCommand.throttleValue = throttleValue\n        }\n    }\n\n    requirement CruiseControlFunction {\n        text \"The system shall implement cruise control by allowing the driver to set a speed, acquiring real-time vehicle speed, and automatically adjusting throttle to maintain the set speed.\"\n    }\n\n    requirement AutomaticResponse {\n        text \"The system shall automatically respond to the driver's set speed command to improve comfort and safety.\"\n    }\n}",
    "package CruiseControlSystem {\n\n    part Driver\n    part ControlInterface\n    part CruiseController\n    part Speedometer\n    part Engine\n\n    interface SetSpeedCommand {\n        in speed: Real;\n    }\n\n    interface VehicleSpeedInfo {\n        out speed: Real;\n    }\n\n    interface ThrottleControlCommand {\n        out throttle: Real;\n    }\n\n    part CruiseControlSystem {\n        part driver: Driver;\n        part controlInterface: ControlInterface;\n        part cruiseController: CruiseController;\n        part speedometer: Speedometer;\n        part engine: Engine;\n\n        connector driverToInterface {\n            end driver;\n            end controlInterface;\n            interface SetSpeedCommand;\n        }\n\n        connector interfaceToController {\n            end controlInterface;\n            end cruiseController;\n            interface SetSpeedCommand;\n        }\n\n        connector speedometerToController {\n            end speedometer;\n            end cruiseController;\n            interface VehicleSpeedInfo;\n        }\n\n        connector controllerToEngine {\n            end cruiseController;\n            end engine;\n            interface ThrottleControlCommand;\n        }\n    }\n\n    behavior CruiseControllerBehavior {\n        input setSpeed: Real;\n        input currentSpeed: Real;\n        output throttleCommand: Real;\n\n        state Idle;\n        state Active;\n\n        transition IdleToActive from Idle to Active\n            trigger setSpeed;\n\n        transition ActiveToIdle from Active to Idle\n            trigger (setSpeed == 0);\n\n        transition MaintainSpeed from Active to Active\n            effect {\n                let speedError = setSpeed - currentSpeed;\n                throttleCommand = calculateThrottle(speedError);\n            }\n    }\n\n    part CruiseController {\n        behavior CruiseControllerBehavior;\n    }\n\n    requirement CruiseControlFunction {\n        text \"The system shall allow the driver to set a target speed via the control interface. The cruise controller shall compare the set speed with the current vehicle speed from the speedometer, calculate the speed difference, and send a throttle control command to the engine to maintain the set speed.\"\n    }\n}",
    "system CruiseControlSystem {\n    \n    part driver: Driver\n    part cruiseController: CruiseController\n    part engine: Engine\n    part speedometer: Speedometer\n\n    interface SpeedSettingRequest {\n        attribute desiredSpeed: Real\n    }\n\n    interface VehicleSpeedFeedback {\n        attribute currentSpeed: Real\n    }\n\n    interface ThrottleControlInstruction {\n        attribute throttleValue: Real\n    }\n\n    driver -> cruiseController: SpeedSettingRequest\n    speedometer -> cruiseController: VehicleSpeedFeedback\n    cruiseController -> engine: ThrottleControlInstruction\n\n    requirement SetCruisingSpeed {\n        text \"The system shall allow the driver to set the vehicle’s cruising speed by sending a command specifying the desired speed.\"\n    }\n\n    requirement RealTimeSpeedFeedback {\n        text \"The system shall provide real-time vehicle speed information from the speedometer to the cruise controller.\"\n    }\n\n    requirement ThrottleAdjustment {\n        text \"The cruise controller shall calculate and send throttle control instructions to the engine based on the desired and current speed.\"\n    }\n\n    requirement AutomaticCruise {\n        text \"The system shall automatically adjust and maintain the vehicle at the set cruising speed with accuracy and smoothness.\"\n    }\n\n    requirement DriverConvenience {\n        text \"The system shall ensure convenience and comfort for the driver during cruise control operation.\"\n    }\n}",
    "package CruiseControlSystem {\n\n    part Vehicle {\n        part engine: Engine;\n        part speedSensor: SpeedSensor;\n        part cruiseController: CruiseController;\n        part cruiseControlInterface: CruiseControlInterface;\n    }\n\n    part Engine {\n        port in fuelControlCommand: FuelControlCommand;\n        port out engineOutput: EngineOutput;\n    }\n\n    part SpeedSensor {\n        port out actualSpeed: Speed;\n    }\n\n    part CruiseController {\n        port in setSpeed: Speed;\n        port in actualSpeed: Speed;\n        port out fuelControlCommand: FuelControlCommand;\n    }\n\n    part CruiseControlInterface {\n        port out setSpeed: Speed;\n    }\n\n    interface Speed {\n        attribute value: Real;\n        attribute unit: String;\n    }\n\n    interface FuelControlCommand {\n        attribute fuelRate: Real;\n    }\n\n    interface EngineOutput {\n        attribute power: Real;\n    }\n\n    association CruiseControlInterfaceToController {\n        end interface: CruiseControlInterface;\n        end controller: CruiseController;\n        role interface.setSpeed -> controller.setSpeed;\n    }\n\n    association SpeedSensorToController {\n        end sensor: SpeedSensor;\n        end controller: CruiseController;\n        role sensor.actualSpeed -> controller.actualSpeed;\n    }\n\n    association ControllerToEngine {\n        end controller: CruiseController;\n        end engine: Engine;\n        role controller.fuelControlCommand -> engine.fuelControlCommand;\n    }\n\n    association EngineToVehicle {\n        end engine: Engine;\n        end vehicle: Vehicle;\n        role engine.engineOutput;\n    }\n\n    requirement CruiseControlFunction {\n        text \"The system shall enable the driver to set a target speed via the cruise control interface. The cruise controller shall receive the set speed and actual speed, compare them, and generate fuel control commands to the engine to maintain the vehicle speed as close as possible to the target speed.\";\n    }\n\n    requirement SpeedDetection {\n        text \"The vehicle shall obtain real-time actual speed information via a speed sensor and provide this information to the cruise controller.\";\n    }\n\n    requirement FuelControl {\n        text \"The cruise controller shall generate engine fuel control commands based on the comparison of set speed and actual speed.\";\n    }\n\n    requirement DataPortCommunication {\n        text \"All components shall exchange information such as set speed, speed sensing, and fuel control via data ports efficiently and accurately.\";\n    }\n}",
    "package CruiseControlSystem {\n\n    part Vehicle {\n        part cruiseController: CruiseController;\n        part speedSensor: SpeedSensor;\n        part engineController: EngineController;\n        part engine: Engine;\n        part driver: Driver;\n    }\n\n    interface SetSpeedCommand {\n        in speed: Real;\n    }\n\n    interface SpeedInfo {\n        out speed: Real;\n    }\n\n    interface FuelControlCommand {\n        in fuelAdjustment: Real;\n    }\n\n    interface EngineControlCommand {\n        in fuelAdjustment: Real;\n    }\n\n    part Driver {\n        port sendSetSpeed: SetSpeedCommand;\n    }\n\n    part SpeedSensor {\n        port provideSpeed: SpeedInfo;\n    }\n\n    part CruiseController {\n        port receiveSetSpeed: SetSpeedCommand;\n        port readSpeed: SpeedInfo;\n        port sendFuelControl: FuelControlCommand;\n    }\n\n    part EngineController {\n        port receiveFuelControl: FuelControlCommand;\n        port sendEngineControl: EngineControlCommand;\n    }\n\n    part Engine {\n        port receiveEngineControl: EngineControlCommand;\n    }\n\n    connector driverToCruiseController {\n        end driver.sendSetSpeed;\n        end cruiseController.receiveSetSpeed;\n    }\n\n    connector speedSensorToCruiseController {\n        end speedSensor.provideSpeed;\n        end cruiseController.readSpeed;\n    }\n\n    connector cruiseControllerToEngineController {\n        end cruiseController.sendFuelControl;\n        end engineController.receiveFuelControl;\n    }\n\n    connector engineControllerToEngine {\n        end engineController.sendEngineControl;\n        end engine.receiveEngineControl;\n    }\n}",
    "package VehicleLifecycleManagement {\n\n    part VehicleLifecycleSystem {\n        part vehicles : Vehicle[0..*];\n    }\n\n    part Vehicle {\n        attribute vin : String;\n        attribute assemblyDate : DateTime;\n        part delivery : Delivery;\n        part ownerships : Ownership[0..*];\n        part endOfUse : EndOfUse[0..1];\n    }\n\n    part Delivery {\n        attribute deliveryDate : DateTime;\n        attribute deliveredTo : Owner;\n    }\n\n    part Ownership {\n        attribute ownershipStart : DateTime;\n        attribute ownershipEnd : DateTime[0..1];\n        part owner : Owner;\n        part drivingRecords : DrivingRecord[0..*];\n    }\n\n    part Owner {\n        attribute ownerId : String;\n        attribute name : String;\n        attribute contactInfo : String;\n    }\n\n    part DrivingRecord {\n        attribute driveDateTime : DateTime;\n        part driver : Driver;\n    }\n\n    part Driver {\n        attribute driverId : String;\n        attribute name : String;\n        attribute licenseNumber : String;\n    }\n\n    part EndOfUse {\n        attribute scrappingDate : DateTime;\n        attribute deregistrationInfo : String;\n    }\n\n    requirement R1 {\n        text = \"The system shall manage and track the entire lifecycle of a vehicle from assembly, delivery, ownership changes, driving operations, to end-of-use (scrapping or de-registration).\";\n    }\n\n    requirement R2 {\n        text = \"The delivery date must be recorded at the time of delivery for each vehicle.\";\n    }\n\n    requirement R3 {\n        text = \"Each ownership change must record the owner's information and ensure traceability to a unique owner for each stage.\";\n    }\n\n    requirement R4 {\n        text = \"During each ownership period, different drivers can be tracked and each driving operation must specify the actual driver.\";\n    }\n\n    requirement R5 {\n        text = \"When the vehicle reaches the end-of-use stage, scrapping or de-registration information must be recorded.\";\n    }\n\n    requirement R6 {\n        text = \"The system shall support inquiry and traceability of all lifecycle-related data.\";\n    }\n}",
    "package VehicleModel {\n\n    // Attribute types\n    type Mass : Real;\n    type GearSetting : Integer;\n    type PedalPosition : Real;\n    type OperationalStatus;\n\n    // OperationalStatus definition\n    part OperationalStatus {\n        attribute gear : GearSetting;\n        attribute acceleratorPedal : PedalPosition;\n    }\n\n    // Engine definition\n    part Engine {\n        // Engine attributes can be extended\n    }\n\n    // Wheel definition\n    part Wheel {\n        // Wheel attributes can be extended\n    }\n\n    // Driver definition (external reference)\n    external part Driver;\n\n    // Vehicle definition\n    part Vehicle {\n        attribute mass : Mass;\n        attribute status : OperationalStatus;\n        part engine : Engine;\n        part wheels : Wheel[1..*];\n        reference driver : Driver;\n    }\n\n    // Vehicle instance: vehicle_1\n    instance vehicle_1 : Vehicle {\n        mass = 1500.0;\n        status = status_1;\n        engine = engine_1;\n        wheels = { leftFrontWheel_1, rightFrontWheel_1, wheel_3, wheel_4 };\n        driver = driver_1;\n    }\n\n    // Specific wheels for vehicle_1\n    instance leftFrontWheel_1 : Wheel { }\n    instance rightFrontWheel_1 : Wheel { }\n    instance wheel_3 : Wheel { }\n    instance wheel_4 : Wheel { }\n\n    // Engine instance for vehicle_1\n    instance engine_1 : Engine { }\n\n    // Driver instance (external)\n    instance driver_1 : Driver { }\n\n    // Operational status snapshots for vehicle_1\n    instance status_1 : OperationalStatus {\n        gear = 1;\n        acceleratorPedal = 0.0;\n    }\n\n    // Time snapshot: t1\n    snapshot t1 {\n        vehicle_1.status = status_1;\n        leftFrontWheel_1; // status at t1\n        rightFrontWheel_1; // status at t1\n    }\n\n    // Time snapshot: t2\n    instance status_2 : OperationalStatus {\n        gear = 2;\n        acceleratorPedal = 0.5;\n    }\n\n    snapshot t2 {\n        vehicle_1.status = status_2;\n        leftFrontWheel_1; // status at t2\n        rightFrontWheel_1; // status at t2\n    }\n}",
    "package VehicleSystem {\n\n    part VehicleSystem {\n        part vehicles: Vehicle[0..*];\n        part engines: Engine[0..*];\n        part drivers: Driver[0..*];\n    }\n\n    part Vehicle {\n        attribute mass: Real;\n        attribute state: VehicleState;\n        part engine: Engine;\n        part driver: Driver;\n    }\n\n    part Engine {\n    }\n\n    part Driver {\n    }\n\n    part VehicleState {\n        attribute gear: Integer;\n        attribute acceleratorPosition: Real;\n    }\n\n    instance Vehicle_1: Vehicle {\n        mass = 2000.0;\n        state = VehicleState_Initial;\n    }\n\n    instance VehicleState_Initial: VehicleState {\n        gear = 0;\n        acceleratorPosition = 0.0;\n    }\n\n    instance VehicleState_Next: VehicleState {\n        gear = 2;\n        acceleratorPosition = 0.5;\n    }\n\n    // Evolution of Vehicle_1 attributes over time\n    constraint Vehicle_1_Evolution {\n        // At t0\n        at t0: Vehicle_1.mass == 2000.0 and\n               Vehicle_1.state.gear == 0 and\n               Vehicle_1.state.acceleratorPosition == 0.0;\n        // At t1\n        at t1: Vehicle_1.mass == 1500.0 and\n               Vehicle_1.state.gear == 2 and\n               Vehicle_1.state.acceleratorPosition == 0.5;\n    }\n}",
    "package VehicleSystem {\n\n    part Vehicle {\n        attribute mass: Real;\n        attribute gearPosition: String;\n        attribute throttlePedalPosition: Real;\n        part engine: Engine;\n        reference driver: Driver;\n    }\n\n    part Engine {\n    }\n\n    part Driver {\n        attribute name: String;\n    }\n\n    part Alice: Driver {\n        name = \"Alice\";\n    }\n\n    part Bob: Driver {\n        name = \"Bob\";\n    }\n\n    state InitialState {\n        vehicle: Vehicle {\n            mass = 2000.0;\n            gearPosition = \"neutral\";\n            throttlePedalPosition = 0.0;\n            driver = Alice;\n        }\n    }\n\n    state SecondState {\n        vehicle: Vehicle {\n            mass = 1500.0;\n            gearPosition = \"second\";\n            throttlePedalPosition = 0.5;\n            driver = Bob;\n        }\n    }\n\n    transition InitialToSecond {\n        source = InitialState;\n        target = SecondState;\n    }\n}",
    "package VehicleMassAggregation {\n\n    part Vehicle {\n        attribute id: String;\n        attribute name: String;\n        attribute mass: Real;\n        part engine: Engine;\n        part transmission: Transmission;\n        part components: Component[*];\n        constraint totalMass: Real = mass + engine.totalMass + transmission.totalMass + sum(components.totalMass);\n    }\n\n    part Engine {\n        attribute id: String;\n        attribute name: String;\n        attribute mass: Real;\n        part components: Component[*];\n        constraint totalMass: Real = mass + sum(components.totalMass);\n    }\n\n    part Transmission {\n        attribute id: String;\n        attribute name: String;\n        attribute mass: Real;\n        part components: Component[*];\n        constraint totalMass: Real = mass + sum(components.totalMass);\n    }\n\n    part Component {\n        attribute id: String;\n        attribute name: String;\n        attribute mass: Real;\n        part subcomponents: Component[*];\n        constraint totalMass: Real = mass + sum(subcomponents.totalMass);\n    }\n\n}",
    "package VehicleMassManagement {\n\n    part Vehicle {\n        attribute vin: String;\n        attribute mass: Real;\n        part components: VehicleComponent[*];\n        constraint totalMass: Real = mass + sum(components->collect(c | c.totalMass));\n    }\n\n    part VehicleComponent {\n        attribute serialNumber: String;\n        attribute mass: Real;\n        part subcomponents: VehicleComponent[*];\n        constraint totalMass: Real = mass + sum(subcomponents->collect(sc | sc.totalMass));\n    }\n\n    part Engine extends VehicleComponent {\n        attribute engineType: String;\n    }\n\n    part Transmission extends VehicleComponent {\n        attribute transmissionType: String;\n    }\n\n    constraint massFilter(threshold: Real): Real = \n        mass + sum(subcomponents->select(sc | sc.mass >= threshold)->collect(sc | sc.massFilter(threshold)));\n\n}",
    "package QualityAggregationManagement {\n\n    part objectWithMass {\n        attribute simpleMass: Real;\n        attribute totalMass: Real;\n    }\n\n    part simpleThing specializes objectWithMass {\n        constraint totalMassEqualsSimpleMass {\n            totalMass = simpleMass;\n        }\n    }\n\n    part compositeThing specializes objectWithMass {\n        part subcomponents: objectWithMass[0..*];\n        constraint totalMassAggregation {\n            totalMass = simpleMass + sum(subcomponents.totalMass);\n        }\n    }\n\n    part QualityAggregationSystem {\n        part managedObjects: objectWithMass[0..*];\n    }\n\n}",
    "package MassManagementSystem {\n\n    part MassManagementSystem {\n        owns part objects: Object[0..*];\n        owns attribute minMassThreshold: Real = 0.0;\n    }\n\n    part Object {\n        owns attribute basicMass: Real;\n        owns part subcomponents: Object[0..*];\n    }\n\n    constraint TotalMass {\n        input object: Object;\n        output totalMass: Real;\n        let subMasses: Real[0..*] = object.subcomponents->collect(sc | sc.basicMass + sc.subcomponents->size() > 0 ? TotalMass(sc) : 0.0);\n        totalMass = object.basicMass + subMasses->sum();\n    }\n\n    constraint FilteredTotalMass {\n        input object: Object;\n        input minMass: Real;\n        output filteredTotalMass: Real;\n        let filteredSubMasses: Real[0..*] = object.subcomponents->select(sc | sc.basicMass >= minMass)->collect(sc | sc.basicMass + (sc.subcomponents->size() > 0 ? FilteredTotalMass(sc, minMass) : 0.0));\n        filteredTotalMass = object.basicMass + filteredSubMasses->sum();\n    }\n\n    constraint MassFilter {\n        input object: Object;\n        input minMass: Real;\n        output filteredSubcomponents: Object[0..*];\n        filteredSubcomponents = object.subcomponents->select(sc | sc.basicMass >= minMass);\n    }\n\n}",
    "system VehicleDynamicsCalculator {\n    \n    part vehicle: Vehicle;\n    part environment: OperatingConditions;\n    \n    requirement CalculateCoreParameters {\n        text \"The system shall calculate core vehicle dynamics parameters: power output, acceleration, speed, and position under various operating conditions.\"\n    }\n    \n    requirement AccuratePowerCalculation {\n        text \"The system shall accurately calculate the vehicle’s actual available power output based on wheel power, aerodynamic drag coefficient, friction coefficient, vehicle mass, and speed.\"\n    }\n    \n    requirement AccelerationDeduction {\n        text \"The system shall deduce the vehicle’s acceleration based on effective power, mass, and current speed.\"\n    }\n    \n    requirement SpeedCalculation {\n        text \"The system shall calculate the vehicle’s speed at any given moment using acceleration, initial speed, and time.\"\n    }\n    \n    requirement DisplacementEstimation {\n        text \"The system shall estimate vehicle displacement based on speed and time.\"\n    }\n    \n    requirement HighAccuracy {\n        text \"The system shall provide high accuracy and clear logical relationships between parameters, with results suitable for practical engineering applications.\"\n    }\n    \n    interface VehicleDynamicsInputs {\n        in wheelPower: Real;\n        in aeroDragCoeff: Real;\n        in frictionCoeff: Real;\n        in vehicleMass: Real;\n        in speed: Real;\n        in initialSpeed: Real;\n        in time: Real;\n        in effectivePower: Real;\n    }\n    \n    interface VehicleDynamicsOutputs {\n        out availablePower: Real;\n        out acceleration: Real;\n        out currentSpeed: Real;\n        out displacement: Real;\n    }\n    \n    constraint AvailablePowerCalculation {\n        parameter wheelPower: Real;\n        parameter aeroDragCoeff: Real;\n        parameter frictionCoeff: Real;\n        parameter vehicleMass: Real;\n        parameter speed: Real;\n        result availablePower: Real;\n        expr availablePower = wheelPower - (0.5 * aeroDragCoeff * speed^3) - (frictionCoeff * vehicleMass * 9.81 * speed);\n    }\n    \n    constraint AccelerationCalculation {\n        parameter effectivePower: Real;\n        parameter vehicleMass: Real;\n        parameter speed: Real;\n        result acceleration: Real;\n        expr acceleration = effectivePower / (vehicleMass * speed);\n    }\n    \n    constraint SpeedAtTimeCalculation {\n        parameter initialSpeed: Real;\n        parameter acceleration: Real;\n        parameter time: Real;\n        result currentSpeed: Real;\n        expr currentSpeed = initialSpeed + acceleration * time;\n    }\n    \n    constraint DisplacementCalculation {\n        parameter initialSpeed: Real;\n        parameter acceleration: Real;\n        parameter time: Real;\n        result displacement: Real;\n        expr displacement = initialSpeed * time + 0.5 * acceleration * time^2;\n    }\n}\n\nblock Vehicle {\n    attribute mass: Real;\n    attribute speed: Real;\n    attribute wheelPower: Real;\n}\n\nblock OperatingConditions {\n    attribute aeroDragCoeff: Real;\n    attribute frictionCoeff: Real;\n    attribute time: Real;\n}",
    "system VehicleDynamicsSimulation {\n    \n    part vehicle: Vehicle;\n    part environment: Environment;\n    part user: UserInterface;\n    part simulator: Simulator;\n\n    interface VehicleDynamicsInput {\n        property initialSpeed: Real;\n        property initialPosition: Real;\n        property timeStep: Real;\n        property totalMass: Real;\n        property wheelEndOutputPower: Real;\n        property aeroDragCoefficient: Real;\n        property rollingResistanceCoefficient: Real;\n    }\n\n    interface VehicleDynamicsOutput {\n        property acceleration: Real;\n        property speed: Real;\n        property position: Real;\n        property availableDrivingPower: Real;\n    }\n\n    part vehicleDynamicsInput: VehicleDynamicsInput;\n    part vehicleDynamicsOutput: VehicleDynamicsOutput;\n\n    constraint AerodynamicDrag {\n        property airDensity: Real;\n        property frontalArea: Real;\n        property speed: Real;\n        property aeroDragCoefficient: Real;\n        expr: dragForce = 0.5 * airDensity * frontalArea * aeroDragCoefficient * speed^2;\n    }\n\n    constraint RollingResistance {\n        property rollingResistanceCoefficient: Real;\n        property totalMass: Real;\n        property gravity: Real;\n        expr: rollingForce = rollingResistanceCoefficient * totalMass * gravity;\n    }\n\n    constraint AvailableDrivingPower {\n        property wheelEndOutputPower: Real;\n        property dragForce: Real;\n        property rollingForce: Real;\n        property speed: Real;\n        expr: availableDrivingPower = wheelEndOutputPower - (dragForce + rollingForce) * speed;\n    }\n\n    constraint AccelerationCalculation {\n        property availableDrivingPower: Real;\n        property speed: Real;\n        property totalMass: Real;\n        expr: acceleration = availableDrivingPower / (totalMass * speed);\n    }\n\n    constraint SpeedUpdate {\n        property speed: Real;\n        property acceleration: Real;\n        property timeStep: Real;\n        expr: newSpeed = speed + acceleration * timeStep;\n    }\n\n    constraint PositionUpdate {\n        property position: Real;\n        property speed: Real;\n        property acceleration: Real;\n        property timeStep: Real;\n        expr: newPosition = position + speed * timeStep + 0.5 * acceleration * timeStep^2;\n    }\n\n    part application: Application;\n\n    interface Application {\n        property performanceAnalysis: Boolean;\n        property energyConsumptionSimulation: Boolean;\n        property drivingStrategyOptimization: Boolean;\n    }\n\n    userInterface allows user to set {\n        vehicleDynamicsInput.initialSpeed,\n        vehicleDynamicsInput.initialPosition,\n        vehicleDynamicsInput.timeStep,\n        vehicleDynamicsInput.totalMass,\n        vehicleDynamicsInput.wheelEndOutputPower,\n        vehicleDynamicsInput.aeroDragCoefficient,\n        vehicleDynamicsInput.rollingResistanceCoefficient\n    };\n\n    simulator computes {\n        AerodynamicDrag,\n        RollingResistance,\n        AvailableDrivingPower,\n        AccelerationCalculation,\n        SpeedUpdate,\n        PositionUpdate\n    };\n\n    simulator provides vehicleDynamicsOutput;\n\n    application supports {\n        performanceAnalysis,\n        energyConsumptionSimulation,\n        drivingStrategyOptimization\n    };\n}",
    "system VehicleDynamicsSimulation {\n    part vehicle: Vehicle\n    part environment: Environment\n    part userInput: UserInput\n    part simulation: SimulationEngine\n\n    relate vehicle, environment, userInput, simulation\n}\n\nblock Vehicle {\n    attribute mass: Real\n    attribute wheelPower: Real\n    attribute position: Real\n    attribute speed: Real\n    attribute acceleration: Real\n    attribute velocity: Real\n    attribute displacement: Real\n}\n\nblock Environment {\n    attribute airDensity: Real\n    attribute aerodynamicDragCoefficient: Real\n    attribute rollingResistanceCoefficient: Real\n}\n\nblock UserInput {\n    attribute initialSpeed: Real\n    attribute initialPosition: Real\n    attribute vehicleMass: Real\n    attribute wheelPower: Real\n    attribute aerodynamicDragCoefficient: Real\n    attribute rollingResistanceCoefficient: Real\n}\n\nblock SimulationEngine {\n    attribute timeStep: Real\n    operation calculateForces(\n        mass: Real,\n        speed: Real,\n        airDensity: Real,\n        dragCoeff: Real,\n        rollingResCoeff: Real\n    ): Real\n\n    operation updateState(\n        currentSpeed: Real,\n        currentPosition: Real,\n        acceleration: Real,\n        timeStep: Real\n    ): (Real, Real)\n\n    operation predictDynamics(\n        userInput: UserInput,\n        environment: Environment,\n        vehicle: Vehicle,\n        timeStep: Real\n    ): DynamicStates\n}\n\nblock DynamicStates {\n    attribute velocity: Real\n    attribute acceleration: Real\n    attribute displacement: Real\n    attribute position: Real\n    attribute speed: Real\n}\n\nrequirement R1 {\n    text \"The system shall model and compute the vehicle's driving dynamics based on user input parameters including vehicle mass, wheel power, aerodynamic drag coefficient, rolling resistance coefficient, initial speed, and initial position.\"\n}\n\nrequirement R2 {\n    text \"The system shall automatically calculate and update the vehicle's speed and position at each time step.\"\n}\n\nrequirement R3 {\n    text \"The system shall account for the effects of air resistance and frictional resistance on vehicle dynamics.\"\n}\n\nrequirement R4 {\n    text \"The system shall predict the vehicle's velocity, acceleration, displacement, and other dynamic states over time.\"\n}\n\nrequirement R5 {\n    text \"The system shall assist end users in analyzing vehicle performance under different operating conditions.\"\n}\n\nsatisfy R1 by Vehicle, UserInput, Environment, SimulationEngine\nsatisfy R2 by SimulationEngine\nsatisfy R3 by Environment, SimulationEngine\nsatisfy R4 by SimulationEngine, DynamicStates\nsatisfy R5 by VehicleDynamicsSimulation",
    "package VehicleLongitudinalDynamics {\n\n    part Vehicle {\n        attribute mass: Real;\n        attribute dragCoefficient: Real;\n        attribute frictionCoefficient: Real;\n        attribute initialPosition: Real;\n        attribute initialVelocity: Real;\n        attribute wheelEndDrivePower: Real;\n    }\n\n    part Environment {\n        attribute airDensity: Real;\n        attribute gravity: Real;\n        attribute timeInterval: Real;\n        attribute frontalArea: Real;\n        attribute rollingResistanceCoefficient: Real;\n    }\n\n    part UserInput {\n        attribute initialPosition: Real;\n        attribute initialVelocity: Real;\n        attribute mass: Real;\n        attribute wheelEndDrivePower: Real;\n        attribute timeInterval: Real;\n    }\n\n    part Output {\n        attribute acceleration: Real;\n        attribute finalVelocity: Real;\n        attribute finalPosition: Real;\n    }\n\n    constraint DragForce {\n        parameter v: Real;\n        parameter Cd: Real;\n        parameter A: Real;\n        parameter rho: Real;\n        expression: Real = 0.5 * rho * Cd * A * v * v;\n    }\n\n    constraint FrictionForce {\n        parameter mu: Real;\n        parameter m: Real;\n        parameter g: Real;\n        expression: Real = mu * m * g;\n    }\n\n    constraint RollingResistanceForce {\n        parameter Crr: Real;\n        parameter m: Real;\n        parameter g: Real;\n        expression: Real = Crr * m * g;\n    }\n\n    constraint TractiveForce {\n        parameter P: Real;\n        parameter v: Real;\n        expression: Real = P / v;\n    }\n\n    constraint NetForce {\n        parameter Ft: Real;\n        parameter Fd: Real;\n        parameter Ff: Real;\n        parameter Frr: Real;\n        expression: Real = Ft - Fd - Ff - Frr;\n    }\n\n    constraint Acceleration {\n        parameter Fnet: Real;\n        parameter m: Real;\n        expression: Real = Fnet / m;\n    }\n\n    constraint FinalVelocity {\n        parameter v0: Real;\n        parameter a: Real;\n        parameter dt: Real;\n        expression: Real = v0 + a * dt;\n    }\n\n    constraint FinalPosition {\n        parameter x0: Real;\n        parameter v0: Real;\n        parameter a: Real;\n        parameter dt: Real;\n        expression: Real = x0 + v0 * dt + 0.5 * a * dt * dt;\n    }\n\n    requirement R1 {\n        text: \"The system shall accept user input for initial position, initial velocity, vehicle mass, wheel-end drive power, and time interval.\"\n    }\n\n    requirement R2 {\n        text: \"The system shall calculate acceleration, final velocity, and final position considering air resistance, frictional resistance, and other relevant factors.\"\n    }\n\n    requirement R3 {\n        text: \"The system shall ensure physical consistency and accuracy of the motion simulation.\"\n    }\n\n    requirement R4 {\n        text: \"The system shall be suitable for linear uniformly accelerated motion scenarios.\"\n    }\n\n    satisfies VehicleLongitudinalDynamics {\n        requirement R1;\n        requirement R2;\n        requirement R3;\n        requirement R4;\n    }\n\n}",
    "package VehicleMassManagement {\n\n    part Vehicle {\n        part chassis: Chassis;\n        part engine: Engine;\n        part gearbox: Gearbox;\n\n        def totalMass: Real = chassis.mass + engine.mass + gearbox.mass;\n\n        constraint massLimit {\n            totalMass <= 2500.0;\n        }\n\n        event OverweightWarning;\n\n        behavior checkMass {\n            if totalMass > 2500.0 {\n                emit OverweightWarning;\n            }\n        }\n    }\n\n    part Chassis {\n        attribute mass: Real;\n    }\n\n    part Engine {\n        attribute mass: Real;\n    }\n\n    part Gearbox {\n        attribute mass: Real;\n    }\n}",
    "system VehicleMassBudgetingSystem {\n\n    part vehicle: Vehicle;\n\n    requirement mass_limit {\n        text \"The total mass of the complete vehicle, including major components such as the chassis, engine, and transmission, shall not exceed 2,500 kilograms.\";\n    }\n\n    requirement component_mass_entry {\n        text \"The actual mass of each component shall be entered and uniformly measured using the international unit of kilograms.\";\n    }\n\n    requirement mass_calculation {\n        text \"The system shall automatically calculate the sum of the component masses and compare the result with the specified mass limit.\";\n    }\n\n    requirement mass_limit_check {\n        text \"If the total mass exceeds the limit, the design requirements are not met.\";\n    }\n\n    requirement engine_transmission_mass_management {\n        text \"The masses of the engine and the transmission shall be separately recorded and managed as critical components.\";\n    }\n\n    requirement curb_weight_control {\n        text \"During the preliminary design stage, vehicle curb weight shall be effectively controlled through these constraints.\";\n    }\n}\n\nblock Vehicle {\n    part chassis: Chassis;\n    part engine: Engine;\n    part transmission: Transmission;\n\n    attribute total_mass: Real[kg];\n}\n\nblock Chassis {\n    attribute mass: Real[kg];\n}\n\nblock Engine {\n    attribute mass: Real[kg];\n}\n\nblock Transmission {\n    attribute mass: Real[kg];\n}\n\nconstraint VehicleMassConstraint {\n    parameter chassis_mass: Real[kg];\n    parameter engine_mass: Real[kg];\n    parameter transmission_mass: Real[kg];\n    parameter total_mass: Real[kg];\n    parameter mass_limit: Real[kg] = 2500.0;\n\n    expression: total_mass = chassis_mass + engine_mass + transmission_mass;\n    expression: total_mass <= mass_limit;\n}",
    "package VehicleMassCompliance {\n\n    part Vehicle {\n        part chassis: Chassis;\n        part engine: Engine;\n        part transmission: Transmission;\n\n        attribute totalMass: Real;\n    }\n\n    part Chassis {\n        attribute mass: Real;\n    }\n\n    part Engine {\n        attribute mass: Real;\n    }\n\n    part Transmission {\n        attribute mass: Real;\n    }\n\n    requirement VehicleMassLimit {\n        text \"The total mass of the complete vehicle (sum of chassis, engine, and transmission masses) must not exceed 2,500 kilograms.\";\n    }\n\n    constraint TotalMassComputation {\n        parameter v: Vehicle;\n        expression v.totalMass = v.chassis.mass + v.engine.mass + v.transmission.mass;\n    }\n\n    constraint MassLimitCompliance {\n        parameter v: Vehicle;\n        expression v.totalMass <= 2500.0;\n    }\n\n    requirement MassComplianceVerification {\n        text \"The system shall receive actual mass data of each component and automatically verify that their total does not exceed the specified upper mass limit.\";\n    }\n\n    satisfies VehicleMassLimit by MassLimitCompliance;\n    satisfies MassComplianceVerification by MassLimitCompliance;\n\n}",
    "system VehicleWeightManagementSystem {\n\n    part chassis: Chassis;\n    part engine: Engine;\n    part transmission: Transmission;\n\n    property totalWeight: kg;\n    property weightLimit: kg = 2500;\n\n    input chassis.weight: kg;\n    input engine.weight: kg;\n    input transmission.weight: kg;\n\n    constraint SumWeights {\n        totalWeight = chassis.weight + engine.weight + transmission.weight;\n    }\n\n    constraint WeightLimitNotExceeded {\n        totalWeight <= weightLimit;\n    }\n\n    requirement RecordComponentWeights {\n        text \"The system shall record and manage the weight of each main vehicle component (chassis, engine, transmission).\";\n    }\n\n    requirement InputComponentWeights {\n        text \"The system shall require the weight data for the chassis, engine, and transmission as inputs.\";\n    }\n\n    requirement SumComponentWeights {\n        text \"The system shall automatically sum the weights of the chassis, engine, and transmission.\";\n    }\n\n    requirement EnforceWeightLimit {\n        text \"The system shall provide a warning or impose restrictions when the total weight exceeds 2,500 kilograms to ensure compliance with regulatory requirements.\";\n    }\n\n    satisfies RecordComponentWeights;\n    satisfies InputComponentWeights;\n    satisfies SumComponentWeights;\n    satisfies EnforceWeightLimit;\n\n    behavior MonitorWeight {\n        input chassis.weight: kg;\n        input engine.weight: kg;\n        input transmission.weight: kg;\n        output warning: Boolean;\n        output restrictionImposed: Boolean;\n\n        do {\n            totalWeight = chassis.weight + engine.weight + transmission.weight;\n            if (totalWeight > weightLimit) {\n                warning = true;\n                restrictionImposed = true;\n            } else {\n                warning = false;\n                restrictionImposed = false;\n            }\n        }\n    }\n}\n\nblock Chassis {\n    property weight: kg;\n}\n\nblock Engine {\n    property weight: kg;\n}\n\nblock Transmission {\n    property weight: kg;\n}\n\nunit kg;",
    "package VehicleSystem {\n\n    part Vehicle {\n        part chassis : Chassis;\n        part engine : Engine;\n        part transmission : Transmission;\n\n        attribute totalMass : Real;\n        constraint TotalMassCalculation {\n            totalMass = chassis.mass + engine.mass + transmission.mass;\n        }\n        constraint MaxTotalMass {\n            totalMass <= 2500;\n        }\n    }\n\n    part Chassis {\n        attribute mass : Real;\n    }\n\n    part Engine {\n        attribute mass : Real;\n    }\n\n    part Transmission {\n        attribute mass : Real;\n    }\n\n    constraint DynamicBehavior(\n        mass : Real,\n        force : Real,\n        time : Real,\n        v_initial : Real,\n        v_final : Real\n    ) {\n        mass > 0;\n        force * time = mass * (v_final - v_initial);\n    }\n}",
    "package VehicleMaintenanceSystem {\n\n    import ScalarValues;\n\n    part VehicleSystem {\n        part vehicles: Vehicle[1..*];\n    }\n\n    part Vehicle {\n        attribute nextMaintenanceTime: Time;\n        attribute maintenanceInterval: Duration;\n        attribute maxAllowedTemperature: Temperature;\n        attribute status: VehicleStatus;\n        attribute actualMaintenanceStartTime: Time;\n        attribute previousHealthyStateEndTime: Time;\n        attribute maintenanceDuration: Duration;\n        attribute healthStatus: HealthStatus;\n    }\n\n    enum VehicleStatus {\n        value healthy;\n        value under_maintenance;\n    }\n\n    enum HealthStatus {\n        value normal;\n        value not_normal;\n    }\n\n    constraint DetermineMaintenanceDue {\n        input nextMaintenanceTime: Time;\n        input currentTime: Time;\n        output maintenanceDue: Boolean;\n        maintenanceDue = (currentTime >= nextMaintenanceTime);\n    }\n\n    constraint SwitchToUnderMaintenance {\n        input maintenanceDue: Boolean;\n        input status: VehicleStatus;\n        output newStatus: VehicleStatus;\n        if maintenanceDue then\n            newStatus = VehicleStatus::under_maintenance\n        else\n            newStatus = status;\n    }\n\n    constraint ActualStartAfterScheduled {\n        input actualMaintenanceStartTime: Time;\n        input nextMaintenanceTime: Time;\n        actualMaintenanceStartTime > nextMaintenanceTime;\n    }\n\n    constraint MaintenanceStartWithin2Sec {\n        input actualMaintenanceStartTime: Time;\n        input previousHealthyStateEndTime: Time;\n        (actualMaintenanceStartTime - previousHealthyStateEndTime) <= Duration(2, \"s\");\n    }\n\n    constraint MaintenanceDurationLimit {\n        input maintenanceDuration: Duration;\n        maintenanceDuration <= Duration(48, \"h\");\n    }\n\n    constraint PostponeNextMaintenance {\n        input nextMaintenanceTime: Time;\n        input maintenanceInterval: Duration;\n        output newNextMaintenanceTime: Time;\n        newNextMaintenanceTime = nextMaintenanceTime + maintenanceInterval;\n    }\n\n    constraint RestoreHealthStatus {\n        input status: VehicleStatus;\n        input healthStatus: HealthStatus;\n        output newHealthStatus: HealthStatus;\n        if status = VehicleStatus::under_maintenance then\n            newHealthStatus = HealthStatus::not_normal\n        else\n            newHealthStatus = HealthStatus::normal;\n    }\n\n    type Time specializes ScalarValues::Real;\n    type Duration specializes ScalarValues::Real;\n    type Temperature specializes ScalarValues::Real;\n}",
    "package VehicleSystem {\n\n    part vehicle {\n        attribute curbWeight: Mass;\n        attribute fuelMass: Mass;\n        attribute totalMass: Mass;\n        attribute maxMassLimit: Mass;\n        constraint totalMassConstraint {\n            totalMass = curbWeight + fuelMass;\n            totalMass <= maxMassLimit;\n        }\n        constraint fuelMassConstraint {\n            fuelMass > 0;\n        }\n        part engine {\n            attribute speed: AngularVelocity;\n            attribute torque: Torque;\n            constraint torqueSpeedCurve {\n                // Placeholder for torque-speed curve relationship\n                torque = torqueCurve(speed);\n            }\n            function torqueCurve(s: AngularVelocity): Torque;\n            port engineTorqueOut: Torque;\n        }\n        part clutch {\n            port engineTorqueIn: Torque;\n            port clutchTorqueOut: Torque;\n            constraint clutchTransmission {\n                clutchTorqueOut = engineTorqueIn;\n            }\n        }\n        part transmission {\n            port transmissionTorqueIn: Torque;\n            port transmissionTorqueOut: Torque;\n        }\n        part driveSystem {\n            port driveTorqueIn: Torque;\n        }\n        connector engineToClutch {\n            connect engine.engineTorqueOut to clutch.engineTorqueIn;\n        }\n        connector clutchToTransmission {\n            connect clutch.clutchTorqueOut to transmission.transmissionTorqueIn;\n        }\n        connector transmissionToDriveSystem {\n            connect transmission.transmissionTorqueOut to driveSystem.driveTorqueIn;\n        }\n        constraint smoothPowerDelivery {\n            // Placeholder for smooth power delivery constraint\n            // e.g., no abrupt changes in torque at interfaces\n        }\n    }\n}",
    "requirement VehicleMassWithFullTank {\n    text \"With a full fuel tank, the vehicle’s total mass must not exceed 2000 kg.\"\n    constraint totalMassWithFullTank {\n        vehicle.totalMass <= 2000 kg\n        where vehicle.fuelTank.level == full\n    }\n}\n\nrequirement VehicleMassWithEmptyTank {\n    text \"With an empty fuel tank, the vehicle’s total mass must not exceed 1500 kg.\"\n    constraint totalMassWithEmptyTank {\n        vehicle.totalMass <= 1500 kg\n        where vehicle.fuelTank.level == empty\n    }\n}\n\nrequirement VehicleMassComposition {\n    text \"The sum of the vehicle’s dry mass and fuel mass must meet the maximum allowable mass under different operating conditions.\"\n    constraint massComposition {\n        vehicle.totalMass == vehicle.dryMass + vehicle.fuelTank.fuelMass\n    }\n}\n\nrequirement EngineTorqueTransmission {\n    text \"The engine must be capable of transmitting its generated torque to the transmission via the clutch interface.\"\n    constraint torqueTransmission {\n        engine.outputTorque == clutch.inputTorque\n        clutch.outputTorque == transmission.inputTorque\n    }\n}\n\nrequirement EngineTorquePerformance {\n    text \"The engine is required to deliver the necessary torque according to the speed-torque curve (see Table 1).\"\n    constraint torquePerformance {\n        engine.outputTorque == engine.speedTorqueCurve(engine.speed)\n    }\n}\n\nrequirement VehicleMassControl {\n    text \"The system aims to regulate vehicle mass control.\"\n}\n\nrequirement PowertrainInterfacePerformance {\n    text \"The system aims to regulate the interface and performance of the powertrain, ensuring the safety of vehicle design and the effectiveness of power transmission.\"\n}\n\npart vehicle {\n    part fuelTank {\n        attribute level : enumeration { empty, full }\n        attribute fuelMass : Real\n    }\n    attribute totalMass : Real\n    attribute dryMass : Real\n}\n\npart engine {\n    attribute outputTorque : Real\n    attribute speed : Real\n    function speedTorqueCurve(speed: Real) : Real\n}\n\npart clutch {\n    attribute inputTorque : Real\n    attribute outputTorque : Real\n}\n\npart transmission {\n    attribute inputTorque : Real\n}",
    "package VehicleSystem {\n\n    requirement VehicleMassLimit {\n        text \"The vehicle's total mass must not exceed 2000 kilograms when fully fueled.\"\n        constraint totalMass <= 2000 kg\n    }\n\n    requirement VehicleEmptyMassLimit {\n        text \"The vehicle's empty mass must not exceed 1500 kilograms.\"\n        constraint emptyMass <= 1500 kg\n    }\n\n    requirement EngineTorqueTransmission {\n        text \"The engine must be capable of effectively transmitting its generated torque to the transmission system through a clutch interface.\"\n    }\n\n    requirement EngineTorquePerformance {\n        text \"The torque generated by the engine should vary with speed, conforming to the relevant performance table specifications.\"\n    }\n\n    requirement MassAndPowerInterfaceCompliance {\n        text \"The design of both the vehicle and its engine must meet these critical requirements for mass and power interface to ensure overall vehicle performance and safety.\"\n        refine VehicleMassLimit\n        refine VehicleEmptyMassLimit\n        refine EngineTorqueTransmission\n        refine EngineTorquePerformance\n    }\n\n    part Vehicle {\n        requirement VehicleMassLimit\n        requirement VehicleEmptyMassLimit\n        part engine : Engine\n    }\n\n    part Engine {\n        requirement EngineTorqueTransmission\n        requirement EngineTorquePerformance\n    }\n\n}",
    "requirement VehicleMassLimit {\n    description: \"The actual mass of the vehicle must not exceed the specified limit under defined operating conditions.\"\n    constraint VehicleMassFullTank {\n        description: \"When the fuel tank is full, the total vehicle mass must not exceed 2000 kg.\"\n        expression: (curbMass + fuelMass_full) <= 2000 kg;\n    }\n    constraint VehicleMassEmptyTank {\n        description: \"When the fuel tank is empty, the total vehicle mass must not exceed 1500 kg.\"\n        expression: (curbMass + fuelMass_empty) <= 1500 kg;\n    }\n    note: \"Total vehicle mass is the sum of the vehicle’s curb mass and the fuel mass.\"\n}\n\nrequirement EngineTorqueCapability {\n    description: \"The engine must be capable of generating the specified torque characteristics at various speeds.\"\n    constraint EngineTorqueAtSpeed {\n        description: \"Engine generates required torque at specified speeds.\"\n        expression: engineTorque(speed) >= requiredTorque(speed);\n    }\n}\n\nrequirement TorqueTransmission {\n    description: \"The generated torque must be effectively transmitted to the gearbox through the clutch interface to ensure smooth power delivery.\"\n    constraint ClutchTorqueTransmission {\n        description: \"Clutch transmits engine torque to gearbox without loss of smoothness.\"\n        expression: transmittedTorque == engineTorque;\n    }\n}\n\nrequirement ComplianceWithStandards {\n    description: \"Vehicle mass control and power transmission must comply with design and safety standards.\"\n    refine VehicleMassLimit;\n    refine EngineTorqueCapability;\n    refine TorqueTransmission;\n}",
    "system VehiclePerformanceAnalysisSystem {\n\n    part vehicle: Vehicle;\n    part driveCycle: DriveCycle;\n    part analysisModule: AnalysisModule;\n    part complianceModule: ComplianceModule;\n    part configurationModule: ConfigurationModule;\n\n    interface VehicleAttributes {\n        attribute curbWeight: Mass;\n        attribute payload: Mass;\n        attribute wheelDiameter: Length;\n        attribute transmissionEfficiency: Ratio;\n        attribute fuelEconomyUrban: FuelEconomy;\n        attribute fuelEconomyHighway: FuelEconomy;\n    }\n\n    interface DriveCycleAttributes {\n        attribute timeStamps: Time[];\n        attribute positions: Length[];\n        attribute speeds: Speed[];\n    }\n\n    part Vehicle {\n        attribute curbWeight: Mass;\n        attribute payload: Mass;\n        attribute wheelDiameter: Length;\n        attribute transmissionEfficiency: Ratio;\n        attribute fuelEconomyUrban: FuelEconomy;\n        attribute fuelEconomyHighway: FuelEconomy;\n    }\n\n    part DriveCycle {\n        attribute timeStamps: Time[];\n        attribute positions: Length[];\n        attribute speeds: Speed[];\n    }\n\n    part AnalysisModule {\n        operation calculatePowerDemand(\n            vehicle: Vehicle,\n            driveCycle: DriveCycle\n        ): PowerDemandResult;\n\n        operation calculateAcceleration(\n            driveCycle: DriveCycle\n        ): AccelerationResult;\n\n        operation calculateSpeed(\n            driveCycle: DriveCycle\n        ): SpeedResult;\n\n        operation calculatePosition(\n            driveCycle: DriveCycle\n        ): PositionResult;\n\n        operation calculateFuelEconomy(\n            vehicle: Vehicle,\n            driveCycle: DriveCycle\n        ): FuelEconomyResult;\n    }\n\n    part ComplianceModule {\n        attribute energyConsumptionTarget: EnergyConsumptionTarget;\n        operation verifyCompliance(\n            fuelEconomy: FuelEconomyResult,\n            target: EnergyConsumptionTarget\n        ): ComplianceResult;\n    }\n\n    part ConfigurationModule {\n        operation setVehicleAttributes(\n            attributes: VehicleAttributes\n        );\n        operation setDriveCycle(\n            attributes: DriveCycleAttributes\n        );\n    }\n\n    interface PowerDemandResult {\n        attribute requiredEnginePower: Power[];\n    }\n\n    interface AccelerationResult {\n        attribute acceleration: Acceleration[];\n    }\n\n    interface SpeedResult {\n        attribute speed: Speed[];\n    }\n\n    interface PositionResult {\n        attribute position: Length[];\n    }\n\n    interface FuelEconomyResult {\n        attribute fuelEconomy: FuelEconomy;\n    }\n\n    interface EnergyConsumptionTarget {\n        attribute fuelConsumptionPer100km: FuelEconomy;\n        attribute milesPerGallon: FuelEconomy;\n    }\n\n    interface ComplianceResult {\n        attribute isCompliant: Boolean;\n        attribute details: String;\n    }\n\n    interface Mass { }\n    interface Length { }\n    interface Ratio { }\n    interface FuelEconomy { }\n    interface Time { }\n    interface Speed { }\n    interface Power { }\n    interface Acceleration { }\n    interface Boolean { }\n    interface String { }\n}",
    "system VehicleFuelEconomySimulationAnalysis {\n    \n    part vehicle : Vehicle\n    part scenario : DrivingScenario\n    part analysis : SimulationAnalysis\n\n    requirement FuelEconomyRequirement {\n        text \"The vehicle shall achieve a fuel economy exceeding 30 miles per gallon under urban and highway driving scenarios.\"\n    }\n\n    requirement EnergySavingCompliance {\n        text \"The vehicle design shall meet energy-saving, emissions reduction, and regulatory compliance requirements in real-world use scenarios.\"\n    }\n\n    interface VehicleParameters {\n        attribute curbWeight : mass\n        attribute load : mass\n        attribute wheelDiameter : length\n        attribute transmissionEfficiency : ratio\n        attribute otherParameters : string\n    }\n\n    part user : User\n\n    part result : SimulationResult\n\n    scenario UrbanDriving : DrivingScenario\n    scenario HighwayDriving : DrivingScenario\n\n    constraint CalculateWheelPower {\n        parameter speed : velocity\n        parameter acceleration : acceleration\n        parameter vehicle : Vehicle\n        expression \"wheelPower = vehicle.mass * acceleration * speed / transmissionEfficiency\"\n    }\n\n    constraint CalculateEnergyConsumption {\n        parameter wheelPower : power\n        parameter time : time\n        expression \"energyConsumption = wheelPower * time\"\n    }\n\n    constraint CalculateEnginePowerDemand {\n        parameter energyConsumption : energy\n        parameter efficiency : ratio\n        expression \"enginePowerDemand = energyConsumption / efficiency\"\n    }\n\n    constraint CalculateFuelConsumption {\n        parameter enginePowerDemand : power\n        parameter fuelEnergyDensity : energy_per_volume\n        parameter time : time\n        expression \"fuelConsumption = enginePowerDemand * time / fuelEnergyDensity\"\n    }\n\n    constraint CalculateFuelEconomy {\n        parameter fuelConsumption : volume\n        parameter distance : length\n        expression \"fuelEconomy = (fuelConsumption / distance) * 100\"\n        unit \"liters per 100 kilometers\"\n    }\n\n    part simulation : Simulation {\n        refines scenario\n        refines vehicle\n        refines analysis\n        refines result\n    }\n\n    satisfies FuelEconomyRequirement\n    satisfies EnergySavingCompliance\n}\n\nblock Vehicle {\n    attribute parameters : VehicleParameters\n}\n\nblock DrivingScenario {\n    attribute trajectory : Trajectory\n    attribute speedProfile : SpeedProfile\n}\n\nblock SimulationAnalysis {\n    operation performAnalysis(vehicle : Vehicle, scenario : DrivingScenario) : SimulationResult\n}\n\nblock SimulationResult {\n    attribute fuelConsumption : volume\n    attribute fuelEconomy : ratio\n    attribute complianceStatus : boolean\n}\n\nblock User {\n    operation assessDesign(result : SimulationResult) : boolean\n}\n\nblock Trajectory {\n    attribute path : string\n}\n\nblock SpeedProfile {\n    attribute speedVariations : sequence<velocity>\n}",
    "package EngineSelectionAnalysis {\n\n    part system: System;\n\n    block System {\n        part engineSelectionAnalyzer: EngineSelectionAnalyzer;\n    }\n\n    block EngineSelectionAnalyzer {\n        part engineTypes: EngineType[1..*];\n        part evaluationFunction: EvaluationFunction;\n        part engineSelector: EngineSelector;\n    }\n\n    block EngineType {\n        attribute name: String;\n        attribute power: Real;\n        attribute mass: Real;\n        attribute efficiency: Real;\n        attribute cost: Real;\n    }\n\n    block FourCylinderEngine extends EngineType {\n    }\n\n    block SixCylinderEngine extends EngineType {\n    }\n\n    block EvaluationFunction {\n        input engine: EngineType;\n        output score: Real;\n        constraint calculateScore: score = f(engine.power, engine.mass, engine.efficiency, engine.cost);\n    }\n\n    block EngineSelector {\n        input engines: EngineType[1..*];\n        input scores: Real[1..*];\n        output optimalEngine: EngineType;\n        constraint selectOptimal: optimalEngine = engines[argMax(scores)];\n    }\n\n    constraint f(power: Real, mass: Real, efficiency: Real, cost: Real): Real;\n\n    function argMax(scores: Real[1..*]): Integer;\n\n}",
    "package VehicleQualityAssessment {\n\n    part Vehicle {\n        attribute curbWeight: Real;\n    }\n\n    requirement CurbWeightLimit {\n        text \"The curb weight of each vehicle must be less than or equal to 2,500 kilograms.\";\n    }\n\n    requirement QualityDetectionProcess {\n        text \"The process must have clear steps of data collection, processing, and evaluation to ensure scientific and accurate detection of vehicle quality.\";\n    }\n\n    action CollectWeightData {\n        in vehicle: Vehicle;\n        out collectedWeight: Real;\n    }\n\n    action ProcessWeightData {\n        in collectedWeight: Real;\n        out processedWeight: Real;\n    }\n\n    action EvaluateWeight {\n        in processedWeight: Real;\n        out evaluationResult: EvaluationResult;\n    }\n\n    enumeration EvaluationResult {\n        literal Qualified;\n        literal Unqualified;\n    }\n\n    constraint CurbWeightConstraint {\n        parameter weight: Real;\n        expression \"weight <= 2500\";\n    }\n\n    usecase VehicleCurbWeightAssessment {\n        step collect: CollectWeightData;\n        step process: ProcessWeightData;\n        step evaluate: EvaluateWeight;\n\n        flow {\n            collect.collectedWeight -> process.collectedWeight;\n            process.processedWeight -> evaluate.processedWeight;\n        }\n    }\n\n    satisfies VehicleCurbWeightAssessment -> CurbWeightLimit;\n    satisfies VehicleCurbWeightAssessment -> QualityDetectionProcess;\n    verify EvaluateWeight -> CurbWeightConstraint;\n}",
    "package MassVerificationSystem {\n\n    part Vehicle {\n        attribute mass: Real;\n        constraint mass_nonnegative { mass >= 0; }\n    }\n\n    part WeighingEquipment {\n        operation measure_mass(v: Vehicle): Real;\n    }\n\n    part MassVerificationUnit {\n        operation verify_mass(v: Vehicle, eq: WeighingEquipment): QualificationResult;\n        constraint upper_limit { 0 <= v.mass and v.mass <= 2500; }\n    }\n\n    enum QualificationResult {\n        Qualified,\n        Unqualified\n    }\n\n    part MassVerificationSystem {\n        part vehicles: Vehicle[*];\n        part weighing_equipment: WeighingEquipment;\n        part mass_verification_unit: MassVerificationUnit;\n    }\n\n    usecase MassInspectionProcess {\n        input vehicle: Vehicle;\n        output result: QualificationResult;\n        scenario {\n            measured_mass = weighing_equipment.measure_mass(vehicle);\n            if measured_mass <= 2500 {\n                result = QualificationResult.Qualified;\n            } else {\n                result = QualificationResult.Unqualified;\n            }\n        }\n    }\n\n    requirement MassLimit {\n        text \"The actual mass of each vehicle must not exceed 2,500 kilograms.\";\n    }\n\n    requirement MassInspection {\n        text \"Every vehicle to be inspected must undergo a mass inspection process to check compliance with the upper mass limit.\";\n    }\n\n    requirement IndependentVerification {\n        text \"The mass verification process is carried out independently for each vehicle.\";\n    }\n\n    requirement Compliance {\n        text \"All vehicles involved in verification must comply with relevant standards and regulatory requirements.\";\n    }\n\n}",
    "package TransportationSystem {\n\n    part TransportationSystem {\n        feature driver: Person;\n        feature passengers: Person[0..4];\n        feature vehicle: Vehicle;\n        feature environment: Environment;\n        feature infrastructure: Infrastructure;\n    }\n\n    part Vehicle {\n        feature entryExit: EntryExit;\n        feature rideExperience: RideExperience;\n        feature safety: Safety;\n        feature comfort: Comfort;\n        feature sustainability: Sustainability;\n        feature compatibility: Compatibility;\n    }\n\n    part EntryExit {\n        requirement simpleEntryExit: \"Users can freely enter and exit the vehicle; the process shall be simple and smooth.\";\n    }\n\n    part RideExperience {\n        requirement humanCentered: \"The system’s operation shall be centered on human needs, focusing on ride experience and convenience.\";\n        requirement assistTasks: \"The system shall assist passengers and drivers in smoothly completing daily transportation tasks.\";\n    }\n\n    part Safety {\n        requirement safeTravel: \"The system shall enable users to travel safely from the starting point to the destination.\";\n        requirement considerEnvironment: \"The system shall consider and integrate surrounding environmental factors to ensure safety.\";\n    }\n\n    part Comfort {\n        requirement comfortableTravel: \"The system shall enable users to travel comfortably from the starting point to the destination.\";\n    }\n\n    part Sustainability {\n        requirement sustainableJourney: \"The system shall ensure the sustainability of the entire journey.\";\n    }\n\n    part Compatibility {\n        requirement infrastructureCompatibility: \"The system shall be compatible with related infrastructure such as gas stations.\";\n    }\n\n    part Environment {\n        feature environmentalFactors: EnvironmentalFactor[0..*];\n    }\n\n    part Infrastructure {\n        feature gasStation: GasStation[0..*];\n    }\n\n    part Person {}\n\n    part EnvironmentalFactor {}\n\n    part GasStation {}\n\n}",
    "package TransportationSystem {\n\n    part Vehicle {\n        part driver: Person;\n        part passengers: Person[0..4];\n        part environment: Environment;\n    }\n\n    part GasStation {}\n\n    part StartingPoint {}\n    part Destination {}\n\n    part Person {}\n\n    part Environment {}\n\n    action EnterVehicle {\n        input user: Person;\n        input vehicle: Vehicle;\n        output vehicleOccupied: Boolean;\n    }\n\n    action OperateVehicle {\n        input driver: Person;\n        input vehicle: Vehicle;\n        input environment: Environment;\n        output vehicleInMotion: Boolean;\n    }\n\n    action RefuelVehicle {\n        input vehicle: Vehicle;\n        input gasStation: GasStation;\n        output vehicleFueled: Boolean;\n    }\n\n    action ExitVehicle {\n        input user: Person;\n        input vehicle: Vehicle;\n        output vehicleVacated: Boolean;\n    }\n\n    action Transport {\n        input vehicle: Vehicle;\n        input startingPoint: StartingPoint;\n        input destination: Destination;\n        output transportComplete: Boolean;\n    }\n\n    requirement SafeTransport {\n        text \"The system shall safely transport a driver and up to four passengers from the starting point to the destination.\"\n    }\n\n    requirement SimpleConvenientInteraction {\n        text \"The system shall ensure that interactions among all participants are simple and convenient, meeting the primary needs of daily transportation.\"\n    }\n\n    scenario TransportationProcess {\n        step enterVehicle: EnterVehicle;\n        step operateVehicle: OperateVehicle;\n        step [optional] refuelVehicle: RefuelVehicle;\n        step transport: Transport;\n        step exitVehicle: ExitVehicle;\n    }\n}",
    "package VehicleConfigurationManagement {\n\n    part VehicleProductLine {\n        part vehicles : Vehicle[0..*];\n    }\n\n    part Vehicle {\n        part engine : Engine;\n        part transmission : Transmission;\n    }\n\n    abstract part Engine {\n        attribute cylinderCount : Integer;\n        part cylinders : Cylinder[0..*];\n    }\n\n    part FourCylinderEngine extends Engine {\n        cylinderCount = 4;\n        part cylinders : Cylinder[4];\n    }\n\n    part SixCylinderEngine extends Engine {\n        cylinderCount = 6;\n        part cylinders : Cylinder[6];\n    }\n\n    part Cylinder {\n        attribute diameter : DiameterType;\n    }\n\n    enum DiameterType {\n        literal small = 70;\n        literal large = 100;\n    }\n\n    abstract part Transmission {}\n\n    part ManualTransmission extends Transmission {}\n\n    part AutomaticTransmission extends Transmission {}\n\n    constraint VehicleCombinationConstraint {\n        // Only allow valid engine and transmission combinations\n        ( (engine instanceof FourCylinderEngine and transmission instanceof ManualTransmission)\n          or\n          (engine instanceof FourCylinderEngine and transmission instanceof AutomaticTransmission)\n          or\n          (engine instanceof SixCylinderEngine and transmission instanceof AutomaticTransmission)\n        )\n    }\n\n    constraint CylinderDiameterConstraint {\n        // Each cylinder must have diameter of 70 mm or 100 mm\n        for (c in engine.cylinders) {\n            (c.diameter == DiameterType::small or c.diameter == DiameterType::large)\n        }\n    }\n\n    constraint EngineCylinderCountConstraint {\n        // Engine must have correct number of cylinders\n        ( (engine instanceof FourCylinderEngine and engine.cylinders->size() == 4)\n          or\n          (engine instanceof SixCylinderEngine and engine.cylinders->size() == 6)\n        )\n    }\n}",
    "package EngineSystem {\n\n    part Engine {\n        feature cylinders : Cylinder[4..6];\n        constraint cylinderCount {\n            cylinders->size() = 4 or cylinders->size() = 6;\n        }\n    }\n\n    part Cylinder {\n        attribute diameter : mm;\n        constraint validDiameter {\n            diameter = 70 mm or diameter = 100 mm;\n        }\n    }\n\n    variant FourCylinderEngine specializes Engine {\n        constraint fourCylinders {\n            cylinders->size() = 4;\n        }\n    }\n\n    variant SixCylinderEngine specializes Engine {\n        constraint sixCylinders {\n            cylinders->size() = 6;\n        }\n    }\n\n}",
    "model AutomotiveConfigurationSpace {\n\n    part Vehicle {\n        part engine: Engine;\n        part transmission: Transmission;\n    }\n\n    abstract part Engine {\n        attribute cylinderDiameter: CylinderDiameter;\n    }\n\n    part FourCylinderEngine extends Engine {\n        attribute numberOfCylinders: Integer = 4;\n    }\n\n    part SixCylinderEngine extends Engine {\n        attribute numberOfCylinders: Integer = 6;\n    }\n\n    enum CylinderDiameter {\n        value diameter70mm;\n        value diameter100mm;\n    }\n\n    abstract part Transmission {}\n\n    part ManualTransmission extends Transmission {}\n\n    part AutomaticTransmission extends Transmission {}\n\n    constraint OnlyOneEngineTypePerVehicle {\n        Vehicle.engine isa FourCylinderEngine or Vehicle.engine isa SixCylinderEngine;\n    }\n\n    constraint OnlyOneTransmissionTypePerVehicle {\n        Vehicle.transmission isa ManualTransmission or Vehicle.transmission isa AutomaticTransmission;\n    }\n\n    constraint EngineTransmissionCompatibility {\n        (Vehicle.engine isa FourCylinderEngine and Vehicle.transmission isa ManualTransmission)\n        or\n        (Vehicle.engine isa SixCylinderEngine and Vehicle.transmission isa AutomaticTransmission);\n    }\n}",
    "package SystemModel {\n\n    part SystemAssembly {\n        part computerSubsystem: ComputerSubsystem;\n        part storageSubsystem: StorageSubsystem;\n    }\n\n    part ComputerSubsystem {\n        uses softwareDesign: SoftwareDesign;\n        satisfies allFunctions: SoftwareFunctions;\n    }\n\n    part StorageSubsystem {\n        accesses messageFormat: MessageFormat;\n        accesses dataFormat: DataFormat;\n        compatibleWith softwareDesign: SoftwareDesign;\n    }\n\n    part SoftwareDesign {\n        defines messageFormat: MessageFormat;\n        defines dataFormat: DataFormat;\n        specifies softwareFunctions: SoftwareFunctions;\n    }\n\n    part MessageFormat {\n        conformsTo dataStructureSpecification: DataStructureSpecification;\n    }\n\n    part DataFormat {\n        conformsTo dataStructureSpecification: DataStructureSpecification;\n    }\n\n    part SoftwareFunctions {\n        includes informationStorage: InformationStorage;\n        includes informationTransmission: InformationTransmission;\n        includes informationProcessing: InformationProcessing;\n    }\n\n    part InformationStorage {\n        ensures efficient: Efficiency;\n        ensures reliable: Reliability;\n        ensures compliant: DataStructureSpecification;\n    }\n\n    part InformationTransmission {\n        ensures efficient: Efficiency;\n        ensures reliable: Reliability;\n        ensures compliant: DataStructureSpecification;\n    }\n\n    part InformationProcessing {\n        ensures efficient: Efficiency;\n        ensures reliable: Reliability;\n        ensures compliant: DataStructureSpecification;\n    }\n\n    part DataStructureSpecification {}\n\n    part Efficiency {}\n\n    part Reliability {}\n\n}",
    "system PowertrainManagementSystem {\n    part powertrainSystem: PowertrainSystem;\n}\n\nblock PowertrainSystem {\n    part logicalLayer: LogicalLayer;\n    part physicalLayer: PhysicalLayer;\n}\n\nblock LogicalLayer {\n    part logicalComponent[0..*]: LogicalComponent;\n    part torqueGenerator: TorqueGenerator;\n}\n\nblock PhysicalLayer {\n    part physicalComponent[0..*]: PhysicalComponent;\n    part powerUnit: PowerUnit;\n}\n\nblock LogicalComponent {\n    feature providePower;\n    feature generateTorque;\n}\n\nblock TorqueGenerator extends LogicalComponent {\n    feature convertPowerToTorque;\n}\n\nblock PhysicalComponent {\n    feature integrateFunctions;\n}\n\nblock PowerUnit extends PhysicalComponent {\n    feature powerOutput;\n    feature torqueGeneration;\n}\n\nmapping TorqueGeneratorToPowerUnit {\n    source: LogicalLayer.torqueGenerator;\n    target: PhysicalLayer.powerUnit;\n    rationale: \"Ensures logical torque generation is realized in physical hardware\";\n}\n\nrequirement PowerAndTorqueRequirement {\n    text \"The system shall provide power transmission and torque output capabilities to meet user power performance demands.\";\n}\n\nsatisfy PowerAndTorqueRequirement by PowerUnit;",
    "system PowerTransmissionSystem {\n    requirement ProvidePowerAndTorque {\n        text \"The system shall provide power and generate torque to meet vehicle operational requirements.\"\n    }\n\n    capability DeliverPowerAndGenerateTorque {\n        satisfies ProvidePowerAndTorque\n        feature power: Power\n        feature torque: Torque\n    }\n\n    action GeneratingTorque {\n        output torque: Torque\n        input power: Power\n    }\n\n    part logicalModel {\n        part torqueGenerator: TorqueGenerator {\n            realizes DeliverPowerAndGenerateTorque\n            performs GeneratingTorque\n        }\n    }\n\n    part physicalModel {\n        part powertrain: Powertrain {\n            part engine: Engine {\n                performs GeneratingTorque\n            }\n        }\n    }\n\n    allocate logicalModel.torqueGenerator to physicalModel.powertrain\n    allocate GeneratingTorque to physicalModel.powertrain.engine\n}\n\ntype Power\ntype Torque\n\nblock TorqueGenerator\nblock Powertrain\nblock Engine",
    "package VehicleFeatureAnnotationSystem {\n\n    part VehicleFeatureAnnotationSystem {\n        part vehicle: Vehicle;\n    }\n\n    part Vehicle {\n        part interior: InteriorAssembly;\n        part body: BodyAssembly;\n    }\n\n    part InteriorAssembly {\n        part seatBelts: SeatBelt [1..*];\n        part frontSeats: FrontSeat [2];\n        part driverAirbag: DriverAirbag [1];\n        part alarmSystem: AlarmSystem [1];\n    }\n\n    part BodyAssembly {\n        part bodyShell: BodyShell [1];\n        part bumpers: Bumper [2];\n        part keylessEntryDevice: KeylessEntryDevice [1];\n    }\n\n    part SeatBelt {\n        feature function: SafetyFunction;\n        function = SafetyFunction.safety;\n    }\n\n    part FrontSeat {\n    }\n\n    part DriverAirbag {\n        feature function: SafetyFunction;\n        function = SafetyFunction.safety;\n    }\n\n    part AlarmSystem {\n        feature function: SafetyFunction;\n        function = SafetyFunction.protection;\n    }\n\n    part BodyShell {\n    }\n\n    part Bumper {\n        feature function: SafetyFunction;\n        function = SafetyFunction.safety;\n    }\n\n    part KeylessEntryDevice {\n        feature function: SafetyFunction;\n        function = SafetyFunction.protection;\n    }\n\n    enum SafetyFunction {\n        safety;\n        protection;\n    }\n}",
    "package VehicleDynamicsSimulation {\n\n    part VehicleDynamicsSimulationSystem {\n        feature userInput: UserInput;\n        feature simulationEngine: SimulationEngine;\n        feature modelCenterIntegration: ModelCenterIntegration;\n        feature simulationOutput: SimulationOutput;\n    }\n\n    part UserInput {\n        feature initialVelocity: Real;\n        feature initialPosition: Real;\n        feature acceleration: Real;\n        feature timeStep: Real;\n    }\n\n    part SimulationEngine {\n        feature inputInitialVelocity: Real;\n        feature inputInitialPosition: Real;\n        feature inputAcceleration: Real;\n        feature inputTimeStep: Real;\n        feature outputVelocity: Real;\n        feature outputPosition: Real;\n        constraint calculateVelocityAndPosition {\n            outputVelocity = inputInitialVelocity + inputAcceleration * inputTimeStep;\n            outputPosition = inputInitialPosition + inputInitialVelocity * inputTimeStep + 0.5 * inputAcceleration * inputTimeStep^2;\n        }\n    }\n\n    part ModelCenterIntegration {\n        feature sendToModelCenter: Boolean;\n        feature receiveFromModelCenter: Boolean;\n        constraint integrationWithModelCenter {\n            sendToModelCenter = true;\n            receiveFromModelCenter = true;\n        }\n    }\n\n    part SimulationOutput {\n        feature velocity: Real;\n        feature position: Real;\n        feature simulationResults: SimulationResults;\n    }\n\n    part SimulationResults {\n        feature keyDynamicParameters: KeyDynamicParameters;\n        feature reliableOutput: Boolean;\n        feature accurateDataTransfer: Boolean;\n    }\n\n    part KeyDynamicParameters {\n        feature velocity: Real;\n        feature position: Real;\n    }\n\n    part VehiclePerformanceAnalysis {\n        feature designOptimization: Boolean;\n        feature performanceSupport: Boolean;\n    }\n\n    relate VehicleDynamicsSimulationSystem.userInput to SimulationEngine.inputInitialVelocity;\n    relate VehicleDynamicsSimulationSystem.userInput to SimulationEngine.inputInitialPosition;\n    relate VehicleDynamicsSimulationSystem.userInput to SimulationEngine.inputAcceleration;\n    relate VehicleDynamicsSimulationSystem.userInput to SimulationEngine.inputTimeStep;\n    relate SimulationEngine.outputVelocity to SimulationOutput.velocity;\n    relate SimulationEngine.outputPosition to SimulationOutput.position;\n    relate SimulationOutput.simulationResults to VehiclePerformanceAnalysis;\n    relate SimulationEngine to ModelCenterIntegration;\n}",
    "package CarSafetyCompliance {\n\n    annotation Safety;\n\n    package SafetyFeatures {\n\n        part SeatBelt @Safety {\n            attribute isMandatory: Boolean = true;\n        }\n\n        part Airbag @Safety {\n            attribute isMandatory: Boolean = false;\n            attribute position: String = \"Driver\";\n        }\n\n        part Bumper @Safety {\n            attribute isMandatory: Boolean = true;\n            attribute location: String = \"Body\";\n        }\n\n        part ABS @Safety {\n            attribute isMandatory: Boolean = false;\n        }\n    }\n\n    package MandatorySafetyFeatures {\n\n        part SeatBelt @Safety {\n            attribute isMandatory: Boolean = true;\n        }\n\n        part Bumper @Safety {\n            attribute isMandatory: Boolean = true;\n            attribute location: String = \"Body\";\n        }\n    }\n\n    package Car {\n\n        part interior {\n            part seatBelt1: SeatBelt;\n            part seatBelt2: SeatBelt;\n            part airbag: Airbag;\n        }\n\n        part body {\n            part bumper: Bumper;\n            part keylessEntrySystem {\n                attribute isMandatory: Boolean = false;\n            }\n        }\n\n        part wheelAssembly {\n            part wheel1 {\n                attribute isMandatory: Boolean = true;\n            }\n            part wheel2 {\n                attribute isMandatory: Boolean = true;\n            }\n            part abs: ABS;\n        }\n    }\n}",
    "package VehicleSafetyComplianceSystem {\n\n    part Vehicle {\n        part interior: VehicleInterior;\n        part body: VehicleBody;\n        part chassis: ChassisSystem;\n        part safetyManager: SafetyComplianceManager;\n    }\n\n    part VehicleInterior {\n        part seatBelt1: SeatBelt;\n        part seatBelt2: SeatBelt;\n        part driverAirbag: DriverAirbag;\n    }\n\n    part VehicleBody {\n        part bumper: Bumper;\n        part keylessEntry: KeylessEntrySystem;\n    }\n\n    part ChassisSystem {\n        part tires: Tire[4];\n        part abs: AntiLockBrakingSystem;\n    }\n\n    part SeatBelt {\n        conformsTo SafetyFeature;\n        conformsTo MandatorySafetyFeature;\n    }\n\n    part DriverAirbag {\n        conformsTo SafetyFeature;\n        conformsTo OptionalSafetyFeature;\n    }\n\n    part Bumper {\n        conformsTo SafetyComponent;\n        conformsTo MandatorySafetyComponent;\n    }\n\n    part KeylessEntrySystem {\n        conformsTo ConfigurationFeature;\n        conformsTo OptionalConfiguration;\n    }\n\n    part Tire {\n    }\n\n    part AntiLockBrakingSystem {\n        conformsTo SafetyFeature;\n        conformsTo OptionalSafetyFeature;\n    }\n\n    part SafetyComplianceManager {\n        manages safetyParts: SafetyRelatedPart[*];\n        categorizes required: RequiredSafety;\n        categorizes optional: OptionalSafety;\n    }\n\n    interface SafetyRelatedPart {\n    }\n\n    interface SafetyFeature extends SafetyRelatedPart {\n    }\n\n    interface SafetyComponent extends SafetyRelatedPart {\n    }\n\n    interface ConfigurationFeature extends SafetyRelatedPart {\n    }\n\n    interface MandatorySafetyFeature extends SafetyFeature, RequiredSafety {\n    }\n\n    interface OptionalSafetyFeature extends SafetyFeature, OptionalSafety {\n    }\n\n    interface MandatorySafetyComponent extends SafetyComponent, RequiredSafety {\n    }\n\n    interface OptionalConfiguration extends ConfigurationFeature, OptionalSafety {\n    }\n\n    interface RequiredSafety {\n    }\n\n    interface OptionalSafety {\n    }\n}",
    "package RiskManagementSystem {\n\n    part system: System;\n\n    block System {\n        part riskScenario: RiskScenario[0..*];\n        part situation: Situation[0..*];\n        part cause: Cause[0..*];\n        part failure: Failure[0..*];\n        part user: User[0..*];\n\n        association (riskScenario, situation);\n        association (situation, cause);\n        association (cause, failure);\n        association (user, riskScenario);\n    }\n\n    block RiskScenario {\n        part situation: Situation[1..*];\n        part riskEvaluation: RiskEvaluation[0..*];\n    }\n\n    block Situation {\n        part cause: Cause[0..*];\n        part failure: Failure[0..*];\n        attribute description: String;\n    }\n\n    block Cause {\n        attribute description: String;\n        attribute probability: Real;\n    }\n\n    block Failure {\n        attribute description: String;\n        attribute severityLevel: Integer;\n    }\n\n    block RiskEvaluation {\n        attribute riskLevel: Real;\n        attribute decisionBasis: String;\n    }\n\n    block User {\n        attribute name: String;\n        operation evaluateRisk(scenario: RiskScenario): RiskEvaluation;\n        operation manageRisk(scenario: RiskScenario): Boolean;\n    }\n\n    association CausalRelationship {\n        end source: Situation;\n        end target: Situation;\n        attribute impactMechanism: String;\n        attribute sequenceOrder: Integer;\n    }\n}",
    "package RiskMetadataManagementSystem {\n\n    part System {\n        part ScenarioSet scenarioSets;\n        part RiskScenario riskScenarios;\n    }\n\n    part ScenarioSet {\n        part Scenario scenarios[*];\n    }\n\n    part Scenario {\n        attribute String name;\n        attribute String description;\n        part Cause causes[*];\n        part Failure failures[*];\n        part ScenarioCausalLink causalLinks[*];\n    }\n\n    part Cause {\n        attribute String name;\n        attribute String description;\n        attribute Real probability;\n    }\n\n    part Failure {\n        attribute String name;\n        attribute String description;\n        attribute SeverityLevel severity;\n    }\n\n    enum SeverityLevel {\n        Low,\n        Medium,\n        High,\n        Critical\n    }\n\n    part ScenarioCausalLink {\n        reference Scenario source;\n        reference Scenario target;\n        attribute String description;\n    }\n\n    part RiskScenario {\n        part Scenario involvedScenarios[*];\n        part Cause involvedCauses[*];\n        part Failure involvedFailures[*];\n        attribute String description;\n    }\n\n    interface StandardModelingLanguageCompatible {\n        // Marker for compatibility with standard modeling languages\n    }\n\n    part System implements StandardModelingLanguageCompatible;\n}",
    "system EquipmentRiskAnalysisSystem {\n    part equipment: Equipment;\n    part riskAnalyzer: RiskAnalyzer;\n    part batteryMonitor: BatteryMonitor;\n}\n\nblock Equipment {\n    part battery: Battery;\n}\n\nblock Battery {\n    attribute level: Real;\n    attribute aging: Boolean;\n    attribute minThreshold: Real;\n}\n\nblock BatteryMonitor {\n    reference battery: Battery;\n    operation monitorLevel();\n    operation detectAging();\n    operation detectLowLevel();\n}\n\nblock RiskAnalyzer {\n    operation identifyRisk(scenario: FailureScenario);\n    operation analyzeFailure(scenario: FailureScenario);\n    operation assignSeverity(failure: FailureEvent);\n    operation alertUser(severity: SeverityLevel);\n}\n\nblock FailureScenario {\n    attribute name: String;\n    attribute probability: Real;\n    attribute cause: String;\n    attribute consequence: String;\n}\n\nblock FailureEvent {\n    attribute name: String;\n    attribute severity: SeverityLevel;\n}\n\nenum SeverityLevel {\n    Low,\n    Medium,\n    High,\n    Critical\n}\n\nrequirement ContinuousBatteryMonitoring {\n    text \"The system shall continuously monitor the battery level during operation.\"\n}\n\nrequirement DetectBatteryAging {\n    text \"The system shall detect increased probability of battery failure due to aging or other factors.\"\n}\n\nrequirement IdentifyBatteryAgingRisk {\n    text \"The system shall identify the risk that battery aging may lead to low battery level.\"\n}\n\nrequirement DetectLowBatteryLevel {\n    text \"The system shall determine when the battery level falls below the set minimum threshold and identify the equipment as being in a low battery state.\"\n}\n\nrequirement AnalyzeProlongedLowBattery {\n    text \"If the low battery state persists for a prolonged period without recovery, the device may automatically shut down, resulting in the failure consequence of device shutdown.\"\n}\n\nrequirement AssignSeverityAndAlert {\n    text \"For high-level failures that may cause interruption of critical device functions, the system shall assign an appropriate severity level and alert users and maintenance personnel.\"\n}\n\nrequirement EnsureReliableOperation {\n    text \"The system shall ensure reliable operation of the equipment and meet the normal usage needs of the user by mitigating potential risks.\"\n}\n\nconstraint BatteryLevelThreshold {\n    battery.level >= battery.minThreshold\n}\n\nconstraint ProlongedLowBattery {\n    if (battery.level < battery.minThreshold) {\n        duration > prolongedPeriod\n    }\n}\n\nfailureScenario BatteryAgingLeadsToLowLevel: FailureScenario {\n    name = \"Battery aging leads to low battery level\";\n    cause = \"Battery aging\";\n    consequence = \"Low battery level\";\n}\n\nfailureScenario ProlongedLowBatteryShutdown: FailureScenario {\n    name = \"Prolonged low battery leads to device shutdown\";\n    cause = \"Prolonged low battery\";\n    consequence = \"Device shutdown\";\n}\n\nfailureEvent DeviceShutdown: FailureEvent {\n    name = \"Device shutdown\";\n    severity = SeverityLevel.Critical;\n}",
    "package SystemDecomposition {\n\n    part System {\n        part Subsystem[1..*] subsystems;\n        interface SystemInterface;\n        satisfies SystemDecompositionCapability;\n    }\n\n    part Subsystem {\n        part Component[1..*] components;\n        interface SubsystemInterface;\n        satisfies SubsystemDecompositionCapability;\n    }\n\n    part Component {\n        interface ComponentInterface;\n        satisfies ComponentCapability;\n    }\n\n    interface SystemInterface {\n        end;\n    }\n\n    interface SubsystemInterface {\n        end;\n    }\n\n    interface ComponentInterface {\n        end;\n    }\n\n    requirement SystemDecompositionCapability {\n        text \"The system shall provide a hierarchical structural decomposition into subsystems and components, with explicit top-down structure and well-defined interfaces.\";\n    }\n\n    requirement SubsystemDecompositionCapability {\n        text \"Each subsystem shall be decomposed into components, with explicit structure and well-defined interfaces.\";\n    }\n\n    requirement ComponentCapability {\n        text \"Each component shall have a well-defined interface and its functions and capabilities shall be fully specified.\";\n    }\n\n    requirement InterfaceDefinition {\n        text \"Interfaces between all system elements shall be well defined to enable independent understanding, analysis, and effective collaboration.\";\n    }\n\n    requirement StructuralViewForIVV {\n        text \"The structural decomposition shall enable system engineers and IV&V parties to comprehend, verify, and validate the system’s integrity and modular design, ensuring all functional and performance requirements are met.\";\n    }\n\n    satisfies SystemDecompositionCapability;\n    satisfies InterfaceDefinition;\n    satisfies StructuralViewForIVV;\n}",
    "system AutomotiveSystem {\n    part root: RootComponent;\n}\n\npart RootComponent {\n    part powertrain: PowertrainSubsystem;\n    part chassis: ChassisSubsystem;\n    part body: BodySubsystem;\n    part safety: SafetySubsystem;\n    part infotainment: InfotainmentSubsystem;\n}\n\npart PowertrainSubsystem {\n    part engine: EngineComponent;\n    part transmission: TransmissionComponent;\n}\n\npart ChassisSubsystem {\n    part suspension: SuspensionComponent;\n    part wheels: WheelsComponent;\n    part brakes: BrakesComponent;\n}\n\npart BodySubsystem {\n    part doors: DoorsComponent;\n    part windows: WindowsComponent;\n    part bumpers: BumperComponent;\n    part seatBelts: SeatBeltComponent;\n}\n\npart SafetySubsystem {\n    part seatBelts: SeatBeltComponent;\n    part bumpers: BumperComponent;\n    part airbags: AirbagComponent;\n    part abs: ABSComponent;\n}\n\npart InfotainmentSubsystem {\n    part display: DisplayComponent;\n    part audio: AudioComponent;\n}\n\npart EngineComponent {\n    interface engineIF;\n}\n\npart TransmissionComponent {\n    interface transmissionIF;\n}\n\npart SuspensionComponent {\n    interface suspensionIF;\n}\n\npart WheelsComponent {\n    interface wheelsIF;\n}\n\npart BrakesComponent {\n    interface brakesIF;\n}\n\npart DoorsComponent {\n    interface doorsIF;\n}\n\npart WindowsComponent {\n    interface windowsIF;\n}\n\npart BumperComponent {\n    interface bumperIF;\n    attribute safetyRelated: Boolean = true;\n    attribute safetyStatus: SafetyStatus = mandatory;\n}\n\npart SeatBeltComponent {\n    interface seatBeltIF;\n    attribute safetyRelated: Boolean = true;\n    attribute safetyStatus: SafetyStatus = mandatory;\n}\n\npart AirbagComponent {\n    interface airbagIF;\n    attribute safetyRelated: Boolean = true;\n    attribute safetyStatus: SafetyStatus = optional;\n}\n\npart ABSComponent {\n    interface absIF;\n    attribute safetyRelated: Boolean = true;\n    attribute safetyStatus: SafetyStatus = optional;\n}\n\npart DisplayComponent {\n    interface displayIF;\n    attribute safetyRelated: Boolean = false;\n}\n\npart AudioComponent {\n    interface audioIF;\n    attribute safetyRelated: Boolean = false;\n}\n\nenum SafetyStatus {\n    mandatory,\n    optional\n}\n\nview HierarchyTree {\n    show AutomotiveSystem.root;\n    show RootComponent.powertrain;\n    show RootComponent.chassis;\n    show RootComponent.body;\n    show RootComponent.safety;\n    show RootComponent.infotainment;\n    show PowertrainSubsystem.engine;\n    show PowertrainSubsystem.transmission;\n    show ChassisSubsystem.suspension;\n    show ChassisSubsystem.wheels;\n    show ChassisSubsystem.brakes;\n    show BodySubsystem.doors;\n    show BodySubsystem.windows;\n    show BodySubsystem.bumpers;\n    show BodySubsystem.seatBelts;\n    show SafetySubsystem.seatBelts;\n    show SafetySubsystem.bumpers;\n    show SafetySubsystem.airbags;\n    show SafetySubsystem.abs;\n    show InfotainmentSubsystem.display;\n    show InfotainmentSubsystem.audio;\n}\n\nview SafetyComponentsTable {\n    show BumperComponent.safetyRelated, BumperComponent.safetyStatus;\n    show SeatBeltComponent.safetyRelated, SeatBeltComponent.safetyStatus;\n    show AirbagComponent.safetyRelated, AirbagComponent.safetyStatus;\n    show ABSComponent.safetyRelated, ABSComponent.safetyStatus;\n}\n\nview NonSafetyComponentsTable {\n    show EngineComponent;\n    show TransmissionComponent;\n    show SuspensionComponent;\n    show WheelsComponent;\n    show BrakesComponent;\n    show DoorsComponent;\n    show WindowsComponent;\n    show DisplayComponent;\n    show AudioComponent;\n}\n\nview SafetyComponentsTree {\n    show SafetySubsystem.seatBelts;\n    show SafetySubsystem.bumpers;\n    show SafetySubsystem.airbags;\n    show SafetySubsystem.abs;\n}\n\nview NonSafetyComponentsTree {\n    show PowertrainSubsystem.engine;\n    show PowertrainSubsystem.transmission;\n    show ChassisSubsystem.suspension;\n    show ChassisSubsystem.wheels;\n    show ChassisSubsystem.brakes;\n    show BodySubsystem.doors;\n    show BodySubsystem.windows;\n    show InfotainmentSubsystem.display;\n    show InfotainmentSubsystem.audio;\n}",
    "model AutomotiveDomain {\n    \n    // Fundamental concept: 汽车 (Automobile)\n    // Alias: 汽车 (Car)\n    // Description: Represents a motor vehicle designed for road use, typically having four wheels and powered by an internal combustion engine or electric motor.\n    // Context: Core component in the automotive domain; serves as the basis for defining automotive systems and subsystems.\n    part Automobile as \"汽车 (Car)\" {\n        // Explanatory comment: The Automobile part encapsulates the essential properties and behaviors of a car.\n        // Extensible for future attributes and relationships.\n    }\n\n    // Physical quantity: 扭矩 (Torque)\n    // Description: A measure of the rotational force applied to the automobile's drivetrain.\n    // Context: Used to characterize the performance and mechanical properties of automotive systems.\n    quantity Torque as \"扭矩\" {\n        unit: newtonMeter; // SI unit for torque\n        // Explanatory comment: Torque is a key parameter in evaluating engine and drivetrain performance.\n    }\n\n    // Association: Automobile has Torque\n    // Description: Associates the Automobile with its characteristic torque value.\n    relation AutomobileHasTorque {\n        from: Automobile;\n        to: Torque;\n        // Explanatory comment: This relation standardizes the expression of torque as an attribute of automobiles.\n    }\n}",
    "package AutomobileDocumentManagementPlatform {\n\n    part system: System {\n        part automobileRepository: AutomobileRepository;\n        part userInterface: UserInterface;\n        part physicalQuantityManager: PhysicalQuantityManager;\n        part documentationManager: DocumentationManager;\n    }\n\n    part AutomobileRepository {\n        attribute automobiles: Automobile[*];\n        operation addAutomobile(a: Automobile);\n        operation queryAutomobile(criteria: QueryCriteria): Automobile[*];\n        operation archiveAutomobile(a: Automobile);\n    }\n\n    part UserInterface {\n        operation enterInformation(a: Automobile, info: AutomobileInformation);\n        operation queryInformation(criteria: QueryCriteria): AutomobileInformation[*];\n        operation archiveInformation(a: Automobile, info: AutomobileInformation);\n        operation searchByAlias(alias: Alias): Automobile[*];\n    }\n\n    part PhysicalQuantityManager {\n        attribute supportedQuantities: PhysicalQuantity[*];\n        operation referenceQuantity(q: PhysicalQuantity): QuantityReference;\n    }\n\n    part DocumentationManager {\n        operation addExplanatoryDocument(target: Documentable, doc: ExplanatoryDocument);\n        operation retrieveExplanatoryDocument(target: Documentable): ExplanatoryDocument[*];\n    }\n\n    part Automobile {\n        attribute id: Identifier;\n        attribute information: AutomobileInformation[*];\n        attribute aliases: Alias[*];\n    }\n\n    part AutomobileInformation {\n        attribute name: String;\n        attribute value: String;\n        attribute physicalQuantity: PhysicalQuantity[0..1];\n    }\n\n    part Alias {\n        attribute name: String;\n        attribute refersTo: Automobile;\n    }\n\n    part Car extends Automobile {\n        // Car is an alias for Automobile\n    }\n\n    part PhysicalQuantity {\n        attribute name: String;\n        attribute value: Real;\n        attribute unit: Unit;\n        attribute standard: PhysicalQuantityStandard;\n    }\n\n    part QuantityReference {\n        attribute quantity: PhysicalQuantity;\n        attribute standardReference: String;\n    }\n\n    part ExplanatoryDocument {\n        attribute title: String;\n        attribute content: String;\n        attribute relatedTo: Documentable;\n    }\n\n    part Documentable {\n        // Abstract supertype for objects that can have explanatory documents\n    }\n\n    part QueryCriteria {\n        attribute field: String;\n        attribute value: String;\n    }\n\n    part Identifier {\n        attribute value: String;\n    }\n\n    part Unit {\n        attribute symbol: String;\n        attribute name: String;\n    }\n\n    part PhysicalQuantityStandard {\n        attribute name: String;\n        attribute description: String;\n    }\n\n    // Example: ISQ standard and TorqueValue\n    part ISQ extends PhysicalQuantityStandard {\n        attribute name = \"ISQ\";\n        attribute description = \"International System of Quantities\";\n    }\n\n    part TorqueValue extends PhysicalQuantity {\n        attribute name = \"Torque\";\n        attribute unit = newtonMeter;\n        attribute standard = ISQ;\n    }\n\n    part newtonMeter extends Unit {\n        attribute symbol = \"N·m\";\n        attribute name = \"Newton meter\";\n    }\n}",
    "package AutomobileSystem {\n\n    import ScalarQuantities::*;\n    import TorqueValue as Torque;\n\n    part Automobile {\n        alias Car;\n        attribute torque: Torque;\n        // Additional scalar physical quantities can be added as needed\n    }\n\n}",
    "package VehicleSystem {\n\n    part Vehicle {\n        attribute size: VehicleSize;\n        part engine: Engine;\n    }\n\n    enum VehicleSize {\n        SMALL,\n        STANDARD,\n        LARGE\n    }\n\n    part Engine {\n        attribute cylinderCount: Integer;\n        part[1..*] cylinder: Cylinder;\n    }\n\n    part Cylinder {\n    }\n\n    constraint StandardVehicleCylinderCount {\n        context Vehicle\n        if self.size == VehicleSize::STANDARD then\n            self.engine.cylinderCount >= 4 and self.engine.cylinderCount <= 6\n        endif\n    }\n\n    constraint SmallVehicleCylinderCount {\n        context Vehicle\n        if self.size == VehicleSize::SMALL then\n            self.engine.cylinderCount == 4\n        endif\n    }\n\n    constraint LargeVehicleCylinderCount {\n        context Vehicle\n        if self.size == VehicleSize::LARGE then\n            self.engine.cylinderCount == 6\n        endif\n    }\n\n    constraint EngineCylinderConfiguration {\n        context Engine\n        self.cylinderCount == self.cylinder->size()\n    }\n\n    constraint AutoSelectCylinderCount {\n        context Vehicle\n        if self.size == VehicleSize::SMALL then\n            self.engine.cylinderCount == 4\n        else if self.size == VehicleSize::LARGE then\n            self.engine.cylinderCount == 6\n        else if self.size == VehicleSize::STANDARD then\n            self.engine.cylinderCount >= 4 and self.engine.cylinderCount <= 6\n        endif\n    }\n\n}",
    "package FuelManagementSystem {\n\n    part FuelTank : FuelTank;\n    part Engine : Engine;\n    part FuelSupplyInterface : FuelInterface;\n    part FuelReturnInterface : FuelInterface;\n\n    part FuelFlowManager : FuelFlowManager;\n    part FuelTemperatureManager : FuelTemperatureManager;\n\n    connect FuelTank.out to FuelSupplyInterface.in;\n    connect FuelSupplyInterface.out to Engine.in;\n    connect Engine.out to FuelReturnInterface.in;\n    connect FuelReturnInterface.out to FuelTank.in;\n\n    requirement ManageFuelFlow {\n        text \"The system shall be capable of managing fuel flow, ensuring that fuel can be delivered from the fuel tank to the engine and supporting fuel return.\";\n    }\n\n    requirement MonitorAndManageFuelTemperature {\n        text \"During operation, the system shall monitor and manage the temperature of the fuel.\";\n    }\n\n    requirement RealizeFuelSupplyAndReturn {\n        text \"The system shall realize fuel supply and return through fuel interfaces.\";\n    }\n\n    requirement StandardizedFuelInterfaces {\n        text \"The fuel tank and the engine shall be connected via standardized fuel interfaces to ensure the reliability and safety of fuel flow.\";\n    }\n\n    satisfies ManageFuelFlow by FuelFlowManager;\n    satisfies MonitorAndManageFuelTemperature by FuelTemperatureManager;\n    satisfies RealizeFuelSupplyAndReturn by FuelSupplyInterface, FuelReturnInterface;\n    satisfies StandardizedFuelInterfaces by FuelSupplyInterface, FuelReturnInterface;\n\n}\n\nblock FuelTank {\n    port in;\n    port out;\n}\n\nblock Engine {\n    port in;\n    port out;\n}\n\nblock FuelInterface {\n    port in;\n    port out;\n}\n\nblock FuelFlowManager {\n}\n\nblock FuelTemperatureManager {\n}",
    "model VehicleStructuralArchitecture {\n\n    part Vehicle {\n        attribute mass: Real;\n        part frontAxleAssembly: AxleAssembly;\n        part rearAxleAssembly: AxleAssembly;\n    }\n\n    part AxleAssembly {\n        part axle: Axle;\n        part leftWheel: Wheel;\n        part rightWheel: Wheel;\n    }\n\n    part Axle {\n    }\n\n    part FrontAxle extends Axle {\n        attribute steeringAngle: Real;\n    }\n\n    part Wheel {\n    }\n\n    part NamedWheel extends Wheel {\n        attribute name: String;\n    }\n\n    // Example vehicle configurations\n\n    instance Vehicle_1750kg: Vehicle {\n        mass = 1750;\n        frontAxleAssembly: AxleAssembly {\n            axle: FrontAxle {\n                steeringAngle = 0.0;\n            }\n            leftWheel: Wheel;\n            rightWheel: Wheel;\n        }\n        rearAxleAssembly: AxleAssembly {\n            axle: Axle;\n            leftWheel: Wheel;\n            rightWheel: Wheel;\n        }\n    }\n\n    instance Vehicle_2000kg_NamedWheels: Vehicle {\n        mass = 2000;\n        frontAxleAssembly: AxleAssembly {\n            axle: FrontAxle {\n                steeringAngle = 15.0;\n            }\n            leftWheel: NamedWheel {\n                name = \"FrontLeft\";\n            }\n            rightWheel: NamedWheel {\n                name = \"FrontRight\";\n            }\n        }\n        rearAxleAssembly: AxleAssembly {\n            axle: Axle;\n            leftWheel: NamedWheel {\n                name = \"RearLeft\";\n            }\n            rightWheel: NamedWheel {\n                name = \"RearRight\";\n            }\n        }\n    }\n}"
]