[
    "package VehicleManagementSystem {\n\n    // Vehicle Mass Quantity Kind\n    quantity kind Mass = kilogram;\n\n    // Accelerator Pedal Position Enumeration\n    enum AcceleratorPedalPosition {\n        RELEASED,\n        PARTIALLY_PRESSED,\n        FULLY_PRESSED\n    }\n\n    // Gear Setting Enumeration\n    enum GearSetting {\n        PARK,\n        REVERSE,\n        NEUTRAL,\n        DRIVE,\n        LOW\n    }\n\n    // Vehicle Status Definition\n    structure VehicleStatus {\n        attribute gear: GearSetting;\n        attribute acceleratorPedal: AcceleratorPedalPosition;\n    }\n\n    // Engine Component\n    structure Engine {\n        attribute engineId: String;\n        attribute power: Real; // in kW\n        attribute status: String;\n    }\n\n    // Personnel (Driver) Component\n    structure Personnel {\n        attribute personnelId: String;\n        attribute name: String;\n        attribute role: String;\n    }\n\n    // Vehicle Definition\n    structure Vehicle {\n        attribute vehicleId: String;\n        attribute mass: Mass;\n        attribute status: VehicleStatus;\n        part engine: Engine;\n        reference driver: Personnel[0..1];\n    }\n\n    // System Context\n    system VehicleManagementSystem {\n        part vehicles: Vehicle[0..*];\n        part engines: Engine[0..*];\n        part personnel: Personnel[0..*];\n    }\n}",
    "package VehicleModel {\n\n    // Entity representing personnel (drivers)\n    part Personnel {}\n\n    // Entity representing engine (power device)\n    part Engine {}\n\n    // Abstract vehicle definition\n    part Vehicle {}\n\n    // Manually operated vehicle: has a single driver (Personnel)\n    part ManuallyOperatedVehicle extends Vehicle {\n        part driver: Personnel;\n    }\n\n    // Powered vehicle: has an engine (Engine)\n    part PoweredVehicle extends Vehicle {\n        part engine: Engine;\n    }\n\n    // Manually operated powered vehicle: both manually operated and powered\n    part ManuallyOperatedPoweredVehicle extends ManuallyOperatedVehicle, PoweredVehicle {}\n\n}",
    "package VehicleStructure {\n\n    // Abstract definition for extensibility\n    abstract part VehicleComponent {}\n\n    // Engine component\n    part Engine specializes VehicleComponent {}\n\n    // Transmission component\n    part Transmission specializes VehicleComponent {}\n\n    // Wheel component\n    part Wheel specializes VehicleComponent {}\n\n    // Vehicle definition with compositional relationships and quantity constraints\n    part Vehicle {\n        // One engine\n        part engine: Engine [1];\n\n        // One transmission\n        part transmission: Transmission [1];\n\n        // Four wheels\n        part wheels: Wheel [4];\n    }\n\n}",
    "package VehicleSystem {\n\n    // Abstract definition of Engine\n    part definition Engine {\n        part cylinders: Cylinder[*];\n    }\n\n    // SmallEngine with 4 cylinders\n    part definition SmallEngine specializes Engine {\n        part cylinders: Cylinder[4];\n    }\n\n    // LargeEngine with 6 cylinders\n    part definition LargeEngine specializes Engine {\n        part cylinders: Cylinder[6];\n    }\n\n    // Cylinder definition\n    part definition Cylinder {\n    }\n\n    // Abstract definition of Vehicle\n    part definition Vehicle {\n        part engine: Engine;\n    }\n\n    // SmallVehicle with SmallEngine\n    part definition SmallVehicle specializes Vehicle {\n        part engine: SmallEngine;\n    }\n\n    // LargeVehicle with LargeEngine\n    part definition LargeVehicle specializes Vehicle {\n        part engine: LargeEngine;\n    }\n\n}",
    "package TrafficSignalSystem {\n\n    enum TrafficSignalColor {\n        literal green;\n        literal yellow;\n        literal red;\n    }\n\n    part TrafficSignal {\n        attribute color: TrafficSignalColor;\n    }\n\n    part GreenTrafficSignal specializes TrafficSignal {\n        constraint alwaysGreen {\n            self.color == TrafficSignalColor::green;\n        }\n    }\n\n    part TrafficSignalSystem {\n        part trafficSignal: TrafficSignal;\n        part greenTrafficSignal: GreenTrafficSignal;\n    }\n}",
    "package InformationClassificationManagement {\n\n    enum InformationLevel {\n        Unclassified,\n        Confidential,\n        Secret\n    }\n\n    enum InformationColor {\n        Green,\n        Yellow,\n        Red\n    }\n\n    enum InformationCode {\n        uncl,\n        conf,\n        secr\n    }\n\n    enum GradeLevel {\n        A,\n        B,\n        C,\n        D,\n        F\n    }\n\n    value GradePoint : Real;\n\n    mapping InformationLevelToCode {\n        Unclassified -> uncl,\n        Confidential -> conf,\n        Secret -> secr\n    }\n\n    mapping InformationLevelToColor {\n        Unclassified -> Green,\n        Confidential -> Yellow,\n        Secret -> Red\n    }\n\n    mapping GradeLevelToPoint {\n        A -> 4.0,\n        B -> 3.0,\n        C -> 2.0,\n        D -> 1.0,\n        F -> 0.0\n    }\n\n    part InformationItem {\n        attribute level : InformationLevel;\n        attribute code : InformationCode;\n        attribute color : InformationColor;\n    }\n\n    part GradeItem {\n        attribute grade : GradeLevel;\n        attribute point : GradePoint;\n    }\n\n    requirement InformationClassification {\n        text \"The system shall implement an information classification management mechanism based on the 'traffic light' principle, dividing information into Unclassified, Confidential, and Secret levels, each with a code and color.\"\n    }\n\n    requirement GradeClassification {\n        text \"The system shall support grade classification with levels A, B, C, D, and F, corresponding to 4.0, 3.0, 2.0, 1.0, and 0.0 points, respectively.\"\n    }\n\n    requirement ClearDistinction {\n        text \"The classification of information types and grade scores shall be clearly defined and distinguished in the system for intuitive user identification during operation and management.\"\n    }\n\n    satisfies InformationItem -> InformationClassification;\n    satisfies GradeItem -> GradeClassification;\n    satisfies InformationItem, GradeItem -> ClearDistinction;\n\n}",
    "package VehicleSystem {\n\n   part type Cylinder {\n   }\n\n   part type Engine {\n      part cylinders: Cylinder[4..6];\n   }\n\n   part type Vehicle {\n      part engine: Engine;\n   }\n\n   part type SmallVehicle specializes Vehicle {\n      part engine: Engine {\n         part cylinders: Cylinder[4];\n      }\n   }\n\n   part type LargeVehicle specializes Vehicle {\n      part engine: Engine {\n         part cylinders: Cylinder[6];\n      }\n   }\n}",
    "package VehicleModeling {\n\n    // Quality Attribute definition\n    element QualityAttribute {\n        attribute name: String;\n        attribute value: String;\n    }\n\n    // Fuel definition\n    element Fuel {\n        attribute name: String;\n        attribute type: String;\n    }\n\n    // Personnel definition\n    element Personnel {\n        attribute id: String;\n        attribute name: String;\n        attribute role: String;\n    }\n\n    // FuelTank definition\n    part FuelTank {\n        attribute capacity: Real;\n        reference fuel: Fuel; // Association to Fuel\n    }\n\n    // Driver definition (specialization of Personnel)\n    element Driver specializes Personnel {\n        attribute licenseNumber: String;\n    }\n\n    // Vehicle definition\n    part Vehicle {\n        attribute id: String;\n        attribute model: String;\n        part qualityAttributes: QualityAttribute[0..*];\n        reference driver: Driver; // Association to Driver\n        part fuelTank: FuelTank; // Each vehicle has an independent fuel tank\n    }\n\n    // System definition\n    system VehicleModelingSystem {\n        part vehicles: Vehicle[0..*];\n        part fuels: Fuel[0..*];\n        part personnel: Personnel[0..*];\n    }\n}",
    "package AutomobileWheelAssembly {\n\n    part WheelAssembly {\n        part wheelBearingUnit: WheelBearingUnit;\n        part tire: Tire;\n        part hub: Hub;\n        part boltConnections: BoltConnection[*];\n    }\n\n    part WheelBearingUnit {\n    }\n\n    part Tire {\n        part bead1: Bead;\n        part bead2: Bead;\n        constraint BeadsSealedAndFastened {\n            // The two beads are pressed onto the two rims of the hub\n            bead1.isPressedOnto == hub.rim1;\n            bead2.isPressedOnto == hub.rim2;\n        }\n    }\n\n    part Bead {\n        attribute isPressedOnto: Rim;\n    }\n\n    part Hub {\n        part rim1: Rim;\n        part rim2: Rim;\n        part mountingHoles: BoltMountingHole[*];\n        part threadedHoles: ThreadedHole[*];\n        constraint MountingHolesConnectedToThreadedHoles {\n            // Each mounting hole is connected to a threaded hole via a bolt\n            for (i in 1..mountingHoles.size()) {\n                mountingHoles[i].isConnectedTo == threadedHoles[i];\n            }\n        }\n    }\n\n    part Rim {\n    }\n\n    part BoltMountingHole {\n        attribute isConnectedTo: ThreadedHole;\n    }\n\n    part ThreadedHole {\n    }\n\n    part BoltConnection {\n        part bolt: Bolt;\n        reference mountingHole: BoltMountingHole;\n        reference threadedHole: ThreadedHole;\n        constraint BoltConnectsMountingAndThreadedHole {\n            bolt.passesThrough == mountingHole;\n            bolt.engages == threadedHole;\n        }\n    }\n\n    part Bolt {\n        attribute passesThrough: BoltMountingHole;\n        attribute engages: ThreadedHole;\n    }\n\n}",
    "package FuelManagementSystem {\n\n    part system: FuelManagementSystem {\n        part fuelTank: FuelTankAssembly;\n        part engine: Engine;\n\n        connector supplyConnection: FuelFlowConnector {\n            end tankPort: fuelTank.supplyPort;\n            end enginePort: engine.supplyPort;\n        }\n\n        connector returnConnection: FuelFlowConnector {\n            end engineReturnPort: engine.returnPort;\n            end tankReturnPort: fuelTank.returnPort;\n        }\n\n        interface userInterface: UserInterface;\n    }\n\n    part FuelTankAssembly {\n        port supplyPort: FuelPort {\n            direction: out;\n        }\n        port returnPort: FuelPort {\n            direction: in;\n        }\n        property fuelLevel: Quantity;\n        property temperature: Temperature;\n    }\n\n    part Engine {\n        port supplyPort: FuelPort {\n            direction: in;\n        }\n        port returnPort: FuelPort {\n            direction: out;\n        }\n        property fuelRequirement: Quantity;\n        property temperature: Temperature;\n    }\n\n    interface FuelPort {\n        property flowRate: FlowRate;\n        property temperature: Temperature;\n    }\n\n    connector FuelFlowConnector {\n        end portA: FuelPort;\n        end portB: FuelPort;\n        property temperature: Temperature;\n    }\n\n    interface UserInterface {\n        operation getFuelSupplyData(): FuelData;\n        operation getReturnFlowData(): FuelData;\n        operation getTemperatureData(): Temperature;\n        operation visualizeMonitoring();\n        operation controlFuelFlow(status: ControlStatus);\n    }\n\n    type FuelData {\n        property flowRate: FlowRate;\n        property temperature: Temperature;\n    }\n\n    type Quantity {\n        unit: \"liter\";\n    }\n\n    type FlowRate {\n        unit: \"liter_per_minute\";\n    }\n\n    type Temperature {\n        unit: \"celsius\";\n    }\n\n    enum ControlStatus {\n        START,\n        STOP,\n        ADJUST\n    }\n}",
    "package VehicleConfigurationVariants {\n\n    // Abstract definition of a vehicle component\n    abstract part VehicleComponent {\n        attribute mass: Real;\n    }\n\n    // Tire definition\n    part Tire extends VehicleComponent {\n        // Additional tire-specific attributes can be added here\n    }\n\n    // Axle definition\n    part Axle extends VehicleComponent {\n        // Each axle has two ordered tires\n        part tires: Tire[2] ordered;\n    }\n\n    // Front axle definition\n    part FrontAxle extends Axle {\n        // Additional front axle-specific attributes can be added here\n    }\n\n    // Dedicated front axle with steering angle (variant)\n    part SteeringFrontAxle extends FrontAxle {\n        attribute steeringAngle: Real;\n    }\n\n    // Rear axle definition\n    part RearAxle extends Axle {\n        // Additional rear axle-specific attributes can be added here\n    }\n\n    // Complete vehicle definition\n    part Vehicle extends VehicleComponent {\n        attribute mass: Real = 1750; // default mass in kg\n\n        // Vehicle consists of one front axle and one rear axle\n        part frontAxle: FrontAxle;\n        part rearAxle: RearAxle;\n    }\n\n    // Variant configuration: vehicle1_c1\n    part vehicle1_c1 extends Vehicle {\n        attribute mass: Real = 2000; // overridden mass\n\n        // Replace front axle with a dedicated steering front axle\n        part frontAxle: SteeringFrontAxle {\n            attribute mass: Real = 350; // example override\n            attribute steeringAngle: Real = 35; // example value in degrees\n\n            // Rename tires for this configuration\n            part tires[1]: Tire {\n                attribute mass: Real = 12; // example override\n            }\n            part tires[2]: Tire {\n                attribute mass: Real = 12; // example override\n            }\n        }\n\n        // Rear axle instance with renamed tires\n        part rearAxle: RearAxle {\n            attribute mass: Real = 300; // example override\n\n            part tires[1]: Tire {\n                attribute mass: Real = 10; // example override\n            }\n            part tires[2]: Tire {\n                attribute mass: Real = 10; // example override\n            }\n        }\n    }\n}",
    "package CouplingSystem {\n\n    part Vehicle {\n        // Vehicle does not own a coupling ball; connects via reference to Hitch's ball\n        reference hitch: Hitch;\n    }\n\n    part Trailer {\n        // Trailer connects via reference to Hitch's connector\n        reference hitch: Hitch;\n    }\n\n    part Hitch {\n        // Hitch contains the coupling ball and connector\n        part ball: CouplingBall;\n        part connector: Connector;\n    }\n\n    part CouplingBall {\n        // Represents the physical ball for coupling\n    }\n\n    part Connector {\n        // Represents the connector interface for the trailer\n    }\n\n    association Vehicle_Hitch {\n        end vehicle: Vehicle[1];\n        end hitch: Hitch[1];\n    }\n\n    association Trailer_Hitch {\n        end trailer: Trailer[1];\n        end hitch: Hitch[1];\n    }\n\n    association Hitch_CouplingBall {\n        end hitch: Hitch[1];\n        end ball: CouplingBall[1];\n    }\n\n    association Hitch_Connector {\n        end hitch: Hitch[1];\n        end connector: Connector[1];\n    }\n\n    constraint ModularDetachment {\n        // Each component can be independently detached without affecting others\n        // (Constraint logic can be further specified as needed)\n    }\n\n    composition CouplingSystem {\n        part vehicle: Vehicle;\n        part trailer: Trailer;\n        part hitch: Hitch;\n    }\n}",
    "package VehiclePowerTransmissionSystem {\n\n    // Define interfaces (features)\n    interface PowerPort {}\n    interface ClutchPort {}\n    interface FuelCommandPort {}\n    interface WheelAxleInterface {}\n    interface RoadContactInterface {}\n\n    // Engine block\n    part Engine {\n        in feature fuelCommand: FuelCommandPort;\n        out feature powerOut: PowerPort;\n        out feature clutchOut: ClutchPort;\n    }\n\n    // Clutch block\n    part Clutch {\n        in feature powerIn: PowerPort;\n        in feature clutchIn: ClutchPort;\n        out feature powerOut: PowerPort;\n    }\n\n    // Transmission (Gearbox) block\n    part Transmission {\n        in feature powerIn: PowerPort;\n        out feature powerOut: PowerPort;\n    }\n\n    // Driveshaft block\n    part Driveshaft {\n        in feature powerIn: PowerPort;\n        out feature powerOut: PowerPort;\n    }\n\n    // Differential block\n    part Differential {\n        in feature powerIn: PowerPort;\n        out feature leftPowerOut: PowerPort;\n        out feature rightPowerOut: PowerPort;\n    }\n\n    // Half-shaft block\n    part HalfShaft {\n        in feature powerIn: PowerPort;\n        out feature axleOut: WheelAxleInterface;\n    }\n\n    // Wheel block\n    part Wheel {\n        in feature axleIn: WheelAxleInterface;\n        out feature roadOut: RoadContactInterface;\n    }\n\n    // Road interface block\n    part RoadSurface {\n        in feature wheelContact: RoadContactInterface;\n    }\n\n    // Rear Axle Assembly (composite part)\n    part RearAxleAssembly {\n        part differential: Differential;\n        part leftHalfShaft: HalfShaft;\n        part rightHalfShaft: HalfShaft;\n\n        connect differential.leftPowerOut -> leftHalfShaft.powerIn;\n        connect differential.rightPowerOut -> rightHalfShaft.powerIn;\n    }\n\n    // Rear Wheel Assembly (composite part)\n    part RearWheelAssembly {\n        part leftWheel: Wheel;\n        part rightWheel: Wheel;\n        part leftHalfShaft: HalfShaft;\n        part rightHalfShaft: HalfShaft;\n\n        connect leftHalfShaft.axleOut -> leftWheel.axleIn;\n        connect rightHalfShaft.axleOut -> rightWheel.axleIn;\n    }\n\n    // Main System block\n    part VehiclePowerTransmissionSystem {\n        part engine: Engine;\n        part clutch: Clutch;\n        part transmission: Transmission;\n        part driveshaft: Driveshaft;\n        part rearAxleAssembly: RearAxleAssembly;\n        part leftHalfShaft: HalfShaft;\n        part rightHalfShaft: HalfShaft;\n        part leftWheel: Wheel;\n        part rightWheel: Wheel;\n        part roadSurface: RoadSurface;\n\n        // Power and command flow connections\n        connect engine.fuelCommand -> engine.fuelCommand;\n        connect engine.powerOut -> clutch.powerIn;\n        connect engine.clutchOut -> clutch.clutchIn;\n        connect clutch.powerOut -> transmission.powerIn;\n        connect transmission.powerOut -> driveshaft.powerIn;\n        connect driveshaft.powerOut -> rearAxleAssembly.differential.powerIn;\n        connect rearAxleAssembly.differential.leftPowerOut -> leftHalfShaft.powerIn;\n        connect rearAxleAssembly.differential.rightPowerOut -> rightHalfShaft.powerIn;\n        connect leftHalfShaft.axleOut -> leftWheel.axleIn;\n        connect rightHalfShaft.axleOut -> rightWheel.axleIn;\n        connect leftWheel.roadOut -> roadSurface.wheelContact;\n        connect rightWheel.roadOut -> roadSurface.wheelContact;\n    }\n}",
    "package MultiArchitectureSystem {\n\n    // Interfaces\n    interface pe {}\n    interface pf {}\n\n    // Signal definition\n    signal S {}\n\n    // Component definitions\n    part c1 {\n        port pb : pe\n        port s_out : out S\n        port s_in : in S\n    }\n\n    part c2 {\n        port s_in : in S\n        port s_out : out S\n    }\n\n    part c3 {\n        port pd : pf\n        port s_out : out S\n        port s_in : in S\n    }\n\n    part c4 {\n        port s_in : in S\n        port s_out : out S\n    }\n\n    // First decomposition: Subsystems b11 and b12\n    part b11 {\n        part c1_ref : c1\n        part c2_ref : c2\n\n        // Signal connection between c1 and c2\n        connector c1_to_c2 {\n            end c1_ref.s_out\n            end c2_ref.s_in\n        }\n\n        // Interface binding\n        binding c1_pb_to_pe {\n            end c1_ref.pb\n            end pe\n        }\n    }\n\n    part b12 {\n        part c3_ref : c3\n        part c4_ref : c4\n\n        // Signal connection between c3 and c4\n        connector c3_to_c4 {\n            end c3_ref.s_out\n            end c4_ref.s_in\n        }\n\n        // Interface binding\n        binding c3_pd_to_pf {\n            end c3_ref.pd\n            end pf\n        }\n    }\n\n    // Communication between b11 and b12 via pe and pf\n    connector b11_b12_comm {\n        end b11.c1_ref.pb\n        end b12.c3_ref.pd\n    }\n\n    // Second decomposition: Modules b21 and b22, reusing c1, c2, c3, c4\n    part b21 {\n        part c1_ref : c1\n        part c2_ref : c2\n        part c3_ref : c3\n        part c4_ref : c4\n\n        // Example of reorganized signal connections\n        connector c1_to_c3 {\n            end c1_ref.s_out\n            end c3_ref.s_in\n        }\n        connector c2_to_c4 {\n            end c2_ref.s_out\n            end c4_ref.s_in\n        }\n    }\n\n    part b22 {\n        part c1_ref : c1\n        part c2_ref : c2\n        part c3_ref : c3\n        part c4_ref : c4\n\n        // Example of reorganized signal connections\n        connector c3_to_c1 {\n            end c3_ref.s_out\n            end c1_ref.s_in\n        }\n        connector c4_to_c2 {\n            end c4_ref.s_out\n            end c2_ref.s_in\n        }\n    }\n\n    // Top-level system definition\n    part IntegratedManagementSystem {\n        part b11_ref : b11\n        part b12_ref : b12\n        part b21_ref : b21\n        part b22_ref : b22\n\n        // Communication between b11 and b12\n        connector b11_b12_comm {\n            end b11_ref.c1_ref.pb\n            end b12_ref.c3_ref.pd\n        }\n    }\n}",
    "package automotive_powertrain {\n\n    // Actors\n    actor User\n\n    // Blocks\n    block PowertrainSystem {\n        part engine: Engine\n        part transmission: Transmission\n        part driveshaft: Driveshaft\n        part leftWheel: Wheel\n        part rightWheel: Wheel\n\n        port fuelCommandIn: FuelCommand\n        port engineControlIn: EngineControlCommand\n        port powerOutput: DrivingForce\n\n        // Internal connections\n        connect fuelCommandIn -> engine.fuelCommand\n        connect engine.torqueOutput -> transmission.torqueInput\n        connect transmission.torqueOutput -> driveshaft.torqueInput\n        connect driveshaft.torqueOutput -> leftWheel.torqueInput\n        connect driveshaft.torqueOutput -> rightWheel.torqueInput\n        connect leftWheel.drivingForce, rightWheel.drivingForce -> powerOutput\n        connect engineControlIn -> engine.controlCommand\n    }\n\n    block Engine {\n        port fuelCommand: FuelCommand\n        port controlCommand: EngineControlCommand\n        port torqueOutput: Torque\n\n        stateMachine EngineState {\n            state Off\n            state Starting\n            state Running\n            state Stopping\n\n            transition Off -> Starting when controlCommand = START\n            transition Starting -> Running when ignitionComplete\n            transition Running -> Stopping when controlCommand = STOP\n            transition Stopping -> Off when shutdownComplete\n        }\n\n        constraint torqueGeneration {\n            if (EngineState == Running) {\n                torqueOutput = f(fuelCommand)\n            } else {\n                torqueOutput = 0\n            }\n        }\n    }\n\n    block Transmission {\n        port torqueInput: Torque\n        port torqueOutput: Torque\n\n        constraint amplifyTorque {\n            torqueOutput = torqueInput * gearRatio\n        }\n\n        attribute gearRatio: Real\n    }\n\n    block Driveshaft {\n        port torqueInput: Torque\n        port torqueOutput: Torque\n\n        constraint transmitTorque {\n            torqueOutput = torqueInput\n        }\n    }\n\n    block Wheel {\n        port torqueInput: Torque\n        port drivingForce: DrivingForce\n\n        constraint generateDrivingForce {\n            drivingForce = torqueInput * wheelRadius\n        }\n\n        attribute wheelRadius: Real\n    }\n\n    // Interfaces\n    interface FuelCommand {\n        attribute value: Real\n    }\n\n    interface EngineControlCommand {\n        attribute command: {START, STOP}\n    }\n\n    interface Torque {\n        attribute value: Real\n    }\n\n    interface DrivingForce {\n        attribute value: Real\n    }\n\n    // Use Cases\n    usecase ControlPowerOutput {\n        actor User\n        description \"User controls power output via fuel commands.\"\n    }\n\n    usecase StartEngine {\n        actor User\n        description \"User starts the engine via command.\"\n    }\n\n    usecase StopEngine {\n        actor User\n        description \"User stops the engine via command, suspending powertrain operation.\"\n    }\n\n    // Requirements\n    requirement FunctionalArchitecture {\n        text \"The system implements the functional architecture of an automotive powertrain, including input of fuel commands, engine start-stop control, and support for power transmission and distribution.\"\n    }\n\n    requirement PowerOutputControl {\n        text \"Users can control the system’s power output through fuel commands.\"\n    }\n\n    requirement EngineTorqueGeneration {\n        text \"Once the engine is started, the system generates engine torque according to the fuel command.\"\n    }\n\n    requirement TorqueAmplificationAndDistribution {\n        text \"The torque is sequentially amplified from the engine to the transmission, transmitted to the driveshaft, and distributed to the left and right wheels, enabling control of the vehicle’s driving force.\"\n    }\n\n    requirement EngineShutdown {\n        text \"Users can shut down the engine via a command, triggering cessation of the system’s powertrain. During engine shutdown, generation and transmission of driving force will be suspended.\"\n    }\n\n    // Satisfy relationships\n    satisfy PowertrainSystem -> FunctionalArchitecture\n    satisfy PowertrainSystem.fuelCommandIn -> PowerOutputControl\n    satisfy Engine.torqueGeneration -> EngineTorqueGeneration\n    satisfy Transmission.amplifyTorque, Driveshaft.transmitTorque, Wheel.generateDrivingForce -> TorqueAmplificationAndDistribution\n    satisfy Engine.EngineState, Engine.torqueGeneration -> EngineShutdown\n\n}",
    "package automotive_powertrain_control {\n\n    part system : PowertrainControlSystem {}\n\n    block PowertrainControlSystem {\n        part engine : Engine {}\n        part torqueAmplifier : TorqueAmplifier {}\n        part transmission : Transmission {}\n        part powerDistributor : PowerDistributor {}\n        part driveWheels : DriveWheels {}\n\n        port fuelControlCmdIn : FuelControlCommand [in]\n        port stallSignalIn : StallSignal [in]\n        port wheelTorqueOut : WheelTorque [out]\n\n        constraint seq_control_logic {\n            // Upon receiving a fuel control command, start engine, generate torque, amplify, transmit, distribute\n            (fuelControlCmdIn.received) -> (engine.start) -> (engine.generateTorque) ->\n            (torqueAmplifier.amplify(engine.torque)) ->\n            (transmission.transmit(torqueAmplifier.torque)) ->\n            (powerDistributor.distribute(transmission.torque)) ->\n            (driveWheels.applyTorque(powerDistributor.torque)) ->\n            (wheelTorqueOut = driveWheels.outputTorque)\n        }\n\n        constraint stall_handling {\n            // When stall signal detected, halt relevant processes\n            (stallSignalIn.detected) -> (engine.shutdown) -> (torqueAmplifier.halt) -> (transmission.halt) -> (powerDistributor.halt)\n        }\n\n        constraint start_shutdown_control {\n            // Support engine start and shutdown control\n            (fuelControlCmdIn.start) -> (engine.start)\n            (fuelControlCmdIn.shutdown) -> (engine.shutdown)\n        }\n\n        constraint power_transmission_process {\n            // Ensure power transmission from fuel command to wheel output torque\n            (fuelControlCmdIn.received) -> (wheelTorqueOut.available)\n        }\n\n        constraint efficient_coordinated_delivery {\n            // Ensure efficient and coordinated power delivery\n            (forall t : Time) (wheelTorqueOut(t) >= requiredTorque(t))\n        }\n\n        constraint reliable_response_handling {\n            // Provide reliable power response and handling\n            (wheelTorqueOut.responseTime <= maxAllowedResponseTime)\n            (wheelTorqueOut.variation <= maxAllowedVariation)\n        }\n    }\n\n    block Engine {\n        port start : StartCommand [in]\n        port shutdown : ShutdownCommand [in]\n        port generateTorque : GenerateTorqueCommand [in]\n        port torque : Torque [out]\n    }\n\n    block TorqueAmplifier {\n        port amplify : Torque [in]\n        port torque : Torque [out]\n        port halt : HaltCommand [in]\n    }\n\n    block Transmission {\n        port transmit : Torque [in]\n        port torque : Torque [out]\n        port halt : HaltCommand [in]\n    }\n\n    block PowerDistributor {\n        port distribute : Torque [in]\n        port torque : Torque [out]\n        port halt : HaltCommand [in]\n    }\n\n    block DriveWheels {\n        port applyTorque : Torque [in]\n        port outputTorque : WheelTorque [out]\n    }\n\n    interface FuelControlCommand {}\n    interface StallSignal {}\n    interface StartCommand {}\n    interface ShutdownCommand {}\n    interface GenerateTorqueCommand {}\n    interface HaltCommand {}\n    interface Torque {}\n    interface WheelTorque {}\n\n    value requiredTorque : Real\n    value maxAllowedResponseTime : Real\n    value maxAllowedVariation : Real\n}",
    "package VehiclePowertrainManagementSystem {\n\n    part VehiclePowertrainManagementSystem {\n        part engine: Engine;\n        part transmission: Transmission;\n        part wheels: Wheel[4];\n        part driverInterface: DriverInterface;\n        part controlUnit: ControlUnit;\n    }\n\n    interface FuelInputCommand {\n        in fuelCommand: Real;\n    }\n\n    interface EngineStartSignal {\n        in startSignal: Boolean;\n    }\n\n    interface EngineShutdownSignal {\n        in shutdownSignal: Boolean;\n    }\n\n    interface EngineOutputTorque {\n        out engineTorque: Real;\n    }\n\n    interface TransmissionInputTorque {\n        in inputTorque: Real;\n    }\n\n    interface TransmissionOutputTorque {\n        out outputTorque: Real;\n    }\n\n    interface WheelInputTorque {\n        in wheelTorque: Real;\n    }\n\n    part DriverInterface {\n        provides FuelInputCommand;\n        provides EngineStartSignal;\n        provides EngineShutdownSignal;\n    }\n\n    part Engine {\n        requires FuelInputCommand;\n        requires EngineStartSignal;\n        requires EngineShutdownSignal;\n        provides EngineOutputTorque;\n    }\n\n    part Transmission {\n        requires TransmissionInputTorque;\n        provides TransmissionOutputTorque;\n    }\n\n    part Wheel {\n        requires WheelInputTorque;\n    }\n\n    part ControlUnit {\n        requires FuelInputCommand;\n        requires EngineStartSignal;\n        requires EngineShutdownSignal;\n        controls Engine;\n        controls Transmission;\n        controls Wheel[4];\n    }\n\n    flow VehiclePowertrainFlow {\n        DriverInterface.fuelCommand -> ControlUnit.fuelCommand;\n        DriverInterface.startSignal -> ControlUnit.startSignal;\n        DriverInterface.shutdownSignal -> ControlUnit.shutdownSignal;\n        ControlUnit.fuelCommand -> Engine.fuelCommand;\n        ControlUnit.startSignal -> Engine.startSignal;\n        ControlUnit.shutdownSignal -> Engine.shutdownSignal;\n        Engine.engineTorque -> Transmission.inputTorque;\n        Transmission.outputTorque -> Wheel[1].wheelTorque;\n        Transmission.outputTorque -> Wheel[2].wheelTorque;\n        Transmission.outputTorque -> Wheel[3].wheelTorque;\n        Transmission.outputTorque -> Wheel[4].wheelTorque;\n    }\n\n    constraint PowertrainManagementBehavior {\n        when (EngineStartSignal.startSignal = true) {\n            Engine.engineTorque = f(DriverInterface.fuelCommand);\n            Transmission.outputTorque = g(Engine.engineTorque);\n            for (i in 1..4) {\n                Wheel[i].wheelTorque = h(Transmission.outputTorque, i);\n            }\n        }\n        when (EngineShutdownSignal.shutdownSignal = true) {\n            Engine.engineTorque = 0;\n            Transmission.outputTorque = 0;\n            for (i in 1..4) {\n                Wheel[i].wheelTorque = 0;\n            }\n        }\n    }\n\n    requirement IntegratedManagement {\n        text \"The system shall achieve integrated management of the vehicle powertrain system according to the driver's fuel input command.\";\n    }\n\n    requirement EngineStartBehavior {\n        text \"When the engine start signal is activated, the system shall generate the corresponding engine output torque based on the fuel command, amplify and transmit the torque through the transmission, and distribute the torque to each wheel.\";\n    }\n\n    requirement EngineShutdownBehavior {\n        text \"When the engine shutdown signal is triggered, the relevant power output process shall be terminated.\";\n    }\n\n    requirement AutomaticControlPerformance {\n        text \"The system shall ensure accurate and efficient automatic control in power demand response, torque transmission, and power distribution, enhancing driving experience and energy efficiency.\";\n    }\n\n    satisfy IntegratedManagement by VehiclePowertrainManagementSystem;\n    satisfy EngineStartBehavior by PowertrainManagementBehavior;\n    satisfy EngineShutdownBehavior by PowertrainManagementBehavior;\n    satisfy AutomaticControlPerformance by PowertrainManagementBehavior;\n\n}",
    "package VehicleTrailerPowerConnection {\n\n    import sysml::systems;\n    import sysml::blocks;\n    import sysml::requirements;\n    import sysml::connections;\n    import sysml::states;\n\n    requirement PowerConnectionMechanism {\n        text \"The system shall implement a power connection and disconnection mechanism between a vehicle and a trailer.\"\n    }\n\n    requirement IndependentStructuralFrames {\n        text \"The vehicle and the trailer shall each possess independent structural frames.\"\n    }\n\n    requirement HitchBallOnVehicle {\n        text \"A hitch ball shall be installed on the vehicle frame.\"\n    }\n\n    requirement CouplerOnTrailer {\n        text \"A trailer coupler shall be installed on the trailer frame.\"\n    }\n\n    requirement ConnectionStates {\n        text \"The system shall enable the vehicle and the trailer to be 'connected' or 'disconnected' via the hitching mechanism.\"\n    }\n\n    requirement SafeReliableOperation {\n        text \"The system shall allow users to safely and reliably connect or disconnect the trailer to/from the vehicle.\"\n    }\n\n    requirement FlexibleCombinationSeparation {\n        text \"The system shall achieve flexible combination and separation, meeting user requirements for vehicle and trailer power coupling functions in various scenarios.\"\n    }\n\n    block Vehicle {\n        part frame: VehicleFrame;\n        part hitchBall: HitchBall;\n    }\n\n    block Trailer {\n        part frame: TrailerFrame;\n        part coupler: TrailerCoupler;\n    }\n\n    block VehicleFrame {}\n\n    block TrailerFrame {}\n\n    block HitchBall {}\n\n    block TrailerCoupler {}\n\n    block PowerConnectionSystem {\n        part vehicle: Vehicle;\n        part trailer: Trailer;\n        part hitchingMechanism: HitchingMechanism;\n        part powerCoupling: PowerCoupling;\n    }\n\n    block HitchingMechanism {\n        reference hitchBall: HitchBall;\n        reference coupler: TrailerCoupler;\n    }\n\n    block PowerCoupling {\n        reference vehicle: Vehicle;\n        reference trailer: Trailer;\n    }\n\n    connection hitchConnection between\n        PowerConnectionSystem.vehicle.hitchBall\n        and PowerConnectionSystem.trailer.coupler\n    {}\n\n    connection powerConnection between\n        PowerConnectionSystem.vehicle\n        and PowerConnectionSystem.trailer\n    {}\n\n    stateMachine PowerConnectionStateMachine {\n        state Disconnected {}\n        state Connected {}\n\n        transition connect from Disconnected to Connected {\n            trigger connectRequest;\n        }\n\n        transition disconnect from Connected to Disconnected {\n            trigger disconnectRequest;\n        }\n    }\n\n    satisfies PowerConnectionSystem -> PowerConnectionMechanism;\n    satisfies Vehicle -> IndependentStructuralFrames;\n    satisfies Trailer -> IndependentStructuralFrames;\n    satisfies Vehicle.hitchBall -> HitchBallOnVehicle;\n    satisfies Trailer.coupler -> CouplerOnTrailer;\n    satisfies HitchingMechanism -> ConnectionStates;\n    satisfies PowerConnectionSystem -> SafeReliableOperation;\n    satisfies PowerConnectionSystem -> FlexibleCombinationSeparation;\n\n}",
    "package VehicleTrailerConnectionSystem {\n\n    part VehicleTrailerConnectionSystem {\n        part vehicle: Vehicle;\n        part trailer: Trailer;\n    }\n\n    part Vehicle {\n        part chassis: Chassis;\n        part towBall: TowBall;\n    }\n\n    part Chassis {}\n\n    part TowBall {}\n\n    part Trailer {\n        part trailerFrame: TrailerFrame;\n        part coupler: Coupler;\n    }\n\n    part TrailerFrame {}\n\n    part Coupler {}\n\n    association VehicleHasTowBall {\n        end vehicle: Vehicle;\n        end towBall: TowBall;\n    }\n\n    association TrailerHasCoupler {\n        end trailer: Trailer;\n        end coupler: Coupler;\n    }\n\n    association ChassisHasTowBall {\n        end chassis: Chassis;\n        end towBall: TowBall;\n    }\n\n    association TrailerFrameHasCoupler {\n        end trailerFrame: TrailerFrame;\n        end coupler: Coupler;\n    }\n\n    association VehicleConnectedToTrailer {\n        end vehicle: Vehicle;\n        end trailer: Trailer;\n        property connectionStatus: ConnectionStatus;\n    }\n\n    enum ConnectionStatus {\n        values = { connected, disconnected }\n    }\n\n    action ConnectTrailer {\n        input vehicle: Vehicle;\n        input trailer: Trailer;\n        output connectionStatus: ConnectionStatus;\n        precondition trailer.coupler is not null and vehicle.towBall is not null;\n        postcondition connectionStatus = connected;\n    }\n\n    action DisconnectTrailer {\n        input vehicle: Vehicle;\n        input trailer: Trailer;\n        output connectionStatus: ConnectionStatus;\n        precondition trailer.coupler is not null and vehicle.towBall is not null;\n        postcondition connectionStatus = disconnected;\n    }\n\n    requirement SafeAndReliableConnection {\n        text \"The system shall ensure that the trailer can be safely and reliably coupled to the vehicle when needed, and can be smoothly detached when not required.\"\n    }\n\n    requirement UserConvenience {\n        text \"Users shall be able to conveniently connect or disconnect the trailer via the system.\"\n    }\n\n    usecase HitchTrailer {\n        subject VehicleTrailerConnectionSystem;\n        action ConnectTrailer;\n        description \"Facilitate hitching operation between vehicle and trailer.\"\n    }\n\n    usecase UnhitchTrailer {\n        subject VehicleTrailerConnectionSystem;\n        action DisconnectTrailer;\n        description \"Facilitate unhitching operation between vehicle and trailer.\"\n    }\n}",
    "package TrailerConnectionModel {\n\n    part Vehicle {\n        part chassis: Chassis;\n        part towBall: TowBall;\n    }\n\n    part Trailer {\n        part trailerChassis: Chassis;\n        part coupler: CouplerMechanism;\n    }\n\n    part Chassis {}\n\n    part TowBall {}\n\n    part CouplerMechanism {\n        attribute engaged: Boolean;\n        operation engage(towBall: TowBall);\n        operation disengage();\n    }\n\n    association VehicleHasTowBall {\n        end vehicle: Vehicle[1];\n        end towBall: TowBall[1];\n    }\n\n    association TrailerHasCoupler {\n        end trailer: Trailer[1];\n        end coupler: CouplerMechanism[1];\n    }\n\n    association Connection {\n        end towBall: TowBall[1];\n        end coupler: CouplerMechanism[1];\n    }\n\n    action HitchTrailer {\n        input vehicle: Vehicle;\n        input trailer: Trailer;\n        precondition not trailer.coupler.engaged;\n        postcondition trailer.coupler.engaged;\n        postcondition trailer.coupler engages vehicle.towBall;\n    }\n\n    action UnhitchTrailer {\n        input vehicle: Vehicle;\n        input trailer: Trailer;\n        precondition trailer.coupler.engaged;\n        postcondition not trailer.coupler.engaged;\n        postcondition trailer.coupler disengages vehicle.towBall;\n    }\n\n    requirement DynamicConnectionReferenceModel {\n        text \"The system implements a dynamic connection reference model between a vehicle and a towed trailer.\"\n    }\n\n    requirement VehicleSection {\n        text \"The vehicle section comprises a chassis equipped with a tow ball device.\"\n    }\n\n    requirement TrailerSection {\n        text \"The trailer section includes a trailer chassis and a coupler mechanism.\"\n    }\n\n    requirement CouplerEngagement {\n        text \"The coupler mechanism is able to engage or disengage with the tow ball through its internal structure.\"\n    }\n\n    requirement UserOperation {\n        text \"Users should be able to connect and disconnect the trailer to and from the vehicle (hitching and unhitching operations).\"\n    }\n\n    requirement SecureLatch {\n        text \"When connected, the trailer’s coupler should securely latch onto the vehicle’s tow ball.\"\n    }\n\n    requirement SmoothDisconnection {\n        text \"Disconnection should allow the two to separate smoothly, achieving safe and convenient trailer attachment and detachment.\"\n    }\n\n    satisfies DynamicConnectionReferenceModel by Vehicle, Trailer, Connection;\n    satisfies VehicleSection by Vehicle;\n    satisfies TrailerSection by Trailer;\n    satisfies CouplerEngagement by CouplerMechanism;\n    satisfies UserOperation by HitchTrailer, UnhitchTrailer;\n    satisfies SecureLatch by CouplerMechanism.engage;\n    satisfies SmoothDisconnection by CouplerMechanism.disengage;\n\n}",
    "package FuelSystem {\n\n    part FuelSystem {\n        part fuelTank: FuelTankAssembly;\n        part engine: Engine;\n        part supplyLine: FuelLine;\n        part returnLine: FuelLine;\n        part tempSensor: TemperatureSensor;\n\n        connect fuelTank.supplyPort to supplyLine.inlet;\n        connect supplyLine.outlet to engine.fuelInlet;\n        connect engine.fuelReturn to returnLine.inlet;\n        connect returnLine.outlet to fuelTank.returnPort;\n\n        connect tempSensor.measurePort to supplyLine.measurePoint;\n    }\n\n    part FuelTankAssembly {\n        port supplyPort: FuelSupplyPort;\n        port returnPort: FuelReturnPort;\n    }\n\n    part Engine {\n        port fuelInlet: FuelInPort;\n        port fuelReturn: FuelOutPort;\n    }\n\n    part FuelLine {\n        port inlet: FuelPort;\n        port outlet: FuelPort;\n        port measurePoint: MeasurePort;\n    }\n\n    part TemperatureSensor {\n        port measurePort: MeasurePort;\n        attribute temperature: Real;\n    }\n\n    interface FuelSupplyPort {\n        flow provides fuel: Fuel;\n    }\n\n    interface FuelReturnPort {\n        flow accepts fuel: Fuel;\n    }\n\n    interface FuelInPort {\n        flow accepts fuel: Fuel;\n    }\n\n    interface FuelOutPort {\n        flow provides fuel: Fuel;\n    }\n\n    interface FuelPort {\n        flow fuel: Fuel;\n    }\n\n    interface MeasurePort {\n        flow measures temperature: Real;\n    }\n\n    type Fuel {\n        attribute temperature: Real;\n        attribute pressure: Real;\n        attribute flowRate: Real;\n    }\n\n    requirement FuelSystemRequirements {\n        text \"The system shall provide fuel from the fuel tank to the engine and return excess fuel from the engine to the fuel tank.\"\n        text \"The system shall monitor temperature during fuel flow to ensure safety and efficiency.\"\n        text \"The system shall support interface connections between components for integrated fuel supply routes.\"\n        text \"The system shall ensure stability and reliability of fuel supply during vehicle operation.\"\n    }\n}",
    "package FuelDeliverySystem {\n\n    // Define the main system\n    system FuelDeliverySystem {\n        part storageTank: StorageTank;\n        part fuelPump: FuelPump;\n        part vehicle: Vehicle;\n\n        // Define fuel flow connections\n        connector storageToPump {\n            end source: storageTank.fuelOutput;\n            end target: fuelPump.fuelInput;\n        }\n        connector pumpToVehicle {\n            end source: fuelPump.fuelOutput;\n            end target: vehicle.fuelTank.fuelInput;\n        }\n    }\n\n    // Storage Tank definition\n    block StorageTank {\n        property fuelQuantity: Real;\n        port fuelOutput: FuelFlowPort;\n    }\n\n    // Fuel Pump definition\n    block FuelPump {\n        port fuelInput: FuelFlowPort;\n        port fuelOutput: FuelFlowPort;\n        property pumpStatus: Boolean;\n        property flowRate: Real;\n    }\n\n    // Vehicle definition\n    block Vehicle {\n        part fuelTank: VehicleFuelTank;\n    }\n\n    // Vehicle Fuel Tank definition\n    block VehicleFuelTank {\n        property maxCapacity: Real;\n        property currentLevel: Real;\n        port fuelInput: FuelFlowPort;\n    }\n\n    // Fuel flow port definition\n    flowport FuelFlowPort {\n        direction: inout;\n        feature fuel: Fuel;\n    }\n\n    // Fuel definition\n    block Fuel {\n        property quantity: Real;\n    }\n\n    // Requirements\n    requirement EfficientFuelDelivery {\n        text \"The system shall provide vehicles with efficient fuel delivery services.\";\n    }\n    requirement EndToEndFuelManagement {\n        text \"The system shall manage fuel from storage, through delivery, to vehicle usage.\";\n    }\n    requirement RealTimeMonitoring {\n        text \"The vehicle fuel tank shall monitor maximum capacity and current fuel level in real-time.\";\n    }\n    requirement SafeAccurateDelivery {\n        text \"The system shall ensure timely, safe, and accurate fuel delivery to vehicles.\";\n    }\n}",
    "package AutomobileAssemblyProcess {\n\n    // Block Definitions\n    block VehicleAssembly {\n        part body: Body\n    }\n\n    block Gearbox {\n        // properties and behaviors of Gearbox\n    }\n\n    block Engine {\n        // properties and behaviors of Engine\n    }\n\n    block VehicleWithGearbox {\n        part base: VehicleAssembly\n        part gearbox: Gearbox\n    }\n\n    block FullyAssembledVehicle {\n        part base: VehicleWithGearbox\n        part engine: Engine\n    }\n\n    // Actions (Activities)\n    action InstallGearbox {\n        input inputVehicle: VehicleAssembly\n        input inputGearbox: Gearbox\n        output outputVehicleWithGearbox: VehicleWithGearbox\n\n        do {\n            outputVehicleWithGearbox.base = inputVehicle;\n            outputVehicleWithGearbox.gearbox = inputGearbox;\n        }\n    }\n\n    action InstallEngine {\n        input inputVehicleWithGearbox: VehicleWithGearbox\n        input inputEngine: Engine\n        output outputFullyAssembledVehicle: FullyAssembledVehicle\n\n        do {\n            outputFullyAssembledVehicle.base = inputVehicleWithGearbox;\n            outputFullyAssembledVehicle.engine = inputEngine;\n        }\n    }\n\n    // Assembly Process Sequence\n    activity FinalAssemblyProcess {\n        input initialVehicle: VehicleAssembly\n        input gearbox: Gearbox\n        input engine: Engine\n        output completedVehicle: FullyAssembledVehicle\n\n        do {\n            step1: InstallGearbox(\n                inputVehicle = initialVehicle,\n                inputGearbox = gearbox,\n                outputVehicleWithGearbox = tempVehicleWithGearbox\n            );\n            step2: InstallEngine(\n                inputVehicleWithGearbox = tempVehicleWithGearbox,\n                inputEngine = engine,\n                outputFullyAssembledVehicle = completedVehicle\n            );\n        }\n    }\n\n    // Requirements\n    requirement SequentialAssembly {\n        text \"Gearbox must be installed before engine during final assembly.\"\n    }\n\n    requirement ClearInputsOutputs {\n        text \"Each assembly step must have clear inputs and outputs.\"\n    }\n\n    requirement ComponentIntegrity {\n        text \"The fully assembled vehicle must have independent, functional gearbox and engine units.\"\n    }\n\n    requirement StandardizedProcess {\n        text \"The assembly process must be standardized, orderly, and efficient.\"\n    }\n\n    // Satisfy relationships\n    satisfy FinalAssemblyProcess -> SequentialAssembly\n    satisfy InstallGearbox -> ClearInputsOutputs\n    satisfy InstallEngine -> ClearInputsOutputs\n    satisfy FullyAssembledVehicle -> ComponentIntegrity\n    satisfy FinalAssemblyProcess -> StandardizedProcess\n\n}",
    "package VehicleA_System {\n\n    import sysml::standard;\n\n    // === States ===\n    state VehicleA_OperatingState {\n        state Off;\n        state Starting;\n        state Running;\n        state HealthManagement;\n        state Maintenance;\n        state Degraded;\n        state Normal;\n\n        transition Off_to_Starting {\n            source: Off;\n            target: Starting;\n            trigger: event(start_signal_received) and condition(brake_pedal_pressed);\n        }\n\n        transition Starting_to_Running {\n            source: Starting;\n            target: Running;\n            trigger: event(vehicle_on_signal_received);\n        }\n\n        transition Running_to_HealthManagement {\n            source: Running;\n            target: HealthManagement;\n            trigger: event(health_check_required);\n        }\n\n        transition Running_to_Degraded {\n            source: Running;\n            target: Degraded;\n            trigger: event(over_temperature_detected);\n        }\n\n        transition Degraded_to_Normal {\n            source: Degraded;\n            target: Normal;\n            trigger: event(restore_to_normal_signal_received);\n        }\n\n        transition Running_to_Maintenance {\n            source: Running;\n            target: Maintenance;\n            trigger: event(maintenance_required);\n        }\n\n        transition Maintenance_to_Normal {\n            source: Maintenance;\n            target: Normal;\n            trigger: event(restore_to_normal_signal_received);\n        }\n\n        transition Running_to_Off {\n            source: Running;\n            target: Off;\n            trigger: event(shutdown_signal_received);\n            effect: action(apply_parking_brake);\n        }\n    }\n\n    // === Signals and Events ===\n    signal start_signal_received;\n    signal brake_pedal_pressed;\n    signal vehicle_on_signal_received;\n    signal health_check_required;\n    signal over_temperature_detected;\n    signal restore_to_normal_signal_received;\n    signal maintenance_required;\n    signal shutdown_signal_received;\n    signal over_temperature_signal;\n    signal apply_parking_brake;\n\n    // === Interfaces ===\n    interface HealthMonitor {\n        property temperature: Real;\n        property safety_threshold: Real;\n        operation detect_over_temperature();\n        operation output_temperature();\n    }\n\n    // === Blocks ===\n    block VehicleA {\n        part controller: VehicleA_Controller;\n        part healthMonitor: HealthMonitor;\n        property operatingState: VehicleA_OperatingState;\n\n        operation startUp() {\n            precondition: brake_pedal_pressed and start_signal_received;\n            postcondition: operatingState == Starting;\n        }\n\n        operation run() {\n            precondition: vehicle_on_signal_received;\n            postcondition: operatingState == Running;\n            action: selfCheck() and supplyPower();\n        }\n\n        operation selfCheck();\n        operation supplyPower();\n        operation applyParkingBrake();\n\n        operation monitorHealth() {\n            action: healthMonitor.output_temperature();\n            if (healthMonitor.temperature > healthMonitor.safety_threshold) {\n                send over_temperature_signal;\n                operatingState = Degraded;\n            }\n        }\n    }\n\n    block VehicleA_Controller {\n        property mainControlState: VehicleA_OperatingState;\n        operation switchState(signal: Signal) {\n            action: // Switch main control state in response to signals\n        }\n    }\n\n    // === Requirements ===\n    requirement AutomatedResponse {\n        text: \"The system shall automatically respond to start-up and shut-down signals to control the vehicle's operating states.\";\n    }\n\n    requirement HealthMonitoring {\n        text: \"The system shall monitor vehicle health in real-time, including temperature detection and reporting.\";\n    }\n\n    requirement SafetyControl {\n        text: \"The system shall ensure safe operation by applying the parking brake when exiting the Running state and switching to Degraded mode on over-temperature.\";\n    }\n\n    requirement Maintainability {\n        text: \"The system shall support Maintenance and Degraded states, and allow restoration to Normal state upon receiving a restore-to-normal signal.\";\n    }\n\n    // === Satisfy relationships ===\n    satisfy AutomatedResponse by VehicleA.startUp, VehicleA.run, VehicleA_Controller.switchState;\n    satisfy HealthMonitoring by VehicleA.monitorHealth, HealthMonitor.output_temperature;\n    satisfy SafetyControl by VehicleA.applyParkingBrake, VehicleA.monitorHealth;\n    satisfy Maintainability by VehicleA_OperatingState.Degraded_to_Normal, VehicleA_OperatingState.Maintenance_to_Normal;\n\n}",
    "package VehicleBehaviorSystem {\n\n    import sysml::blocks::*;\n    import sysml::constraints::*;\n    import sysml::states::*;\n    import sysml::signals::*;\n    import sysml::flows::*;\n    import sysml::values::*;\n\n    block VehicleBehaviorSystem {\n        attribute fuel: String;\n        attribute maintenanceInterval: Duration;\n        attribute temperatureThreshold: Real;\n        part vehicle: Vehicle;\n        part controller: VehicleController;\n        flowPort temperatureSensor: out Real;\n    }\n\n    block Vehicle {\n        attribute operationState: VehicleState;\n        attribute healthStatus: HealthStatus;\n        attribute currentTemperature: Real;\n        attribute lastMaintenance: DateTime;\n        attribute maintenanceDue: Boolean;\n        attribute faultDetected: Boolean;\n        port brakePedal: in Boolean;\n        port startSignal: in Boolean;\n        port warningSignal: out Boolean;\n        port statusSignal: out VehicleState;\n        port controlSignal: in ControlCommand;\n        port temperature: out Real;\n        operation selfInspection(): Boolean;\n        operation powerSupply(): Boolean;\n        operation performMaintenance(): Boolean;\n        operation recoverFromFault(): Boolean;\n        operation senseTemperature(): Real;\n        operation detectOverheat(): Boolean;\n        operation switchToDegradedMode(): Boolean;\n        operation ensureSafety(): Boolean;\n    }\n\n    block VehicleController {\n        port receiveWarning: in Boolean;\n        port receiveStatus: in VehicleState;\n        port sendControl: out ControlCommand;\n        operation processSignals(): Boolean;\n        operation startVehicle(): Boolean;\n        operation shutdownVehicle(): Boolean;\n        operation configureAttributes(fuel: String, maintenanceInterval: Duration, temperatureThreshold: Real): Boolean;\n    }\n\n    enum VehicleState {\n        Shutdown,\n        Startup,\n        Normal,\n        Degraded,\n        Maintenance,\n        Fault\n    }\n\n    enum HealthStatus {\n        Healthy,\n        MaintenanceDue,\n        FaultDetected,\n        Recovering\n    }\n\n    enum ControlCommand {\n        Start,\n        Shutdown,\n        Maintenance,\n        Recover\n    }\n\n    constraint StartupCondition {\n        context vehicle: Vehicle;\n        (vehicle.operationState == VehicleState::Shutdown and\n         vehicle.brakePedal and\n         vehicle.startSignal)\n         implies\n         (vehicle.operationState = VehicleState::Startup and\n          vehicle.selfInspection() and\n          vehicle.powerSupply());\n    }\n\n    constraint OverheatDetection {\n        context vehicle: Vehicle;\n        (vehicle.senseTemperature() > vehicle.owner.temperatureThreshold)\n         implies\n         (vehicle.warningSignal = true and\n          vehicle.operationState = VehicleState::Degraded and\n          vehicle.ensureSafety());\n    }\n\n    constraint MaintenanceAndRecovery {\n        context vehicle: Vehicle;\n        (vehicle.maintenanceDue or vehicle.faultDetected)\n         implies\n         (vehicle.performMaintenance() or vehicle.recoverFromFault());\n    }\n\n    constraint RegularMaintenance {\n        context vehicle: Vehicle;\n        (now() - vehicle.lastMaintenance >= vehicle.owner.maintenanceInterval)\n         implies\n         (vehicle.maintenanceDue = true);\n    }\n\n    stateMachine VehicleStateMachine for Vehicle {\n        state Shutdown {\n            transition to Startup when brakePedal and startSignal;\n        }\n        state Startup {\n            entry / selfInspection(); powerSupply();\n            transition to Normal when selfInspection() and powerSupply();\n        }\n        state Normal {\n            transition to Degraded when senseTemperature() > owner.temperatureThreshold;\n            transition to Maintenance when maintenanceDue;\n            transition to Fault when faultDetected;\n        }\n        state Degraded {\n            entry / warningSignal = true; ensureSafety();\n            transition to Normal when recoverFromFault();\n        }\n        state Maintenance {\n            entry / performMaintenance();\n            transition to Normal when not maintenanceDue;\n        }\n        state Fault {\n            entry / recoverFromFault();\n            transition to Normal when not faultDetected;\n        }\n    }\n\n    stateMachine ControllerStateMachine for VehicleController {\n        state Idle {\n            transition to Controlling when receiveStatus != VehicleState::Shutdown;\n        }\n        state Controlling {\n            entry / processSignals();\n            transition to Idle when receiveStatus == VehicleState::Shutdown;\n        }\n    }\n\n    interface TemperatureSensor {\n        flow temperature: out Real;\n    }\n\n    interface WarningSignal {\n        flow warning: out Boolean;\n    }\n\n    interface ControlSignal {\n        flow control: in ControlCommand;\n    }\n\n    interface StatusSignal {\n        flow status: out VehicleState;\n    }\n\n    Vehicle implements TemperatureSensor;\n    Vehicle implements WarningSignal;\n    Vehicle implements ControlSignal;\n    Vehicle implements StatusSignal;\n\n    VehicleController implements ControlSignal;\n    VehicleController implements StatusSignal;\n    VehicleController implements WarningSignal;\n\n}",
    "package VehicleDynamicsSimulation {\n\n    import ScalarValues::*;\n    import SI::*;\n\n    // Fundamental types\n    type Mass specializes Real;\n    type Position specializes Real[3]; // x, y, z\n    type Velocity specializes Real[3];\n    type Acceleration specializes Real[3];\n    type Angle specializes Real; // radians\n    type FrictionCoefficient specializes Real; // dimensionless\n\n    // Vehicle State enumeration\n    enumeration VehicleState {\n        On,\n        Driving,\n        Off\n    }\n\n    // Vehicle definition\n    part Vehicle {\n        attribute mass: Mass;\n        attribute position: Position;\n        attribute velocity: Velocity;\n        attribute acceleration: Acceleration;\n        attribute state: VehicleState;\n    }\n\n    // Road definition\n    part Road {\n        attribute slopeAngle: Angle;\n        attribute surfaceFriction: FrictionCoefficient;\n    }\n\n    // Snapshot of simulation at a specific time\n    part Snapshot {\n        attribute time: Time;\n        part vehicle: Vehicle;\n        part road: Road;\n    }\n\n    // Simulation time series\n    part Simulation {\n        attribute startTime: Time;\n        attribute endTime: Time;\n        attribute timeStep: Time;\n        part snapshots: Snapshot[*];\n    }\n\n    // User interaction\n    interface User {\n        operation defineVehicleParameters(\n            mass: Mass,\n            position: Position,\n            velocity: Velocity,\n            acceleration: Acceleration\n        );\n        operation defineRoadParameters(\n            slopeAngle: Angle,\n            surfaceFriction: FrictionCoefficient\n        );\n        operation runSimulation(\n            startTime: Time,\n            endTime: Time,\n            timeStep: Time\n        );\n        operation recordSnapshot(time: Time);\n        operation getVehicleState(time: Time): VehicleState;\n        operation getSimulationData(): Simulation;\n    }\n\n    // System definition\n    system VehicleDynamicsSimulationSystem {\n        part simulation: Simulation;\n        part user: User;\n    }\n\n    // Requirements\n    requirement SpatiotemporalSimulation {\n        text \"The system shall simulate the dynamic behavior of vehicles on roads at different moments in time.\";\n    }\n    requirement ParameterDefinition {\n        text \"The system shall allow users to define vehicle mass, position, velocity, acceleration, road slope angle, and surface friction coefficient.\";\n    }\n    requirement StateTracking {\n        text \"The system shall support snapshot recording at multiple moments to track vehicle state transitions (on, driving, off).\";\n    }\n    requirement DataSupport {\n        text \"The system shall provide detailed data for vehicle dynamics analysis and road adaptability assessment.\";\n    }\n    requirement PerformancePrediction {\n        text \"The system shall help users predict vehicle performance under specific road and time conditions in a virtual environment.\";\n    }\n\n    // Satisfy relationships\n    satisfy SpatiotemporalSimulation by VehicleDynamicsSimulationSystem;\n    satisfy ParameterDefinition by User;\n    satisfy StateTracking by Simulation;\n    satisfy DataSupport by Simulation;\n    satisfy PerformancePrediction by VehicleDynamicsSimulationSystem;\n\n}",
    "package AutomotiveConfigManagement {\n\n    part Automobile {\n        part subsystemA: SubsystemA;\n        part subsystemB: SubsystemB;\n    }\n\n    part SubsystemA {\n        feature config: SubsystemAConfig;\n    }\n\n    part SubsystemB {\n        feature config: SubsystemBConfig;\n    }\n\n    part Component1 {}\n    part Component2 {}\n    part Component3 {}\n    part Component4 {}\n    part Component5 {}\n    part Component6 {}\n\n    // SubsystemA Configurations\n    specialization SubsystemAConfig1 specializes SubsystemAConfig {\n        part c1: Component1;\n        part c2: Component2;\n    }\n\n    specialization SubsystemAConfig2 specializes SubsystemAConfig {\n        part c2: Component2;\n        part c3: Component3;\n    }\n\n    abstract part SubsystemAConfig {}\n\n    // SubsystemB Configurations\n    specialization SubsystemBConfig1 specializes SubsystemBConfig {\n        part c4: Component4;\n        part c5: Component5;\n    }\n\n    specialization SubsystemBConfig2 specializes SubsystemBConfig {\n        part c5: Component5;\n        part c6: Component6;\n    }\n\n    abstract part SubsystemBConfig {}\n\n    // Constraint: If SubsystemA selects Config2, then SubsystemB must select Config2, or SubsystemA must not be Config2\n    constraint SubsystemConfigConstraint {\n        input aConfig: SubsystemAConfig;\n        input bConfig: SubsystemBConfig;\n        assert ( (aConfig instanceOf SubsystemAConfig2) implies (bConfig instanceOf SubsystemBConfig2) );\n    }\n\n    // Predefined Vehicle Configurations\n    specialization ConfigurationA specializes Automobile {\n        subsystemA.config: SubsystemAConfig1;\n        subsystemB.config: SubsystemBConfig1;\n    }\n\n    specialization ConfigurationB specializes Automobile {\n        subsystemA.config: SubsystemAConfig2;\n        subsystemB.config: SubsystemBConfig1;\n    }\n}",
    "package ModularVehiclePlatform {\n\n    // Abstract Component Definition\n    abstract part Component {}\n\n    // Concrete Components\n    part Part1 specializes Component {}\n\n    part Part2 specializes Component {}\n\n    part Part3 specializes Component {\n        port p1\n    }\n\n    part Part4 specializes Component {}\n\n    part Part5 specializes Component {\n        port p2\n        // Behavioral Variants\n        behavior variant VariantA {}\n        behavior variant VariantB {}\n    }\n\n    part Part6 specializes Component {}\n\n    // Abstract Subsystem Definition\n    abstract part Subsystem {\n        port s_port\n        // Allow allocation of components\n        part allocatedComponents: Component[0..*]\n    }\n\n    // Subsystem A with flexible internal structure\n    part SubsystemA specializes Subsystem {\n        // Variant selection for internal components\n        part internalComponents: Component[1..*]\n        port a_port specializes s_port\n    }\n\n    // Subsystem B with flexible internal structure\n    part SubsystemB specializes Subsystem {\n        part internalComponents: Component[1..*]\n        port b_port specializes s_port\n    }\n\n    // System-level definition\n    part ModularVehicleSystem {\n        // Subsystems\n        part subsysA: SubsystemA\n        part subsysB: SubsystemB\n\n        // Interconnection for functional interoperability\n        connector Interconnect {\n            end a: subsysA.a_port\n            end b: subsysB.b_port\n        }\n\n        // System-level constraints for configuration consistency\n        constraint Consistency {\n            // Example: No duplicate allocation of the same component instance\n            for all c in (subsysA.internalComponents + subsysB.internalComponents) {\n                count((subsysA.internalComponents + subsysB.internalComponents), c) <= 1\n            }\n        }\n    }\n\n    // Configuration Schemes\n    configuration VehicleConfigA {\n        use ModularVehicleSystem as system\n        // Example configuration: assign components to subsystems\n        assign system.subsysA.internalComponents = { Part1, Part3 }\n        assign system.subsysB.internalComponents = { Part2, Part5 }\n        // Select behavioral variant for Part5\n        assign system.subsysB.internalComponents[Part5].variant = VariantA\n        // Parameter customization example\n        assign system.subsysA.parameterX = 42\n    }\n\n    configuration VehicleConfigB {\n        use ModularVehicleSystem as system\n        assign system.subsysA.internalComponents = { Part4, Part6 }\n        assign system.subsysB.internalComponents = { Part3, Part5 }\n        assign system.subsysB.internalComponents[Part5].variant = VariantB\n        assign system.subsysB.parameterY = \"Eco\"\n    }\n\n    // Parameters for customization (example)\n    property parameterX: Integer\n    property parameterY: String\n\n}",
    "package VehicleProductLineConfig {\n\n    // Block Definitions\n    block VehicleProductLineConfigSystem {\n        part vehicleModels: VehicleModel[1..*];\n        part configEngine: Engine;\n        part configTransmission: Transmission;\n        part configWheels: Wheels;\n        attribute userPreferences: UserPreferences;\n        attribute performanceRequirement: PerformanceRequirement;\n    }\n\n    block VehicleModel {\n        attribute modelName: String;\n        part engine: Engine;\n        part transmission: Transmission;\n        part wheels: Wheels;\n    }\n\n    block Engine {\n        attribute type: EngineType;\n        attribute cylinders: Integer;\n    }\n\n    enum EngineType {\n        value Inline4;\n        value V6;\n        value V8;\n    }\n\n    block Transmission {\n        attribute type: TransmissionType;\n    }\n\n    enum TransmissionType {\n        value Manual;\n        value Automatic;\n    }\n\n    block Wheels {\n        attribute rimWidth: RimWidthType;\n    }\n\n    enum RimWidthType {\n        value Narrow;\n        value Wide;\n    }\n\n    block UserPreferences {\n        attribute preferredEngine: EngineType;\n        attribute preferredTransmission: TransmissionType;\n        attribute preferredWheels: RimWidthType;\n    }\n\n    enum PerformanceRequirement {\n        value High;\n        value Standard;\n        value Custom;\n    }\n\n    // Requirements\n    requirement FlexibleConfiguration {\n        text \"The system shall provide flexible solutions for vehicle product line configuration, supporting multiple model variants and user customization.\"\n    }\n\n    requirement AutomaticMatching {\n        text \"The system shall automatically match suitable combinations of engines, transmissions, and wheels based on performance requirements and user preferences.\"\n    }\n\n    requirement HighPerformanceConfig {\n        text \"For high performance, the system shall configure a 6-cylinder engine, automatic transmission, and wide-rim wheels, ensuring component compatibility.\"\n    }\n\n    requirement StandardPerformanceConfig {\n        text \"For standard performance, the system shall configure a 4-cylinder engine, manual transmission, and narrow-rim wheels.\"\n    }\n\n    requirement ConfigurationConstraints {\n        text \"The system shall enforce configuration constraints to ensure each configuration meets vehicle performance and component compatibility requirements.\"\n    }\n\n    requirement Customization {\n        text \"The system shall enable customized vehicles tailored to individual user needs.\"\n    }\n\n    requirement ProductLineExpansion {\n        text \"The system shall support selection of multiple vehicle model variants for flexible product line expansion and management.\"\n    }\n\n    // Constraints\n    constraint HighPerformanceCombination {\n        context VehicleProductLineConfigSystem\n        expression:\n            (performanceRequirement == PerformanceRequirement::High) implies\n            (configEngine.cylinders == 6 and\n             configEngine.type == EngineType::V6 and\n             configTransmission.type == TransmissionType::Automatic and\n             configWheels.rimWidth == RimWidthType::Wide);\n    }\n\n    constraint StandardPerformanceCombination {\n        context VehicleProductLineConfigSystem\n        expression:\n            (performanceRequirement == PerformanceRequirement::Standard) implies\n            (configEngine.cylinders == 4 and\n             configEngine.type == EngineType::Inline4 and\n             configTransmission.type == TransmissionType::Manual and\n             configWheels.rimWidth == RimWidthType::Narrow);\n    }\n\n    constraint ComponentCompatibility {\n        context VehicleProductLineConfigSystem\n        expression:\n            // Example: Wide-rim wheels only allowed with V6 or V8 engines\n            (configWheels.rimWidth == RimWidthType::Wide) implies\n            (configEngine.type == EngineType::V6 or configEngine.type == EngineType::V8);\n    }\n\n    constraint CustomizationSupport {\n        context VehicleProductLineConfigSystem\n        expression:\n            // User preferences can override standard configurations if compatible\n            (performanceRequirement == PerformanceRequirement::Custom) implies\n            (configEngine.type == userPreferences.preferredEngine and\n             configTransmission.type == userPreferences.preferredTransmission and\n             configWheels.rimWidth == userPreferences.preferredWheels);\n    }\n\n    // Relationships\n    satisfies VehicleProductLineConfigSystem -> FlexibleConfiguration;\n    satisfies VehicleProductLineConfigSystem -> AutomaticMatching;\n    satisfies VehicleProductLineConfigSystem -> HighPerformanceConfig;\n    satisfies VehicleProductLineConfigSystem -> StandardPerformanceConfig;\n    satisfies VehicleProductLineConfigSystem -> ConfigurationConstraints;\n    satisfies VehicleProductLineConfigSystem -> Customization;\n    satisfies VehicleProductLineConfigSystem -> ProductLineExpansion;\n\n}",
    "package AutomobileSystem {\n\n    // Domain Concepts\n    part Vehicle {\n        attribute mass: Real;\n        attribute maxMass: Real;\n        attribute fuelStatus: FuelStatusKind;\n        part engine: Engine;\n        part transmission: Transmission;\n        part driveInterface: DriveInterface;\n        attribute reliability: Reliability;\n    }\n\n    enum FuelStatusKind {\n        FULL,\n        EMPTY\n    }\n\n    part Engine {\n        attribute torqueOutput: Real;\n    }\n\n    part Transmission {\n        // Transmission-specific attributes can be added here\n    }\n\n    part DriveInterface {\n        // Represents the connection between engine and transmission\n        reference engine: Engine;\n        reference transmission: Transmission;\n    }\n\n    part Reliability {\n        attribute performance: Real;\n        attribute durability: Real;\n    }\n\n    // Requirements\n    requirement ManageVehicleSpecifications {\n        text \"The system shall define and manage primary specifications and performance requirements for automobiles, including vehicle mass, fuel status, powertrain, and reliability.\"\n    }\n\n    requirement MassGrades {\n        text \"The system shall support vehicles with different mass grades, such as 2000 kg and 2500 kg.\"\n    }\n\n    requirement ActualMassCompliance {\n        text \"Each vehicle shall reflect its actual mass and comply with the corresponding maximum mass limitations to prevent overloading.\"\n    }\n\n    requirement FuelStatusRegulation {\n        text \"The system shall regulate fuel status, requiring some vehicles to meet mass requirements when fully fueled, while others are accepted in an empty-fuel state.\"\n    }\n\n    requirement PowerDeliveryFunctionality {\n        text \"Vehicles shall have power delivery functionality, requiring the engine to output torque and be connected to the transmission via a drive interface to ensure reliable power transfer.\"\n    }\n\n    requirement ReliabilityTracking {\n        text \"For specific models, the system shall track and fulfill reliability requirements, ensuring specified performance and durability throughout the vehicle lifecycle.\"\n    }\n\n    requirement StandardizedManagement {\n        text \"The system shall support standardized management and quality control of vehicles throughout design, testing, and practical application.\"\n    }\n\n    // Requirement Decomposition and Allocation\n    satisfy ManageVehicleSpecifications with Vehicle;\n    satisfy MassGrades with Vehicle.mass, Vehicle.maxMass;\n    satisfy ActualMassCompliance with Vehicle.mass, Vehicle.maxMass;\n    satisfy FuelStatusRegulation with Vehicle.fuelStatus;\n    satisfy PowerDeliveryFunctionality with Vehicle.engine, Vehicle.transmission, Vehicle.driveInterface, Engine.torqueOutput;\n    satisfy ReliabilityTracking with Vehicle.reliability;\n    satisfy StandardizedManagement with Vehicle, Engine, Transmission, DriveInterface, Reliability;\n\n    // Validation\n    testCase ValidateMassCompliance {\n        text \"Test that vehicle actual mass does not exceed maximum mass.\"\n        verify ActualMassCompliance;\n    }\n\n    testCase ValidateFuelStatus {\n        text \"Test that vehicle mass requirements are met for specified fuel status (full or empty).\"\n        verify FuelStatusRegulation;\n    }\n\n    testCase ValidatePowerDelivery {\n        text \"Test that engine outputs torque and is connected to transmission via drive interface.\"\n        verify PowerDeliveryFunctionality;\n    }\n\n    testCase ValidateReliability {\n        text \"Test that vehicle reliability meets specified performance and durability requirements.\"\n        verify ReliabilityTracking;\n    }\n}",
    "package VehicleMassCompliance {\n\n    import ScalarValues::*;\n    import CommonElements::*;\n\n    // Value definitions\n    value MaximumPermissibleMass: Mass = 2500 kg;\n\n    // Block definitions\n    block Vehicle {\n        attribute actualMass: Mass;\n        attribute complianceStatus: ComplianceStatus;\n    }\n\n    enum ComplianceStatus {\n        Compliant,\n        NonCompliant\n    }\n\n    block WeighingEquipment {\n        operation measureMass(vehicle: Vehicle): Mass;\n    }\n\n    block TestOperator {\n        operation operate(equipment: WeighingEquipment, vehicle: Vehicle): Mass;\n    }\n\n    block MassComplianceSystem {\n        part weighingEquipment: WeighingEquipment;\n        part testOperator: TestOperator;\n        part vehicles: Vehicle[*];\n\n        operation verifyCompliance(vehicle: Vehicle): ComplianceStatus {\n            measuredMass: Mass = testOperator.operate(weighingEquipment, vehicle);\n            if measuredMass <= MaximumPermissibleMass {\n                vehicle.complianceStatus = ComplianceStatus::Compliant;\n            } else {\n                vehicle.complianceStatus = ComplianceStatus::NonCompliant;\n            }\n            return vehicle.complianceStatus;\n        }\n\n        operation testAllVehicles(): ComplianceStatus[*] {\n            results: ComplianceStatus[*];\n            for v in vehicles {\n                result: ComplianceStatus = verifyCompliance(v);\n                results += result;\n            }\n            return results;\n        }\n    }\n\n    // Requirement definitions\n    requirement MassComplianceVerification {\n        text \"The system shall verify that the actual mass of each tested vehicle does not exceed the specified maximum permissible mass of 2,500 kilograms.\";\n    }\n\n    requirement MassMeasurement {\n        text \"Each participating vehicle shall have its actual mass measured using weighing equipment operated by a test operator.\";\n    }\n\n    requirement ComplianceDetermination {\n        text \"If the vehicle's actual mass is less than or equal to the maximum permissible mass, it shall be considered compliant; otherwise, it shall be deemed non-compliant.\";\n    }\n\n    requirement SequentialTesting {\n        text \"The system shall support sequential testing and result determination for multiple vehicles.\";\n    }\n\n    // Satisfy relationships\n    satisfy MassComplianceSystem -> MassComplianceVerification;\n    satisfy MassComplianceSystem -> MassMeasurement;\n    satisfy MassComplianceSystem -> ComplianceDetermination;\n    satisfy MassComplianceSystem -> SequentialTesting;\n\n}",
    "package WaterSupplyNetwork {\n\n    // Block Definitions\n    block SpigotBank {\n        part hotOutlet: Spigot\n        part coldOutlet: Spigot\n    }\n\n    block Spigot {\n        port waterOut: WaterPort\n    }\n\n    block Faucet {\n        part hotInlet: FaucetInlet\n        part coldInlet: FaucetInlet\n    }\n\n    block FaucetInlet {\n        port waterIn: WaterPort\n    }\n\n    interface WaterPort {\n        // Flow property for water\n        flow water: Water\n    }\n\n    value type Water {\n        // Placeholder for water properties (e.g., temperature)\n        property temperature: Real\n    }\n\n    // System Context\n    block WaterSupplySystem {\n        part mainSupply: SpigotBank\n        part faucets: Faucet[1..*]\n    }\n\n    // Connections\n    association HotWaterConnection {\n        end mainSupply: SpigotBank\n        end faucets: Faucet[1..*]\n    }\n\n    association ColdWaterConnection {\n        end mainSupply: SpigotBank\n        end faucets: Faucet[1..*]\n    }\n\n    // Requirements\n    requirement ReliableDelivery {\n        text \"The system shall reliably deliver hot and cold water from the respective outlets of the main supply pipe to the corresponding inlets of all downstream faucets, ensuring simultaneous supply to multiple water usage points.\"\n    }\n\n    requirement CorrectConnection {\n        text \"The system shall guarantee correct connection and smooth transmission of the hot and cold water pipelines, meeting the requirements for distributed hot and cold water supply.\"\n    }\n\n    // Requirement Satisfaction\n    satisfies WaterSupplySystem -> ReliableDelivery\n    satisfies WaterSupplySystem -> CorrectConnection\n\n    // Usage\n    composition WaterSupplySystemUsage {\n        part supplySystem: WaterSupplySystem\n\n        // Connect hot water\n        connect supplySystem.mainSupply.hotOutlet.waterOut to supplySystem.faucets.hotInlet.waterIn\n\n        // Connect cold water\n        connect supplySystem.mainSupply.coldOutlet.waterOut to supplySystem.faucets.coldInlet.waterIn\n    }\n}",
    "package VehicleQualityAnalysisSystem {\n\n    // Key Components\n    part Vehicle {\n        part engine: Engine;\n        part transmission: Transmission;\n        part frontAxle: FrontAxleAssembly;\n        part rearAxle: RearAxleAssembly;\n    }\n\n    part Engine {\n        attribute mass: Real;\n        attribute qualityData: QualityData;\n    }\n\n    part Transmission {\n        attribute mass: Real;\n        attribute qualityData: QualityData;\n    }\n\n    part FrontAxleAssembly {\n        attribute mass: Real;\n        attribute qualityData: QualityData;\n    }\n\n    part RearAxleAssembly {\n        attribute mass: Real;\n        attribute qualityData: QualityData;\n    }\n\n    // Quality Data Structure\n    structure QualityData {\n        attribute defectRate: Real;\n        attribute reliability: Real;\n        attribute durability: Real;\n        attribute otherMetrics: String;\n    }\n\n    // System Functions\n    action InputQualityData {\n        input component: Component;\n        input data: QualityData;\n        output updatedComponent: Component;\n    }\n\n    action AggregateMass {\n        input vehicle: Vehicle;\n        output totalMass: Real;\n    }\n\n    action DefineQualityAnalysisRequirement {\n        input requirement: QualityAnalysisRequirement;\n        output registeredRequirement: QualityAnalysisRequirement;\n    }\n\n    action FormulateAnalysisUseCase {\n        input useCase: AnalysisUseCase;\n        output registeredUseCase: AnalysisUseCase;\n    }\n\n    action GenerateAnalysisTaskAndPlan {\n        input objective: AnalysisObjective;\n        output tasks: AnalysisTask[];\n        output plan: AnalysisPlan;\n    }\n\n    action EvaluateVehicleQuality {\n        input vehicle: Vehicle;\n        input requirements: QualityAnalysisRequirement[];\n        output evaluationReport: QualityEvaluationReport;\n    }\n\n    action TrackRequirements {\n        input requirements: QualityAnalysisRequirement[];\n        input evaluationReport: QualityEvaluationReport;\n        output trackingStatus: TrackingStatus;\n    }\n\n    // Supporting Structures\n    structure QualityAnalysisRequirement {\n        attribute description: String;\n        attribute targetValue: Real;\n        attribute metric: String;\n    }\n\n    structure AnalysisUseCase {\n        attribute name: String;\n        attribute description: String;\n    }\n\n    structure AnalysisObjective {\n        attribute description: String;\n        attribute target: String;\n    }\n\n    structure AnalysisTask {\n        attribute name: String;\n        attribute description: String;\n    }\n\n    structure AnalysisPlan {\n        attribute tasks: AnalysisTask[];\n        attribute schedule: String;\n    }\n\n    structure QualityEvaluationReport {\n        attribute summary: String;\n        attribute results: String;\n    }\n\n    structure TrackingStatus {\n        attribute status: String;\n        attribute details: String;\n    }\n\n    // User Interaction\n    actor User;\n\n    usecase InputComponentQualityData {\n        actor User;\n        action InputQualityData;\n    }\n\n    usecase CalculateTotalVehicleMass {\n        actor User;\n        action AggregateMass;\n    }\n\n    usecase DefineQualityRequirements {\n        actor User;\n        action DefineQualityAnalysisRequirement;\n    }\n\n    usecase FormulateAnalysisUseCases {\n        actor User;\n        action FormulateAnalysisUseCase;\n    }\n\n    usecase GenerateAnalysisTasksAndPlans {\n        actor User;\n        action GenerateAnalysisTaskAndPlan;\n    }\n\n    usecase EvaluateAndTrackQuality {\n        actor User;\n        action EvaluateVehicleQuality;\n        action TrackRequirements;\n    }\n\n    // System Purpose\n    requirement ScientificSupportForDesign {\n        text \"The system shall provide scientific support for vehicle design and performance optimization, improving development efficiency and product performance.\";\n    }\n}",
    "package VehiclePowertrainConfigurationSystem {\n\n    import sysml::common;\n    import sysml::analysis;\n    import sysml::requirements;\n\n    requirement PowertrainOptimization {\n        text \"The system shall provide optimal solutions for vehicle powertrain configuration, focusing on trade-off analysis of engine types to select the best engine configuration across multiple key performance indicators: power, mass, efficiency, reliability, and cost.\"\n    }\n\n    requirement EngineStructureModeling {\n        text \"The system shall support modeling of various engine structures, such as four-cylinder and six-cylinder engines, and automatically assemble related components including cylinders, pistons, connecting rods, and crankshafts.\"\n    }\n\n    requirement MultiAttributeTradeoff {\n        text \"The system shall use a multi-attribute trade-off analysis method and a pre-defined evaluation model to comprehensively assess the performance data of different engine schemes.\"\n    }\n\n    requirement OptimalEngineRecommendation {\n        text \"The system shall automatically recommend the optimal engine solution based on evaluation results, ensuring the best balance between vehicle performance and economy.\"\n    }\n\n    requirement DecisionTransparency {\n        text \"The system shall allow users to view explanations on the rationality of the engine selection, ensuring decision transparency and traceability.\"\n    }\n\n    performanceIndicator Power;\n    performanceIndicator Mass;\n    performanceIndicator Efficiency;\n    performanceIndicator Reliability;\n    performanceIndicator Cost;\n\n    part VehiclePowertrainConfigurationSystem {\n        part engineSelector: EngineSelector;\n        part engineModelLibrary: EngineModelLibrary;\n        part tradeoffAnalyzer: TradeoffAnalyzer;\n        part evaluationModel: EvaluationModel;\n        part recommendationModule: RecommendationModule;\n        part explanationModule: ExplanationModule;\n    }\n\n    part EngineSelector {\n        reference engineModels: EngineModelLibrary;\n        operation selectOptimalEngine();\n    }\n\n    part EngineModelLibrary {\n        part fourCylinderEngine: Engine;\n        part sixCylinderEngine: Engine;\n        // Additional engine types can be added here\n    }\n\n    part Engine {\n        part cylinders: Cylinder[*];\n        part pistons: Piston[*];\n        part connectingRods: ConnectingRod[*];\n        part crankshaft: Crankshaft;\n        attribute numberOfCylinders: Integer;\n        attribute engineType: String;\n        attribute power: Power;\n        attribute mass: Mass;\n        attribute efficiency: Efficiency;\n        attribute reliability: Reliability;\n        attribute cost: Cost;\n    }\n\n    part Cylinder {}\n    part Piston {}\n    part ConnectingRod {}\n    part Crankshaft {}\n\n    part TradeoffAnalyzer {\n        operation analyzeTradeoffs(engineSet: Engine[*]): TradeoffResult;\n    }\n\n    part EvaluationModel {\n        operation evaluate(engine: Engine): EvaluationResult;\n    }\n\n    part RecommendationModule {\n        operation recommend(engineEvaluations: EvaluationResult[*]): Engine;\n    }\n\n    part ExplanationModule {\n        operation provideExplanation(selectedEngine: Engine, evaluationData: EvaluationResult): Explanation;\n    }\n\n    type TradeoffResult {\n        attribute scores: Map<Engine, Real>;\n    }\n\n    type EvaluationResult {\n        attribute engine: Engine;\n        attribute power: Power;\n        attribute mass: Mass;\n        attribute efficiency: Efficiency;\n        attribute reliability: Reliability;\n        attribute cost: Cost;\n        attribute overallScore: Real;\n    }\n\n    type Explanation {\n        attribute rationale: String;\n        attribute traceabilityLinks: String;\n    }\n\n    usecase \"Configure Powertrain\" {\n        actor User;\n        subject VehiclePowertrainConfigurationSystem;\n        step \"User selects vehicle requirements\";\n        step \"System models candidate engine structures\";\n        step \"System assembles engine components\";\n        step \"System evaluates engine schemes\";\n        step \"System performs trade-off analysis\";\n        step \"System recommends optimal engine\";\n        step \"System provides explanation and traceability\";\n    }\n\n    satisfies PowertrainOptimization by VehiclePowertrainConfigurationSystem;\n    satisfies EngineStructureModeling by EngineModelLibrary;\n    satisfies MultiAttributeTradeoff by TradeoffAnalyzer;\n    satisfies OptimalEngineRecommendation by RecommendationModule;\n    satisfies DecisionTransparency by ExplanationModule;\n\n}",
    "package VehicleFuelEconomy {\n\n    import ScalarValues::*;\n    import Units::*;\n\n    unit us_gallon : Volume = 231 * cubic_inch;\n    unit mile_per_us_gallon : FuelEconomy = mile / us_gallon;\n\n    quantity kind FuelEconomy inherits ScalarValue {\n        unit mile_per_us_gallon;\n    }\n\n    quantity kind Mass inherits ScalarValue {\n        unit pound;\n    }\n\n    quantity kind Distance inherits ScalarValue {\n        unit mile;\n    }\n\n    quantity kind Volume inherits ScalarValue {\n        unit us_gallon;\n    }\n\n    requirement FuelEconomyRegulatoryCompliance {\n        text \"The system shall ensure that vehicle fuel economy meets relevant regulatory and performance requirements for both urban and highway driving conditions.\"\n    }\n\n    requirement UrbanFuelEconomyMinimum {\n        text \"Under urban driving conditions, the vehicle’s range per gallon must not be less than 25 miles.\"\n        satisfies FuelEconomyRegulatoryCompliance;\n    }\n\n    requirement HighwayFuelEconomyMinimum {\n        text \"Under highway driving conditions, the vehicle’s range per gallon must not be less than 30 miles.\"\n        satisfies FuelEconomyRegulatoryCompliance;\n    }\n\n    requirement FuelEconomyMeasurementStandard {\n        text \"Fuel economy is measured in miles per US gallon (231 cubic inches).\"\n        satisfies FuelEconomyRegulatoryCompliance;\n    }\n\n    requirement TestLoadCondition {\n        text \"Fuel economy tests are conducted with the vehicle assuming an additional load of 1,000 pounds, under standard urban and highway driving scenarios respectively.\"\n        satisfies FuelEconomyRegulatoryCompliance;\n    }\n\n    requirement FuelEconomyAssessment {\n        text \"The system shall model and analyze key parameters such as vehicle powertrain, load, and operating conditions, supporting fuel consumption assessment under various conditions to ensure that the designed vehicle can achieve the regulatory fuel economy targets for both urban and highway scenarios.\"\n        satisfies FuelEconomyRegulatoryCompliance;\n    }\n\n    constraint UrbanFuelEconomyConstraint {\n        parameter fuelEconomyUrban : FuelEconomy;\n        expression fuelEconomyUrban >= 25 * mile_per_us_gallon;\n    }\n\n    constraint HighwayFuelEconomyConstraint {\n        parameter fuelEconomyHighway : FuelEconomy;\n        expression fuelEconomyHighway >= 30 * mile_per_us_gallon;\n    }\n\n    constraint TestLoadConstraint {\n        parameter testLoad : Mass;\n        expression testLoad == 1000 * pound;\n    }\n\n    scenario UrbanFuelEconomyTest {\n        description \"Test scenario for measuring urban fuel economy with 1,000 pound load.\"\n        parameter testLoad : Mass = 1000 * pound;\n        parameter fuelEconomyUrban : FuelEconomy;\n        satisfies UrbanFuelEconomyMinimum;\n        satisfies TestLoadCondition;\n        constraint UrbanFuelEconomyConstraint;\n        constraint TestLoadConstraint;\n    }\n\n    scenario HighwayFuelEconomyTest {\n        description \"Test scenario for measuring highway fuel economy with 1,000 pound load.\"\n        parameter testLoad : Mass = 1000 * pound;\n        parameter fuelEconomyHighway : FuelEconomy;\n        satisfies HighwayFuelEconomyMinimum;\n        satisfies TestLoadCondition;\n        constraint HighwayFuelEconomyConstraint;\n        constraint TestLoadConstraint;\n    }\n\n    part Vehicle {\n        attribute powertrain;\n        attribute load : Mass;\n        attribute operatingCondition;\n    }\n\n    part FuelEconomyAssessmentSystem {\n        part vehicle : Vehicle;\n        satisfies FuelEconomyAssessment;\n    }\n}",
    "package VehicleLongitudinalDynamicsSimulation {\n\n    import ScalarValues::*;\n    import SI::*;\n\n    part VehicleLongitudinalDynamicsSystem {\n        property mass: Mass;\n        property initialPosition: Length;\n        property initialVelocity: Velocity;\n        property powerOutputSegments: PowerOutputSegmentSet;\n        property timeStep: Duration;\n        property accelerationSequence: AccelerationSequence;\n        property velocitySequence: VelocitySequence;\n        property positionSequence: PositionSequence;\n    }\n\n    part PowerOutputSegmentSet {\n        property segments: PowerOutputSegment[1..*];\n    }\n\n    part PowerOutputSegment {\n        property startTime: Time;\n        property endTime: Time;\n        property power: Power;\n    }\n\n    part AccelerationSequence {\n        property values: Acceleration[1..*];\n        property times: Time[1..*];\n    }\n\n    part VelocitySequence {\n        property values: Velocity[1..*];\n        property times: Time[1..*];\n    }\n\n    part PositionSequence {\n        property values: Length[1..*];\n        property times: Time[1..*];\n    }\n\n    constraint VehicleDynamicsCalculation {\n        input mass: Mass;\n        input initialPosition: Length;\n        input initialVelocity: Velocity;\n        input powerOutputSegments: PowerOutputSegmentSet;\n        input timeStep: Duration;\n        output accelerationSequence: AccelerationSequence;\n        output velocitySequence: VelocitySequence;\n        output positionSequence: PositionSequence;\n\n        // Pseudocode for constraint logic (SysML v2 allows for constraint expressions)\n        // For each time step t:\n        //   1. Determine power P(t) from powerOutputSegments\n        //   2. Calculate force F(t) = P(t) / v(t)\n        //   3. Calculate acceleration a(t) = F(t) / mass\n        //   4. Update velocity v(t+1) = v(t) + a(t) * timeStep\n        //   5. Update position x(t+1) = x(t) + v(t) * timeStep + 0.5 * a(t) * timeStep^2\n        //   6. Store a(t), v(t), x(t) in respective sequences\n    }\n\n    requirement SimulateAndAnalyzeLongitudinalDynamics {\n        text \"The system shall simulate and analyze the longitudinal dynamic characteristics of vehicle motion by accepting user inputs for vehicle mass, initial position, initial velocity, and segmented power output data. It shall calculate acceleration, velocity, and position at each time step using dynamic equations, and output the sequences of acceleration, velocity, and displacement for the entire motion process.\"\n    }\n\n    satisfies VehicleLongitudinalDynamicsSystem -> SimulateAndAnalyzeLongitudinalDynamics;\n\n    usecase VehiclePerformanceAnalysis {\n        text \"Analyze vehicle performance using simulation results.\"\n    }\n\n    usecase ControlStrategyDevelopment {\n        text \"Develop control strategies based on simulation data.\"\n    }\n\n    usecase DrivingBehaviorEvaluation {\n        text \"Evaluate driving behavior using motion analysis outputs.\"\n    }\n\n    VehicleLongitudinalDynamicsSystem supports VehiclePerformanceAnalysis;\n    VehicleLongitudinalDynamicsSystem supports ControlStrategyDevelopment;\n    VehicleLongitudinalDynamicsSystem supports DrivingBehaviorEvaluation;\n\n}",
    "package VehicleSystemModel {\n\n    part VehicleSystem {\n        attribute mass: Real = 2500.0; // kg\n\n        part frontAxleAssembly: FrontAxleAssembly;\n        part rearAxleAssembly: RearAxleAssembly;\n    }\n\n    part FrontAxleAssembly {\n        attribute mass: Real = 150.0; // kg\n\n        part frontLeftWheel: Wheel;\n        part frontRightWheel: Wheel;\n        part frontAxle: FrontAxle;\n    }\n\n    part RearAxleAssembly {\n        attribute mass: Real = 250.0; // kg\n\n        part rearLeftWheel: Wheel;\n        part rearRightWheel: Wheel;\n        part rearAxle: RearAxle;\n    }\n\n    part FrontAxle {\n        attribute mass: Real;\n        attribute steeringAngle: Real; // degrees\n    }\n\n    part RearAxle {\n        attribute mass: Real;\n    }\n\n    part Wheel {\n        // Additional attributes can be defined as needed\n    }\n}",
    "package VehicleSafetySecuritySystem {\n\n    // Feature Kinds\n    enum FeatureKind {\n        values: safety, security\n    }\n\n    // Mandatoriness\n    enum Mandatoriness {\n        values: mandatory, optional\n    }\n\n    // Abstract Feature\n    abstract part Feature {\n        attribute kind: FeatureKind;\n        attribute mandatoriness: Mandatoriness;\n    }\n\n    // Safety Features\n    part SeatBelt extends Feature {\n        kind = FeatureKind.safety;\n        mandatoriness = Mandatoriness.mandatory;\n    }\n\n    part Bumper extends Feature {\n        kind = FeatureKind.safety;\n        mandatoriness = Mandatoriness.mandatory;\n    }\n\n    part Airbag extends Feature {\n        kind = FeatureKind.safety;\n        mandatoriness = Mandatoriness.optional;\n    }\n\n    part AntiLockBrakingSystem extends Feature {\n        kind = FeatureKind.safety;\n        mandatoriness = Mandatoriness.optional;\n    }\n\n    // Security Features\n    part AlarmDevice extends Feature {\n        kind = FeatureKind.security;\n        mandatoriness = Mandatoriness.mandatory;\n    }\n\n    part KeylessEntrySystem extends Feature {\n        kind = FeatureKind.security;\n        mandatoriness = Mandatoriness.mandatory;\n    }\n\n    // Vehicle\n    part Vehicle {\n        part seatBelt: SeatBelt;\n        part bumper: Bumper;\n        part airbag: Airbag;\n        part antiLockBrakingSystem: AntiLockBrakingSystem;\n        part alarmDevice: AlarmDevice;\n        part keylessEntrySystem: KeylessEntrySystem;\n    }\n\n    // System Functions\n    action FilterComponentsByFeatureKind {\n        input kind: FeatureKind;\n        output filteredComponents: Feature[];\n    }\n\n    action OrganizeComponents {\n        input organizationForm: OrganizationForm;\n        input components: Feature[];\n        output organizedView: OrganizedView;\n    }\n\n    enum OrganizationForm {\n        values: tree, table\n    }\n\n    type OrganizedView;\n\n    action VisualizeSafetySecurityConfiguration {\n        input vehicle: Vehicle;\n        input organizationForm: OrganizationForm;\n        output visualization: OrganizedView;\n    }\n\n    // Use Case: Review Safety Configurations\n    usecase ReviewSafetyConfigurations {\n        description: \"End user reviews the safety configurations of the whole vehicle and its sub-systems, distinguishing between mandatory and non-mandatory safety functions.\"\n        actor: EndUser;\n        system: VehicleSafetySecuritySystem;\n    }\n\n    // System\n    system VehicleSafetySecuritySystem {\n        part vehicle: Vehicle;\n        action filterComponentsByFeatureKind: FilterComponentsByFeatureKind;\n        action organizeComponents: OrganizeComponents;\n        action visualizeSafetySecurityConfiguration: VisualizeSafetySecurityConfiguration;\n    }\n\n    actor EndUser;\n}",
    "package LayeredSystem {\n\n    // Core attributes\n    attribute x: Real;\n    attribute y: Real;\n    attribute z: Real;\n    \n    constraint z_depends_on_x_y {\n        z = f(x, y); // f represents a function of x and y\n    }\n\n    // Layer definitions\n    part applicationLayer: ApplicationLayer;\n    part serviceLayer: ServiceLayer;\n    part dataLayer: DataLayer;\n\n    // Layered dependencies\n    applicationLayer.uses(serviceLayer);\n    serviceLayer.uses(dataLayer);\n\n    // System definition\n    system LayeredSystem {\n        attribute x: Real;\n        attribute y: Real;\n        attribute z: Real;\n        constraint z_depends_on_x_y;\n        part applicationLayer: ApplicationLayer;\n        part serviceLayer: ServiceLayer;\n        part dataLayer: DataLayer;\n        dependency application_to_service: applicationLayer -> serviceLayer;\n        dependency service_to_data: serviceLayer -> dataLayer;\n    }\n\n    // Layer blocks\n    block ApplicationLayer {\n        // Uses functionalities from ServiceLayer\n        reference serviceLayer: ServiceLayer;\n    }\n\n    block ServiceLayer {\n        // Relies on DataLayer for data operations\n        reference dataLayer: DataLayer;\n    }\n\n    block DataLayer {\n        // Provides data storage and retrieval\n    }\n}",
    "package PowertrainTorqueGeneration {\n\n    import sysml::standard;\n\n    // Requirement Definitions\n    requirement TorqueGenerationFunction {\n        text \"The system shall realize the torque generation function within the powertrain system.\"\n    }\n\n    requirement PositiveTorqueRequirement {\n        text \"The torque produced during operation must be greater than zero newton-meters to ensure driving capability.\"\n    }\n\n    requirement FunctionAllocationRequirement {\n        text \"The logic layer's torque generator function shall be allocated and mapped to the physical layer of the powertrain, including actual components such as the engine.\"\n    }\n\n    // Function Definition\n    function TorqueGenerator {\n        in inputPower: Real;\n        out outputTorque: Real;\n        constraint PositiveTorque {\n            outputTorque > 0.0;\n        }\n    }\n\n    // Block Definitions\n    block PowertrainSystem {\n        part torqueGenerator: TorqueGenerator;\n        part engine: Engine;\n        satisfies TorqueGenerationFunction;\n        satisfies PositiveTorqueRequirement;\n        satisfies FunctionAllocationRequirement;\n    }\n\n    block Engine {\n        out outputTorque: Real;\n    }\n\n    // Allocation and Mapping\n    allocation TorqueGeneratorToEngine {\n        from TorqueGenerator;\n        to Engine;\n    }\n\n    // Satisfy Relationships\n    satisfy PowertrainSystemSatisfiesTorqueGenerationFunction {\n        from PowertrainSystem;\n        to TorqueGenerationFunction;\n    }\n\n    satisfy PowertrainSystemSatisfiesPositiveTorqueRequirement {\n        from PowertrainSystem;\n        to PositiveTorqueRequirement;\n    }\n\n    satisfy PowertrainSystemSatisfiesFunctionAllocationRequirement {\n        from PowertrainSystem;\n        to FunctionAllocationRequirement;\n    }\n\n    // Usage Relationships\n    usecase GenerateAndTransmitTorque {\n        subject PowertrainSystem;\n        description \"Generate and transmit torque to meet vehicle power output requirements.\";\n    }\n\n}",
    "package PowerSystem {\n\n    // Logical Functions\n    function PowerTransmission {\n        output: Power;\n    }\n\n    function PowerOutput {\n        output: Power;\n    }\n\n    function ProvidePower {\n        output: Power;\n    }\n\n    function GenerateTorque {\n        output: Torque;\n    }\n\n    // Logical Components\n    part TorqueGenerator {\n        performs: GenerateTorque;\n    }\n\n    // Logical System\n    part System {\n        performs: PowerTransmission;\n        performs: PowerOutput;\n        performs: ProvidePower;\n        has: TorqueGenerator;\n    }\n\n    // Physical Components\n    part Engine {\n        performs: GenerateTorque;\n    }\n\n    part Powertrain {\n        has: Engine;\n    }\n\n    // Physical System\n    part PhysicalSystem {\n        has: Powertrain;\n    }\n\n    // Allocations: Mapping logical to physical\n    allocation TorqueGeneratorToEngine {\n        from: System.TorqueGenerator.performs(GenerateTorque);\n        to: Powertrain.Engine.performs(GenerateTorque);\n    }\n\n    // Value Types\n    type Power {\n        unit: \"W\";\n    }\n\n    type Torque {\n        unit: \"Nm\";\n    }\n}",
    "package VehicleSafetyAndAntiTheftCatalogue {\n\n    // Enumerations\n    enum ComponentType {\n        Safety\n        AntiTheft\n        Both\n    }\n\n    enum Mandatoriness {\n        Mandatory\n        Optional\n    }\n\n    // Features\n    feature Vehicle {\n        part body: Body\n        part interior: Interior\n        part safetyFeatures: SafetyFeatureSet\n        part securityFeatures: SecurityFeatureSet\n    }\n\n    // Safety Feature Set\n    feature SafetyFeatureSet {\n        part frontSeatBelts: FrontSeatBelts\n        part bumpers: Bumpers\n        part? driverAirbag: DriverAirbag\n        part? antiLockBrakingSystem: AntiLockBrakingSystem\n    }\n\n    // Security Feature Set\n    feature SecurityFeatureSet {\n        part alarmSystem: AlarmSystem\n        part keylessEntrySystem: KeylessEntrySystem\n    }\n\n    // Components\n    partdef Body {}\n    partdef Interior {}\n\n    partdef FrontSeatBelts {\n        property type: ComponentType = Safety\n        property mandatoriness: Mandatoriness = Mandatory\n    }\n\n    partdef Bumpers {\n        property type: ComponentType = Safety\n        property mandatoriness: Mandatoriness = Mandatory\n    }\n\n    partdef DriverAirbag {\n        property type: ComponentType = Safety\n        property mandatoriness: Mandatoriness = Optional\n    }\n\n    partdef AntiLockBrakingSystem {\n        property type: ComponentType = Safety\n        property mandatoriness: Mandatoriness = Optional\n    }\n\n    partdef AlarmSystem {\n        property type: ComponentType = AntiTheft\n        property mandatoriness: Mandatoriness = Mandatory\n    }\n\n    partdef KeylessEntrySystem {\n        property type: ComponentType = AntiTheft\n        property mandatoriness: Mandatoriness = Mandatory\n    }\n\n    // Requirements\n    requirement CataloguePurpose {\n        text = \"Standardize basic configuration requirements for key vehicle components in terms of safety and anti-theft performance.\"\n    }\n\n    requirement MandatorySafetyComponents {\n        text = \"Front seat belts and bumpers must be installed on the body and interior to ensure fundamental personal safety of occupants.\"\n        verify Vehicle.safetyFeatures.frontSeatBelts.mandatoriness == Mandatory\n        verify Vehicle.safetyFeatures.bumpers.mandatoriness == Mandatory\n    }\n\n    requirement OptionalSafetyComponents {\n        text = \"Driver’s airbag and anti-lock braking system are safety features that may or may not be mandatory depending on specific configurations.\"\n        verify Vehicle.safetyFeatures.driverAirbag.mandatoriness == Optional\n        verify Vehicle.safetyFeatures.antiLockBrakingSystem.mandatoriness == Optional\n    }\n\n    requirement SecurityComponents {\n        text = \"Vehicle should be equipped with security components such as an alarm system and a keyless entry system to enhance security.\"\n        verify Vehicle.securityFeatures.alarmSystem.mandatoriness == Mandatory\n        verify Vehicle.securityFeatures.keylessEntrySystem.mandatoriness == Mandatory\n    }\n\n    requirement ComponentClassification {\n        text = \"Catalogue distinguishes and describes all components that affect safety, anti-theft, both, and all mandatory safety components.\"\n    }\n}",
    "package FuelSystemManagement {\n\n    part Vehicle {\n        part fuelSystem: FuelSystem;\n    }\n\n    part FuelSystem {\n        part fuelTankAssembly: FuelTankAssembly;\n        part fuelPump: FuelPump;\n        part fuelReturnLine: FuelReturnLine;\n        part fuelConsumingUnits: FuelConsumingUnits;\n        part fuelTemperatureSensor: FuelTemperatureSensor;\n\n        // Fuel flow from tank to pump to consuming units\n        connector tankToPump: FuelFlow {\n            end source: fuelTankAssembly.fuelOutlet;\n            end target: fuelPump.inlet;\n        }\n        connector pumpToUnits: FuelFlow {\n            end source: fuelPump.outlet;\n            end target: fuelConsumingUnits.fuelInlet;\n        }\n        // Return unused fuel to tank\n        connector unitsToReturn: FuelFlow {\n            end source: fuelConsumingUnits.fuelReturn;\n            end target: fuelReturnLine.inlet;\n        }\n        connector returnToTank: FuelFlow {\n            end source: fuelReturnLine.outlet;\n            end target: fuelTankAssembly.fuelReturnInlet;\n        }\n        // Data flow: temperature monitoring\n        connector tempToMonitor: TemperatureDataFlow {\n            end source: fuelTemperatureSensor.temperatureOutput;\n            end target: fuelSystemMonitor.temperatureInput;\n        }\n        part fuelSystemMonitor: FuelSystemMonitor;\n    }\n\n    part FuelTankAssembly {\n        port fuelOutlet: FuelPort;\n        port fuelReturnInlet: FuelPort;\n        part integratedFuelPump: FuelPump;\n    }\n\n    part FuelPump {\n        port inlet: FuelPort;\n        port outlet: FuelPort;\n    }\n\n    part FuelReturnLine {\n        port inlet: FuelPort;\n        port outlet: FuelPort;\n    }\n\n    part FuelConsumingUnits {\n        port fuelInlet: FuelPort;\n        port fuelReturn: FuelPort;\n    }\n\n    part FuelTemperatureSensor {\n        port temperatureOutput: TemperaturePort;\n    }\n\n    part FuelSystemMonitor {\n        port temperatureInput: TemperaturePort;\n    }\n\n    interface FuelPort {\n        feature flow: FuelFlow;\n    }\n\n    interface TemperaturePort {\n        feature data: TemperatureDataFlow;\n    }\n\n    interface FuelFlow {\n        property flowRate: Real;\n        property pressure: Real;\n    }\n\n    interface TemperatureDataFlow {\n        property temperature: Real;\n        property timestamp: Time;\n    }\n\n    requirement FuelSupplyAndReturn {\n        text \"The system shall provide complete fuel supply and return management for vehicles, including pressurizing, delivering, and returning unused fuel, while monitoring and transmitting real-time fuel temperature for safety and efficiency. All fuel and data flows between components shall be strictly bound according to the design for reliability.\"\n    }\n\n    constraint FuelFlowPathDefined {\n        // All fuel and data flows must be defined and bound between components\n        assert tankToPump.source == fuelTankAssembly.fuelOutlet;\n        assert tankToPump.target == fuelPump.inlet;\n        assert pumpToUnits.source == fuelPump.outlet;\n        assert pumpToUnits.target == fuelConsumingUnits.fuelInlet;\n        assert unitsToReturn.source == fuelConsumingUnits.fuelReturn;\n        assert unitsToReturn.target == fuelReturnLine.inlet;\n        assert returnToTank.source == fuelReturnLine.outlet;\n        assert returnToTank.target == fuelTankAssembly.fuelReturnInlet;\n        assert tempToMonitor.source == fuelTemperatureSensor.temperatureOutput;\n        assert tempToMonitor.target == fuelSystemMonitor.temperatureInput;\n    }\n}",
    "package VehicleSafetySecurityCompliance {\n\n    import sysml::requirements::*;\n    import sysml::blocks::*;\n    import sysml::features::*;\n    import sysml::constraints::*;\n\n    requirement SafetyAndSecurityCompliance {\n        text \"All safety and security components must be identified and classified to ensure compliance with regulations regarding critical safety and security functions.\"\n    }\n\n    requirement SeatBeltRequirement {\n        text \"The vehicle interior must be equipped with two seat belts, which are mandatory safety features.\"\n        derivedFrom SafetyAndSecurityCompliance\n    }\n\n    requirement AirbagRequirement {\n        text \"An airbag should be installed in the cockpit, but its application is not mandatory.\"\n        derivedFrom SafetyAndSecurityCompliance\n    }\n\n    requirement AntiTheftAlarmRequirement {\n        text \"An anti-theft alarm device should be installed inside the vehicle to enhance security protection.\"\n        derivedFrom SafetyAndSecurityCompliance\n    }\n\n    requirement BumperRequirement {\n        text \"The vehicle body must be equipped with a bumper, which is a required safety component.\"\n        derivedFrom SafetyAndSecurityCompliance\n    }\n\n    requirement KeylessEntryRequirement {\n        text \"The vehicle body is required to have a keyless entry system to improve security performance.\"\n        derivedFrom SafetyAndSecurityCompliance\n    }\n\n    requirement WheelRequirement {\n        text \"The chassis structure is to be fitted with two wheels.\"\n        derivedFrom SafetyAndSecurityCompliance\n    }\n\n    requirement ABSRequirement {\n        text \"The chassis structure is to be equipped with two sets of anti-lock braking systems, although the installation of such braking systems is not mandatory.\"\n        derivedFrom SafetyAndSecurityCompliance\n    }\n\n    block Vehicle {\n        part interior: VehicleInterior;\n        part body: VehicleBody;\n        part chassis: ChassisStructure;\n    }\n\n    block VehicleInterior {\n        part seatBelt[2]: SeatBelt;\n        part airbag[0..1]: Airbag;\n        part antiTheftAlarm[1]: AntiTheftAlarm;\n    }\n\n    block VehicleBody {\n        part bumper[1]: Bumper;\n        part keylessEntrySystem[1]: KeylessEntrySystem;\n    }\n\n    block ChassisStructure {\n        part wheel[2]: Wheel;\n        part antiLockBrakingSystem[0..2]: AntiLockBrakingSystem;\n    }\n\n    block SeatBelt {\n        isSafetyFeature: Boolean = true;\n    }\n\n    block Airbag {\n        isSafetyFeature: Boolean = true;\n        isMandatory: Boolean = false;\n    }\n\n    block AntiTheftAlarm {\n        isSecurityFeature: Boolean = true;\n    }\n\n    block Bumper {\n        isSafetyFeature: Boolean = true;\n    }\n\n    block KeylessEntrySystem {\n        isSecurityFeature: Boolean = true;\n    }\n\n    block Wheel {}\n\n    block AntiLockBrakingSystem {\n        isSafetyFeature: Boolean = true;\n        isMandatory: Boolean = false;\n    }\n\n    block IdentificationAndClassificationManager {\n        operation identifyAndClassify(component: SafetyOrSecurityComponent): ComplianceStatus;\n    }\n\n    interface SafetyOrSecurityComponent {}\n\n    block ComplianceStatus {}\n\n    // Satisfy relationships\n    satisfy SeatBeltSatisfySeatBeltRequirement {\n        from VehicleInterior.seatBelt\n        to SeatBeltRequirement\n    }\n\n    satisfy AirbagSatisfyAirbagRequirement {\n        from VehicleInterior.airbag\n        to AirbagRequirement\n    }\n\n    satisfy AntiTheftAlarmSatisfyAntiTheftAlarmRequirement {\n        from VehicleInterior.antiTheftAlarm\n        to AntiTheftAlarmRequirement\n    }\n\n    satisfy BumperSatisfyBumperRequirement {\n        from VehicleBody.bumper\n        to BumperRequirement\n    }\n\n    satisfy KeylessEntrySatisfyKeylessEntryRequirement {\n        from VehicleBody.keylessEntrySystem\n        to KeylessEntryRequirement\n    }\n\n    satisfy WheelSatisfyWheelRequirement {\n        from ChassisStructure.wheel\n        to WheelRequirement\n    }\n\n    satisfy ABSSatisfyABSRequirement {\n        from ChassisStructure.antiLockBrakingSystem\n        to ABSRequirement\n    }\n\n    satisfy IdentificationAndClassificationSatisfyCompliance {\n        from IdentificationAndClassificationManager\n        to SafetyAndSecurityCompliance\n    }\n}",
    "package VehicleSafetyAndSecuritySystem {\n\n    part VehicleSafetyAndSecurityComponentSystem {\n        part interior: Interior;\n        part bodyAssembly: BodyAssembly;\n    }\n\n    part Interior {\n        part alarmSystem: AlarmSystem;\n        part seatBelts: SeatBelts;\n        part frontRowSeats: FrontRowSeats;\n        part driverAirbag: Airbag;\n    }\n\n    part BodyAssembly {\n        part vehicleBody: VehicleBody;\n        part bumper: Bumper;\n        part keylessEntrySystem: KeylessEntrySystem;\n    }\n\n    part AlarmSystem {\n        // Onboard alarm for security\n    }\n\n    part SeatBelts {\n        // Safety feature for driver and passengers\n    }\n\n    part FrontRowSeats {\n        // Seats for driver and front passenger\n    }\n\n    part Airbag {\n        // Driver's airbag for safety\n    }\n\n    part VehicleBody {\n        // Main structure of the vehicle\n    }\n\n    part Bumper {\n        // Safety feature to absorb impact\n    }\n\n    part KeylessEntrySystem {\n        // Security feature for anti-theft and access\n    }\n\n    feature safetyProtection: SafetyProtection;\n    feature securitySupport: SecuritySupport;\n\n    function SafetyProtection {\n        input seatBelts: SeatBelts;\n        input airbag: Airbag;\n        input bumper: Bumper;\n        output protection: Protection;\n        // Enhances protection of driver and passengers during driving\n    }\n\n    function SecuritySupport {\n        input alarmSystem: AlarmSystem;\n        input keylessEntrySystem: KeylessEntrySystem;\n        output security: Security;\n        // Provides anti-theft and convenient access\n    }\n\n    VehicleSafetyAndSecurityComponentSystem {\n        satisfies safetyProtection;\n        satisfies securitySupport;\n    }\n\n    requirement ComprehensiveSafetyProtection {\n        description \"The system shall provide comprehensive safety protection for users by integrating seat belts, airbags, and bumpers.\"\n    }\n\n    requirement ConvenientUserExperience {\n        description \"The system shall provide a convenient user experience through the integration of an onboard alarm and keyless entry system.\"\n    }\n\n    VehicleSafetyAndSecurityComponentSystem {\n        satisfies ComprehensiveSafetyProtection;\n        satisfies ConvenientUserExperience;\n    }\n}",
    "package InformationSecurityManagement {\n\n    enum SecurityClassificationLevel {\n        Unclassified,\n        Confidential,\n        Secret\n    }\n\n    part Component {\n        attribute classification: SecurityClassificationLevel;\n    }\n\n    requirement ClassifyAndLabelComponents {\n        text \"The system shall classify and label each component to meet information security management requirements.\"\n        verify ClassifyAndLabelComponentsTest\n    }\n\n    requirement AssignSecurityClassificationLevel {\n        text \"Every component must be clearly assigned a security classification level, such as 'Unclassified,' 'Confidential,' or 'Secret.'\"\n        verify AssignSecurityClassificationLevelTest\n    }\n\n    requirement RecognizeAndDisplayConfidentialClassification {\n        text \"When a component is marked as 'Confidential,' the system should be able to recognize and display its corresponding classification attribute, thereby enabling effective differentiation and protection of sensitive information during system operation and document management.\"\n        verify RecognizeAndDisplayConfidentialClassificationTest\n    }\n\n    test ClassifyAndLabelComponentsTest {\n        text \"Verify that each component is classified and labeled according to information security management requirements.\"\n    }\n\n    test AssignSecurityClassificationLevelTest {\n        text \"Verify that every component is assigned a security classification level: 'Unclassified,' 'Confidential,' or 'Secret.'\"\n    }\n\n    test RecognizeAndDisplayConfidentialClassificationTest {\n        text \"Verify that when a component is marked as 'Confidential,' the system recognizes and displays its classification attribute for effective differentiation and protection.\"\n    }\n\n    constraint AllComponentsHaveClassification {\n        text \"All instances of Component must have a classification attribute assigned.\"\n        expression 'Component.classification != null'\n    }\n\n}",
    "package AutomotiveECUCommunicationSystem {\n\n    part VehicleControlUnit : VCU\n    part EngineControlUnit : ECU\n    part CANBus : CAN_Bus\n\n    part VCU_BusIF : BusIF\n    part ECU_BusIF : BusIF\n\n    part VCU_SensorIF : SensorIF\n    part ECU_SensorIF : SensorIF\n\n    // Connections\n    connect VehicleControlUnit.busPort to VCU_BusIF.ecuPort\n    connect VCU_BusIF.busPort to CANBus.vcuPort\n\n    connect EngineControlUnit.busPort to ECU_BusIF.ecuPort\n    connect ECU_BusIF.busPort to CANBus.ecuPort\n\n    connect VehicleControlUnit.sensorPort to VCU_SensorIF.ecuPort\n    connect EngineControlUnit.sensorPort to ECU_SensorIF.ecuPort\n\n    // Definitions\n    block VCU {\n        port busPort : BusPort\n        port sensorPort : SensorPort\n    }\n\n    block ECU {\n        port busPort : BusPort\n        port sensorPort : SensorPort\n    }\n\n    block CAN_Bus {\n        port vcuPort : BusPort\n        port ecuPort : BusPort\n    }\n\n    block BusIF {\n        port ecuPort : BusPort\n        port busPort : BusPort\n    }\n\n    block SensorIF {\n        port ecuPort : SensorPort\n        // Reserved for future sensor data exchange\n    }\n\n    interface BusPort {\n        // Represents CAN bus communication interface\n        flow inout CAN_Message\n    }\n\n    interface SensorPort {\n        // Represents sensor data interface\n        flow inout Sensor_Data\n    }\n\n    type CAN_Message {\n        attribute id : Integer\n        attribute data : String\n    }\n\n    type Sensor_Data {\n        attribute type : String\n        attribute value : Real\n    }\n}",
    "package BloodGlucoseMeterSystem {\n\n    requirement HighReliabilityAndSafety {\n        text \"The system shall ensure high reliability and safety of the blood glucose meter during use.\"\n    }\n\n    requirement BatteryStatusDetection {\n        text \"The system shall automatically detect the battery status when the battery is depleted or cannot be charged.\"\n        derivesFrom HighReliabilityAndSafety\n    }\n\n    requirement UserAlertOnBatteryIssue {\n        text \"The system shall promptly alert the user when a battery issue is detected to prevent failure to measure blood glucose levels and potential treatment delays.\"\n        derivesFrom BatteryStatusDetection\n    }\n\n    requirement PreventiveMeasuresForBattery {\n        text \"The system shall implement preventive measures for battery status to prevent failure scenarios related to battery issues.\"\n        derivesFrom BatteryStatusDetection\n    }\n\n    requirement AlarmAndEmergencyResponse {\n        text \"The system shall provide appropriate alarm and emergency response mechanisms in case of abnormalities in the blood glucose measurement function.\"\n        derivesFrom HighReliabilityAndSafety\n    }\n\n    requirement RigorousApprovalOfRequirements {\n        text \"The related system requirements shall undergo rigorous approval.\"\n    }\n\n    requirement RiskManagementForKeyScenarios {\n        text \"The system shall establish management measures for key risk scenarios to ensure timely, continuous, and safe therapeutic support for patients under all circumstances.\"\n        derivesFrom HighReliabilityAndSafety\n    }\n\n    satisfies HighReliabilityAndSafety\n    satisfies BatteryStatusDetection\n    satisfies UserAlertOnBatteryIssue\n    satisfies PreventiveMeasuresForBattery\n    satisfies AlarmAndEmergencyResponse\n    satisfies RigorousApprovalOfRequirements\n    satisfies RiskManagementForKeyScenarios\n\n}",
    "package ScientificConstants {\n\n    import sysml::units;\n\n    // Abstract concept for all constants\n    abstract part Constant {\n        attribute name: String;\n        attribute description: String;\n    }\n\n    // Mathematical Constants\n    part MathematicalConstant extends Constant {\n        attribute value: Real;\n        attribute precision: Integer;\n    }\n\n    part EulerNumber extends MathematicalConstant {\n        name = \"Euler's number\";\n        description = \"Base of natural logarithm\";\n        value = 2.71828182845904523536;\n        precision = 20;\n    }\n\n    part PiConstant extends MathematicalConstant {\n        name = \"Pi\";\n        description = \"Ratio of circumference to diameter of a circle\";\n        value = 3.14159265358979323846;\n        precision = 20;\n    }\n\n    // Physical Constants\n    part PhysicalConstant extends Constant {\n        attribute value: Real;\n        attribute unit: units::Unit;\n    }\n\n    part SpeedOfLightInVacuum extends PhysicalConstant {\n        name = \"Speed of light in vacuum\";\n        description = \"Defined value of the speed of light in vacuum\";\n        value = 299792458.0;\n        unit = units::meter_per_second;\n    }\n\n    part FineStructureConstant extends PhysicalConstant {\n        name = \"Fine-structure constant\";\n        description = \"Dimensionless physical constant characterizing the strength of electromagnetic interaction\";\n        value = 0.0072973525693;\n        unit = units::dimensionless;\n    }\n\n    part ElectronToProtonMassRatio extends PhysicalConstant {\n        name = \"Electron-to-proton mass ratio\";\n        description = \"Ratio of the mass of an electron to that of a proton\";\n        value = 0.000544617021487;\n        unit = units::dimensionless;\n    }\n\n    // Scenario-based Constants\n    part ScenarioConstant extends Constant {\n        attribute value: Real;\n        attribute unit: units::Unit;\n        attribute context: String;\n    }\n\n    part StandardGravitationalAcceleration extends ScenarioConstant {\n        name = \"Standard gravitational acceleration on Earth\";\n        description = \"Standard acceleration due to gravity at Earth's surface\";\n        value = 9.80665;\n        unit = units::meter_per_second_squared;\n        context = \"Earth surface\";\n    }\n\n    part AmplifierGainCoefficient_ModelX extends ScenarioConstant {\n        name = \"Amplifier gain coefficient\";\n        description = \"Gain coefficient for amplifier in Model X\";\n        value = 45.0;\n        unit = units::decibel;\n        context = \"Product: Model X\";\n    }\n\n    // Accessibility and Verification\n    interface ConstantRepository {\n        operation getConstantByName(name: String): Constant;\n        operation verifyConstant(name: String): Boolean;\n    }\n\n    part ScientificConstantSystem {\n        part eulerNumber: EulerNumber;\n        part pi: PiConstant;\n        part speedOfLight: SpeedOfLightInVacuum;\n        part fineStructure: FineStructureConstant;\n        part electronToProtonMassRatio: ElectronToProtonMassRatio;\n        part standardGravity: StandardGravitationalAcceleration;\n        part amplifierGain_ModelX: AmplifierGainCoefficient_ModelX;\n        reference repository: ConstantRepository;\n    }\n}",
    "package AutomotiveComponents {\n\n    import ScalarValues::*;\n\n    part type Tire {\n        attribute manufacturer: String;\n        attribute rimDiameter: Real;\n        attribute width: Integer;\n    }\n\n    part type FrenchTire specializes Tire;\n\n    instance MichelinTire_18_245: FrenchTire {\n        manufacturer = \"Michelin\";\n        rimDiameter = 18.0;\n        width = 245;\n    }\n\n}",
    "package AutomotiveComponentModel {\n\n    import ScalarValues::*;\n    import Units::*;\n    \n    // Unit definitions for SI and Imperial\n    unit kg : Mass;\n    unit m : Length;\n    unit mm : Length;\n    unit inch : Length;\n    \n    // Conversion factors\n    define unitConversion mm_to_m : mm = 0.001 * m;\n    define unitConversion inch_to_m : inch = 0.0254 * m;\n    define unitConversion kg_to_lb : kg = 2.20462 * pound_mass;\n    define unitConversion m_to_ft : m = 3.28084 * foot;\n    \n    // Tire definition\n    part Tire {\n        // Additional tire properties can be added here\n    }\n    \n    // Wheel definition\n    part Wheel {\n        attribute hubDiameter : Length [1] = 18 * inch;\n        attribute width : Length [1] = 245 * mm;\n        attribute tireHeight : Length [1]; // To be specified for each wheel\n        attribute outerDiameter : Length [1] = hubDiameter + 2 * tireHeight;\n        part tire : Tire;\n    }\n    \n    // Vehicle definition\n    part Vehicle {\n        attribute mass : Mass [1] = 1200 * kg;\n        attribute length : Length [1] = 4.82 * m;\n        part frontLeftWheel : Wheel;\n        part frontRightWheel : Wheel;\n    }\n    \n    // Automotive Component Model root\n    part AutomotiveComponent {\n        part vehicle : Vehicle;\n    }\n}",
    "package VehiclePowertrainConfig {\n\n    enum EngineType {\n        literal four_cylinder;\n        literal six_cylinder;\n    }\n\n    enum TransmissionType {\n        literal manual;\n        literal automatic;\n    }\n\n    part Vehicle {\n        attribute isHighPerformance: Boolean;\n        attribute engine: EngineType;\n        attribute transmission: TransmissionType;\n\n        constraint select_one_engine {\n            (engine == EngineType::four_cylinder) or (engine == EngineType::six_cylinder)\n        }\n\n        constraint select_one_transmission {\n            (transmission == TransmissionType::manual) or (transmission == TransmissionType::automatic)\n        }\n\n        constraint high_performance_engine {\n            if isHighPerformance then\n                engine == EngineType::six_cylinder\n            else\n                engine == EngineType::four_cylinder\n        }\n\n        constraint valid_powertrain_combinations {\n            ((engine == EngineType::four_cylinder) and (transmission == TransmissionType::manual))\n            or\n            ((engine == EngineType::six_cylinder) and (transmission == TransmissionType::automatic))\n        }\n    }\n}",
    "package AutomotiveComponents {\n\n    import sysml::units::*;\n    import sysml::constraints::*;\n\n    // ==== Value Definitions ====\n    value Mass : Real;\n    value Length : Real;\n    value Diameter : Real;\n    value Radius : Real;\n    value Width : Real;\n    value Height : Real;\n    value Depth : Real;\n\n    // ==== Car ====\n    part Car {\n        attribute totalMass : Mass = 1200 kg;\n        attribute length : Length = 4.82 m;\n        part wheelAssemblies : WheelAssembly[4..*];\n    }\n\n    // ==== Wheel Assembly ====\n    part WheelAssembly {\n        part wheel : Wheel;\n        part brakeDisc : BrakeDisc;\n    }\n\n    // ==== Wheel ====\n    part Wheel {\n        part rim : Rim;\n        part tire : Tire;\n\n        // Outer diameter calculation\n        attribute outerDiameter : Diameter;\n        constraint OuterDiameterCalculation {\n            // Rim diameter in mm: 18 in * 25.4 mm/in = 457.2 mm\n            rim.diameter = 18 in;\n            tire.width = 245 mm;\n            tire.height = 45 mm;\n            outerDiameter = (rim.diameter * 25.4 mm/in) + 2 * tire.height;\n        }\n    }\n\n    // ==== Rim ====\n    part Rim {\n        attribute diameter : Diameter = 18 in;\n    }\n\n    // ==== Tire ====\n    part Tire {\n        attribute width : Width = 245 mm;\n        attribute height : Height = 45 mm;\n        attribute treadDepth : Depth = 6.0 mm;\n        constraint TreadDepthMinimum {\n            treadDepth >= 3.5 mm;\n        }\n    }\n\n    // ==== Brake Disc ====\n    part BrakeDisc {\n        attribute radius : Radius = 95 mm;\n        attribute diameter : Diameter;\n        constraint DiameterCalculation {\n            diameter = 2 * radius;\n        }\n    }\n\n    // ==== Constraints ====\n\n    // Brake disc diameter must be less than wheel outer diameter\n    constraint BrakeDiscFitsWheel(wheelAssembly: WheelAssembly) {\n        wheelAssembly.brakeDisc.diameter < wheelAssembly.wheel.outerDiameter;\n    }\n\n    // All wheel assemblies must satisfy fitment constraint\n    constraint AllWheelAssembliesFit(car: Car) {\n        for wa in car.wheelAssemblies {\n            BrakeDiscFitsWheel(wa);\n        }\n    }\n\n    // Tread depth constraint for all tires\n    constraint AllTiresTreadDepth(car: Car) {\n        for wa in car.wheelAssemblies {\n            wa.wheel.tire.treadDepth >= 3.5 mm;\n        }\n    }\n\n}",
    "package AutomotiveFuelSystem {\n\n    part system: FuelSystem {\n        part fuelTankAssembly: FuelTankAssembly;\n        part fuelPump: FuelPump;\n        part fuelTank: FuelTank;\n        part engine: Engine;\n\n        // Connections\n        connect fuelTankAssembly.outlet to engine.fuelInlet;\n        connect engine.fuelReturn to fuelTankAssembly.returnInlet;\n        connect fuelTankAssembly.pumpInterface to fuelPump.pumpPort;\n        connect fuelPump.tankInterface to fuelTank.fuelPort;\n        connect fuelPump.engineSupply to engine.fuelInlet;\n        connect fuelPump.returnInlet to fuelTankAssembly.returnInlet;\n    }\n\n    interface FuelOutlet {\n        out fuel: Fuel;\n    }\n\n    interface FuelReturn {\n        in returnedFuel: Fuel;\n    }\n\n    interface FuelTemperatureInfo {\n        out temperature: Temperature;\n    }\n\n    interface PumpPort {\n        in fuel: Fuel;\n        out fuel: Fuel;\n    }\n\n    interface FuelPort {\n        in fuel: Fuel;\n        out fuel: Fuel;\n    }\n\n    interface EngineFuelInlet {\n        in fuel: Fuel;\n    }\n\n    interface EngineFuelReturn {\n        out returnedFuel: Fuel;\n    }\n\n    part FuelTankAssembly {\n        interface outlet: FuelOutlet;\n        interface returnInlet: FuelReturn;\n        interface pumpInterface: PumpPort;\n        interface tempMonitor: FuelTemperatureInfo;\n    }\n\n    part FuelPump {\n        interface pumpPort: PumpPort;\n        interface tankInterface: FuelPort;\n        interface engineSupply: EngineFuelInlet;\n        interface returnInlet: FuelReturn;\n        interface tempMonitor: FuelTemperatureInfo;\n    }\n\n    part FuelTank {\n        interface fuelPort: FuelPort;\n        interface tempMonitor: FuelTemperatureInfo;\n    }\n\n    part Engine {\n        interface fuelInlet: EngineFuelInlet;\n        interface fuelReturn: EngineFuelReturn;\n    }\n\n    type Fuel;\n    type Temperature;\n\n    requirement FuelCirculation {\n        description: \"Fuel shall circulate efficiently and safely among all components, meeting vehicle requirements for fuel supply and return, and ensuring normal fuel supply to the engine.\";\n    }\n\n    requirement FuelTemperatureMonitoring {\n        description: \"The system shall monitor and transmit fuel temperature information.\";\n    }\n\n    requirement FuelSupplyAndReturn {\n        description: \"The fuel tank assembly shall provide an outlet interface for fuel (including a return function), enabling delivery of fuel to the engine or other components, as well as reception of returned fuel.\";\n    }\n\n    requirement FuelPumpFunction {\n        description: \"The fuel pump, installed inside the fuel tank assembly, shall pump fuel from the fuel tank and supply it to the engine, and be capable of receiving returned fuel.\";\n    }\n}",
    "package PhysicalQuantitySystem {\n\n    import sysml::units;\n\n    part system: System {\n        feature supportsData: SupportsData;\n        feature managesUnits: ManagesUnits;\n        feature coversISQ: CoversISQ;\n        feature allowsImport: AllowsImport;\n        feature allowsExtension: AllowsExtension;\n        feature ensuresAccuracy: EnsuresAccuracy;\n        feature ensuresConsistency: EnsuresConsistency;\n        feature facilitatesProcessing: FacilitatesProcessing;\n        feature supportsUnitConversion: SupportsUnitConversion;\n        feature meetsUserRequirements: MeetsUserRequirements;\n    }\n\n    interface SupportsData {\n        inout data: PhysicalQuantityData;\n    }\n\n    interface ManagesUnits {\n        inout unit: Unit;\n    }\n\n    interface CoversISQ {\n        out length: Length;\n        out mass: Mass;\n        out time: Time;\n        out electricCurrent: ElectricCurrent;\n        out temperature: ThermodynamicTemperature;\n        out amountOfSubstance: AmountOfSubstance;\n        out luminousIntensity: LuminousIntensity;\n    }\n\n    interface AllowsImport {\n        in importData: PhysicalQuantityData;\n        in importUnit: Unit;\n    }\n\n    interface AllowsExtension {\n        in extension: PhysicalQuantityExtension;\n    }\n\n    interface EnsuresAccuracy {\n        inout data: PhysicalQuantityData;\n        constraint accurateRepresentation;\n    }\n\n    interface EnsuresConsistency {\n        inout data: PhysicalQuantityData;\n        constraint consistentInformation;\n    }\n\n    interface FacilitatesProcessing {\n        inout data: PhysicalQuantityData;\n        operation processData();\n    }\n\n    interface SupportsUnitConversion {\n        in sourceUnit: Unit;\n        in targetUnit: Unit;\n        in value: Real;\n        out convertedValue: Real;\n        operation convertUnit();\n    }\n\n    interface MeetsUserRequirements {\n        in userRequirement: UserRequirement;\n        out satisfied: Boolean;\n    }\n\n    type PhysicalQuantityData {\n        property value: Real;\n        property unit: Unit;\n        property quantityType: QuantityType;\n    }\n\n    type Unit {\n        property symbol: String;\n        property name: String;\n        property scale: Real;\n    }\n\n    enum QuantityType {\n        length,\n        mass,\n        time,\n        electricCurrent,\n        temperature,\n        amountOfSubstance,\n        luminousIntensity,\n        extended\n    }\n\n    type PhysicalQuantityExtension {\n        property name: String;\n        property definition: String;\n    }\n\n    type UserRequirement {\n        property description: String;\n        property priority: Integer;\n    }\n\n    // ISQ Base Quantities\n    type Length specializes PhysicalQuantityData;\n    type Mass specializes PhysicalQuantityData;\n    type Time specializes PhysicalQuantityData;\n    type ElectricCurrent specializes PhysicalQuantityData;\n    type ThermodynamicTemperature specializes PhysicalQuantityData;\n    type AmountOfSubstance specializes PhysicalQuantityData;\n    type LuminousIntensity specializes PhysicalQuantityData;\n\n}",
    "package UnitSystemLibrary {\n\n    // Stakeholders\n    stakeholder User {\n        description: \"Individuals or organizations requiring standardized unit management, conversion, and application.\"\n    }\n\n    stakeholder StandardsAuthority {\n        description: \"Entities responsible for ensuring accuracy and authoritative standardization of units.\"\n    }\n\n    // Concerns\n    concern Interoperability {\n        description: \"Support interoperability and adaptation between ISQ and USCustomaryUnits.\"\n    }\n\n    concern Accuracy {\n        description: \"Ensure accuracy and authoritative standardization of all unit types.\"\n    }\n\n    concern Usability {\n        description: \"Enable convenient management, conversion, and application of units.\"\n    }\n\n    concern Efficiency {\n        description: \"Enhance efficiency and reliability of data processing and communication.\"\n    }\n\n    // Requirements\n    requirement ProvideStandardizedUnitSystemLibrary {\n        text: \"The system shall provide a standardized unit system library.\"\n        satisfies: [Interoperability, Accuracy, Usability]\n    }\n\n    requirement SupportISQandUSCustomaryUnits {\n        text: \"The system shall support both the International System of Quantities (ISQ) and United States Customary Units (USCustomaryUnits).\"\n        satisfies: [Interoperability]\n    }\n\n    requirement EnableUnitConversion {\n        text: \"The system shall enable users to convert between ISQ and USCustomaryUnits.\"\n        satisfies: [Usability, Interoperability]\n    }\n\n    requirement EnsureAccuracyAndStandardization {\n        text: \"The system shall ensure the accuracy and authoritative standardization of all unit types.\"\n        satisfies: [Accuracy]\n    }\n\n    requirement SupportMeasurementNeeds {\n        text: \"The system shall meet the measurement needs of engineering, scientific research, and daily life.\"\n        satisfies: [Usability]\n    }\n\n    requirement EnhanceEfficiencyAndReliability {\n        text: \"The system shall enhance the efficiency and reliability of data processing and communication.\"\n        satisfies: [Efficiency]\n    }\n\n    // Use Cases\n    usecase ManageUnits {\n        description: \"User manages various units of physical quantities.\"\n        actor: User\n        satisfies: ProvideStandardizedUnitSystemLibrary\n    }\n\n    usecase ConvertUnits {\n        description: \"User converts values between ISQ and USCustomaryUnits.\"\n        actor: User\n        satisfies: EnableUnitConversion\n    }\n\n    usecase ApplyUnits {\n        description: \"User applies units in engineering, scientific, or daily life contexts.\"\n        actor: User\n        satisfies: SupportMeasurementNeeds\n    }\n\n    // System Definition\n    system UnitSystemLibrarySystem {\n        satisfies: [\n            ProvideStandardizedUnitSystemLibrary,\n            SupportISQandUSCustomaryUnits,\n            EnableUnitConversion,\n            EnsureAccuracyAndStandardization,\n            SupportMeasurementNeeds,\n            EnhanceEfficiencyAndReliability\n        ]\n    }\n\n    // Interfaces\n    interface UnitSystemLibraryAPI {\n        description: \"API for managing, converting, and applying units.\"\n        operation manageUnits()\n        operation convertUnits(fromUnit: Unit, toUnit: Unit, value: Real): Real\n        operation getSupportedUnits(): Set<Unit>\n    }\n\n    // Structure\n    part ISQUnitSet: UnitSet {\n        description: \"Collection of units defined by the International System of Quantities.\"\n    }\n\n    part USCustomaryUnitSet: UnitSet {\n        description: \"Collection of units defined by the United States Customary Units.\"\n    }\n\n    // Relationships\n    UnitSystemLibrarySystem {\n        part isqUnits: ISQUnitSet\n        part usCustomaryUnits: USCustomaryUnitSet\n        exposes api: UnitSystemLibraryAPI\n    }\n\n    // Constraints\n    constraint AccurateConversion {\n        description: \"All unit conversions shall be accurate within the authoritative standards.\"\n    }\n\n    constraint ConsistentUnitDefinitions {\n        description: \"All unit definitions shall be consistent with recognized standards.\"\n    }\n}",
    "package CarHeadlampTiltAdjustmentKnob {\n\n    import sysml::units;\n    import sysml::expressions;\n\n    unit deg : units::Angle = units::degree;\n\n    constant pi : Real = 3.141592653589793;\n    constant e  : Real = 2.718281828459045;\n\n    type HeadlampTiltAngle : Real {\n        unit = deg;\n    }\n\n    part CarHeadlampTiltAdjustmentKnobSystem {\n        attribute currentTiltAngle : HeadlampTiltAngle;\n    }\n\n    requirement HeadlampTiltAngleRange {\n        text \"The tilt angle of the headlamp beam (measured in degrees) must be between 50 degrees and 80 degrees; any value outside this range does not comply with safety and regulatory standards.\";\n    }\n\n    constraint HeadlampTiltAngleWithinRange {\n        parameter angle : HeadlampTiltAngle;\n        expression: 50.0 * deg <= angle and angle <= 80.0 * deg;\n    }\n\n    verify CarHeadlampTiltAdjustmentKnobSystem satisfies HeadlampTiltAngleRange\n        by HeadlampTiltAngleWithinRange(currentTiltAngle);\n\n    requirement SIUnitsAndPrecision {\n        text \"The system adopts the International System of Units (SI) and standard real number constants (such as pi and Euler’s number e) to ensure precision and consistency in calculations.\";\n    }\n\n}",
    "package DataManagementSystem {\n\n    // Core Data Types\n    type UnsignedInteger {\n        constraint NonNegative {\n            self >= 0\n        }\n    }\n\n    type UnsignedFloat {\n        constraint NonNegative {\n            self >= 0.0\n        }\n    }\n\n    type DateTime\n    type String\n    type Boolean\n\n    // Status Levels and Color Labeling\n    enum StatusLevel {\n        critical\n        warning\n        normal\n    }\n\n    enum StatusColor {\n        red\n        yellow\n        green\n    }\n\n    association StatusLevelToColor {\n        end statusLevel : StatusLevel[1];\n        end statusColor : StatusColor[1];\n        constraint LevelColorMapping {\n            (statusLevel == StatusLevel::critical and statusColor == StatusColor::red) or\n            (statusLevel == StatusLevel::warning and statusColor == StatusColor::yellow) or\n            (statusLevel == StatusLevel::normal and statusColor == StatusColor::green)\n        }\n    }\n\n    // Physical Dimension: Diameter\n    enum DiameterOption {\n        Small\n        Medium\n        Large\n    }\n\n    value DiameterValue : UnsignedInteger;\n\n    def DiameterOptionToValue(option: DiameterOption) : UnsignedInteger {\n        if option == DiameterOption::Small then 60\n        else if option == DiameterOption::Medium then 70\n        else if option == DiameterOption::Large then 80\n        else 60 // default fallback\n    }\n\n    property diameterOption : DiameterOption = DiameterOption::Small;\n    property diameter : UnsignedInteger = DiameterOptionToValue(diameterOption);\n\n    // System Data Type Container for Extensibility\n    part systemDataTypes {\n        property unsignedInteger : UnsignedInteger;\n        property unsignedFloat : UnsignedFloat;\n        property dateTime : DateTime;\n        property string : String;\n        property boolean : Boolean;\n        property statusLevel : StatusLevel;\n        property statusColor : StatusColor;\n        property diameterOption : DiameterOption;\n        property diameter : UnsignedInteger;\n    }\n\n}",
    "package SparePartsManagementSystem {\n\n    import sysml::collections::*;\n    import sysml::datatypes::*;\n\n    type Person;\n\n    part system {\n        // Spare parts managed as Bags\n        property spareParts: Bag<SparePart>;\n\n        // Integers managed as Lists\n        property integerLists: List<Integer>;\n\n        // Strings managed as Sets\n        property stringSets: Set<String>;\n\n        // Personnel managed as OrderedSets of Person\n        property personnelOrderedSets: OrderedSet<Person>;\n\n        // Nested collection: List of Sets of Person\n        property personnelSetLists: List<Set<Person>>;\n\n        // Real numbers managed as fixed-length arrays (length 4)\n        property realArrays: Array<Real>[4];\n\n        // Integration with business functions\n        operation retrieveRelatedInformation(input: Any): Any;\n        operation integrateWithBusinessFunction(data: Any): Any;\n    }\n\n    type SparePart;\n}",
    "package TireInformationSystem {\n\n    import sysml::units;\n    import sysml::types;\n\n    // Define unit for inches\n    unit Inch : units::Length = units::inch;\n\n    // Define a coordinate vector in 3D space\n    structure Coordinate3D {\n        x: Real;\n        y: Real;\n        z: Real;\n    }\n\n    // Define Tire structure\n    structure Tire {\n        manufacturerName: String;\n        rimDiameter: Real [unit=Inch];\n        tireWidth: Real;\n        installationPosition?: Coordinate3D;\n    }\n\n    // Example instance: Michelin tire\n    instance MichelinTire_18_245: Tire {\n        manufacturerName = \"Michelin\";\n        rimDiameter = 18.0;\n        tireWidth = 245.0;\n        // installationPosition is optional and can be omitted or specified\n    }\n\n}",
    "package SpacecraftAscentTrajectorySampling {\n\n    import ScalarValues::*;\n    import SI_Units::*;\n\n    // Value definitions\n    value TimeInSeconds : Real [unit = s];\n    value Position3D : Real[3] [unit = m];\n    value Velocity3D : Real[3] [unit = m/s];\n    value UTCTimestamp : String;\n\n    // Data structure for a single sampling point\n    data SamplingPoint {\n        attribute time : TimeInSeconds;\n        attribute position : Position3D;\n        attribute velocity : Velocity3D;\n    }\n\n    // Data structure for the full trajectory record\n    data TrajectoryRecord {\n        attribute referenceTimeZero : TimeInSeconds;\n        attribute referenceUTCTime : UTCTimestamp;\n        attribute samples : SamplingPoint[1..*];\n    }\n\n    // Requirement definitions\n    requirement SampleAndRecordTrajectory {\n        text \"The system shall sample and record the trajectory of the spacecraft during the ascent phase.\"\n    }\n\n    requirement UseMissionLiftoffTimeAsReference {\n        text \"The system shall use the mission liftoff time as the reference time zero, measured in seconds.\"\n    }\n\n    requirement AcceptUTCLiftoffTime {\n        text \"The system shall be able to take the UTC liftoff time of the mission as the reference time.\"\n    }\n\n    requirement CollectKeyParameters {\n        text \"The system shall collect key parameters including the position and velocity of the spacecraft at different time points.\"\n    }\n\n    requirement AssociateTimeWithData {\n        text \"Each set of sampled data shall associate a specific time point with the corresponding position and velocity data.\"\n    }\n\n    requirement UseCartesianCoordinates {\n        text \"Both the three-dimensional position and velocity shall be described in a Cartesian coordinate system, with units of meters and meters per second, respectively.\"\n    }\n\n    requirement MultipleSamplingPoints {\n        text \"The system shall record multiple sampling points during the ascent phase, with each sampling point containing explicit information on time, position, and velocity.\"\n    }\n\n    requirement SupportTrajectoryAnalysis {\n        text \"The system shall provide accurate data support for subsequent trajectory analysis and performance evaluation.\"\n    }\n\n    // Satisfy relationships\n    part SpacecraftAscentTrajectorySampler {\n        satisfies SampleAndRecordTrajectory;\n        satisfies UseMissionLiftoffTimeAsReference;\n        satisfies AcceptUTCLiftoffTime;\n        satisfies CollectKeyParameters;\n        satisfies AssociateTimeWithData;\n        satisfies UseCartesianCoordinates;\n        satisfies MultipleSamplingPoints;\n        satisfies SupportTrajectoryAnalysis;\n    }\n\n}",
    "package MaterialsScienceAlloyModel {\n\n    import ScalarValues::*;\n    import SI_Units::*;\n\n    // Abstract definition for a Substance\n    abstract definition Substance {\n        property name: String;\n        property atomicMass: Real [0..1] { unit = \"u\"; } // atomic mass unit\n    }\n\n    // Material is a type of Substance\n    definition Material : Substance {\n        // Additional material-specific properties can be added here\n    }\n\n    // Metal is a type of Material\n    definition Metal : Material {\n        // Additional metal-specific properties can be added here\n    }\n\n    // Alloy is a type of Material, composed of two or more Materials\n    definition Alloy : Material {\n        property component: ComponentMaterial [2..*];\n        property tensileStrength: Real [0..1] { unit = \"N/mm^2\"; } // tensile strength in newtons per square millimeter\n    }\n\n    // ComponentMaterial links a Material to its mass fraction in an Alloy\n    definition ComponentMaterial {\n        property material: Material;\n        property massFraction: Real [1] { unit = \"1\"; } // fraction (0..1)\n    }\n\n    // Example instances of common metals\n    instance Iron : Metal {\n        name = \"Iron\";\n        atomicMass = 55.845;\n    }\n\n    instance Carbon : Metal {\n        name = \"Carbon\";\n        atomicMass = 12.011;\n    }\n\n    instance Manganese : Metal {\n        name = \"Manganese\";\n        atomicMass = 54.938;\n    }\n\n    // Example instance of an alloy (Steel 980)\n    instance Steel980 : Alloy {\n        name = \"Steel 980\";\n        atomicMass = null; // Not defined for alloys\n        tensileStrength = 980.0; // N/mm^2\n\n        component = {\n            instance Steel980_Fe : ComponentMaterial {\n                material = Iron;\n                massFraction = 0.98;\n            },\n            instance Steel980_C : ComponentMaterial {\n                material = Carbon;\n                massFraction = 0.015;\n            },\n            instance Steel980_Mn : ComponentMaterial {\n                material = Manganese;\n                massFraction = 0.005;\n            }\n        };\n    }\n\n}",
    "package EngineeringMaterialsDatabaseSystem {\n\n    // Units\n    unit NewtonPerSquareMillimeter {\n        symbol: \"N/mm^2\";\n        quantityKind: force_per_area;\n    }\n\n    // Fundamental Property Kinds\n    propertyKind AtomicMass {\n        description: \"Atomic mass of a material constituent\";\n        unit: kilogram_per_mole;\n    }\n\n    propertyKind MassFraction {\n        description: \"Mass fraction of a constituent in a material\";\n        unit: dimensionless;\n    }\n\n    propertyKind TensileStrength {\n        description: \"Tensile strength of a material\";\n        unit: NewtonPerSquareMillimeter;\n    }\n\n    // Material Constituents\n    element MaterialConstituent {\n        attribute name: String;\n        attribute atomicMass: Real [0..1] { kind = AtomicMass; };\n    }\n\n    // Engineering Material\n    element EngineeringMaterial {\n        attribute name: String;\n        attribute description: String [0..1];\n        part property fundamentalProperties: FundamentalProperty [*];\n        part property mechanicalProperties: MechanicalProperty [*];\n    }\n\n    // Fundamental Property\n    element FundamentalProperty {\n        attribute kind: propertyKind;\n        attribute value: Real;\n    }\n\n    // Mechanical Property\n    element MechanicalProperty {\n        attribute kind: propertyKind;\n        attribute value: Real;\n        attribute unit: unit;\n    }\n\n    // Metal and Alloy (specializations)\n    element Metal specializes EngineeringMaterial {\n        part property composition: MaterialComposition [*];\n    }\n\n    element Alloy specializes EngineeringMaterial {\n        part property composition: MaterialComposition [*];\n    }\n\n    // Material Composition\n    element MaterialComposition {\n        part property constituent: MaterialConstituent;\n        attribute massFraction: Real { kind = MassFraction; };\n    }\n\n    // Example: Steel_980\n    element Steel_980 specializes Alloy {\n        attribute name: String = \"Steel_980\";\n        part property composition: MaterialComposition = [\n            MaterialComposition {\n                constituent: MaterialConstituent { name: \"Iron\"; atomicMass: 55.845; },\n                massFraction: 0.96\n            },\n            MaterialComposition {\n                constituent: MaterialConstituent { name: \"Carbon\"; atomicMass: 12.011; },\n                massFraction: 0.02\n            },\n            MaterialComposition {\n                constituent: MaterialConstituent { name: \"Manganese\"; atomicMass: 54.938; },\n                massFraction: 0.02\n            }\n        ];\n        part property mechanicalProperties: MechanicalProperty = [\n            MechanicalProperty {\n                kind: TensileStrength;\n                value: 980;\n                unit: NewtonPerSquareMillimeter;\n            }\n        ];\n    }\n\n    // System Functions\n    action EnterMaterialData {\n        input: EngineeringMaterial;\n        output: Boolean;\n    }\n\n    action QueryMaterialData {\n        input: String; // query string or criteria\n        output: EngineeringMaterial [*];\n    }\n\n    action CompareMaterials {\n        input: EngineeringMaterial [*];\n        output: ComparisonResult;\n    }\n\n    element ComparisonResult {\n        attribute summary: String;\n        attribute comparedProperties: String [*];\n    }\n\n    // System\n    system EngineeringMaterialsDatabaseSystem {\n        part property materials: EngineeringMaterial [*];\n        operation enterMaterialData: EnterMaterialData;\n        operation queryMaterialData: QueryMaterialData;\n        operation compareMaterials: CompareMaterials;\n    }\n}",
    "package PubSubSystem {\n\n    // Define Topics\n    type Topic {\n        id: String;\n        name: String;\n    }\n\n    // Define Message\n    type Message {\n        id: String;\n        topic: Topic;\n        content: String;\n        timestamp: DateTime;\n    }\n\n    // Define User\n    part User {\n        id: String;\n        name: String;\n    }\n\n    // Producer role\n    part Producer specializes User {\n        publishes: Message[0..*];\n        operation publish(msg: Message): Boolean;\n    }\n\n    // Consumer role\n    part Consumer specializes User {\n        subscribesTo: Topic[0..*];\n        receives: Message[0..*];\n        operation subscribe(topic: Topic): Boolean;\n        operation receive(msg: Message): Boolean;\n    }\n\n    // Server\n    part Server {\n        managedTopics: Topic[0..*];\n        subscriptions: Map<Topic, Consumer[0..*]>;\n        operation registerSubscription(consumer: Consumer, topic: Topic): Boolean;\n        operation receiveMessage(msg: Message): Boolean;\n        operation distributeMessage(msg: Message): Boolean;\n    }\n\n    // System Context\n    part PubSubSystem {\n        producers: Producer[0..*];\n        consumers: Consumer[0..*];\n        server: Server;\n    }\n\n    // Requirements\n    requirement PubSubModel {\n        text = \"The system shall implement a Publish-Subscribe message interaction model, supporting message producers to publish messages on specific topics to the server, and consumers to subscribe to topics of interest through the server.\";\n    }\n\n    requirement MessageDistribution {\n        text = \"When a producer publishes a new message, the server shall promptly receive the published information and, according to the existing topic subscription relationships, distribute and deliver the message to the corresponding subscribers.\";\n    }\n\n    requirement SubscriberTransparency {\n        text = \"Users shall only need to declare the topics they wish to subscribe to, without needing to know the specific publishers or other subscribers.\";\n    }\n\n    requirement EfficientManagement {\n        text = \"The system shall provide clear management and efficient processing of message subscription, publishing, and distribution flows.\";\n    }\n\n    // Use Cases\n    usecase PublishMessage {\n        actor: Producer;\n        subject: Server;\n        description: \"Producer publishes a message on a topic to the server.\";\n    }\n\n    usecase SubscribeToTopic {\n        actor: Consumer;\n        subject: Server;\n        description: \"Consumer subscribes to a topic of interest via the server.\";\n    }\n\n    usecase DistributeMessage {\n        actor: Server;\n        subject: Consumer;\n        description: \"Server distributes messages to consumers based on their topic subscriptions.\";\n    }\n\n    // Relationships\n    satisfies PubSubSystem -> PubSubModel;\n    satisfies Server -> MessageDistribution;\n    satisfies Consumer -> SubscriberTransparency;\n    satisfies PubSubSystem -> EfficientManagement;\n\n    // Flows\n    flow PublishFlow {\n        from: Producer.publish;\n        to: Server.receiveMessage;\n        description: \"Producer sends message to server.\";\n    }\n\n    flow SubscriptionFlow {\n        from: Consumer.subscribe;\n        to: Server.registerSubscription;\n        description: \"Consumer subscribes to topic via server.\";\n    }\n\n    flow DistributionFlow {\n        from: Server.distributeMessage;\n        to: Consumer.receive;\n        description: \"Server delivers message to subscribed consumers.\";\n    }\n}",
    "package VehicleFuelSystem {\n\n    part Vehicle {\n        part fuelSystem: FuelSystem;\n    }\n\n    part FuelSystem {\n        part fuelTankAssembly: FuelTankAssembly;\n        part engine: Engine;\n        part supplyLine: FuelLine;\n        part returnLine: FuelLine;\n        part fuelTemperatureSensor: FuelTemperatureSensor;\n\n        connect fuelTankAssembly.fuelOut to supplyLine.inlet;\n        connect supplyLine.outlet to engine.fuelIn;\n        connect engine.fuelReturn to returnLine.inlet;\n        connect returnLine.outlet to fuelTankAssembly.fuelIn;\n\n        connect fuelTemperatureSensor.measurePoint to supplyLine.outlet;\n    }\n\n    part FuelTankAssembly {\n        port fuelOut: FuelPort;\n        port fuelIn: FuelPort;\n\n        operation supplyFuel(amount: FuelQuantity): Fuel;\n        operation receiveReturnedFuel(amount: FuelQuantity): void;\n    }\n\n    part Engine {\n        port fuelIn: FuelPort;\n        port fuelReturn: FuelPort;\n\n        operation consumeFuel(amount: FuelQuantity): void;\n        operation returnUnusedFuel(amount: FuelQuantity): Fuel;\n    }\n\n    part FuelLine {\n        port inlet: FuelPort;\n        port outlet: FuelPort;\n    }\n\n    part FuelTemperatureSensor {\n        port measurePoint: FuelPort;\n        port dataOut: TemperatureDataPort;\n\n        operation measureTemperature(): Temperature;\n        operation transmitTemperatureData(data: Temperature): void;\n    }\n\n    interface FuelPort {\n        flow fuel: Fuel;\n    }\n\n    interface TemperatureDataPort {\n        flow temperatureData: Temperature;\n    }\n\n    type Fuel;\n    type FuelQuantity;\n    type Temperature;\n\n    requirement ContinuousFuelSupply {\n        text \"The fuel system shall provide a continuous and stable fuel supply to the engine during vehicle operation.\"\n    }\n\n    requirement FuelReturn {\n        text \"The fuel system shall return unused fuel from the engine to the fuel tank assembly for recycling.\"\n    }\n\n    requirement FuelTemperatureMonitoring {\n        text \"The fuel system shall monitor and transmit information on fuel temperature to ensure operational safety and efficiency.\"\n    }\n\n    requirement ResourceOptimization {\n        text \"The fuel system shall optimize resource utilization by recycling excess fuel.\"\n    }\n}",
    "package PublishSubscribeArchitecture {\n\n    // Participants\n    part Producer\n    part Server\n    part Consumer\n\n    // Topics and Messages\n    type Topic\n    type Message {\n        attribute topic: Topic;\n        attribute content: String;\n    }\n\n    // Flows\n    flow SubscriptionRequest {\n        attribute topic: Topic;\n        attribute consumer: Consumer;\n    }\n    flow PublishRequest {\n        attribute message: Message;\n        attribute producer: Producer;\n    }\n    flow Delivery {\n        attribute message: Message;\n        attribute consumer: Consumer;\n    }\n\n    // Producer behavior\n    behavior ProducerBehavior {\n        action publishMessage {\n            input: message: Message;\n            output: publishRequest: PublishRequest;\n        }\n    }\n\n    // Consumer behavior\n    behavior ConsumerBehavior {\n        action subscribeToTopic {\n            input: topic: Topic;\n            output: subscriptionRequest: SubscriptionRequest;\n        }\n        action receiveMessage {\n            input: delivery: Delivery;\n        }\n    }\n\n    // Server behavior\n    behavior ServerBehavior {\n        action receiveSubscription {\n            input: subscriptionRequest: SubscriptionRequest;\n            effect: addSubscriber(subscriptionRequest.topic, subscriptionRequest.consumer);\n        }\n        action receivePublish {\n            input: publishRequest: PublishRequest;\n            effect: deliverToSubscribers(publishRequest.message);\n        }\n        action deliverToSubscribers {\n            input: message: Message;\n            output: deliveries: Delivery[*];\n        }\n    }\n\n    // System Structure\n    part system: PublishSubscribeSystem {\n        part producers: Producer[*];\n        part server: Server;\n        part consumers: Consumer[*];\n\n        connect producers.publishMessage.output to server.receivePublish.input;\n        connect consumers.subscribeToTopic.output to server.receiveSubscription.input;\n        connect server.deliverToSubscribers.output to consumers.receiveMessage.input;\n    }\n\n    // Requirements\n    requirement PublishSubscribeFlow {\n        text \"Producers shall be able to publish topic messages to the server.\"\n        text \"Consumers shall be able to subscribe to specific topics via the server.\"\n        text \"Upon successful subscription, when a new message related to the topic is published, the server shall deliver the message to all consumers subscribed to that topic.\"\n        text \"The system shall ensure reliable message publishing and distribution.\"\n        text \"The system shall ensure efficient information exchange between different users.\"\n    }\n}",
    "package TransportationSystem {\n\n    // Actors\n    actor User {\n        role driver : Driver\n        role passenger : Passenger[0..4]\n    }\n\n    actor Driver extends User\n    actor Passenger extends User\n\n    // System Definition\n    system VehicleTransportationSystem {\n        part vehicle : Vehicle\n        part users : User[1..5]\n        part environment : Environment\n    }\n\n    // Vehicle Definition\n    block Vehicle {\n        property fuelLevel : Real\n        property maxFuelCapacity : Real\n        property occupancy : Integer\n        property maxOccupancy : Integer = 5\n    }\n\n    // Environment Definition\n    block Environment {\n        property factors : String\n    }\n\n    // Use Cases\n    usecase ProvideTransportationServices {\n        subject VehicleTransportationSystem\n        actor User\n        includes BoardVehicle, OperateVehicle, RefuelVehicle, AlightVehicle\n    }\n\n    usecase BoardVehicle {\n        subject Vehicle\n        actor User\n        precondition vehicle.occupancy < vehicle.maxOccupancy\n        postcondition vehicle.occupancy = vehicle.occupancy@pre + 1\n    }\n\n    usecase OperateVehicle {\n        subject Vehicle\n        actor Driver\n        precondition vehicle.occupancy > 0\n        postcondition vehicle.fuelLevel < vehicle.fuelLevel@pre\n        note \"Driver operates vehicle to complete travel tasks.\"\n    }\n\n    usecase RefuelVehicle {\n        subject Vehicle\n        actor Driver\n        precondition vehicle.fuelLevel < 0.1 * vehicle.maxFuelCapacity\n        postcondition vehicle.fuelLevel = vehicle.maxFuelCapacity\n        note \"Driver may refuel at gas station if fuel is low.\"\n    }\n\n    usecase AlightVehicle {\n        subject Vehicle\n        actor User\n        precondition vehicle.occupancy > 0\n        postcondition vehicle.occupancy = vehicle.occupancy@pre - 1\n        note \"All individuals exit vehicle safely after transportation.\"\n    }\n\n    // Requirements\n    requirement TransportationService {\n        text \"The system shall provide transportation services for users (driver and up to four passengers).\"\n    }\n\n    requirement Boarding {\n        text \"The system shall facilitate user boarding, ensuring occupancy does not exceed five.\"\n    }\n\n    requirement Refueling {\n        text \"If fuel level falls below 10% of maximum tank capacity, the driver may refuel at a gas station.\"\n    }\n\n    requirement EnvironmentalFactors {\n        text \"Environmental factors shall be taken into account during transportation.\"\n    }\n\n    requirement SafeAlighting {\n        text \"After transportation, all individuals shall exit the vehicle safely.\"\n    }\n\n    requirement EfficientSafeTravel {\n        text \"The system shall guarantee an efficient and safe travel experience.\"\n    }\n\n    // Satisfy relationships\n    satisfy ProvideTransportationServices -> TransportationService\n    satisfy BoardVehicle -> Boarding\n    satisfy RefuelVehicle -> Refueling\n    satisfy OperateVehicle -> EnvironmentalFactors\n    satisfy AlightVehicle -> SafeAlighting\n    satisfy ProvideTransportationServices -> EfficientSafeTravel\n\n}",
    "package FuelManagementSystem {\n\n    import sysml::standard;\n\n    // Interface for fuel flow between components\n    interface FuelInterface {\n        attribute fuelTemperature: Real;\n        attribute fuelFlowRate: Real;\n        attribute fuelPressure: Real;\n        // Add more attributes as needed\n    }\n\n    // Fuel Tank Assembly definition\n    part FuelTankAssembly {\n        port fuelOutlet: out FuelInterface;\n        port fuelReturn: in FuelInterface;\n    }\n\n    // Engine Unit definition\n    part EngineUnit {\n        port fuelInlet: in FuelInterface;\n        port fuelReturnOutlet: out FuelInterface;\n    }\n\n    // System definition\n    part FuelSupplyReturnSystem {\n        part tank: FuelTankAssembly;\n        part engine: EngineUnit;\n\n        // Connect fuel supply from tank to engine\n        connect tank.fuelOutlet to engine.fuelInlet;\n\n        // Connect fuel return from engine to tank\n        connect engine.fuelReturnOutlet to tank.fuelReturn;\n    }\n\n    // Requirement definitions\n    requirement ContinuousReliableFuelSupply {\n        text \"The system shall ensure that the vehicle engine can continuously and reliably obtain the required fuel.\";\n    }\n\n    requirement SupportFuelReturnProcessing {\n        text \"The system shall support fuel return processing from the engine to the fuel tank.\";\n    }\n\n    requirement RealTimeFuelParameterMonitoring {\n        text \"The system shall monitor fuel parameters, including fuel temperature, in real time during both supply and return processes.\";\n    }\n\n    requirement EfficientFuelCirculation {\n        text \"The system shall enable efficient fuel circulation to meet engine operation requirements and improve vehicle fuel management intelligence and safety.\";\n    }\n\n    // Satisfy relationships\n    satisfy FuelSupplyReturnSystem satisfies ContinuousReliableFuelSupply;\n    satisfy FuelSupplyReturnSystem satisfies SupportFuelReturnProcessing;\n    satisfy FuelSupplyReturnSystem satisfies RealTimeFuelParameterMonitoring;\n    satisfy FuelSupplyReturnSystem satisfies EfficientFuelCirculation;\n\n}",
    "package VehicleFuelSystemManagement {\n\n    import sysml::standard\n\n    // Requirement Definitions\n    requirement EfficientFuelSupplyAndReturn {\n        text \"The system shall achieve efficient supply and return of fuel.\"\n    }\n\n    requirement ReliableSafeMonitoring {\n        text \"The system shall ensure reliability, safety, and monitoring of fuel delivery during normal vehicle operation.\"\n    }\n\n    // Block Definitions\n    block FuelSystem {\n        part fuelTank: FuelTankAssembly\n        part engine: Engine\n\n        connector supplyConnection: FuelSupplyPort\n        connector returnConnection: FuelReturnPort\n\n        satisfy EfficientFuelSupplyAndReturn\n        satisfy ReliableSafeMonitoring\n    }\n\n    block FuelTankAssembly {\n        port supplyPort: FuelSupplyPort\n        port returnPort: FuelReturnPort\n    }\n\n    block Engine {\n        port supplyPort: FuelSupplyPort\n        port returnPort: FuelReturnPort\n    }\n\n    // Interface Blocks\n    interface block FuelSupplyPort {\n        out flow fuel: Fuel\n        out fuelTemperature: Temperature\n    }\n\n    interface block FuelReturnPort {\n        in flow fuel: Fuel\n        out fuelTemperature: Temperature\n    }\n\n    // Value Types\n    value type Fuel {\n        // Placeholder for fuel properties\n    }\n\n    value type Temperature {\n        unit = \"degC\"\n        range = [ -60.0 .. 150.0 ]\n    }\n\n    // Allocations\n    allocation FuelFlowAllocation {\n        from FuelTankAssembly.supplyPort\n        to Engine.supplyPort\n    }\n\n    allocation FuelReturnAllocation {\n        from Engine.returnPort\n        to FuelTankAssembly.returnPort\n    }\n\n    // Use Cases\n    usecase SupplyFuel {\n        description \"Fuel flows from the fuel tank to the engine via the supply port, with temperature information provided.\"\n    }\n\n    usecase ReturnFuel {\n        description \"Unused fuel returns from the engine to the fuel tank via the return port, with temperature information provided.\"\n    }\n\n    // Satisfy relationships\n    satisfy SupplyFuel -> EfficientFuelSupplyAndReturn\n    satisfy ReturnFuel -> EfficientFuelSupplyAndReturn\n    satisfy FuelSystem -> ReliableSafeMonitoring\n\n}",
    "package PhotoCaptureSystem {\n\n    part User\n    part PhotoCaptureSystem\n\n    interface SceneSelection {\n        in scene: Scene\n    }\n\n    interface PhotoOutput {\n        out photo: Photo\n    }\n\n    type Scene\n    type Image\n    type Photo\n\n    action SelectScene {\n        in user: User\n        out scene: Scene\n    }\n\n    action AutoFocus {\n        in scene: Scene\n        out focusedImage: Image\n    }\n\n    action CapturePhoto {\n        in focusedImage: Image\n        out photo: Photo\n    }\n\n    usecase ObtainPhotoFromScene {\n        user: User\n        system: PhotoCaptureSystem\n\n        scenario {\n            step userSelectsScene: SelectScene(user: user) -> scene\n            step systemAutoFocuses: AutoFocus(scene: scene) -> focusedImage\n            step systemCapturesPhoto: CapturePhoto(focusedImage: focusedImage) -> photo\n            step userObtainsPhoto: photo\n        }\n    }\n\n    requirement R1_obtain_photos {\n        text \"The system shall enable users to obtain photos from real-world scenes.\"\n    }\n\n    requirement R2_select_scene {\n        text \"After a user selects a scene to capture, the system shall automatically perform focusing for the selected scene and generate an intermediate image.\"\n    }\n\n    requirement R3_capture_photo {\n        text \"Based on the focused image, the system shall capture and output the final photo.\"\n    }\n\n    requirement R4_automatic_process {\n        text \"The system shall complete the focusing and shooting processes automatically in the background, without requiring manual intervention at each step.\"\n    }\n\n    satisfy R1_obtain_photos by ObtainPhotoFromScene\n    satisfy R2_select_scene by AutoFocus\n    satisfy R3_capture_photo by CapturePhoto\n    satisfy R4_automatic_process by ObtainPhotoFromScene\n\n    PhotoCaptureSystem {\n        port sceneSelection: SceneSelection\n        port photoOutput: PhotoOutput\n\n        part autoFocus: AutoFocus\n        part capturePhoto: CapturePhoto\n\n        connect sceneSelection.scene -> autoFocus.scene\n        connect autoFocus.focusedImage -> capturePhoto.focusedImage\n        connect capturePhoto.photo -> photoOutput.photo\n    }\n}",
    "package PhotographyWorkflow {\n\n    // Define the main system\n    system PhotographySystem {\n        part user: User\n        part workflow: PhotographyWorkflow\n    }\n\n    // Define the user\n    part User {}\n\n    // Define the workflow\n    part PhotographyWorkflow {\n        part focusing: Focusing\n        part shooting: Shooting\n    }\n\n    // Define the focusing operation\n    part Focusing {\n        input scene: Scene\n        output focusedImage: Image\n        constraint \"Focusing produces a focused image from the selected scene\" {\n            focusedImage.isFocused = true\n            focusedImage.scene = scene\n        }\n    }\n\n    // Define the shooting operation\n    part Shooting {\n        input focusedImage: Image\n        output finalPhoto: Photo\n        constraint \"Shooting requires a focused image\" {\n            focusedImage.isFocused = true\n        }\n        constraint \"Final photo is high quality\" {\n            finalPhoto.quality = \"high\"\n        }\n    }\n\n    // Define the scene, image, and photo types\n    type Scene {\n        attribute description: String\n    }\n\n    type Image {\n        attribute isFocused: Boolean\n        attribute scene: Scene\n    }\n\n    type Photo {\n        attribute quality: String\n        attribute sourceImage: Image\n    }\n\n    // Define the workflow behavior\n    behavior PhotographyWorkflowBehavior {\n        input user: User\n        input scene: Scene\n        output finalPhoto: Photo\n\n        action selectScene {\n            output selectedScene: Scene\n        }\n\n        action performFocusing {\n            input selectedScene: Scene\n            output focusedImage: Image\n        }\n\n        action performShooting {\n            input focusedImage: Image\n            output finalPhoto: Photo\n        }\n\n        // Sequential workflow\n        constraint \"Workflow is sequential: Focusing then Shooting\" {\n            selectScene.precedes(performFocusing)\n            performFocusing.precedes(performShooting)\n        }\n\n        constraint \"Focusing ensures image is focused before shooting\" {\n            performFocusing.focusedImage.isFocused = true\n        }\n\n        constraint \"Final photo is high quality\" {\n            performShooting.finalPhoto.quality = \"high\"\n        }\n    }\n\n    // Bind workflow behavior to workflow part\n    PhotographyWorkflow.behavior = PhotographyWorkflowBehavior\n}",
    "package PhotographyWorkflow {\n\n    // Actors\n    actor User;\n\n    // System Definition\n    system PhotographySystem {\n        part user: User;\n        part sceneSelector: SceneSelector;\n        part focuser: FocusingProcess;\n        part shooter: ShootingProcess;\n    }\n\n    // Scene Selection\n    part SceneSelector {\n        output selectedScene: Scene;\n        input userInput: SceneSelectionRequest;\n    }\n\n    // Focusing Process\n    part FocusingProcess {\n        input scene: Scene;\n        output image: Image;\n    }\n\n    // Shooting Process\n    part ShootingProcess {\n        input image: Image;\n        output photograph: Photograph;\n    }\n\n    // Data Types\n    type Scene;\n    type Image;\n    type Photograph;\n    type SceneSelectionRequest;\n\n    // Requirements\n    requirement SupportPhotographyWorkflow {\n        text \"The system shall support photography workflows, allowing users to frame and capture a scene.\"\n    }\n\n    requirement AutomaticFocusingAndShooting {\n        text \"The system shall automatically perform focusing and shooting steps after scene selection.\"\n    }\n\n    requirement HighQualityPhotograph {\n        text \"The system shall produce a high-quality photograph from the selected scene without requiring manual intermediate processing by the user.\"\n    }\n\n    // Use Cases\n    usecase FrameAndCaptureScene {\n        actor User;\n        subject PhotographySystem;\n        step selectScene: \"User selects a specific scene.\";\n        step focusScene: \"System performs focusing on the selected scene to generate an image.\";\n        step shootScene: \"System carries out shooting process based on the image to produce a final photograph.\";\n    }\n\n    // Workflow Behavior\n    behavior PhotographyWorkflow {\n        input userInput: SceneSelectionRequest;\n        output photograph: Photograph;\n\n        step selectScene {\n            output selectedScene: Scene;\n            do SceneSelector(userInput) -> selectedScene;\n        }\n        step focusScene {\n            input selectedScene: Scene;\n            output image: Image;\n            do FocusingProcess(selectedScene) -> image;\n        }\n        step shootScene {\n            input image: Image;\n            output photograph: Photograph;\n            do ShootingProcess(image) -> photograph;\n        }\n        flow selectScene -> focusScene -> shootScene;\n    }\n\n    // Satisfy relationships\n    satisfy SupportPhotographyWorkflow by PhotographyWorkflow;\n    satisfy AutomaticFocusingAndShooting by PhotographyWorkflow;\n    satisfy HighQualityPhotograph by ShootingProcess;\n\n}",
    "package PhotographyAutomationSystem {\n\n    part User\n\n    part PhotographySystem {\n        part FocusProcessor\n        part ShootingOperator\n    }\n\n    interface Scene\n    interface Image\n    interface Photograph\n\n    action ProvideScene {\n        in parameter scene: Scene\n        out parameter acceptedScene: Scene\n    }\n\n    action FocusProcess {\n        in parameter inputScene: Scene\n        out parameter focusedImage: Image\n    }\n\n    action ShootingOperation {\n        in parameter inputImage: Image\n        out parameter photograph: Photograph\n    }\n\n    action ObtainPhotograph {\n        in parameter scene: Scene\n        out parameter photograph: Photograph\n    }\n\n    requirement AutomatePhotographyProcess {\n        text \"The system shall automate the photography process such that users only need to provide a shooting scene, and the system will perform focus processing and shooting operations to generate a final photograph without requiring in-depth user intervention.\"\n    }\n\n    requirement SeamlessIntegration {\n        text \"The system shall seamlessly integrate focus processing and shooting operations, simplifying the photography workflow.\"\n    }\n\n    requirement UserSimplicity {\n        text \"The system shall require no in-depth user intervention in focusing or shooting details.\"\n    }\n\n    constraint NoUserIntervention {\n        expression \"PhotographySystem.FocusProcessor and PhotographySystem.ShootingOperator operate automatically without requiring user input beyond the initial scene.\"\n    }\n\n    usecase AutomatedPhotography {\n        actor User\n        subject PhotographySystem\n        scenario {\n            step 1: User invokes ProvideScene with scene\n            step 2: PhotographySystem.FocusProcessor performs FocusProcess with inputScene = scene, outputs focusedImage\n            step 3: PhotographySystem.ShootingOperator performs ShootingOperation with inputImage = focusedImage, outputs photograph\n            step 4: User receives photograph\n        }\n    }\n\n    stateMachine PhotographyWorkflow {\n        state Idle\n        state SceneProvided\n        state FocusProcessing\n        state Shooting\n        state PhotographReady\n\n        transition Idle -> SceneProvided on ProvideScene\n        transition SceneProvided -> FocusProcessing on FocusProcess\n        transition FocusProcessing -> Shooting on ShootingOperation\n        transition Shooting -> PhotographReady on ObtainPhotograph\n    }\n\n    satisfies AutomatePhotographyProcess\n    satisfies SeamlessIntegration\n    satisfies UserSimplicity\n    satisfies NoUserIntervention\n\n}",
    "package PhotographyWorkflowSystem {\n\n    // Define the main system\n    system PhotographyWorkflow {\n        part user: User;\n        part workflow: PhotographyWorkflowSoftware;\n    }\n\n    // User definition\n    part User {\n        // User provides the desired scene\n        property desiredScene: Scene;\n    }\n\n    // PhotographyWorkflowSoftware definition\n    part PhotographyWorkflowSoftware {\n        // Internal parts\n        part focus: Focus;\n        part shoot: Shoot;\n\n        // Input and output\n        input scene: Scene;\n        output picture: Picture;\n\n        // Workflow behavior\n        behavior {\n            // User provides scene\n            receive scene;\n            // Focus operation\n            let image: Image = focus.focusOn(scene);\n            // Shoot operation\n            let picture: Picture = shoot.shootImage(image);\n            // Output picture\n            send picture;\n        }\n    }\n\n    // Focus operation definition\n    part Focus {\n        input scene: Scene;\n        output image: Image;\n\n        behavior {\n            // Generate image frame from scene\n            image = new Image(scene);\n            send image;\n        }\n\n        operation focusOn(s: Scene): Image {\n            return new Image(s);\n        }\n    }\n\n    // Shoot operation definition\n    part Shoot {\n        input image: Image;\n        output picture: Picture;\n\n        behavior {\n            // Produce photograph from image\n            picture = new Picture(image);\n            send picture;\n        }\n\n        operation shootImage(img: Image): Picture {\n            return new Picture(img);\n        }\n    }\n\n    // Data definitions\n    type Scene;\n    type Image;\n    type Picture;\n}",
    "package PhotographyWorkflow {\n\n    part User {\n        // Represents the user interacting with the system\n    }\n\n    part CameraSystem {\n        part SceneSelector\n        part FocusingMechanism\n        part ImageSensor\n        part ImageProcessor\n    }\n\n    interface Photographing {\n        in parameter selectedScene: Scene\n        out parameter finalImage: Image\n    }\n\n    type Scene\n    type Image\n\n    action SelectScene {\n        in parameter user: User\n        out parameter selectedScene: Scene\n    }\n\n    action FocusScene {\n        in parameter selectedScene: Scene\n        out parameter focusStatus: FocusStatus\n    }\n\n    enum FocusStatus {\n        CLEAR\n        UNCLEAR\n    }\n\n    action CapturePhoto {\n        in parameter focusStatus: FocusStatus\n        out parameter rawImage: Image\n    }\n\n    action ProcessImage {\n        in parameter rawImage: Image\n        out parameter finalImage: Image\n    }\n\n    usecase OneClickShootingExperience {\n        description \"Provides a convenient one-click shooting experience, automatically performing focusing and shooting in sequence.\"\n        subject CameraSystem\n        actor User\n    }\n\n    behavior PhotographyWorkflowBehavior implements Photographing {\n        input selectedScene: Scene\n        output finalImage: Image\n\n        do {\n            focusStatus = FocusScene(selectedScene)\n            if focusStatus == FocusStatus::CLEAR {\n                rawImage = CapturePhoto(focusStatus)\n                finalImage = ProcessImage(rawImage)\n            }\n        }\n    }\n\n    requirement R1 {\n        text \"The system shall allow users to select a scene and capture it as a photograph.\"\n    }\n\n    requirement R2 {\n        text \"The system shall focus the selected scene before capturing the photograph to ensure optimal image sharpness.\"\n    }\n\n    requirement R3 {\n        text \"If the camera detects that the focus is clear, it shall proceed to take the photo and generate the final image.\"\n    }\n\n    requirement R4 {\n        text \"The system shall automatically perform focusing and shooting operations in sequence, providing a convenient one-click shooting experience.\"\n    }\n\n    satisfy R1 by SelectScene\n    satisfy R2 by FocusScene\n    satisfy R3 by CapturePhoto\n    satisfy R4 by PhotographyWorkflowBehavior\n\n}",
    "package PhotographWorkflow {\n\n    // Actors\n    actor User;\n\n    // System Definition\n    system PhotographSystem {\n        part user: User;\n        part sceneSelector: SceneSelector;\n        part focuser: Focuser;\n        part imageGenerator: ImageGenerator;\n        part focusEvaluator: FocusEvaluator;\n        part shooter: Shooter;\n        part photoProducer: PhotoProducer;\n    }\n\n    // Blocks\n    block SceneSelector {\n        in userInput: Scene;\n        out selectedScene: Scene;\n    }\n\n    block Focuser {\n        in scene: Scene;\n        out focusedScene: Scene;\n    }\n\n    block ImageGenerator {\n        in focusedScene: Scene;\n        out image: Image;\n    }\n\n    block FocusEvaluator {\n        in image: Image;\n        out isWellFocused: Boolean;\n    }\n\n    block Shooter {\n        in image: Image;\n        in isWellFocused: Boolean;\n        out photo: Photo;\n    }\n\n    block PhotoProducer {\n        in photo: Photo;\n        out finalPhoto: Photo;\n    }\n\n    // Data Types\n    type Scene;\n    type Image;\n    type Photo;\n\n    // Requirements\n    requirement WorkflowSupport {\n        text \"The system shall support users in a workflow for capturing high-quality photographs.\";\n    }\n\n    requirement SceneSelection {\n        text \"Users shall be able to select a scene.\";\n    }\n\n    requirement Focusing {\n        text \"The system shall perform focusing on the selected scene.\";\n    }\n\n    requirement ImageGeneration {\n        text \"The system shall generate an image of the focused scene.\";\n    }\n\n    requirement FocusEvaluation {\n        text \"The system shall evaluate the generated image for focus quality.\";\n    }\n\n    requirement ConditionalShooting {\n        text \"The system shall proceed with shooting only if the image is well-focused.\";\n    }\n\n    requirement PhotoProduction {\n        text \"The system shall convert the focused image into a photograph and produce the final photo.\";\n    }\n\n    requirement AutomaticWorkflow {\n        text \"The entire shooting process shall be automatically linked from scene input to photo output.\";\n    }\n\n    requirement QualityAssurance {\n        text \"Shooting shall only take place when the focus is appropriate, improving clarity and quality of photographs.\";\n    }\n\n    // Use Case\n    usecase CapturePhoto {\n        actor user;\n        \"User selects scene\"\n        \"System focuses scene\"\n        \"System generates image\"\n        \"System evaluates focus\"\n        \"If well-focused, system shoots and produces photo\"\n    }\n\n    // Behavior (Activity)\n    activity PhotographWorkflowActivity {\n        input userInput: Scene;\n        output finalPhoto: Photo;\n\n        action selectScene {\n            input userInput: Scene;\n            output selectedScene: Scene;\n        }\n\n        action focusScene {\n            input selectedScene: Scene;\n            output focusedScene: Scene;\n        }\n\n        action generateImage {\n            input focusedScene: Scene;\n            output image: Image;\n        }\n\n        action evaluateFocus {\n            input image: Image;\n            output isWellFocused: Boolean;\n        }\n\n        decision isWellFocused;\n\n        action shootPhoto {\n            input image: Image;\n            output photo: Photo;\n        }\n\n        action produceFinalPhoto {\n            input photo: Photo;\n            output finalPhoto: Photo;\n        }\n\n        // Control Flow\n        flow {\n            userInput -> selectScene.userInput;\n            selectScene.selectedScene -> focusScene.selectedScene;\n            focusScene.focusedScene -> generateImage.focusedScene;\n            generateImage.image -> evaluateFocus.image;\n            evaluateFocus.isWellFocused -> isWellFocused;\n            isWellFocused [true] -> shootPhoto.image;\n            generateImage.image -> shootPhoto.image;\n            shootPhoto.photo -> produceFinalPhoto.photo;\n            produceFinalPhoto.finalPhoto -> finalPhoto;\n        }\n    }\n}",
    "package PhotographyWorkflow {\n\n    // Actors\n    actor User;\n\n    // System Definition\n    system PhotographySystem {\n        operation takePhoto();\n        part sceneAcquisition: SceneAcquisition;\n        part focusing: Focusing;\n        part shooting: Shooting;\n        part display: Display;\n    }\n\n    // Blocks for workflow steps\n    block SceneAcquisition {\n        operation acquireScene(): Scene;\n    }\n\n    block Focusing {\n        operation focus(scene: Scene): Image;\n    }\n\n    block Shooting {\n        operation shoot(image: Image): Photo;\n    }\n\n    block Display {\n        operation show(photo: Photo);\n    }\n\n    // Data Types\n    type Scene;\n    type Image;\n    type Photo;\n\n    // Use Case\n    usecase CompletePhotographyWorkflow {\n        actor User;\n        subject PhotographySystem;\n        description \"User triggers 'take photo' once; system automatically acquires scene, focuses, shoots, and displays the photo without further user intervention.\"\n    }\n\n    // Requirements\n    requirement R1 \"Single Trigger\" {\n        text \"The user only needs to trigger the 'take photo' operation once to start the workflow.\";\n    }\n    requirement R2 \"Automatic Scene Acquisition\" {\n        text \"The system acquires the current shooting scene automatically.\";\n    }\n    requirement R3 \"Automatic Focusing\" {\n        text \"The system inputs the acquired scene into the focus function and performs focusing automatically.\";\n    }\n    requirement R4 \"Automatic Shooting\" {\n        text \"The system executes the shooting operation based on the focused image.\";\n    }\n    requirement R5 \"Immediate Display\" {\n        text \"After shooting, the system immediately displays the resulting photo.\";\n    }\n    requirement R6 \"No Manual Intervention\" {\n        text \"The system completes all steps without requiring manual intervention from the user at each step.\";\n    }\n    requirement R7 \"Seamless Integration\" {\n        text \"The entire process is seamlessly integrated to improve convenience and smoothness.\";\n    }\n\n    // Requirement Satisfaction\n    satisfy R1 by PhotographySystem.takePhoto;\n    satisfy R2 by PhotographySystem.sceneAcquisition.acquireScene;\n    satisfy R3 by PhotographySystem.focusing.focus;\n    satisfy R4 by PhotographySystem.shooting.shoot;\n    satisfy R5 by PhotographySystem.display.show;\n    satisfy R6 by PhotographySystem;\n    satisfy R7 by PhotographySystem;\n\n    // Workflow Behavior\n    behavior PhotographyWorkflowBehavior {\n        input: trigger: takePhoto;\n        do {\n            let scene = sceneAcquisition.acquireScene();\n            let image = focusing.focus(scene);\n            let photo = shooting.shoot(image);\n            display.show(photo);\n        }\n    }\n\n    // Bind behavior to operation\n    PhotographySystem.takePhoto.behavior = PhotographyWorkflowBehavior;\n\n    // User interaction\n    interaction UserTriggersTakePhoto {\n        lifeline user: User;\n        lifeline system: PhotographySystem;\n        user -> system: takePhoto();\n    }\n}",
    "package AutomaticBrakingControlSystem {\n\n    // System Definition\n    system AutomaticBrakingControlSystem {\n        part vehicle : Vehicle\n        part brakingControlUnit : BrakingControlUnit\n        part brakePedalSensor : BrakePedalSensor\n        part tractionSensor : TractionSensor\n        part brakeActuator : BrakeActuator\n\n        // System Activation\n        constraint [activation] {\n            when vehicle.ignitionKey.position == #start {\n                brakingControlUnit.active == true;\n            }\n        }\n\n        // Continuous Monitoring\n        constraint [monitoring] {\n            brakingControlUnit.active == true implies\n                brakePedalSensor.status == monitored and\n                tractionSensor.status == monitored;\n        }\n\n        // Brake Pressure Detection\n        constraint [brakePressureDetection] {\n            brakePedalSensor.pressed == true implies\n                brakePedalSensor.brakePressure > 0;\n        }\n\n        // Traction Evaluation\n        constraint [tractionEvaluation] {\n            tractionSensor.roadAdhesion in RoadAdhesionLevel;\n        }\n\n        // Intelligent Adjustment\n        constraint [intelligentAdjustment] {\n            brakingControlUnit.active == true and\n            brakePedalSensor.pressed == true implies\n                brakeActuator.brakePressure = \n                    brakingControlUnit.calculateBrakePressure(\n                        brakePedalSensor.brakePressure,\n                        tractionSensor.roadAdhesion\n                    ) and\n                brakeActuator.modulationFrequency = \n                    brakingControlUnit.calculateModulationFrequency(\n                        tractionSensor.roadAdhesion\n                    );\n        }\n\n        // Safe and Reliable Braking\n        constraint [safeBraking] {\n            brakeActuator.brakePressure in SafeBrakePressureRange;\n            brakeActuator.modulationFrequency in SafeModulationFrequencyRange;\n        }\n\n        // Automatic Monitoring and Regulation\n        constraint [autoRegulation] {\n            brakingControlUnit.regulation == automatic;\n            brakingControlUnit.userIntervention == false;\n        }\n\n        // Optimal State Operation\n        constraint [optimalOperation] {\n            brakingControlUnit.operatingState == #optimal;\n        }\n    }\n\n    // Supporting Definitions\n    part Vehicle {\n        attribute ignitionKey : IgnitionKey\n    }\n\n    part IgnitionKey {\n        attribute position : IgnitionKeyPosition\n    }\n\n    enum IgnitionKeyPosition {\n        #off,\n        #accessory,\n        #start,\n        #run\n    }\n\n    part BrakingControlUnit {\n        attribute active : Boolean\n        attribute regulation : RegulationMode\n        attribute userIntervention : Boolean\n        attribute operatingState : OperatingState\n\n        operation calculateBrakePressure(\n            brakePedalPressure : Real,\n            roadAdhesion : RoadAdhesionLevel\n        ) : Real\n\n        operation calculateModulationFrequency(\n            roadAdhesion : RoadAdhesionLevel\n        ) : Real\n    }\n\n    enum RegulationMode {\n        automatic,\n        manual\n    }\n\n    enum OperatingState {\n        #optimal,\n        #suboptimal,\n        #fault\n    }\n\n    part BrakePedalSensor {\n        attribute status : SensorStatus\n        attribute pressed : Boolean\n        attribute brakePressure : Real\n    }\n\n    part TractionSensor {\n        attribute status : SensorStatus\n        attribute roadAdhesion : RoadAdhesionLevel\n    }\n\n    enum SensorStatus {\n        monitored,\n        notMonitored,\n        fault\n    }\n\n    enum RoadAdhesionLevel {\n        high,\n        medium,\n        low\n    }\n\n    part BrakeActuator {\n        attribute brakePressure : Real\n        attribute modulationFrequency : Real\n    }\n\n    value SafeBrakePressureRange : Real[0.0..1.0] // normalized\n    value SafeModulationFrequencyRange : Real[0.0..100.0] // Hz\n\n}",
    "package BatteryChargingControlSystem {\n\n    part BatteryChargingControlSystem {\n        part battery: Battery;\n        part charger: Charger;\n        part controller: ChargingController;\n    }\n\n    part Battery {\n        attribute capacity: Real;\n        attribute level: Real;\n        constraint [BatteryLevelRange] {\n            level >= 0.0 and level <= capacity;\n        }\n    }\n\n    part Charger {\n        attribute isSupplyingCharge: Boolean;\n    }\n\n    part ChargingController {\n        reference battery: Battery;\n        reference charger: Charger;\n\n        operation monitorBatteryLevel() {\n            // Monitors battery.level in real time\n        }\n\n        operation startCharging() {\n            precondition battery.level < battery.capacity;\n            effect charger.isSupplyingCharge = true;\n        }\n\n        operation stopCharging() {\n            precondition battery.level >= battery.capacity;\n            effect charger.isSupplyingCharge = false;\n        }\n    }\n\n    requirement SafeEfficientFullCharge {\n        text \"The system shall ensure the battery is safely and efficiently fully charged.\";\n    }\n\n    requirement RealTimeMonitoring {\n        text \"The system shall monitor the current battery level in real time.\";\n    }\n\n    requirement AutomaticCharging {\n        text \"The system shall automatically supply charge when the battery level is below 100%.\";\n    }\n\n    requirement AutomaticTermination {\n        text \"The system shall automatically terminate charging when the battery level reaches or exceeds 100%.\";\n    }\n\n    requirement NoManualIntervention {\n        text \"The system shall not require manual intervention for charging termination.\";\n    }\n\n    requirement CoreFunctions {\n        text \"The system shall provide battery capacity monitoring, automatic charging, and charging termination control.\";\n    }\n\n    requirement HealthyCharging {\n        text \"The system shall ensure healthy charging of the battery.\";\n    }\n\n    requirement EnhancedConvenienceSafety {\n        text \"The system shall enhance convenience and safety of use.\";\n    }\n\n    satisfies BatteryChargingControlSystem -> SafeEfficientFullCharge;\n    satisfies BatteryChargingControlSystem -> RealTimeMonitoring;\n    satisfies BatteryChargingControlSystem -> AutomaticCharging;\n    satisfies BatteryChargingControlSystem -> AutomaticTermination;\n    satisfies BatteryChargingControlSystem -> NoManualIntervention;\n    satisfies BatteryChargingControlSystem -> CoreFunctions;\n    satisfies BatteryChargingControlSystem -> HealthyCharging;\n    satisfies BatteryChargingControlSystem -> EnhancedConvenienceSafety;\n\n    constraint [AutomaticChargingControl] {\n        if battery.level < battery.capacity {\n            charger.isSupplyingCharge = true;\n        } else {\n            charger.isSupplyingCharge = false;\n        }\n    }\n}",
    "package BatteryChargingSystem {\n\n    part Battery {\n        attribute level: Real[0.0..100.0] = 0.0; // percentage\n    }\n\n    part Charger {\n        operation startCharging();\n        operation stopCharging();\n        operation replenish(battery: Battery);\n    }\n\n    part ChargingController {\n        reference battery: Battery;\n        reference charger: Charger;\n\n        stateMachine ChargingProcess {\n            state Idle {\n                transition to Charging when startRequested;\n            }\n            state Charging {\n                entry / charger.startCharging();\n                do / monitorAndReplenish();\n                transition to Terminated when battery.level >= 100.0;\n            }\n            state Terminated {\n                entry / charger.stopCharging();\n            }\n        }\n\n        action monitorAndReplenish() {\n            while (battery.level < 100.0) {\n                charger.replenish(battery);\n                // Assume battery.level is updated by replenish\n            }\n        }\n\n        event startRequested;\n    }\n\n    requirement ContinuousMonitoring {\n        text \"The system shall continuously monitor the battery level during charging.\";\n    }\n\n    requirement AutomaticReplenishment {\n        text \"If the battery level is below 100%, the system shall automatically replenish the battery.\";\n    }\n\n    requirement TerminateAtFullCharge {\n        text \"The system shall terminate charging when the battery level reaches or exceeds 100%.\";\n    }\n\n    requirement FullyAutomated {\n        text \"The charging operation shall be fully automated, requiring no manual intervention.\";\n    }\n\n    satisfies ChargingController -> ContinuousMonitoring;\n    satisfies ChargingController -> AutomaticReplenishment;\n    satisfies ChargingController -> TerminateAtFullCharge;\n    satisfies ChargingController -> FullyAutomated;\n\n}",
    "package CameraSystem {\n\n    part system: CameraSystem\n\n    part user: User\n\n    part autofocus: AutofocusSubsystem\n\n    part imaging: ImagingSubsystem\n\n    part storage: PhotoStorageSubsystem\n\n    part scene: Scene\n\n    // Requirements\n    requirement req_camera_function {\n        text \"The system shall implement a camera function capable of taking photos of various scenes.\"\n    }\n\n    requirement req_autofocus {\n        text \"The system shall automatically focus on objects within the selected scene before imaging.\"\n    }\n\n    requirement req_imaging {\n        text \"The system shall capture a clear and realistic image as a photograph after focusing.\"\n    }\n\n    requirement req_photo_storage {\n        text \"The system shall record and save all photos taken.\"\n    }\n\n    requirement req_user_interaction {\n        text \"The user shall only need to select or confirm the scene to be photographed.\"\n    }\n\n    requirement req_automatic_operation {\n        text \"The camera shall automatically complete focusing and imaging operations to generate high-quality photos.\"\n    }\n\n    // Use Cases\n    usecase TakePhoto {\n        brief \"User selects a scene; system focuses, images, and stores the photo automatically.\"\n        actor user\n        includes SelectScene, Autofocus, CaptureImage, StorePhoto\n    }\n\n    usecase SelectScene {\n        brief \"User selects or confirms the scene to be photographed.\"\n        actor user\n    }\n\n    usecase Autofocus {\n        brief \"System automatically focuses on objects in the selected scene.\"\n        subject autofocus\n    }\n\n    usecase CaptureImage {\n        brief \"System captures a clear and realistic image as a photograph.\"\n        subject imaging\n    }\n\n    usecase StorePhoto {\n        brief \"System records and saves the captured photo.\"\n        subject storage\n    }\n\n    // Structure\n    partdef CameraSystem {\n        part autofocus: AutofocusSubsystem\n        part imaging: ImagingSubsystem\n        part storage: PhotoStorageSubsystem\n        part user: User\n    }\n\n    partdef AutofocusSubsystem {\n        // Internal structure or properties can be defined as needed\n    }\n\n    partdef ImagingSubsystem {\n        // Internal structure or properties can be defined as needed\n    }\n\n    partdef PhotoStorageSubsystem {\n        // Internal structure or properties can be defined as needed\n    }\n\n    partdef User {\n        // Represents the camera user\n    }\n\n    partdef Scene {\n        // Represents a scene to be photographed\n    }\n\n    // Behavior\n    statemachine CameraOperation {\n        state Idle\n        state SceneSelected\n        state Focusing\n        state Imaging\n        state Storing\n        state Completed\n\n        transition Idle -> SceneSelected {\n            trigger: user.selectScene(scene)\n        }\n        transition SceneSelected -> Focusing {\n            effect: autofocus.focusOn(scene)\n        }\n        transition Focusing -> Imaging {\n            effect: imaging.captureImage()\n        }\n        transition Imaging -> Storing {\n            effect: storage.savePhoto()\n        }\n        transition Storing -> Completed\n        transition Completed -> Idle\n    }\n\n    // Satisfy relationships\n    satisfy CameraSystem -> req_camera_function\n    satisfy AutofocusSubsystem -> req_autofocus\n    satisfy ImagingSubsystem -> req_imaging\n    satisfy PhotoStorageSubsystem -> req_photo_storage\n    satisfy User -> req_user_interaction\n    satisfy CameraSystem -> req_automatic_operation\n\n}",
    "package DigitalCameraShootingProcess {\n\n    requirement ShootingProcessAutomation {\n        text \"The system shall automate the entire shooting process from viewfinding and focusing to imaging with a single user operation.\"\n    }\n\n    requirement SceneSelection {\n        text \"The system shall allow the user to select the shooting scene.\"\n    }\n\n    requirement AutoFocus {\n        text \"The system shall automatically focus on the selected scene.\"\n    }\n\n    requirement AutomatedImaging {\n        text \"The system shall automatically generate an image that meets the requirements after focusing.\"\n    }\n\n    requirement PhotoOutput {\n        text \"The system shall capture and produce the final photo.\"\n    }\n\n    requirement NoManualAdjustment {\n        text \"The system shall not require the user to manually adjust focus or initiate imaging.\"\n    }\n\n    requirement ModuleCollaboration {\n        text \"All functional modules shall collaborate to complete the shooting and image acquisition process.\"\n    }\n\n    requirement HighQualityPhoto {\n        text \"The system shall output high-quality photos.\"\n    }\n\n    block DigitalCameraSystem {\n        part user: User\n        part sceneSelector: SceneSelector\n        part autoFocusModule: AutoFocusModule\n        part imagingModule: ImagingModule\n        part photoOutputModule: PhotoOutputModule\n\n        satisfies ShootingProcessAutomation\n        satisfies SceneSelection\n        satisfies AutoFocus\n        satisfies AutomatedImaging\n        satisfies PhotoOutput\n        satisfies NoManualAdjustment\n        satisfies ModuleCollaboration\n        satisfies HighQualityPhoto\n    }\n\n    block User {\n        operation selectScene()\n    }\n\n    block SceneSelector {\n        operation receiveSceneSelection()\n        operation notifyAutoFocus()\n    }\n\n    block AutoFocusModule {\n        operation focusOnScene()\n        operation notifyImaging()\n    }\n\n    block ImagingModule {\n        operation generateImage()\n        operation notifyPhotoOutput()\n    }\n\n    block PhotoOutputModule {\n        operation capturePhoto()\n        operation outputPhoto()\n    }\n\n    interaction ShootingProcess {\n        participant user: User\n        participant sceneSelector: SceneSelector\n        participant autoFocusModule: AutoFocusModule\n        participant imagingModule: ImagingModule\n        participant photoOutputModule: PhotoOutputModule\n\n        user.selectScene()\n        sceneSelector.receiveSceneSelection()\n        sceneSelector.notifyAutoFocus()\n        autoFocusModule.focusOnScene()\n        autoFocusModule.notifyImaging()\n        imagingModule.generateImage()\n        imagingModule.notifyPhotoOutput()\n        photoOutputModule.capturePhoto()\n        photoOutputModule.outputPhoto()\n    }\n}",
    "package VehicleSimulation {\n\n    import ScalarValues::*;\n    import SI::*;\n\n    part VehicleSimulationSystem {\n        attribute mass: Mass;\n        attribute initialPosition: Length;\n        attribute initialVelocity: Velocity;\n        attribute timeStep: Duration;\n        attribute powerInputSequence: Sequence<Power>;\n        attribute numSteps: Integer;\n\n        part vehicle: Vehicle;\n        part simulator: Simulator;\n        part user: User;\n\n        connector userToSystem {\n            end user;\n            end system: VehicleSimulationSystem;\n        }\n\n        constraint [massInput] {\n            user.massInput = system.mass;\n        }\n        constraint [initialPositionInput] {\n            user.initialPositionInput = system.initialPosition;\n        }\n        constraint [initialVelocityInput] {\n            user.initialVelocityInput = system.initialVelocity;\n        }\n        constraint [timeStepInput] {\n            user.timeStepInput = system.timeStep;\n        }\n        constraint [powerInputSequenceInput] {\n            user.powerInputSequenceInput = system.powerInputSequence;\n        }\n        constraint [numStepsInput] {\n            user.numStepsInput = system.numSteps;\n        }\n\n        constraint [simulation] {\n            simulator.mass = system.mass;\n            simulator.initialPosition = system.initialPosition;\n            simulator.initialVelocity = system.initialVelocity;\n            simulator.timeStep = system.timeStep;\n            simulator.powerInputSequence = system.powerInputSequence;\n            simulator.numSteps = system.numSteps;\n        }\n\n        constraint [outputTrajectory] {\n            system.trajectory = simulator.positionTrajectory;\n        }\n\n        attribute trajectory: Sequence<Length>;\n    }\n\n    part Vehicle {\n        attribute mass: Mass;\n        attribute position: Length;\n        attribute velocity: Velocity;\n    }\n\n    part Simulator {\n        attribute mass: Mass;\n        attribute initialPosition: Length;\n        attribute initialVelocity: Velocity;\n        attribute timeStep: Duration;\n        attribute powerInputSequence: Sequence<Power>;\n        attribute numSteps: Integer;\n\n        attribute positionTrajectory: Sequence<Length>;\n        attribute velocityTrajectory: Sequence<Velocity>;\n\n        constraint [simulationLogic] {\n            // For each time step i in 0..numSteps-1:\n            //   power = powerInputSequence[i]\n            //   acceleration = power / (mass * velocity)  (if velocity != 0, else 0)\n            //   velocity[i+1] = velocity[i] + acceleration * timeStep\n            //   position[i+1] = position[i] + velocity[i+1] * timeStep\n            //   position[0] = initialPosition\n            //   velocity[0] = initialVelocity\n        }\n    }\n\n    part User {\n        attribute massInput: Mass;\n        attribute initialPositionInput: Length;\n        attribute initialVelocityInput: Velocity;\n        attribute timeStepInput: Duration;\n        attribute powerInputSequenceInput: Sequence<Power>;\n        attribute numStepsInput: Integer;\n    }\n}",
    "package CameraSystem {\n\n    // Actors\n    actor User\n\n    // System Definition\n    system CameraSystem {\n        part screen: Screen\n        part lens: Lens\n        part imageProcessor: ImageProcessor\n        part storage: Storage\n        part controller: Controller\n    }\n\n    // Use Cases\n    usecase PhotographAndView {\n        actor User\n        description \"User performs a simple shooting operation to photograph a scene and view the result.\"\n    }\n\n    // Requirements\n    requirement BasicCameraFunctionality {\n        text \"The system shall implement basic camera shooting and display functionality.\"\n    }\n\n    requirement SceneInput {\n        text \"While framing, the user can input the current scene into the system.\"\n    }\n\n    requirement FocusingProcess {\n        text \"The system shall perform a focusing process on the scene to obtain an image.\"\n    }\n\n    requirement ImageCapture {\n        text \"The system shall capture the obtained image to generate a photo.\"\n    }\n\n    requirement PhotoDisplay {\n        text \"The system shall automatically display the captured photo on the screen.\"\n    }\n\n    requirement SeamlessIntegration {\n        text \"Scene processing, image generation, and photo display shall be seamlessly and automatically integrated.\"\n    }\n\n    requirement SimpleUserOperation {\n        text \"The user shall only need to perform a simple shooting operation to obtain a complete experience.\"\n    }\n\n    // States\n    stateMachine CameraOperation {\n        state Idle\n        state Framing\n        state Focusing\n        state Capturing\n        state Displaying\n\n        transition Idle -> Framing {\n            trigger User.shoot()\n        }\n        transition Framing -> Focusing\n        transition Focusing -> Capturing\n        transition Capturing -> Displaying\n        transition Displaying -> Idle\n    }\n\n    // Interfaces\n    interface SceneInput {\n        in scene: Scene\n    }\n\n    interface ImageOutput {\n        out image: Image\n    }\n\n    interface PhotoOutput {\n        out photo: Photo\n    }\n\n    // Blocks\n    block Scene {\n        attribute data: String\n    }\n\n    block Image {\n        attribute data: String\n    }\n\n    block Photo {\n        attribute data: String\n    }\n\n    block Screen {\n        operation display(photo: Photo)\n    }\n\n    block Lens {\n        operation focus(scene: Scene): Image\n    }\n\n    block ImageProcessor {\n        operation capture(image: Image): Photo\n    }\n\n    block Storage {\n        operation save(photo: Photo)\n    }\n\n    block Controller {\n        operation shoot()\n    }\n\n    // Behavior\n    action CameraShootingProcess {\n        input scene: Scene\n        output photo: Photo\n\n        step focusScene {\n            do lens.focus(scene)\n            output image: Image\n        }\n        step captureImage {\n            do imageProcessor.capture(focusScene.image)\n            output photo: Photo\n        }\n        step displayPhoto {\n            do screen.display(captureImage.photo)\n        }\n    }\n\n    // Satisfy relationships\n    satisfy BasicCameraFunctionality by CameraShootingProcess\n    satisfy SceneInput by CameraShootingProcess.focusScene\n    satisfy FocusingProcess by CameraShootingProcess.focusScene\n    satisfy ImageCapture by CameraShootingProcess.captureImage\n    satisfy PhotoDisplay by CameraShootingProcess.displayPhoto\n    satisfy SeamlessIntegration by CameraShootingProcess\n    satisfy SimpleUserOperation by PhotographAndView\n\n}",
    "package CameraInformationProcessingWorkflow {\n\n    // Define the main system\n    part def CameraSystem {\n        port userInputPort : UserInputPort\n        port viewPort : ViewPort\n        port displayPort : DisplayPort\n\n        part focusUnit : FocusUnit\n        part captureUnit : CaptureUnit\n        part displayUnit : DisplayUnit\n\n        // Workflow behavior\n        behavior def CameraWorkflow {\n            input userSelection : SceneSelection\n            output displayedPicture : Picture\n\n            do {\n                // User selects scene via viewPort\n                userSelection = userInputPort.selectScene()\n                viewPort.displayScene(userSelection)\n\n                // System focuses and obtains image\n                image : Image = focusUnit.focusOn(userSelection)\n\n                // System captures image to generate photograph\n                picture : Picture = captureUnit.capture(image)\n\n                // System displays photograph on displayPort\n                displayUnit.display(picture, displayPort)\n                displayedPicture = picture\n            }\n        }\n    }\n\n    // User Input Port\n    interface def UserInputPort {\n        op selectScene() : SceneSelection\n    }\n\n    // ViewPort for scene selection\n    interface def ViewPort {\n        op displayScene(scene : SceneSelection)\n    }\n\n    // DisplayPort for showing picture\n    interface def DisplayPort {\n        op show(picture : Picture)\n    }\n\n    // Focus Unit\n    part def FocusUnit {\n        op focusOn(scene : SceneSelection) : Image\n    }\n\n    // Capture Unit\n    part def CaptureUnit {\n        op capture(image : Image) : Picture\n    }\n\n    // Display Unit\n    part def DisplayUnit {\n        op display(picture : Picture, port : DisplayPort)\n    }\n\n    // Data types\n    type def SceneSelection\n    type def Image\n    type def Picture\n\n}",
    "package SensorManagementSystem {\n\n    part SensorManager {\n        owns sensors: Sensor[0..*];\n    }\n\n    part Sensor {\n        attribute status: SensorStatus;\n        operation update();\n        operation isReady(): Boolean;\n    }\n\n    enum SensorStatus {\n        values = [Ready, NotReady, Updating, Error];\n    }\n\n    action MonitorAndUpdateSensors {\n        input manager: SensorManager;\n        do {\n            for (sensor in manager.sensors) {\n                if (sensor.isReady()) {\n                    sensor.update();\n                }\n            }\n        }\n    }\n\n    requirement ManageMultipleSensors {\n        text = \"The system shall be capable of managing multiple sensors.\";\n        verify SensorManager.sensors->size() >= 0;\n    }\n\n    requirement MonitorAndUpdateStatus {\n        text = \"The system shall support monitoring and updating the status of sensors.\";\n        verify Sensor.status;\n        verify Sensor.update();\n    }\n\n    requirement AutoUpdateReadySensors {\n        text = \"When any sensor is in a ready state, the system shall automatically perform an update operation on that sensor.\";\n        verify MonitorAndUpdateSensors;\n    }\n\n    requirement TraverseAndMaintainSensors {\n        text = \"The system shall automatically traverse all registered sensors and promptly process and maintain each sensor that meets the ready condition.\";\n        verify MonitorAndUpdateSensors;\n    }\n\n    requirement EnhanceResponsivenessReliability {\n        text = \"The system shall ensure all available sensors are kept up-to-date to enhance responsiveness and reliability.\";\n        deriveFrom = [AutoUpdateReadySensors, TraverseAndMaintainSensors];\n    }\n\n    satisfies SensorManagerSatisfiesRequirements {\n        subject = SensorManager;\n        satisfies = [\n            ManageMultipleSensors,\n            MonitorAndUpdateStatus,\n            AutoUpdateReadySensors,\n            TraverseAndMaintainSensors,\n            EnhanceResponsivenessReliability\n        ];\n    }\n}",
    "package VehicleStateManagement {\n\n    enum VehicleState {\n        off,\n        starting,\n        on\n    }\n\n    signal VehicleStartSignal {}\n    signal VehiclePowerOnSignal {}\n    signal VehicleShutdownSignal {}\n\n    part VehicleStateManager {\n        attribute state: VehicleState = VehicleState::off;\n\n        statemachine VehicleStateMachine {\n            initial state Off {\n                entry / state = VehicleState::off;\n                transition to Starting\n                    when received(VehicleStartSignal);\n                transition to Off\n                    when received(VehicleShutdownSignal);\n            }\n            state Starting {\n                entry / state = VehicleState::starting;\n                transition to On\n                    when received(VehiclePowerOnSignal);\n                transition to Off\n                    when received(VehicleShutdownSignal);\n            }\n            state On {\n                entry / state = VehicleState::on;\n                transition to Off\n                    when received(VehicleShutdownSignal);\n            }\n        }\n    }\n\n    requirement VehicleStateTransition {\n        text \"The system shall manage the vehicle state according to the following logic: \n        - The vehicle is initially in the off state.\n        - Upon receiving a vehicle start signal, the vehicle transitions to the starting state.\n        - Upon receiving a vehicle power-on signal, the vehicle transitions to the on state.\n        - At any time, upon receiving a vehicle shutdown signal, the vehicle transitions to the off state.\n        - The system shall reliably ensure that the vehicle state responds appropriately to the corresponding control signals, and safely and sequentially transitions between each state.\"\n    }\n\n    satisfies VehicleStateManager -> VehicleStateTransition;\n}",
    "package VehicleStatusManagement {\n\n    import sysml::states;\n    import sysml::signals;\n\n    signal VehicleStartSignal;\n    signal VehicleOnSignal;\n    signal VehicleOffSignal;\n\n    stateMachine VehicleOperationalStatus {\n        state off {\n            entry / [initial];\n            transition to starting\n                when VehicleStartSignal;\n        }\n        state starting {\n            transition to on\n                when VehicleOnSignal;\n        }\n        state on {\n            transition to off\n                when VehicleOffSignal;\n        }\n    }\n\n    part VehicleStatusManager {\n        stateMachine usage statusMachine : VehicleOperationalStatus;\n    }\n\n    requirement VehicleStatusManagement_Req {\n        text \"The system manages the operational status of a vehicle, enabling automatic state transitions based on control signals: VehicleStartSignal, VehicleOnSignal, and VehicleOffSignal. The initial state is 'off'.\";\n    }\n}",
    "SysMLv2 {\n\npackage VehiclePowerManagement {\n\n    // States\n    state VehiclePowerState {\n        state Off\n        state StartPhase\n        state PoweredOn\n    }\n\n    // Signals\n    signal VehicleStartCommand\n    signal VehicleStarted\n    signal VehicleShutdownCommand\n\n    // Functional Units\n    part FunctionalUnit\n\n    // System Block\n    block PowerManagementSystem {\n        part functionalUnits: FunctionalUnit[1..*]\n        stateMachine powerState: VehiclePowerState\n    }\n\n    // Self-Diagnosis Behavior\n    behavior SelfDiagnosis {\n        input context: PowerManagementSystem\n        do {\n            // Self-diagnosis logic placeholder\n        }\n    }\n\n    // Safety Operations Behavior\n    behavior SafetyOperations {\n        input context: PowerManagementSystem\n        do {\n            // Safety operations logic placeholder (e.g., parking brake engagement)\n        }\n    }\n\n    // State Machine for Power Management\n    statemachine VehiclePowerState {\n        initial state Off\n\n        state Off {\n            on entry {\n                // Power supply is cut off\n            }\n            transition to StartPhase\n                when VehicleStartCommand\n        }\n\n        state StartPhase {\n            on entry {\n                // Transitioning to powered-on\n            }\n            transition to PoweredOn\n                when VehicleStarted\n        }\n\n        state PoweredOn {\n            on entry {\n                do SelfDiagnosis\n                // Power supplied to functional units\n            }\n            transition to Off\n                when VehicleShutdownCommand\n                do SafetyOperations\n        }\n    }\n\n    // Requirements\n    requirement PowerStateManagement {\n        text \"The system shall manage the vehicle power state, enabling automatic switching between Off, StartPhase, and PoweredOn according to control signals.\"\n    }\n\n    requirement SelfDiagnosisDuringPoweredOn {\n        text \"The system shall perform self-diagnosis operations during the PoweredOn state.\"\n    }\n\n    requirement PowerSupplyToFunctionalUnits {\n        text \"The system shall supply power to all functional units during the PoweredOn state.\"\n    }\n\n    requirement SafetyOnShutdown {\n        text \"The system shall execute safety operations, such as parking brake engagement, when shutting down.\"\n    }\n\n    requirement PowerCutOffOnOffState {\n        text \"The system shall cut off power supply in the Off state.\"\n    }\n\n    // Satisfy relationships\n    satisfy PowerStateManagement by PowerManagementSystem\n    satisfy SelfDiagnosisDuringPoweredOn by SelfDiagnosis\n    satisfy PowerSupplyToFunctionalUnits by PowerManagementSystem.functionalUnits\n    satisfy SafetyOnShutdown by SafetyOperations\n    satisfy PowerCutOffOnOffState by PowerManagementSystem\n\n}\n}",
    "package VehicleControlSystem {\n\n    // Signals\n    signal UserStartSignal {}\n    signal UserShutdownSignal {}\n    signal VehicleStartedSignal {}\n\n    // States\n    state Shutdown {}\n    state Startup {}\n    state Running {}\n\n    // Vehicle Status enumeration\n    enum VehicleStatus {\n        Shutdown,\n        Startup,\n        Running\n    }\n\n    // State Machine for Vehicle Operation\n    statemachine VehicleOperationStateMachine {\n        state ShutdownState : Shutdown {\n            transition to StartupState\n                when UserStartSignal;\n        }\n        state StartupState : Startup {\n            transition to RunningState\n                when VehicleStartedSignal;\n        }\n        state RunningState : Running {\n            transition to ShutdownState\n                when UserShutdownSignal;\n        }\n        initial ShutdownState;\n    }\n\n    // System Block\n    block VehicleControlSystem {\n        attribute status: VehicleStatus = VehicleStatus::Shutdown;\n\n        part operationStateMachine: VehicleOperationStateMachine;\n\n        // Receptions for signals\n        receive UserStartSignal;\n        receive UserShutdownSignal;\n        receive VehicleStartedSignal;\n\n        // Behavior to update status based on state machine\n        behavior UpdateStatus {\n            when operationStateMachine.currentState == ShutdownState {\n                status = VehicleStatus::Shutdown;\n            }\n            when operationStateMachine.currentState == StartupState {\n                status = VehicleStatus::Startup;\n            }\n            when operationStateMachine.currentState == RunningState {\n                status = VehicleStatus::Running;\n            }\n        }\n    }\n}",
    "package VehiclePowerManagement {\n\n    // Enumerated type for vehicle operating states\n    enum VehicleOperatingState {\n        Off,\n        Start,\n        On\n    }\n\n    // Signals issued by the user\n    interface UserControlSignals {\n        signal start_signal;\n        signal on_signal;\n        signal off_signal;\n    }\n\n    // Main system definition\n    part VehiclePowerManagementSystem {\n        attribute currentState: VehicleOperatingState = VehicleOperatingState::Off;\n\n        // Reserve for future health state management\n        part healthStateManager; // Placeholder for future expansion\n\n        // State machine for vehicle operating states\n        statemachine VehicleStateMachine {\n            state Off {\n                entry / currentState = VehicleOperatingState::Off;\n                transition to Start when UserControlSignals::start_signal;\n            }\n            state Start {\n                entry / currentState = VehicleOperatingState::Start;\n                transition to On when UserControlSignals::on_signal;\n            }\n            state On {\n                entry / currentState = VehicleOperatingState::On;\n                transition to Off when UserControlSignals::off_signal;\n            }\n        }\n    }\n\n    // Requirement definitions\n    requirement PowerManagement {\n        text \"The system shall implement power management for vehicles by controlling the vehicle's operating state (Off, Start, On) in response to user control signals.\"\n    }\n\n    requirement AccuratePromptSwitching {\n        text \"The system shall ensure that the vehicle’s operating state can be switched accurately and promptly in accordance with the various control signals issued by the user.\"\n    }\n\n    requirement HealthStateManagementReserve {\n        text \"The system shall reserve functionality for health state management to allow for future expansion of vehicle health monitoring capabilities.\"\n    }\n\n    // Satisfy relationships\n    satisfy PowerManagement by VehiclePowerManagementSystem;\n    satisfy AccuratePromptSwitching by VehiclePowerManagementSystem.VehicleStateMachine;\n    satisfy HealthStateManagementReserve by VehiclePowerManagementSystem.healthStateManager;\n\n}",
    "package VehicleHealthMonitoringSystem {\n\n    enum VehicleHealthStatus {\n        normal\n        degraded\n        maintenance\n    }\n\n    interface VehicleController {\n        operation receiveOverTemperatureWarning()\n        operation updateHealthStatus(status: VehicleHealthStatus)\n    }\n\n    part VehicleHealthMonitor {\n        attribute currentTemperature: Real\n        attribute maxAllowableTemperature: Real\n        attribute healthStatus: VehicleHealthStatus = VehicleHealthStatus::normal\n        attribute maintenanceInterval: Duration\n        attribute nextMaintenanceTime: DateTime\n        attribute maintenanceStartTime: DateTime\n        attribute maintenanceDuration: Duration = 48h\n\n        reference controller: VehicleController\n\n        operation senseTemperature(): Real\n        operation compareTemperature(): Boolean\n        operation sendOverTemperatureWarning()\n        operation switchToDegraded()\n        operation switchToNormal()\n        operation checkMaintenanceDue(currentTime: DateTime): Boolean\n        operation enterMaintenance(currentTime: DateTime)\n        operation completeMaintenance(currentTime: DateTime)\n        operation updateNextMaintenanceTime(currentTime: DateTime)\n        operation checkMaintenanceDuration(currentTime: DateTime)\n    }\n\n    behavior VehicleHealthMonitorBehavior {\n        stateMachine {\n            state Normal {\n                entry / healthStatus = VehicleHealthStatus::normal;\n                transition to Degraded when compareTemperature() == true {\n                    effect {\n                        sendOverTemperatureWarning();\n                        switchToDegraded();\n                        controller.receiveOverTemperatureWarning();\n                        controller.updateHealthStatus(VehicleHealthStatus::degraded);\n                    }\n                }\n                transition to Maintenance when checkMaintenanceDue(now) == true {\n                    effect {\n                        enterMaintenance(now);\n                        controller.updateHealthStatus(VehicleHealthStatus::maintenance);\n                    }\n                }\n            }\n            state Degraded {\n                entry / healthStatus = VehicleHealthStatus::degraded;\n                transition to Normal when compareTemperature() == false {\n                    effect {\n                        switchToNormal();\n                        controller.updateHealthStatus(VehicleHealthStatus::normal);\n                    }\n                }\n                transition to Maintenance when checkMaintenanceDue(now) == true {\n                    effect {\n                        enterMaintenance(now);\n                        controller.updateHealthStatus(VehicleHealthStatus::maintenance);\n                    }\n                }\n            }\n            state Maintenance {\n                entry / healthStatus = VehicleHealthStatus::maintenance;\n                do / checkMaintenanceDuration(now);\n                transition to Normal when (now - maintenanceStartTime) >= maintenanceDuration {\n                    effect {\n                        completeMaintenance(now);\n                        updateNextMaintenanceTime(now);\n                        switchToNormal();\n                        controller.updateHealthStatus(VehicleHealthStatus::normal);\n                    }\n                }\n            }\n        }\n    }\n\n    requirement IntelligentMonitoringAndManagement {\n        text \"The system shall enable intelligent monitoring and management of vehicle health status, including automatic detection of over-temperature and maintenance needs, and automatic status transitions.\"\n    }\n\n    requirement OverTemperatureDetection {\n        text \"The system shall sense the current vehicle temperature and compare it with the preset maximum allowable temperature. If the temperature exceeds the maximum, the system shall send an over-temperature warning and switch to degraded mode. When temperature returns to safe range, status shall revert to normal.\"\n    }\n\n    requirement PeriodicMaintenance {\n        text \"The system shall enter maintenance status at scheduled intervals, update the next maintenance cycle after completion, and return to normal status after 48 hours in maintenance.\"\n    }\n\n    satisfies VehicleHealthMonitor -> IntelligentMonitoringAndManagement\n    satisfies VehicleHealthMonitor -> OverTemperatureDetection\n    satisfies VehicleHealthMonitor -> PeriodicMaintenance\n\n    VehicleHealthMonitor realizes VehicleHealthMonitorBehavior\n\n}",
    "package ServerSystem {\n\n    import sysml::standard;\n\n    part server : Server;\n\n    block Server {\n        part localClock : Clock;\n        port requestPort : RequestPort;\n        stateMachine behavior : ServerBehavior;\n    }\n\n    block Clock {\n        attribute currentTime : standard::Time;\n        operation getTime() : standard::Time;\n    }\n\n    interface RequestPort {\n        in event start();\n        in event request();\n    }\n\n    stateMachine ServerBehavior {\n        state off {\n            entry / doOffEntry();\n            transition to waiting\n                when requestPort.start()\n                effect / doStartTransition();\n        }\n        state waiting {\n            entry / doWaitingEntry();\n            transition to response\n                when requestPort.request()\n                effect / doRequestTransition();\n        }\n        state response {\n            entry / doResponseEntry();\n            do / wait(5 min);\n            transition to waiting\n                after 5 min\n                effect / doResponseTimeout();\n        }\n        transition from off to off\n            when localClock.getTime().matches(\"11:59:00\")\n            effect / doDailyOff();\n        transition from waiting to off\n            when localClock.getTime().matches(\"11:59:00\")\n            effect / doDailyOff();\n        transition from response to off\n            when localClock.getTime().matches(\"11:59:00\")\n            effect / doDailyOff();\n        initial off;\n    }\n\n    behavior doOffEntry() {\n        // Implementation for entering off state\n    }\n    behavior doStartTransition() {\n        // Implementation for start command\n    }\n    behavior doWaitingEntry() {\n        // Implementation for entering waiting state\n    }\n    behavior doRequestTransition() {\n        // Implementation for request command\n    }\n    behavior doResponseEntry() {\n        // Implementation for entering response state\n    }\n    behavior doResponseTimeout() {\n        // Implementation for response timeout\n    }\n    behavior doDailyOff() {\n        // Implementation for daily off transition\n    }\n}",
    "package VehicleStartStopSystem {\n\n    // Signals\n    signal StartSignal;\n    signal StopSignal;\n    signal PowerOnSignal;\n    signal BrakePedalDepressed;\n    signal StartSignalToController;\n    signal SelfCheckComplete;\n    signal ParkingBrakeApplied;\n\n    // States\n    state OffState;\n    state StartProcess;\n    state OperatingState;\n\n    // System Definition\n    part VehicleStartStopController {\n        // State Machine\n        statemachine StartStopProcess {\n            initial state OffState {\n                transition on StartSignal to StartProcess;\n            }\n            state StartProcess {\n                entry [\n                    // Wait for brake pedal to be depressed\n                    wait BrakePedalDepressed;\n                    // Respond to power-on signal\n                    on PowerOnSignal {\n                        // Send start signal to controller\n                        send StartSignalToController;\n                        transition to OperatingState;\n                    }\n                ]\n            }\n            state OperatingState {\n                entry [\n                    // Perform self-check\n                    send SelfCheckComplete;\n                    // Continuously supply power\n                    // (modeled as ongoing activity)\n                ]\n                do [\n                    // Supply power to vehicle\n                ]\n                transition on StopSignal to OffState {\n                    effect [\n                        // Apply parking brake upon leaving operating state\n                        send ParkingBrakeApplied;\n                    ]\n                }\n            }\n        }\n    }\n\n    // Requirements\n    requirement SafetyRequirement {\n        text \"The system shall ensure safety and reliability of the vehicle’s start-stop process.\"\n    }\n    requirement ControllerCoordination {\n        text \"The system shall coordinate control with the controller during the start process.\"\n    }\n    requirement ParkingSafety {\n        text \"Upon leaving the operating state, the parking brake shall be automatically applied.\"\n    }\n\n    // Satisfy relationships\n    satisfy VehicleStartStopController -> SafetyRequirement;\n    satisfy VehicleStartStopController -> ControllerCoordination;\n    satisfy VehicleStartStopController -> ParkingSafety;\n\n}",
    "package VehicleStartStopSystem {\n\n    // Block Definitions\n    block VehicleStartStopController {\n        input signal vehicleStartSignal\n        input signal vehicleOnSignal\n        input signal brakePedalDepressed\n        input signal shutdownSignal\n        output signal startControlSignal\n        output signal powerSupply\n        output signal applyParkingBrake\n        output signal vehicleState\n        output signal selfCheckStatus\n    }\n\n    block VehicleController {\n        input signal startControlSignal\n        output signal vehicleState\n    }\n\n    // State Machine for Start-Stop and Status Management\n    statemachine VehicleStartStopStateMachine {\n        state Off {\n            entry / vehicleState = \"Off\";\n            transition to Starting\n                when vehicleStartSignal.received\n                effect / ;\n        }\n        state Starting {\n            entry / vehicleState = \"Starting\";\n            transition to Started\n                when brakePedalDepressed.received and vehicleOnSignal.received\n                effect / startControlSignal.send();\n        }\n        state Started {\n            entry / {\n                vehicleState = \"Started\";\n                selfCheckStatus = \"Running\";\n                powerSupply.send();\n            }\n            do / powerSupply.send();\n            transition to ShuttingDown\n                when shutdownSignal.received\n                effect / ;\n        }\n        state ShuttingDown {\n            entry / {\n                applyParkingBrake.send();\n            }\n            transition to Off\n                when applyParkingBrake.sent\n                effect / vehicleState = \"Off\";\n        }\n    }\n\n    // Requirements\n    requirement AutomatedStartStopControl {\n        text \"The system shall enable automated control of vehicle start-up, operation, and shutdown.\"\n    }\n\n    requirement StartCondition {\n        text \"The system shall only allow vehicle start when the brake pedal is depressed and a vehicle-on signal is received.\"\n    }\n\n    requirement SelfCheckAndPowerSupply {\n        text \"While in the started state, the system shall perform a self-check and continuously supply power to the vehicle.\"\n    }\n\n    requirement SafeShutdown {\n        text \"The system shall ensure the parking brake is applied before shutdown to ensure safety.\"\n    }\n\n    requirement StateManagement {\n        text \"The system shall manage vehicle states: Off, Starting, Started, and ShuttingDown.\"\n    }\n\n    // Satisfy relationships\n    satisfy AutomatedStartStopControl by VehicleStartStopController\n    satisfy StartCondition by VehicleStartStopStateMachine.Starting\n    satisfy SelfCheckAndPowerSupply by VehicleStartStopStateMachine.Started\n    satisfy SafeShutdown by VehicleStartStopStateMachine.ShuttingDown\n    satisfy StateManagement by VehicleStartStopStateMachine\n\n    // Usage\n    part vehicleStartStopController : VehicleStartStopController\n    part vehicleController : VehicleController\n\n    // Connections\n    connector vehicleStartStopController.startControlSignal -> vehicleController.startControlSignal\n    connector vehicleStartStopController.vehicleState -> vehicleController.vehicleState\n\n}",
    "package CruiseControlSystem {\n\n    part Driver {\n        port setSpeedCommandOut: out SetSpeedCommand;\n    }\n\n    part CruiseController {\n        port setSpeedCommandIn: in SetSpeedCommand;\n        port vehicleSpeedIn: in VehicleSpeed;\n        port fuelControlCommandOut: out FuelControlCommand;\n    }\n\n    part Speedometer {\n        port vehicleSpeedOut: out VehicleSpeed;\n        port vehicleIn: in Vehicle;\n    }\n\n    part Engine {\n        port fuelControlCommandIn: in FuelControlCommand;\n        port engineOutputOut: out EngineOutput;\n    }\n\n    part Vehicle {\n        port engineInputIn: in EngineOutput;\n        port vehicleSpeedOut: out VehicleSpeed;\n    }\n\n    interface SetSpeedCommand {\n        attribute desiredSpeed: Real;\n    }\n\n    interface VehicleSpeed {\n        attribute speed: Real;\n    }\n\n    interface FuelControlCommand {\n        attribute fuelRate: Real;\n    }\n\n    interface EngineOutput {\n        attribute torque: Real;\n    }\n\n    connection DriverToCruiseController {\n        end driverPort: Driver.setSpeedCommandOut;\n        end controllerPort: CruiseController.setSpeedCommandIn;\n    }\n\n    connection SpeedometerToCruiseController {\n        end speedometerPort: Speedometer.vehicleSpeedOut;\n        end controllerPort: CruiseController.vehicleSpeedIn;\n    }\n\n    connection CruiseControllerToEngine {\n        end controllerPort: CruiseController.fuelControlCommandOut;\n        end enginePort: Engine.fuelControlCommandIn;\n    }\n\n    connection EngineToVehicle {\n        end enginePort: Engine.engineOutputOut;\n        end vehiclePort: Vehicle.engineInputIn;\n    }\n\n    connection VehicleToSpeedometer {\n        end vehiclePort: Vehicle.vehicleSpeedOut;\n        end speedometerPort: Speedometer.vehicleIn;\n    }\n\n    connection VehicleToSpeedometerSpeed {\n        end vehiclePort: Vehicle.vehicleSpeedOut;\n        end speedometerPort: Speedometer.vehicleSpeedOut;\n    }\n\n    behavior CruiseControlFunction {\n        input setSpeed: SetSpeedCommand;\n        input actualSpeed: VehicleSpeed;\n        output fuelCommand: FuelControlCommand;\n\n        constraint \"Maintain set speed\" {\n            // Pseudocode for control logic\n            // fuelCommand.fuelRate = controlLaw(setSpeed.desiredSpeed, actualSpeed.speed)\n        }\n    }\n\n    part CruiseControlSystem {\n        part driver: Driver;\n        part cruiseController: CruiseController;\n        part speedometer: Speedometer;\n        part engine: Engine;\n        part vehicle: Vehicle;\n\n        connect driver.setSpeedCommandOut to cruiseController.setSpeedCommandIn;\n        connect speedometer.vehicleSpeedOut to cruiseController.vehicleSpeedIn;\n        connect cruiseController.fuelControlCommandOut to engine.fuelControlCommandIn;\n        connect engine.engineOutputOut to vehicle.engineInputIn;\n        connect vehicle.vehicleSpeedOut to speedometer.vehicleIn;\n    }\n}",
    "package CruiseControlSystem {\n\n    part Vehicle {\n        part speedometer: Speedometer;\n        part engineSystem: EngineSystem;\n        part cruiseController: CruiseController;\n        part driver: Driver;\n    }\n\n    part Driver {\n        operation sendSetSpeed(setSpeed: Real);\n    }\n\n    part Speedometer {\n        attribute vehicleSpeed: Real;\n        operation getVehicleSpeed(): Real;\n    }\n\n    part EngineSystem {\n        operation receiveThrottleCommand(throttleCommand: Real);\n    }\n\n    part CruiseController {\n        attribute setSpeed: Real;\n        attribute actualSpeed: Real;\n        attribute throttleCommand: Real;\n\n        operation receiveSetSpeed(setSpeed: Real);\n        operation acquireVehicleSpeed(): Real;\n        operation generateThrottleCommand();\n        operation sendThrottleCommand(throttleCommand: Real);\n    }\n\n    requirement CruiseControlFunction {\n        text \"The system shall implement cruise control by allowing the driver to set a speed, acquiring real-time vehicle speed, generating throttle commands based on speed difference, and sending commands to the engine system for automatic speed control.\"\n    }\n\n    constraint SpeedControlLogic {\n        parameter setSpeed: Real;\n        parameter actualSpeed: Real;\n        parameter throttleCommand: Real;\n        expression \"throttleCommand = k * (setSpeed - actualSpeed)\";\n        comment \"k is a control gain parameter.\"\n    }\n\n    usecase SetCruiseSpeed {\n        actor driver: Driver;\n        subject cruiseController: CruiseController;\n        step \"Driver sends set speed command to cruise controller.\";\n        step \"Cruise controller receives set speed.\";\n    }\n\n    usecase AutomaticSpeedControl {\n        actor cruiseController: CruiseController;\n        subject speedometer: Speedometer, engineSystem: EngineSystem;\n        step \"Cruise controller acquires real-time vehicle speed from speedometer.\";\n        step \"Cruise controller calculates throttle command based on speed difference.\";\n        step \"Cruise controller sends throttle command to engine system.\";\n        step \"Engine system adjusts vehicle power output.\";\n    }\n\n    scenario CruiseControlOperation {\n        part driver: Driver;\n        part cruiseController: CruiseController;\n        part speedometer: Speedometer;\n        part engineSystem: EngineSystem;\n\n        action driver.sendSetSpeed(setSpeed);\n        action cruiseController.receiveSetSpeed(setSpeed);\n        action cruiseController.acquireVehicleSpeed();\n        action cruiseController.generateThrottleCommand();\n        action cruiseController.sendThrottleCommand(throttleCommand);\n        action engineSystem.receiveThrottleCommand(throttleCommand);\n    }\n}",
    "package CruiseControlSystem {\n\n    // Actors\n    actor Driver\n    actor Speedometer\n    actor Engine\n\n    // System Definition\n    system CruiseControlSystem {\n        part driver: Driver\n        part cruiseController: CruiseController\n        part speedometer: Speedometer\n        part engine: Engine\n\n        // Connections\n        connector driverToController {\n            end driver\n            end cruiseController\n        }\n        connector controllerToSpeedometer {\n            end cruiseController\n            end speedometer\n        }\n        connector controllerToEngine {\n            end cruiseController\n            end engine\n        }\n    }\n\n    // Cruise Controller Definition\n    block CruiseController {\n        // Ports\n        in port setSpeedCmd: SetSpeedCommand\n        in port currentSpeed: VehicleSpeed\n        out port throttleCmd: ThrottleCommand\n\n        // Operations\n        operation compareSpeeds(setSpeed: Real, actualSpeed: Real): Real\n        operation generateThrottleCmd(speedError: Real): ThrottleCommand\n    }\n\n    // Interfaces\n    interface SetSpeedCommand {\n        attribute setSpeed: Real\n    }\n\n    interface VehicleSpeed {\n        attribute speed: Real\n    }\n\n    interface ThrottleCommand {\n        attribute throttleValue: Real\n    }\n\n    // Behavior\n    behavior CruiseControlBehavior for CruiseController {\n        state Idle\n        state Active\n\n        transition Idle -> Active when setSpeedCmd received\n        transition Active -> Idle when setSpeedCmd cancelled\n\n        do in Active {\n            let setSpeed = setSpeedCmd.setSpeed;\n            let actualSpeed = currentSpeed.speed;\n            let speedError = compareSpeeds(setSpeed, actualSpeed);\n            let throttle = generateThrottleCmd(speedError);\n            throttleCmd.throttleValue = throttle.throttleValue;\n        }\n    }\n\n    // Requirements\n    requirement CruiseControlFunction {\n        text \"The system shall allow the driver to set a target speed via the in-vehicle control interface.\"\n    }\n    requirement SpeedComparison {\n        text \"The cruise controller shall compare the set speed with the current vehicle speed provided by the speedometer.\"\n    }\n    requirement ThrottleControl {\n        text \"The cruise controller shall generate a throttle control command to the engine to maintain or reach the set speed.\"\n    }\n    requirement AutomaticSpeedMaintenance {\n        text \"After the driver sets the target speed, the vehicle shall automatically maintain that speed without continuous accelerator pedal operation.\"\n    }\n\n    // Traceability\n    satisfy CruiseControlFunction by CruiseController\n    satisfy SpeedComparison by CruiseController\n    satisfy ThrottleControl by CruiseController\n    satisfy AutomaticSpeedMaintenance by CruiseController\n\n}",
    "package AutomotiveCruiseControl {\n\n    // Actors\n    actor Driver\n\n    // Blocks\n    block Vehicle {\n        part cruiseController: CruiseController\n        part engine: Engine\n        part speedometer: Speedometer\n    }\n\n    block CruiseController {\n        port speedSetRequestIn: SpeedSetRequestIn\n        port speedFeedbackIn: SpeedFeedbackIn\n        port throttleControlOut: ThrottleControlOut\n    }\n\n    block Engine {\n        port throttleControlIn: ThrottleControlIn\n    }\n\n    block Speedometer {\n        port speedFeedbackOut: SpeedFeedbackOut\n    }\n\n    // Interfaces\n    interface SpeedSetRequestIn {\n        in property desiredSpeed: Real\n    }\n\n    interface SpeedFeedbackIn {\n        in property currentSpeed: Real\n    }\n\n    interface SpeedFeedbackOut {\n        out property currentSpeed: Real\n    }\n\n    interface ThrottleControlOut {\n        out property throttleCommand: Real\n    }\n\n    interface ThrottleControlIn {\n        in property throttleCommand: Real\n    }\n\n    // Requirements\n    requirement CruiseControlFunctionality {\n        text \"The system shall enable the driver to set a desired cruising speed and automatically maintain the vehicle at that speed by adjusting the engine throttle based on real-time speed feedback.\"\n    }\n\n    requirement SpeedSettingRequest {\n        text \"The system shall collect and transmit the driver’s speed setting request promptly to the cruise controller.\"\n    }\n\n    requirement RealTimeSpeedFeedback {\n        text \"The system shall provide real-time vehicle speed feedback from the speedometer to the cruise controller.\"\n    }\n\n    requirement ThrottleAdjustment {\n        text \"The cruise controller shall calculate and send throttle control instructions to the engine to maintain the set cruising speed.\"\n    }\n\n    requirement ConvenienceAndComfort {\n        text \"The system shall ensure convenience and comfort for the driver during cruise control operation.\"\n    }\n\n    requirement AccuracyAndSmoothness {\n        text \"The system shall enable the vehicle to cruise at the preset speed with accuracy and smoothness.\"\n    }\n\n    // Use Cases\n    usecase SetCruisingSpeed {\n        actor: Driver\n        description: \"Driver sets the desired cruising speed.\"\n    }\n\n    usecase MaintainCruisingSpeed {\n        actor: CruiseController\n        description: \"Cruise controller maintains the vehicle at the set speed by adjusting throttle.\"\n    }\n\n    // Relationships\n    satisfy CruiseControlFunctionality by CruiseController\n    satisfy SpeedSettingRequest by CruiseController\n    satisfy RealTimeSpeedFeedback by Speedometer\n    satisfy ThrottleAdjustment by CruiseController\n    satisfy ConvenienceAndComfort by Vehicle\n    satisfy AccuracyAndSmoothness by CruiseController\n\n    // Connections\n    connector driverToCruiseController {\n        end driver: Driver\n        end controller: CruiseController.speedSetRequestIn\n    }\n\n    connector speedometerToCruiseController {\n        end speedometer: Speedometer.speedFeedbackOut\n        end controller: CruiseController.speedFeedbackIn\n    }\n\n    connector cruiseControllerToEngine {\n        end controller: CruiseController.throttleControlOut\n        end engine: Engine.throttleControlIn\n    }\n\n}",
    "package CruiseControlSystem {\n\n    part Driver {\n        port setSpeedCommand: out SetSpeed;\n    }\n\n    part CruiseControlInterface {\n        port setSpeedIn: in SetSpeed;\n        port setSpeedOut: out SetSpeed;\n    }\n\n    part SpeedSensor {\n        port actualSpeedOut: out ActualSpeed;\n    }\n\n    part CruiseController {\n        port setSpeedIn: in SetSpeed;\n        port actualSpeedIn: in ActualSpeed;\n        port fuelControlOut: out FuelControlCommand;\n    }\n\n    part Engine {\n        port fuelControlIn: in FuelControlCommand;\n    }\n\n    // Data Types\n    type SetSpeed {\n        attribute value: Real;\n        attribute unit: String;\n    }\n\n    type ActualSpeed {\n        attribute value: Real;\n        attribute unit: String;\n    }\n\n    type FuelControlCommand {\n        attribute value: Real;\n        attribute unit: String;\n    }\n\n    // System Structure\n    part CruiseControlSystem {\n        part driver: Driver;\n        part interface: CruiseControlInterface;\n        part speedSensor: SpeedSensor;\n        part controller: CruiseController;\n        part engine: Engine;\n\n        connector driverToInterface: driver.setSpeedCommand -> interface.setSpeedIn;\n        connector interfaceToController: interface.setSpeedOut -> controller.setSpeedIn;\n        connector speedSensorToController: speedSensor.actualSpeedOut -> controller.actualSpeedIn;\n        connector controllerToEngine: controller.fuelControlOut -> engine.fuelControlIn;\n    }\n\n    // Requirements\n    requirement SetTargetSpeed {\n        text \"The system shall enable the driver to set a target speed through the cruise control interface.\";\n    }\n\n    requirement DetectActualSpeed {\n        text \"The system shall detect the current vehicle speed using a speed sensor.\";\n    }\n\n    requirement MaintainTargetSpeed {\n        text \"The system shall automatically adjust engine output to maintain the vehicle speed at the set target speed.\";\n    }\n\n    requirement FeedbackControl {\n        text \"The cruise controller shall compare the set speed and actual speed and generate engine fuel control commands accordingly.\";\n    }\n\n    requirement DataPortCommunication {\n        text \"All components shall exchange set speed, speed sensing, and fuel control information via data ports efficiently and accurately.\";\n    }\n\n    // Satisfy relationships\n    satisfy SetTargetSpeed by CruiseControlInterface;\n    satisfy DetectActualSpeed by SpeedSensor;\n    satisfy MaintainTargetSpeed by CruiseController;\n    satisfy FeedbackControl by CruiseController;\n    satisfy DataPortCommunication by CruiseControlSystem;\n}",
    "package CruiseControlSystem {\n\n    // Interfaces\n    interface MessageInterface {\n        inout message: Message;\n    }\n\n    interface SpeedInterface {\n        out speed: Real;\n    }\n\n    interface FuelControlCommandInterface {\n        out fuelControlCommand: FuelControlCommand;\n    }\n\n    // Data Types\n    type Message {\n        attribute content: String;\n    }\n\n    type SetSpeedCommand specializes Message {\n        attribute setSpeed: Real;\n    }\n\n    type FuelControlCommand specializes Message {\n        attribute fuelAdjustment: Real;\n    }\n\n    // Blocks\n    block Driver {\n        port setSpeedOut: MessageInterface;\n    }\n\n    block SpeedSensor {\n        port speedOut: SpeedInterface;\n    }\n\n    block CruiseController {\n        port setSpeedIn: MessageInterface;\n        port speedIn: SpeedInterface;\n        port fuelControlCommandOut: FuelControlCommandInterface;\n\n        attribute setSpeed: Real;\n        attribute actualSpeed: Real;\n        attribute fuelAdjustment: Real;\n\n        operation processSetSpeed(cmd: SetSpeedCommand);\n        operation readSpeed(speed: Real);\n        operation calculateFuelAdjustment();\n        operation generateFuelControlCommand(): FuelControlCommand;\n    }\n\n    block EngineController {\n        port fuelControlCommandIn: FuelControlCommandInterface;\n        port fuelControlCommandOut: FuelControlCommandInterface;\n\n        operation processFuelControlCommand(cmd: FuelControlCommand): FuelControlCommand;\n    }\n\n    block Engine {\n        port fuelControlCommandIn: FuelControlCommandInterface;\n\n        operation adjustFuelFlow(cmd: FuelControlCommand);\n    }\n\n    // System Context\n    block CruiseControlSystem {\n        part driver: Driver;\n        part speedSensor: SpeedSensor;\n        part cruiseController: CruiseController;\n        part engineController: EngineController;\n        part engine: Engine;\n\n        connector driverToCruiseController: MessageInterface between driver.setSpeedOut and cruiseController.setSpeedIn;\n        connector speedSensorToCruiseController: SpeedInterface between speedSensor.speedOut and cruiseController.speedIn;\n        connector cruiseControllerToEngineController: FuelControlCommandInterface between cruiseController.fuelControlCommandOut and engineController.fuelControlCommandIn;\n        connector engineControllerToEngine: FuelControlCommandInterface between engineController.fuelControlCommandOut and engine.fuelControlCommandIn;\n    }\n\n    // Requirements\n    requirement CruiseControlMessageInteraction {\n        text \"The system shall provide a message interaction mechanism for vehicles equipped with cruise control functionality. Drivers can send set speed commands, which are processed by the cruise controller. The cruise controller reads real-time speed from the speed sensor, calculates the difference, and generates a fuel control command. The fuel control command is processed by the engine controller and forwarded to the engine to control fuel flow and stabilize speed. All components communicate via standardized message interfaces to ensure reliable, efficient, and safe operation.\"\n    }\n}",
    "package VehicleLifecycleManagement {\n\n    part VehicleLifecycleSystem {\n        part vehicles: Vehicle[0..*];\n        part owners: Owner[0..*];\n        part drivers: Driver[0..*];\n    }\n\n    part Vehicle {\n        attribute vin: String;\n        attribute model: String;\n        attribute assemblyDate: DateTime;\n        part delivery: Delivery;\n        part ownerships: Ownership[1..*];\n        part scrapping: Scrapping[0..1];\n    }\n\n    part Delivery {\n        attribute deliveryDate: DateTime;\n        reference deliveredTo: Owner;\n    }\n\n    part Ownership {\n        attribute ownershipStart: DateTime;\n        attribute ownershipEnd: DateTime[0..1];\n        reference owner: Owner;\n        part drivingRecords: DrivingRecord[0..*];\n    }\n\n    part Owner {\n        attribute ownerId: String;\n        attribute name: String;\n        attribute contactInfo: String;\n    }\n\n    part Driver {\n        attribute driverId: String;\n        attribute name: String;\n        attribute licenseNumber: String;\n    }\n\n    part DrivingRecord {\n        attribute driveDateTime: DateTime;\n        reference driver: Driver;\n        attribute purpose: String;\n        attribute mileage: Real;\n    }\n\n    part Scrapping {\n        attribute scrappingDate: DateTime;\n        attribute reason: String;\n        attribute deregistrationNumber: String;\n    }\n\n    requirement ManageAndTrackLifecycle {\n        text \"The system shall manage and track the entire lifecycle of a vehicle, including assembly, delivery, ownership changes, driving operations, and scrapping, ensuring accurate recording, inquiry, and traceability of all relevant data.\"\n    }\n\n    requirement RecordDeliveryDate {\n        text \"The system shall record the specific delivery date at the time of delivery for each vehicle.\"\n    }\n\n    requirement RecordOwnershipChange {\n        text \"The system shall record each ownership change, including unique owner information, and ensure traceability to each stage.\"\n    }\n\n    requirement TrackDrivers {\n        text \"The system shall track and record different drivers during each ownership period, specifying the actual driver for each driving operation.\"\n    }\n\n    requirement RecordScrapping {\n        text \"The system shall record scrapping or de-registration information when the vehicle reaches the end-of-use stage.\"\n    }\n\n    requirement SupportInquiryAndTraceability {\n        text \"The system shall support inquiry and traceability of all lifecycle-related information.\"\n    }\n\n    satisfies VehicleLifecycleSystem -> ManageAndTrackLifecycle;\n    satisfies Delivery -> RecordDeliveryDate;\n    satisfies Ownership -> RecordOwnershipChange;\n    satisfies DrivingRecord -> TrackDrivers;\n    satisfies Scrapping -> RecordScrapping;\n    satisfies VehicleLifecycleSystem -> SupportInquiryAndTraceability;\n\n}",
    "package VehicleModel {\n\n    // Basic types\n    type Mass = Real;\n    type GearSetting = enumeration { PARK, REVERSE, NEUTRAL, DRIVE, LOW };\n    type PedalPosition = Real; // 0.0 (not pressed) to 1.0 (fully pressed)\n\n    // Operational Status\n    structure OperationalStatus {\n        attribute gear: GearSetting;\n        attribute acceleratorPedal: PedalPosition;\n    }\n\n    // Engine definition\n    part Engine {}\n\n    // Wheel definition\n    part Wheel {\n        attribute position: String; // e.g., \"left front\", \"right front\"\n    }\n\n    // Driver as external reference\n    external part Driver {}\n\n    // Vehicle definition\n    part Vehicle {\n        attribute mass: Mass;\n        attribute status: OperationalStatus;\n\n        part engine: Engine;\n        part wheels: Wheel[2..*]; // At least two wheels\n        reference driver: Driver;\n    }\n\n    // Vehicle instance with specific wheels and time snapshots\n    instance vehicle_1: Vehicle {\n        mass = 1500.0;\n        status = OperationalStatus {\n            gear = DRIVE;\n            acceleratorPedal = 0.3;\n        };\n        engine = Engine {};\n        wheels = {\n            leftFront: Wheel {\n                position = \"left front\";\n            },\n            rightFront: Wheel {\n                position = \"right front\";\n            }\n        };\n        driver = external Driver {};\n    }\n\n    // Time snapshots for wheels\n    snapshot vehicle_1_leftFront_t0: vehicle_1.wheels.leftFront {\n        // Example: status at time t0\n        // Add attributes as needed for tracking\n    }\n\n    snapshot vehicle_1_leftFront_t1: vehicle_1.wheels.leftFront {\n        // Example: status at time t1\n        // Add attributes as needed for tracking\n    }\n\n    snapshot vehicle_1_rightFront_t0: vehicle_1.wheels.rightFront {\n        // Example: status at time t0\n        // Add attributes as needed for tracking\n    }\n\n    snapshot vehicle_1_rightFront_t1: vehicle_1.wheels.rightFront {\n        // Example: status at time t1\n        // Add attributes as needed for tracking\n    }\n}",
    "package VehicleSystem {\n\n    // ==== Types ====\n    type Mass : Real;\n    type Gear : Integer;\n    type AcceleratorPosition : Real;\n\n    // ==== States ====\n    structure VehicleState {\n        attribute gear: Gear;\n        attribute acceleratorPosition: AcceleratorPosition;\n    }\n\n    // ==== Components ====\n    part Engine {}\n    part Driver {}\n\n    structure Vehicle {\n        attribute mass: Mass;\n        attribute state: VehicleState;\n        part engine: Engine;\n        part driver: Driver;\n    }\n\n    // ==== Composite System ====\n    structure CompositeSystem {\n        part vehicles: Vehicle[*];\n    }\n\n    // ==== Vehicle Instance with State Evolution ====\n    instance Vehicle_1: Vehicle {\n        // Initial state at t0\n        at t0 {\n            mass = 2000.0;\n            state.gear = 0;\n            state.acceleratorPosition = 0.0;\n        }\n        // Next state at t1\n        at t1 {\n            mass = 1500.0;\n            state.gear = 2;\n            state.acceleratorPosition = 0.5;\n        }\n    }\n\n    // ==== System Instance ====\n    instance MyCompositeSystem: CompositeSystem {\n        vehicles = [Vehicle_1];\n    }\n}",
    "package VehicleSystem {\n\n    // Define enumeration for GearPosition\n    enum GearPosition {\n        neutral,\n        first,\n        second,\n        third,\n        fourth,\n        fifth,\n        reverse\n    }\n\n    // Define Driver\n    part definition Driver {\n        attribute name: String;\n    }\n\n    // Define Engine\n    part definition Engine {\n        // Engine properties can be added here\n    }\n\n    // Define Vehicle\n    part definition Vehicle {\n        attribute mass: Real;\n        attribute gear: GearPosition;\n        attribute throttlePedalPosition: Real; // 0.0 to 1.0\n        part engine: Engine;\n        part driver: Driver;\n    }\n\n    // Define VehicleState for time slices\n    part definition VehicleState {\n        attribute mass: Real;\n        attribute gear: GearPosition;\n        attribute throttlePedalPosition: Real;\n        part driver: Driver;\n    }\n\n    // Define the System\n    part definition VehicleSystem {\n        part vehicle: Vehicle;\n        part alice: Driver;\n        part bob: Driver;\n    }\n\n    // Instantiate the system\n    part vehicleSystem: VehicleSystem {\n        alice: Driver {\n            name = \"Alice\";\n        }\n        bob: Driver {\n            name = \"Bob\";\n        }\n        vehicle: Vehicle {\n            mass = 2000.0;\n            gear = GearPosition::neutral;\n            throttlePedalPosition = 0.0;\n            engine: Engine { }\n            driver = alice;\n        }\n    }\n\n    // Define time slices as snapshots of vehicle state\n    instance vehicleState_t0: VehicleState {\n        mass = 2000.0;\n        gear = GearPosition::neutral;\n        throttlePedalPosition = 0.0;\n        driver = vehicleSystem.alice;\n    }\n\n    instance vehicleState_t1: VehicleState {\n        mass = 1500.0;\n        gear = GearPosition::second;\n        throttlePedalPosition = 0.5;\n        driver = vehicleSystem.bob;\n    }\n}",
    "package VehicleMassAggregation {\n\n    import ScalarValues::*;\n\n    // Abstract definition for any object with mass\n    abstract part MassObject {\n        attribute id: String;\n        attribute name: String;\n        attribute mass: Mass; // mass of this object only\n\n        // Aggregated mass: this + all subcomponents\n        def totalMass(): Mass {\n            return mass + subcomponents->sum(c | c.totalMass());\n        }\n\n        part subcomponents: MassObject[0..*];\n    }\n\n    // Concrete component (leaf node)\n    part Component extends MassObject {\n        // No additional subcomponents\n        redefine subcomponents: MassObject[0];\n    }\n\n    // Composite object (can have subcomponents)\n    part CompositeComponent extends MassObject {\n        // subcomponents as defined in MassObject\n    }\n\n    // Core vehicle components\n    part Engine extends Component {\n        // Additional engine-specific attributes can be added here\n    }\n\n    part Transmission extends Component {\n        // Additional transmission-specific attributes can be added here\n    }\n\n    // The complete vehicle\n    part Vehicle extends CompositeComponent {\n        // Explicitly define core components\n        part engine: Engine;\n        part transmission: Transmission;\n        // Other components can be added as subcomponents\n    }\n\n    // Example instance (usage)\n    instance myVehicle: Vehicle {\n        id = \"V001\";\n        name = \"Sedan\";\n        mass = 1200 kg; // mass of vehicle body (excluding subcomponents)\n        engine = {\n            id = \"E001\";\n            name = \"V6 Engine\";\n            mass = 180 kg;\n        };\n        transmission = {\n            id = \"T001\";\n            name = \"Automatic Transmission\";\n            mass = 90 kg;\n        };\n        subcomponents = [\n            {\n                id = \"C001\";\n                name = \"Wheel Set\";\n                mass = 40 kg;\n            },\n            {\n                id = \"C002\";\n                name = \"Battery\";\n                mass = 20 kg;\n            }\n        ];\n    }\n}",
    "package VehicleMassManagement {\n\n    import sysml::blocks;\n    import sysml::constraints;\n    import sysml::expressions;\n    import sysml::values;\n\n    // Value Types\n    value type Mass {\n        unit: kilogram;\n        quantity kind: mass;\n    }\n\n    value type SerialNumber {\n        base: String;\n    }\n\n    value type VIN {\n        base: String;\n    }\n\n    // Component Block\n    block VehicleComponent {\n        attribute serialNumber: SerialNumber;\n        attribute mass: Mass;\n        part subcomponents: VehicleComponent[0..*];\n        \n        // Recursive total mass calculation with optional mass threshold\n        operation totalMass(threshold: Mass = 0 kg): Mass {\n            result: Mass;\n            body: result = \n                if mass >= threshold then\n                    mass + sum(subcomponents->select(c | c.mass >= threshold).totalMass(threshold))\n                else\n                    sum(subcomponents->select(c | c.mass >= threshold).totalMass(threshold));\n        }\n    }\n\n    // Engine Block\n    block Engine extends VehicleComponent {\n        // Additional engine-specific attributes can be added here\n    }\n\n    // Transmission Block\n    block Transmission extends VehicleComponent {\n        // Additional transmission-specific attributes can be added here\n    }\n\n    // Vehicle Block\n    block Vehicle {\n        attribute vin: VIN;\n        attribute mass: Mass;\n        part engine: Engine;\n        part transmission: Transmission;\n        part components: VehicleComponent[0..*];\n\n        // Total vehicle mass = own mass + engine + transmission + all other components\n        operation totalMass(threshold: Mass = 0 kg): Mass {\n            result: Mass;\n            body: result = \n                (if mass >= threshold then mass else 0 kg) +\n                (if engine.mass >= threshold then engine.totalMass(threshold) else 0 kg) +\n                (if transmission.mass >= threshold then transmission.totalMass(threshold) else 0 kg) +\n                sum(components->select(c | c.mass >= threshold).totalMass(threshold));\n        }\n    }\n\n    // User Input Interface (for mass data entry)\n    interface MassDataInput {\n        operation inputComponentMass(serialNumber: SerialNumber, mass: Mass);\n        operation inputEngineMass(serialNumber: SerialNumber, mass: Mass);\n        operation inputTransmissionMass(serialNumber: SerialNumber, mass: Mass);\n        operation inputVehicleMass(vin: VIN, mass: Mass);\n    }\n\n    // Mass Summary Interface\n    interface MassSummary {\n        operation getTotalVehicleMass(vin: VIN, threshold: Mass = 0 kg): Mass;\n        operation getComponentMass(serialNumber: SerialNumber, threshold: Mass = 0 kg): Mass;\n    }\n\n}",
    "package QualityAggregationManagement {\n\n    // Abstract definition for any object with mass\n    abstract part type MassObject {\n        attribute simpleMass: Real;\n        attribute totalMass: Real;\n    }\n\n    // The most basic object: simpleThing\n    part type SimpleThing specializes MassObject {\n        constraint totalMassEqualsSimpleMass {\n            totalMass = simpleMass;\n        }\n    }\n\n    // Composite object: compositeThing\n    part type CompositeThing specializes MassObject {\n        // Subcomponents, each is a MassObject\n        part subcomponents: MassObject[0..*];\n\n        constraint totalMassAggregation {\n            totalMass = simpleMass + sum(subcomponents.totalMass);\n        }\n    }\n\n    // The system for quality aggregation management\n    part type QualityAggregationSystem {\n        // Top-level managed objects\n        part managedObjects: MassObject[1..*];\n    }\n}",
    "package MassManagementSystem {\n\n    import ScalarValues;\n\n    // Mass attribute type\n    type Mass = ScalarValues::Real;\n\n    // Requirement definitions\n    requirement req_aggregation_management {\n        text \"The system shall aggregate and manage the mass of objects with mass attributes.\"\n    }\n\n    requirement req_basic_mass {\n        text \"Each object shall have a basic mass.\"\n    }\n\n    requirement req_subcomponents {\n        text \"Each object can contain several subcomponents.\"\n    }\n\n    requirement req_total_mass_auto_calc {\n        text \"The system shall automatically calculate the total mass, including all subcomponents.\"\n    }\n\n    requirement req_composite_total_mass {\n        text \"For composite objects, the total mass equals the sum of the object's own basic mass and the full mass of all its subcomponents.\"\n    }\n\n    requirement req_mass_filtering_aggregation {\n        text \"The system shall support mass-based filtering and aggregation of components using a minimum mass threshold.\"\n    }\n\n    requirement req_hierarchical_decomposition {\n        text \"The system shall support hierarchical decomposition and overall mass control of complex products or equipment structures.\"\n    }\n\n    // MassObject definition\n    part definition MassObject {\n        attribute basicMass: Mass;\n        part subcomponents: MassObject[0..*];\n\n        // Calculate total mass including all subcomponents recursively\n        operation totalMass(): Mass {\n            return basicMass + subcomponents->sum(s | s.totalMass());\n        }\n\n        // Calculate total mass with mass threshold filtering\n        operation totalMassWithThreshold(minMass: Mass): Mass {\n            return basicMass + subcomponents->select(s | s.totalMass() >= minMass)->sum(s | s.totalMass());\n        }\n    }\n\n    // System context\n    part definition MassManagementSystem {\n        part managedObjects: MassObject[1..*];\n        attribute minMassThreshold: Mass;\n\n        // Aggregated mass for all managed objects\n        operation aggregateTotalMass(): Mass {\n            return managedObjects->sum(o | o.totalMass());\n        }\n\n        // Aggregated mass with threshold for all managed objects\n        operation aggregateTotalMassWithThreshold(): Mass {\n            return managedObjects->sum(o | o.totalMassWithThreshold(minMassThreshold));\n        }\n    }\n\n    // Satisfy relationships\n    satisfy MassObject -> req_basic_mass;\n    satisfy MassObject -> req_subcomponents;\n    satisfy MassObject::totalMass -> req_total_mass_auto_calc;\n    satisfy MassObject::totalMass -> req_composite_total_mass;\n    satisfy MassObject::totalMassWithThreshold -> req_mass_filtering_aggregation;\n    satisfy MassManagementSystem -> req_aggregation_management;\n    satisfy MassManagementSystem -> req_hierarchical_decomposition;\n}",
    "package VehicleDynamicsAnalysis {\n\n    requirement CalculateCoreParameters {\n        text \"The system shall calculate core vehicle dynamics parameters: power output, acceleration, speed, and position under various operating conditions.\"\n    }\n\n    requirement AccuratePowerCalculation {\n        text \"The system shall accurately calculate the vehicle’s actual available power output based on wheel power, aerodynamic drag coefficient, friction coefficient, vehicle mass, and speed.\"\n    }\n\n    requirement AccelerationDeduction {\n        text \"The system shall deduce the vehicle’s acceleration based on effective power, mass, and current speed.\"\n    }\n\n    requirement SpeedCalculation {\n        text \"The system shall calculate the vehicle’s speed at any given moment using acceleration, initial speed, and time.\"\n    }\n\n    requirement DisplacementEstimation {\n        text \"The system shall estimate vehicle displacement based on speed and time.\"\n    }\n\n    requirement HighAccuracy {\n        text \"The system shall provide high accuracy and clear logical relationships between parameters, with results suitable for practical engineering applications.\"\n    }\n\n    interface VehicleDynamicsInputs {\n        in parameter wheelPower: Real;\n        in parameter aeroDragCoeff: Real;\n        in parameter frictionCoeff: Real;\n        in parameter vehicleMass: Real;\n        in parameter speed: Real;\n        in parameter initialSpeed: Real;\n        in parameter time: Real;\n    }\n\n    interface VehicleDynamicsOutputs {\n        out parameter availablePower: Real;\n        out parameter acceleration: Real;\n        out parameter currentSpeed: Real;\n        out parameter displacement: Real;\n    }\n\n    part VehicleDynamicsCalculator {\n        feature input: VehicleDynamicsInputs;\n        feature output: VehicleDynamicsOutputs;\n    }\n\n    constraint AvailablePowerCalculation {\n        parameter wheelPower: Real;\n        parameter aeroDragCoeff: Real;\n        parameter frictionCoeff: Real;\n        parameter vehicleMass: Real;\n        parameter speed: Real;\n        parameter availablePower: Real;\n        expression availablePower = wheelPower - (0.5 * aeroDragCoeff * speed^3) - (frictionCoeff * vehicleMass * 9.81 * speed);\n    }\n\n    constraint AccelerationCalculation {\n        parameter availablePower: Real;\n        parameter vehicleMass: Real;\n        parameter speed: Real;\n        parameter acceleration: Real;\n        expression acceleration = availablePower / (vehicleMass * speed);\n    }\n\n    constraint SpeedAtTimeCalculation {\n        parameter initialSpeed: Real;\n        parameter acceleration: Real;\n        parameter time: Real;\n        parameter currentSpeed: Real;\n        expression currentSpeed = initialSpeed + acceleration * time;\n    }\n\n    constraint DisplacementCalculation {\n        parameter initialSpeed: Real;\n        parameter acceleration: Real;\n        parameter time: Real;\n        parameter displacement: Real;\n        expression displacement = initialSpeed * time + 0.5 * acceleration * time^2;\n    }\n\n    satisfies VehicleDynamicsCalculator -> CalculateCoreParameters;\n    satisfies VehicleDynamicsCalculator -> AccuratePowerCalculation;\n    satisfies VehicleDynamicsCalculator -> AccelerationDeduction;\n    satisfies VehicleDynamicsCalculator -> SpeedCalculation;\n    satisfies VehicleDynamicsCalculator -> DisplacementEstimation;\n    satisfies VehicleDynamicsCalculator -> HighAccuracy;\n\n    VehicleDynamicsCalculator {\n        constraintUsage AvailablePowerCalculation;\n        constraintUsage AccelerationCalculation;\n        constraintUsage SpeedAtTimeCalculation;\n        constraintUsage DisplacementCalculation;\n    }\n}",
    "package VehicleDynamicsSimulation {\n\n    import ScalarValues::*;\n    import SI::*;\n\n    part VehicleDynamicsSimulator {\n        attribute totalVehicleMass: Mass;\n        attribute aerodynamicDragCoefficient: Real;\n        attribute rollingResistanceCoefficient: Real;\n        attribute wheelEndOutputPower: Power;\n        attribute initialSpeed: Velocity;\n        attribute initialPosition: Length;\n        attribute timeStep: Duration;\n\n        attribute airDensity: Density = 1.225; // kg/m^3, default at sea level\n        attribute frontalArea: Area;\n\n        attribute currentSpeed: Velocity;\n        attribute currentPosition: Length;\n        attribute currentAcceleration: Acceleration;\n\n        operation simulateStep() {\n            input: (currentSpeed: Velocity, currentPosition: Length);\n            output: (newSpeed: Velocity, newPosition: Length, acceleration: Acceleration);\n        }\n    }\n\n    constraint AerodynamicDragForce {\n        parameter v: Velocity;\n        parameter Cd: Real;\n        parameter A: Area;\n        parameter rho: Density;\n        result F_drag: Force;\n        expr F_drag = 0.5 * Cd * A * rho * v^2;\n    }\n\n    constraint RollingResistanceForce {\n        parameter Crr: Real;\n        parameter m: Mass;\n        parameter g: Acceleration = 9.81; // m/s^2\n        result F_roll: Force;\n        expr F_roll = Crr * m * g;\n    }\n\n    constraint AvailableDrivingForce {\n        parameter P_wheel: Power;\n        parameter v: Velocity;\n        result F_drive: Force;\n        expr F_drive = P_wheel / v;\n    }\n\n    constraint NetForce {\n        parameter F_drive: Force;\n        parameter F_drag: Force;\n        parameter F_roll: Force;\n        result F_net: Force;\n        expr F_net = F_drive - F_drag - F_roll;\n    }\n\n    constraint AccelerationCalculation {\n        parameter F_net: Force;\n        parameter m: Mass;\n        result a: Acceleration;\n        expr a = F_net / m;\n    }\n\n    constraint SpeedUpdate {\n        parameter v0: Velocity;\n        parameter a: Acceleration;\n        parameter dt: Duration;\n        result v1: Velocity;\n        expr v1 = v0 + a * dt;\n    }\n\n    constraint PositionUpdate {\n        parameter x0: Length;\n        parameter v0: Velocity;\n        parameter a: Acceleration;\n        parameter dt: Duration;\n        result x1: Length;\n        expr x1 = x0 + v0 * dt + 0.5 * a * dt^2;\n    }\n\n    requirement SimulateAndComputeDynamics {\n        text \"The system shall simulate and compute the dynamic behavior of vehicles during straight-line driving, considering aerodynamic drag and rolling resistance, and dynamically calculate acceleration, speed, and position using wheel-end output power and total vehicle mass.\"\n    }\n\n    requirement ParameterFlexibility {\n        text \"The system shall allow users to flexibly set key parameters including aerodynamic drag coefficient, rolling resistance coefficient, total vehicle mass, wheel-end output power, initial speed, initial position, time step, air density, and frontal area.\"\n    }\n\n    requirement AccuratePhysicalModeling {\n        text \"The system shall provide accurate physical modeling and computational foundations for applications such as straight-line driving performance analysis, energy consumption simulation, and driving strategy optimization.\"\n    }\n\n    satisfies VehicleDynamicsSimulator -> SimulateAndComputeDynamics;\n    satisfies VehicleDynamicsSimulator -> ParameterFlexibility;\n    satisfies VehicleDynamicsSimulator -> AccuratePhysicalModeling;\n\n    VehicleDynamicsSimulator.simulateStep\n        conformsTo AerodynamicDragForce,\n                   RollingResistanceForce,\n                   AvailableDrivingForce,\n                   NetForce,\n                   AccelerationCalculation,\n                   SpeedUpdate,\n                   PositionUpdate;\n}",
    "package VehicleDynamicsSimulation {\n\n    import ScalarValues::*;\n    import SI::*;\n\n    part VehicleDynamicsSystem {\n        attribute vehicleMass: Mass;\n        attribute wheelPower: Power;\n        attribute aeroDragCoeff: Real;\n        attribute rollingResistCoeff: Real;\n        attribute initialSpeed: Velocity;\n        attribute initialPosition: Length;\n        attribute timeStep: Duration;\n        attribute airDensity: Density = 1.225; // default at sea level [kg/m^3]\n        attribute frontalArea: Area;\n\n        attribute currentSpeed: Velocity;\n        attribute currentPosition: Length;\n        attribute currentAcceleration: Acceleration;\n        attribute currentTime: Time = 0.0;\n\n        constraint CalculateAerodynamicDrag {\n            input: speed: Velocity;\n            output: dragForce: Force;\n            expr: dragForce = 0.5 * airDensity * frontalArea * aeroDragCoeff * speed^2;\n        }\n\n        constraint CalculateRollingResistance {\n            input: mass: Mass;\n            input: gravity: Acceleration = 9.81;\n            output: rollingForce: Force;\n            expr: rollingForce = rollingResistCoeff * mass * gravity;\n        }\n\n        constraint CalculateTractiveForce {\n            input: power: Power;\n            input: speed: Velocity;\n            output: tractiveForce: Force;\n            expr: tractiveForce = if speed > 0.0 then power / speed else 0.0;\n        }\n\n        constraint CalculateNetForce {\n            input: tractive: Force;\n            input: drag: Force;\n            input: rolling: Force;\n            output: netForce: Force;\n            expr: netForce = tractive - drag - rolling;\n        }\n\n        constraint CalculateAcceleration {\n            input: netForce: Force;\n            input: mass: Mass;\n            output: acceleration: Acceleration;\n            expr: acceleration = netForce / mass;\n        }\n\n        constraint UpdateSpeed {\n            input: speed: Velocity;\n            input: acceleration: Acceleration;\n            input: dt: Duration;\n            output: newSpeed: Velocity;\n            expr: newSpeed = speed + acceleration * dt;\n        }\n\n        constraint UpdatePosition {\n            input: position: Length;\n            input: speed: Velocity;\n            input: acceleration: Acceleration;\n            input: dt: Duration;\n            output: newPosition: Length;\n            expr: newPosition = position + speed * dt + 0.5 * acceleration * dt^2;\n        }\n\n        constraint UpdateTime {\n            input: time: Time;\n            input: dt: Duration;\n            output: newTime: Time;\n            expr: newTime = time + dt;\n        }\n\n        action simulateStep {\n            input: prevSpeed: Velocity;\n            input: prevPosition: Length;\n            input: prevTime: Time;\n            output: nextSpeed: Velocity;\n            output: nextPosition: Length;\n            output: nextAcceleration: Acceleration;\n            output: nextTime: Time;\n\n            do {\n                drag = CalculateAerodynamicDrag(speed=prevSpeed);\n                rolling = CalculateRollingResistance(mass=vehicleMass);\n                tractive = CalculateTractiveForce(power=wheelPower, speed=prevSpeed);\n                netForce = CalculateNetForce(tractive=tractive, drag=drag, rolling=rolling);\n                acceleration = CalculateAcceleration(netForce=netForce, mass=vehicleMass);\n                nextSpeed = UpdateSpeed(speed=prevSpeed, acceleration=acceleration, dt=timeStep);\n                nextPosition = UpdatePosition(position=prevPosition, speed=prevSpeed, acceleration=acceleration, dt=timeStep);\n                nextAcceleration = acceleration;\n                nextTime = UpdateTime(time=prevTime, dt=timeStep);\n            }\n        }\n\n        stateMachine SimulationStateMachine {\n            state Idle {\n                on entry {\n                    currentSpeed = initialSpeed;\n                    currentPosition = initialPosition;\n                    currentTime = 0.0;\n                }\n                transition to Simulating when startSimulation;\n            }\n            state Simulating {\n                on entry {\n                    // Simulation loop handled externally or by repeated action calls\n                }\n                transition to Completed when simulationComplete;\n            }\n            state Completed {}\n        }\n    }\n\n    interface VehicleDynamicsUser {\n        operation setInputParameters(\n            vehicleMass: Mass,\n            wheelPower: Power,\n            aeroDragCoeff: Real,\n            rollingResistCoeff: Real,\n            initialSpeed: Velocity,\n            initialPosition: Length,\n            timeStep: Duration,\n            frontalArea: Area\n        );\n        operation startSimulation();\n        operation getCurrentState(): (\n            speed: Velocity,\n            position: Length,\n            acceleration: Acceleration,\n            time: Time\n        );\n    }\n\n    VehicleDynamicsSystem realizes VehicleDynamicsUser;\n\n}",
    "package VehicleLongitudinalDynamics {\n\n    import ScalarValues::*;\n    import SI::*;\n\n    part VehicleSystem {\n        attribute initialPosition: Length;\n        attribute initialVelocity: Velocity;\n        attribute vehicleMass: Mass;\n        attribute wheelEndDrivePower: Power;\n        attribute timeInterval: Duration;\n        attribute dragCoefficient: Real;\n        attribute frictionCoefficient: Real;\n        attribute frontalArea: Area;\n        attribute airDensity: Density = 1.225 \"kg/m^3\"; // default at sea level\n\n        attribute acceleration: Acceleration;\n        attribute finalVelocity: Velocity;\n        attribute finalPosition: Length;\n\n        constraint CalculateLongitudinalDynamics {\n            // Air resistance: F_drag = 0.5 * airDensity * dragCoefficient * frontalArea * v^2\n            def F_drag(v: Velocity) = 0.5 * airDensity * dragCoefficient * frontalArea * v^2;\n\n            // Frictional resistance: F_friction = frictionCoefficient * vehicleMass * g\n            def F_friction = frictionCoefficient * vehicleMass * 9.80665 \"m/s^2\";\n\n            // Total resistance: F_total = F_drag + F_friction\n            def F_total(v: Velocity) = F_drag(v) + F_friction;\n\n            // Drive force: F_drive = wheelEndDrivePower / v, avoid division by zero\n            def F_drive(v: Velocity) = if v > 0.01 \"m/s\" then wheelEndDrivePower / v else 0.0 \"N\";\n\n            // Net force: F_net = F_drive - F_total\n            def F_net(v: Velocity) = F_drive(v) - F_total(v);\n\n            // Acceleration: a = F_net / vehicleMass\n            acceleration = F_net(initialVelocity) / vehicleMass;\n\n            // Final velocity: v_f = initialVelocity + acceleration * timeInterval\n            finalVelocity = initialVelocity + acceleration * timeInterval;\n\n            // Final position: s_f = initialPosition + initialVelocity * timeInterval + 0.5 * acceleration * timeInterval^2\n            finalPosition = initialPosition + initialVelocity * timeInterval + 0.5 * acceleration * timeInterval^2;\n        }\n    }\n\n    interface VehicleDynamicsInput {\n        in initialPosition: Length;\n        in initialVelocity: Velocity;\n        in vehicleMass: Mass;\n        in wheelEndDrivePower: Power;\n        in timeInterval: Duration;\n        in dragCoefficient: Real;\n        in frictionCoefficient: Real;\n        in frontalArea: Area;\n        in airDensity: Density;\n    }\n\n    interface VehicleDynamicsOutput {\n        out acceleration: Acceleration;\n        out finalVelocity: Velocity;\n        out finalPosition: Length;\n    }\n\n    usage VehicleDynamicsUsage {\n        input: VehicleDynamicsInput;\n        output: VehicleDynamicsOutput;\n        part vehicleSystem: VehicleSystem;\n\n        constraint BindInputsOutputs {\n            vehicleSystem.initialPosition = input.initialPosition;\n            vehicleSystem.initialVelocity = input.initialVelocity;\n            vehicleSystem.vehicleMass = input.vehicleMass;\n            vehicleSystem.wheelEndDrivePower = input.wheelEndDrivePower;\n            vehicleSystem.timeInterval = input.timeInterval;\n            vehicleSystem.dragCoefficient = input.dragCoefficient;\n            vehicleSystem.frictionCoefficient = input.frictionCoefficient;\n            vehicleSystem.frontalArea = input.frontalArea;\n            vehicleSystem.airDensity = input.airDensity;\n\n            output.acceleration = vehicleSystem.acceleration;\n            output.finalVelocity = vehicleSystem.finalVelocity;\n            output.finalPosition = vehicleSystem.finalPosition;\n        }\n    }\n}",
    "package VehicleMassManagement {\n\n    import ScalarValues::*;\n    import CommonConcepts::*;\n\n    part Vehicle {\n        part chassis: Chassis;\n        part engine: Engine;\n        part gearbox: Gearbox;\n\n        def totalMass: Mass = chassis.mass + engine.mass + gearbox.mass;\n\n        constraint massLimit {\n            totalMass <= 2500 kg;\n        }\n\n        event overweightWarning;\n\n        behavior checkMass {\n            if (totalMass > 2500 kg) {\n                emit overweightWarning;\n            }\n        }\n    }\n\n    part Chassis {\n        attribute mass: Mass;\n    }\n\n    part Engine {\n        attribute mass: Mass;\n    }\n\n    part Gearbox {\n        attribute mass: Mass;\n    }\n\n    requirement VehicleMassLimit {\n        text \"The total mass of the chassis, engine, and gearbox shall not exceed 2,500 kilograms.\";\n        verify Vehicle.massLimit;\n    }\n\n    requirement OverweightWarning {\n        text \"If the combined mass exceeds 2,500 kilograms, the system shall issue an overweight warning.\";\n        verify Vehicle.checkMass;\n    }\n}",
    "package VehicleMassBudgeting {\n\n    import ScalarValues::*;\n    import Units::*;\n\n    // Define the kilogram unit\n    unit kilogram : MassUnit = si::kilogram;\n\n    // Define the Mass property\n    property Mass : Real[kg];\n\n    // Define the Vehicle Component\n    part Vehicle {\n        property chassis : Chassis;\n        property engine : Engine;\n        property transmission : Transmission;\n        property otherComponents : Mass[kg][*];\n\n        // Total mass calculation\n        property totalMass : Mass[kg] = \n            chassis.mass + engine.mass + transmission.mass + sum(otherComponents);\n\n        // Mass limit constant\n        constant massLimit : Mass[kg] = 2500.0[kg];\n\n        // Constraint: total mass must not exceed limit\n        constraint massConstraint {\n            totalMass <= massLimit;\n        }\n    }\n\n    // Chassis component\n    part Chassis {\n        property mass : Mass[kg];\n    }\n\n    // Engine component\n    part Engine {\n        property mass : Mass[kg];\n    }\n\n    // Transmission component\n    part Transmission {\n        property mass : Mass[kg];\n    }\n\n    // Requirement: Mass entry and unit\n    requirement MassEntryUnit {\n        text \"The actual mass of each component shall be entered and measured in kilograms (kg).\";\n    }\n\n    // Requirement: Mass limit\n    requirement MassLimit {\n        text \"The total mass of the complete vehicle, including chassis, engine, and transmission, shall not exceed 2,500 kilograms.\";\n        verify Vehicle.massConstraint;\n    }\n\n    // Requirement: Engine and transmission mass management\n    requirement EngineTransmissionMassManagement {\n        text \"The masses of the engine and the transmission shall be separately recorded and managed as critical components.\";\n    }\n\n    // Requirement: Curb weight control\n    requirement CurbWeightControl {\n        text \"During the preliminary design stage, the system shall control vehicle curb weight through these constraints to provide a basis for performance and energy optimization.\";\n    }\n}",
    "package VehicleMassCompliance {\n\n    import ScalarValues::*;\n    import CommonConcepts::*;\n\n    // Requirement Definitions\n    requirement VehicleMassComplianceReq {\n        text \"The total mass of the complete vehicle (sum of chassis, engine, and transmission masses) must not exceed 2,500 kilograms to meet compliance requirements.\"\n    }\n\n    requirement MassDataAcquisitionReq {\n        text \"The system shall receive the actual mass data of each vehicle component (chassis, engine, transmission).\"\n    }\n\n    requirement MassVerificationReq {\n        text \"The system shall automatically verify whether the total vehicle mass exceeds the specified upper mass limit.\"\n    }\n\n    // Block Definitions\n    part VehicleSystem {\n        part chassis: Chassis;\n        part engine: Engine;\n        part transmission: Transmission;\n        part massComplianceController: MassComplianceController;\n    }\n\n    part Chassis {\n        attribute mass: Mass;\n    }\n\n    part Engine {\n        attribute mass: Mass;\n    }\n\n    part Transmission {\n        attribute mass: Mass;\n    }\n\n    part MassComplianceController {\n        operation receiveMassData(\n            chassisMass: Mass,\n            engineMass: Mass,\n            transmissionMass: Mass\n        );\n        operation verifyMassCompliance(\n            chassisMass: Mass,\n            engineMass: Mass,\n            transmissionMass: Mass\n        ): Boolean;\n    }\n\n    // Value Type Definitions\n    value type Mass {\n        unit: kilogram;\n        range: [0.0, 10000.0];\n    }\n\n    // Constraint Definitions\n    constraint VehicleTotalMassLimit {\n        input chassisMass: Mass;\n        input engineMass: Mass;\n        input transmissionMass: Mass;\n        parameter maxVehicleMass: Mass = 2500.0 kilogram;\n        assert (chassisMass + engineMass + transmissionMass) <= maxVehicleMass;\n    }\n\n    // Satisfy Relationships\n    satisfy VehicleMassComplianceReq by VehicleTotalMassLimit;\n    satisfy MassDataAcquisitionReq by MassComplianceController::receiveMassData;\n    satisfy MassVerificationReq by MassComplianceController::verifyMassCompliance;\n\n    // Usage Example\n    usecase VehicleMassComplianceUseCase {\n        subject: VehicleSystem;\n        scenario {\n            step 1: massComplianceController.receiveMassData(\n                chassis.mass, engine.mass, transmission.mass\n            );\n            step 2: massComplianceController.verifyMassCompliance(\n                chassis.mass, engine.mass, transmission.mass\n            );\n        }\n    }\n}",
    "package VehicleWeightManagement {\n\n    part VehicleSystem {\n        part chassis: Chassis;\n        part engine: Engine;\n        part transmission: Transmission;\n        part weightManager: WeightManager;\n    }\n\n    part Chassis {\n        attribute weight: Real;\n    }\n\n    part Engine {\n        attribute weight: Real;\n    }\n\n    part Transmission {\n        attribute weight: Real;\n    }\n\n    part WeightManager {\n        attribute chassisWeight: Real;\n        attribute engineWeight: Real;\n        attribute transmissionWeight: Real;\n        attribute totalWeight: Real;\n        attribute weightLimit: Real = 2500.0;\n        attribute warningIssued: Boolean;\n        attribute restrictionsImposed: Boolean;\n\n        constraint sumWeights {\n            totalWeight = chassisWeight + engineWeight + transmissionWeight;\n        }\n\n        constraint weightLimitNotExceeded {\n            totalWeight <= weightLimit;\n        }\n\n        constraint warningOrRestriction {\n            if totalWeight > weightLimit {\n                warningIssued = true;\n                restrictionsImposed = true;\n            } else {\n                warningIssued = false;\n                restrictionsImposed = false;\n            }\n        }\n    }\n\n    requirement WeightLimitRequirement {\n        text \"The combined weight of the chassis, engine, and transmission must not exceed 2,500 kilograms.\"\n        verify WeightManager::weightLimitNotExceeded;\n    }\n\n    requirement WeightRecordingRequirement {\n        text \"The system must record and manage the weight of each component (chassis, engine, transmission).\"\n        verify WeightManager::chassisWeight;\n        verify WeightManager::engineWeight;\n        verify WeightManager::transmissionWeight;\n    }\n\n    requirement WeightSummationRequirement {\n        text \"The system must automatically sum the weights of the chassis, engine, and transmission.\"\n        verify WeightManager::sumWeights;\n    }\n\n    requirement WarningRestrictionRequirement {\n        text \"If the total weight exceeds the limit, the system must provide a warning or impose restrictions.\"\n        verify WeightManager::warningOrRestriction;\n    }\n\n    requirement ComplianceRequirement {\n        text \"The system must ensure the vehicle’s total weight complies with regulatory requirements for legality, compliance, and safety.\"\n        derive WeightLimitRequirement;\n        derive WarningRestrictionRequirement;\n    }\n\n    satisfies VehicleSystem -> WeightLimitRequirement;\n    satisfies VehicleSystem -> WeightRecordingRequirement;\n    satisfies VehicleSystem -> WeightSummationRequirement;\n    satisfies VehicleSystem -> WarningRestrictionRequirement;\n    satisfies VehicleSystem -> ComplianceRequirement;\n\n    binding VehicleSystem.chassis.weight = VehicleSystem.weightManager.chassisWeight;\n    binding VehicleSystem.engine.weight = VehicleSystem.weightManager.engineWeight;\n    binding VehicleSystem.transmission.weight = VehicleSystem.weightManager.transmissionWeight;\n}",
    "package VehicleSystem {\n\n    // Define Mass Quantity Kind\n    quantity kind Mass = kilogram;\n\n    // Define Time Quantity Kind\n    quantity kind Time = second;\n\n    // Define Force Quantity Kind\n    quantity kind Force = newton;\n\n    // Define Velocity Quantity Kind\n    quantity kind Velocity = meter_per_second;\n\n    // Vehicle Component Abstract Definition\n    part definition VehicleComponent {\n        attribute mass: Mass;\n    }\n\n    // Chassis Definition\n    part definition Chassis specializes VehicleComponent {\n    }\n\n    // Engine Definition\n    part definition Engine specializes VehicleComponent {\n    }\n\n    // Transmission Definition\n    part definition Transmission specializes VehicleComponent {\n    }\n\n    // Vehicle Definition\n    part definition Vehicle {\n        part chassis: Chassis;\n        part engine: Engine;\n        part transmission: Transmission;\n\n        // Total mass as sum of component masses\n        attribute totalMass: Mass;\n\n        constraint totalMassCalculation {\n            totalMass = chassis.mass + engine.mass + transmission.mass;\n        }\n\n        // Mass constraint: total mass <= 2500 kg\n        constraint totalMassLimit {\n            totalMass <= 2500 kilogram;\n        }\n\n        // Mass must be greater than zero\n        constraint positiveMass {\n            totalMass > 0 kilogram;\n        }\n    }\n\n    // Dynamic Behavior Definition\n    behavior definition VehicleDynamics {\n        // Parameters\n        parameter input initialVelocity: Velocity;\n        parameter input finalVelocity: Velocity;\n        parameter input mass: Mass;\n        parameter input force: Force;\n        parameter input duration: Time;\n\n        // Mass must be greater than zero\n        constraint positiveMass {\n            mass > 0 kilogram;\n        }\n\n        // Newton's Second Law: F * t = m * (v_f - v_i)\n        constraint dynamicConstraint {\n            force * duration = mass * (finalVelocity - initialVelocity);\n        }\n    }\n\n    // Vehicle Usage with Dynamics\n    part usage vehicle: Vehicle;\n\n    behavior usage dynamics: VehicleDynamics;\n\n    // Bind vehicle total mass to dynamics mass\n    constraint massBinding {\n        dynamics.mass = vehicle.totalMass;\n    }\n}",
    "package VehicleMaintenanceSystem {\n\n    import sysml::standard;\n\n    // Enumerations\n    enum VehicleStatus {\n        healthy;\n        under_maintenance;\n    }\n\n    // Vehicle concept\n    part Vehicle {\n        attribute id: String;\n        attribute nextMaintenanceTime: DateTime;\n        attribute maintenanceInterval: Duration;\n        attribute maxAllowedTemperature: Real;\n        attribute status: VehicleStatus = VehicleStatus::healthy;\n        attribute actualMaintenanceStartTime: DateTime;\n        attribute actualMaintenanceEndTime: DateTime;\n    }\n\n    // System concept\n    part MaintenanceManager {\n        part vehicles: Vehicle[0..*];\n\n        // Determine if maintenance is due\n        operation isMaintenanceDue(v: Vehicle): Boolean {\n            return (now() >= v.nextMaintenanceTime);\n        }\n\n        // Switch status to under maintenance\n        operation switchToUnderMaintenance(v: Vehicle) {\n            if (isMaintenanceDue(v)) {\n                v.status = VehicleStatus::under_maintenance;\n            }\n        }\n\n        // Postpone next maintenance time\n        operation postponeNextMaintenance(v: Vehicle) {\n            v.nextMaintenanceTime = v.nextMaintenanceTime + v.maintenanceInterval;\n        }\n\n        // Restore health status\n        operation restoreHealthStatus(v: Vehicle) {\n            v.status = VehicleStatus::healthy;\n        }\n    }\n\n    // Constraints\n    constraint MaintenanceStartAfterScheduled {\n        for (v in MaintenanceManager.vehicles) {\n            if (v.status == VehicleStatus::under_maintenance) {\n                v.actualMaintenanceStartTime > v.nextMaintenanceTime;\n            }\n        }\n    }\n\n    constraint MaintenanceStartWithin2Seconds {\n        for (v in MaintenanceManager.vehicles) {\n            if (v.status == VehicleStatus::under_maintenance) {\n                (v.actualMaintenanceStartTime - v.actualMaintenanceEndTime[previous]) <= duration(\"PT2S\");\n            }\n        }\n    }\n\n    constraint MaintenanceDurationLimit {\n        for (v in MaintenanceManager.vehicles) {\n            if (v.status == VehicleStatus::under_maintenance) {\n                (v.actualMaintenanceEndTime - v.actualMaintenanceStartTime) <= duration(\"PT48H\");\n            }\n        }\n    }\n\n    // Behavior: Maintenance process\n    behavior MaintenanceProcess {\n        input v: Vehicle;\n\n        state Healthy {\n            on (MaintenanceManager.isMaintenanceDue(v)) {\n                v.status = VehicleStatus::under_maintenance;\n                transition to UnderMaintenance;\n            }\n        }\n\n        state UnderMaintenance {\n            entry {\n                v.actualMaintenanceStartTime = now();\n            }\n            exit {\n                v.actualMaintenanceEndTime = now();\n                MaintenanceManager.postponeNextMaintenance(v);\n                MaintenanceManager.restoreHealthStatus(v);\n            }\n            after (duration(\"PT48H\")) {\n                // Maintenance duration limit\n                transition to Healthy;\n            }\n        }\n\n        initial Healthy;\n    }\n}",
    "package VehicleSystem {\n\n    import sysml::units;\n    import sysml::constraints;\n\n    // Value definitions\n    value MaximumMassLimit : Real [units::kg];\n    value CurbWeight : Real [units::kg];\n    value FuelMass : Real [units::kg];\n    value EngineSpeed : Real [units::rpm];\n    value EngineTorque : Real [units::Nm];\n\n    // Requirement: Total mass constraint\n    constraint TotalMassConstraint {\n        (CurbWeight + FuelMass) <= MaximumMassLimit;\n    }\n\n    // Requirement: Fuel mass positive\n    constraint FuelMassPositive {\n        FuelMass > 0.0;\n    }\n\n    // Engine block\n    part Engine {\n        attribute speed : Real [units::rpm];\n        attribute torque : Real [units::Nm];\n\n        // Requirement: Torque-speed curve\n        constraint TorqueSpeedCurve {\n            // Placeholder for actual torque-speed function\n            torque == torque_speed_function(speed);\n        }\n    }\n\n    // Clutch interface\n    interface ClutchInterface {\n        in torque_in : Real [units::Nm];\n        out torque_out : Real [units::Nm];\n    }\n\n    // Transmission block\n    part Transmission {\n        in torque_in : Real [units::Nm];\n        out torque_out : Real [units::Nm];\n    }\n\n    // Drive system block\n    part DriveSystem {\n        in torque_in : Real [units::Nm];\n    }\n\n    // Requirement: Torque transmission through clutch\n    constraint TorqueTransmittedThroughClutch {\n        // The torque output from engine is input to clutch\n        Engine.torque == ClutchInterface.torque_in;\n        // The clutch transmits torque to transmission\n        ClutchInterface.torque_out == Transmission.torque_in;\n        // Transmission outputs torque to drive system\n        Transmission.torque_out == DriveSystem.torque_in;\n        // Smooth delivery (placeholder for smoothness constraint)\n        // smooth(ClutchInterface.torque_out);\n    }\n\n    // System composition\n    part Vehicle {\n        part engine : Engine;\n        part clutch : ClutchInterface;\n        part transmission : Transmission;\n        part driveSystem : DriveSystem;\n\n        // Connect engine to clutch\n        connect engine.torque -> clutch.torque_in;\n        connect clutch.torque_out -> transmission.torque_in;\n        connect transmission.torque_out -> driveSystem.torque_in;\n    }\n\n    // Requirements grouping\n    requirement TotalMassRequirement {\n        subject Vehicle;\n        verify TotalMassConstraint;\n    }\n\n    requirement FuelMassRequirement {\n        subject Vehicle;\n        verify FuelMassPositive;\n    }\n\n    requirement EngineTorqueRequirement {\n        subject Engine;\n        verify TorqueSpeedCurve;\n    }\n\n    requirement TorqueTransmissionRequirement {\n        subject Vehicle;\n        verify TorqueTransmittedThroughClutch;\n    }\n}",
    "package VehicleSystemRequirements {\n\n    requirement VehicleMassWithFullFuelTank {\n        text \"With a full fuel tank, the vehicle’s total mass must not exceed 2000 kg.\"\n        constraint VehicleMassFullFuelTankConstraint {\n            input: vehicle: Vehicle;\n            input: fuelTank: FuelTank;\n            input: fuel: Fuel;\n            input: dryMass: Real = vehicle.dryMass;\n            input: fuelMass: Real = fuelTank.capacity * fuel.density;\n            output: totalMass: Real = dryMass + fuelMass;\n            assert totalMass <= 2000.0;\n        }\n    }\n\n    requirement VehicleMassWithEmptyFuelTank {\n        text \"With an empty fuel tank, the vehicle’s total mass must not exceed 1500 kg.\"\n        constraint VehicleMassEmptyFuelTankConstraint {\n            input: vehicle: Vehicle;\n            input: dryMass: Real = vehicle.dryMass;\n            output: totalMass: Real = dryMass;\n            assert totalMass <= 1500.0;\n        }\n    }\n\n    requirement EngineTorqueTransmission {\n        text \"The engine must be capable of transmitting its generated torque to the transmission via the clutch interface.\"\n        constraint EngineTorqueTransmissionConstraint {\n            input: engine: Engine;\n            input: clutch: Clutch;\n            input: transmission: Transmission;\n            assert engine.outputTorque == clutch.inputTorque;\n            assert clutch.outputTorque == transmission.inputTorque;\n        }\n    }\n\n    requirement EngineSpeedTorquePerformance {\n        text \"The engine is required to deliver the necessary torque according to the speed-torque curve (see Table 1).\"\n        constraint EngineSpeedTorqueCurveConstraint {\n            input: engine: Engine;\n            input: speed: Real;\n            input: requiredTorque: Real = lookupTable1(speed);\n            assert engine.outputTorque >= requiredTorque;\n        }\n    }\n\n    requirement VehicleMassControlObjective {\n        text \"The system aims to regulate vehicle mass control, ensuring the safety of vehicle design.\"\n        refine VehicleMassWithFullFuelTank;\n        refine VehicleMassWithEmptyFuelTank;\n    }\n\n    requirement PowertrainInterfaceAndPerformanceObjective {\n        text \"The system aims to regulate the interface and performance of the powertrain, ensuring the effectiveness of power transmission.\"\n        refine EngineTorqueTransmission;\n        refine EngineSpeedTorquePerformance;\n    }\n\n    part Vehicle {\n        attribute dryMass: Real;\n        part fuelTank: FuelTank;\n        part engine: Engine;\n        part transmission: Transmission;\n    }\n\n    part FuelTank {\n        attribute capacity: Real;\n    }\n\n    part Fuel {\n        attribute density: Real;\n    }\n\n    part Engine {\n        attribute outputTorque: Real;\n    }\n\n    part Clutch {\n        attribute inputTorque: Real;\n        attribute outputTorque: Real;\n    }\n\n    part Transmission {\n        attribute inputTorque: Real;\n    }\n\n    function lookupTable1(speed: Real): Real;\n}",
    "package VehicleSystemRequirements {\n\n    requirement VehicleMassLimits {\n        text \"The vehicle's total mass must not exceed 2000 kilograms when fully fueled, and should not be higher than 1500 kilograms when empty.\"\n    }\n\n    requirement EngineTorqueTransmission {\n        text \"The engine must be capable of effectively transmitting its generated torque to the transmission system through a clutch interface.\"\n    }\n\n    requirement EngineTorquePerformance {\n        text \"The torque generated by the engine should vary with speed, conforming to the relevant performance table specifications.\"\n    }\n\n    requirement VehiclePerformanceAndSafety {\n        text \"The design of both the vehicle and its engine must meet these critical requirements for mass and power interface to ensure overall vehicle performance and safety.\"\n    }\n\n    part Vehicle {\n        part engine: Engine;\n        part transmission: Transmission;\n        part clutch: Clutch;\n    }\n\n    part Engine {\n        attribute torque: Real;\n        attribute speed: Real;\n    }\n\n    part Transmission {}\n\n    part Clutch {}\n\n    constraint VehicleMassConstraint {\n        parameter full_mass: Real;\n        parameter empty_mass: Real;\n        expression: full_mass <= 2000 and empty_mass <= 1500;\n    }\n\n    constraint EngineTorqueVsSpeed {\n        parameter torque: Real;\n        parameter speed: Real;\n        // Placeholder for performance table reference\n        expression: conformsToPerformanceTable(torque, speed);\n    }\n\n    interface PowerInterface {\n        in torque: Real;\n        in speed: Real;\n    }\n\n    satisfy VehicleMassLimits by VehicleMassConstraint;\n    satisfy EngineTorqueTransmission by [Vehicle.engine, Vehicle.clutch, Vehicle.transmission];\n    satisfy EngineTorquePerformance by EngineTorqueVsSpeed;\n    satisfy VehiclePerformanceAndSafety by [VehicleMassConstraint, EngineTorqueVsSpeed, PowerInterface];\n\n    Vehicle.engine conformsTo PowerInterface;\n    Vehicle.clutch conformsTo PowerInterface;\n    Vehicle.transmission conformsTo PowerInterface;\n\n}",
    "package VehicleSystemRequirements {\n\n    import ScalarValues::*;\n    import SI::*;\n\n    // Value definitions\n    value definition CurbMass : Mass;\n    value definition FuelMass : Mass;\n    value definition TotalVehicleMass : Mass;\n    value definition FuelTankState : enumeration { full, empty };\n    value definition Torque : Torque;\n    value definition EngineSpeed : AngularVelocity;\n\n    // Requirement: Total vehicle mass calculation\n    constraint definition TotalVehicleMassCalculation {\n        TotalVehicleMass = CurbMass + FuelMass;\n    }\n\n    // Requirement: Mass limits for operating conditions\n    constraint definition MassLimitFullTank {\n        context FuelTankState = #full;\n        TotalVehicleMass <= 2000 * kilogram;\n    }\n\n    constraint definition MassLimitEmptyTank {\n        context FuelTankState = #empty;\n        TotalVehicleMass <= 1500 * kilogram;\n    }\n\n    // Requirement: Engine torque characteristics\n    requirement EngineTorqueCharacteristic {\n        text \"The engine shall be capable of generating the specified torque characteristics at various engine speeds.\";\n    }\n\n    // Requirement: Torque transmission through clutch\n    requirement TorqueTransmissionToGearbox {\n        text \"The generated torque shall be effectively transmitted to the gearbox through the clutch interface to ensure smooth power delivery.\";\n    }\n\n    // Requirement: Compliance with design and safety standards\n    requirement ComplianceWithStandards {\n        text \"Vehicle mass control and power transmission shall comply with design and safety standards.\";\n    }\n\n    // Vehicle System Requirement Group\n    requirement VehicleSystemRequirements {\n        refines TotalVehicleMassCalculation;\n        refines MassLimitFullTank;\n        refines MassLimitEmptyTank;\n        refines EngineTorqueCharacteristic;\n        refines TorqueTransmissionToGearbox;\n        refines ComplianceWithStandards;\n    }\n}",
    "package VehiclePerformanceAnalysisSystem {\n\n    import ScalarValues::*;\n    import CommonUnits::*;\n\n    part VehiclePerformanceAnalysisSystem {\n        attribute vehicle: Vehicle;\n        attribute driveCycle: DriveCycle;\n        attribute analysisResult: AnalysisResult;\n        attribute energyConsumptionTarget: EnergyConsumptionTarget;\n    }\n\n    part Vehicle {\n        attribute curbWeight: Mass;\n        attribute payload: Mass;\n        attribute wheelDiameter: Length;\n        attribute transmissionEfficiency: Ratio;\n        attribute fuelEconomyUrban: FuelEconomy;\n        attribute fuelEconomyHighway: FuelEconomy;\n    }\n\n    part DriveCycle {\n        attribute cyclePoints: List<DriveCyclePoint>;\n    }\n\n    part DriveCyclePoint {\n        attribute time: Time;\n        attribute position: Length;\n        attribute speed: Velocity;\n    }\n\n    part AnalysisResult {\n        attribute powerDemand: List<PowerDemandPoint>;\n        attribute accelerationProfile: List<AccelerationPoint>;\n        attribute speedProfile: List<SpeedPoint>;\n        attribute positionProfile: List<PositionPoint>;\n        attribute totalFuelEconomy: FuelEconomy;\n        attribute complianceResult: ComplianceResult;\n    }\n\n    part PowerDemandPoint {\n        attribute time: Time;\n        attribute power: Power;\n    }\n\n    part AccelerationPoint {\n        attribute time: Time;\n        attribute acceleration: Acceleration;\n    }\n\n    part SpeedPoint {\n        attribute time: Time;\n        attribute speed: Velocity;\n    }\n\n    part PositionPoint {\n        attribute time: Time;\n        attribute position: Length;\n    }\n\n    part FuelEconomy {\n        attribute value: Real;\n        attribute unit: FuelEconomyUnit;\n    }\n\n    enum FuelEconomyUnit {\n        L_per_100km,\n        mpg\n    }\n\n    part EnergyConsumptionTarget {\n        attribute targetValue: Real;\n        attribute unit: FuelEconomyUnit;\n    }\n\n    part ComplianceResult {\n        attribute isCompliant: Boolean;\n        attribute actualValue: Real;\n        attribute targetValue: Real;\n        attribute unit: FuelEconomyUnit;\n    }\n\n    requirement DynamicPerformanceAnalysis {\n        text \"The system shall model and calculate power demand, acceleration, speed, and position variations over time during straight-line driving.\"\n    }\n\n    requirement VehicleAttributeConfiguration {\n        text \"The system shall allow users to set vehicle attributes including curb weight, payload, wheel diameter, transmission efficiency, and fuel economy under urban and highway conditions.\"\n    }\n\n    requirement DriveCycleConfiguration {\n        text \"The system shall allow users to set specific driving cycles, including time-stamped position and speed information.\"\n    }\n\n    requirement EnginePowerCalculation {\n        text \"The system shall analyze the required engine power, acceleration, and other dynamic parameters necessary to meet the specified driving cycle and vehicle configuration.\"\n    }\n\n    requirement FuelEconomyCalculation {\n        text \"The system shall calculate the vehicle’s fuel economy throughout the entire driving cycle.\"\n    }\n\n    requirement ComplianceVerification {\n        text \"The system shall support compliance verification based on specified energy consumption targets, such as fuel consumption per 100 kilometers or miles per gallon.\"\n    }\n\n    requirement Configurability {\n        text \"The system shall provide adjustable configuration options for vehicle parameters and drive cycle scenarios.\"\n    }\n\n    requirement DataSupport {\n        text \"The system shall provide data support and decision-making references for vehicle design optimization and achievement of energy consumption targets.\"\n    }\n\n    satisfies VehiclePerformanceAnalysisSystem -> DynamicPerformanceAnalysis;\n    satisfies VehiclePerformanceAnalysisSystem -> VehicleAttributeConfiguration;\n    satisfies VehiclePerformanceAnalysisSystem -> DriveCycleConfiguration;\n    satisfies VehiclePerformanceAnalysisSystem -> EnginePowerCalculation;\n    satisfies VehiclePerformanceAnalysisSystem -> FuelEconomyCalculation;\n    satisfies VehiclePerformanceAnalysisSystem -> ComplianceVerification;\n    satisfies VehiclePerformanceAnalysisSystem -> Configurability;\n    satisfies VehiclePerformanceAnalysisSystem -> DataSupport;\n\n}",
    "package VehicleFuelEconomySimulation {\n\n    import ScalarValues::*;\n    import SI::*;\n\n    // === Value Types ===\n    value type MilesPerGallon specializes Real;\n    value type LitersPer100Km specializes Real;\n    value type Kilogram specializes Real;\n    value type Meter specializes Real;\n    value type Percent specializes Real;\n    value type Power specializes Watt;\n    value type Speed specializes MeterPerSecond;\n    value type Acceleration specializes MeterPerSecondSquared;\n\n    // === Vehicle Parameters ===\n    part Vehicle {\n        attribute curbWeight: Kilogram;\n        attribute load: Kilogram;\n        attribute wheelDiameter: Meter;\n        attribute transmissionEfficiency: Percent;\n        // Additional parameters can be added as needed\n    }\n\n    // === Driving Scenario ===\n    part DrivingScenario {\n        attribute scenarioType: String; // \"Urban\" or \"Highway\"\n        attribute drivingTrajectory: Trajectory;\n        attribute speedProfile: SpeedProfile;\n    }\n\n    part Trajectory {\n        attribute distance: Meter;\n        // Additional trajectory attributes as needed\n    }\n\n    part SpeedProfile {\n        attribute speedVariations: Sequence<Speed>;\n        // Additional speed profile attributes as needed\n    }\n\n    // === Simulation Analysis ===\n    part SimulationAnalysis {\n        reference vehicle: Vehicle;\n        reference scenario: DrivingScenario;\n\n        attribute requiredWheelPower: Power;\n        attribute acceleration: Acceleration;\n        attribute energyConsumption: Joule;\n        attribute enginePowerDemand: Power;\n        attribute fuelConsumption: LitersPer100Km;\n        attribute fuelEconomy: MilesPerGallon;\n    }\n\n    // === Requirements ===\n    requirement FuelEconomyRequirement {\n        text \"The vehicle shall achieve a fuel economy exceeding 30 miles per gallon under both urban and highway driving scenarios.\";\n        attribute minimumFuelEconomy: MilesPerGallon = 30.0;\n    }\n\n    requirement EnergySavingRequirement {\n        text \"The vehicle design shall support energy-saving and emissions reduction goals in real-world use scenarios.\";\n    }\n\n    requirement RegulatoryComplianceRequirement {\n        text \"The vehicle shall comply with applicable fuel economy and emissions regulations.\";\n    }\n\n    // === Constraints ===\n    constraint FuelEconomyConstraint {\n        parameter analysis: SimulationAnalysis;\n        expression analysis.fuelEconomy > 30.0;\n    }\n\n    // === Use Case ===\n    usecase AssessVehicleDesign {\n        text \"User assesses whether the vehicle design meets energy-saving, emissions reduction, and regulatory compliance requirements based on simulation results.\";\n        actor User;\n        input analysis: SimulationAnalysis;\n        output assessmentResult: Boolean;\n    }\n\n    // === Relationships ===\n    SimulationAnalysis satisfies FuelEconomyRequirement;\n    SimulationAnalysis satisfies EnergySavingRequirement;\n    SimulationAnalysis satisfies RegulatoryComplianceRequirement;\n    AssessVehicleDesign uses SimulationAnalysis;\n\n}",
    "package EngineSelectionAnalysis {\n\n    import sysml::common::*;\n    import sysml::requirements::*;\n    import sysml::analysis::*;\n    import sysml::datatypes::*;\n\n    // Engine Types\n    enum EngineType {\n        FourCylinder,\n        SixCylinder\n    }\n\n    // Key Performance Indicators\n    structure PerformanceIndicators {\n        power: Real;\n        mass: Real;\n        efficiency: Real;\n        cost: Real;\n    }\n\n    // Engine Candidate\n    part EngineCandidate {\n        type: EngineType;\n        indicators: PerformanceIndicators;\n    }\n\n    // Evaluation Function\n    function evaluateEngine(\n        indicators: PerformanceIndicators\n    ): Real;\n\n    // System Structure\n    part EngineSelectionSystem {\n        candidates: EngineCandidate[*];\n        evaluationResults: Real[*];\n        optimalEngine: EngineCandidate;\n    }\n\n    // Requirements\n    requirement ComprehensiveSelectionAnalysis {\n        text \"The system shall conduct a comprehensive selection analysis for various types of engines, including four-cylinder and six-cylinder engines.\"\n    }\n\n    requirement AggregateAndCalculateKPIs {\n        text \"For each type of engine, the system shall aggregate and calculate key performance indicators such as power, mass, efficiency, and cost.\"\n    }\n\n    requirement UnifiedEvaluationFunction {\n        text \"The system shall use a unified evaluation function to comprehensively assess each engine based on the key performance indicators.\"\n    }\n\n    requirement AutomaticScreeningAndRecommendation {\n        text \"The system shall automatically screen and recommend the optimal engine selection from all candidates according to the comprehensive evaluation results.\"\n    }\n\n    requirement MaximizePerformanceAndEconomy {\n        text \"The system shall maximize both engine performance and economic efficiency.\"\n    }\n\n    // Analysis Cases\n    analysis AggregateKPIs {\n        input candidates: EngineCandidate[*];\n        output aggregatedIndicators: PerformanceIndicators[*];\n    }\n\n    analysis EvaluateEngines {\n        input indicators: PerformanceIndicators[*];\n        output evaluationResults: Real[*];\n    }\n\n    analysis SelectOptimalEngine {\n        input evaluationResults: Real[*];\n        input candidates: EngineCandidate[*];\n        output optimalEngine: EngineCandidate;\n    }\n\n    // Relationships\n    satisfies EngineSelectionSystem -> ComprehensiveSelectionAnalysis;\n    satisfies EngineSelectionSystem -> AggregateAndCalculateKPIs;\n    satisfies EngineSelectionSystem -> UnifiedEvaluationFunction;\n    satisfies EngineSelectionSystem -> AutomaticScreeningAndRecommendation;\n    satisfies EngineSelectionSystem -> MaximizePerformanceAndEconomy;\n\n    refines AggregateKPIs -> AggregateAndCalculateKPIs;\n    refines EvaluateEngines -> UnifiedEvaluationFunction;\n    refines SelectOptimalEngine -> AutomaticScreeningAndRecommendation;\n\n    // Behavior\n    action EngineSelectionProcess {\n        input candidates: EngineCandidate[*];\n        output optimalEngine: EngineCandidate;\n\n        step aggregateKPIs: AggregateKPIs(\n            candidates = candidates\n        );\n        step evaluate: EvaluateEngines(\n            indicators = aggregateKPIs.aggregatedIndicators\n        );\n        step select: SelectOptimalEngine(\n            evaluationResults = evaluate.evaluationResults,\n            candidates = candidates\n        );\n        output optimalEngine = select.optimalEngine;\n    }\n\n}",
    "package VehicleQualityAssessment {\n\n    import ScalarValues::*;\n    import CommonConcepts::*;\n\n    // Requirement Definitions\n    requirement VehicleCurbWeightRequirement {\n        text \"The curb weight of each vehicle must be less than or equal to 2,500 kilograms.\"\n    }\n\n    requirement VehicleWeightEvaluationProcessRequirement {\n        text \"The process must include data collection, processing, and evaluation steps to ensure scientific and accurate detection of vehicle quality.\"\n    }\n\n    // Value Type for Weight\n    value type WeightKg {\n        base ScalarValues::Real;\n        unit kg;\n    }\n\n    // Vehicle Definition\n    part Vehicle {\n        attribute curbWeight: WeightKg;\n    }\n\n    // Test Process Definition\n    action VehicleCurbWeightTest {\n        input vehicle: Vehicle;\n        output evaluationResult: EvaluationResult;\n\n        step collectData {\n            output collectedWeight: WeightKg;\n            action = collectVehicleWeight(vehicle);\n        }\n\n        step processData {\n            input collectedWeight: WeightKg;\n            output processedWeight: WeightKg;\n            action = processWeightData(collectedWeight);\n        }\n\n        step evaluateWeight {\n            input processedWeight: WeightKg;\n            output evaluationResult: EvaluationResult;\n            action = evaluateCurbWeight(processedWeight);\n        }\n\n        flow {\n            collectData.collectedWeight -> processData.collectedWeight;\n            processData.processedWeight -> evaluateWeight.processedWeight;\n            evaluateWeight.evaluationResult -> evaluationResult;\n        }\n    }\n\n    // Evaluation Result Enumeration\n    enum EvaluationResult {\n        Qualified,\n        Unqualified\n    }\n\n    // Constraint for Curb Weight\n    constraint CurbWeightLimit {\n        input curbWeight: WeightKg;\n        expression curbWeight <= 2500.0;\n    }\n\n    // Satisfy Relationships\n    satisfy VehicleCurbWeightRequirement by VehicleCurbWeightTest.evaluateWeight;\n    satisfy VehicleWeightEvaluationProcessRequirement by VehicleCurbWeightTest;\n\n    // Traceability\n    refine VehicleCurbWeightRequirement by CurbWeightLimit;\n}",
    "package VehicleMassVerificationSystem {\n\n    import ScalarValues::*;\n    import CommonConcepts::*;\n\n    value type Mass inherits ScalarValue {\n        unit: kilogram;\n    }\n\n    constant value MassUpperLimit: Mass = 2500 kilogram;\n\n    part type Vehicle {\n        attribute mass: Mass;\n    }\n\n    part type WeighingEquipment {\n        operation measureMass(vehicle: Vehicle): Mass;\n    }\n\n    part type MassVerificationUnit {\n        operation verifyMass(vehicle: Vehicle, equipment: WeighingEquipment): VerificationResult;\n    }\n\n    enum VerificationResult {\n        Qualified,\n        Unqualified\n    }\n\n    part type VehicleMassVerificationSystem {\n        part vehicles: Vehicle[1..*];\n        part weighingEquipment: WeighingEquipment;\n        part massVerificationUnit: MassVerificationUnit;\n    }\n\n    action MassInspectionProcess {\n        input vehicle: Vehicle;\n        input weighingEquipment: WeighingEquipment;\n        input massVerificationUnit: MassVerificationUnit;\n        output result: VerificationResult;\n\n        step measureMass {\n            measuredMass: Mass = weighingEquipment.measureMass(vehicle);\n        }\n        step verifyMass {\n            result = massVerificationUnit.verifyMass(vehicle, weighingEquipment);\n        }\n    }\n\n    constraint MassWithinLimit {\n        input mass: Mass;\n        assert mass <= MassUpperLimit;\n    }\n\n    behavior MassVerificationBehavior {\n        input vehicle: Vehicle;\n        input weighingEquipment: WeighingEquipment;\n        input massVerificationUnit: MassVerificationUnit;\n        output result: VerificationResult;\n\n        do {\n            measuredMass: Mass = weighingEquipment.measureMass(vehicle);\n            if measuredMass <= MassUpperLimit {\n                result = VerificationResult::Qualified;\n            } else {\n                result = VerificationResult::Unqualified;\n            }\n        }\n    }\n\n    requirement MassVerificationRequirement {\n        text \"The system shall verify that the actual mass of each vehicle does not exceed 2,500 kilograms.\";\n        verify MassWithinLimit;\n    }\n\n    requirement MassInspectionRequirement {\n        text \"Every vehicle to be inspected must undergo a mass inspection process to check whether its mass complies with the specified upper limit.\";\n        refine MassVerificationRequirement;\n    }\n\n    requirement IndependentVerificationRequirement {\n        text \"The entire mass verification process shall be carried out independently for each vehicle.\";\n    }\n\n    requirement ComplianceRequirement {\n        text \"All vehicles involved in verification shall comply with relevant standards and regulatory requirements.\";\n    }\n\n}",
    "package TransportationSystem {\n\n    // Define the main system\n    system TransportationSystem {\n        part vehicle: Vehicle;\n        part environment: Environment;\n        part infrastructure: Infrastructure;\n        part userInterface: UserInterface;\n    }\n\n    // Define the Vehicle block\n    block Vehicle {\n        attribute maxPassengers: Integer = 4;\n        attribute hasDriver: Boolean = true;\n        attribute rideComfortLevel: String;\n        attribute safetyLevel: String;\n        attribute entryExitSimplicity: String;\n        operation transport(from: Location, to: Location);\n        operation allowEntryExit(user: User);\n        operation monitorEnvironment(env: Environment);\n        operation interfaceWithInfrastructure(infra: Infrastructure);\n    }\n\n    // Define the User block\n    block User {\n        attribute userType: UserType;\n        attribute needs: String;\n    }\n\n    enum UserType {\n        Driver,\n        Passenger\n    }\n\n    // Define the Environment block\n    block Environment {\n        attribute environmentalFactors: String;\n        operation provideEnvironmentalData();\n    }\n\n    // Define the Infrastructure block\n    block Infrastructure {\n        attribute compatibleWithGasStations: Boolean = true;\n        attribute relatedFacilities: String;\n    }\n\n    // Define the UserInterface block\n    block UserInterface {\n        operation assistUser(user: User, task: TransportationTask);\n        attribute rideExperienceLevel: String;\n        attribute convenienceFeatures: String;\n    }\n\n    // Define the TransportationTask block\n    block TransportationTask {\n        attribute taskType: String;\n        attribute isCompleted: Boolean;\n    }\n\n    // Define the Location block\n    block Location {\n        attribute name: String;\n        attribute coordinates: String;\n    }\n\n    // Requirements\n    requirement ProvideConvenientEfficientTransportation {\n        text \"The system shall provide end users with a convenient and efficient mode of transportation.\";\n    }\n\n    requirement SupportDriverAndPassengers {\n        text \"The system shall support a driver and up to four passengers sharing a vehicle.\";\n    }\n\n    requirement EnableSafeComfortableTravel {\n        text \"The system shall enable users to travel safely and comfortably from the starting point to the destination.\";\n    }\n\n    requirement SimpleSmoothEntryExit {\n        text \"The system shall ensure that users can freely enter and exit the vehicle, and that this process is simple and smooth.\";\n    }\n\n    requirement IntegrateEnvironmentalFactors {\n        text \"The system shall fully consider and integrate surrounding environmental factors to ensure safety and sustainability of the journey.\";\n    }\n\n    requirement InfrastructureCompatibility {\n        text \"The system shall be compatible with related infrastructure such as gas stations.\";\n    }\n\n    requirement HumanCenteredOperation {\n        text \"The system’s operation shall be centered on human needs, focusing on ride experience and various conveniences.\";\n    }\n\n    requirement AssistDailyTransportationTasks {\n        text \"The system shall assist passengers and drivers in smoothly completing all kinds of daily transportation tasks.\";\n    }\n\n    // Satisfy relationships\n    satisfy ProvideConvenientEfficientTransportation by TransportationSystem;\n    satisfy SupportDriverAndPassengers by Vehicle;\n    satisfy EnableSafeComfortableTravel by Vehicle;\n    satisfy SimpleSmoothEntryExit by Vehicle;\n    satisfy IntegrateEnvironmentalFactors by Vehicle;\n    satisfy InfrastructureCompatibility by Infrastructure;\n    satisfy HumanCenteredOperation by UserInterface;\n    satisfy AssistDailyTransportationTasks by UserInterface;\n\n}",
    "package TransportationSystem {\n\n    part Vehicle {\n        attribute maxPassengers: Integer = 4;\n        attribute hasDriver: Boolean;\n        attribute currentPassengers: Integer;\n        attribute fuelLevel: Real;\n        attribute location: Location;\n    }\n\n    part Driver {\n        attribute isInVehicle: Boolean;\n        attribute isOperating: Boolean;\n    }\n\n    part Passenger {\n        attribute isInVehicle: Boolean;\n    }\n\n    part Environment {\n        attribute conditions: String;\n    }\n\n    part GasStation {\n        attribute location: Location;\n    }\n\n    part Location {\n        attribute name: String;\n    }\n\n    requirement ComprehensiveTransportation {\n        text \"The system shall support comprehensive transportation scenarios, enabling a driver and up to four passengers to be safely transported from the starting point to the destination.\"\n    }\n\n    requirement SafeEntryExit {\n        text \"Users shall be able to enter and exit the vehicle safely at the starting point and destination.\"\n    }\n\n    requirement DriverOperation {\n        text \"The driver shall operate the vehicle under the influence of environmental conditions.\"\n    }\n\n    requirement Refueling {\n        text \"The driver may refuel at a gas station as needed to ensure a smooth journey.\"\n    }\n\n    requirement SimpleConvenientInteraction {\n        text \"The system shall ensure that interactions among all participants are simple and convenient, meeting the primary needs of daily transportation.\"\n    }\n\n    usecase TransportationProcess {\n        actor driver: Driver;\n        actor passengers: Passenger[0..4];\n        subject vehicle: Vehicle;\n        subject environment: Environment;\n        subject gasStation: GasStation;\n\n        step EnterVehicle {\n            action \"Driver and passengers enter the vehicle at the starting point.\"\n        }\n        step OperateVehicle {\n            action \"Driver operates the vehicle, considering environmental conditions.\"\n        }\n        step RefuelIfNeeded {\n            action \"Driver refuels at a gas station if fuel is insufficient.\"\n        }\n        step ArriveAtDestination {\n            action \"Vehicle arrives at the destination.\"\n        }\n        step ExitVehicle {\n            action \"Driver and passengers exit the vehicle at the destination.\"\n        }\n    }\n\n    constraint MaxPassengers {\n        expression \"vehicle.currentPassengers <= vehicle.maxPassengers\";\n    }\n\n    constraint HasDriver {\n        expression \"vehicle.hasDriver = true\";\n    }\n\n    satisfies ComprehensiveTransportation by TransportationProcess;\n    satisfies SafeEntryExit by TransportationProcess;\n    satisfies DriverOperation by TransportationProcess;\n    satisfies Refueling by TransportationProcess;\n    satisfies SimpleConvenientInteraction by TransportationProcess;\n\n}",
    "package VehicleConfigurationManagement {\n\n    import sysml::common::*;\n\n    // EngineType enumeration\n    enum EngineType {\n        FourCylinder,\n        SixCylinder\n    }\n\n    // CylinderDiameter enumeration\n    enum CylinderDiameter {\n        Small,   // 70 mm\n        Large    // 100 mm\n    }\n\n    // TransmissionType enumeration\n    enum TransmissionType {\n        Manual,\n        Automatic\n    }\n\n    // Cylinder definition\n    partdef Cylinder {\n        attribute diameter: CylinderDiameter;\n    }\n\n    // Engine definition\n    partdef Engine {\n        attribute type: EngineType;\n        part cylinders: Cylinder[*];\n        constraint engineCylinderCount {\n            if type == EngineType::FourCylinder {\n                cylinders->size() == 4;\n            } else if type == EngineType::SixCylinder {\n                cylinders->size() == 6;\n            }\n        }\n    }\n\n    // Transmission definition\n    partdef Transmission {\n        attribute type: TransmissionType;\n    }\n\n    // Vehicle definition\n    partdef Vehicle {\n        part engine: Engine;\n        part transmission: Transmission;\n\n        // Constraint: Only allowed engine-transmission combinations\n        constraint validEngineTransmissionCombination {\n            (engine.type == EngineType::FourCylinder and transmission.type == TransmissionType::Manual)\n            or\n            (engine.type == EngineType::FourCylinder and transmission.type == TransmissionType::Automatic)\n            or\n            (engine.type == EngineType::SixCylinder and transmission.type == TransmissionType::Automatic);\n        }\n\n        // Constraint: Manual transmission only with four-cylinder engine\n        constraint manualOnlyWithFourCylinder {\n            transmission.type == TransmissionType::Manual implies engine.type == EngineType::FourCylinder;\n        }\n\n        // Constraint: Six-cylinder engine only with automatic transmission\n        constraint sixCylinderOnlyWithAutomatic {\n            engine.type == EngineType::SixCylinder implies transmission.type == TransmissionType::Automatic;\n        }\n    }\n\n    // System definition\n    partdef ConfigurationManagementSystem {\n        part vehicles: Vehicle[*];\n    }\n}",
    "package EngineSystem {\n\n    import ScalarValues::*;\n    import CommonDataTypes::*;\n\n    // Enumeration for CylinderDiameter\n    enum CylinderDiameterEnum {\n        seventy_mm: Real = 70.0;\n        hundred_mm: Real = 100.0;\n    }\n\n    // Cylinder definition\n    partdef Cylinder {\n        attribute diameter: CylinderDiameterEnum;\n    }\n\n    // Engine definition with configurable number of cylinders and diameter\n    partdef Engine {\n        attribute numberOfCylinders: Integer;\n        attribute cylinderDiameter: CylinderDiameterEnum;\n\n        part cylinders: Cylinder [numberOfCylinders] {\n            diameter = cylinderDiameter;\n        }\n    }\n\n    // Four-cylinder engine variant\n    partdef FourCylinderEngine extends Engine {\n        numberOfCylinders = 4;\n    }\n\n    // Six-cylinder engine variant\n    partdef SixCylinderEngine extends Engine {\n        numberOfCylinders = 6;\n    }\n\n    // System context\n    partdef EngineSystemContext {\n        part engine: Engine;\n    }\n}",
    "package AutomotiveConfigurationSpace {\n\n    // Value definitions\n    value CylinderDiameter: Real;\n    value_spec CylinderDiameter70: CylinderDiameter = 70.0;\n    value_spec CylinderDiameter100: CylinderDiameter = 100.0;\n\n    // Engine abstract definition\n    abstract part Engine {\n        attribute numCylinders: Integer;\n        attribute cylinderDiameter: CylinderDiameter;\n    }\n\n    // 4-cylinder engine\n    part FourCylinderEngine extends Engine {\n        numCylinders = 4;\n        constraint cylinderDiameterIsValid {\n            cylinderDiameter == CylinderDiameter70 or\n            cylinderDiameter == CylinderDiameter100;\n        }\n    }\n\n    // 6-cylinder engine\n    part SixCylinderEngine extends Engine {\n        numCylinders = 6;\n        constraint cylinderDiameterIsValid {\n            cylinderDiameter == CylinderDiameter70 or\n            cylinderDiameter == CylinderDiameter100;\n        }\n    }\n\n    // Transmission abstract definition\n    abstract part TransmissionSystem {}\n\n    // Manual transmission\n    part ManualTransmission extends TransmissionSystem {}\n\n    // Automatic transmission\n    part AutomaticTransmission extends TransmissionSystem {}\n\n    // Vehicle definition\n    part Vehicle {\n        attribute engine: Engine;\n        attribute transmission: TransmissionSystem;\n\n        constraint singleEngineType {\n            engine isa FourCylinderEngine or engine isa SixCylinderEngine;\n        }\n        constraint singleTransmissionType {\n            transmission isa ManualTransmission or transmission isa AutomaticTransmission;\n        }\n        constraint engineTransmissionCompatibility {\n            (engine isa FourCylinderEngine and transmission isa ManualTransmission) or\n            (engine isa SixCylinderEngine and transmission isa AutomaticTransmission);\n        }\n    }\n}",
    "package SystemModel {\n\n    // System Assembly Definition\n    part SystemAssembly {\n        part computer: ComputerSubsystem;\n        part storage: StorageSubsystem;\n        part software: SoftwareDesign;\n    }\n\n    // Software Design Section\n    part SoftwareDesign {\n        def messageFormat: MessageFormat;\n        def dataFormat: DataFormat;\n    }\n\n    // Message Format Definition\n    part MessageFormat {\n        // Define message structure here\n    }\n\n    // Data Format Definition\n    part DataFormat {\n        // Define data structure here\n    }\n\n    // Computer Subsystem Definition\n    part ComputerSubsystem {\n        // Computer subsystem integrates all software functions\n        uses software: SoftwareDesign;\n        constraint IntegrateAllSoftwareFunctions {\n            // The computer subsystem must utilize and integrate all software functions\n            software.messageFormat;\n            software.dataFormat;\n        }\n    }\n\n    // Storage Subsystem Definition\n    part StorageSubsystem {\n        // Storage subsystem accesses and is compatible with software formats\n        uses software: SoftwareDesign;\n        constraint AccessAndCompatibility {\n            // The storage subsystem must access and be compatible with message and data formats\n            software.messageFormat;\n            software.dataFormat;\n        }\n    }\n\n    // System Requirements\n    requirement SystemIntegration {\n        text \"The software and hardware of the entire system must work together seamlessly to ensure efficient, reliable, and compliant information storage, transmission, and processing according to required data structure specifications.\";\n    }\n\n    // Satisfy relationships\n    satisfy SystemAssembly -> SystemIntegration;\n    satisfy ComputerSubsystem -> SystemIntegration;\n    satisfy StorageSubsystem -> SystemIntegration;\n    satisfy SoftwareDesign -> SystemIntegration;\n\n}",
    "package powertrain_allocation_management {\n\n    // Requirements\n    requirement EfficientAllocationAndManagement {\n        text \"The system shall achieve efficient allocation and management of the powertrain system.\"\n    }\n\n    requirement PowerAndTorqueProvision {\n        text \"Logical components shall provide power and generate torque.\"\n    }\n\n    requirement TorqueGeneratorFunction {\n        text \"The torque generator shall convert power into torque.\"\n    }\n\n    requirement PhysicalIntegration {\n        text \"Physical components shall integrate power output and torque generation functions.\"\n    }\n\n    requirement MappingLogicalToPhysical {\n        text \"The torque generator in the logical layer shall be mapped to the corresponding power unit in the physical layer.\"\n    }\n\n    requirement FunctionalRealization {\n        text \"All functional requirements shall be realized in the physical hardware.\"\n    }\n\n    requirement PowerPerformance {\n        text \"The system shall ensure power transmission and torque output capabilities to meet user power performance demands.\"\n    }\n\n    // Structure\n    part PowertrainSystem {\n        part logicalLayer: LogicalLayer;\n        part physicalLayer: PhysicalLayer;\n    }\n\n    part LogicalLayer {\n        part torqueGenerator: TorqueGenerator;\n        part otherLogicalComponents: LogicalComponent[0..*];\n    }\n\n    part PhysicalLayer {\n        part powerUnit: PowerUnit;\n        part otherPhysicalComponents: PhysicalComponent[0..*];\n    }\n\n    part TorqueGenerator specializes LogicalComponent {\n        // No additional structure\n    }\n\n    part PowerUnit specializes PhysicalComponent {\n        // No additional structure\n    }\n\n    part LogicalComponent {\n        // Abstract logical component\n    }\n\n    part PhysicalComponent {\n        // Abstract physical component\n    }\n\n    // Functions\n    action ProvidePower {\n        out power: Power;\n    }\n\n    action GenerateTorque {\n        in power: Power;\n        out torque: Torque;\n    }\n\n    // Allocations and Mappings\n    allocation TorqueGeneratorToPowerUnit {\n        from logicalLayer.torqueGenerator;\n        to physicalLayer.powerUnit;\n    }\n\n    // Relationships\n    satisfies PowertrainSystem -> EfficientAllocationAndManagement;\n    satisfies logicalLayer -> PowerAndTorqueProvision;\n    satisfies logicalLayer.torqueGenerator -> TorqueGeneratorFunction;\n    satisfies physicalLayer -> PhysicalIntegration;\n    satisfies TorqueGeneratorToPowerUnit -> MappingLogicalToPhysical;\n    satisfies PowertrainSystem -> FunctionalRealization;\n    satisfies PowertrainSystem -> PowerPerformance;\n\n    // Interfaces\n    interface Power {\n        // Power interface\n    }\n\n    interface Torque {\n        // Torque interface\n    }\n\n    // Usage\n    usage TorqueGenerationUsage {\n        part torqueGen: TorqueGenerator;\n        part powerUnit: PowerUnit;\n\n        connect torqueGen.power -> powerUnit.power;\n        connect torqueGen.torque -> powerUnit.torque;\n    }\n}",
    "package PowerTransmissionSystem {\n\n    // Requirement definition\n    requirement PowerAndTorqueRequirement {\n        text \"The system shall provide power and generate torque to meet practical requirements for power output during vehicle operation.\"\n    }\n\n    // Capabilities\n    capability ProvidePower {}\n    capability GenerateTorque {}\n\n    // Logical Model\n    part System {\n        capabilityref ProvidePower\n        capabilityref GenerateTorque\n        partref PowerTransmissionSystem\n    }\n\n    part PowerTransmissionSystem {\n        capabilityref ProvidePower\n        capabilityref GenerateTorque\n        partref TorqueGenerator\n    }\n\n    part TorqueGenerator {\n        actionref GeneratingTorque\n    }\n\n    action GeneratingTorque {\n        out torque: Real\n        out power: Real\n    }\n\n    // Physical Model\n    part Powertrain {\n        partref Engine\n    }\n\n    part Engine {\n        actionref GeneratingTorque\n    }\n\n    // Allocations\n    allocate TorqueGenerator to Powertrain\n    allocate GeneratingTorque to Engine\n\n    // Satisfy relationships\n    satisfy PowerAndTorqueRequirement by System\n\n}",
    "package VehicleFeatureAnnotationSystem {\n\n    // Feature Annotations\n    annotation SafetyFeature;\n    annotation SecurityFeature;\n\n    // Functions\n    function ProvideSafety;\n    function ProvideSecurity;\n    function ProvideUserConvenience;\n    function ProvidePropertySecurity;\n\n    // Components\n    part Vehicle {\n        part interior: InteriorAssembly;\n        part body: BodyAssembly;\n    }\n\n    part InteriorAssembly {\n        part seatBelts: SeatBelt [1..*] {\n            annotation SafetyFeature;\n            satisfies ProvideSafety;\n        }\n        part frontSeats: FrontSeat [2];\n        part driverAirbag: DriverAirbag {\n            annotation SafetyFeature;\n            satisfies ProvideSafety;\n        }\n        part alarmSystem: AlarmSystem {\n            annotation SecurityFeature;\n            satisfies ProvideSecurity;\n            satisfies ProvidePropertySecurity;\n        }\n    }\n\n    part BodyAssembly {\n        part bodyShell: BodyShell;\n        part bumpers: Bumper [2] {\n            annotation SafetyFeature;\n            satisfies ProvideSafety;\n        }\n        part keylessEntryDevice: KeylessEntryDevice {\n            annotation SecurityFeature;\n            satisfies ProvideSecurity;\n            satisfies ProvideUserConvenience;\n        }\n    }\n\n    // Component Definitions\n    part SeatBelt {\n        annotation SafetyFeature;\n        satisfies ProvideSafety;\n    }\n\n    part FrontSeat;\n\n    part DriverAirbag {\n        annotation SafetyFeature;\n        satisfies ProvideSafety;\n    }\n\n    part AlarmSystem {\n        annotation SecurityFeature;\n        satisfies ProvideSecurity;\n        satisfies ProvidePropertySecurity;\n    }\n\n    part BodyShell;\n\n    part Bumper {\n        annotation SafetyFeature;\n        satisfies ProvideSafety;\n    }\n\n    part KeylessEntryDevice {\n        annotation SecurityFeature;\n        satisfies ProvideSecurity;\n        satisfies ProvideUserConvenience;\n    }\n\n    // Requirements\n    requirement SafetyRequirement {\n        text \"The vehicle shall be equipped with basic safety features such as seat belts, driver airbags, and bumpers.\";\n    }\n\n    requirement SecurityRequirement {\n        text \"The vehicle shall be equipped with security features including anti-theft alarms and keyless entry systems.\";\n    }\n\n    requirement DistributionRequirement {\n        text \"The system must clearly indicate the distribution of these components within the vehicle structure and specify their respective safety or protection functions.\";\n    }\n\n    requirement ComprehensiveRequirement {\n        text \"The system shall comprehensively meet requirements for automotive safety and protection, user convenience, and property security.\";\n    }\n\n    // Satisfy relationships\n    satisfy seatBelts -> SafetyRequirement;\n    satisfy driverAirbag -> SafetyRequirement;\n    satisfy bumpers -> SafetyRequirement;\n    satisfy alarmSystem -> SecurityRequirement;\n    satisfy keylessEntryDevice -> SecurityRequirement;\n    satisfy Vehicle -> DistributionRequirement;\n    satisfy Vehicle -> ComprehensiveRequirement;\n\n}",
    "package VehicleDynamicsSimulation {\n\n    import ModelCenterIntegration;\n\n    requirement AutomatedSimulationAndAnalysis {\n        text \"The system shall be capable of performing automated simulation and analysis of vehicle dynamic behavior.\"\n    }\n\n    requirement UserInputParameters {\n        text \"Users should be able to input the vehicle’s initial velocity, initial position, acceleration at a specific moment, and the time step.\"\n    }\n\n    requirement ModelCenterIntegrationReq {\n        text \"Through integration with the ModelCenter analysis tool, the system shall automatically calculate and output the vehicle’s velocity and position after the specified time step based on the given physical model.\"\n    }\n\n    requirement AccurateDataTransfer {\n        text \"The system must ensure accurate data transfer and reliable output of simulation results.\"\n    }\n\n    requirement ConvenientParameterOutput {\n        text \"The system shall enable users to conveniently obtain key dynamic parameters to support vehicle performance analysis and design optimization.\"\n    }\n\n    part VehicleDynamicsSimulator {\n        feature input initialVelocity: Real;\n        feature input initialPosition: Real;\n        feature input acceleration: Real;\n        feature input timeStep: Real;\n        feature output finalVelocity: Real;\n        feature output finalPosition: Real;\n        feature output simulationResults: SimulationResults;\n        feature uses modelCenter: ModelCenterIntegration::ModelCenterTool;\n    }\n\n    part SimulationResults {\n        feature velocity: Real;\n        feature position: Real;\n    }\n\n    constraint VehicleDynamicsCalculation {\n        parameter initialVelocity: Real;\n        parameter initialPosition: Real;\n        parameter acceleration: Real;\n        parameter timeStep: Real;\n        parameter finalVelocity: Real;\n        parameter finalPosition: Real;\n        expression \"\n            finalVelocity = initialVelocity + acceleration * timeStep;\n            finalPosition = initialPosition + initialVelocity * timeStep + 0.5 * acceleration * timeStep^2;\n        \";\n    }\n\n    usecase PerformAutomatedSimulation {\n        subject VehicleDynamicsSimulator;\n        input initialVelocity;\n        input initialPosition;\n        input acceleration;\n        input timeStep;\n        output simulationResults;\n        includes ModelCenterIntegration::RunAnalysis;\n    }\n\n    satisfy AutomatedSimulationAndAnalysis by VehicleDynamicsSimulator;\n    satisfy UserInputParameters by VehicleDynamicsSimulator;\n    satisfy ModelCenterIntegrationReq by VehicleDynamicsSimulator;\n    satisfy AccurateDataTransfer by VehicleDynamicsSimulator;\n    satisfy ConvenientParameterOutput by VehicleDynamicsSimulator;\n\n}",
    "package CarSafetyComplianceRequirements {\n\n    annotation Safety;\n\n    package SafetyFeatures {\n\n        part seatBelt: SeatBelt @Safety;\n        part driverAirbag: Airbag @Safety;\n        part bumper: Bumper @Safety;\n        part abs: ABS @Safety;\n    }\n\n    package MandatorySafetyFeatures {\n\n        part seatBelt: SeatBelt @Safety (isMandatory=true);\n        part bumper: Bumper @Safety (isMandatory=true);\n    }\n\n    part car: Car {\n        part interior: Interior {\n            part seatBelt1: SeatBelt @Safety (isMandatory=true);\n            part seatBelt2: SeatBelt @Safety (isMandatory=true);\n            part driverAirbag: Airbag @Safety (isMandatory=false); // optional\n        }\n        part body: Body {\n            part bumper: Bumper @Safety (isMandatory=true);\n            part keylessEntry: KeylessEntrySystem (isMandatory=false); // not required\n        }\n        part wheelAssembly: WheelAssembly {\n            part wheel1: Wheel;\n            part wheel2: Wheel;\n            part abs: ABS @Safety (isMandatory=false); // optional\n        }\n    }\n\n    block Car {\n        part interior: Interior;\n        part body: Body;\n        part wheelAssembly: WheelAssembly;\n    }\n\n    block Interior {\n        part seatBelt1: SeatBelt;\n        part seatBelt2: SeatBelt;\n        part driverAirbag: Airbag;\n    }\n\n    block Body {\n        part bumper: Bumper;\n        part keylessEntry: KeylessEntrySystem;\n    }\n\n    block WheelAssembly {\n        part wheel1: Wheel;\n        part wheel2: Wheel;\n        part abs: ABS;\n    }\n\n    block SeatBelt {\n        annotation Safety;\n        property isMandatory: Boolean = true;\n    }\n\n    block Airbag {\n        annotation Safety;\n        property isMandatory: Boolean = false;\n    }\n\n    block Bumper {\n        annotation Safety;\n        property isMandatory: Boolean = true;\n    }\n\n    block ABS {\n        annotation Safety;\n        property isMandatory: Boolean = false;\n    }\n\n    block KeylessEntrySystem {\n        property isMandatory: Boolean = false;\n    }\n\n    block Wheel {\n    }\n}",
    "package VehicleSafetyComplianceSystem {\n\n    // Categories for safety features\n    enum SafetyFeatureType {\n        values: mandatory, optional;\n    }\n\n    // Abstract definition for a safety feature\n    part SafetyFeature {\n        attribute type: SafetyFeatureType;\n        attribute description: String;\n    }\n\n    // Abstract definition for a vehicle component\n    part VehicleComponent {\n        attribute name: String;\n        part safetyFeatures: SafetyFeature[0..*];\n    }\n\n    // Seat Belt as a mandatory safety feature\n    part SeatBelt extends SafetyFeature {\n        type = SafetyFeatureType::mandatory;\n        description = \"Seat belt required by law\";\n    }\n\n    // Airbag as an optional safety feature\n    part Airbag extends SafetyFeature {\n        type = SafetyFeatureType::optional;\n        description = \"Driver's airbag, optional\";\n    }\n\n    // Bumper as a mandatory safety feature\n    part Bumper extends SafetyFeature {\n        type = SafetyFeatureType::mandatory;\n        description = \"Bumper required by law\";\n    }\n\n    // Keyless Entry as an optional configuration\n    part KeylessEntry extends SafetyFeature {\n        type = SafetyFeatureType::optional;\n        description = \"Keyless entry system, optional\";\n    }\n\n    // ABS as an optional safety feature\n    part ABS extends SafetyFeature {\n        type = SafetyFeatureType::optional;\n        description = \"Anti-lock braking system (ABS), optional\";\n    }\n\n    // Tire as a fixed component (not a safety feature per se)\n    part Tire extends VehicleComponent {\n        name = \"Tire\";\n    }\n\n    // Vehicle Interior definition\n    part VehicleInterior extends VehicleComponent {\n        name = \"Vehicle Interior\";\n        part seatBelt1: SeatBelt;\n        part seatBelt2: SeatBelt;\n        // Both seat belts are required\n        safetyFeatures = [seatBelt1, seatBelt2];\n        part airbag: Airbag;\n        // Airbag is optional\n        safetyFeatures += [airbag];\n    }\n\n    // Vehicle Body definition\n    part VehicleBody extends VehicleComponent {\n        name = \"Vehicle Body\";\n        part bumper: Bumper;\n        safetyFeatures = [bumper];\n        part keylessEntry: KeylessEntry;\n        safetyFeatures += [keylessEntry];\n    }\n\n    // Chassis System definition\n    part ChassisSystem extends VehicleComponent {\n        name = \"Chassis System\";\n        part tire1: Tire;\n        part tire2: Tire;\n        part tire3: Tire;\n        part tire4: Tire;\n        // Number of tires is fixed at 4\n        part abs: ABS;\n        safetyFeatures = [abs];\n    }\n\n    // Vehicle definition\n    part Vehicle {\n        part interior: VehicleInterior;\n        part body: VehicleBody;\n        part chassis: ChassisSystem;\n    }\n\n    // System requirement for compliance\n    requirement SafetyCompliance {\n        text = \"All vehicle components must possess corresponding safety features, some of which are mandatory. The system must distinguish between mandatory and optional safety features, ensuring compliance with fundamental safety standards and offering optional safety functions.\";\n    }\n\n    // Traceability relationships\n    satisfy SafetyCompliance by Vehicle;\n\n}",
    "package RiskManagementSystem {\n\n    // Define enumerations for severity levels\n    enum SeverityLevel {\n        Low;\n        Medium;\n        High;\n        Critical;\n    }\n\n    // Define Situation\n    concept Situation {\n        description: String;\n    }\n\n    // Define Cause\n    concept Cause {\n        description: String;\n        probability: Real [0.0..1.0];\n    }\n\n    // Define Failure\n    concept Failure {\n        description: String;\n        severity: SeverityLevel;\n    }\n\n    // Define RiskScenario\n    concept RiskScenario {\n        description: String;\n        situations: Situation[0..*];\n        causes: Cause[0..*];\n        failures: Failure[0..*];\n    }\n\n    // Define CausalRelationship between Situation, Cause, and Failure\n    association CausalRelationship {\n        from situation: Situation;\n        via cause: Cause;\n        to failure: Failure;\n        impactDescription: String;\n    }\n\n    // Define RiskAnalysis function\n    action AnalyzeRisk {\n        input scenario: RiskScenario;\n        output riskAssessment: String;\n    }\n\n    // Define RiskManagementSystem\n    system RiskManagementSystem {\n        scenarios: RiskScenario[0..*];\n        relationships: CausalRelationship[0..*];\n        analyzeRisk: AnalyzeRisk;\n    }\n}",
    "package RiskMetadataModel {\n\n    import sysml::standard;\n\n    // User concept\n    part User;\n\n    // Severity enumeration\n    enum SeverityLevel {\n        Low;\n        Medium;\n        High;\n        Critical;\n    }\n\n    // FailureType concept\n    part FailureType {\n        attribute name: String;\n        attribute description: String;\n        attribute severity: SeverityLevel;\n    }\n\n    // Cause concept\n    part Cause {\n        attribute name: String;\n        attribute description: String;\n        attribute probability: Real [0.0..1.0];\n    }\n\n    // Scenario concept\n    part Scenario {\n        attribute name: String;\n        attribute description: String;\n        owned causes: set of Cause;\n        owned failures: set of FailureType;\n    }\n\n    // Causal relationship between scenarios\n    association ScenarioCausalRelation {\n        end source: Scenario;\n        end target: Scenario;\n        attribute description: String;\n    }\n\n    // RiskScenario: a set of interrelated scenarios, causes, and failures\n    part RiskScenario {\n        attribute name: String;\n        attribute description: String;\n        owned scenarios: set of Scenario;\n        owned causes: set of Cause;\n        owned failures: set of FailureType;\n    }\n\n    // System concept\n    part RiskMetadataSystem {\n        owned users: set of User;\n        owned scenarios: set of Scenario;\n        owned causes: set of Cause;\n        owned failures: set of FailureType;\n        owned riskScenarios: set of RiskScenario;\n        owned scenarioCausalRelations: set of ScenarioCausalRelation;\n        attribute compatibleWithStandardModelingLanguages: Boolean = true;\n    }\n\n}",
    "package EquipmentRiskAnalysis {\n\n    // === Block Definitions ===\n\n    block Equipment {\n        part battery: Battery;\n        part riskAnalyzer: RiskAnalyzer;\n    }\n\n    block Battery {\n        attribute level: Real; // percentage (0..100)\n        attribute isAged: Boolean;\n        attribute failureProbability: Real; // 0..1\n        attribute minThreshold: Real; // minimum allowed level\n    }\n\n    block RiskAnalyzer {\n        reference monitoredBattery: Battery;\n        operation monitorBatteryLevel();\n        operation detectBatteryAging();\n        operation identifyRisk();\n        operation analyzeFailureScenario();\n        operation assignSeverityLevel();\n        operation alertUser();\n    }\n\n    // === States ===\n\n    stateMachine BatteryStateMachine {\n        state Normal;\n        state LowBattery;\n        state ProlongedLowBattery;\n        state DeviceShutdown;\n\n        transition Normal -> LowBattery\n            when (monitoredBattery.level < monitoredBattery.minThreshold);\n\n        transition LowBattery -> ProlongedLowBattery\n            when (durationInState(LowBattery) > prolongedThreshold);\n\n        transition ProlongedLowBattery -> DeviceShutdown\n            when (not recovered);\n\n        transition LowBattery -> Normal\n            when (monitoredBattery.level >= monitoredBattery.minThreshold);\n\n        transition ProlongedLowBattery -> Normal\n            when (monitoredBattery.level >= monitoredBattery.minThreshold);\n    }\n\n    // === Requirements ===\n\n    requirement SystemIdentifiesAndAnalyzesRisks {\n        text \"The system shall identify and analyze potential risks and failure scenarios that may occur in the equipment.\"\n    }\n\n    requirement MonitorBatteryLevel {\n        text \"The system shall continuously monitor the battery level during operation.\"\n    }\n\n    requirement DetectBatteryAging {\n        text \"The system shall detect increased probability of battery failure due to aging or other factors.\"\n    }\n\n    requirement IdentifyBatteryAgingRisk {\n        text \"The system shall identify the risk that battery aging may lead to low battery level.\"\n    }\n\n    requirement DetectLowBatteryState {\n        text \"When the battery level falls below the minimum threshold, the system shall determine that the equipment is in a low battery state and analyze the situation.\"\n    }\n\n    requirement ProlongedLowBatteryShutdown {\n        text \"If the low battery state persists for a prolonged period without recovery, the device may automatically shut down, resulting in device shutdown.\"\n    }\n\n    requirement AssignSeverityLevel {\n        text \"For high-level failures that may interrupt critical device functions, the system shall assign an appropriate severity level to alert users and maintenance personnel.\"\n    }\n\n    requirement EnsureReliableOperation {\n        text \"The system shall ensure reliable operation of the equipment and normal usage needs of the user by enabling timely intervention to mitigate potential risks.\"\n    }\n\n    // === Risk and Failure Scenarios ===\n\n    risk BatteryAgingRisk {\n        description \"Battery aging increases the probability of battery failure, which may lead to low battery level.\"\n        source: Battery.isAged;\n        consequence: LowBatteryState;\n    }\n\n    failure LowBatteryState {\n        description \"Battery level falls below the minimum threshold.\";\n        cause: BatteryAgingRisk;\n        effect: ProlongedLowBatteryState;\n    }\n\n    failure ProlongedLowBatteryState {\n        description \"Low battery state persists for a prolonged period.\";\n        cause: LowBatteryState;\n        effect: DeviceShutdown;\n    }\n\n    failure DeviceShutdown {\n        description \"Device automatically shuts down due to prolonged low battery.\";\n        cause: ProlongedLowBatteryState;\n        effect: InterruptionOfCriticalFunctions;\n    }\n\n    failure InterruptionOfCriticalFunctions {\n        description \"Critical device functions are interrupted.\";\n        severity: SeverityLevel;\n    }\n\n    // === Severity Level Enumeration ===\n\n    enum SeverityLevel {\n        value Low;\n        value Medium;\n        value High;\n        value Critical;\n    }\n\n    // === Relationships ===\n\n    satisfies Equipment -> SystemIdentifiesAndAnalyzesRisks;\n    satisfies RiskAnalyzer -> MonitorBatteryLevel;\n    satisfies RiskAnalyzer -> DetectBatteryAging;\n    satisfies RiskAnalyzer -> IdentifyBatteryAgingRisk;\n    satisfies RiskAnalyzer -> DetectLowBatteryState;\n    satisfies RiskAnalyzer -> ProlongedLowBatteryShutdown;\n    satisfies RiskAnalyzer -> AssignSeverityLevel;\n    satisfies Equipment -> EnsureReliableOperation;\n\n    // === Usage Scenarios ===\n\n    usecase MonitorAndAnalyzeBattery {\n        subject: Equipment;\n        scenario: {\n            riskAnalyzer.monitorBatteryLevel();\n            if (battery.isAged or battery.failureProbability > threshold) {\n                riskAnalyzer.detectBatteryAging();\n                riskAnalyzer.identifyRisk();\n            }\n            if (battery.level < battery.minThreshold) {\n                riskAnalyzer.analyzeFailureScenario();\n                if (durationInState(LowBattery) > prolongedThreshold) {\n                    // Device shutdown\n                }\n            }\n            riskAnalyzer.assignSeverityLevel();\n            riskAnalyzer.alertUser();\n        }\n    }\n\n}",
    "package StructuralDecompositionExample {\n\n    // Capability definition for structural decomposition\n    capability StructuralDecompositionCapability {\n        description \"Capability to explicitly present a top-down hierarchical structure, dividing the system into subsystems and components, ensuring full coverage of functions and capabilities at each level.\"\n    }\n\n    // System definition\n    system System {\n        capability StructuralDecompositionCapability\n        part subsystems: Subsystem[1..*]\n    }\n\n    // Subsystem definition\n    block Subsystem {\n        part components: Component[1..*]\n        // Each subsystem covers its own functions and capabilities\n        satisfies SubsystemFunctionCoverage\n    }\n\n    // Component definition\n    block Component {\n        // Each component covers its own functions and capabilities\n        satisfies ComponentFunctionCoverage\n    }\n\n    // Interface definition between components\n    interface ComponentInterface {\n        description \"Well-defined interface enabling independent understanding, analysis, and effective collaboration between components.\"\n    }\n\n    // Relationships between components via interfaces\n    association ComponentConnection {\n        end source: Component\n        end target: Component\n        end interface: ComponentInterface\n    }\n\n    // Requirements for function and capability coverage at each level\n    requirement SubsystemFunctionCoverage {\n        description \"Each subsystem must fully cover its allocated functions and capabilities.\"\n    }\n\n    requirement ComponentFunctionCoverage {\n        description \"Each component must fully cover its allocated functions and capabilities.\"\n    }\n\n    // Requirement for well-defined interfaces\n    requirement WellDefinedInterfaces {\n        description \"Interfaces between system components must be well defined to enable independent understanding and effective collaboration.\"\n    }\n\n    // Requirement for IV&V support\n    requirement IVVStructuralView {\n        description \"System engineers and IV&V parties must be able to use the structural view to comprehend and verify system integrity and modular design, ensuring all functional and performance requirements are met.\"\n    }\n\n    // Satisfy relationships\n    satisfy SystemSatisfiesIVV {\n        from System\n        to IVVStructuralView\n    }\n\n    satisfy SubsystemSatisfiesInterfaceReq {\n        from Subsystem\n        to WellDefinedInterfaces\n    }\n\n    satisfy ComponentSatisfiesInterfaceReq {\n        from Component\n        to WellDefinedInterfaces\n    }\n}",
    "package AutomotiveSystemArchitecture {\n\n    // Safety attribute enumeration\n    enum SafetyStatus {\n        mandatory,\n        optional,\n        non_safety\n    }\n\n    // Interface definition\n    interface SystemInterface {\n        // Placeholder for interface features\n    }\n\n    // Abstract component definition\n    abstract part Component {\n        attribute name: String;\n        attribute safetyStatus: SafetyStatus = non_safety;\n        port interfaces: SystemInterface[*];\n    }\n\n    // Root system definition\n    part AutomotiveSystem extends Component {\n        name = \"AutomotiveSystem\";\n        safetyStatus = non_safety;\n\n        part subsystems: Subsystem[*];\n    }\n\n    // Subsystem definition\n    part Subsystem extends Component {\n        part components: Component[*];\n    }\n\n    // Safety-related components\n    part SeatBelt extends Component {\n        name = \"SeatBelt\";\n        safetyStatus = mandatory;\n    }\n\n    part Bumper extends Component {\n        name = \"Bumper\";\n        safetyStatus = mandatory;\n    }\n\n    part DriverAirbag extends Component {\n        name = \"DriverAirbag\";\n        safetyStatus = optional;\n    }\n\n    part ABS extends Component {\n        name = \"ABS\";\n        safetyStatus = optional;\n    }\n\n    // Non-safety components\n    part InfotainmentSystem extends Component {\n        name = \"InfotainmentSystem\";\n        safetyStatus = non_safety;\n    }\n\n    part ClimateControl extends Component {\n        name = \"ClimateControl\";\n        safetyStatus = non_safety;\n    }\n\n    part EngineControlUnit extends Component {\n        name = \"EngineControlUnit\";\n        safetyStatus = non_safety;\n    }\n\n    // Example subsystem composition\n    part ChassisSubsystem extends Subsystem {\n        name = \"ChassisSubsystem\";\n        safetyStatus = non_safety;\n\n        part components: Component[2] = {Bumper, ABS};\n    }\n\n    part CabinSubsystem extends Subsystem {\n        name = \"CabinSubsystem\";\n        safetyStatus = non_safety;\n\n        part components: Component[3] = {SeatBelt, DriverAirbag, InfotainmentSystem};\n    }\n\n    part PowertrainSubsystem extends Subsystem {\n        name = \"PowertrainSubsystem\";\n        safetyStatus = non_safety;\n\n        part components: Component[2] = {EngineControlUnit, ClimateControl};\n    }\n\n    // System composition\n    part AutomotiveSystem {\n        part subsystems: Subsystem[3] = {ChassisSubsystem, CabinSubsystem, PowertrainSubsystem};\n    }\n\n    // Views\n\n    // Hierarchical structure tree view\n    view HierarchyTreeView {\n        description = \"Displays the hierarchical structure of all components.\";\n        root = AutomotiveSystem;\n        show parts tree;\n    }\n\n    // Safety components table view\n    view SafetyComponentsTable {\n        description = \"Lists all safety-related components with their mandatory/optional status.\";\n        select c:Component where c.safetyStatus != non_safety;\n        columns = {c.name, c.safetyStatus};\n    }\n\n    // Non-safety components table view\n    view NonSafetyComponentsTable {\n        description = \"Lists all non-safety components.\";\n        select c:Component where c.safetyStatus == non_safety;\n        columns = {c.name};\n    }\n\n    // Safety components tree view\n    view SafetyComponentsTree {\n        description = \"Displays safety-related components in a tree structure.\";\n        root = AutomotiveSystem;\n        show parts tree where part.safetyStatus != non_safety;\n    }\n\n    // Non-safety components tree view\n    view NonSafetyComponentsTree {\n        description = \"Displays non-safety components in a tree structure.\";\n        root = AutomotiveSystem;\n        show parts tree where part.safetyStatus == non_safety;\n    }\n}",
    "// Automotive Domain Fundamental Concepts Model\n// This SysML v2 model provides standardized definitions and annotations for core automotive concepts.\n// All elements include explanatory comments for clarity and extensibility.\n\npackage automotive_domain {\n\n// Core Component: 汽车 (Automobile)\npart definition Automobile {\n    // 汽车 (Automobile) is the primary means of road transportation, designed to carry passengers or cargo.\n    // Alias: 汽车 (Car) is provided for common usage in various contexts.\n    alias: \"汽车 (Car)\";\n    \n    // Key physical characteristics of an automobile\n    attribute torque: Torque;\n    // 扭矩 (Torque) represents the rotational force generated by the automobile's engine or motor.\n}\n\n// Physical Quantity: 扭矩 (Torque)\nvalue definition Torque {\n    // 扭矩 (Torque) is a measure of the rotational force applied to an object, typically measured in newton-meters (N·m).\n    unit: \"N·m\";\n    // Used to characterize the performance of automotive engines and drivetrains.\n}\n\n// Additional extensibility: placeholder for future automotive elements\n// Developers can extend this package with further components, physical quantities, and relationships as needed.\n\n}",
    "package AutomobileDocumentManagementPlatform {\n\n    import StandardPhysicalQuantities::ISQ;\n\n    // Core object: Automobile (alias: Car)\n    concept Automobile {\n        alias: Car;\n        description: \"Represents an automobile; core object for document management.\";\n    }\n\n    // User concept\n    concept User {\n        description: \"A user of the document management platform.\";\n    }\n\n    // Document concept\n    concept Document {\n        description: \"A document containing information related to an Automobile.\";\n        property subject: Automobile;\n        property explanatoryText: String;\n    }\n\n    // Explanatory Document for objects and aliases\n    concept ExplanatoryDocument {\n        description: \"Explanatory document for objects and their aliases.\";\n        property target: Concept;\n        property explanation: String;\n    }\n\n    // Physical Quantity Reference\n    concept PhysicalQuantityReference {\n        description: \"Reference to a standard physical quantity (e.g., TorqueValue under ISQ).\";\n        property quantity: ISQ::PhysicalQuantity;\n    }\n\n    // System\n    system DocumentManagementPlatform {\n        part automobiles: Automobile[*];\n        part users: User[*];\n        part documents: Document[*];\n        part explanatoryDocuments: ExplanatoryDocument[*];\n        part physicalQuantityReferences: PhysicalQuantityReference[*];\n\n        // User operations\n        operation enterInformation(user: User, automobile: Automobile, document: Document);\n        operation queryInformation(user: User, query: String): Document[*];\n        operation archiveInformation(user: User, document: Document);\n        operation addExplanatoryDocument(user: User, target: Concept, explanation: String);\n\n        // Alias support\n        constraint aliasSupport {\n            description: \"The system provides 'Car' as an alias for 'Automobile' for flexible user operations.\";\n            assert Automobile.alias == \"Car\";\n        }\n\n        // Physical quantity compatibility\n        constraint physicalQuantityCompatibility {\n            description: \"The system supports referencing standard physical quantities (e.g., ISQ::TorqueValue).\";\n            assert physicalQuantityReferences.quantity in ISQ::PhysicalQuantity;\n        }\n\n        // Traceability\n        constraint traceability {\n            description: \"All documents and aliases can be annotated and traced via explanatory documents.\";\n            assert explanatoryDocuments.target in {Automobile, Automobile.alias, Document};\n        }\n    }\n}",
    "package Automobiles {\n\n    import ScalarQuantities::*;\n    \n    // Definition of Automobile, with alias \"Car\"\n    part definition Automobile alias Car {\n        // Reference to torque value\n        property torqueValue: TorqueValue alias Torque;\n        // Additional scalar physical quantities can be added as needed\n        property scalarQuantities: ScalarQuantity[0..*];\n    }\n\n    // Definition of TorqueValue, imported or defined as a scalar physical quantity\n    value definition TorqueValue specializes ScalarQuantity {\n        // Unit: Newton meter (N·m)\n        unit: N_m;\n    }\n\n    // ScalarQuantity is assumed to be imported from ScalarQuantities package\n    // Example unit definition for Newton meter\n    unit definition N_m {\n        symbol: \"N·m\";\n        quantityKind: \"torque\";\n    }\n}",
    "package VehicleSystem {\n\n    // Abstract definition of a Cylinder\n    part Cylinder {}\n\n    // Abstract definition of an Engine with a variable number of cylinders\n    part Engine {\n        part cylinders: Cylinder[4..6];\n    }\n\n    // Abstract definition of a Vehicle with an Engine\n    part Vehicle {\n        part engine: Engine;\n    }\n\n    // Specialization for SmallVehicle: engine must have exactly 4 cylinders\n    part SmallVehicle specializes Vehicle {\n        part engine: Engine {\n            part cylinders: Cylinder[4];\n        }\n    }\n\n    // Specialization for LargeVehicle: engine must have exactly 6 cylinders\n    part LargeVehicle specializes Vehicle {\n        part engine: Engine {\n            part cylinders: Cylinder[6];\n        }\n    }\n\n    // Constraint to ensure engine cylinder count matches vehicle size\n    constraint VehicleEngineCylinderConfiguration {\n        // For SmallVehicle, engine.cylinders->size() = 4\n        // For LargeVehicle, engine.cylinders->size() = 6\n        // For standard Vehicle, engine.cylinders->size() in 4..6\n        (self.oclIsKindOf(SmallVehicle) implies self.engine.cylinders->size() = 4) and\n        (self.oclIsKindOf(LargeVehicle) implies self.engine.cylinders->size() = 6) and\n        (self.oclIsKindOf(Vehicle) and not self.oclIsKindOf(SmallVehicle) and not self.oclIsKindOf(LargeVehicle) implies\n            self.engine.cylinders->size() >= 4 and self.engine.cylinders->size() <= 6)\n    }\n\n    // Behavior to automatically configure engine cylinders based on vehicle size\n    behavior AutoConfigureEngineCylinders {\n        input vehicle: Vehicle;\n        output configuredEngine: Engine;\n\n        do {\n            if (vehicle.oclIsKindOf(SmallVehicle)) {\n                configuredEngine.cylinders := Cylinder[4];\n            } else if (vehicle.oclIsKindOf(LargeVehicle)) {\n                configuredEngine.cylinders := Cylinder[6];\n            } else {\n                // Default to 4 cylinders for standard vehicles\n                configuredEngine.cylinders := Cylinder[4];\n            }\n        }\n    }\n}",
    "package FuelManagementSystem {\n\n    part system: System {\n        part fuelTank: FuelTank;\n        part engine: Engine;\n        part fuelSupplyInterface: FuelInterface;\n        part fuelReturnInterface: FuelInterface;\n        part fuelFlowManager: FuelFlowManager;\n        part fuelTemperatureManager: FuelTemperatureManager;\n\n        connect fuelTank.outlet to fuelSupplyInterface.inlet;\n        connect fuelSupplyInterface.outlet to engine.inlet;\n        connect engine.returnOutlet to fuelReturnInterface.inlet;\n        connect fuelReturnInterface.outlet to fuelTank.returnInlet;\n    }\n\n    part FuelTank {\n        port outlet: FuelPort;\n        port returnInlet: FuelPort;\n    }\n\n    part Engine {\n        port inlet: FuelPort;\n        port returnOutlet: FuelPort;\n    }\n\n    part FuelInterface {\n        port inlet: FuelPort;\n        port outlet: FuelPort;\n        attribute standard: String;\n    }\n\n    part FuelFlowManager {\n        reference fuelSupplyInterface: FuelInterface;\n        reference fuelReturnInterface: FuelInterface;\n        operation manageFuelFlow();\n        constraint ensureFuelDelivery {\n            // Ensures fuel can be delivered from tank to engine and supports return\n        }\n        constraint ensureReliabilityAndSafety {\n            // Ensures reliability and safety of fuel flow\n        }\n    }\n\n    part FuelTemperatureManager {\n        reference fuelSupplyInterface: FuelInterface;\n        operation monitorTemperature();\n        operation manageTemperature();\n    }\n\n    interface FuelPort {\n        flow property fuel: Fuel;\n    }\n\n    type Fuel {\n        attribute temperature: Real;\n        attribute pressure: Real;\n        attribute flowRate: Real;\n    }\n}",
    "package VehicleStructuralArchitecture {\n\n    // Vehicle Mass Value Type\n    value type MassValue {\n        unit: kg;\n        base: Real;\n    }\n\n    // Steering Angle Value Type\n    value type SteeringAngleValue {\n        unit: deg;\n        base: Real;\n    }\n\n    // Wheel Definition\n    part definition Wheel {\n        attribute name: String;\n    }\n\n    // Axle Definition\n    part definition Axle {\n        part wheel[2]: Wheel ordered;\n    }\n\n    // Front Axle with Optional Steering\n    part definition FrontAxle extends Axle {\n    }\n\n    part definition SteeringFrontAxle extends FrontAxle {\n        attribute steeringAngle: SteeringAngleValue;\n    }\n\n    // Rear Axle\n    part definition RearAxle extends Axle {\n    }\n\n    // Axle Assembly Definition\n    part definition AxleAssembly {\n        part axle: Axle;\n    }\n\n    // Vehicle Definition\n    part definition Vehicle {\n        attribute mass: MassValue;\n        part frontAxleAssembly: AxleAssembly;\n        part rearAxleAssembly: AxleAssembly;\n    }\n\n    // Specialized Vehicle with Steering Front Axle\n    part definition VehicleWithSteeringFrontAxle extends Vehicle {\n        part frontAxleAssembly: AxleAssembly {\n            axle: SteeringFrontAxle;\n        }\n    }\n\n    // Vehicle with Individually Named Wheels\n    part definition VehicleWithNamedWheels extends Vehicle {\n        part frontAxleAssembly: AxleAssembly {\n            axle: FrontAxle {\n                wheel[2]: Wheel {\n                    name = \"FrontLeft\", \"FrontRight\";\n                }\n            }\n        }\n        part rearAxleAssembly: AxleAssembly {\n            axle: RearAxle {\n                wheel[2]: Wheel {\n                    name = \"RearLeft\", \"RearRight\";\n                }\n            }\n        }\n    }\n\n    // Example Vehicle Instances\n    part vehicle_1750kg: Vehicle {\n        mass = 1750 kg;\n    }\n\n    part vehicle_2000kg: VehicleWithSteeringFrontAxle {\n        mass = 2000 kg;\n        frontAxleAssembly.axle.steeringAngle = 15 deg;\n    }\n\n}"
]