[
    "package 'VehicleManagement' {\n\t// Attribute definitions\n\tattribute def VehicleMass;\n\tattribute def GearSetting;\n\tattribute def AcceleratorPedalPosition;\n\tattribute def EngineStatus;\n\tattribute def DriverStatus;\n\n\t// Port definitions\n\tport def VehicleStatusPort {\n\t\tout gearSetting: GearSetting;\n\t\tout acceleratorPedalPosition: AcceleratorPedalPosition;\n\t}\n\tport def EnginePort {\n\t\tout engineStatus: EngineStatus;\n\t}\n\tport def DriverPort {\n\t\tout driverStatus: DriverStatus;\n\t}\n\n\t// Part definitions\n\tpart def Engine {\n\t\tport enginePort: EnginePort;\n\t\tattribute mass: VehicleMass;\n\t\tperform engineBehavior {\n\t\t\tout engineStatus = enginePort.engineStatus;\n\t\t}\n\t}\n\tpart def Driver {\n\t\tport driverPort: DriverPort;\n\t\tperform driverBehavior {\n\t\t\tout driverStatus = driverPort.driverStatus;\n\t\t}\n\t}\n\tpart def Vehicle {\n\t\tattribute mass: VehicleMass;\n\t\tport statusPort: VehicleStatusPort;\n\t\tpart engine: Engine;\n\t\tpart driver: Driver;\n\t\tperform vehicleBehavior {\n\t\t\tout gearSetting = statusPort.gearSetting;\n\t\t\tout acceleratorPedalPosition = statusPort.acceleratorPedalPosition;\n\t\t}\n\t}\n\n\t// Context for system usage\n\tpart context {\n\t\tpart vehicle: Vehicle;\n\t\tpart engine: Engine;\n\t\tpart driver: Driver;\n\n\t\t// Association: Each vehicle has one engine and can be associated with a driver\n\t\tassociation vehicleToEngine between vehicle.engine and engine;\n\t\tassociation vehicleToDriver between vehicle.driver and driver;\n\t}\n\n\t// Actions for tracking and management\n\taction TrackAndManageVehicle {\n\t\taction trackVehicleStatus {\n\t\t\tin gearSetting: GearSetting;\n\t\t\tin acceleratorPedalPosition: AcceleratorPedalPosition;\n\t\t\tin engineStatus: EngineStatus;\n\t\t\tin driverStatus: DriverStatus;\n\t\t}\n\t}\n\n\t// Support for independent modeling and management\n\tpart def EngineManagement {\n\t\tpart engine: Engine;\n\t\tperform manageEngine {\n\t\t\tin engineStatus = engine.enginePort.engineStatus;\n\t\t}\n\t}\n\tpart def PersonnelManagement {\n\t\tpart driver: Driver;\n\t\tperform manageDriver {\n\t\t\tin driverStatus = driver.driverPort.driverStatus;\n\t\t}\n\t}\n}",
    "package 'VehicleSystem' {\n\ttype def Vehicle;\n\ttype def ManuallyOperatedVehicle specializes Vehicle;\n\ttype def PoweredVehicle specializes Vehicle;\n\ttype def ManuallyOperatedPoweredVehicle specializes ManuallyOperatedVehicle, PoweredVehicle;\n\n\ttype def Personnel;\n\ttype def Engine;\n\n\tpart context {\n\t\tpart personnel: Personnel;\n\t\tpart engine: Engine;\n\n\t\tpart vehicle: Vehicle;\n\n\t\tpart manuallyOperatedVehicle: ManuallyOperatedVehicle {\n\t\t\tref driver: Personnel;\n\t\t}\n\n\t\tpart poweredVehicle: PoweredVehicle {\n\t\t\tref engine: Engine;\n\t\t}\n\n\t\tpart manuallyOperatedPoweredVehicle: ManuallyOperatedPoweredVehicle {\n\t\t\tref driver: Personnel;\n\t\t\tref engine: Engine;\n\t\t}\n\t}\n}",
    "package 'VehicleStructure' {\n\ttype def VehicleComponent;\n\t\n\ttype def Engine specializes VehicleComponent;\n\ttype def Transmission specializes VehicleComponent;\n\ttype def Wheel specializes VehicleComponent;\n\n\tpart def Vehicle {\n\t\tpart engine: Engine;\n\t\tpart transmission: Transmission;\n\t\tpart wheels: Wheel[4];\n\t}\n\n\tpart def VehicleSystem {\n\t\tpart vehicles: Vehicle[*];\n\t}\n\n\t// Extensibility for new vehicle/component types\n\ttype def CustomVehicle specializes Vehicle;\n\ttype def CustomComponent specializes VehicleComponent;\n}",
    "package 'VehicleSystem' {\n\ttype def Cylinder;\n\t\n\tpart def Engine {\n\t\tattribute numCylinders: Integer;\n\t\tpart cylinders: Cylinder[*];\n\t}\n\t\n\tpart def SmallEngine specializes Engine {\n\t\tnumCylinders = 4;\n\t\tpart cylinders: Cylinder[4];\n\t}\n\t\n\tpart def LargeEngine specializes Engine {\n\t\tnumCylinders = 6;\n\t\tpart cylinders: Cylinder[6];\n\t}\n\t\n\tpart def Vehicle {\n\t\tpart engine: Engine;\n\t}\n\t\n\tpart def SmallVehicle specializes Vehicle {\n\t\tpart engine: SmallEngine;\n\t}\n\t\n\tpart def LargeVehicle specializes Vehicle {\n\t\tpart engine: LargeEngine;\n\t}\n\t\n\t// Classification for adaptability and reliability\n\tclassification VehicleType {\n\t\tSmallVehicle;\n\t\tLargeVehicle;\n\t}\n}",
    "package 'TrafficSignalSystem' {\n\tenumeration def TrafficSignalColor {\n\t\tliteral green;\n\t\tliteral yellow;\n\t\tliteral red;\n\t}\n\tattribute def color: TrafficSignalColor;\n\tpart def TrafficSignal {\n\t\tattribute color: TrafficSignalColor;\n\t}\n\tpart def GreenTrafficSignal extends TrafficSignal {\n\t\tattribute color: TrafficSignalColor = TrafficSignalColor::green;\n\t}\n\tpart context {\n\t\tpart trafficSignal: TrafficSignal;\n\t\tpart greenSignal: GreenTrafficSignal;\n\t}\n}",
    "package 'InformationClassificationSystem' {\n\n\t// Information Classification Enumeration\n\tenum def InformationLevel {\n\t\tUnclassified,\n\t\tConfidential,\n\t\tSecret\n\t}\n\n\t// Information Code and Color Mapping\n\tstruct def InformationClassification {\n\t\tlevel: InformationLevel;\n\t\tcode: String;\n\t\tcolor: String;\n\t}\n\n\t// Grade Enumeration\n\tenum def GradeLevel {\n\t\tA,\n\t\tB,\n\t\tC,\n\t\tD,\n\t\tF\n\t}\n\n\t// Grade Score Mapping\n\tstruct def GradeClassification {\n\t\tgrade: GradeLevel;\n\t\tscore: Real;\n\t}\n\n\t// Information Item\n\tpart def InformationItem {\n\t\tclassification: InformationClassification;\n\t\tgrade: GradeClassification;\n\t}\n\n\t// User Interface for Display\n\tpart def UserInterface {\n\t\toperation displayInformation(item: InformationItem);\n\t}\n\n\t// System Context\n\tpart context {\n\t\tpart userInterface: UserInterface;\n\t\tpart informationItem: InformationItem;\n\t}\n\n\t// Classification Definitions\n\tconstant def UnclassifiedClassification: InformationClassification = InformationClassification {\n\t\tlevel = InformationLevel.Unclassified;\n\t\tcode = \"uncl\";\n\t\tcolor = \"green\";\n\t};\n\n\tconstant def ConfidentialClassification: InformationClassification = InformationClassification {\n\t\tlevel = InformationLevel.Confidential;\n\t\tcode = \"conf\";\n\t\tcolor = \"yellow\";\n\t};\n\n\tconstant def SecretClassification: InformationClassification = InformationClassification {\n\t\tlevel = InformationLevel.Secret;\n\t\tcode = \"secr\";\n\t\tcolor = \"red\";\n\t};\n\n\t// Grade Definitions\n\tconstant def GradeA: GradeClassification = GradeClassification {\n\t\tgrade = GradeLevel.A;\n\t\tscore = 4.0;\n\t};\n\n\tconstant def GradeB: GradeClassification = GradeClassification {\n\t\tgrade = GradeLevel.B;\n\t\tscore = 3.0;\n\t};\n\n\tconstant def GradeC: GradeClassification = GradeClassification {\n\t\tgrade = GradeLevel.C;\n\t\tscore = 2.0;\n\t};\n\n\tconstant def GradeD: GradeClassification = GradeClassification {\n\t\tgrade = GradeLevel.D;\n\t\tscore = 1.0;\n\t};\n\n\tconstant def GradeF: GradeClassification = GradeClassification {\n\t\tgrade = GradeLevel.F;\n\t\tscore = 0.0;\n\t};\n\n\t// Action for User Identification\n\taction IdentifyInformationAndGrade {\n\t\tin item: InformationItem;\n\t\tout classification: InformationClassification;\n\t\tout grade: GradeClassification;\n\t}\n\n}",
    "package 'VehicleSystem' {\n\tpart def Cylinder {\n\t\t// Fundamental component of the engine\n\t}\n\t\n\tpart def Engine {\n\t\tattribute cylinderCount: Integer;\n\t\tpart cylinders: Cylinder[cylinderCount];\n\t}\n\t\n\tpart def SmallVehicle {\n\t\tpart engine: Engine {\n\t\t\tcylinderCount = 4;\n\t\t}\n\t}\n\t\n\tpart def LargeVehicle {\n\t\tpart engine: Engine {\n\t\t\tcylinderCount = 6;\n\t\t}\n\t}\n\t\n\tpart context {\n\t\tpart smallVehicle: SmallVehicle;\n\t\tpart largeVehicle: LargeVehicle;\n\t}\n\t\n\tconstraint def EngineCylinderCountRange {\n\t\t// Engine supports 4 to 6 cylinders\n\t\tengine: Engine;\n\t\tengine.cylinderCount >= 4 and engine.cylinderCount <= 6;\n\t}\n}",
    "package 'VehicleModeling' {\n\tattribute def QualityAttribute;\n\tattribute def FuelType;\n\tattribute def BasicInfo;\n\t\n\tpart def Personnel {\n\t\tattribute info: BasicInfo;\n\t}\n\t\n\tpart def Fuel {\n\t\tattribute type: FuelType;\n\t\tattribute info: BasicInfo;\n\t}\n\t\n\tpart def FuelTank {\n\t\tattribute fuelType: FuelType;\n\t\trefuelable fuel: Fuel;\n\t}\n\t\n\tpart def Driver {\n\t\tattribute info: BasicInfo;\n\t}\n\t\n\tpart def Vehicle {\n\t\tattribute qualityAttributes: QualityAttribute[];\n\t\tpart driver: Driver;\n\t\tpart fuelTank: FuelTank;\n\t}\n\t\n\tpart context {\n\t\tpart personnel: Personnel[];\n\t\tpart fuels: Fuel[];\n\t\tpart vehicles: Vehicle[];\n\t}\n\t\n\tassociation VehicleHasDriver between Vehicle and Driver {\n\t\tends vehicle: Vehicle, driver: Driver;\n\t}\n\t\n\tassociation VehicleHasFuelTank between Vehicle and FuelTank {\n\t\tends vehicle: Vehicle, fuelTank: FuelTank;\n\t}\n\t\n\tassociation FuelTankStoresFuel between FuelTank and Fuel {\n\t\tends fuelTank: FuelTank, fuel: Fuel;\n\t}\n\t\n\tassociation PersonnelInfo between Personnel and BasicInfo {\n\t\tends personnel: Personnel, info: BasicInfo;\n\t}\n\t\n\tassociation FuelInfo between Fuel and BasicInfo {\n\t\tends fuel: Fuel, info: BasicInfo;\n\t}\n}",
    "package 'AutomobileWheelAssembly' {\n\tpart def WheelAssembly {\n\t\tpart bearingUnit: WheelBearingUnit;\n\t\tpart tire: Tire;\n\t\tpart hub: Hub;\n\t\tpart rim: Rim[2];\n\t\tpart boltMountingHole: BoltMountingHole[pattern=multiple];\n\t\tpart threadedHole: ThreadedHole[pattern=multiple];\n\t\tpart boltConnection: BoltConnection[pattern=multiple];\n\n\t\t// Tire beads interface with rims\n\t\trelates tireBeadToRim: TireBeadToRimRelation {\n\t\t\tsource: tire.bead[2];\n\t\t\ttarget: rim[2];\n\t\t}\n\n\t\t// Rims are mounted on hub\n\t\trelates rimToHub: RimToHubRelation {\n\t\t\tsource: rim[2];\n\t\t\ttarget: hub;\n\t\t}\n\n\t\t// Hub has multiple mounting holes\n\t\trelates hubToMountingHoles: HubToMountingHoleRelation {\n\t\t\tsource: hub;\n\t\t\ttarget: boltMountingHole[*];\n\t\t}\n\n\t\t// Mounting holes connect to threaded holes via bolts\n\t\trelates mountingHoleToThreadedHole: MountingHoleToThreadedHoleRelation {\n\t\t\tsource: boltMountingHole[*];\n\t\t\ttarget: threadedHole[*];\n\t\t\tvia: boltConnection[*];\n\t\t}\n\n\t\t// Hub and bearing unit interface\n\t\trelates hubToBearingUnit: HubToBearingUnitRelation {\n\t\t\tsource: hub;\n\t\t\ttarget: bearingUnit;\n\t\t}\n\t}\n\n\tpart def WheelBearingUnit {}\n\n\tpart def Tire {\n\t\tpart bead: Bead[2];\n\t}\n\n\tpart def Bead {}\n\n\tpart def Hub {}\n\n\tpart def Rim {}\n\n\tpart def BoltMountingHole {}\n\n\tpart def ThreadedHole {}\n\n\tpart def BoltConnection {}\n\n\tassociation TireBeadToRimRelation {\n\t\tend bead: Bead[2];\n\t\tend rim: Rim[2];\n\t}\n\n\tassociation RimToHubRelation {\n\t\tend rim: Rim[2];\n\t\tend hub: Hub;\n\t}\n\n\tassociation HubToMountingHoleRelation {\n\t\tend hub: Hub;\n\t\tend mountingHole: BoltMountingHole[*];\n\t}\n\n\tassociation MountingHoleToThreadedHoleRelation {\n\t\tend mountingHole: BoltMountingHole[*];\n\t\tend threadedHole: ThreadedHole[*];\n\t\tend bolt: BoltConnection[*];\n\t}\n\n\tassociation HubToBearingUnitRelation {\n\t\tend hub: Hub;\n\t\tend bearingUnit: WheelBearingUnit;\n\t}\n}",
    "package 'FuelManagementSystem' {\n\tattribute def Fuel;\n\tattribute def FuelFlow;\n\tattribute def Temperature;\n\tattribute def FuelStatusData;\n\n\tport def FuelSupplyPort {\n\t\tout fuelFlow: FuelFlow;\n\t}\n\tport def FuelReturnPort {\n\t\tin fuelFlow: FuelFlow;\n\t}\n\tport def TemperaturePort {\n\t\tout temperature: Temperature;\n\t}\n\tport def StatusDataPort {\n\t\tout statusData: FuelStatusData;\n\t}\n\n\tpart context {\n\t\tpart fuelTankAssembly {\n\t\t\tport supplyPort: FuelSupplyPort;\n\t\t\tport returnPort: FuelReturnPort;\n\t\t\tport tempPort: TemperaturePort;\n\t\t\tperform manageFuel.supplyFuel {\n\t\t\t\tout fuelFlow = supplyPort.fuelFlow;\n\t\t\t}\n\t\t\tperform manageFuel.receiveReturnFuel {\n\t\t\t\tin fuelFlow = returnPort.fuelFlow;\n\t\t\t}\n\t\t\tperform manageFuel.detectTemperature {\n\t\t\t\tout temperature = tempPort.temperature;\n\t\t\t}\n\t\t}\n\t\tpart engine {\n\t\t\tport supplyPort: ~FuelSupplyPort;\n\t\t\tport returnPort: ~FuelReturnPort;\n\t\t\tport tempPort: ~TemperaturePort;\n\t\t\tperform manageFuel.consumeFuel {\n\t\t\t\tin fuelFlow = supplyPort.fuelFlow;\n\t\t\t\tout fuelFlow = returnPort.fuelFlow;\n\t\t\t}\n\t\t\tperform manageFuel.monitorTemperature {\n\t\t\t\tin temperature = tempPort.temperature;\n\t\t\t}\n\t\t}\n\t\tpart user {\n\t\t\tport statusPort: StatusDataPort;\n\t\t\tperform manageFuel.visualizeStatus {\n\t\t\t\tout statusData = statusPort.statusData;\n\t\t\t}\n\t\t}\n\t\tinterface tankToEngine connect fuelTankAssembly.supplyPort to engine.supplyPort {\n\t\t\tref flow references manageFuel.supplyFlow\n\t\t\t\tfrom source.fuelFlow to target.fuelFlow;\n\t\t}\n\t\tinterface engineToTank connect engine.returnPort to fuelTankAssembly.returnPort {\n\t\t\tref flow references manageFuel.returnFlow\n\t\t\t\tfrom source.fuelFlow to target.fuelFlow;\n\t\t}\n\t\tinterface tempAtInterface connect fuelTankAssembly.tempPort to engine.tempPort {\n\t\t\tref flow references manageFuel.tempFlow\n\t\t\t\tfrom source.temperature to target.temperature;\n\t\t}\n\t\tinterface statusToUser connect manageFuel.statusDataPort to user.statusPort {\n\t\t\tref flow references manageFuel.statusFlow\n\t\t\t\tfrom source.statusData to target.statusData;\n\t\t}\n\t}\n\n\taction manageFuel {\n\t\taction supplyFuel { out fuelFlow: FuelFlow; }\n\t\taction receiveReturnFuel { in fuelFlow: FuelFlow; }\n\t\taction detectTemperature { out temperature: Temperature; }\n\t\taction consumeFuel { in fuelFlow: FuelFlow; out fuelFlow: FuelFlow; }\n\t\taction monitorTemperature { in temperature: Temperature; }\n\t\taction visualizeStatus { out statusData: FuelStatusData; }\n\n\t\tsuccession flow supplyFlow from supplyFuel.fuelFlow to consumeFuel.fuelFlow;\n\t\tsuccession flow returnFlow from consumeFuel.fuelFlow to receiveReturnFuel.fuelFlow;\n\t\tsuccession flow tempFlow from detectTemperature.temperature to monitorTemperature.temperature;\n\t\tsuccession flow statusFlow from visualizeStatus.statusData to statusToUser.statusData;\n\t}\n}",
    "package 'VehicleConfiguration' {\n\n\t// Attribute definitions\n\tattribute def Mass : Real;\n\tattribute def SteeringAngle : Real;\n\n\t// Tire definition\n\tpart def Tire {\n\t\tattribute mass: Mass;\n\t}\n\n\t// Axle definitions\n\tpart def Axle {\n\t\tattribute mass: Mass;\n\t\tordered part tires: Tire[2];\n\t}\n\n\tpart def FrontAxle extends Axle {\n\t}\n\n\tpart def RearAxle extends Axle {\n\t}\n\n\tpart def SteeringFrontAxle extends FrontAxle {\n\t\tattribute steeringAngle: SteeringAngle;\n\t}\n\n\t// Vehicle definition\n\tpart def Vehicle {\n\t\tattribute mass: Mass = 1750.0;\n\t\tpart frontAxle: FrontAxle;\n\t\tpart rearAxle: RearAxle;\n\t}\n\n\t// Variant: vehicle1_c1\n\tpart def Vehicle1_C1 extends Vehicle {\n\t\tattribute mass: Mass = 2000.0;\n\t\tpart frontAxle: SteeringFrontAxle;\n\t}\n\n\t// Example of explicit instance naming and management\n\tpart def CustomFrontAxle extends SteeringFrontAxle {\n\t\tattribute mass: Mass = 150.0;\n\t\tattribute steeringAngle: SteeringAngle = 30.0;\n\t\tordered part tires: Tire[2];\n\t}\n\n\tpart def CustomRearAxle extends RearAxle {\n\t\tattribute mass: Mass = 140.0;\n\t\tordered part tires: Tire[2];\n\t}\n\n\tpart def CustomTireFrontLeft extends Tire {\n\t\tattribute mass: Mass = 12.0;\n\t}\n\n\tpart def CustomTireFrontRight extends Tire {\n\t\tattribute mass: Mass = 12.0;\n\t}\n\n\tpart def CustomTireRearLeft extends Tire {\n\t\tattribute mass: Mass = 13.0;\n\t}\n\n\tpart def CustomTireRearRight extends Tire {\n\t\tattribute mass: Mass = 13.0;\n\t}\n\n\t// Example vehicle instance with custom components\n\tpart def Vehicle1_Instance extends Vehicle1_C1 {\n\t\tpart frontAxle: CustomFrontAxle {\n\t\t\ttires[1]: CustomTireFrontLeft;\n\t\t\ttires[2]: CustomTireFrontRight;\n\t\t}\n\t\tpart rearAxle: CustomRearAxle {\n\t\t\ttires[1]: CustomTireRearLeft;\n\t\t\ttires[2]: CustomTireRearRight;\n\t\t}\n\t}\n\n}",
    "package 'VehicleTrailerCoupling' {\n\tpart def Vehicle {\n\t\tport hitchRef: HitchRefPort;\n\t}\n\tpart def Trailer {\n\t\tport connectorRef: ConnectorRefPort;\n\t}\n\tpart def Hitch {\n\t\tport ball: BallPort;\n\t\tport connector: ConnectorPort;\n\t}\n\tport def HitchRefPort {\n\t\tref hitch: Hitch;\n\t}\n\tport def ConnectorRefPort {\n\t\tref connector: ConnectorPort;\n\t}\n\tport def BallPort {}\n\tport def ConnectorPort {}\n\n\tpart context {\n\t\tpart vehicle: Vehicle;\n\t\tpart trailer: Trailer;\n\t\tpart hitch: Hitch;\n\n\t\t// Vehicle references the hitch (not a built-in ball)\n\t\tvehicle.hitchRef.hitch = hitch;\n\n\t\t// Trailer references the connector in the hitch\n\t\ttrailer.connectorRef.connector = hitch.connector;\n\n\t\t// Physical connection between hitch ball and trailer connector\n\t\tinterface hitchBallToTrailerConnector connect hitch.ball to hitch.connector {}\n\n\t\t// Modularity: all parts can be independently detached\n\t\t// (No direct dependencies between vehicle and trailer except via hitch)\n\t}\n}",
    "package 'VehiclePowerTransmissionSystem' {\n\n\t// Attribute definitions\n\tattribute def FuelCmd;\n\tattribute def Power;\n\tattribute def ClutchCmd;\n\tattribute def RoadContact;\n\n\t// Port definitions\n\tport def FuelCmdPort {\n\t\tin fuelCmd: FuelCmd;\n\t}\n\tport def PowerPort {\n\t\tinout power: Power;\n\t}\n\tport def ClutchPort {\n\t\tin clutchCmd: ClutchCmd;\n\t}\n\tport def RoadContactPort {\n\t\tout roadContact: RoadContact;\n\t}\n\n\t// Main system context\n\tpart context {\n\t\tpart engine {\n\t\t\tport fuelCmdPort: FuelCmdPort;\n\t\t\tport powerOut: PowerPort;\n\t\t\tport clutchPort: ClutchPort;\n\t\t\tperform powerTransmission.receiveFuelCmd {\n\t\t\t\tin fuelCmd = fuelCmdPort.fuelCmd;\n\t\t\t}\n\t\t\tperform powerTransmission.producePower {\n\t\t\t\tin fuelCmd = fuelCmdPort.fuelCmd;\n\t\t\t\tout power = powerOut.power;\n\t\t\t}\n\t\t}\n\t\tpart clutch {\n\t\t\tport clutchCmdPort: ClutchPort;\n\t\t\tport powerIn: PowerPort;\n\t\t\tport powerOut: PowerPort;\n\t\t\tperform powerTransmission.receiveClutchCmd {\n\t\t\t\tin clutchCmd = clutchCmdPort.clutchCmd;\n\t\t\t}\n\t\t\tperform powerTransmission.transmitPowerClutch {\n\t\t\t\tin power = powerIn.power;\n\t\t\t\tin clutchCmd = clutchCmdPort.clutchCmd;\n\t\t\t\tout power = powerOut.power;\n\t\t\t}\n\t\t}\n\t\tpart transmission {\n\t\t\tport powerIn: PowerPort;\n\t\t\tport powerOut: PowerPort;\n\t\t\tperform powerTransmission.transmitPowerTransmission {\n\t\t\t\tin power = powerIn.power;\n\t\t\t\tout power = powerOut.power;\n\t\t\t}\n\t\t}\n\t\tpart driveshaft {\n\t\t\tport powerIn: PowerPort;\n\t\t\tport powerOut: PowerPort;\n\t\t\tperform powerTransmission.transmitPowerDriveshaft {\n\t\t\t\tin power = powerIn.power;\n\t\t\t\tout power = powerOut.power;\n\t\t\t}\n\t\t}\n\t\tpart rearAxleAssembly {\n\t\t\tport powerIn: PowerPort;\n\t\t\tpart differential {\n\t\t\t\tport powerIn: PowerPort;\n\t\t\t\tport leftOut: PowerPort;\n\t\t\t\tport rightOut: PowerPort;\n\t\t\t\tperform powerTransmission.splitPowerDifferential {\n\t\t\t\t\tin power = powerIn.power;\n\t\t\t\t\tout leftPower = leftOut.power;\n\t\t\t\t\tout rightPower = rightOut.power;\n\t\t\t\t}\n\t\t\t}\n\t\t\tpart leftHalfShaft {\n\t\t\t\tport powerIn: PowerPort;\n\t\t\t\tport powerOut: PowerPort;\n\t\t\t\tperform powerTransmission.transmitPowerHalfShaft {\n\t\t\t\t\tin power = powerIn.power;\n\t\t\t\t\tout power = powerOut.power;\n\t\t\t\t}\n\t\t\t}\n\t\t\tpart rightHalfShaft {\n\t\t\t\tport powerIn: PowerPort;\n\t\t\t\tport powerOut: PowerPort;\n\t\t\t\tperform powerTransmission.transmitPowerHalfShaft {\n\t\t\t\t\tin power = powerIn.power;\n\t\t\t\t\tout power = powerOut.power;\n\t\t\t\t}\n\t\t\t}\n\t\t\t// Connect differential to half-shafts\n\t\t\tinterface diffToLeftHalf connect differential.leftOut to leftHalfShaft.powerIn {\n\t\t\t\tref flow references powerTransmission.leftDiffFlow\n\t\t\t\t\tfrom source.leftOut to target.powerIn;\n\t\t\t}\n\t\t\tinterface diffToRightHalf connect differential.rightOut to rightHalfShaft.powerIn {\n\t\t\t\tref flow references powerTransmission.rightDiffFlow\n\t\t\t\t\tfrom source.rightOut to target.powerIn;\n\t\t\t}\n\t\t}\n\t\tpart leftRearWheel {\n\t\t\tport powerIn: PowerPort;\n\t\t\tport roadContactPort: RoadContactPort;\n\t\t\tperform powerTransmission.transmitPowerWheel {\n\t\t\t\tin power = powerIn.power;\n\t\t\t\tout roadContact = roadContactPort.roadContact;\n\t\t\t}\n\t\t}\n\t\tpart rightRearWheel {\n\t\t\tport powerIn: PowerPort;\n\t\t\tport roadContactPort: RoadContactPort;\n\t\t\tperform powerTransmission.transmitPowerWheel {\n\t\t\t\tin power = powerIn.power;\n\t\t\t\tout roadContact = roadContactPort.roadContact;\n\t\t\t}\n\t\t}\n\t\tpart road {\n\t\t\tport leftContact: RoadContactPort;\n\t\t\tport rightContact: RoadContactPort;\n\t\t\tperform powerTransmission.receiveRoadContact {\n\t\t\t\tin leftContact = leftContact.roadContact;\n\t\t\t\tin rightContact = rightContact.roadContact;\n\t\t\t}\n\t\t}\n\n\t\t// Interfaces between components\n\t\tinterface engineToClutch connect engine.powerOut to clutch.powerIn {\n\t\t\tref flow references powerTransmission.engineClutchFlow\n\t\t\t\tfrom source.powerOut to target.powerIn;\n\t\t}\n\t\tinterface clutchToTransmission connect clutch.powerOut to transmission.powerIn {\n\t\t\tref flow references powerTransmission.clutchTransFlow\n\t\t\t\tfrom source.powerOut to target.powerIn;\n\t\t}\n\t\tinterface transmissionToDriveshaft connect transmission.powerOut to driveshaft.powerIn {\n\t\t\tref flow references powerTransmission.transDriveshaftFlow\n\t\t\t\tfrom source.powerOut to target.powerIn;\n\t\t}\n\t\tinterface driveshaftToRearAxle connect driveshaft.powerOut to rearAxleAssembly.powerIn {\n\t\t\tref flow references powerTransmission.driveshaftAxleFlow\n\t\t\t\tfrom source.powerOut to target.powerIn;\n\t\t}\n\t\tinterface leftHalfShaftToWheel connect rearAxleAssembly.leftHalfShaft.powerOut to leftRearWheel.powerIn {\n\t\t\tref flow references powerTransmission.leftShaftWheelFlow\n\t\t\t\tfrom source.powerOut to target.powerIn;\n\t\t}\n\t\tinterface rightHalfShaftToWheel connect rearAxleAssembly.rightHalfShaft.powerOut to rightRearWheel.powerIn {\n\t\t\tref flow references powerTransmission.rightShaftWheelFlow\n\t\t\t\tfrom source.powerOut to target.powerIn;\n\t\t}\n\t\tinterface leftWheelToRoad connect leftRearWheel.roadContactPort to road.leftContact {\n\t\t\tref flow references powerTransmission.leftWheelRoadFlow\n\t\t\t\tfrom source.roadContactPort to target.leftContact;\n\t\t}\n\t\tinterface rightWheelToRoad connect rightRearWheel.roadContactPort to road.rightContact {\n\t\t\tref flow references powerTransmission.rightWheelRoadFlow\n\t\t\t\tfrom source.roadContactPort to target.rightContact;\n\t\t}\n\t}\n\n\t// Action definitions and flows\n\taction powerTransmission {\n\t\taction receiveFuelCmd { in fuelCmd: FuelCmd; }\n\t\taction producePower { in fuelCmd: FuelCmd; out power: Power; }\n\t\tsuccession flow engineClutchFlow from producePower.power to transmitPowerClutch.power;\n\t\taction receiveClutchCmd { in clutchCmd: ClutchCmd; }\n\t\taction transmitPowerClutch { in power: Power; in clutchCmd: ClutchCmd; out power: Power; }\n\t\tsuccession flow clutchTransFlow from transmitPowerClutch.power to transmitPowerTransmission.power;\n\t\taction transmitPowerTransmission { in power: Power; out power: Power; }\n\t\tsuccession flow transDriveshaftFlow from transmitPowerTransmission.power to transmitPowerDriveshaft.power;\n\t\taction transmitPowerDriveshaft { in power: Power; out power: Power; }\n\t\tsuccession flow driveshaftAxleFlow from transmitPowerDriveshaft.power to splitPowerDifferential.power;\n\t\taction splitPowerDifferential { in power: Power; out leftPower: Power; out rightPower: Power; }\n\t\tsuccession flow leftDiffFlow from splitPowerDifferential.leftPower to transmitPowerHalfShaft.power;\n\t\tsuccession flow rightDiffFlow from splitPowerDifferential.rightPower to transmitPowerHalfShaft.power;\n\t\taction transmitPowerHalfShaft { in power: Power; out power: Power; }\n\t\tsuccession flow leftShaftWheelFlow from transmitPowerHalfShaft.power to transmitPowerWheel.power;\n\t\tsuccession flow rightShaftWheelFlow from transmitPowerHalfShaft.power to transmitPowerWheel.power;\n\t\taction transmitPowerWheel { in power: Power; out roadContact: RoadContact; }\n\t\tsuccession flow leftWheelRoadFlow from transmitPowerWheel.roadContact to receiveRoadContact.leftContact;\n\t\tsuccession flow rightWheelRoadFlow from transmitPowerWheel.roadContact to receiveRoadContact.rightContact;\n\t\taction receiveRoadContact { in leftContact: RoadContact; in rightContact: RoadContact; }\n\t}\n}",
    "package 'IntegratedManagementSystem' {\n\n\tinterface pe;\n\tinterface pf;\n\n\tport def pePort {\n\t\tfeature pe: pe;\n\t}\n\tport def pfPort {\n\t\tfeature pf: pf;\n\t}\n\tport def pbPort {\n\t\tfeature pe: pe;\n\t}\n\tport def pdPort {\n\t\tfeature pf: pf;\n\t}\n\tport def signalPort {\n\t\tout signal: Signal;\n\t\tin signal: Signal;\n\t}\n\n\tpart def c1 {\n\t\tport pb: pbPort;\n\t\tport sig: signalPort;\n\t}\n\tpart def c2 {\n\t\tport sig: signalPort;\n\t}\n\tpart def c3 {\n\t\tport pd: pdPort;\n\t\tport sig: signalPort;\n\t}\n\tpart def c4 {\n\t\tport sig: signalPort;\n\t}\n\n\tpart def b11 {\n\t\tpart c1: c1;\n\t\tpart c2: c2;\n\t\t// Signal connection between c1 and c2\n\t\tconnector c1_c2_signal {\n\t\t\tend c1.sig;\n\t\t\tend c2.sig;\n\t\t}\n\t\t// Interface pe bound to pb port of c1\n\t\tbind pe to c1.pb.pe;\n\t}\n\tpart def b12 {\n\t\tpart c3: c3;\n\t\tpart c4: c4;\n\t\t// Signal connection between c3 and c4\n\t\tconnector c3_c4_signal {\n\t\t\tend c3.sig;\n\t\t\tend c4.sig;\n\t\t}\n\t\t// Interface pf bound to pd port of c3\n\t\tbind pf to c3.pd.pf;\n\t}\n\t// Communication between b11 and b12 via pe and pf\n\tconnector b11_b12_comm {\n\t\tend b11.c1.pb.pe;\n\t\tend b12.c3.pd.pf;\n\t}\n\n\t// Second decomposition: modules b21 and b22 reuse c1, c2, c3, c4\n\tpart def b21 {\n\t\tref c1: c1;\n\t\tref c2: c2;\n\t\t// Reorganized signal connection\n\t\tconnector c1_c2_signal {\n\t\t\tend c1.sig;\n\t\t\tend c2.sig;\n\t\t}\n\t}\n\tpart def b22 {\n\t\tref c3: c3;\n\t\tref c4: c4;\n\t\t// Reorganized signal connection\n\t\tconnector c3_c4_signal {\n\t\t\tend c3.sig;\n\t\t\tend c4.sig;\n\t\t}\n\t}\n\n\t// Top-level system context\n\tpart context {\n\t\tpart b11: b11;\n\t\tpart b12: b12;\n\t\tpart b21: b21;\n\t\tpart b22: b22;\n\t\t// Share c-level components between b21 and b22\n\t\tshare c1: c1 between b11.c1 and b21.c1;\n\t\tshare c2: c2 between b11.c2 and b21.c2;\n\t\tshare c3: c3 between b12.c3 and b22.c3;\n\t\tshare c4: c4 between b12.c4 and b22.c4;\n\t}\n}",
    "package 'AutomotivePowertrain' {\n\tattribute def FuelCmd;\n\tattribute def StartStopCmd;\n\tattribute def EngineTorque;\n\tattribute def TransmissionTorque;\n\tattribute def DriveshaftTorque;\n\tattribute def WheelTorque;\n\n\tport def FuelCmdPort {\n\t\tout fuelCmd: FuelCmd;\n\t}\n\tport def StartStopCmdPort {\n\t\tout startStopCmd: StartStopCmd;\n\t}\n\tport def EngineTorquePort {\n\t\tout engineTorque: EngineTorque;\n\t}\n\tport def TransmissionTorquePort {\n\t\tout transmissionTorque: TransmissionTorque;\n\t}\n\tport def DriveshaftTorquePort {\n\t\tout driveshaftTorque: DriveshaftTorque;\n\t}\n\tport def WheelTorquePort {\n\t\tout wheelTorque: WheelTorque;\n\t}\n\n\tpart context {\n\t\tpart user {\n\t\t\tport fuelCmdPort: FuelCmdPort;\n\t\t\tport startStopCmdPort: StartStopCmdPort;\n\t\t\tperform controlPowertrain.sendFuelCmd {\n\t\t\t\tout fuelCmd = fuelCmdPort.fuelCmd;\n\t\t\t}\n\t\t\tperform controlPowertrain.sendStartStopCmd {\n\t\t\t\tout startStopCmd = startStopCmdPort.startStopCmd;\n\t\t\t}\n\t\t}\n\t\tpart engine {\n\t\t\tport fuelCmdPort: ~FuelCmdPort;\n\t\t\tport startStopCmdPort: ~StartStopCmdPort;\n\t\t\tport engineTorquePort: EngineTorquePort;\n\t\t\tperform controlPowertrain.generateEngineTorque {\n\t\t\t\tin fuelCmd = fuelCmdPort.fuelCmd;\n\t\t\t\tin startStopCmd = startStopCmdPort.startStopCmd;\n\t\t\t\tout engineTorque = engineTorquePort.engineTorque;\n\t\t\t}\n\t\t}\n\t\tpart transmission {\n\t\t\tport engineTorquePort: ~EngineTorquePort;\n\t\t\tport transmissionTorquePort: TransmissionTorquePort;\n\t\t\tperform controlPowertrain.amplifyTorque {\n\t\t\t\tin engineTorque = engineTorquePort.engineTorque;\n\t\t\t\tout transmissionTorque = transmissionTorquePort.transmissionTorque;\n\t\t\t}\n\t\t}\n\t\tpart driveshaft {\n\t\t\tport transmissionTorquePort: ~TransmissionTorquePort;\n\t\t\tport driveshaftTorquePort: DriveshaftTorquePort;\n\t\t\tperform controlPowertrain.transmitTorque {\n\t\t\t\tin transmissionTorque = transmissionTorquePort.transmissionTorque;\n\t\t\t\tout driveshaftTorque = driveshaftTorquePort.driveshaftTorque;\n\t\t\t}\n\t\t}\n\t\tpart wheelAssembly {\n\t\t\tport driveshaftTorquePort: ~DriveshaftTorquePort;\n\t\t\tport wheelTorquePort: WheelTorquePort;\n\t\t\tperform controlPowertrain.distributeTorque {\n\t\t\t\tin driveshaftTorque = driveshaftTorquePort.driveshaftTorque;\n\t\t\t\tout wheelTorque = wheelTorquePort.wheelTorque;\n\t\t\t}\n\t\t}\n\t}\n\n\taction controlPowertrain {\n\t\taction sendFuelCmd { out fuelCmd: FuelCmd; }\n\t\taction sendStartStopCmd { out startStopCmd: StartStopCmd; }\n\t\taction generateEngineTorque {\n\t\t\tin fuelCmd: FuelCmd;\n\t\t\tin startStopCmd: StartStopCmd;\n\t\t\tout engineTorque: EngineTorque;\n\t\t}\n\t\taction amplifyTorque {\n\t\t\tin engineTorque: EngineTorque;\n\t\t\tout transmissionTorque: TransmissionTorque;\n\t\t}\n\t\taction transmitTorque {\n\t\t\tin transmissionTorque: TransmissionTorque;\n\t\t\tout driveshaftTorque: DriveshaftTorque;\n\t\t}\n\t\taction distributeTorque {\n\t\t\tin driveshaftTorque: DriveshaftTorque;\n\t\t\tout wheelTorque: WheelTorque;\n\t\t}\n\t\tsuccession flow fuelCmdFlow from sendFuelCmd.fuelCmd to generateEngineTorque.fuelCmd;\n\t\tsuccession flow startStopCmdFlow from sendStartStopCmd.startStopCmd to generateEngineTorque.startStopCmd;\n\t\tsuccession flow engineTorqueFlow from generateEngineTorque.engineTorque to amplifyTorque.engineTorque;\n\t\tsuccession flow transmissionTorqueFlow from amplifyTorque.transmissionTorque to transmitTorque.transmissionTorque;\n\t\tsuccession flow driveshaftTorqueFlow from transmitTorque.driveshaftTorque to distributeTorque.driveshaftTorque;\n\t}\n}",
    "package 'AutomotivePowertrainControl' {\n\tattribute def FuelControlCmd;\n\tattribute def StallSignal;\n\tattribute def EngineStartCmd;\n\tattribute def EngineShutdownCmd;\n\tattribute def Torque;\n\tattribute def AmplifiedTorque;\n\tattribute def TransmittedTorque;\n\tattribute def DistributedTorque;\n\tattribute def WheelTorque;\n\n\tport def FuelControlCmdPort {\n\t\tin fuelControlCmd: FuelControlCmd;\n\t}\n\tport def StallSignalPort {\n\t\tin stallSignal: StallSignal;\n\t}\n\tport def EngineControlPort {\n\t\tout engineStartCmd: EngineStartCmd;\n\t\tout engineShutdownCmd: EngineShutdownCmd;\n\t}\n\tport def TorquePort {\n\t\tout torque: Torque;\n\t}\n\tport def AmplifiedTorquePort {\n\t\tout amplifiedTorque: AmplifiedTorque;\n\t}\n\tport def TransmittedTorquePort {\n\t\tout transmittedTorque: TransmittedTorque;\n\t}\n\tport def DistributedTorquePort {\n\t\tout distributedTorque: DistributedTorque;\n\t}\n\tport def WheelTorquePort {\n\t\tout wheelTorque: WheelTorque;\n\t}\n\n\tpart context {\n\t\tpart user {\n\t\t\tport fuelControlCmdPort: FuelControlCmdPort;\n\t\t\tport stallSignalPort: StallSignalPort;\n\t\t\tperform powertrainControl.sendFuelControlCmd {\n\t\t\t\tout fuelControlCmd = fuelControlCmdPort.fuelControlCmd;\n\t\t\t}\n\t\t\tperform powertrainControl.sendStallSignal {\n\t\t\t\tout stallSignal = stallSignalPort.stallSignal;\n\t\t\t}\n\t\t}\n\t\tpart powertrainController {\n\t\t\tport fuelControlCmdPort: ~FuelControlCmdPort;\n\t\t\tport stallSignalPort: ~StallSignalPort;\n\t\t\tport engineControlPort: EngineControlPort;\n\t\t\tport torquePort: TorquePort;\n\n\t\t\tperform powertrainControl.processFuelCmd {\n\t\t\t\tin fuelControlCmd = fuelControlCmdPort.fuelControlCmd;\n\t\t\t\tout engineStartCmd = engineControlPort.engineStartCmd;\n\t\t\t}\n\t\t\tperform powertrainControl.processStallSignal {\n\t\t\t\tin stallSignal = stallSignalPort.stallSignal;\n\t\t\t\tout engineShutdownCmd = engineControlPort.engineShutdownCmd;\n\t\t\t}\n\t\t\tperform powertrainControl.generateTorque {\n\t\t\t\tin engineStartCmd = engineControlPort.engineStartCmd;\n\t\t\t\tout torque = torquePort.torque;\n\t\t\t}\n\t\t}\n\t\tpart torqueAmplifier {\n\t\t\tport torquePort: ~TorquePort;\n\t\t\tport amplifiedTorquePort: AmplifiedTorquePort;\n\t\t\tperform powertrainControl.amplifyTorque {\n\t\t\t\tin torque = torquePort.torque;\n\t\t\t\tout amplifiedTorque = amplifiedTorquePort.amplifiedTorque;\n\t\t\t}\n\t\t}\n\t\tpart torqueTransmitter {\n\t\t\tport amplifiedTorquePort: ~AmplifiedTorquePort;\n\t\t\tport transmittedTorquePort: TransmittedTorquePort;\n\t\t\tperform powertrainControl.transmitTorque {\n\t\t\t\tin amplifiedTorque = amplifiedTorquePort.amplifiedTorque;\n\t\t\t\tout transmittedTorque = transmittedTorquePort.transmittedTorque;\n\t\t\t}\n\t\t}\n\t\tpart torqueDistributor {\n\t\t\tport transmittedTorquePort: ~TransmittedTorquePort;\n\t\t\tport distributedTorquePort: DistributedTorquePort;\n\t\t\tperform powertrainControl.distributeTorque {\n\t\t\t\tin transmittedTorque = transmittedTorquePort.transmittedTorque;\n\t\t\t\tout distributedTorque = distributedTorquePort.distributedTorque;\n\t\t\t}\n\t\t}\n\t\tpart driveWheels {\n\t\t\tport distributedTorquePort: ~DistributedTorquePort;\n\t\t\tport wheelTorquePort: WheelTorquePort;\n\t\t\tperform powertrainControl.applyTorqueToWheels {\n\t\t\t\tin distributedTorque = distributedTorquePort.distributedTorque;\n\t\t\t\tout wheelTorque = wheelTorquePort.wheelTorque;\n\t\t\t}\n\t\t}\n\t}\n\n\taction powertrainControl {\n\t\taction sendFuelControlCmd { out fuelControlCmd: FuelControlCmd; }\n\t\taction sendStallSignal { out stallSignal: StallSignal; }\n\t\taction processFuelCmd { in fuelControlCmd: FuelControlCmd; out engineStartCmd: EngineStartCmd; }\n\t\taction processStallSignal { in stallSignal: StallSignal; out engineShutdownCmd: EngineShutdownCmd; }\n\t\taction generateTorque { in engineStartCmd: EngineStartCmd; out torque: Torque; }\n\t\taction amplifyTorque { in torque: Torque; out amplifiedTorque: AmplifiedTorque; }\n\t\taction transmitTorque { in amplifiedTorque: AmplifiedTorque; out transmittedTorque: TransmittedTorque; }\n\t\taction distributeTorque { in transmittedTorque: TransmittedTorque; out distributedTorque: DistributedTorque; }\n\t\taction applyTorqueToWheels { in distributedTorque: DistributedTorque; out wheelTorque: WheelTorque; }\n\n\t\tsuccession flow fuelCmdFlow from sendFuelControlCmd.fuelControlCmd to processFuelCmd.fuelControlCmd;\n\t\tsuccession flow engineStartFlow from processFuelCmd.engineStartCmd to generateTorque.engineStartCmd;\n\t\tsuccession flow torqueFlow from generateTorque.torque to amplifyTorque.torque;\n\t\tsuccession flow amplifiedTorqueFlow from amplifyTorque.amplifiedTorque to transmitTorque.amplifiedTorque;\n\t\tsuccession flow transmittedTorqueFlow from transmitTorque.transmittedTorque to distributeTorque.transmittedTorque;\n\t\tsuccession flow distributedTorqueFlow from distributeTorque.distributedTorque to applyTorqueToWheels.distributedTorque;\n\n\t\tsuccession flow stallSignalFlow from sendStallSignal.stallSignal to processStallSignal.stallSignal;\n\t}\n}",
    "package 'VehiclePowertrainManagement' {\n\tattribute def FuelCmd;\n\tattribute def EngineStartSignal;\n\tattribute def EngineShutdownSignal;\n\tattribute def EngineTorque;\n\tattribute def TransmissionTorque;\n\tattribute def WheelTorque;\n\n\tport def FuelCmdPort {\n\t\tout fuelCmd: FuelCmd;\n\t}\n\tport def EngineStartPort {\n\t\tout engineStart: EngineStartSignal;\n\t}\n\tport def EngineShutdownPort {\n\t\tout engineShutdown: EngineShutdownSignal;\n\t}\n\tport def EngineTorquePort {\n\t\tout engineTorque: EngineTorque;\n\t}\n\tport def TransmissionTorquePort {\n\t\tout transmissionTorque: TransmissionTorque;\n\t}\n\tport def WheelTorquePort {\n\t\tout wheelTorque: WheelTorque;\n\t}\n\n\tpart context {\n\t\tpart driver {\n\t\t\tport fuelCmdPort: FuelCmdPort;\n\t\t\tport engineStartPort: EngineStartPort;\n\t\t\tport engineShutdownPort: EngineShutdownPort;\n\t\t\tperform managePowertrain.sendDriverCommands {\n\t\t\t\tout fuelCmd = fuelCmdPort.fuelCmd;\n\t\t\t\tout engineStart = engineStartPort.engineStart;\n\t\t\t\tout engineShutdown = engineShutdownPort.engineShutdown;\n\t\t\t}\n\t\t}\n\t\tpart powertrainSystem {\n\t\t\tport fuelCmdPort: ~FuelCmdPort;\n\t\t\tport engineStartPort: ~EngineStartPort;\n\t\t\tport engineShutdownPort: ~EngineShutdownPort;\n\t\t\tport engineTorquePort: EngineTorquePort;\n\t\t\tport transmissionTorquePort: TransmissionTorquePort;\n\t\t\tport wheelTorquePort: WheelTorquePort;\n\t\t\tperform managePowertrain.processPowertrain {\n\t\t\t\tin fuelCmd = fuelCmdPort.fuelCmd;\n\t\t\t\tin engineStart = engineStartPort.engineStart;\n\t\t\t\tin engineShutdown = engineShutdownPort.engineShutdown;\n\t\t\t\tout engineTorque = engineTorquePort.engineTorque;\n\t\t\t\tout transmissionTorque = transmissionTorquePort.transmissionTorque;\n\t\t\t\tout wheelTorque = wheelTorquePort.wheelTorque;\n\t\t\t}\n\t\t}\n\t\tpart transmission {\n\t\t\tport engineTorquePort: ~EngineTorquePort;\n\t\t\tport transmissionTorquePort: TransmissionTorquePort;\n\t\t\tperform managePowertrain.amplifyTorque {\n\t\t\t\tin engineTorque = engineTorquePort.engineTorque;\n\t\t\t\tout transmissionTorque = transmissionTorquePort.transmissionTorque;\n\t\t\t}\n\t\t}\n\t\tpart wheelSystem {\n\t\t\tport transmissionTorquePort: ~TransmissionTorquePort;\n\t\t\tport wheelTorquePort: WheelTorquePort;\n\t\t\tperform managePowertrain.distributeTorque {\n\t\t\t\tin transmissionTorque = transmissionTorquePort.transmissionTorque;\n\t\t\t\tout wheelTorque = wheelTorquePort.wheelTorque;\n\t\t\t}\n\t\t}\n\t\tinterface driverToPowertrain connect driver.fuelCmdPort to powertrainSystem.fuelCmdPort {\n\t\t\tref flow references managePowertrain.fuelCmdFlow\n\t\t\t\tfrom source.fuelCmd to target.fuelCmd;\n\t\t}\n\t\tinterface driverStartToPowertrain connect driver.engineStartPort to powertrainSystem.engineStartPort {\n\t\t\tref flow references managePowertrain.engineStartFlow\n\t\t\t\tfrom source.engineStart to target.engineStart;\n\t\t}\n\t\tinterface driverShutdownToPowertrain connect driver.engineShutdownPort to powertrainSystem.engineShutdownPort {\n\t\t\tref flow references managePowertrain.engineShutdownFlow\n\t\t\t\tfrom source.engineShutdown to target.engineShutdown;\n\t\t}\n\t\tinterface powertrainToTransmission connect powertrainSystem.engineTorquePort to transmission.engineTorquePort {\n\t\t\tref flow references managePowertrain.engineTorqueFlow\n\t\t\t\tfrom source.engineTorque to target.engineTorque;\n\t\t}\n\t\tinterface transmissionToWheelSystem connect transmission.transmissionTorquePort to wheelSystem.transmissionTorquePort {\n\t\t\tref flow references managePowertrain.transmissionTorqueFlow\n\t\t\t\tfrom source.transmissionTorque to target.transmissionTorque;\n\t\t}\n\t\tinterface wheelSystemOutput connect wheelSystem.wheelTorquePort to powertrainSystem.wheelTorquePort {\n\t\t\tref flow references managePowertrain.wheelTorqueFlow\n\t\t\t\tfrom source.wheelTorque to target.wheelTorque;\n\t\t}\n\t}\n\n\taction managePowertrain {\n\t\taction sendDriverCommands {\n\t\t\tout fuelCmd: FuelCmd;\n\t\t\tout engineStart: EngineStartSignal;\n\t\t\tout engineShutdown: EngineShutdownSignal;\n\t\t}\n\t\taction processPowertrain {\n\t\t\tin fuelCmd: FuelCmd;\n\t\t\tin engineStart: EngineStartSignal;\n\t\t\tin engineShutdown: EngineShutdownSignal;\n\t\t\tout engineTorque: EngineTorque;\n\t\t\tout transmissionTorque: TransmissionTorque;\n\t\t\tout wheelTorque: WheelTorque;\n\t\t}\n\t\taction amplifyTorque {\n\t\t\tin engineTorque: EngineTorque;\n\t\t\tout transmissionTorque: TransmissionTorque;\n\t\t}\n\t\taction distributeTorque {\n\t\t\tin transmissionTorque: TransmissionTorque;\n\t\t\tout wheelTorque: WheelTorque;\n\t\t}\n\t\tsuccession flow fuelCmdFlow from sendDriverCommands.fuelCmd to processPowertrain.fuelCmd;\n\t\tsuccession flow engineStartFlow from sendDriverCommands.engineStart to processPowertrain.engineStart;\n\t\tsuccession flow engineShutdownFlow from sendDriverCommands.engineShutdown to processPowertrain.engineShutdown;\n\t\tsuccession flow engineTorqueFlow from processPowertrain.engineTorque to amplifyTorque.engineTorque;\n\t\tsuccession flow transmissionTorqueFlow from amplifyTorque.transmissionTorque to distributeTorque.transmissionTorque;\n\t\tsuccession flow wheelTorqueFlow from distributeTorque.wheelTorque to processPowertrain.wheelTorque;\n\t}\n}",
    "package 'VehicleTrailerHitching' {\n\tattribute def HitchCmd;\n\tattribute def PowerConnectionState;\n\tattribute def StructuralConnectionState;\n\n\tport def HitchCmdPort {\n\t\tout hitchCmd: HitchCmd;\n\t}\n\tport def PowerConnectionPort {\n\t\tout powerState: PowerConnectionState;\n\t}\n\tport def StructuralConnectionPort {\n\t\tout structState: StructuralConnectionState;\n\t}\n\n\tpart context {\n\t\tpart user {\n\t\t\tport hitchCmdPort: HitchCmdPort;\n\t\t\tperform hitchingControl.sendHitchCmd {\n\t\t\t\tout hitchCmd = hitchCmdPort.hitchCmd;\n\t\t\t}\n\t\t}\n\t\tpart vehicle {\n\t\t\tpart frame;\n\t\t\tpart hitchBall;\n\t\t\tport structuralConnectionPort: ~StructuralConnectionPort;\n\t\t\tport powerConnectionPort: ~PowerConnectionPort;\n\t\t}\n\t\tpart trailer {\n\t\t\tpart frame;\n\t\t\tpart coupler;\n\t\t\tport structuralConnectionPort: StructuralConnectionPort;\n\t\t\tport powerConnectionPort: PowerConnectionPort;\n\t\t}\n\t\tinterface userToHitch connect user.hitchCmdPort to hitchingMechanism.hitchCmdPort {\n\t\t\tref flow references hitchingControl.hitchCmdFlow\n\t\t\t\tfrom source.hitchCmd to target.hitchCmd;\n\t\t}\n\t\tpart hitchingMechanism {\n\t\t\tport hitchCmdPort: ~HitchCmdPort;\n\t\t\tport structuralConnectionPort: StructuralConnectionPort;\n\t\t\tport powerConnectionPort: PowerConnectionPort;\n\t\t\tperform hitchingControl.processHitchCmd {\n\t\t\t\tin hitchCmd = hitchCmdPort.hitchCmd;\n\t\t\t\tout structState = structuralConnectionPort.structState;\n\t\t\t\tout powerState = powerConnectionPort.powerState;\n\t\t\t}\n\t\t}\n\t\tinterface hitchToVehicle connect hitchingMechanism.structuralConnectionPort to vehicle.structuralConnectionPort {\n\t\t\tref flow references hitchingControl.structuralConnectionFlow\n\t\t\t\tfrom source.structState to target.structState;\n\t\t}\n\t\tinterface hitchToTrailer connect hitchingMechanism.structuralConnectionPort to trailer.structuralConnectionPort {\n\t\t\tref flow references hitchingControl.structuralConnectionFlow\n\t\t\t\tfrom source.structState to target.structState;\n\t\t}\n\t\tinterface powerToVehicle connect hitchingMechanism.powerConnectionPort to vehicle.powerConnectionPort {\n\t\t\tref flow references hitchingControl.powerConnectionFlow\n\t\t\t\tfrom source.powerState to target.powerState;\n\t\t}\n\t\tinterface powerToTrailer connect hitchingMechanism.powerConnectionPort to trailer.powerConnectionPort {\n\t\t\tref flow references hitchingControl.powerConnectionFlow\n\t\t\t\tfrom source.powerState to target.powerState;\n\t\t}\n\t}\n\n\taction hitchingControl {\n\t\taction sendHitchCmd { out hitchCmd: HitchCmd; }\n\t\tsuccession flow hitchCmdFlow from sendHitchCmd.hitchCmd to processHitchCmd.hitchCmd;\n\t\taction processHitchCmd {\n\t\t\tin hitchCmd: HitchCmd;\n\t\t\tout structState: StructuralConnectionState;\n\t\t\tout powerState: PowerConnectionState;\n\t\t}\n\t\tsuccession flow structuralConnectionFlow from processHitchCmd.structState to vehicle.structuralConnectionPort.structState;\n\t\tsuccession flow structuralConnectionFlow from processHitchCmd.structState to trailer.structuralConnectionPort.structState;\n\t\tsuccession flow powerConnectionFlow from processHitchCmd.powerState to vehicle.powerConnectionPort.powerState;\n\t\tsuccession flow powerConnectionFlow from processHitchCmd.powerState to trailer.powerConnectionPort.powerState;\n\t}\n}",
    "package 'VehicleTrailerConnection' {\n\tattribute def ConnectCmd;\n\tattribute def ConnectionStatus;\n\tport def ConnectCmdPort {\n\t\tout connectCmd: ConnectCmd;\n\t}\n\tport def ConnectionStatusPort {\n\t\tout connectionStatus: ConnectionStatus;\n\t}\n\tpart context {\n\t\tpart user {\n\t\t\tport connectCmdPort: ConnectCmdPort;\n\t\t\tperform manageConnection.sendConnectCmd {\n\t\t\t\tout connectCmd = connectCmdPort.connectCmd;\n\t\t\t}\n\t\t}\n\t\tpart vehicle {\n\t\t\tpart chassis;\n\t\t\tpart towBall;\n\t\t}\n\t\tpart trailer {\n\t\t\tpart trailerFrame;\n\t\t\tpart coupler;\n\t\t}\n\t\tpart connectionSystem {\n\t\t\tport connectCmdPort: ~ConnectCmdPort;\n\t\t\tport connectionStatusPort: ConnectionStatusPort;\n\t\t\tpart vehicleRef: vehicle;\n\t\t\tpart trailerRef: trailer;\n\t\t\tperform manageConnection.performConnection {\n\t\t\t\tin connectCmd = connectCmdPort.connectCmd;\n\t\t\t\tout connectionStatus = connectionStatusPort.connectionStatus;\n\t\t\t}\n\t\t}\n\t\tinterface userToConnectionSystem connect user.connectCmdPort to connectionSystem.connectCmdPort {\n\t\t\tref flow references manageConnection.connectCmdFlow\n\t\t\t\tfrom source.connectCmd to target.connectCmd;\n\t\t}\n\t}\n\taction manageConnection {\n\t\taction sendConnectCmd { out connectCmd: ConnectCmd; }\n\t\tsuccession flow connectCmdFlow from sendConnectCmd.connectCmd to performConnection.connectCmd;\n\t\taction performConnection {\n\t\t\tin connectCmd: ConnectCmd;\n\t\t\tout connectionStatus: ConnectionStatus;\n\t\t}\n\t}\n}",
    "package 'VehicleTrailerConnection' {\n\tattribute def HitchCmd;\n\tattribute def ConnectionStatus;\n\tport def HitchCmdPort {\n\t\tout hitchCmd: HitchCmd;\n\t}\n\tport def ConnectionStatusPort {\n\t\tout connectionStatus: ConnectionStatus;\n\t}\n\tpart context {\n\t\tpart user {\n\t\t\tport hitchCmdPort: HitchCmdPort;\n\t\t\tperform manageConnection.sendHitchCmd {\n\t\t\t\tout hitchCmd = hitchCmdPort.hitchCmd;\n\t\t\t}\n\t\t}\n\t\tpart vehicle {\n\t\t\tpart chassis;\n\t\t\tpart towBallDevice;\n\t\t\tport towBallPort;\n\t\t}\n\t\tpart trailer {\n\t\t\tpart trailerChassis;\n\t\t\tpart couplerMechanism {\n\t\t\t\tport couplerPort;\n\t\t\t\tport connectionStatusPort: ConnectionStatusPort;\n\t\t\t\tperform manageConnection.engageCoupler {\n\t\t\t\t\tin hitchCmd;\n\t\t\t\t\tout connectionStatus = connectionStatusPort.connectionStatus;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tinterface userToTrailer connect user.hitchCmdPort to trailer.couplerMechanism.hitchCmdPort {\n\t\t\tref flow references manageConnection.hitchCmdFlow\n\t\t\t\tfrom source.hitchCmd to target.hitchCmd;\n\t\t}\n\t\tinterface towBallToCoupler connect vehicle.towBallDevice.towBallPort to trailer.couplerMechanism.couplerPort;\n\t}\n\taction manageConnection {\n\t\taction sendHitchCmd { out hitchCmd: HitchCmd; }\n\t\tsuccession flow hitchCmdFlow from sendHitchCmd.hitchCmd to engageCoupler.hitchCmd;\n\t\taction engageCoupler {\n\t\t\tin hitchCmd: HitchCmd;\n\t\t\tout connectionStatus: ConnectionStatus;\n\t\t}\n\t}\n}",
    "package 'FuelSystem' {\n\tattribute def Fuel;\n\tattribute def Temperature;\n\tport def FuelPort {\n\t\tinout fuel: Fuel;\n\t}\n\tport def TempPort {\n\t\tout temperature: Temperature;\n\t}\n\tpart context {\n\t\tpart fuelTankAssembly {\n\t\t\tport fuelPort: FuelPort;\n\t\t\tperform fuelCirculation.supplyFuel {\n\t\t\t\tout fuel = fuelPort.fuel;\n\t\t\t}\n\t\t\tperform fuelCirculation.receiveReturnFuel {\n\t\t\t\tin fuel = fuelPort.fuel;\n\t\t\t}\n\t\t}\n\t\tpart engine {\n\t\t\tport fuelPort: ~FuelPort;\n\t\t\tport tempPort: TempPort;\n\t\t\tperform fuelCirculation.consumeFuel {\n\t\t\t\tin fuel = fuelPort.fuel;\n\t\t\t}\n\t\t\tperform fuelCirculation.returnFuel {\n\t\t\t\tout fuel = fuelPort.fuel;\n\t\t\t}\n\t\t\tperform fuelCirculation.monitorTemperature {\n\t\t\t\tout temperature = tempPort.temperature;\n\t\t\t}\n\t\t}\n\t\tinterface fuelSupply connect fuelTankAssembly.fuelPort to engine.fuelPort {\n\t\t\tref flow references fuelCirculation.fuelSupplyFlow\n\t\t\t\tfrom source.fuel to target.fuel;\n\t\t}\n\t\tinterface fuelReturn connect engine.fuelPort to fuelTankAssembly.fuelPort {\n\t\t\tref flow references fuelCirculation.fuelReturnFlow\n\t\t\t\tfrom source.fuel to target.fuel;\n\t\t}\n\t}\n\taction fuelCirculation {\n\t\taction supplyFuel { out fuel: Fuel; }\n\t\taction consumeFuel { in fuel: Fuel; }\n\t\tsuccession flow fuelSupplyFlow from supplyFuel.fuel to consumeFuel.fuel;\n\t\taction returnFuel { out fuel: Fuel; }\n\t\taction receiveReturnFuel { in fuel: Fuel; }\n\t\tsuccession flow fuelReturnFlow from returnFuel.fuel to receiveReturnFuel.fuel;\n\t\taction monitorTemperature { out temperature: Temperature; }\n\t}\n}",
    "package 'FuelDeliverySystem' {\n\tattribute def FuelQuantity;\n\tattribute def FuelLevel;\n\tattribute def FuelCapacity;\n\tport def FuelPort {\n\t\tflow out fuelQuantity: FuelQuantity;\n\t}\n\tport def FuelLevelPort {\n\t\tflow out fuelLevel: FuelLevel;\n\t\tflow out fuelCapacity: FuelCapacity;\n\t}\n\tpart context {\n\t\tpart storageTank {\n\t\t\tport fuelOut: FuelPort;\n\t\t\tperform fuelTransferSystem.extractFuel {\n\t\t\t\tout fuelQuantity = fuelOut.fuelQuantity;\n\t\t\t}\n\t\t}\n\t\tpart fuelPump {\n\t\t\tport fuelIn: ~FuelPort;\n\t\t\tport fuelOut: FuelPort;\n\t\t\tperform fuelTransferSystem.transferFuel {\n\t\t\t\tin fuelQuantity = fuelIn.fuelQuantity;\n\t\t\t\tout fuelQuantity = fuelOut.fuelQuantity;\n\t\t\t}\n\t\t}\n\t\tpart vehicle {\n\t\t\tport fuelIn: ~FuelPort;\n\t\t\tport fuelLevelOut: FuelLevelPort;\n\t\t\tperform fuelTransferSystem.receiveFuel {\n\t\t\t\tin fuelQuantity = fuelIn.fuelQuantity;\n\t\t\t\tout fuelLevel = fuelLevelOut.fuelLevel;\n\t\t\t\tout fuelCapacity = fuelLevelOut.fuelCapacity;\n\t\t\t}\n\t\t}\n\t\tinterface storageToPump connect storageTank.fuelOut to fuelPump.fuelIn {\n\t\t\tref flow references fuelTransferSystem.fuelFlow1\n\t\t\t\tfrom source.fuelQuantity to target.fuelQuantity;\n\t\t}\n\t\tinterface pumpToVehicle connect fuelPump.fuelOut to vehicle.fuelIn {\n\t\t\tref flow references fuelTransferSystem.fuelFlow2\n\t\t\t\tfrom source.fuelQuantity to target.fuelQuantity;\n\t\t}\n\t}\n\taction fuelTransferSystem {\n\t\taction extractFuel { out fuelQuantity: FuelQuantity; }\n\t\tsuccession flow fuelFlow1 from extractFuel.fuelQuantity to transferFuel.fuelQuantity;\n\t\taction transferFuel { in fuelQuantity: FuelQuantity; out fuelQuantity: FuelQuantity; }\n\t\tsuccession flow fuelFlow2 from transferFuel.fuelQuantity to receiveFuel.fuelQuantity;\n\t\taction receiveFuel {\n\t\t\tin fuelQuantity: FuelQuantity;\n\t\t\tout fuelLevel: FuelLevel;\n\t\t\tout fuelCapacity: FuelCapacity;\n\t\t}\n\t}\n}",
    "package 'AutomobileAssembly' {\n\ttype def VehicleAssembly;\n\ttype def Gearbox;\n\ttype def Engine;\n\ttype def VehicleWithGearbox;\n\ttype def FullyAssembledVehicle;\n\n\tport def VehicleAssemblyPort {\n\t\tinout vehicleAssembly: VehicleAssembly;\n\t}\n\tport def GearboxPort {\n\t\tinout gearbox: Gearbox;\n\t}\n\tport def EnginePort {\n\t\tinout engine: Engine;\n\t}\n\tport def VehicleWithGearboxPort {\n\t\tinout vehicleWithGearbox: VehicleWithGearbox;\n\t}\n\tport def FullyAssembledVehiclePort {\n\t\tinout fullyAssembledVehicle: FullyAssembledVehicle;\n\t}\n\n\tpart context {\n\t\tpart assemblyLine {\n\t\t\tport vehicleAssemblyPort: VehicleAssemblyPort;\n\t\t\tport gearboxPort: GearboxPort;\n\t\t\tport enginePort: EnginePort;\n\t\t\tport vehicleWithGearboxPort: VehicleWithGearboxPort;\n\t\t\tport fullyAssembledVehiclePort: FullyAssembledVehiclePort;\n\n\t\t\tperform assemblyProcess.installGearbox {\n\t\t\t\tin vehicleAssembly = vehicleAssemblyPort.vehicleAssembly;\n\t\t\t\tin gearbox = gearboxPort.gearbox;\n\t\t\t\tout vehicleWithGearbox = vehicleWithGearboxPort.vehicleWithGearbox;\n\t\t\t}\n\t\t\tperform assemblyProcess.installEngine {\n\t\t\t\tin vehicleWithGearbox = vehicleWithGearboxPort.vehicleWithGearbox;\n\t\t\t\tin engine = enginePort.engine;\n\t\t\t\tout fullyAssembledVehicle = fullyAssembledVehiclePort.fullyAssembledVehicle;\n\t\t\t}\n\t\t}\n\t}\n\n\taction assemblyProcess {\n\t\taction installGearbox {\n\t\t\tin vehicleAssembly: VehicleAssembly;\n\t\t\tin gearbox: Gearbox;\n\t\t\tout vehicleWithGearbox: VehicleWithGearbox;\n\t\t}\n\t\tsuccession flow gearboxInstallFlow from installGearbox.vehicleWithGearbox to installEngine.vehicleWithGearbox;\n\n\t\taction installEngine {\n\t\t\tin vehicleWithGearbox: VehicleWithGearbox;\n\t\t\tin engine: Engine;\n\t\t\tout fullyAssembledVehicle: FullyAssembledVehicle;\n\t\t}\n\t}\n\n\t// Structure of the fully assembled vehicle\n\tstructure FullyAssembledVehicle {\n\t\tattribute gearbox: Gearbox;\n\t\tattribute engine: Engine;\n\t\tattribute baseAssembly: VehicleAssembly;\n\t}\n}",
    "package 'VehicleA_ControlSystem' {\n\n\t// Attribute and Type Definitions\n\tattribute def BrakePedalPressed : Boolean;\n\tattribute def StartSignal : Boolean;\n\tattribute def VehicleOnSignal : Boolean;\n\tattribute def RestoreToNormalSignal : Boolean;\n\tattribute def OverTempSignal : Boolean;\n\tattribute def VehicleTemp : Real;\n\tattribute def TempThreshold : Real;\n\tattribute def PowerSupplyCmd : Boolean;\n\tattribute def ParkingBrakeCmd : Boolean;\n\tattribute def DegradedModeCmd : Boolean;\n\n\t// State Definitions\n\tstate def VehicleState {\n\t\tstate Off;\n\t\tstate Starting;\n\t\tstate Running;\n\t\tstate HealthManagement;\n\t\tstate Maintenance;\n\t\tstate Degraded;\n\t\tstate Normal;\n\t}\n\n\t// Port Definitions\n\tport def BrakePedalPort {\n\t\tin brakePedalPressed: BrakePedalPressed;\n\t}\n\tport def StartSignalPort {\n\t\tin startSignal: StartSignal;\n\t}\n\tport def VehicleOnSignalPort {\n\t\tin vehicleOnSignal: VehicleOnSignal;\n\t}\n\tport def RestoreToNormalPort {\n\t\tin restoreToNormalSignal: RestoreToNormalSignal;\n\t}\n\tport def OverTempPort {\n\t\tout overTempSignal: OverTempSignal;\n\t}\n\tport def VehicleTempPort {\n\t\tout vehicleTemp: VehicleTemp;\n\t}\n\tport def PowerSupplyPort {\n\t\tout powerSupplyCmd: PowerSupplyCmd;\n\t}\n\tport def ParkingBrakePort {\n\t\tout parkingBrakeCmd: ParkingBrakeCmd;\n\t}\n\tport def DegradedModePort {\n\t\tout degradedModeCmd: DegradedModeCmd;\n\t}\n\n\t// Main System Context\n\tpart context {\n\t\tpart vehicleController {\n\t\t\tport brakePedalPort: BrakePedalPort;\n\t\t\tport startSignalPort: StartSignalPort;\n\t\t\tport vehicleOnSignalPort: VehicleOnSignalPort;\n\t\t\tport restoreToNormalPort: RestoreToNormalPort;\n\t\t\tport overTempPort: ~OverTempPort;\n\t\t\tport vehicleTempPort: ~VehicleTempPort;\n\t\t\tport powerSupplyPort: PowerSupplyPort;\n\t\t\tport parkingBrakePort: ParkingBrakePort;\n\t\t\tport degradedModePort: DegradedModePort;\n\n\t\t\tperform vehicleControl.manageVehicleState {\n\t\t\t\tin brakePedalPressed = brakePedalPort.brakePedalPressed;\n\t\t\t\tin startSignal = startSignalPort.startSignal;\n\t\t\t\tin vehicleOnSignal = vehicleOnSignalPort.vehicleOnSignal;\n\t\t\t\tin restoreToNormalSignal = restoreToNormalPort.restoreToNormalSignal;\n\t\t\t\tout powerSupplyCmd = powerSupplyPort.powerSupplyCmd;\n\t\t\t\tout parkingBrakeCmd = parkingBrakePort.parkingBrakeCmd;\n\t\t\t\tout degradedModeCmd = degradedModePort.degradedModeCmd;\n\t\t\t}\n\t\t\tperform vehicleControl.monitorHealth {\n\t\t\t\tout vehicleTemp = vehicleTempPort.vehicleTemp;\n\t\t\t\tout overTempSignal = overTempPort.overTempSignal;\n\t\t\t}\n\t\t}\n\t}\n\n\t// Behavior and Action Definitions\n\taction vehicleControl {\n\t\taction manageVehicleState {\n\t\t\tin brakePedalPressed: BrakePedalPressed;\n\t\t\tin startSignal: StartSignal;\n\t\t\tin vehicleOnSignal: VehicleOnSignal;\n\t\t\tin restoreToNormalSignal: RestoreToNormalSignal;\n\t\t\tout powerSupplyCmd: PowerSupplyCmd;\n\t\t\tout parkingBrakeCmd: ParkingBrakeCmd;\n\t\t\tout degradedModeCmd: DegradedModeCmd;\n\n\t\t\tstate vehicleState: VehicleState = Off;\n\n\t\t\t// State Transitions\n\t\t\twhen vehicleState == Off and brakePedalPressed and startSignal then\n\t\t\t\tvehicleState := Starting;\n\n\t\t\twhen vehicleState == Starting and vehicleOnSignal then\n\t\t\t\tvehicleState := Running;\n\n\t\t\twhen vehicleState == Running then\n\t\t\t\tpowerSupplyCmd := true;\n\t\t\t\t// Self-checks performed automatically\n\n\t\t\twhen vehicleState == Running and not vehicleOnSignal then\n\t\t\t\tparkingBrakeCmd := true;\n\t\t\t\tvehicleState := Off;\n\n\t\t\twhen vehicleState == Degraded and restoreToNormalSignal then\n\t\t\t\tvehicleState := Normal;\n\n\t\t\twhen vehicleState == Running and degradedModeCmd then\n\t\t\t\tvehicleState := Degraded;\n\t\t}\n\n\t\taction monitorHealth {\n\t\t\tout vehicleTemp: VehicleTemp;\n\t\t\tout overTempSignal: OverTempSignal;\n\t\t\tin tempThreshold: TempThreshold;\n\n\t\t\t// Real-time temperature monitoring\n\t\t\tobserve vehicleTemp;\n\n\t\t\twhen vehicleTemp > tempThreshold then\n\t\t\t\toverTempSignal := true;\n\t\t\t\tperform enterDegradedMode;\n\t\t}\n\n\t\taction enterDegradedMode {\n\t\t\tout degradedModeCmd: DegradedModeCmd;\n\t\t\tdegradedModeCmd := true;\n\t\t}\n\t}\n}",
    "package 'AutomatedVehicleModeling' {\n\tattribute def StartSignal;\n\tattribute def BrakePedalStatus;\n\tattribute def VehicleStatus;\n\tattribute def Temperature;\n\tattribute def WarningSignal;\n\tattribute def ControlSignal;\n\tattribute def HealthStatus;\n\tattribute def FuelType;\n\tattribute def MaintenanceInterval;\n\tattribute def TemperatureThreshold;\n\n\tport def StartCmdPort {\n\t\tin startSignal: StartSignal;\n\t\tin brakePedalStatus: BrakePedalStatus;\n\t}\n\tport def StatusPort {\n\t\tout vehicleStatus: VehicleStatus;\n\t\tout healthStatus: HealthStatus;\n\t\tout temperature: Temperature;\n\t}\n\tport def WarningPort {\n\t\tout warningSignal: WarningSignal;\n\t}\n\tport def ControlPort {\n\t\tin controlSignal: ControlSignal;\n\t}\n\tport def ConfigPort {\n\t\tin fuelType: FuelType;\n\t\tin maintenanceInterval: MaintenanceInterval;\n\t\tin temperatureThreshold: TemperatureThreshold;\n\t}\n\n\tpart context {\n\t\tpart vehicleController {\n\t\t\tport startCmdPort: ~StartCmdPort;\n\t\t\tport statusPort: StatusPort;\n\t\t\tport warningPort: ~WarningPort;\n\t\t\tport controlPort: ControlPort;\n\t\t\tport configPort: ConfigPort;\n\n\t\t\tperform vehicleBehavior.processSignals {\n\t\t\t\tin vehicleStatus = statusPort.vehicleStatus;\n\t\t\t\tin healthStatus = statusPort.healthStatus;\n\t\t\t\tin temperature = statusPort.temperature;\n\t\t\t\tin warningSignal = warningPort.warningSignal;\n\t\t\t\tout controlSignal = controlPort.controlSignal;\n\t\t\t}\n\t\t}\n\t\tpart vehicle {\n\t\t\tport startCmdPort: StartCmdPort;\n\t\t\tport statusPort: ~StatusPort;\n\t\t\tport warningPort: WarningPort;\n\t\t\tport controlPort: ~ControlPort;\n\t\t\tport configPort: ~ConfigPort;\n\n\t\t\tperform vehicleBehavior.startupSequence {\n\t\t\t\tin startSignal = startCmdPort.startSignal;\n\t\t\t\tin brakePedalStatus = startCmdPort.brakePedalStatus;\n\t\t\t\tout vehicleStatus = statusPort.vehicleStatus;\n\t\t\t\tout healthStatus = statusPort.healthStatus;\n\t\t\t}\n\t\t\tperform vehicleBehavior.selfInspection {\n\t\t\t\tin vehicleStatus = statusPort.vehicleStatus;\n\t\t\t\tout healthStatus = statusPort.healthStatus;\n\t\t\t}\n\t\t\tperform vehicleBehavior.monitorTemperature {\n\t\t\t\tout temperature = statusPort.temperature;\n\t\t\t}\n\t\t\tperform vehicleBehavior.handleOverheat {\n\t\t\t\tin temperature = statusPort.temperature;\n\t\t\t\tin temperatureThreshold = configPort.temperatureThreshold;\n\t\t\t\tout warningSignal = warningPort.warningSignal;\n\t\t\t\tout vehicleStatus = statusPort.vehicleStatus;\n\t\t\t}\n\t\t\tperform vehicleBehavior.healthManagement {\n\t\t\t\tin healthStatus = statusPort.healthStatus;\n\t\t\t\tin maintenanceInterval = configPort.maintenanceInterval;\n\t\t\t\tout healthStatus = statusPort.healthStatus;\n\t\t\t}\n\t\t\tperform vehicleBehavior.faultRecovery {\n\t\t\t\tin healthStatus = statusPort.healthStatus;\n\t\t\t\tout healthStatus = statusPort.healthStatus;\n\t\t\t}\n\t\t\tperform vehicleBehavior.processControl {\n\t\t\t\tin controlSignal = controlPort.controlSignal;\n\t\t\t\tout vehicleStatus = statusPort.vehicleStatus;\n\t\t\t}\n\t\t}\n\t\tinterface controllerToVehicle connect vehicleController.startCmdPort to vehicle.startCmdPort {\n\t\t\tref flow references vehicleBehavior.startCmdFlow\n\t\t\t\tfrom source.startSignal to target.startSignal,\n\t\t\t\tfrom source.brakePedalStatus to target.brakePedalStatus;\n\t\t}\n\t\tinterface vehicleToController connect vehicle.statusPort to vehicleController.statusPort {\n\t\t\tref flow references vehicleBehavior.statusFlow\n\t\t\t\tfrom source.vehicleStatus to target.vehicleStatus,\n\t\t\t\tfrom source.healthStatus to target.healthStatus,\n\t\t\t\tfrom source.temperature to target.temperature;\n\t\t}\n\t\tinterface warningToController connect vehicle.warningPort to vehicleController.warningPort {\n\t\t\tref flow references vehicleBehavior.warningFlow\n\t\t\t\tfrom source.warningSignal to target.warningSignal;\n\t\t}\n\t\tinterface controlToVehicle connect vehicleController.controlPort to vehicle.controlPort {\n\t\t\tref flow references vehicleBehavior.controlFlow\n\t\t\t\tfrom source.controlSignal to target.controlSignal;\n\t\t}\n\t\tinterface configToVehicle connect vehicleController.configPort to vehicle.configPort {\n\t\t\tref flow references vehicleBehavior.configFlow\n\t\t\t\tfrom source.fuelType to target.fuelType,\n\t\t\t\tfrom source.maintenanceInterval to target.maintenanceInterval,\n\t\t\t\tfrom source.temperatureThreshold to target.temperatureThreshold;\n\t\t}\n\t}\n\n\taction vehicleBehavior {\n\t\taction startCmdFlow { out startSignal: StartSignal; out brakePedalStatus: BrakePedalStatus; }\n\t\taction statusFlow { out vehicleStatus: VehicleStatus; out healthStatus: HealthStatus; out temperature: Temperature; }\n\t\taction warningFlow { out warningSignal: WarningSignal; }\n\t\taction controlFlow { out controlSignal: ControlSignal; }\n\t\taction configFlow { out fuelType: FuelType; out maintenanceInterval: MaintenanceInterval; out temperatureThreshold: TemperatureThreshold; }\n\n\t\taction startupSequence {\n\t\t\tin startSignal: StartSignal;\n\t\t\tin brakePedalStatus: BrakePedalStatus;\n\t\t\tout vehicleStatus: VehicleStatus;\n\t\t\tout healthStatus: HealthStatus;\n\t\t}\n\t\taction selfInspection {\n\t\t\tin vehicleStatus: VehicleStatus;\n\t\t\tout healthStatus: HealthStatus;\n\t\t}\n\t\taction monitorTemperature {\n\t\t\tout temperature: Temperature;\n\t\t}\n\t\taction handleOverheat {\n\t\t\tin temperature: Temperature;\n\t\t\tin temperatureThreshold: TemperatureThreshold;\n\t\t\tout warningSignal: WarningSignal;\n\t\t\tout vehicleStatus: VehicleStatus;\n\t\t}\n\t\taction healthManagement {\n\t\t\tin healthStatus: HealthStatus;\n\t\t\tin maintenanceInterval: MaintenanceInterval;\n\t\t\tout healthStatus: HealthStatus;\n\t\t}\n\t\taction faultRecovery {\n\t\t\tin healthStatus: HealthStatus;\n\t\t\tout healthStatus: HealthStatus;\n\t\t}\n\t\taction processControl {\n\t\t\tin controlSignal: ControlSignal;\n\t\t\tout vehicleStatus: VehicleStatus;\n\t\t}\n\t\taction processSignals {\n\t\t\tin vehicleStatus: VehicleStatus;\n\t\t\tin healthStatus: HealthStatus;\n\t\t\tin temperature: Temperature;\n\t\t\tin warningSignal: WarningSignal;\n\t\t\tout controlSignal: ControlSignal;\n\t\t}\n\t}\n}",
    "package 'VehicleSpatiotemporalSimulation' {\n\tattribute def Mass;\n\tattribute def Position;\n\tattribute def Velocity;\n\tattribute def Acceleration;\n\tattribute def SlopeAngle;\n\tattribute def FrictionCoefficient;\n\tattribute def TimePoint;\n\tattribute def VehicleState; // e.g., On, Driving, Off\n\n\tport def VehicleParamPort {\n\t\tin mass: Mass;\n\t\tin position: Position;\n\t\tin velocity: Velocity;\n\t\tin acceleration: Acceleration;\n\t\tin state: VehicleState;\n\t}\n\tport def RoadParamPort {\n\t\tin slopeAngle: SlopeAngle;\n\t\tin frictionCoefficient: FrictionCoefficient;\n\t}\n\tport def TimePort {\n\t\tin timePoint: TimePoint;\n\t}\n\tport def SnapshotPort {\n\t\tout snapshot: Snapshot;\n\t}\n\n\ttype def Snapshot {\n\t\tmass: Mass;\n\t\tposition: Position;\n\t\tvelocity: Velocity;\n\t\tacceleration: Acceleration;\n\t\tstate: VehicleState;\n\t\tslopeAngle: SlopeAngle;\n\t\tfrictionCoefficient: FrictionCoefficient;\n\t\ttimePoint: TimePoint;\n\t}\n\n\tpart context {\n\t\tpart user {\n\t\t\tport vehicleParamPort: VehicleParamPort;\n\t\t\tport roadParamPort: RoadParamPort;\n\t\t\tport timePort: TimePort;\n\t\t\tperform simulationInteraction.defineParameters {\n\t\t\t\tout mass = vehicleParamPort.mass;\n\t\t\t\tout position = vehicleParamPort.position;\n\t\t\t\tout velocity = vehicleParamPort.velocity;\n\t\t\t\tout acceleration = vehicleParamPort.acceleration;\n\t\t\t\tout state = vehicleParamPort.state;\n\t\t\t\tout slopeAngle = roadParamPort.slopeAngle;\n\t\t\t\tout frictionCoefficient = roadParamPort.frictionCoefficient;\n\t\t\t\tout timePoint = timePort.timePoint;\n\t\t\t}\n\t\t}\n\t\tpart simulationEngine {\n\t\t\tport vehicleParamPort: ~VehicleParamPort;\n\t\t\tport roadParamPort: ~RoadParamPort;\n\t\t\tport timePort: ~TimePort;\n\t\t\tport snapshotPort: SnapshotPort;\n\t\t\tperform simulationInteraction.simulateDynamics {\n\t\t\t\tin mass = vehicleParamPort.mass;\n\t\t\t\tin position = vehicleParamPort.position;\n\t\t\t\tin velocity = vehicleParamPort.velocity;\n\t\t\t\tin acceleration = vehicleParamPort.acceleration;\n\t\t\t\tin state = vehicleParamPort.state;\n\t\t\t\tin slopeAngle = roadParamPort.slopeAngle;\n\t\t\t\tin frictionCoefficient = roadParamPort.frictionCoefficient;\n\t\t\t\tin timePoint = timePort.timePoint;\n\t\t\t\tout snapshot = snapshotPort.snapshot;\n\t\t\t}\n\t\t}\n\t\tinterface userToSimulationEngine connect user.vehicleParamPort to simulationEngine.vehicleParamPort {\n\t\t\tref flow references simulationInteraction.vehicleParamFlow\n\t\t\t\tfrom source.mass to target.mass,\n\t\t\t\tfrom source.position to target.position,\n\t\t\t\tfrom source.velocity to target.velocity,\n\t\t\t\tfrom source.acceleration to target.acceleration,\n\t\t\t\tfrom source.state to target.state;\n\t\t}\n\t\tinterface userToSimulationEngineRoad connect user.roadParamPort to simulationEngine.roadParamPort {\n\t\t\tref flow references simulationInteraction.roadParamFlow\n\t\t\t\tfrom source.slopeAngle to target.slopeAngle,\n\t\t\t\tfrom source.frictionCoefficient to target.frictionCoefficient;\n\t\t}\n\t\tinterface userToSimulationEngineTime connect user.timePort to simulationEngine.timePort {\n\t\t\tref flow references simulationInteraction.timeParamFlow\n\t\t\t\tfrom source.timePoint to target.timePoint;\n\t\t}\n\t}\n\n\taction simulationInteraction {\n\t\taction defineParameters {\n\t\t\tout mass: Mass;\n\t\t\tout position: Position;\n\t\t\tout velocity: Velocity;\n\t\t\tout acceleration: Acceleration;\n\t\t\tout state: VehicleState;\n\t\t\tout slopeAngle: SlopeAngle;\n\t\t\tout frictionCoefficient: FrictionCoefficient;\n\t\t\tout timePoint: TimePoint;\n\t\t}\n\t\tsuccession flow vehicleParamFlow from defineParameters.mass to simulateDynamics.mass,\n\t\t\tfrom defineParameters.position to simulateDynamics.position,\n\t\t\tfrom defineParameters.velocity to simulateDynamics.velocity,\n\t\t\tfrom defineParameters.acceleration to simulateDynamics.acceleration,\n\t\t\tfrom defineParameters.state to simulateDynamics.state;\n\t\tsuccession flow roadParamFlow from defineParameters.slopeAngle to simulateDynamics.slopeAngle,\n\t\t\tfrom defineParameters.frictionCoefficient to simulateDynamics.frictionCoefficient;\n\t\tsuccession flow timeParamFlow from defineParameters.timePoint to simulateDynamics.timePoint;\n\t\taction simulateDynamics {\n\t\t\tin mass: Mass;\n\t\t\tin position: Position;\n\t\t\tin velocity: Velocity;\n\t\t\tin acceleration: Acceleration;\n\t\t\tin state: VehicleState;\n\t\t\tin slopeAngle: SlopeAngle;\n\t\t\tin frictionCoefficient: FrictionCoefficient;\n\t\t\tin timePoint: TimePoint;\n\t\t\tout snapshot: Snapshot;\n\t\t}\n\t}\n}",
    "package 'AutomotiveConfigurationManagement' {\n\n\t// Component definitions\n\tpart def Component1;\n\tpart def Component2;\n\tpart def Component3;\n\tpart def Component4;\n\tpart def Component5;\n\tpart def Component6;\n\n\t// Subsystem A configurations\n\tpart def SubsystemA_Option1 {\n\t\tpart component1: Component1;\n\t\tpart component2: Component2;\n\t}\n\tpart def SubsystemA_Option2 {\n\t\tpart component2: Component2;\n\t\tpart component3: Component3;\n\t}\n\n\t// Subsystem B configurations\n\tpart def SubsystemB_Option1 {\n\t\tpart component4: Component4;\n\t\tpart component5: Component5;\n\t}\n\tpart def SubsystemB_Option2 {\n\t\tpart component5: Component5;\n\t\tpart component6: Component6;\n\t}\n\n\t// Subsystem A definition with configuration options\n\tpart def SubsystemA {\n\t\tchoice configA {\n\t\t\toption option1: SubsystemA_Option1;\n\t\t\toption option2: SubsystemA_Option2;\n\t\t}\n\t}\n\n\t// Subsystem B definition with configuration options\n\tpart def SubsystemB {\n\t\tchoice configB {\n\t\t\toption option1: SubsystemB_Option1;\n\t\t\toption option2: SubsystemB_Option2;\n\t\t}\n\t}\n\n\t// Main Automobile system\n\tpart def Automobile {\n\t\tpart subsystemA: SubsystemA;\n\t\tpart subsystemB: SubsystemB;\n\t}\n\n\t// Constraint: If SubsystemA selects option2, then SubsystemB must select option2, or SubsystemA must not be option2\n\tconstraint def ConfigurationConstraint(\n\t\tsubsystemA_config: String,\n\t\tsubsystemB_config: String\n\t) {\n\t\t(subsystemA_config != \"option2\") or (subsystemB_config = \"option2\");\n\t}\n\n\t// Predefined vehicle configurations\n\tpart def ConfigurationA {\n\t\tpart automobile: Automobile {\n\t\t\tsubsystemA.configA = option1;\n\t\t\tsubsystemB.configB = option1;\n\t\t}\n\t}\n\n\tpart def ConfigurationB {\n\t\tpart automobile: Automobile {\n\t\t\tsubsystemA.configA = option2;\n\t\t\tsubsystemB.configB = option1;\n\t\t}\n\t}\n}",
    "package 'ModularVehiclePlatform' {\n\n\t// Abstract Component Definition\n\tblock def Component {\n\t\tattribute def id: String;\n\t}\n\n\t// Concrete Components\n\tblock def Part1 extends Component {}\n\tblock def Part2 extends Component {}\n\tblock def Part3 extends Component {\n\t\tport def p1;\n\t}\n\tblock def Part4 extends Component {}\n\tblock def Part5 extends Component {\n\t\tport def p2;\n\t\t// Behavioral Variants\n\t\tbehavior def VariantA;\n\t\tbehavior def VariantB;\n\t}\n\tblock def Part6 extends Component {}\n\n\t// Abstract Subsystem Definition\n\tblock def Subsystem {\n\t\tattribute def name: String;\n\t\tpart def components: Component[*];\n\t\tport def interconnect;\n\t}\n\n\t// Subsystem A and B with Variants\n\tblock def SubsystemA extends Subsystem {\n\t\t// Variant selection for internal components\n\t\tpart def part1: Part1[0..*];\n\t\tpart def part3: Part3[0..*];\n\t\tpart def part5: Part5[0..*];\n\t\tport def portA;\n\t}\n\tblock def SubsystemB extends Subsystem {\n\t\tpart def part2: Part2[0..*];\n\t\tpart def part4: Part4[0..*];\n\t\tpart def part6: Part6[0..*];\n\t\tport def portB;\n\t}\n\n\t// Interconnection between Subsystems\n\tinterface def SubsystemInterconnection {\n\t\tport a: SubsystemA.portA;\n\t\tport b: SubsystemB.portB;\n\t}\n\n\t// Vehicle Configuration Schemes\n\tblock def VehicleConfigA {\n\t\tpart def subsystemA: SubsystemA;\n\t\tpart def subsystemB: SubsystemB;\n\t\t// Example: select variants and quantities\n\t\tattribute def configParams: String;\n\t}\n\n\tblock def VehicleConfigB {\n\t\tpart def subsystemA: SubsystemA;\n\t\tpart def subsystemB: SubsystemB;\n\t\tattribute def configParams: String;\n\t}\n\n\t// System Context\n\tblock context ModularVehicleSystem {\n\t\tpart def config: VehicleConfigA | VehicleConfigB;\n\t\t// System-level constraints\n\t\tconstraint def validConfiguration {\n\t\t\t// Example: Ensure at least one component in each subsystem\n\t\t\tconfig.subsystemA.components->size() > 0;\n\t\t\tconfig.subsystemB.components->size() > 0;\n\t\t}\n\t\t// Interconnection\n\t\tassociation def connectSubsystems {\n\t\t\tend a: config.subsystemA.portA;\n\t\t\tend b: config.subsystemB.portB;\n\t\t}\n\t}\n\n\t// Customization at Subsystem and Component Level\n\tfeature def Customization {\n\t\tattribute def parameters: String;\n\t\tbehavior def customBehavior;\n\t}\n\n\t// Allocation of Components to Subsystems\n\taction def allocateComponent {\n\t\tin component: Component;\n\t\tin subsystem: Subsystem;\n\t\teffect {\n\t\t\tsubsystem.components += component;\n\t\t}\n\t}\n\n}",
    "package 'VehicleProductLineConfiguration' {\n\tattribute def PerformanceRequirement;\n\tattribute def UserPreference;\n\tattribute def EngineType;\n\tattribute def TransmissionType;\n\tattribute def WheelType;\n\tattribute def VehicleModelVariant;\n\tattribute def ConfigurationScheme;\n\n\tport def PerformanceReqPort {\n\t\tout performanceReq: PerformanceRequirement;\n\t}\n\tport def UserPrefPort {\n\t\tout userPref: UserPreference;\n\t}\n\tport def ConfigSchemePort {\n\t\tout configScheme: ConfigurationScheme;\n\t}\n\tport def ModelVariantPort {\n\t\tout modelVariant: VehicleModelVariant;\n\t}\n\n\tpart context {\n\t\tpart user {\n\t\t\tport performanceReqPort: PerformanceReqPort;\n\t\t\tport userPrefPort: UserPrefPort;\n\t\t\tport modelVariantPort: ModelVariantPort;\n\t\t\tperform configureVehicle.sendRequirements {\n\t\t\t\tout performanceReq = performanceReqPort.performanceReq;\n\t\t\t\tout userPref = userPrefPort.userPref;\n\t\t\t\tout modelVariant = modelVariantPort.modelVariant;\n\t\t\t}\n\t\t}\n\t\tpart configurationSystem {\n\t\t\tport performanceReqPort: ~PerformanceReqPort;\n\t\t\tport userPrefPort: ~UserPrefPort;\n\t\t\tport configSchemePort: ConfigSchemePort;\n\t\t\tport modelVariantPort: ~ModelVariantPort;\n\t\t\tperform configureVehicle.matchAndConfigure {\n\t\t\t\tin performanceReq = performanceReqPort.performanceReq;\n\t\t\t\tin userPref = userPrefPort.userPref;\n\t\t\t\tin modelVariant = modelVariantPort.modelVariant;\n\t\t\t\tout configScheme = configSchemePort.configScheme;\n\t\t\t}\n\t\t}\n\t\tinterface userToConfigSystem connect user.performanceReqPort to configurationSystem.performanceReqPort {\n\t\t\tref flow references configureVehicle.performanceReqFlow\n\t\t\t\tfrom source.performanceReq to target.performanceReq;\n\t\t}\n\t\tinterface userPrefToConfigSystem connect user.userPrefPort to configurationSystem.userPrefPort {\n\t\t\tref flow references configureVehicle.userPrefFlow\n\t\t\t\tfrom source.userPref to target.userPref;\n\t\t}\n\t\tinterface userModelVariantToConfigSystem connect user.modelVariantPort to configurationSystem.modelVariantPort {\n\t\t\tref flow references configureVehicle.modelVariantFlow\n\t\t\t\tfrom source.modelVariant to target.modelVariant;\n\t\t}\n\t}\n\n\taction configureVehicle {\n\t\taction sendRequirements {\n\t\t\tout performanceReq: PerformanceRequirement;\n\t\t\tout userPref: UserPreference;\n\t\t\tout modelVariant: VehicleModelVariant;\n\t\t}\n\t\tsuccession flow performanceReqFlow from sendRequirements.performanceReq to matchAndConfigure.performanceReq;\n\t\tsuccession flow userPrefFlow from sendRequirements.userPref to matchAndConfigure.userPref;\n\t\tsuccession flow modelVariantFlow from sendRequirements.modelVariant to matchAndConfigure.modelVariant;\n\n\t\taction matchAndConfigure {\n\t\t\tin performanceReq: PerformanceRequirement;\n\t\t\tin userPref: UserPreference;\n\t\t\tin modelVariant: VehicleModelVariant;\n\t\t\tout configScheme: ConfigurationScheme;\n\t\t}\n\t}\n\n\tclass ConfigurationScheme {\n\t\tattribute engine: EngineType;\n\t\tattribute transmission: TransmissionType;\n\t\tattribute wheels: WheelType;\n\t\tattribute modelVariant: VehicleModelVariant;\n\t}\n\n\tconstraint def HighPerformanceConfig {\n\t\tcontext ConfigurationScheme;\n\t\tengine = '6-cylinder' and transmission = 'automatic' and wheels = 'wide-rim'\n\t\tif performanceReq = 'high';\n\t}\n\n\tconstraint def StandardPerformanceConfig {\n\t\tcontext ConfigurationScheme;\n\t\tengine = '4-cylinder' and transmission = 'manual' and wheels = 'narrow-rim'\n\t\tif performanceReq = 'standard';\n\t}\n\n\tconstraint def CompatibilityConstraint {\n\t\tcontext ConfigurationScheme;\n\t\t(engine = '6-cylinder' implies transmission = 'automatic') and\n\t\t(wheels = 'wide-rim' implies engine = '6-cylinder');\n\t}\n\n\tconstraint def ValidConfiguration {\n\t\tcontext ConfigurationScheme;\n\t\tHighPerformanceConfig or StandardPerformanceConfig;\n\t}\n\n\tclass VehicleModelVariant {\n\t\tattribute name: String;\n\t}\n\n\t// The system supports multiple model variants and flexible expansion.\n}",
    "package 'AutomobileSystem' {\n\n\t// Attribute Definitions\n\tattribute def Mass;\n\tattribute def MassLimit;\n\tattribute def FuelStatus;\n\tattribute def Torque;\n\tattribute def ReliabilityMetric;\n\n\t// Port Definitions\n\tport def MassPort {\n\t\tout mass: Mass;\n\t}\n\tport def MassLimitPort {\n\t\tin massLimit: MassLimit;\n\t}\n\tport def FuelStatusPort {\n\t\tout fuelStatus: FuelStatus;\n\t}\n\tport def TorquePort {\n\t\tout torque: Torque;\n\t}\n\tport def DriveInterfacePort {\n\t\tin torque: Torque;\n\t}\n\tport def ReliabilityPort {\n\t\tout reliability: ReliabilityMetric;\n\t}\n\n\t// Part Definitions\n\tpart def Engine {\n\t\tport torquePort: TorquePort;\n\t\tperform deliverTorque {\n\t\t\tout torque = torquePort.torque;\n\t\t}\n\t}\n\tpart def Transmission {\n\t\tport driveInterfacePort: DriveInterfacePort;\n\t\tperform receiveTorque {\n\t\t\tin torque = driveInterfacePort.torque;\n\t\t}\n\t}\n\tpart def Vehicle {\n\t\tport massPort: MassPort;\n\t\tport massLimitPort: MassLimitPort;\n\t\tport fuelStatusPort: FuelStatusPort;\n\t\tport reliabilityPort: ReliabilityPort;\n\t\tpart engine: Engine;\n\t\tpart transmission: Transmission;\n\t\tport engineTorquePort: TorquePort;\n\t\tport transmissionDrivePort: DriveInterfacePort;\n\n\t\t// Mass and Fuel Management\n\t\tperform manageMass {\n\t\t\tout mass = massPort.mass;\n\t\t\tin massLimit = massLimitPort.massLimit;\n\t\t}\n\t\tperform manageFuelStatus {\n\t\t\tout fuelStatus = fuelStatusPort.fuelStatus;\n\t\t}\n\t\t// Reliability Tracking\n\t\tperform trackReliability {\n\t\t\tout reliability = reliabilityPort.reliability;\n\t\t}\n\t\t// Powertrain Connection\n\t\tperform connectPowertrain {\n\t\t\tout torque = engineTorquePort.torque;\n\t\t\tin torque = transmissionDrivePort.torque;\n\t\t}\n\t\t// Internal Connections\n\t\tinterface engineToVehicle connect engine.torquePort to engineTorquePort {\n\t\t\tref flow from source.torque to target.torque;\n\t\t}\n\t\tinterface vehicleToTransmission connect transmissionDrivePort to transmission.driveInterfacePort {\n\t\t\tref flow from source.torque to target.torque;\n\t\t}\n\t}\n\n\t// Context Definition\n\tpart context {\n\t\tpart vehicle2000kg: Vehicle {\n\t\t\tmassPort.mass = 2000;\n\t\t\tmassLimitPort.massLimit = 2000;\n\t\t\tfuelStatusPort.fuelStatus = 'full';\n\t\t}\n\t\tpart vehicle2500kg: Vehicle {\n\t\t\tmassPort.mass = 2500;\n\t\t\tmassLimitPort.massLimit = 2500;\n\t\t\tfuelStatusPort.fuelStatus = 'empty';\n\t\t}\n\t}\n\n\t// Requirement Definitions\n\trequirement def MassCompliance {\n\t\ttext = \"Each vehicle shall not exceed its specified maximum mass limit.\";\n\t}\n\trequirement def FuelStatusCompliance {\n\t\ttext = \"Vehicles shall meet mass requirements in either fully fueled or empty-fuel state as specified.\";\n\t}\n\trequirement def PowertrainConnection {\n\t\ttext = \"The engine shall output torque and be connected to the transmission via a drive interface for reliable power transfer.\";\n\t}\n\trequirement def ReliabilityTracking {\n\t\ttext = \"Vehicles shall track and fulfill specified reliability metrics throughout their lifecycle.\";\n\t}\n\n\t// Requirement Allocation\n\tallocate MassCompliance to Vehicle.manageMass;\n\tallocate FuelStatusCompliance to Vehicle.manageFuelStatus;\n\tallocate PowertrainConnection to Vehicle.connectPowertrain;\n\tallocate ReliabilityTracking to Vehicle.trackReliability;\n\n\t// Validation Actions\n\taction validateMassCompliance {\n\t\tin mass: Mass;\n\t\tin massLimit: MassLimit;\n\t\tassert mass <= massLimit;\n\t}\n\taction validateFuelStatusCompliance {\n\t\tin fuelStatus: FuelStatus;\n\t\tassert fuelStatus in {'full', 'empty'};\n\t}\n\taction validatePowertrainConnection {\n\t\tin torque: Torque;\n\t\tassert torque > 0;\n\t}\n\taction validateReliabilityTracking {\n\t\tin reliability: ReliabilityMetric;\n\t\tassert reliability >= requiredReliability;\n\t}\n\n}",
    "package 'VehicleMassCompliance' {\n\tattribute def VehicleId;\n\tattribute def Mass;\n\tattribute def ComplianceStatus;\n\tattribute def MaxPermissibleMass;\n\t\n\tport def VehiclePort {\n\t\tout vehicleId: VehicleId;\n\t}\n\tport def MassPort {\n\t\tout mass: Mass;\n\t}\n\tport def CompliancePort {\n\t\tout complianceStatus: ComplianceStatus;\n\t}\n\tport def MaxMassPort {\n\t\tout maxPermissibleMass: MaxPermissibleMass;\n\t}\n\t\n\tpart context {\n\t\tpart testOperator {\n\t\t\tport vehiclePort: VehiclePort;\n\t\t\tport massPort: MassPort;\n\t\t\tperform massComplianceTest.measureVehicleMass {\n\t\t\t\tout vehicleId = vehiclePort.vehicleId;\n\t\t\t\tout mass = massPort.mass;\n\t\t\t}\n\t\t}\n\t\tpart weighingEquipment {\n\t\t\tport massPort: ~MassPort;\n\t\t\tperform massComplianceTest.provideMassMeasurement {\n\t\t\t\tout mass = massPort.mass;\n\t\t\t}\n\t\t}\n\t\tpart complianceSystem {\n\t\t\tport vehiclePort: ~VehiclePort;\n\t\t\tport massPort: ~MassPort;\n\t\t\tport maxMassPort: MaxMassPort;\n\t\t\tport compliancePort: CompliancePort;\n\t\t\tperform massComplianceTest.determineCompliance {\n\t\t\t\tin vehicleId = vehiclePort.vehicleId;\n\t\t\t\tin mass = massPort.mass;\n\t\t\t\tin maxPermissibleMass = maxMassPort.maxPermissibleMass;\n\t\t\t\tout complianceStatus = compliancePort.complianceStatus;\n\t\t\t}\n\t\t}\n\t}\n\t\n\taction massComplianceTest {\n\t\taction measureVehicleMass {\n\t\t\tout vehicleId: VehicleId;\n\t\t\tout mass: Mass;\n\t\t}\n\t\taction provideMassMeasurement {\n\t\t\tout mass: Mass;\n\t\t}\n\t\taction determineCompliance {\n\t\t\tin vehicleId: VehicleId;\n\t\t\tin mass: Mass;\n\t\t\tin maxPermissibleMass: MaxPermissibleMass;\n\t\t\tout complianceStatus: ComplianceStatus;\n\t\t}\n\t\tsuccession flow vehicleIdFlow from measureVehicleMass.vehicleId to determineCompliance.vehicleId;\n\t\tsuccession flow massFlow from provideMassMeasurement.mass to determineCompliance.mass;\n\t\tsuccession flow maxMassFlow from determineCompliance.maxPermissibleMass to determineCompliance.maxPermissibleMass;\n\t}\n\t\n\tenumeration ComplianceStatusEnum {\n\t\tvalue Compliant;\n\t\tvalue NonCompliant;\n\t}\n}",
    "package 'WaterSupplyNetwork' {\n\tattribute def HotWater;\n\tattribute def ColdWater;\n\n\tport def HotWaterPort {\n\t\tout hotWater: HotWater;\n\t}\n\tport def ColdWaterPort {\n\t\tout coldWater: ColdWater;\n\t}\n\n\tpart context {\n\t\tpart spigotBank {\n\t\t\tport hotWaterPort: HotWaterPort;\n\t\t\tport coldWaterPort: ColdWaterPort;\n\t\t\tperform distributeWater.supplyHotWater {\n\t\t\t\tout hotWater = hotWaterPort.hotWater;\n\t\t\t}\n\t\t\tperform distributeWater.supplyColdWater {\n\t\t\t\tout coldWater = coldWaterPort.coldWater;\n\t\t\t}\n\t\t}\n\n\t\tpart faucet[1..*] {\n\t\t\tport hotInlet: ~HotWaterPort;\n\t\t\tport coldInlet: ~ColdWaterPort;\n\t\t\tperform distributeWater.receiveHotWater {\n\t\t\t\tin hotWater = hotInlet.hotWater;\n\t\t\t}\n\t\t\tperform distributeWater.receiveColdWater {\n\t\t\t\tin coldWater = coldInlet.coldWater;\n\t\t\t}\n\t\t}\n\n\t\tinterface hotWaterConnection connect spigotBank.hotWaterPort to faucet.hotInlet {\n\t\t\tref flow references distributeWater.hotWaterFlow\n\t\t\t\tfrom source.hotWater to target.hotWater;\n\t\t}\n\t\tinterface coldWaterConnection connect spigotBank.coldWaterPort to faucet.coldInlet {\n\t\t\tref flow references distributeWater.coldWaterFlow\n\t\t\t\tfrom source.coldWater to target.coldWater;\n\t\t}\n\t}\n\n\taction distributeWater {\n\t\taction supplyHotWater { out hotWater: HotWater; }\n\t\taction supplyColdWater { out coldWater: ColdWater; }\n\t\tsuccession flow hotWaterFlow from supplyHotWater.hotWater to receiveHotWater.hotWater;\n\t\tsuccession flow coldWaterFlow from supplyColdWater.coldWater to receiveColdWater.coldWater;\n\t\taction receiveHotWater { in hotWater: HotWater; }\n\t\taction receiveColdWater { in coldWater: ColdWater; }\n\t}\n}",
    "package 'VehicleQualityAnalysisSystem' {\n\tattribute def QualityData;\n\tattribute def Mass;\n\tattribute def AnalysisRequirement;\n\tattribute def AnalysisObjective;\n\tattribute def AnalysisTask;\n\tattribute def AnalysisPlan;\n\tattribute def EvaluationResult;\n\n\tport def QualityDataPort {\n\t\tin qualityData: QualityData;\n\t}\n\tport def MassPort {\n\t\tout mass: Mass;\n\t}\n\tport def AnalysisRequirementPort {\n\t\tin analysisRequirement: AnalysisRequirement;\n\t}\n\tport def AnalysisObjectivePort {\n\t\tin analysisObjective: AnalysisObjective;\n\t}\n\tport def AnalysisTaskPort {\n\t\tout analysisTask: AnalysisTask;\n\t}\n\tport def AnalysisPlanPort {\n\t\tout analysisPlan: AnalysisPlan;\n\t}\n\tport def EvaluationResultPort {\n\t\tout evaluationResult: EvaluationResult;\n\t}\n\n\tpart context {\n\t\tpart user {\n\t\t\tport qualityDataPort: QualityDataPort;\n\t\t\tport analysisRequirementPort: AnalysisRequirementPort;\n\t\t\tport analysisObjectivePort: AnalysisObjectivePort;\n\t\t\tperform manageQuality.inputQualityData {\n\t\t\t\tout qualityData = qualityDataPort.qualityData;\n\t\t\t}\n\t\t\tperform manageQuality.defineAnalysisRequirement {\n\t\t\t\tout analysisRequirement = analysisRequirementPort.analysisRequirement;\n\t\t\t}\n\t\t\tperform manageQuality.setAnalysisObjective {\n\t\t\t\tout analysisObjective = analysisObjectivePort.analysisObjective;\n\t\t\t}\n\t\t}\n\t\tpart vehicle {\n\t\t\tport massPort: MassPort;\n\t\t\tpart engine {\n\t\t\t\tport qualityDataPort: ~QualityDataPort;\n\t\t\t}\n\t\t\tpart transmission {\n\t\t\t\tport qualityDataPort: ~QualityDataPort;\n\t\t\t}\n\t\t\tpart frontAxleAssembly {\n\t\t\t\tport qualityDataPort: ~QualityDataPort;\n\t\t\t}\n\t\t\tpart rearAxleAssembly {\n\t\t\t\tport qualityDataPort: ~QualityDataPort;\n\t\t\t}\n\t\t\tperform manageQuality.aggregateMass {\n\t\t\t\tin engineQuality = engine.qualityDataPort.qualityData;\n\t\t\t\tin transmissionQuality = transmission.qualityDataPort.qualityData;\n\t\t\t\tin frontAxleQuality = frontAxleAssembly.qualityDataPort.qualityData;\n\t\t\t\tin rearAxleQuality = rearAxleAssembly.qualityDataPort.qualityData;\n\t\t\t\tout mass = massPort.mass;\n\t\t\t}\n\t\t}\n\t\tpart qualityAnalysisSystem {\n\t\t\tport analysisRequirementPort: ~AnalysisRequirementPort;\n\t\t\tport analysisObjectivePort: ~AnalysisObjectivePort;\n\t\t\tport analysisTaskPort: AnalysisTaskPort;\n\t\t\tport analysisPlanPort: AnalysisPlanPort;\n\t\t\tport evaluationResultPort: EvaluationResultPort;\n\t\t\tperform manageQuality.formulateAnalysisUseCase {\n\t\t\t\tin analysisRequirement = analysisRequirementPort.analysisRequirement;\n\t\t\t}\n\t\t\tperform manageQuality.generateAnalysisTaskAndPlan {\n\t\t\t\tin analysisObjective = analysisObjectivePort.analysisObjective;\n\t\t\t\tout analysisTask = analysisTaskPort.analysisTask;\n\t\t\t\tout analysisPlan = analysisPlanPort.analysisPlan;\n\t\t\t}\n\t\t\tperform manageQuality.evaluateAndTrackRequirements {\n\t\t\t\tin analysisTask = analysisTaskPort.analysisTask;\n\t\t\t\tin analysisPlan = analysisPlanPort.analysisPlan;\n\t\t\t\tout evaluationResult = evaluationResultPort.evaluationResult;\n\t\t\t}\n\t\t}\n\t}\n\n\taction manageQuality {\n\t\taction inputQualityData { out qualityData: QualityData; }\n\t\taction defineAnalysisRequirement { out analysisRequirement: AnalysisRequirement; }\n\t\taction setAnalysisObjective { out analysisObjective: AnalysisObjective; }\n\t\taction aggregateMass {\n\t\t\tin engineQuality: QualityData;\n\t\t\tin transmissionQuality: QualityData;\n\t\t\tin frontAxleQuality: QualityData;\n\t\t\tin rearAxleQuality: QualityData;\n\t\t\tout mass: Mass;\n\t\t}\n\t\taction formulateAnalysisUseCase { in analysisRequirement: AnalysisRequirement; }\n\t\taction generateAnalysisTaskAndPlan {\n\t\t\tin analysisObjective: AnalysisObjective;\n\t\t\tout analysisTask: AnalysisTask;\n\t\t\tout analysisPlan: AnalysisPlan;\n\t\t}\n\t\taction evaluateAndTrackRequirements {\n\t\t\tin analysisTask: AnalysisTask;\n\t\t\tin analysisPlan: AnalysisPlan;\n\t\t\tout evaluationResult: EvaluationResult;\n\t\t}\n\t}\n}",
    "package 'VehiclePowertrainConfiguration' {\n\n\tattribute def EngineType;\n\tattribute def Power;\n\tattribute def Mass;\n\tattribute def Efficiency;\n\tattribute def Reliability;\n\tattribute def Cost;\n\tattribute def PerformanceScore;\n\tattribute def Explanation;\n\tattribute def EngineConfig;\n\tattribute def ComponentList;\n\n\tport def EngineConfigPort {\n\t\tout engineConfig: EngineConfig;\n\t}\n\tport def PerformanceDataPort {\n\t\tout power: Power;\n\t\tout mass: Mass;\n\t\tout efficiency: Efficiency;\n\t\tout reliability: Reliability;\n\t\tout cost: Cost;\n\t}\n\tport def RecommendationPort {\n\t\tout recommendedConfig: EngineConfig;\n\t\tout explanation: Explanation;\n\t}\n\n\tpart context {\n\t\tpart user {\n\t\t\tport recommendationPort: ~RecommendationPort;\n\t\t\tperform configurePowertrain.requestRecommendation {\n\t\t\t\tout recommendedConfig = recommendationPort.recommendedConfig;\n\t\t\t\tout explanation = recommendationPort.explanation;\n\t\t\t}\n\t\t}\n\t\tpart powertrainConfigSystem {\n\t\t\tport engineConfigPort: EngineConfigPort;\n\t\t\tport performanceDataPort: PerformanceDataPort;\n\t\t\tport recommendationPort: RecommendationPort;\n\n\t\t\tperform configurePowertrain.modelEngines {\n\t\t\t\tout engineConfig = engineConfigPort.engineConfig;\n\t\t\t\tout componentList: ComponentList;\n\t\t\t}\n\t\t\tperform configurePowertrain.evaluateEngines {\n\t\t\t\tin engineConfig = engineConfigPort.engineConfig;\n\t\t\t\tout power = performanceDataPort.power;\n\t\t\t\tout mass = performanceDataPort.mass;\n\t\t\t\tout efficiency = performanceDataPort.efficiency;\n\t\t\t\tout reliability = performanceDataPort.reliability;\n\t\t\t\tout cost = performanceDataPort.cost;\n\t\t\t\tout performanceScore: PerformanceScore;\n\t\t\t}\n\t\t\tperform configurePowertrain.recommendEngine {\n\t\t\t\tin performanceScore;\n\t\t\t\tin engineConfig;\n\t\t\t\tout recommendedConfig = recommendationPort.recommendedConfig;\n\t\t\t\tout explanation = recommendationPort.explanation;\n\t\t\t}\n\t\t}\n\t}\n\n\taction configurePowertrain {\n\t\taction requestRecommendation {\n\t\t\tout recommendedConfig: EngineConfig;\n\t\t\tout explanation: Explanation;\n\t\t}\n\t\taction modelEngines {\n\t\t\tout engineConfig: EngineConfig;\n\t\t\tout componentList: ComponentList;\n\t\t}\n\t\taction evaluateEngines {\n\t\t\tin engineConfig: EngineConfig;\n\t\t\tout power: Power;\n\t\t\tout mass: Mass;\n\t\t\tout efficiency: Efficiency;\n\t\t\tout reliability: Reliability;\n\t\t\tout cost: Cost;\n\t\t\tout performanceScore: PerformanceScore;\n\t\t}\n\t\taction recommendEngine {\n\t\t\tin performanceScore: PerformanceScore;\n\t\t\tin engineConfig: EngineConfig;\n\t\t\tout recommendedConfig: EngineConfig;\n\t\t\tout explanation: Explanation;\n\t\t}\n\t\tsuccession flow configFlow from modelEngines.engineConfig to evaluateEngines.engineConfig;\n\t\tsuccession flow evalFlow from evaluateEngines.performanceScore to recommendEngine.performanceScore;\n\t\tsuccession flow recFlow from recommendEngine.recommendedConfig to requestRecommendation.recommendedConfig;\n\t\tsuccession flow expFlow from recommendEngine.explanation to requestRecommendation.explanation;\n\t}\n\n\tblock Engine {\n\t\tattribute engineType: EngineType;\n\t\tattribute cylinders: Integer;\n\t\tattribute pistons: Integer;\n\t\tattribute connectingRods: Integer;\n\t\tattribute crankshaft: Boolean;\n\t\tattribute power: Power;\n\t\tattribute mass: Mass;\n\t\tattribute efficiency: Efficiency;\n\t\tattribute reliability: Reliability;\n\t\tattribute cost: Cost;\n\t}\n\tblock EngineConfig {\n\t\tattribute engineType: EngineType;\n\t\tattribute structure: String;\n\t\tattribute componentList: ComponentList;\n\t}\n\tblock ComponentList {\n\t\tattribute cylinders: Integer;\n\t\tattribute pistons: Integer;\n\t\tattribute connectingRods: Integer;\n\t\tattribute crankshaft: Boolean;\n\t}\n\tblock EvaluationModel {\n\t\tattribute weights: Map<String, Real>;\n\t\toperation evaluate(engineConfig: EngineConfig): PerformanceScore;\n\t}\n}",
    "package 'VehicleFuelEconomy' {\n\tattribute def FuelEconomy; // miles per gallon\n\tattribute def Load; // pounds\n\tattribute def Distance; // miles\n\tattribute def FuelVolume; // gallons (US, 231 in^3)\n\tattribute def Scenario; // 'urban' or 'highway'\n\tattribute def Powertrain;\n\tattribute def OperatingCondition;\n\n\tport def FuelEconomyPort {\n\t\tout fuelEconomy: FuelEconomy;\n\t}\n\tport def ScenarioPort {\n\t\tin scenario: Scenario;\n\t}\n\tport def LoadPort {\n\t\tin load: Load;\n\t}\n\tport def PowertrainPort {\n\t\tin powertrain: Powertrain;\n\t}\n\tport def OperatingConditionPort {\n\t\tin operatingCondition: OperatingCondition;\n\t}\n\n\tpart context {\n\t\tpart vehicle {\n\t\t\tport scenarioPort: ScenarioPort;\n\t\t\tport loadPort: LoadPort;\n\t\t\tport powertrainPort: PowertrainPort;\n\t\t\tport operatingConditionPort: OperatingConditionPort;\n\t\t\tport fuelEconomyPort: FuelEconomyPort;\n\n\t\t\tperform assessFuelEconomy.evaluate {\n\t\t\t\tin scenario = scenarioPort.scenario;\n\t\t\t\tin load = loadPort.load;\n\t\t\t\tin powertrain = powertrainPort.powertrain;\n\t\t\t\tin operatingCondition = operatingConditionPort.operatingCondition;\n\t\t\t\tout fuelEconomy = fuelEconomyPort.fuelEconomy;\n\t\t\t}\n\t\t}\n\t}\n\n\taction assessFuelEconomy {\n\t\taction evaluate {\n\t\t\tin scenario: Scenario;\n\t\t\tin load: Load;\n\t\t\tin powertrain: Powertrain;\n\t\t\tin operatingCondition: OperatingCondition;\n\t\t\tout fuelEconomy: FuelEconomy;\n\t\t}\n\t}\n\n\tconstraint def UrbanFuelEconomyMinimum {\n\t\tcontext scenario: Scenario, fuelEconomy: FuelEconomy;\n\t\tif scenario = 'urban' then fuelEconomy >= 25;\n\t}\n\tconstraint def HighwayFuelEconomyMinimum {\n\t\tcontext scenario: Scenario, fuelEconomy: FuelEconomy;\n\t\tif scenario = 'highway' then fuelEconomy >= 30;\n\t}\n\tconstraint def FuelEconomyUnit {\n\t\tcontext fuelEconomy: FuelEconomy, fuelVolume: FuelVolume;\n\t\tfuelVolume.unit = 'gallon_US' and 1 gallon_US = 231 cubic_inch;\n\t}\n\tconstraint def TestLoad {\n\t\tcontext load: Load;\n\t\tload = 1000;\n\t}\n}\n",
    "package 'VehicleLongitudinalDynamics' {\n\tattribute def VehicleMass;\n\tattribute def Position;\n\tattribute def Velocity;\n\tattribute def Acceleration;\n\tattribute def PowerOutput;\n\tattribute def TimeStep;\n\tattribute def Time;\n\tattribute def AccelerationSeq;\n\tattribute def VelocitySeq;\n\tattribute def PositionSeq;\n\n\tport def InputPort {\n\t\tin vehicleMass: VehicleMass;\n\t\tin initialPosition: Position;\n\t\tin initialVelocity: Velocity;\n\t\tin powerOutputSeq: PowerOutput[];\n\t\tin timeStep: TimeStep;\n\t}\n\tport def OutputPort {\n\t\tout accelerationSeq: AccelerationSeq;\n\t\tout velocitySeq: VelocitySeq;\n\t\tout positionSeq: PositionSeq;\n\t}\n\n\tpart context {\n\t\tpart user {\n\t\t\tport inputPort: InputPort;\n\t\t\tperform simulateVehicleDynamics.provideInputs {\n\t\t\t\tout vehicleMass = inputPort.vehicleMass;\n\t\t\t\tout initialPosition = inputPort.initialPosition;\n\t\t\t\tout initialVelocity = inputPort.initialVelocity;\n\t\t\t\tout powerOutputSeq = inputPort.powerOutputSeq;\n\t\t\t\tout timeStep = inputPort.timeStep;\n\t\t\t}\n\t\t}\n\t\tpart simulationSystem {\n\t\t\tport inputPort: ~InputPort;\n\t\t\tport outputPort: OutputPort;\n\t\t\tperform simulateVehicleDynamics.computeDynamics {\n\t\t\t\tin vehicleMass = inputPort.vehicleMass;\n\t\t\t\tin initialPosition = inputPort.initialPosition;\n\t\t\t\tin initialVelocity = inputPort.initialVelocity;\n\t\t\t\tin powerOutputSeq = inputPort.powerOutputSeq;\n\t\t\t\tin timeStep = inputPort.timeStep;\n\t\t\t\tout accelerationSeq = outputPort.accelerationSeq;\n\t\t\t\tout velocitySeq = outputPort.velocitySeq;\n\t\t\t\tout positionSeq = outputPort.positionSeq;\n\t\t\t}\n\t\t}\n\t\tinterface userToSystem connect user.inputPort to simulationSystem.inputPort {\n\t\t\tref flow references simulateVehicleDynamics.inputFlow\n\t\t\t\tfrom source.vehicleMass to target.vehicleMass,\n\t\t\t\tfrom source.initialPosition to target.initialPosition,\n\t\t\t\tfrom source.initialVelocity to target.initialVelocity,\n\t\t\t\tfrom source.powerOutputSeq to target.powerOutputSeq,\n\t\t\t\tfrom source.timeStep to target.timeStep;\n\t\t}\n\t}\n\n\taction simulateVehicleDynamics {\n\t\taction provideInputs {\n\t\t\tout vehicleMass: VehicleMass;\n\t\t\tout initialPosition: Position;\n\t\t\tout initialVelocity: Velocity;\n\t\t\tout powerOutputSeq: PowerOutput[];\n\t\t\tout timeStep: TimeStep;\n\t\t}\n\t\tsuccession flow inputFlow from provideInputs.vehicleMass to computeDynamics.vehicleMass,\n\t\t\tfrom provideInputs.initialPosition to computeDynamics.initialPosition,\n\t\t\tfrom provideInputs.initialVelocity to computeDynamics.initialVelocity,\n\t\t\tfrom provideInputs.powerOutputSeq to computeDynamics.powerOutputSeq,\n\t\t\tfrom provideInputs.timeStep to computeDynamics.timeStep;\n\t\taction computeDynamics {\n\t\t\tin vehicleMass: VehicleMass;\n\t\t\tin initialPosition: Position;\n\t\t\tin initialVelocity: Velocity;\n\t\t\tin powerOutputSeq: PowerOutput[];\n\t\t\tin timeStep: TimeStep;\n\t\t\tout accelerationSeq: AccelerationSeq;\n\t\t\tout velocitySeq: VelocitySeq;\n\t\t\tout positionSeq: PositionSeq;\n\t\t}\n\t}\n}",
    "package 'VehicleSystem' {\n\tattribute def Mass : Real;\n\tattribute def SteeringAngle : Real;\n\n\tpart def Wheel {\n\t\t// Wheel-specific attributes can be added in further detail\n\t}\n\n\tpart def FrontAxle {\n\t\tattribute mass: Mass;\n\t\tattribute steeringAngle: SteeringAngle;\n\t}\n\n\tpart def RearAxle {\n\t\tattribute mass: Mass;\n\t}\n\n\tpart def FrontAxleAssembly {\n\t\tattribute mass: Mass;\n\t\tpart frontLeftWheel: Wheel;\n\t\tpart frontRightWheel: Wheel;\n\t\tpart frontAxle: FrontAxle;\n\t}\n\n\tpart def RearAxleAssembly {\n\t\tattribute mass: Mass;\n\t\tpart rearLeftWheel: Wheel;\n\t\tpart rearRightWheel: Wheel;\n\t\tpart rearAxle: RearAxle;\n\t}\n\n\tpart def Car {\n\t\tattribute totalMass: Mass;\n\t\tpart frontAxleAssembly: FrontAxleAssembly;\n\t\tpart rearAxleAssembly: RearAxleAssembly;\n\t}\n\n\tpart context {\n\t\tpart car: Car {\n\t\t\ttotalMass = 2500.0;\n\t\t\tfrontAxleAssembly: FrontAxleAssembly {\n\t\t\t\tmass = 150.0;\n\t\t\t\tfrontAxle: FrontAxle {\n\t\t\t\t\tmass = 150.0;\n\t\t\t\t\tsteeringAngle = 0.0;\n\t\t\t\t}\n\t\t\t}\n\t\t\trearAxleAssembly: RearAxleAssembly {\n\t\t\t\tmass = 250.0;\n\t\t\t\trearAxle: RearAxle {\n\t\t\t\t\tmass = 250.0;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n}",
    "package 'VehicleSafetySecurityManagement' {\n\n\t// Feature Types\n\tfeature def SafetyFeature;\n\tfeature def SecurityFeature;\n\n\t// Feature Categories\n\tfeature def MandatorySafetyFeature extends SafetyFeature;\n\tfeature def OptionalSafetyFeature extends SafetyFeature;\n\n\t// Component Types\n\tblock def SeatBelt {\n\t\tfeature seatBeltFeature: MandatorySafetyFeature;\n\t}\n\tblock def Bumper {\n\t\tfeature bumperFeature: MandatorySafetyFeature;\n\t}\n\tblock def Airbag {\n\t\tfeature airbagFeature: OptionalSafetyFeature;\n\t}\n\tblock def AntiLockBrakingSystem {\n\t\tfeature absFeature: OptionalSafetyFeature;\n\t}\n\tblock def AlarmDevice {\n\t\tfeature alarmFeature: SecurityFeature;\n\t}\n\tblock def KeylessEntrySystem {\n\t\tfeature keylessEntryFeature: SecurityFeature;\n\t}\n\n\t// Vehicle Structure\n\tblock def Vehicle {\n\t\tpart seatBelt: SeatBelt;\n\t\tpart bumper: Bumper;\n\t\tpart airbag?: Airbag;\n\t\tpart abs?: AntiLockBrakingSystem;\n\t\tpart alarmDevice: AlarmDevice;\n\t\tpart keylessEntrySystem: KeylessEntrySystem;\n\t}\n\n\t// System Context\n\tblock def User;\n\tblock def SafetySecurityManagementSystem {\n\t\tpart vehicle: Vehicle;\n\t\tpart user: User;\n\n\t\t// Interfaces for filtering and visualization\n\t\tport def FilterRequestPort {\n\t\t\tin filterType: String;\n\t\t}\n\t\tport def VisualizationPort {\n\t\t\tout visualizationData: VisualizationData;\n\t\t}\n\t\tpart filterRequestPort: FilterRequestPort;\n\t\tpart visualizationPort: VisualizationPort;\n\t}\n\n\t// Visualization Data Structure\n\tblock def VisualizationData {\n\t\tattribute dataFormat: String;\n\t\tattribute dataContent: String;\n\t}\n\n\t// Actions\n\taction def FilterAndOrganizeFeatures {\n\t\tin filterType: String;\n\t\tin vehicle: Vehicle;\n\t\tout filteredFeatures: FeatureList;\n\t}\n\taction def VisualizeFeatures {\n\t\tin filteredFeatures: FeatureList;\n\t\tin format: String;\n\t\tout visualizationData: VisualizationData;\n\t}\n\n\t// Feature List Structure\n\tblock def FeatureList {\n\t\tattribute features: List<SafetyFeature|SecurityFeature>;\n\t}\n\n\t// Succession/Flows\n\tbehavior def SafetySecurityManagementBehavior {\n\t\taction userRequestsFilter {\n\t\t\tout filterType: String;\n\t\t}\n\t\taction systemFiltersFeatures {\n\t\t\tin filterType: String;\n\t\t\tin vehicle: Vehicle;\n\t\t\tout filteredFeatures: FeatureList;\n\t\t}\n\t\taction systemVisualizesFeatures {\n\t\t\tin filteredFeatures: FeatureList;\n\t\t\tin format: String;\n\t\t\tout visualizationData: VisualizationData;\n\t\t}\n\t\tsuccession flow filterRequestFlow from userRequestsFilter.filterType to systemFiltersFeatures.filterType;\n\t\tsuccession flow featureFilterFlow from systemFiltersFeatures.filteredFeatures to systemVisualizesFeatures.filteredFeatures;\n\t}\n\n\t// Visualization Formats\n\tenum def VisualizationFormat {\n\t\tTree;\n\t\tTable;\n\t}\n\n}",
    "package 'LayeredSystem' {\n\tattribute def x;\n\tattribute def y;\n\tattribute def z;\n\n\tpart context {\n\t\tpart applicationLayer {\n\t\t\tperform systemBehavior.useService {\n\t\t\t\tout funcCall: ServiceFunctionality;\n\t\t\t}\n\t\t\tport servicePort: ServicePort;\n\t\t}\n\t\tpart serviceLayer {\n\t\t\tport servicePort: ~ServicePort;\n\t\t\tperform systemBehavior.provideService {\n\t\t\t\tin funcCall: ServiceFunctionality;\n\t\t\t\tout dataReq: DataRequest;\n\t\t\t\tout dataResp: DataResponse;\n\t\t\t}\n\t\t\tport dataPort: DataPort;\n\t\t}\n\t\tpart dataLayer {\n\t\t\tport dataPort: ~DataPort;\n\t\t\tperform systemBehavior.handleData {\n\t\t\t\tin dataReq: DataRequest;\n\t\t\t\tout dataResp: DataResponse;\n\t\t\t}\n\t\t}\n\t\tinterface appToService connect applicationLayer.servicePort to serviceLayer.servicePort {\n\t\t\tref flow references systemBehavior.funcCallFlow\n\t\t\t\tfrom source.funcCall to target.funcCall;\n\t\t}\n\t\tinterface serviceToData connect serviceLayer.dataPort to dataLayer.dataPort {\n\t\t\tref flow references systemBehavior.dataReqFlow\n\t\t\t\tfrom source.dataReq to target.dataReq;\n\t\t\tref flow references systemBehavior.dataRespFlow\n\t\t\t\tfrom source.dataResp to target.dataResp;\n\t\t}\n\t}\n\n\taction systemBehavior {\n\t\taction useService { out funcCall: ServiceFunctionality; }\n\t\tsuccession flow funcCallFlow from useService.funcCall to provideService.funcCall;\n\t\taction provideService {\n\t\t\tin funcCall: ServiceFunctionality;\n\t\t\tout dataReq: DataRequest;\n\t\t\tout dataResp: DataResponse;\n\t\t}\n\t\tsuccession flow dataReqFlow from provideService.dataReq to handleData.dataReq;\n\t\tsuccession flow dataRespFlow from handleData.dataResp to provideService.dataResp;\n\t\taction handleData {\n\t\t\tin dataReq: DataRequest;\n\t\t\tout dataResp: DataResponse;\n\t\t}\n\t}\n\n\tattribute def x;\n\tattribute def y;\n\tattribute def z = computeZ(x, y);\n\n\tfunction computeZ(x, y): z;\n\n\ttype ServiceFunctionality;\n\ttype DataRequest;\n\ttype DataResponse;\n\t\n\t// Layer ports\n\tport def ServicePort {\n\t\tin funcCall: ServiceFunctionality;\n\t}\n\tport def DataPort {\n\t\tin dataReq: DataRequest;\n\t\tout dataResp: DataResponse;\n\t}\n}",
    "package 'PowertrainTorqueGeneration' {\n\tattribute def Torque {\n\t\tunit = 'Nm';\n\t}\n\tattribute def TorqueCmd;\n\tport def TorqueCmdPort {\n\t\tout torqueCmd: TorqueCmd;\n\t}\n\tport def TorquePort {\n\t\tout torque: Torque;\n\t}\n\tpart context {\n\t\tpart logicLayer {\n\t\t\tport torqueCmdPort: TorqueCmdPort;\n\t\t\tperform generateTorque.sendTorqueCmd {\n\t\t\t\tout torqueCmd = torqueCmdPort.torqueCmd;\n\t\t\t}\n\t\t}\n\t\tpart physicalLayer {\n\t\t\tpart engine {\n\t\t\t\tport torqueCmdPort: ~TorqueCmdPort;\n\t\t\t\tport torquePort: TorquePort;\n\t\t\t\tperform generateTorque.produceTorque {\n\t\t\t\t\tin torqueCmd = torqueCmdPort.torqueCmd;\n\t\t\t\t\tout torque = torquePort.torque;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tinterface logicToPhysical connect logicLayer.torqueCmdPort to physicalLayer.engine.torqueCmdPort {\n\t\t\tref flow references generateTorque.torqueCmdFlow\n\t\t\t\tfrom source.torqueCmd to target.torqueCmd;\n\t\t}\n\t}\n\taction generateTorque {\n\t\taction sendTorqueCmd { out torqueCmd: TorqueCmd; }\n\t\tsuccession flow torqueCmdFlow from sendTorqueCmd.torqueCmd to produceTorque.torqueCmd;\n\t\taction produceTorque { \n\t\t\tin torqueCmd; \n\t\t\tout torque: Torque; \n\t\t\trequire torque > 0;\n\t\t}\n\t}\n}",
    "package 'PowerTransmissionSystem' {\n\tattribute def Power;\n\tattribute def Torque;\n\n\tport def PowerPort {\n\t\tout power: Power;\n\t}\n\tport def TorquePort {\n\t\tout torque: Torque;\n\t}\n\n\tpart context {\n\t\tpart system {\n\t\t\tport powerPort: PowerPort;\n\t\t\tport torquePort: TorquePort;\n\n\t\t\tperform transmitAndOutputPower.providePower {\n\t\t\t\tout power = powerPort.power;\n\t\t\t}\n\t\t\tperform transmitAndOutputPower.generateTorque {\n\t\t\t\tout torque = torquePort.torque;\n\t\t\t}\n\t\t}\n\n\t\tpart powertrain {\n\t\t\tpart engine {\n\t\t\t\tport torquePort: ~TorquePort;\n\t\t\t\tperform transmitAndOutputPower.engineGenerateTorque {\n\t\t\t\t\tout torque = torquePort.torque;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\taction transmitAndOutputPower {\n\t\taction providePower { out power: Power; }\n\t\taction generateTorque { out torque: Torque; }\n\t\taction engineGenerateTorque { out torque: Torque; }\n\n\t\tallocation mapTorqueGenToEngine {\n\t\t\tsource = generateTorque;\n\t\t\ttarget = engineGenerateTorque;\n\t\t}\n\t}\n\t\n\tpart torqueGenerator {\n\t\tperform transmitAndOutputPower.generateTorque;\n\t}\n}",
    "package 'VehicleSafetyAndAntiTheft' {\n\n\t// Enumerations for component categories and requirement types\n\tenum def ComponentCategory {\n\t\tsafety,\n\t\tantiTheft,\n\t\tboth\n\t}\n\tenum def RequirementType {\n\t\tmandatory,\n\t\toptional\n\t}\n\n\t// Abstract definition for a vehicle component\n\tblock def VehicleComponent {\n\t\tattribute name: String;\n\t\tattribute category: ComponentCategory;\n\t\tattribute requirementType: RequirementType;\n\t}\n\n\t// Concrete component definitions\n\tblock def FrontSeatBelt extends VehicleComponent {\n\t\tname = \"Front Seat Belt\";\n\t\tcategory = ComponentCategory.safety;\n\t\trequirementType = RequirementType.mandatory;\n\t}\n\tblock def Bumper extends VehicleComponent {\n\t\tname = \"Bumper\";\n\t\tcategory = ComponentCategory.safety;\n\t\trequirementType = RequirementType.mandatory;\n\t}\n\tblock def DriverAirbag extends VehicleComponent {\n\t\tname = \"Driver Airbag\";\n\t\tcategory = ComponentCategory.safety;\n\t\trequirementType = RequirementType.optional;\n\t}\n\tblock def AntiLockBrakingSystem extends VehicleComponent {\n\t\tname = \"Anti-lock Braking System\";\n\t\tcategory = ComponentCategory.safety;\n\t\trequirementType = RequirementType.optional;\n\t}\n\tblock def AlarmSystem extends VehicleComponent {\n\t\tname = \"Alarm System\";\n\t\tcategory = ComponentCategory.antiTheft;\n\t\trequirementType = RequirementType.mandatory;\n\t}\n\tblock def KeylessEntrySystem extends VehicleComponent {\n\t\tname = \"Keyless Entry System\";\n\t\tcategory = ComponentCategory.antiTheft;\n\t\trequirementType = RequirementType.mandatory;\n\t}\n\n\t// Vehicle context with required components\n\tpart context {\n\t\tpart body {\n\t\t\tpart frontSeatBelt: FrontSeatBelt;\n\t\t\tpart bumper: Bumper;\n\t\t}\n\t\tpart interior {\n\t\t\tpart driverAirbag: DriverAirbag;\n\t\t}\n\t\tpart chassis {\n\t\t\tpart antiLockBrakingSystem: AntiLockBrakingSystem;\n\t\t}\n\t\tpart security {\n\t\t\tpart alarmSystem: AlarmSystem;\n\t\t\tpart keylessEntrySystem: KeylessEntrySystem;\n\t\t}\n\t}\n\n\t// Requirements\n\trequirement def BasicSafetyRequirement {\n\t\ttext = \"The vehicle shall be equipped with front seat belts and bumpers as mandatory safety components to ensure occupant safety.\";\n\t}\n\trequirement def OptionalSafetyFeatures {\n\t\ttext = \"The vehicle may be equipped with a drivers airbag and anti-lock braking system as optional safety features depending on configuration.\";\n\t}\n\trequirement def SecurityRequirement {\n\t\ttext = \"The vehicle shall be equipped with an alarm system and a keyless entry system as mandatory anti-theft components.\";\n\t}\n\trequirement def ComponentCategorization {\n\t\ttext = \"All components affecting safety, anti-theft, or both shall be distinguished and described in the catalogue.\";\n\t}\n\trequirement def RegulatoryCompliance {\n\t\ttext = \"All mandatory safety components shall meet regulatory requirements for basic safety and protection functions.\";\n\t}\n\n\t// Traceability relationships\n\tsatisfy context.body.frontSeatBelt -> BasicSafetyRequirement;\n\tsatisfy context.body.bumper -> BasicSafetyRequirement;\n\tsatisfy context.interior.driverAirbag -> OptionalSafetyFeatures;\n\tsatisfy context.chassis.antiLockBrakingSystem -> OptionalSafetyFeatures;\n\tsatisfy context.security.alarmSystem -> SecurityRequirement;\n\tsatisfy context.security.keylessEntrySystem -> SecurityRequirement;\n}\n",
    "package 'VehicleFuelSystem' {\n\tattribute def Fuel;\n\tattribute def FuelTemp;\n\tattribute def FuelPressure;\n\tattribute def FuelCmd;\n\t\n\tport def FuelPort {\n\t\tout fuel: Fuel;\n\t}\n\tport def FuelReturnPort {\n\t\tin fuel: Fuel;\n\t}\n\tport def FuelTempPort {\n\t\tout fuelTemp: FuelTemp;\n\t}\n\tport def FuelPressurePort {\n\t\tout fuelPressure: FuelPressure;\n\t}\n\tport def FuelCmdPort {\n\t\tin fuelCmd: FuelCmd;\n\t}\n\t\n\tpart context {\n\t\tpart vehicle {\n\t\t\tpart fuelSystem: fuelSystem;\n\t\t}\n\t}\n\t\n\tpart def fuelSystem {\n\t\tpart fuelTankAssembly: fuelTankAssembly;\n\t\tpart fuelPump: fuelPump;\n\t\tpart fuelConsumer: fuelConsumer;\n\t\tpart fuelReturnLine: fuelReturnLine;\n\t\tpart fuelTempSensor: fuelTempSensor;\n\t\t\n\t\t// Fuel supply path\n\t\tinterface tankToPump connect fuelTankAssembly.fuelPort to fuelPump.fuelInPort {\n\t\t\tref flow references manageFuelFlow.fuelSupplyFlow\n\t\t\t\tfrom source.fuel to target.fuel;\n\t\t}\n\t\tinterface pumpToConsumer connect fuelPump.fuelOutPort to fuelConsumer.fuelInPort {\n\t\t\tref flow references manageFuelFlow.fuelDeliveryFlow\n\t\t\t\tfrom source.fuel to target.fuel;\n\t\t}\n\t\t// Fuel return path\n\t\tinterface consumerToReturn connect fuelConsumer.fuelReturnPort to fuelReturnLine.fuelReturnInPort {\n\t\t\tref flow references manageFuelFlow.fuelReturnFlow\n\t\t\t\tfrom source.fuel to target.fuel;\n\t\t}\n\t\tinterface returnToTank connect fuelReturnLine.fuelReturnOutPort to fuelTankAssembly.fuelReturnPort {\n\t\t\tref flow references manageFuelFlow.fuelBackToTankFlow\n\t\t\t\tfrom source.fuel to target.fuel;\n\t\t}\n\t\t// Fuel temperature monitoring\n\t\tinterface tempToMonitor connect fuelTempSensor.fuelTempPort to fuelPump.fuelTempInPort {\n\t\t\tref flow references manageFuelFlow.fuelTempFlow\n\t\t\t\tfrom source.fuelTemp to target.fuelTemp;\n\t\t}\n\t}\n\t\n\tpart def fuelTankAssembly {\n\t\tport fuelPort: FuelPort;\n\t\tport fuelReturnPort: FuelReturnPort;\n\t}\n\tpart def fuelPump {\n\t\tport fuelInPort: ~FuelPort;\n\t\tport fuelOutPort: FuelPort;\n\t\tport fuelTempInPort: ~FuelTempPort;\n\t}\n\tpart def fuelConsumer {\n\t\tport fuelInPort: ~FuelPort;\n\t\tport fuelReturnPort: FuelReturnPort;\n\t}\n\tpart def fuelReturnLine {\n\t\tport fuelReturnInPort: ~FuelReturnPort;\n\t\tport fuelReturnOutPort: FuelReturnPort;\n\t}\n\tpart def fuelTempSensor {\n\t\tport fuelTempPort: FuelTempPort;\n\t}\n\t\n\taction manageFuelFlow {\n\t\taction fuelSupply { out fuel: Fuel; }\n\t\tsuccession flow fuelSupplyFlow from fuelSupply.fuel to fuelPressurize.fuelIn;\n\t\taction fuelPressurize { in fuel: Fuel; out fuel: Fuel; }\n\t\tsuccession flow fuelDeliveryFlow from fuelPressurize.fuel to fuelConsume.fuelIn;\n\t\taction fuelConsume { in fuel: Fuel; out fuel: Fuel; }\n\t\tsuccession flow fuelReturnFlow from fuelConsume.fuel to fuelReturn.fuelIn;\n\t\taction fuelReturn { in fuel: Fuel; out fuel: Fuel; }\n\t\tsuccession flow fuelBackToTankFlow from fuelReturn.fuel to fuelSupply.fuel;\n\t\t\n\t\taction monitorFuelTemp { out fuelTemp: FuelTemp; }\n\t\tsuccession flow fuelTempFlow from monitorFuelTemp.fuelTemp to fuelPressurize.fuelTemp;\n\t}\n}",
    "package 'VehicleSafetySecurityCompliance' {\n\n\t// Attribute and type definitions\n\tattribute def SeatBelt;\n\tattribute def Airbag;\n\tattribute def AntiTheftAlarm;\n\tattribute def Bumper;\n\tattribute def KeylessEntrySystem;\n\tattribute def Wheel;\n\tattribute def AntiLockBrakingSystem;\n\tattribute def ComponentID;\n\tattribute def Classification;\n\n\t// Port definitions\n\tport def SafetyPort {\n\t\tout seatBelt: SeatBelt;\n\t\tout airbag: Airbag;\n\t\tout bumper: Bumper;\n\t}\n\tport def SecurityPort {\n\t\tout antiTheftAlarm: AntiTheftAlarm;\n\t\tout keylessEntry: KeylessEntrySystem;\n\t}\n\tport def ChassisPort {\n\t\tout wheel: Wheel;\n\t\tout abs: AntiLockBrakingSystem;\n\t}\n\tport def CompliancePort {\n\t\tin componentID: ComponentID;\n\t\tin classification: Classification;\n\t}\n\n\t// Part structure\n\tpart context {\n\t\tpart vehicle {\n\t\t\tpart interior {\n\t\t\t\tport safetyPort: SafetyPort;\n\t\t\t\tpart seatBelt1 { attribute id: ComponentID; }\n\t\t\t\tpart seatBelt2 { attribute id: ComponentID; }\n\t\t\t\tpart airbag { attribute id: ComponentID; }\n\t\t\t\tperform safetyConfig.provideSeatBelts {\n\t\t\t\t\tout seatBelt = safetyPort.seatBelt;\n\t\t\t\t}\n\t\t\t\tperform safetyConfig.provideAirbag {\n\t\t\t\t\tout airbag = safetyPort.airbag;\n\t\t\t\t}\n\t\t\t}\n\t\t\tpart cockpit {\n\t\t\t\tref airbag = interior.airbag;\n\t\t\t}\n\t\t\tpart securitySystem {\n\t\t\t\tport securityPort: SecurityPort;\n\t\t\t\tpart antiTheftAlarm { attribute id: ComponentID; }\n\t\t\t\tpart keylessEntry { attribute id: ComponentID; }\n\t\t\t\tperform securityConfig.provideAntiTheftAlarm {\n\t\t\t\t\tout antiTheftAlarm = securityPort.antiTheftAlarm;\n\t\t\t\t}\n\t\t\t\tperform securityConfig.provideKeylessEntry {\n\t\t\t\t\tout keylessEntry = securityPort.keylessEntry;\n\t\t\t\t}\n\t\t\t}\n\t\t\tpart body {\n\t\t\t\tport safetyPort: ~SafetyPort;\n\t\t\t\tpart bumper { attribute id: ComponentID; }\n\t\t\t\tperform safetyConfig.provideBumper {\n\t\t\t\t\tout bumper = safetyPort.bumper;\n\t\t\t\t}\n\t\t\t}\n\t\t\tpart chassis {\n\t\t\t\tport chassisPort: ChassisPort;\n\t\t\t\tpart wheel1 { attribute id: ComponentID; }\n\t\t\t\tpart wheel2 { attribute id: ComponentID; }\n\t\t\t\tpart abs1 { attribute id: ComponentID; }\n\t\t\t\tpart abs2 { attribute id: ComponentID; }\n\t\t\t\tperform safetyConfig.provideWheels {\n\t\t\t\t\tout wheel = chassisPort.wheel;\n\t\t\t\t}\n\t\t\t\tperform safetyConfig.provideABS {\n\t\t\t\t\tout abs = chassisPort.abs;\n\t\t\t\t}\n\t\t\t}\n\t\t\tpart complianceManager {\n\t\t\t\tport compliancePort: CompliancePort;\n\t\t\t\tperform complianceConfig.identifyAndClassify {\n\t\t\t\t\tin componentID = compliancePort.componentID;\n\t\t\t\t\tin classification = compliancePort.classification;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\t// Actions for configuration and compliance\n\taction safetyConfig {\n\t\taction provideSeatBelts { out seatBelt: SeatBelt; }\n\t\taction provideAirbag { out airbag: Airbag; }\n\t\taction provideBumper { out bumper: Bumper; }\n\t\taction provideWheels { out wheel: Wheel; }\n\t\taction provideABS { out abs: AntiLockBrakingSystem; }\n\t}\n\taction securityConfig {\n\t\taction provideAntiTheftAlarm { out antiTheftAlarm: AntiTheftAlarm; }\n\t\taction provideKeylessEntry { out keylessEntry: KeylessEntrySystem; }\n\t}\n\taction complianceConfig {\n\t\taction identifyAndClassify { in componentID: ComponentID; in classification: Classification; }\n\t}\n\n\t// Requirements\n\trequirement SeatBeltRequired {\n\t\ttext = \"The vehicle interior shall be equipped with two seat belts as mandatory safety features.\";\n\t}\n\trequirement AirbagOptional {\n\t\ttext = \"An airbag should be installed in the cockpit, but its application is not mandatory.\";\n\t}\n\trequirement AntiTheftAlarmRequired {\n\t\ttext = \"An anti-theft alarm device shall be installed inside the vehicle to enhance security protection.\";\n\t}\n\trequirement BumperRequired {\n\t\ttext = \"The vehicle body shall be equipped with a bumper as a required safety component.\";\n\t}\n\trequirement KeylessEntryRequired {\n\t\ttext = \"The vehicle body shall be equipped with a keyless entry system to improve security performance.\";\n\t}\n\trequirement WheelsRequired {\n\t\ttext = \"The chassis structure shall be fitted with two wheels.\";\n\t}\n\trequirement ABSOptional {\n\t\ttext = \"The chassis structure should be equipped with two sets of anti-lock braking systems, although installation is not mandatory.\";\n\t}\n\trequirement ComplianceManagement {\n\t\ttext = \"All safety and security components shall be subject to identification and classification management to ensure compliance with regulations regarding critical safety and security functions.\";\n\t}\n}",
    "package 'VehicleSafetyAndSecurity' {\n\tattribute def AlarmSignal;\n\tattribute def SeatBeltStatus;\n\tattribute def AirbagStatus;\n\tattribute def KeylessEntryCmd;\n\tattribute def BumperImpactStatus;\n\tattribute def OccupantProtectionLevel;\n\tattribute def SecurityStatus;\n\n\tport def AlarmPort {\n\t\tout alarmSignal: AlarmSignal;\n\t}\n\tport def SeatBeltPort {\n\t\tout seatBeltStatus: SeatBeltStatus;\n\t}\n\tport def AirbagPort {\n\t\tout airbagStatus: AirbagStatus;\n\t}\n\tport def KeylessEntryPort {\n\t\tin keylessEntryCmd: KeylessEntryCmd;\n\t\tout securityStatus: SecurityStatus;\n\t}\n\tport def BumperPort {\n\t\tout bumperImpactStatus: BumperImpactStatus;\n\t}\n\tport def OccupantProtectionPort {\n\t\tout occupantProtectionLevel: OccupantProtectionLevel;\n\t}\n\n\tpart context {\n\t\tpart user {\n\t\t\tport keylessEntryPort: KeylessEntryPort;\n\t\t\tperform operateVehicle.sendKeylessEntryCmd {\n\t\t\t\tout keylessEntryCmd = keylessEntryPort.keylessEntryCmd;\n\t\t\t}\n\t\t}\n\t\tpart vehicle {\n\t\t\tpart interior {\n\t\t\t\tpart alarmSystem {\n\t\t\t\t\tport alarmPort: AlarmPort;\n\t\t\t\t\tperform operateVehicle.detectIntrusion {\n\t\t\t\t\t\tout alarmSignal = alarmPort.alarmSignal;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tpart seatBelt {\n\t\t\t\t\tport seatBeltPort: SeatBeltPort;\n\t\t\t\t\tperform protectOccupants.monitorSeatBelt {\n\t\t\t\t\t\tout seatBeltStatus = seatBeltPort.seatBeltStatus;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tpart frontRowSeats {}\n\t\t\t\tpart driverAirbag {\n\t\t\t\t\tport airbagPort: AirbagPort;\n\t\t\t\t\tperform protectOccupants.deployAirbag {\n\t\t\t\t\t\tout airbagStatus = airbagPort.airbagStatus;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tpart bodyAssembly {\n\t\t\t\tpart vehicleBody {}\n\t\t\t\tpart bumper {\n\t\t\t\t\tport bumperPort: BumperPort;\n\t\t\t\t\tperform protectOccupants.absorbImpact {\n\t\t\t\t\t\tout bumperImpactStatus = bumperPort.bumperImpactStatus;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tpart keylessEntrySystem {\n\t\t\t\t\tport keylessEntryPort: ~KeylessEntryPort;\n\t\t\t\t\tperform operateVehicle.processKeylessEntry {\n\t\t\t\t\t\tin keylessEntryCmd = keylessEntryPort.keylessEntryCmd;\n\t\t\t\t\t\tout securityStatus = keylessEntryPort.securityStatus;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tport occupantProtectionPort: OccupantProtectionPort;\n\t\t\tperform protectOccupants.aggregateProtection {\n\t\t\t\tin seatBeltStatus = interior.seatBelt.seatBeltPort.seatBeltStatus;\n\t\t\t\tin airbagStatus = interior.driverAirbag.airbagPort.airbagStatus;\n\t\t\t\tin bumperImpactStatus = bodyAssembly.bumper.bumperPort.bumperImpactStatus;\n\t\t\t\tout occupantProtectionLevel = occupantProtectionPort.occupantProtectionLevel;\n\t\t\t}\n\t\t}\n\t}\n\n\taction protectOccupants {\n\t\taction monitorSeatBelt { out seatBeltStatus: SeatBeltStatus; }\n\t\taction deployAirbag { out airbagStatus: AirbagStatus; }\n\t\taction absorbImpact { out bumperImpactStatus: BumperImpactStatus; }\n\t\taction aggregateProtection {\n\t\t\tin seatBeltStatus: SeatBeltStatus;\n\t\t\tin airbagStatus: AirbagStatus;\n\t\t\tin bumperImpactStatus: BumperImpactStatus;\n\t\t\tout occupantProtectionLevel: OccupantProtectionLevel;\n\t\t}\n\t\tsuccession flow seatBeltFlow from monitorSeatBelt.seatBeltStatus to aggregateProtection.seatBeltStatus;\n\t\tsuccession flow airbagFlow from deployAirbag.airbagStatus to aggregateProtection.airbagStatus;\n\t\tsuccession flow bumperFlow from absorbImpact.bumperImpactStatus to aggregateProtection.bumperImpactStatus;\n\t}\n\n\taction operateVehicle {\n\t\taction sendKeylessEntryCmd { out keylessEntryCmd: KeylessEntryCmd; }\n\t\taction processKeylessEntry {\n\t\t\tin keylessEntryCmd: KeylessEntryCmd;\n\t\t\tout securityStatus: SecurityStatus;\n\t\t}\n\t\taction detectIntrusion { out alarmSignal: AlarmSignal; }\n\t\tsuccession flow keylessEntryFlow from sendKeylessEntryCmd.keylessEntryCmd to processKeylessEntry.keylessEntryCmd;\n\t}\n\n\tinterface userToVehicle connect user.keylessEntryPort to vehicle.bodyAssembly.keylessEntrySystem.keylessEntryPort {\n\t\tref flow references operateVehicle.keylessEntryFlow\n\t\t\tfrom source.keylessEntryCmd to target.keylessEntryCmd;\n\t}\n}",
    "package 'SecurityClassification' {\n\tattribute def SecurityLevel {\n\t\tliteral Unclassified;\n\t\tliteral Confidential;\n\t\tliteral Secret;\n\t}\n\tattribute def ClassificationLabel {\n\t\tlevel: SecurityLevel;\n\t}\n\tport def ClassificationPort {\n\t\tout classificationLabel: ClassificationLabel;\n\t}\n\tpart context {\n\t\tpart component {\n\t\t\tattribute securityLevel: SecurityLevel;\n\t\t\tport classificationPort: ClassificationPort;\n\t\t\tperform classifyComponent.assignClassification {\n\t\t\t\tout classificationLabel.level = securityLevel;\n\t\t\t}\n\t\t}\n\t\tpart system {\n\t\t\tport classificationPort: ~ClassificationPort;\n\t\t\tperform classifyComponent.displayClassification {\n\t\t\t\tin classificationLabel: ClassificationLabel;\n\t\t\t}\n\t\t}\n\t\tinterface componentToSystem connect component.classificationPort to system.classificationPort {\n\t\t\tref flow references classifyComponent.classificationFlow\n\t\t\t\tfrom source.classificationLabel to target.classificationLabel;\n\t\t}\n\t}\n\taction classifyComponent {\n\t\taction assignClassification { out classificationLabel: ClassificationLabel; }\n\t\tsuccession flow classificationFlow from assignClassification.classificationLabel to displayClassification.classificationLabel;\n\t\taction displayClassification { in classificationLabel: ClassificationLabel; }\n\t}\n}",
    "package 'AutomotiveECUCommunication' {\n\tattribute def CANMessage;\n\tattribute def VehicleState;\n\tattribute def EngineState;\n\tattribute def SensorData;\n\n\tport def CANBusPort {\n\t\tinout canMsg: CANMessage;\n\t}\n\tport def SensorPort {\n\t\tinout sensorData: SensorData;\n\t}\n\n\tpart context {\n\t\tpart canBus {\n\t\t\tport canBusPortVCU: ~CANBusPort;\n\t\t\tport canBusPortECU: ~CANBusPort;\n\t\t}\n\t\tpart VCU {\n\t\t\tport canBusPort: CANBusPort;\n\t\t\tport sensorPort: SensorPort;\n\t\t\tperform controlFlow.monitorVehicleState {\n\t\t\t\tout canMsg = canBusPort.canMsg;\n\t\t\t\tin sensorData = sensorPort.sensorData;\n\t\t\t}\n\t\t}\n\t\tpart ECU {\n\t\t\tport canBusPort: CANBusPort;\n\t\t\tport sensorPort: SensorPort;\n\t\t\tperform controlFlow.monitorEngineState {\n\t\t\t\tout canMsg = canBusPort.canMsg;\n\t\t\t\tin sensorData = sensorPort.sensorData;\n\t\t\t}\n\t\t}\n\t\tinterface VCU_CAN connect VCU.canBusPort to canBus.canBusPortVCU {\n\t\t\tref flow references controlFlow.canMsgFlowVCU\n\t\t\t\tfrom source.canMsg to target.canMsg;\n\t\t}\n\t\tinterface ECU_CAN connect ECU.canBusPort to canBus.canBusPortECU {\n\t\t\tref flow references controlFlow.canMsgFlowECU\n\t\t\t\tfrom source.canMsg to target.canMsg;\n\t\t}\n\t}\n\n\taction controlFlow {\n\t\taction monitorVehicleState {\n\t\t\tout canMsg: CANMessage;\n\t\t\tin sensorData: SensorData;\n\t\t}\n\t\taction monitorEngineState {\n\t\t\tout canMsg: CANMessage;\n\t\t\tin sensorData: SensorData;\n\t\t}\n\t\tsuccession flow canMsgFlowVCU from monitorVehicleState.canMsg to canBusPortVCU.canMsg;\n\t\tsuccession flow canMsgFlowECU from monitorEngineState.canMsg to canBusPortECU.canMsg;\n\t}\n}",
    "package 'BloodGlucoseMeter' {\n\tattribute def BatteryStatus;\n\tattribute def MeasurementStatus;\n\tattribute def AlarmSignal;\n\tattribute def EmergencyResponseCmd;\n\tattribute def RiskScenario;\n\tattribute def ApprovalStatus;\n\n\tport def BatteryStatusPort {\n\t\tout batteryStatus: BatteryStatus;\n\t}\n\tport def MeasurementStatusPort {\n\t\tout measurementStatus: MeasurementStatus;\n\t}\n\tport def AlarmPort {\n\t\tout alarmSignal: AlarmSignal;\n\t}\n\tport def EmergencyResponsePort {\n\t\tout emergencyResponseCmd: EmergencyResponseCmd;\n\t}\n\tport def ApprovalPort {\n\t\tout approvalStatus: ApprovalStatus;\n\t}\n\tport def RiskScenarioPort {\n\t\tout riskScenario: RiskScenario;\n\t}\n\n\tpart context {\n\t\tpart user {\n\t\t\tport alarmPort: ~AlarmPort;\n\t\t\tport emergencyResponsePort: ~EmergencyResponsePort;\n\t\t\tperform ensureTherapeuticSupport.receiveAlarm {\n\t\t\t\tin alarmSignal = alarmPort.alarmSignal;\n\t\t\t}\n\t\t\tperform ensureTherapeuticSupport.receiveEmergencyResponse {\n\t\t\t\tin emergencyResponseCmd = emergencyResponsePort.emergencyResponseCmd;\n\t\t\t}\n\t\t}\n\t\tpart bloodGlucoseMeter {\n\t\t\tport batteryStatusPort: BatteryStatusPort;\n\t\t\tport measurementStatusPort: MeasurementStatusPort;\n\t\t\tport alarmPort: AlarmPort;\n\t\t\tport emergencyResponsePort: EmergencyResponsePort;\n\t\t\tport approvalPort: ApprovalPort;\n\t\t\tport riskScenarioPort: RiskScenarioPort;\n\n\t\t\tperform ensureTherapeuticSupport.monitorBattery {\n\t\t\t\tout batteryStatus = batteryStatusPort.batteryStatus;\n\t\t\t}\n\t\t\tperform ensureTherapeuticSupport.monitorMeasurement {\n\t\t\t\tout measurementStatus = measurementStatusPort.measurementStatus;\n\t\t\t}\n\t\t\tperform ensureTherapeuticSupport.detectAbnormalities {\n\t\t\t\tin batteryStatus = batteryStatusPort.batteryStatus;\n\t\t\t\tin measurementStatus = measurementStatusPort.measurementStatus;\n\t\t\t\tout alarmSignal = alarmPort.alarmSignal;\n\t\t\t\tout emergencyResponseCmd = emergencyResponsePort.emergencyResponseCmd;\n\t\t\t}\n\t\t\tperform ensureTherapeuticSupport.manageRiskScenarios {\n\t\t\t\tout riskScenario = riskScenarioPort.riskScenario;\n\t\t\t\tout approvalStatus = approvalPort.approvalStatus;\n\t\t\t}\n\t\t}\n\t}\n\n\taction ensureTherapeuticSupport {\n\t\taction monitorBattery { out batteryStatus: BatteryStatus; }\n\t\taction monitorMeasurement { out measurementStatus: MeasurementStatus; }\n\t\taction detectAbnormalities {\n\t\t\tin batteryStatus: BatteryStatus;\n\t\t\tin measurementStatus: MeasurementStatus;\n\t\t\tout alarmSignal: AlarmSignal;\n\t\t\tout emergencyResponseCmd: EmergencyResponseCmd;\n\t\t}\n\t\taction receiveAlarm { in alarmSignal: AlarmSignal; }\n\t\taction receiveEmergencyResponse { in emergencyResponseCmd: EmergencyResponseCmd; }\n\t\taction manageRiskScenarios {\n\t\t\tout riskScenario: RiskScenario;\n\t\t\tout approvalStatus: ApprovalStatus;\n\t\t}\n\t\tsuccession flow batteryStatusFlow from monitorBattery.batteryStatus to detectAbnormalities.batteryStatus;\n\t\tsuccession flow measurementStatusFlow from monitorMeasurement.measurementStatus to detectAbnormalities.measurementStatus;\n\t\tsuccession flow alarmFlow from detectAbnormalities.alarmSignal to receiveAlarm.alarmSignal;\n\t\tsuccession flow emergencyResponseFlow from detectAbnormalities.emergencyResponseCmd to receiveEmergencyResponse.emergencyResponseCmd;\n\t}\n\n\trequirement def HighReliabilityAndSafety {\n\t\ttext = \"The system shall ensure high reliability and safety during use.\"\n\t}\n\trequirement def BatteryStatusDetection {\n\t\ttext = \"The system shall automatically detect battery status and alert the user if the battery is depleted or cannot be charged.\"\n\t}\n\trequirement def PreventiveMeasures {\n\t\ttext = \"The system shall implement preventive measures for battery status to avoid measurement failures and treatment delays.\"\n\t}\n\trequirement def AlarmAndEmergencyResponse {\n\t\ttext = \"The system shall provide alarm and emergency response mechanisms for abnormalities in blood glucose measurement.\"\n\t}\n\trequirement def RiskManagement {\n\t\ttext = \"The system shall establish management measures for key risk scenarios and ensure requirements approval.\"\n\t}\n\trequirement def ContinuousTherapeuticSupport {\n\t\ttext = \"The system shall ensure timely, continuous, and safe therapeutic support for patients under all circumstances.\"\n\t}\n}",
    "package 'ScientificConstantsSystem' {\n\n\t// Mathematical Constants\n\tconstant def Pi : Real = 3.14159265358979323846;\n\tconstant def EulerNumber : Real = 2.71828182845904523536;\n\n\t// Physical Constants (with SI units)\n\tconstant def SpeedOfLight : Real = 299792458.0; // [m/s]\n\tconstant def FineStructureConstant : Real = 0.0072973525693; // [dimensionless]\n\tconstant def ElectronToProtonMassRatio : Real = 0.000544617021487; // [dimensionless]\n\n\t// Scenario-based Constants\n\tconstant def StandardGravitationalAcceleration : Real = 9.80665; // [m/s^2]\n\n\t// Context-specific Parameter Example\n\tconstant def AmplifierGainCoefficient_ModelX : Real = 45.0; // [dB]\n\n\t// Grouping of constants for accessibility\n\tpart context {\n\t\tpart constantsRepository {\n\t\t\tref pi: Pi;\n\t\t\tref e: EulerNumber;\n\t\t\tref speedOfLight: SpeedOfLight;\n\t\t\tref fineStructureConstant: FineStructureConstant;\n\t\t\tref electronToProtonMassRatio: ElectronToProtonMassRatio;\n\t\t\tref standardGravitationalAcceleration: StandardGravitationalAcceleration;\n\t\t\tref amplifierGainCoefficient_ModelX: AmplifierGainCoefficient_ModelX;\n\t\t}\n\t}\n\n\t// Verification action for constants\n\taction verifyConstant {\n\t\tin constantValue: Real;\n\t\tin referenceValue: Real;\n\t\tout isVerified: Boolean;\n\t}\n\n\t// Accessibility interface\n\tinterface ConstantsAccess {\n\t\tout pi: Pi;\n\t\tout e: EulerNumber;\n\t\tout speedOfLight: SpeedOfLight;\n\t\tout fineStructureConstant: FineStructureConstant;\n\t\tout electronToProtonMassRatio: ElectronToProtonMassRatio;\n\t\tout standardGravitationalAcceleration: StandardGravitationalAcceleration;\n\t\tout amplifierGainCoefficient_ModelX: AmplifierGainCoefficient_ModelX;\n\t}\n\n\tpart context {\n\t\tpart user {\n\t\t\tport access: ConstantsAccess;\n\t\t}\n\t\tpart constantsRepository {\n\t\t\tport provide: ~ConstantsAccess;\n\t\t}\n\t\tinterface userToRepository connect user.access to constantsRepository.provide;\n\t}\n}",
    "package 'AutomotiveComponentSpecification' {\n\ttype ManufacturerName is String;\n\ttype RimDiameter is Real;\n\ttype TireWidth is Integer;\n\n\tstruct Tire {\n\t\tattribute manufacturer: ManufacturerName;\n\t\tattribute rimDiameter: RimDiameter;\n\t\tattribute width: TireWidth;\n\t}\n\n\tpart context {\n\t\tpart tire1: Tire {\n\t\t\tmanufacturer = \"Michelin\";\n\t\t\trimDiameter = 18.0;\n\t\t\twidth = 245;\n\t\t}\n\t\tpart tire2: Tire {\n\t\t\tmanufacturer = \"Bridgestone\";\n\t\t\trimDiameter = 17.0;\n\t\t\twidth = 225;\n\t\t}\n\t\tpart tire3: Tire {\n\t\t\tmanufacturer = \"Continental\";\n\t\t\trimDiameter = 19.0;\n\t\t\twidth = 255;\n\t\t}\n\t}\n}",
    "package 'AutomotiveComponentModel' {\n\n\t// Unit definitions\n\tunit def kilogram : si::kilogram;\n\tunit def meter : si::meter;\n\tunit def inch : imperial::inch;\n\tunit def millimeter : si::millimeter;\n\tunit def pound : imperial::pound;\n\tunit def foot : imperial::foot;\n\n\t// Quantity definitions\n\tquantity def Mass : kilogram;\n\tquantity def Length : meter;\n\tquantity def Diameter : meter;\n\tquantity def Width : meter;\n\n\t// Conversion functions\n\tfunction def inchToMeter(in value: inch) : meter => value * 0.0254;\n\tfunction def meterToInch(in value: meter) : inch => value / 0.0254;\n\tfunction def mmToMeter(in value: millimeter) : meter => value * 0.001;\n\tfunction def meterToMm(in value: meter) : millimeter => value / 0.001;\n\n\t// Tire part definition\n\tpart def Tire {\n\t\tattribute tireHeight: Length;\n\t}\n\n\t// Wheel part definition\n\tpart def Wheel {\n\t\tattribute hubDiameter: Diameter;\n\t\tattribute width: Width;\n\t\tattribute outerDiameter: Diameter;\n\t\tpart tire: Tire;\n\n\t\tconstraint def OuterDiameterCalculation {\n\t\t\t// outerDiameter = hubDiameter + 2 * tire.tireHeight\n\t\t\touterDiameter = hubDiameter + 2.0 * tire.tireHeight;\n\t\t}\n\t}\n\n\t// Vehicle part definition\n\tpart def Vehicle {\n\t\tattribute mass: Mass = 1200.0 * kilogram;\n\t\tattribute length: Length = 4.82 * meter;\n\t\tpart frontLeftWheel: Wheel;\n\t\tpart frontRightWheel: Wheel;\n\t}\n\n\t// Context for standardized design and simulation\n\tpart context {\n\t\tpart vehicle: Vehicle {\n\t\t\tfrontLeftWheel: Wheel {\n\t\t\t\thubDiameter = inchToMeter(18.0 * inch);\n\t\t\t\twidth = mmToMeter(245.0 * millimeter);\n\t\t\t\ttire: Tire {\n\t\t\t\t\ttireHeight: Length; // To be specified per design\n\t\t\t\t}\n\t\t\t}\n\t\t\tfrontRightWheel: Wheel {\n\t\t\t\thubDiameter = inchToMeter(18.0 * inch);\n\t\t\t\twidth = mmToMeter(245.0 * millimeter);\n\t\t\t\ttire: Tire {\n\t\t\t\t\ttireHeight: Length; // To be specified per design\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n}",
    "package 'VehiclePowertrainConfig' {\n\ttype def EngineType {\n\t\tliteral FourCylinder;\n\t\tliteral SixCylinder;\n\t}\n\ttype def TransmissionType {\n\t\tliteral Manual;\n\t\tliteral Automatic;\n\t}\n\tattribute def isHighPerformance: Boolean;\n\tattribute def engineType: EngineType;\n\tattribute def transmissionType: TransmissionType;\n\n\tconstraint def validEngineSelection {\n\t\tif isHighPerformance then\n\t\t\tengineType == EngineType::SixCylinder\n\t\telse\n\t\t\tengineType == EngineType::FourCylinder\n\t}\n\tconstraint def validPowertrainCombination {\n\t\t(engineType == EngineType::FourCylinder and transmissionType == TransmissionType::Manual)\n\t\tor\n\t\t(engineType == EngineType::SixCylinder and transmissionType == TransmissionType::Automatic)\n\t}\n\tpart context {\n\t\tattribute isHighPerformance: Boolean;\n\t\tattribute engineType: EngineType;\n\t\tattribute transmissionType: TransmissionType;\n\n\t\tconstraint use validEngineSelection;\n\t\tconstraint use validPowertrainCombination;\n\t}\n}",
    "package 'AutomotiveComponents' {\n\n\t// Fundamental units\n\tunit def kilogram;\n\tunit def meter;\n\tunit def millimeter;\n\tunit def inch;\n\n\t// Car attributes\n\tattribute def totalMass: kilogram = 1200;\n\tattribute def length: meter = 4.82;\n\n\t// Tire attributes\n\tattribute def tireWidth: millimeter = 245;\n\tattribute def tireHeight: millimeter = 45;\n\tattribute def treadDepthDefault: millimeter = 6.0;\n\tattribute def treadDepthMin: millimeter = 3.5;\n\n\t// Rim attributes\n\tattribute def rimDiameter: inch = 18;\n\n\t// Brake disc attributes\n\tattribute def brakeDiscRadius: millimeter = 95;\n\n\t// Conversion constant\n\tconstant def inchToMillimeter: millimeter = 25.4;\n\n\t// Derived attributes\n\tattribute def rimDiameter_mm: millimeter = rimDiameter * inchToMillimeter;\n\tattribute def wheelOuterDiameter: millimeter = rimDiameter_mm + 2 * tireHeight;\n\tattribute def brakeDiscDiameter: millimeter = 2 * brakeDiscRadius;\n\n\t// Part definitions\n\tpart def Tire {\n\t\tattribute width: millimeter = tireWidth;\n\t\tattribute height: millimeter = tireHeight;\n\t\tattribute treadDepth: millimeter = treadDepthDefault;\n\t\tconstraint treadDepthRequirement {\n\t\t\ttreadDepth >= treadDepthMin;\n\t\t}\n\t}\n\n\tpart def Rim {\n\t\tattribute diameter: inch = rimDiameter;\n\t\tattribute diameter_mm: millimeter = diameter * inchToMillimeter;\n\t}\n\n\tpart def Wheel {\n\t\tpart rim: Rim;\n\t\tpart tire: Tire;\n\t\tattribute outerDiameter: millimeter = rim.diameter_mm + 2 * tire.height;\n\t}\n\n\tpart def BrakeDisc {\n\t\tattribute radius: millimeter = brakeDiscRadius;\n\t\tattribute diameter: millimeter = 2 * radius;\n\t}\n\n\tpart def WheelAssembly {\n\t\tpart wheel: Wheel;\n\t\tpart brakeDisc: BrakeDisc;\n\t\tconstraint brakeDiscFitment {\n\t\t\tbrakeDisc.diameter < wheel.outerDiameter;\n\t\t}\n\t}\n\n\tpart def Car {\n\t\tattribute mass: kilogram = totalMass;\n\t\tattribute length: meter = length;\n\t\tpart wheelAssemblies: WheelAssembly[*];\n\t\tconstraint allWheelAssembliesFitment {\n\t\t\tfor (wa in wheelAssemblies) {\n\t\t\t\twa.brakeDisc.diameter < wa.wheel.outerDiameter;\n\t\t\t}\n\t\t}\n\t\tconstraint allTiresTreadDepth {\n\t\t\tfor (wa in wheelAssemblies) {\n\t\t\t\twa.wheel.tire.treadDepth >= treadDepthMin;\n\t\t\t}\n\t\t}\n\t}\n\n}",
    "package 'AutomotiveFuelSystem' {\n\tattribute def Fuel;\n\tattribute def FuelTemp;\n\tattribute def FuelCmd;\n\t\n\tport def FuelPort {\n\t\tinout fuel: Fuel;\n\t}\n\tport def FuelReturnPort {\n\t\tin fuelReturn: Fuel;\n\t}\n\tport def FuelTempPort {\n\t\tout fuelTemp: FuelTemp;\n\t}\n\tport def FuelCmdPort {\n\t\tin fuelCmd: FuelCmd;\n\t}\n\t\n\tpart context {\n\t\tpart fuelTankAssembly {\n\t\t\tport fuelOut: FuelPort;\n\t\t\tport fuelReturn: FuelReturnPort;\n\t\t\tport fuelTemp: FuelTempPort;\n\t\t\tpart fuelTank {\n\t\t\t\tport fuelOut: ~FuelPort;\n\t\t\t\tport fuelReturn: ~FuelReturnPort;\n\t\t\t}\n\t\t\tpart fuelPump {\n\t\t\t\tport fuelIn: FuelPort;\n\t\t\t\tport fuelOut: FuelPort;\n\t\t\t\tport fuelReturn: FuelReturnPort;\n\t\t\t\tport fuelCmd: FuelCmdPort;\n\t\t\t}\n\t\t\tperform fuelSystem.deliverFuel {\n\t\t\t\tout fuel = fuelOut.fuel;\n\t\t\t\tin fuelReturn = fuelReturn.fuelReturn;\n\t\t\t}\n\t\t\tperform fuelSystem.monitorFuelTemp {\n\t\t\t\tout fuelTemp = fuelTemp.fuelTemp;\n\t\t\t}\n\t\t}\n\t\tpart engine {\n\t\t\tport fuelIn: ~FuelPort;\n\t\t\tport fuelReturn: FuelReturnPort;\n\t\t\tport fuelCmd: FuelCmdPort;\n\t\t}\n\t\tinterface fuelToEngine connect fuelTankAssembly.fuelOut to engine.fuelIn {\n\t\t\tref flow references fuelSystem.fuelDeliveryFlow\n\t\t\t\tfrom source.fuel to target.fuel;\n\t\t}\n\t\tinterface engineToFuelReturn connect engine.fuelReturn to fuelTankAssembly.fuelReturn {\n\t\t\tref flow references fuelSystem.fuelReturnFlow\n\t\t\t\tfrom source.fuelReturn to target.fuelReturn;\n\t\t}\n\t\tinterface fuelTempToMonitor connect fuelTankAssembly.fuelTemp to monitor.fuelTemp {\n\t\t\tref flow references fuelSystem.fuelTempFlow\n\t\t\t\tfrom source.fuelTemp to target.fuelTemp;\n\t\t}\n\t\tpart monitor {\n\t\t\tport fuelTemp: ~FuelTempPort;\n\t\t}\n\t}\n\t\n\taction fuelSystem {\n\t\taction deliverFuel { out fuel: Fuel; in fuelReturn: Fuel; }\n\t\tsuccession flow fuelDeliveryFlow from deliverFuel.fuel to engine.fuelIn.fuel;\n\t\tsuccession flow fuelReturnFlow from engine.fuelReturn.fuelReturn to deliverFuel.fuelReturn;\n\t\taction monitorFuelTemp { out fuelTemp: FuelTemp; }\n\t\tsuccession flow fuelTempFlow from monitorFuelTemp.fuelTemp to monitor.fuelTemp.fuelTemp;\n\t}\n}",
    "package 'PhysicalQuantitySystem' {\n\tattribute def PhysicalQuantity;\n\tattribute def Unit;\n\tattribute def Value;\n\tattribute def QuantityType;\n\tattribute def ConversionRule;\n\n\tenum def ISQBaseQuantity {\n\t\tlength,\n\t\tmass,\n\t\ttime,\n\t\telectricCurrent,\n\t\ttemperature,\n\t\tamountOfSubstance,\n\t\tluminousIntensity\n\t}\n\n\tport def QuantityPort {\n\t\tin quantity: PhysicalQuantity;\n\t\tout value: Value;\n\t\tout unit: Unit;\n\t}\n\n\tport def ConversionPort {\n\t\tin value: Value;\n\t\tin fromUnit: Unit;\n\t\tin toUnit: Unit;\n\t\tout convertedValue: Value;\n\t}\n\n\tpart context {\n\t\tpart user {\n\t\t\tport quantityPort: QuantityPort;\n\t\t\tport conversionPort: ConversionPort;\n\t\t\tperform manageQuantities.inputQuantity {\n\t\t\t\tout quantity = quantityPort.quantity;\n\t\t\t\tout value = quantityPort.value;\n\t\t\t\tout unit = quantityPort.unit;\n\t\t\t}\n\t\t\tperform manageQuantities.requestConversion {\n\t\t\t\tin value = conversionPort.value;\n\t\t\t\tin fromUnit = conversionPort.fromUnit;\n\t\t\t\tin toUnit = conversionPort.toUnit;\n\t\t\t\tout convertedValue = conversionPort.convertedValue;\n\t\t\t}\n\t\t}\n\t\tpart quantitySystem {\n\t\t\tport quantityPort: ~QuantityPort;\n\t\t\tport conversionPort: ~ConversionPort;\n\t\t\tperform manageQuantities.storeQuantity {\n\t\t\t\tin quantity = quantityPort.quantity;\n\t\t\t\tin value = quantityPort.value;\n\t\t\t\tin unit = quantityPort.unit;\n\t\t\t}\n\t\t\tperform manageQuantities.convertUnit {\n\t\t\t\tin value = conversionPort.value;\n\t\t\t\tin fromUnit = conversionPort.fromUnit;\n\t\t\t\tin toUnit = conversionPort.toUnit;\n\t\t\t\tout convertedValue = conversionPort.convertedValue;\n\t\t\t}\n\t\t\tperform manageQuantities.ensureConsistency {\n\t\t\t\tin quantity: PhysicalQuantity;\n\t\t\t\tin value: Value;\n\t\t\t\tin unit: Unit;\n\t\t\t}\n\t\t\tperform manageQuantities.importOrExtend {\n\t\t\t\tin quantityType: QuantityType;\n\t\t\t\tin unit: Unit;\n\t\t\t}\n\t\t}\n\t}\n\n\taction manageQuantities {\n\t\taction inputQuantity {\n\t\t\tout quantity: PhysicalQuantity;\n\t\t\tout value: Value;\n\t\t\tout unit: Unit;\n\t\t}\n\t\taction storeQuantity {\n\t\t\tin quantity: PhysicalQuantity;\n\t\t\tin value: Value;\n\t\t\tin unit: Unit;\n\t\t}\n\t\taction convertUnit {\n\t\t\tin value: Value;\n\t\t\tin fromUnit: Unit;\n\t\t\tin toUnit: Unit;\n\t\t\tout convertedValue: Value;\n\t\t}\n\t\taction ensureConsistency {\n\t\t\tin quantity: PhysicalQuantity;\n\t\t\tin value: Value;\n\t\t\tin unit: Unit;\n\t\t}\n\t\taction importOrExtend {\n\t\t\tin quantityType: QuantityType;\n\t\t\tin unit: Unit;\n\t\t}\n\t\taction requestConversion {\n\t\t\tin value: Value;\n\t\t\tin fromUnit: Unit;\n\t\t\tin toUnit: Unit;\n\t\t\tout convertedValue: Value;\n\t\t}\n\t}\n\n\tsuccession flow inputToStore from inputQuantity.quantity to storeQuantity.quantity;\n\tsuccession flow inputToConsistency from inputQuantity.quantity to ensureConsistency.quantity;\n\tsuccession flow storeToConsistency from storeQuantity.quantity to ensureConsistency.quantity;\n\tsuccession flow conversionRequest to convertUnit;\n\tsuccession flow importOrExtendFlow to importOrExtend;\n}",
    "package 'UnitSystemLibrary' {\n\tattribute def PhysicalQuantity;\n\tattribute def ISQUnit;\n\tattribute def USCustomaryUnit;\n\tattribute def StandardizedUnit;\n\tattribute def ConversionRule;\n\tattribute def UnitType;\n\tattribute def ConversionAccuracy;\n\tattribute def UserRequest;\n\tattribute def ConversionResult;\n\n\tport def UserRequestPort {\n\t\tin userRequest: UserRequest;\n\t}\n\tport def ConversionResultPort {\n\t\tout conversionResult: ConversionResult;\n\t}\n\tport def UnitPort {\n\t\tinout unit: StandardizedUnit;\n\t}\n\n\tpart context {\n\t\tpart user {\n\t\t\tport userRequestPort: UserRequestPort;\n\t\t\tperform manageUnits.sendUserRequest {\n\t\t\t\tout userRequest = userRequestPort.userRequest;\n\t\t\t}\n\t\t}\n\t\tpart unitSystemLibrary {\n\t\t\tport userRequestPort: ~UserRequestPort;\n\t\t\tport conversionResultPort: ConversionResultPort;\n\t\t\tport unitPort: UnitPort;\n\t\t\tperform manageUnits.processRequest {\n\t\t\t\tin userRequest = userRequestPort.userRequest;\n\t\t\t\tout conversionResult = conversionResultPort.conversionResult;\n\t\t\t}\n\t\t\tperform manageUnits.convertUnits {\n\t\t\t\tin unit: StandardizedUnit = unitPort.unit;\n\t\t\t\tout unit: StandardizedUnit = unitPort.unit;\n\t\t\t}\n\t\t\tperform manageUnits.ensureStandardization {\n\t\t\t\tin unitType: UnitType;\n\t\t\t\tout unit: StandardizedUnit = unitPort.unit;\n\t\t\t}\n\t\t}\n\t}\n\n\taction manageUnits {\n\t\taction sendUserRequest { out userRequest: UserRequest; }\n\t\tsuccession flow userRequestFlow from sendUserRequest.userRequest to processRequest.userRequest;\n\n\t\taction processRequest {\n\t\t\tin userRequest: UserRequest;\n\t\t\tout conversionResult: ConversionResult;\n\t\t}\n\t\tsuccession flow conversionResultFlow from processRequest.conversionResult to convertUnits.unit;\n\n\t\taction convertUnits {\n\t\t\tin unit: StandardizedUnit;\n\t\t\tout unit: StandardizedUnit;\n\t\t}\n\t\tsuccession flow unitStandardizationFlow from convertUnits.unit to ensureStandardization.unit;\n\n\t\taction ensureStandardization {\n\t\t\tin unitType: UnitType;\n\t\t\tout unit: StandardizedUnit;\n\t\t}\n\t}\n\n\ttype def ISQUnit specializes StandardizedUnit;\n\ttype def USCustomaryUnit specializes StandardizedUnit;\n\n\trelation def ConversionRuleRelatesUnits {\n\t\trelates from: ISQUnit;\n\t\trelates to: USCustomaryUnit;\n\t\tattribute conversionAccuracy: ConversionAccuracy;\n\t}\n}",
    "package 'HeadlampTiltAdjustment' {\n\timport Scalar;\n\t\n\tattribute def TiltAngle {\n\t\ttype: Scalar::Real;\n\t\tunit: Scalar::Degree;\n\t}\n\t\n\tconstant def MIN_TILT_ANGLE: Scalar::Real = 50.0;\n\tconstant def MAX_TILT_ANGLE: Scalar::Real = 80.0;\n\tconstant def PI: Scalar::Real = 3.141592653589793;\n\tconstant def E: Scalar::Real = 2.718281828459045;\n\t\n\tport def TiltAnglePort {\n\t\tout tiltAngle: TiltAngle;\n\t}\n\t\n\tpart context {\n\t\tpart adjustmentKnob {\n\t\t\tport tiltAnglePort: TiltAnglePort;\n\t\t\tperform adjustHeadlamp.setTiltAngle {\n\t\t\t\tout tiltAngle = tiltAnglePort.tiltAngle;\n\t\t\t}\n\t\t}\n\t\tpart verificationSystem {\n\t\t\tport tiltAnglePort: ~TiltAnglePort;\n\t\t\tperform adjustHeadlamp.verifyTiltAngle {\n\t\t\t\tin tiltAngle = tiltAnglePort.tiltAngle;\n\t\t\t}\n\t\t}\n\t\tinterface knobToSystem connect adjustmentKnob.tiltAnglePort to verificationSystem.tiltAnglePort {\n\t\t\tref flow references adjustHeadlamp.tiltAngleFlow\n\t\t\t\tfrom source.tiltAngle to target.tiltAngle;\n\t\t}\n\t}\n\t\n\taction adjustHeadlamp {\n\t\taction setTiltAngle { out tiltAngle: TiltAngle; }\n\t\tsuccession flow tiltAngleFlow from setTiltAngle.tiltAngle to verifyTiltAngle.tiltAngle;\n\t\taction verifyTiltAngle {\n\t\t\tin tiltAngle: TiltAngle;\n\t\t\trequirement constraint withinRange {\n\t\t\t\tassert (tiltAngle >= MIN_TILT_ANGLE) and (tiltAngle <= MAX_TILT_ANGLE);\n\t\t\t}\n\t\t}\n\t}\n\t\n\trequirement def SIUnitsAdopted {\n\t\ttext \"The system adopts the International System of Units (SI) and standard real number constants (such as pi and Eulers number e) to ensure precision and consistency in calculations.\"\n\t}\n\t\n\trequirement def ValidTiltAngleRange {\n\t\ttext \"The tilt angle of the headlamp beam must be between 50 degrees and 80 degrees inclusive; any value outside this range does not comply with safety and regulatory standards.\"\n\t}\n}",
    "package 'CoreDataManagement' {\n\n\t// Core Data Types\n\ttype def UnsignedInteger {\n\t\tconstraint NonNegative { self >= 0; }\n\t}\n\ttype def UnsignedFloat {\n\t\tconstraint NonNegative { self >= 0.0; }\n\t}\n\ttype def DateTime;\n\ttype def String;\n\ttype def Boolean;\n\n\t// Status Levels and Color Association\n\tenum def StatusLevel {\n\t\tcritical,\n\t\twarning,\n\t\tnormal\n\t}\n\tenum def StatusColor {\n\t\tred,\n\t\tyellow,\n\t\tgreen\n\t}\n\tassociation def StatusLevelToColor {\n\t\tsource statusLevel: StatusLevel;\n\t\ttarget statusColor: StatusColor;\n\t\tconstraint AssociationLogic {\n\t\t\t(statusLevel == StatusLevel::critical) implies (statusColor == StatusColor::red);\n\t\t\t(statusLevel == StatusLevel::warning) implies (statusColor == StatusColor::yellow);\n\t\t\t(statusLevel == StatusLevel::normal) implies (statusColor == StatusColor::green);\n\t\t}\n\t}\n\n\t// Physical Dimension: Diameter\n\tenum def DiameterOption {\n\t\tSmall,\n\t\tMedium,\n\t\tLarge\n\t}\n\ttype def Diameter_mm {\n\t\tvalue: UnsignedFloat;\n\t\tconstraint AllowedValues {\n\t\t\tvalue == 60.0 or value == 70.0 or value == 80.0;\n\t\t}\n\t}\n\tassociation def DiameterOptionToValue {\n\t\tsource option: DiameterOption;\n\t\ttarget value: Diameter_mm;\n\t\tconstraint OptionValueLogic {\n\t\t\t(option == DiameterOption::Small) implies (value.value == 60.0);\n\t\t\t(option == DiameterOption::Medium) implies (value.value == 70.0);\n\t\t\t(option == DiameterOption::Large) implies (value.value == 80.0);\n\t\t}\n\t}\n\n\t// System Context\n\tpart context {\n\t\tattribute unsignedInt: UnsignedInteger;\n\t\tattribute unsignedFloat: UnsignedFloat;\n\t\tattribute dateTime: DateTime;\n\t\tattribute stringVal: String;\n\t\tattribute boolVal: Boolean;\n\n\t\tattribute statusLevel: StatusLevel;\n\t\tattribute statusColor: StatusColor;\n\t\tattribute diameterOption: DiameterOption = DiameterOption::Small;\n\t\tattribute diameter: Diameter_mm = Diameter_mm { value = 60.0; };\n\n\t\t// Enforce association between status level and color\n\t\tconstraint StatusColorAssociation {\n\t\t\t(statusLevel == StatusLevel::critical) implies (statusColor == StatusColor::red);\n\t\t\t(statusLevel == StatusLevel::warning) implies (statusColor == StatusColor::yellow);\n\t\t\t(statusLevel == StatusLevel::normal) implies (statusColor == StatusColor::green);\n\t\t}\n\t\t// Enforce association between diameter option and value\n\t\tconstraint DiameterAssociation {\n\t\t\t(diameterOption == DiameterOption::Small) implies (diameter.value == 60.0);\n\t\t\t(diameterOption == DiameterOption::Medium) implies (diameter.value == 70.0);\n\t\t\t(diameterOption == DiameterOption::Large) implies (diameter.value == 80.0);\n\t\t}\n\t}\n\n\t// Extensibility Note\n\tcomment \"All data types and enumerations are defined for extensibility. Additional types, status levels, colors, and diameter options can be added as needed.\"\n}",
    "package 'CollectionManagementSystem' {\n\n\ttype SparePart;\n\ttype Person;\n\n\t// Collection Types\n\tcollection Bag<T>;\n\tcollection List<T>;\n\tcollection Set<T>;\n\tcollection OrderedSet<T>;\n\tcollection Array4<T> {\n\t\tconstant length: Integer = 4;\n\t}\n\n\t// Spare Parts Management\n\tpart SparePartsManager {\n\t\tattribute sparePartsBag: Bag<SparePart>;\n\t\toperation archiveSpareParts(in parts: Bag<SparePart>);\n\t\toperation manageSpareParts(in parts: Bag<SparePart>);\n\t}\n\n\t// Integer List Management\n\tpart IntegerListManager {\n\t\tattribute integerList: List<Integer>;\n\t\toperation storeIntegers(in values: List<Integer>);\n\t}\n\n\t// String Set Management\n\tpart StringSetManager {\n\t\tattribute stringSet: Set<String>;\n\t\toperation manageStrings(in values: Set<String>);\n\t}\n\n\t// Personnel Management\n\tpart PersonnelManager {\n\t\tattribute personnelOrderedSet: OrderedSet<Person>;\n\t\toperation managePersonnel(in personnel: OrderedSet<Person>);\n\t}\n\n\t// Nested Collection Management: List of Sets of Personnel\n\tpart NestedPersonnelManager {\n\t\tattribute personnelSetList: List<Set<Person>>;\n\t\toperation manageNestedPersonnel(in nestedPersonnel: List<Set<Person>>);\n\t}\n\n\t// Real Array Management\n\tpart RealArrayManager {\n\t\tattribute realArray: Array4<Real>;\n\t\toperation processRealArray(in values: Array4<Real>);\n\t}\n\n\t// Integration with Business Functions\n\tpart BusinessFunctionIntegrator {\n\t\tport sparePartsPort {\n\t\t\tin spareParts: Bag<SparePart>;\n\t\t}\n\t\tport personnelPort {\n\t\t\tin personnel: OrderedSet<Person>;\n\t\t}\n\t\tport integerListPort {\n\t\t\tin integerList: List<Integer>;\n\t\t}\n\t\tport stringSetPort {\n\t\t\tin stringSet: Set<String>;\n\t\t}\n\t\tport nestedPersonnelPort {\n\t\t\tin nestedPersonnel: List<Set<Person>>;\n\t\t}\n\t\tport realArrayPort {\n\t\t\tin realArray: Array4<Real>;\n\t\t}\n\t\toperation retrieveInformation();\n\t\toperation useInformation();\n\t}\n\n\t// Context\n\tpart context {\n\t\tpart sparePartsManager: SparePartsManager;\n\t\tpart integerListManager: IntegerListManager;\n\t\tpart stringSetManager: StringSetManager;\n\t\tpart personnelManager: PersonnelManager;\n\t\tpart nestedPersonnelManager: NestedPersonnelManager;\n\t\tpart realArrayManager: RealArrayManager;\n\t\tpart businessFunctionIntegrator: BusinessFunctionIntegrator;\n\n\t\t// Connections for integration and interaction\n\t\tconnect sparePartsManager.sparePartsBag to businessFunctionIntegrator.sparePartsPort.spareParts;\n\t\tconnect personnelManager.personnelOrderedSet to businessFunctionIntegrator.personnelPort.personnel;\n\t\tconnect integerListManager.integerList to businessFunctionIntegrator.integerListPort.integerList;\n\t\tconnect stringSetManager.stringSet to businessFunctionIntegrator.stringSetPort.stringSet;\n\t\tconnect nestedPersonnelManager.personnelSetList to businessFunctionIntegrator.nestedPersonnelPort.nestedPersonnel;\n\t\tconnect realArrayManager.realArray to businessFunctionIntegrator.realArrayPort.realArray;\n\t}\n}",
    "package 'TireInformation' {\n\ttype ManufacturerName is String;\n\ttype RimDiameterInch is Real;\n\ttype TireWidth is Real;\n\ttype Coordinate3D is Tuple {\n\t\tx: Real;\n\t\ty: Real;\n\t\tz: Real;\n\t}\n\n\trecord TireEntry {\n\t\tmanufacturer: ManufacturerName;\n\t\trimDiameter: RimDiameterInch;\n\t\twidth: TireWidth;\n\t\tinstallationPosition?: Coordinate3D;\n\t}\n\n\tpart context {\n\t\tattribute tireEntries: Set<TireEntry>;\n\t}\n\n\t// Example instance for illustration (not required for structure)\n\tinstance exampleTire: TireEntry {\n\t\tmanufacturer = \"Michelin\";\n\t\trimDiameter = 18.0;\n\t\twidth = 245.0;\n\t\t// installationPosition omitted (optional)\n\t}\n}",
    "package 'SpacecraftAscentTrajectorySampling' {\n\n\ttype TimeUTC {\n\t\tattribute hours: Integer;\n\t\tattribute minutes: Integer;\n\t\tattribute seconds: Real;\n\t\tattribute day: Integer;\n\t\tattribute month: Integer;\n\t\tattribute year: Integer;\n\t}\n\t\n\ttype CartesianPosition {\n\t\tattribute x: Real; // meters\n\t\tattribute y: Real; // meters\n\t\tattribute z: Real; // meters\n\t}\n\t\n\ttype CartesianVelocity {\n\t\tattribute vx: Real; // meters per second\n\t\tattribute vy: Real; // meters per second\n\t\tattribute vz: Real; // meters per second\n\t}\n\t\n\ttype TrajectorySample {\n\t\tattribute timeSinceLiftoff: Real; // seconds\n\t\tattribute position: CartesianPosition;\n\t\tattribute velocity: CartesianVelocity;\n\t}\n\t\n\tpart context {\n\t\tpart spacecraftAscentSampler {\n\t\t\tattribute liftoffTimeUTC: TimeUTC;\n\t\t\tattribute samples: TrajectorySample[];\n\t\t\t\n\t\t\tperform sampleTrajectoryDuringAscent {\n\t\t\t\tin liftoffTimeUTC: TimeUTC;\n\t\t\t\tout samples: TrajectorySample[];\n\t\t\t}\n\t\t}\n\t}\n\t\n\taction sampleTrajectoryDuringAscent {\n\t\taction setLiftoffReferenceTime {\n\t\t\tin liftoffTimeUTC: TimeUTC;\n\t\t\tout referenceTimeZero: Real; // seconds, set to 0 at liftoff\n\t\t}\n\t\taction sampleTrajectoryPoint {\n\t\t\tin referenceTimeZero: Real;\n\t\t\tout sample: TrajectorySample;\n\t\t}\n\t\tsuccession flow liftoffTimeFlow from setLiftoffReferenceTime.referenceTimeZero to sampleTrajectoryPoint.referenceTimeZero;\n\t}\n}",
    "package 'AlloyMaterialSystem' {\n\n\t// SI Units\n\tunit def Kilogram;\n\tunit def Gram;\n\tunit def Newton;\n\tunit def SquareMillimeter;\n\tunit def MassFraction; // dimensionless, 0..1\n\n\tquantity kind def Mass {\n\t\tunit: Kilogram;\n\t}\n\tquantity kind def Force {\n\t\tunit: Newton;\n\t}\n\tquantity kind def Area {\n\t\tunit: SquareMillimeter;\n\t}\n\tquantity kind def Stress {\n\t\tunit: Newton per SquareMillimeter;\n\t}\n\tquantity kind def Fraction {\n\t\tunit: MassFraction;\n\t}\n\n\t// Basic Substance\n\tblock def Substance {\n\t\tattribute name: String;\n\t\tattribute atomicMass: Mass;\n\t}\n\n\t// Material (can be a metal or other)\n\tblock def Material specializes Substance {\n\t\tattribute symbol: String;\n\t}\n\n\t// Metal\n\tblock def Metal specializes Material {\n\t}\n\n\t// Alloy\n\tblock def Alloy specializes Material {\n\t\tattribute tensileStrength: Stress;\n\t\tpart component: AlloyComponent[2..*];\n\t}\n\n\t// Alloy Component\n\tblock def AlloyComponent {\n\t\tref material: Material;\n\t\tattribute massFraction: Fraction;\n\t}\n\n\t// Library of Metals\n\tblock def Iron specializes Metal {\n\t\tname = \"Iron\";\n\t\tsymbol = \"Fe\";\n\t\tatomicMass = 55.845 Kilogram;\n\t}\n\tblock def Carbon specializes Metal {\n\t\tname = \"Carbon\";\n\t\tsymbol = \"C\";\n\t\tatomicMass = 12.011 Kilogram;\n\t}\n\tblock def Manganese specializes Metal {\n\t\tname = \"Manganese\";\n\t\tsymbol = \"Mn\";\n\t\tatomicMass = 54.938 Kilogram;\n\t}\n\n\t// Example Alloy Instance: Steel 980\n\tblock def Steel980 specializes Alloy {\n\t\tname = \"Steel 980\";\n\t\tsymbol = \"Steel980\";\n\t\ttensileStrength = 980 Newton per SquareMillimeter;\n\t\tcomponent = {\n\t\t\tAlloyComponent {\n\t\t\t\tmaterial = Iron;\n\t\t\t\tmassFraction = 0.98 MassFraction;\n\t\t\t},\n\t\t\tAlloyComponent {\n\t\t\t\tmaterial = Carbon;\n\t\t\t\tmassFraction = 0.01 MassFraction;\n\t\t\t},\n\t\t\tAlloyComponent {\n\t\t\t\tmaterial = Manganese;\n\t\t\t\tmassFraction = 0.01 MassFraction;\n\t\t\t}\n\t\t};\n\t}\n\n\t// User interaction\n\tblock def User {\n\t\toperation viewMaterialData(material: Material);\n\t\toperation editMaterialData(material: Material, property: String, value: Any);\n\t\toperation addAlloyComponent(alloy: Alloy, component: AlloyComponent);\n\t\toperation createMaterialInstance(name: String, symbol: String, atomicMass: Mass): Material;\n\t\toperation createAlloyInstance(name: String, symbol: String, tensileStrength: Stress, components: AlloyComponent[*]): Alloy;\n\t}\n\n\t// System Context\n\tpart context {\n\t\tpart user: User;\n\t\tpart materialLibrary: Material[*];\n\t\tpart alloyLibrary: Alloy[*];\n\t}\n\n}",
    "package 'EngineeringMaterialsDatabase' {\n\n\t// Fundamental types and units\n\ttype def AtomicMass : Real;\n\ttype def MassFraction : Real;\n\ttype def TensileStrength : Real;\n\tunit def NewtonPerSquareMillimeter : 'N/mm^2';\n\n\t// Property definitions\n\tproperty def atomicMass : AtomicMass;\n\tproperty def massFraction : MassFraction;\n\tproperty def tensileStrength : TensileStrength;\n\tproperty def compositionalInfo : Map<Material, MassFraction>;\n\n\t// Material hierarchy\n\tblock def Material {\n\t\tattribute name : String;\n\t\tattribute atomicMass : AtomicMass;\n\t}\n\n\tblock def Metal extends Material {\n\t\tattribute compositionalInfo : Map<Material, MassFraction>;\n\t}\n\n\tblock def Alloy extends Metal {\n\t\tattribute compositionalInfo : Map<Material, MassFraction>;\n\t}\n\n\tblock def MechanicalProperty {\n\t\tattribute tensileStrength : TensileStrength;\n\t\tattribute unit : String;\n\t}\n\n\t// Example: Steel_980\n\tblock def Steel_980 extends Alloy {\n\t\tattribute name = 'Steel_980';\n\t\tattribute compositionalInfo = Map {\n\t\t\t'Iron' -> 0.96,\n\t\t\t'Carbon' -> 0.002,\n\t\t\t'Manganese' -> 0.018\n\t\t};\n\t\tattribute atomicMass = 55.85; // Example value for iron\n\t}\n\n\tblock def Steel_980_MechanicalProperty extends MechanicalProperty {\n\t\tattribute tensileStrength = 980.0;\n\t\tattribute unit = 'N/mm^2';\n\t}\n\n\t// System context\n\tblock def EngineeringMaterialsDatabaseSystem {\n\t\tattribute materials : Set<Material>;\n\t\tattribute mechanicalProperties : Map<Material, MechanicalProperty>;\n\t\toperation addMaterial(material : Material);\n\t\toperation queryMaterialByName(name : String) : Material;\n\t\toperation compareMaterials(material1 : Material, material2 : Material) : String;\n\t}\n\n\t// User interaction\n\tblock def EndUser {\n\t\toperation enterMaterialData(material : Material);\n\t\toperation queryMaterial(materialName : String) : Material;\n\t\toperation compareMaterials(material1 : Material, material2 : Material) : String;\n\t}\n\n\t// Usage scenario\n\tinteraction def MaterialDataEntryAndQuery {\n\t\tpart user : EndUser;\n\t\tpart db : EngineeringMaterialsDatabaseSystem;\n\t\tstep user.enterMaterialData(Steel_980);\n\t\tstep db.addMaterial(Steel_980);\n\t\tstep user.queryMaterial('Steel_980');\n\t\tstep db.queryMaterialByName('Steel_980');\n\t\tstep user.compareMaterials(Steel_980, Steel_980);\n\t\tstep db.compareMaterials(Steel_980, Steel_980);\n\t}\n}",
    "package 'PubSubSystem' {\n\tattribute def Topic;\n\tattribute def Message;\n\tattribute def SubscriptionRequest;\n\tattribute def PublishRequest;\n\n\tport def PublishPort {\n\t\tout publishRequest: PublishRequest;\n\t}\n\tport def SubscribePort {\n\t\tout subscriptionRequest: SubscriptionRequest;\n\t}\n\tport def MessageDeliveryPort {\n\t\tout message: Message;\n\t}\n\n\tpart context {\n\t\tpart producer {\n\t\t\tport publishPort: PublishPort;\n\t\t\tperform pubSubInteraction.publishMessage {\n\t\t\t\tout publishRequest = publishPort.publishRequest;\n\t\t\t}\n\t\t}\n\t\tpart consumer {\n\t\t\tport subscribePort: SubscribePort;\n\t\t\tport messageDeliveryPort: ~MessageDeliveryPort;\n\t\t\tperform pubSubInteraction.subscribeToTopic {\n\t\t\t\tout subscriptionRequest = subscribePort.subscriptionRequest;\n\t\t\t}\n\t\t\tperform pubSubInteraction.receiveMessage {\n\t\t\t\tin message = messageDeliveryPort.message;\n\t\t\t}\n\t\t}\n\t\tpart server {\n\t\t\tport publishPort: ~PublishPort;\n\t\t\tport subscribePort: ~SubscribePort;\n\t\t\tport messageDeliveryPort: MessageDeliveryPort;\n\t\t\tperform pubSubInteraction.manageSubscriptions {\n\t\t\t\tin subscriptionRequest = subscribePort.subscriptionRequest;\n\t\t\t}\n\t\t\tperform pubSubInteraction.receivePublish {\n\t\t\t\tin publishRequest = publishPort.publishRequest;\n\t\t\t}\n\t\t\tperform pubSubInteraction.distributeMessage {\n\t\t\t\tout message = messageDeliveryPort.message;\n\t\t\t}\n\t\t}\n\t\tinterface producerToServer connect producer.publishPort to server.publishPort {\n\t\t\tref flow references pubSubInteraction.publishFlow\n\t\t\t\tfrom source.publishRequest to target.publishRequest;\n\t\t}\n\t\tinterface consumerToServer connect consumer.subscribePort to server.subscribePort {\n\t\t\tref flow references pubSubInteraction.subscriptionFlow\n\t\t\t\tfrom source.subscriptionRequest to target.subscriptionRequest;\n\t\t}\n\t\tinterface serverToConsumer connect server.messageDeliveryPort to consumer.messageDeliveryPort {\n\t\t\tref flow references pubSubInteraction.messageDeliveryFlow\n\t\t\t\tfrom source.message to target.message;\n\t\t}\n\t}\n\n\taction pubSubInteraction {\n\t\taction publishMessage { out publishRequest: PublishRequest; }\n\t\taction subscribeToTopic { out subscriptionRequest: SubscriptionRequest; }\n\t\taction receivePublish { in publishRequest: PublishRequest; }\n\t\taction manageSubscriptions { in subscriptionRequest: SubscriptionRequest; }\n\t\taction distributeMessage { out message: Message; }\n\t\taction receiveMessage { in message: Message; }\n\n\t\tsuccession flow publishFlow from publishMessage.publishRequest to receivePublish.publishRequest;\n\t\tsuccession flow subscriptionFlow from subscribeToTopic.subscriptionRequest to manageSubscriptions.subscriptionRequest;\n\t\tsuccession flow messageDeliveryFlow from distributeMessage.message to receiveMessage.message;\n\t}\n}",
    "package 'VehicleFuelSystem' {\n\tattribute def Fuel;\n\tattribute def FuelTemperature;\n\tport def FuelSupplyPort {\n\t\tout fuel: Fuel;\n\t}\n\tport def FuelReturnPort {\n\t\tin fuel: Fuel;\n\t}\n\tport def FuelTemperaturePort {\n\t\tout fuelTemperature: FuelTemperature;\n\t}\n\tpart context {\n\t\tpart fuelTankAssembly {\n\t\t\tport fuelSupplyPort: FuelSupplyPort;\n\t\t\tport fuelReturnPort: ~FuelReturnPort;\n\t\t\tport fuelTemperaturePort: FuelTemperaturePort;\n\t\t\tperform manageFuelSystem.supplyFuel {\n\t\t\t\tout fuel = fuelSupplyPort.fuel;\n\t\t\t}\n\t\t\tperform manageFuelSystem.receiveReturnedFuel {\n\t\t\t\tin fuel = fuelReturnPort.fuel;\n\t\t\t}\n\t\t\tperform manageFuelSystem.monitorFuelTemperature {\n\t\t\t\tout fuelTemperature = fuelTemperaturePort.fuelTemperature;\n\t\t\t}\n\t\t}\n\t\tpart engine {\n\t\t\tport fuelSupplyPort: ~FuelSupplyPort;\n\t\t\tport fuelReturnPort: FuelReturnPort;\n\t\t\tport fuelTemperaturePort: ~FuelTemperaturePort;\n\t\t\tperform manageFuelSystem.consumeFuel {\n\t\t\t\tin fuel = fuelSupplyPort.fuel;\n\t\t\t\tout fuel = fuelReturnPort.fuel;\n\t\t\t}\n\t\t\tperform manageFuelSystem.receiveFuelTemperature {\n\t\t\t\tin fuelTemperature = fuelTemperaturePort.fuelTemperature;\n\t\t\t}\n\t\t}\n\t\tinterface supplyFuel connect fuelTankAssembly.fuelSupplyPort to engine.fuelSupplyPort {\n\t\t\tref flow references manageFuelSystem.fuelSupplyFlow\n\t\t\t\tfrom source.fuel to target.fuel;\n\t\t}\n\t\tinterface returnFuel connect engine.fuelReturnPort to fuelTankAssembly.fuelReturnPort {\n\t\t\tref flow references manageFuelSystem.fuelReturnFlow\n\t\t\t\tfrom source.fuel to target.fuel;\n\t\t}\n\t\tinterface transmitFuelTemperature connect fuelTankAssembly.fuelTemperaturePort to engine.fuelTemperaturePort {\n\t\t\tref flow references manageFuelSystem.fuelTemperatureFlow\n\t\t\t\tfrom source.fuelTemperature to target.fuelTemperature;\n\t\t}\n\t}\n\taction manageFuelSystem {\n\t\taction supplyFuel { out fuel: Fuel; }\n\t\taction receiveReturnedFuel { in fuel: Fuel; }\n\t\taction consumeFuel { in fuel: Fuel; out fuel: Fuel; }\n\t\taction monitorFuelTemperature { out fuelTemperature: FuelTemperature; }\n\t\taction receiveFuelTemperature { in fuelTemperature: FuelTemperature; }\n\t\tsuccession flow fuelSupplyFlow from supplyFuel.fuel to consumeFuel.fuel;\n\t\tsuccession flow fuelReturnFlow from consumeFuel.fuel to receiveReturnedFuel.fuel;\n\t\tsuccession flow fuelTemperatureFlow from monitorFuelTemperature.fuelTemperature to receiveFuelTemperature.fuelTemperature;\n\t}\n}",
    "package 'PubSubSystem' {\n\tattribute def Topic;\n\tattribute def Message;\n\tattribute def SubscriptionRequest;\n\tattribute def SubscriptionAck;\n\n\tport def PublishPort {\n\t\tout topic: Topic;\n\t\tout message: Message;\n\t}\n\tport def SubscribePort {\n\t\tout subscriptionRequest: SubscriptionRequest;\n\t\tin subscriptionAck: SubscriptionAck;\n\t}\n\tport def DeliveryPort {\n\t\tin topic: Topic;\n\t\tin message: Message;\n\t}\n\n\tpart context {\n\t\tpart producer {\n\t\t\tport publishPort: PublishPort;\n\t\t\tperform pubsubFlow.publishMessage {\n\t\t\t\tout topic = publishPort.topic;\n\t\t\t\tout message = publishPort.message;\n\t\t\t}\n\t\t}\n\t\tpart consumer {\n\t\t\tport subscribePort: SubscribePort;\n\t\t\tport deliveryPort: DeliveryPort;\n\t\t\tperform pubsubFlow.sendSubscriptionRequest {\n\t\t\t\tout subscriptionRequest = subscribePort.subscriptionRequest;\n\t\t\t}\n\t\t\tperform pubsubFlow.receiveSubscriptionAck {\n\t\t\t\tin subscriptionAck = subscribePort.subscriptionAck;\n\t\t\t}\n\t\t\tperform pubsubFlow.receiveMessage {\n\t\t\t\tin topic = deliveryPort.topic;\n\t\t\t\tin message = deliveryPort.message;\n\t\t\t}\n\t\t}\n\t\tpart server {\n\t\t\tport producerPublishPort: ~PublishPort;\n\t\t\tport consumerSubscribePort: ~SubscribePort;\n\t\t\tport consumerDeliveryPort: ~DeliveryPort;\n\t\t\tperform pubsubFlow.acceptSubscription {\n\t\t\t\tin subscriptionRequest = consumerSubscribePort.subscriptionRequest;\n\t\t\t\tout subscriptionAck = consumerSubscribePort.subscriptionAck;\n\t\t\t}\n\t\t\tperform pubsubFlow.acceptPublish {\n\t\t\t\tin topic = producerPublishPort.topic;\n\t\t\t\tin message = producerPublishPort.message;\n\t\t\t}\n\t\t\tperform pubsubFlow.deliverMessage {\n\t\t\t\tin topic;\n\t\t\t\tin message;\n\t\t\t\tout topic = consumerDeliveryPort.topic;\n\t\t\t\tout message = consumerDeliveryPort.message;\n\t\t\t}\n\t\t}\n\t\tinterface producerToServer connect producer.publishPort to server.producerPublishPort {\n\t\t\tref flow references pubsubFlow.publishFlow\n\t\t\t\tfrom source.topic to target.topic,\n\t\t\t\tfrom source.message to target.message;\n\t\t}\n\t\tinterface consumerToServer connect consumer.subscribePort to server.consumerSubscribePort {\n\t\t\tref flow references pubsubFlow.subscriptionFlow\n\t\t\t\tfrom source.subscriptionRequest to target.subscriptionRequest,\n\t\t\t\tfrom target.subscriptionAck to source.subscriptionAck;\n\t\t}\n\t\tinterface serverToConsumer connect server.consumerDeliveryPort to consumer.deliveryPort {\n\t\t\tref flow references pubsubFlow.deliveryFlow\n\t\t\t\tfrom source.topic to target.topic,\n\t\t\t\tfrom source.message to target.message;\n\t\t}\n\t}\n\n\taction pubsubFlow {\n\t\taction publishMessage { out topic: Topic; out message: Message; }\n\t\taction sendSubscriptionRequest { out subscriptionRequest: SubscriptionRequest; }\n\t\taction receiveSubscriptionAck { in subscriptionAck: SubscriptionAck; }\n\t\taction acceptSubscription { in subscriptionRequest: SubscriptionRequest; out subscriptionAck: SubscriptionAck; }\n\t\taction acceptPublish { in topic: Topic; in message: Message; }\n\t\taction deliverMessage { in topic: Topic; in message: Message; out topic: Topic; out message: Message; }\n\t\taction receiveMessage { in topic: Topic; in message: Message; }\n\n\t\tsuccession flow subscriptionFlow from sendSubscriptionRequest.subscriptionRequest to acceptSubscription.subscriptionRequest;\n\t\tsuccession flow subscriptionAckFlow from acceptSubscription.subscriptionAck to receiveSubscriptionAck.subscriptionAck;\n\t\tsuccession flow publishFlow from publishMessage.topic to acceptPublish.topic, from publishMessage.message to acceptPublish.message;\n\t\tsuccession flow deliveryFlow from acceptPublish.topic to deliverMessage.topic, from acceptPublish.message to deliverMessage.message;\n\t\tsuccession flow deliverToConsumerFlow from deliverMessage.topic to receiveMessage.topic, from deliverMessage.message to receiveMessage.message;\n\t}\n}",
    "package 'TransportationSystem' {\n\tattribute def BoardingCmd;\n\tattribute def AlightingCmd;\n\tattribute def TravelTask;\n\tattribute def FuelLevel;\n\tattribute def RefuelCmd;\n\tattribute def EnvironmentFactor;\n\tattribute def SafetyStatus;\n\n\tport def BoardingPort {\n\t\tout boardingCmd: BoardingCmd;\n\t}\n\tport def AlightingPort {\n\t\tout alightingCmd: AlightingCmd;\n\t}\n\tport def TravelTaskPort {\n\t\tout travelTask: TravelTask;\n\t}\n\tport def FuelLevelPort {\n\t\tin fuelLevel: FuelLevel;\n\t}\n\tport def RefuelPort {\n\t\tout refuelCmd: RefuelCmd;\n\t}\n\tport def EnvironmentPort {\n\t\tin environmentFactor: EnvironmentFactor;\n\t}\n\tport def SafetyStatusPort {\n\t\tout safetyStatus: SafetyStatus;\n\t}\n\n\tpart context {\n\t\tpart userGroup {\n\t\t\tpart driver {\n\t\t\t\tport boardingPort: BoardingPort;\n\t\t\t\tport alightingPort: AlightingPort;\n\t\t\t\tport travelTaskPort: TravelTaskPort;\n\t\t\t\tport refuelPort: RefuelPort;\n\t\t\t\tport safetyStatusPort: SafetyStatusPort;\n\t\t\t\tperform transportScenario.driverBoarding {\n\t\t\t\t\tout boardingCmd = boardingPort.boardingCmd;\n\t\t\t\t}\n\t\t\t\tperform transportScenario.driverAlighting {\n\t\t\t\t\tout alightingCmd = alightingPort.alightingCmd;\n\t\t\t\t}\n\t\t\t\tperform transportScenario.initiateTravelTask {\n\t\t\t\t\tout travelTask = travelTaskPort.travelTask;\n\t\t\t\t}\n\t\t\t\tperform transportScenario.initiateRefuel {\n\t\t\t\t\tout refuelCmd = refuelPort.refuelCmd;\n\t\t\t\t}\n\t\t\t\tperform transportScenario.reportSafetyStatus {\n\t\t\t\t\tout safetyStatus = safetyStatusPort.safetyStatus;\n\t\t\t\t}\n\t\t\t}\n\t\t\tpart passenger[4] {\n\t\t\t\tport boardingPort: BoardingPort;\n\t\t\t\tport alightingPort: AlightingPort;\n\t\t\t\tport safetyStatusPort: SafetyStatusPort;\n\t\t\t\tperform transportScenario.passengerBoarding {\n\t\t\t\t\tout boardingCmd = boardingPort.boardingCmd;\n\t\t\t\t}\n\t\t\t\tperform transportScenario.passengerAlighting {\n\t\t\t\t\tout alightingCmd = alightingPort.alightingCmd;\n\t\t\t\t}\n\t\t\t\tperform transportScenario.reportSafetyStatus {\n\t\t\t\t\tout safetyStatus = safetyStatusPort.safetyStatus;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tpart vehicle {\n\t\t\tport boardingPort: ~BoardingPort;\n\t\t\tport alightingPort: ~AlightingPort;\n\t\t\tport travelTaskPort: ~TravelTaskPort;\n\t\t\tport fuelLevelPort: FuelLevelPort;\n\t\t\tport refuelPort: ~RefuelPort;\n\t\t\tport environmentPort: EnvironmentPort;\n\t\t\tport safetyStatusPort: ~SafetyStatusPort;\n\t\t\tperform transportScenario.handleBoarding {\n\t\t\t\tin boardingCmd = boardingPort.boardingCmd;\n\t\t\t}\n\t\t\tperform transportScenario.handleAlighting {\n\t\t\t\tin alightingCmd = alightingPort.alightingCmd;\n\t\t\t}\n\t\t\tperform transportScenario.executeTravelTask {\n\t\t\t\tin travelTask = travelTaskPort.travelTask;\n\t\t\t\tin environmentFactor = environmentPort.environmentFactor;\n\t\t\t\tin fuelLevel = fuelLevelPort.fuelLevel;\n\t\t\t}\n\t\t\tperform transportScenario.handleRefuel {\n\t\t\t\tin refuelCmd = refuelPort.refuelCmd;\n\t\t\t}\n\t\t\tperform transportScenario.ensureSafety {\n\t\t\t\tout safetyStatus = safetyStatusPort.safetyStatus;\n\t\t\t}\n\t\t}\n\t\tpart environment {\n\t\t\tport environmentPort: ~EnvironmentPort;\n\t\t\tperform transportScenario.provideEnvironmentFactor {\n\t\t\t\tout environmentFactor = environmentPort.environmentFactor;\n\t\t\t}\n\t\t}\n\t}\n\n\taction transportScenario {\n\t\taction driverBoarding { out boardingCmd: BoardingCmd; }\n\t\taction passengerBoarding { out boardingCmd: BoardingCmd; }\n\t\tsuccession flow boardingFlow from driverBoarding.boardingCmd to handleBoarding.boardingCmd;\n\t\tsuccession flow passengerBoardingFlow from passengerBoarding.boardingCmd to handleBoarding.boardingCmd;\n\n\t\taction handleBoarding { in boardingCmd: BoardingCmd; }\n\n\t\taction initiateTravelTask { out travelTask: TravelTask; }\n\t\tsuccession flow travelTaskFlow from initiateTravelTask.travelTask to executeTravelTask.travelTask;\n\n\t\taction provideEnvironmentFactor { out environmentFactor: EnvironmentFactor; }\n\t\tsuccession flow environmentFlow from provideEnvironmentFactor.environmentFactor to executeTravelTask.environmentFactor;\n\n\t\taction executeTravelTask { in travelTask: TravelTask; in environmentFactor: EnvironmentFactor; in fuelLevel: FuelLevel; }\n\n\t\taction initiateRefuel { out refuelCmd: RefuelCmd; }\n\t\tsuccession flow refuelFlow from initiateRefuel.refuelCmd to handleRefuel.refuelCmd;\n\n\t\taction handleRefuel { in refuelCmd: RefuelCmd; }\n\n\t\taction driverAlighting { out alightingCmd: AlightingCmd; }\n\t\taction passengerAlighting { out alightingCmd: AlightingCmd; }\n\t\tsuccession flow alightingFlow from driverAlighting.alightingCmd to handleAlighting.alightingCmd;\n\t\tsuccession flow passengerAlightingFlow from passengerAlighting.alightingCmd to handleAlighting.alightingCmd;\n\n\t\taction handleAlighting { in alightingCmd: AlightingCmd; }\n\n\t\taction reportSafetyStatus { out safetyStatus: SafetyStatus; }\n\t\tsuccession flow safetyStatusFlow from reportSafetyStatus.safetyStatus to ensureSafety.safetyStatus;\n\n\t\taction ensureSafety { out safetyStatus: SafetyStatus; }\n\t}\n}",
    "package 'FuelSupplyReturnSystem' {\n\tattribute def Fuel;\n\tattribute def FuelTemperature;\n\t\n\tport def FuelPort {\n\t\tinout fuel: Fuel;\n\t\tinout fuelTemperature: FuelTemperature;\n\t}\n\t\n\tpart context {\n\t\tpart fuelTankAssembly {\n\t\t\tport fuelOutletPort: FuelPort;\n\t\t\tport fuelReturnPort: FuelPort;\n\t\t\tperform fuelManagement.supplyFuel {\n\t\t\t\tout fuel = fuelOutletPort.fuel;\n\t\t\t\tout fuelTemperature = fuelOutletPort.fuelTemperature;\n\t\t\t}\n\t\t\tperform fuelManagement.receiveReturnFuel {\n\t\t\t\tin fuel = fuelReturnPort.fuel;\n\t\t\t\tin fuelTemperature = fuelReturnPort.fuelTemperature;\n\t\t\t}\n\t\t}\n\t\tpart engineUnit {\n\t\t\tport fuelInletPort: ~FuelPort;\n\t\t\tport fuelReturnPort: ~FuelPort;\n\t\t\tperform fuelManagement.consumeFuel {\n\t\t\t\tin fuel = fuelInletPort.fuel;\n\t\t\t\tin fuelTemperature = fuelInletPort.fuelTemperature;\n\t\t\t}\n\t\t\tperform fuelManagement.returnFuel {\n\t\t\t\tout fuel = fuelReturnPort.fuel;\n\t\t\t\tout fuelTemperature = fuelReturnPort.fuelTemperature;\n\t\t\t}\n\t\t}\n\t\tinterface fuelSupply connect fuelTankAssembly.fuelOutletPort to engineUnit.fuelInletPort {\n\t\t\tref flow references fuelManagement.supplyFlow\n\t\t\t\tfrom source.fuel to target.fuel;\n\t\t\tref flow references fuelManagement.supplyTempFlow\n\t\t\t\tfrom source.fuelTemperature to target.fuelTemperature;\n\t\t}\n\t\tinterface fuelReturn connect engineUnit.fuelReturnPort to fuelTankAssembly.fuelReturnPort {\n\t\t\tref flow references fuelManagement.returnFlow\n\t\t\t\tfrom source.fuel to target.fuel;\n\t\t\tref flow references fuelManagement.returnTempFlow\n\t\t\t\tfrom source.fuelTemperature to target.fuelTemperature;\n\t\t}\n\t}\n\t\n\taction fuelManagement {\n\t\taction supplyFuel { out fuel: Fuel; out fuelTemperature: FuelTemperature; }\n\t\taction receiveReturnFuel { in fuel: Fuel; in fuelTemperature: FuelTemperature; }\n\t\taction consumeFuel { in fuel: Fuel; in fuelTemperature: FuelTemperature; }\n\t\taction returnFuel { out fuel: Fuel; out fuelTemperature: FuelTemperature; }\n\t\t\n\t\tsuccession flow supplyFlow from supplyFuel.fuel to consumeFuel.fuel;\n\t\tsuccession flow supplyTempFlow from supplyFuel.fuelTemperature to consumeFuel.fuelTemperature;\n\t\tsuccession flow returnFlow from returnFuel.fuel to receiveReturnFuel.fuel;\n\t\tsuccession flow returnTempFlow from returnFuel.fuelTemperature to receiveReturnFuel.fuelTemperature;\n\t}\n}",
    "package 'VehicleFuelSystem' {\n\tattribute def Fuel;\n\tattribute def FuelTemperature;\n\tport def FuelSupplyPort {\n\t\tout fuel: Fuel;\n\t\tout temperature: FuelTemperature;\n\t}\n\tport def FuelReturnPort {\n\t\tin fuel: Fuel;\n\t\tin temperature: FuelTemperature;\n\t}\n\tpart context {\n\t\tpart fuelTankAssembly {\n\t\t\tport supplyPort: FuelSupplyPort;\n\t\t\tport returnPort: FuelReturnPort;\n\t\t\tperform fuelManagement.supplyFuel {\n\t\t\t\tout fuel = supplyPort.fuel;\n\t\t\t\tout temperature = supplyPort.temperature;\n\t\t\t}\n\t\t\tperform fuelManagement.receiveReturnedFuel {\n\t\t\t\tin fuel = returnPort.fuel;\n\t\t\t\tin temperature = returnPort.temperature;\n\t\t\t}\n\t\t}\n\t\tpart engine {\n\t\t\tport supplyPort: ~FuelSupplyPort;\n\t\t\tport returnPort: ~FuelReturnPort;\n\t\t\tperform fuelManagement.consumeFuel {\n\t\t\t\tin fuel = supplyPort.fuel;\n\t\t\t\tin temperature = supplyPort.temperature;\n\t\t\t}\n\t\t\tperform fuelManagement.returnUnusedFuel {\n\t\t\t\tout fuel = returnPort.fuel;\n\t\t\t\tout temperature = returnPort.temperature;\n\t\t\t}\n\t\t}\n\t\tinterface supplyConnection connect fuelTankAssembly.supplyPort to engine.supplyPort {\n\t\t\tref flow references fuelManagement.supplyFlow\n\t\t\t\tfrom source.fuel to target.fuel,\n\t\t\t\tfrom source.temperature to target.temperature;\n\t\t}\n\t\tinterface returnConnection connect engine.returnPort to fuelTankAssembly.returnPort {\n\t\t\tref flow references fuelManagement.returnFlow\n\t\t\t\tfrom source.fuel to target.fuel,\n\t\t\t\tfrom source.temperature to target.temperature;\n\t\t}\n\t}\n\taction fuelManagement {\n\t\taction supplyFuel { out fuel: Fuel; out temperature: FuelTemperature; }\n\t\taction consumeFuel { in fuel: Fuel; in temperature: FuelTemperature; }\n\t\tsuccession flow supplyFlow from supplyFuel.fuel to consumeFuel.fuel;\n\t\tsuccession flow supplyTempFlow from supplyFuel.temperature to consumeFuel.temperature;\n\t\taction returnUnusedFuel { out fuel: Fuel; out temperature: FuelTemperature; }\n\t\taction receiveReturnedFuel { in fuel: Fuel; in temperature: FuelTemperature; }\n\t\tsuccession flow returnFlow from returnUnusedFuel.fuel to receiveReturnedFuel.fuel;\n\t\tsuccession flow returnTempFlow from returnUnusedFuel.temperature to receiveReturnedFuel.temperature;\n\t}\n}",
    "package 'PhotoCapture' {\n\tattribute def SceneSelection;\n\tattribute def FocusedImage;\n\tattribute def Photo;\n\tport def SceneSelectionPort {\n\t\tout sceneSelection: SceneSelection;\n\t}\n\tport def PhotoPort {\n\t\tout photo: Photo;\n\t}\n\tpart context {\n\t\tpart user {\n\t\t\tport sceneSelectionPort: SceneSelectionPort;\n\t\t\tperform capturePhoto.selectScene {\n\t\t\t\tout sceneSelection = sceneSelectionPort.sceneSelection;\n\t\t\t}\n\t\t}\n\t\tinterface userToSystem connect user.sceneSelectionPort to system.sceneSelectionPort {\n\t\t\tref flow references capturePhoto.sceneSelectionFlow\n\t\t\t\tfrom source.sceneSelection to target.sceneSelection;\n\t\t}\n\t\tpart system {\n\t\t\tport sceneSelectionPort: ~SceneSelectionPort;\n\t\t\tport photoPort: PhotoPort;\n\t\t\tperform capturePhoto.focusScene {\n\t\t\t\tin sceneSelection = sceneSelectionPort.sceneSelection;\n\t\t\t\tout focusedImage: FocusedImage;\n\t\t\t}\n\t\t\tperform capturePhoto.capturePhoto {\n\t\t\t\tin focusedImage: FocusedImage;\n\t\t\t\tout photo = photoPort.photo;\n\t\t\t}\n\t\t}\n\t}\n\taction capturePhoto {\n\t\taction selectScene { out sceneSelection: SceneSelection; }\n\t\tsuccession flow sceneSelectionFlow from selectScene.sceneSelection to focusScene.sceneSelection;\n\t\taction focusScene { in sceneSelection: SceneSelection; out focusedImage: FocusedImage; }\n\t\tsuccession flow focusFlow from focusScene.focusedImage to capturePhoto.focusedImage;\n\t\taction capturePhoto { in focusedImage: FocusedImage; out photo: Photo; }\n\t}\n}",
    "package 'PhotographyWorkflow' {\n\tattribute def SceneSelection;\n\tattribute def FocusedImage;\n\tattribute def FinalPhoto;\n\n\tport def SceneSelectionPort {\n\t\tout sceneSelection: SceneSelection;\n\t}\n\tport def FocusedImagePort {\n\t\tout focusedImage: FocusedImage;\n\t}\n\tport def FinalPhotoPort {\n\t\tout finalPhoto: FinalPhoto;\n\t}\n\n\tpart context {\n\t\tpart user {\n\t\t\tport sceneSelectionPort: SceneSelectionPort;\n\t\t\tperform workflow.selectScene {\n\t\t\t\tout sceneSelection = sceneSelectionPort.sceneSelection;\n\t\t\t}\n\t\t}\n\t\tinterface userToSystem connect user.sceneSelectionPort to system.sceneSelectionPort {\n\t\t\tref flow references workflow.sceneSelectionFlow\n\t\t\t\tfrom source.sceneSelection to target.sceneSelection;\n\t\t}\n\t\tpart system {\n\t\t\tport sceneSelectionPort: ~SceneSelectionPort;\n\t\t\tport focusedImagePort: FocusedImagePort;\n\t\t\tport finalPhotoPort: FinalPhotoPort;\n\n\t\t\tperform workflow.focusScene {\n\t\t\t\tin sceneSelection = sceneSelectionPort.sceneSelection;\n\t\t\t\tout focusedImage = focusedImagePort.focusedImage;\n\t\t\t}\n\t\t\tperform workflow.shootPhoto {\n\t\t\t\tin focusedImage = focusedImagePort.focusedImage;\n\t\t\t\tout finalPhoto = finalPhotoPort.finalPhoto;\n\t\t\t}\n\t\t}\n\t}\n\n\taction workflow {\n\t\taction selectScene { out sceneSelection: SceneSelection; }\n\t\tsuccession flow sceneSelectionFlow from selectScene.sceneSelection to focusScene.sceneSelection;\n\t\taction focusScene { in sceneSelection; out focusedImage: FocusedImage; }\n\t\tsuccession flow focusFlow from focusScene.focusedImage to shootPhoto.focusedImage;\n\t\taction shootPhoto { in focusedImage; out finalPhoto: FinalPhoto; }\n\t}\n}",
    "package 'PhotographyWorkflow' {\n\tattribute def Scene;\n\tattribute def Image;\n\tattribute def Photograph;\n\n\tport def SceneSelectionPort {\n\t\tout selectedScene: Scene;\n\t}\n\tport def PhotographPort {\n\t\tout photograph: Photograph;\n\t}\n\n\tpart context {\n\t\tpart user {\n\t\t\tport sceneSelectionPort: SceneSelectionPort;\n\t\t\tperform captureScene.selectScene {\n\t\t\t\tout selectedScene = sceneSelectionPort.selectedScene;\n\t\t\t}\n\t\t}\n\t\tinterface userToSystem connect user.sceneSelectionPort to system.sceneSelectionPort {\n\t\t\tref flow references captureScene.sceneSelectionFlow\n\t\t\t\tfrom source.selectedScene to target.selectedScene;\n\t\t}\n\t\tpart system {\n\t\t\tport sceneSelectionPort: ~SceneSelectionPort;\n\t\t\tport photographPort: PhotographPort;\n\t\t\tperform captureScene.focusScene {\n\t\t\t\tin selectedScene = sceneSelectionPort.selectedScene;\n\t\t\t\tout image: Image;\n\t\t\t}\n\t\t\tperform captureScene.shootScene {\n\t\t\t\tin image: Image;\n\t\t\t\tout photograph = photographPort.photograph;\n\t\t\t}\n\t\t}\n\t}\n\n\taction captureScene {\n\t\taction selectScene { out selectedScene: Scene; }\n\t\tsuccession flow sceneSelectionFlow from selectScene.selectedScene to focusScene.selectedScene;\n\t\taction focusScene { in selectedScene: Scene; out image: Image; }\n\t\tsuccession flow focusToShootFlow from focusScene.image to shootScene.image;\n\t\taction shootScene { in image: Image; out photograph: Photograph; }\n\t}\n}",
    "package 'AutomatedPhotography' {\n\tattribute def Scene;\n\tattribute def FocusedImage;\n\tattribute def Photograph;\n\tport def ScenePort {\n\t\tout scene: Scene;\n\t}\n\tport def FocusedImagePort {\n\t\tout focusedImage: FocusedImage;\n\t}\n\tport def PhotographPort {\n\t\tout photograph: Photograph;\n\t}\n\tpart context {\n\t\tpart user {\n\t\t\tport scenePort: ScenePort;\n\t\t\tperform automatePhotography.provideScene {\n\t\t\t\tout scene = scenePort.scene;\n\t\t\t}\n\t\t}\n\t\tinterface userToSystem connect user.scenePort to system.scenePort {\n\t\t\tref flow references automatePhotography.sceneFlow\n\t\t\t\tfrom source.scene to target.scene;\n\t\t}\n\t\tpart system {\n\t\t\tport scenePort: ~ScenePort;\n\t\t\tport focusedImagePort: FocusedImagePort;\n\t\t\tport photographPort: PhotographPort;\n\t\t\tperform automatePhotography.focusScene {\n\t\t\t\tin scene = scenePort.scene;\n\t\t\t\tout focusedImage = focusedImagePort.focusedImage;\n\t\t\t}\n\t\t\tperform automatePhotography.shootPhoto {\n\t\t\t\tin focusedImage = focusedImagePort.focusedImage;\n\t\t\t\tout photograph = photographPort.photograph;\n\t\t\t}\n\t\t}\n\t}\n\taction automatePhotography {\n\t\taction provideScene { out scene: Scene; }\n\t\tsuccession flow sceneFlow from provideScene.scene to focusScene.scene;\n\t\taction focusScene { in scene: Scene; out focusedImage: FocusedImage; }\n\t\tsuccession flow focusFlow from focusScene.focusedImage to shootPhoto.focusedImage;\n\t\taction shootPhoto { in focusedImage: FocusedImage; out photograph: Photograph; }\n\t}\n}",
    "package 'PhotographyWorkflow' {\n\tattribute def Scene;\n\tattribute def Image;\n\tattribute def Picture;\n\tport def SceneInputPort {\n\t\tout scene: Scene;\n\t}\n\tport def PictureOutputPort {\n\t\tout picture: Picture;\n\t}\n\tpart context {\n\t\tpart user {\n\t\t\tport sceneInputPort: SceneInputPort;\n\t\t\tperform photographyWorkflow.inputScene {\n\t\t\t\tout scene = sceneInputPort.scene;\n\t\t\t}\n\t\t}\n\t\tinterface userToWorkflow connect user.sceneInputPort to workflow.sceneInputPort {\n\t\t\tref flow references photographyWorkflow.sceneFlow\n\t\t\t\tfrom source.scene to target.scene;\n\t\t}\n\t\tpart workflow {\n\t\t\tport sceneInputPort: ~SceneInputPort;\n\t\t\tport pictureOutputPort: PictureOutputPort;\n\t\t\tperform photographyWorkflow.focusAndShoot {\n\t\t\t\tin scene = sceneInputPort.scene;\n\t\t\t\tout picture = pictureOutputPort.picture;\n\t\t\t}\n\t\t}\n\t}\n\taction photographyWorkflow {\n\t\taction inputScene { out scene: Scene; }\n\t\tsuccession flow sceneFlow from inputScene.scene to focusAndShoot.scene;\n\t\taction focusAndShoot {\n\t\t\tin scene: Scene;\n\t\t\tout picture: Picture;\n\t\t\taction focus {\n\t\t\t\tin scene: Scene;\n\t\t\t\tout image: Image;\n\t\t\t}\n\t\t\tsuccession flow focusFlow from focus.scene to focus.image;\n\t\t\taction shoot {\n\t\t\t\tin image: Image;\n\t\t\t\tout picture: Picture;\n\t\t\t}\n\t\t\tsuccession flow shootFlow from focus.image to shoot.image;\n\t\t\tsuccession flow pictureFlow from shoot.picture to focusAndShoot.picture;\n\t\t}\n\t}\n}",
    "package 'PhotographyWorkflow' {\n\tattribute def Scene;\n\tattribute def FocusStatus;\n\tattribute def Photo;\n\tport def SceneSelectionPort {\n\t\tout scene: Scene;\n\t}\n\tport def FocusStatusPort {\n\t\tout focusStatus: FocusStatus;\n\t}\n\tport def PhotoPort {\n\t\tout photo: Photo;\n\t}\n\tpart context {\n\t\tpart user {\n\t\t\tport sceneSelectionPort: SceneSelectionPort;\n\t\t\tperform captureScene.selectScene {\n\t\t\t\tout scene = sceneSelectionPort.scene;\n\t\t\t}\n\t\t}\n\t\tinterface userToCamera connect user.sceneSelectionPort to camera.sceneSelectionPort {\n\t\t\tref flow references captureScene.sceneFlow\n\t\t\t\tfrom source.scene to target.scene;\n\t\t}\n\t\tpart camera {\n\t\t\tport sceneSelectionPort: ~SceneSelectionPort;\n\t\t\tport focusStatusPort: FocusStatusPort;\n\t\t\tport photoPort: PhotoPort;\n\t\t\tperform captureScene.focusScene {\n\t\t\t\tin scene = sceneSelectionPort.scene;\n\t\t\t\tout focusStatus = focusStatusPort.focusStatus;\n\t\t\t}\n\t\t\tperform captureScene.shootPhoto {\n\t\t\t\tin focusStatus = focusStatusPort.focusStatus;\n\t\t\t\tout photo = photoPort.photo;\n\t\t\t}\n\t\t}\n\t}\n\taction captureScene {\n\t\taction selectScene { out scene: Scene; }\n\t\tsuccession flow sceneFlow from selectScene.scene to focusScene.scene;\n\t\taction focusScene { in scene: Scene; out focusStatus: FocusStatus; }\n\t\tsuccession flow focusFlow from focusScene.focusStatus to shootPhoto.focusStatus;\n\t\taction shootPhoto { in focusStatus: FocusStatus; out photo: Photo; }\n\t}\n}",
    "package 'PhotoCaptureSystem' {\n\tattribute def Scene;\n\tattribute def FocusedImage;\n\tattribute def FocusQuality;\n\tattribute def Photo;\n\n\tport def SceneInputPort {\n\t\tout scene: Scene;\n\t}\n\tport def PhotoOutputPort {\n\t\tout photo: Photo;\n\t}\n\n\tpart context {\n\t\tpart user {\n\t\t\tport sceneInputPort: SceneInputPort;\n\t\t\tperform photoWorkflow.selectScene {\n\t\t\t\tout scene = sceneInputPort.scene;\n\t\t\t}\n\t\t}\n\t\tpart photoCaptureSystem {\n\t\t\tport sceneInputPort: ~SceneInputPort;\n\t\t\tport photoOutputPort: PhotoOutputPort;\n\t\t\tperform photoWorkflow.focusScene {\n\t\t\t\tin scene = sceneInputPort.scene;\n\t\t\t\tout focusedImage: FocusedImage;\n\t\t\t}\n\t\t\tperform photoWorkflow.evaluateFocus {\n\t\t\t\tin focusedImage: FocusedImage;\n\t\t\t\tout focusQuality: FocusQuality;\n\t\t\t}\n\t\t\tperform photoWorkflow.shootPhoto {\n\t\t\t\tin focusedImage: FocusedImage;\n\t\t\t\tin focusQuality: FocusQuality;\n\t\t\t\tout photo = photoOutputPort.photo;\n\t\t\t}\n\t\t}\n\t\tinterface userToSystem connect user.sceneInputPort to photoCaptureSystem.sceneInputPort {\n\t\t\tref flow references photoWorkflow.sceneFlow\n\t\t\t\tfrom source.scene to target.scene;\n\t\t}\n\t}\n\n\taction photoWorkflow {\n\t\taction selectScene { out scene: Scene; }\n\t\tsuccession flow sceneFlow from selectScene.scene to focusScene.scene;\n\n\t\taction focusScene { in scene: Scene; out focusedImage: FocusedImage; }\n\t\tsuccession flow focusFlow from focusScene.focusedImage to evaluateFocus.focusedImage;\n\n\t\taction evaluateFocus { in focusedImage: FocusedImage; out focusQuality: FocusQuality; }\n\t\tsuccession flow focusQualityFlow from evaluateFocus.focusQuality to shootPhoto.focusQuality;\n\t\tsuccession flow focusedImageFlow from focusScene.focusedImage to shootPhoto.focusedImage;\n\n\t\taction shootPhoto {\n\t\t\tin focusedImage: FocusedImage;\n\t\t\tin focusQuality: FocusQuality;\n\t\t\tout photo: Photo;\n\t\t\tprecondition focusQuality == 'well-focused';\n\t\t}\n\t}\n}",
    "package 'PhotographyWorkflow' {\n\tattribute def TakePhotoCmd;\n\tattribute def Scene;\n\tattribute def FocusedImage;\n\tattribute def Photograph;\n\tport def TakePhotoCmdPort {\n\t\tout takePhotoCmd: TakePhotoCmd;\n\t}\n\tport def ScenePort {\n\t\tout scene: Scene;\n\t}\n\tport def FocusedImagePort {\n\t\tout focusedImage: FocusedImage;\n\t}\n\tport def PhotographPort {\n\t\tout photograph: Photograph;\n\t}\n\tpart context {\n\t\tpart user {\n\t\t\tport takePhotoCmdPort: TakePhotoCmdPort;\n\t\t\tperform photoWorkflow.initiateTakePhoto {\n\t\t\t\tout takePhotoCmd = takePhotoCmdPort.takePhotoCmd;\n\t\t\t}\n\t\t}\n\t\tinterface userToSystem connect user.takePhotoCmdPort to system.takePhotoCmdPort {\n\t\t\tref flow references photoWorkflow.takePhotoCmdFlow\n\t\t\t\tfrom source.takePhotoCmd to target.takePhotoCmd;\n\t\t}\n\t\tpart system {\n\t\t\tport takePhotoCmdPort: ~TakePhotoCmdPort;\n\t\t\tport scenePort: ScenePort;\n\t\t\tport focusedImagePort: FocusedImagePort;\n\t\t\tport photographPort: PhotographPort;\n\t\t\tperform photoWorkflow.acquireScene {\n\t\t\t\tin takePhotoCmd = takePhotoCmdPort.takePhotoCmd;\n\t\t\t\tout scene = scenePort.scene;\n\t\t\t}\n\t\t\tperform photoWorkflow.focusScene {\n\t\t\t\tin scene = scenePort.scene;\n\t\t\t\tout focusedImage = focusedImagePort.focusedImage;\n\t\t\t}\n\t\t\tperform photoWorkflow.shootPhoto {\n\t\t\t\tin focusedImage = focusedImagePort.focusedImage;\n\t\t\t\tout photograph = photographPort.photograph;\n\t\t\t}\n\t\t\tperform photoWorkflow.displayPhoto {\n\t\t\t\tin photograph = photographPort.photograph;\n\t\t\t}\n\t\t}\n\t}\n\taction photoWorkflow {\n\t\taction initiateTakePhoto { out takePhotoCmd: TakePhotoCmd; }\n\t\tsuccession flow takePhotoCmdFlow from initiateTakePhoto.takePhotoCmd to acquireScene.takePhotoCmd;\n\t\taction acquireScene { in takePhotoCmd; out scene: Scene; }\n\t\tsuccession flow sceneFlow from acquireScene.scene to focusScene.scene;\n\t\taction focusScene { in scene; out focusedImage: FocusedImage; }\n\t\tsuccession flow focusedImageFlow from focusScene.focusedImage to shootPhoto.focusedImage;\n\t\taction shootPhoto { in focusedImage; out photograph: Photograph; }\n\t\tsuccession flow photographFlow from shootPhoto.photograph to displayPhoto.photograph;\n\t\taction displayPhoto { in photograph; }\n\t}\n}",
    "package 'AutomaticBrakingControl' {\n\tattribute def KeyPosition;\n\tattribute def BrakePedalStatus;\n\tattribute def BrakePressure;\n\tattribute def TractionInfo;\n\tattribute def ModulationFrequency;\n\tattribute def BrakeControlCmd;\n\tattribute def VehicleState;\n\n\tport def KeyPort {\n\t\tout keyPosition: KeyPosition;\n\t}\n\tport def BrakePedalPort {\n\t\tout brakePedalStatus: BrakePedalStatus;\n\t}\n\tport def BrakePressurePort {\n\t\tinout brakePressure: BrakePressure;\n\t}\n\tport def TractionPort {\n\t\tout tractionInfo: TractionInfo;\n\t}\n\tport def ModulationPort {\n\t\tinout modulationFrequency: ModulationFrequency;\n\t}\n\tport def BrakeControlPort {\n\t\tout brakeControlCmd: BrakeControlCmd;\n\t}\n\tport def VehicleStatePort {\n\t\tinout vehicleState: VehicleState;\n\t}\n\n\tpart context {\n\t\tpart user {\n\t\t\tport keyPort: KeyPort;\n\t\t\tport brakePedalPort: BrakePedalPort;\n\t\t\tperform brakingControl.sendKeyPosition {\n\t\t\t\tout keyPosition = keyPort.keyPosition;\n\t\t\t}\n\t\t\tperform brakingControl.sendBrakePedalStatus {\n\t\t\t\tout brakePedalStatus = brakePedalPort.brakePedalStatus;\n\t\t\t}\n\t\t}\n\t\tpart road {\n\t\t\tport tractionPort: TractionPort;\n\t\t\tperform brakingControl.provideTractionInfo {\n\t\t\t\tout tractionInfo = tractionPort.tractionInfo;\n\t\t\t}\n\t\t}\n\t\tpart vehicle {\n\t\t\tport brakePressurePort: BrakePressurePort;\n\t\t\tport modulationPort: ModulationPort;\n\t\t\tport brakeControlPort: ~BrakeControlPort;\n\t\t\tport vehicleStatePort: VehicleStatePort;\n\t\t\tperform brakingControl.applyBrakeControl {\n\t\t\t\tin brakeControlCmd = brakeControlPort.brakeControlCmd;\n\t\t\t\tinout brakePressure = brakePressurePort.brakePressure;\n\t\t\t\tinout modulationFrequency = modulationPort.modulationFrequency;\n\t\t\t\tinout vehicleState = vehicleStatePort.vehicleState;\n\t\t\t}\n\t\t}\n\t\tpart automaticBrakingControlSystem {\n\t\t\tport keyPort: ~KeyPort;\n\t\t\tport brakePedalPort: ~BrakePedalPort;\n\t\t\tport tractionPort: ~TractionPort;\n\t\t\tport brakePressurePort: ~BrakePressurePort;\n\t\t\tport modulationPort: ~ModulationPort;\n\t\t\tport brakeControlPort: BrakeControlPort;\n\t\t\tport vehicleStatePort: ~VehicleStatePort;\n\t\t\tperform brakingControl.monitorAndControlBraking {\n\t\t\t\tin keyPosition = keyPort.keyPosition;\n\t\t\t\tin brakePedalStatus = brakePedalPort.brakePedalStatus;\n\t\t\t\tin tractionInfo = tractionPort.tractionInfo;\n\t\t\t\tinout brakePressure = brakePressurePort.brakePressure;\n\t\t\t\tinout modulationFrequency = modulationPort.modulationFrequency;\n\t\t\t\tout brakeControlCmd = brakeControlPort.brakeControlCmd;\n\t\t\t\tinout vehicleState = vehicleStatePort.vehicleState;\n\t\t\t}\n\t\t}\n\t\tinterface userToSystem connect user.keyPort to automaticBrakingControlSystem.keyPort {\n\t\t\tref flow references brakingControl.keyPositionFlow\n\t\t\t\tfrom source.keyPosition to target.keyPosition;\n\t\t}\n\t\tinterface userPedalToSystem connect user.brakePedalPort to automaticBrakingControlSystem.brakePedalPort {\n\t\t\tref flow references brakingControl.brakePedalStatusFlow\n\t\t\t\tfrom source.brakePedalStatus to target.brakePedalStatus;\n\t\t}\n\t\tinterface roadToSystem connect road.tractionPort to automaticBrakingControlSystem.tractionPort {\n\t\t\tref flow references brakingControl.tractionInfoFlow\n\t\t\t\tfrom source.tractionInfo to target.tractionInfo;\n\t\t}\n\t\tinterface systemToVehicle connect automaticBrakingControlSystem.brakeControlPort to vehicle.brakeControlPort {\n\t\t\tref flow references brakingControl.brakeControlCmdFlow\n\t\t\t\tfrom source.brakeControlCmd to target.brakeControlCmd;\n\t\t}\n\t\tinterface systemToVehiclePressure connect automaticBrakingControlSystem.brakePressurePort to vehicle.brakePressurePort {\n\t\t\tref flow references brakingControl.brakePressureFlow\n\t\t\t\tfrom source.brakePressure to target.brakePressure;\n\t\t}\n\t\tinterface systemToVehicleModulation connect automaticBrakingControlSystem.modulationPort to vehicle.modulationPort {\n\t\t\tref flow references brakingControl.modulationFrequencyFlow\n\t\t\t\tfrom source.modulationFrequency to target.modulationFrequency;\n\t\t}\n\t\tinterface systemToVehicleState connect automaticBrakingControlSystem.vehicleStatePort to vehicle.vehicleStatePort {\n\t\t\tref flow references brakingControl.vehicleStateFlow\n\t\t\t\tfrom source.vehicleState to target.vehicleState;\n\t\t}\n\t}\n\n\taction brakingControl {\n\t\taction sendKeyPosition { out keyPosition: KeyPosition; }\n\t\taction sendBrakePedalStatus { out brakePedalStatus: BrakePedalStatus; }\n\t\taction provideTractionInfo { out tractionInfo: TractionInfo; }\n\t\taction monitorAndControlBraking {\n\t\t\tin keyPosition: KeyPosition;\n\t\t\tin brakePedalStatus: BrakePedalStatus;\n\t\t\tin tractionInfo: TractionInfo;\n\t\t\tinout brakePressure: BrakePressure;\n\t\t\tinout modulationFrequency: ModulationFrequency;\n\t\t\tout brakeControlCmd: BrakeControlCmd;\n\t\t\tinout vehicleState: VehicleState;\n\t\t}\n\t\taction applyBrakeControl {\n\t\t\tin brakeControlCmd: BrakeControlCmd;\n\t\t\tinout brakePressure: BrakePressure;\n\t\t\tinout modulationFrequency: ModulationFrequency;\n\t\t\tinout vehicleState: VehicleState;\n\t\t}\n\t\tsuccession flow keyPositionFlow from sendKeyPosition.keyPosition to monitorAndControlBraking.keyPosition;\n\t\tsuccession flow brakePedalStatusFlow from sendBrakePedalStatus.brakePedalStatus to monitorAndControlBraking.brakePedalStatus;\n\t\tsuccession flow tractionInfoFlow from provideTractionInfo.tractionInfo to monitorAndControlBraking.tractionInfo;\n\t\tsuccession flow brakeControlCmdFlow from monitorAndControlBraking.brakeControlCmd to applyBrakeControl.brakeControlCmd;\n\t\tsuccession flow brakePressureFlow from monitorAndControlBraking.brakePressure to applyBrakeControl.brakePressure;\n\t\tsuccession flow modulationFrequencyFlow from monitorAndControlBraking.modulationFrequency to applyBrakeControl.modulationFrequency;\n\t\tsuccession flow vehicleStateFlow from monitorAndControlBraking.vehicleState to applyBrakeControl.vehicleState;\n\t}\n}",
    "package 'BatteryChargingControlSystem' {\n\tattribute def BatteryLevel;\n\tattribute def ChargeCmd;\n\tattribute def BatteryHealthStatus;\n\tport def BatteryLevelPort {\n\t\tout batteryLevel: BatteryLevel;\n\t}\n\tport def ChargeCmdPort {\n\t\tout chargeCmd: ChargeCmd;\n\t}\n\tport def BatteryHealthStatusPort {\n\t\tout batteryHealthStatus: BatteryHealthStatus;\n\t}\n\tpart context {\n\t\tpart battery {\n\t\t\tport batteryLevelPort: BatteryLevelPort;\n\t\t\tport chargeCmdPort: ~ChargeCmdPort;\n\t\t\tport batteryHealthStatusPort: BatteryHealthStatusPort;\n\t\t\tperform manageCharging.receiveChargeCmd {\n\t\t\t\tin chargeCmd = chargeCmdPort.chargeCmd;\n\t\t\t\tout batteryLevel = batteryLevelPort.batteryLevel;\n\t\t\t\tout batteryHealthStatus = batteryHealthStatusPort.batteryHealthStatus;\n\t\t\t}\n\t\t}\n\t\tpart chargingController {\n\t\t\tport batteryLevelPort: ~BatteryLevelPort;\n\t\t\tport chargeCmdPort: ChargeCmdPort;\n\t\t\tport batteryHealthStatusPort: ~BatteryHealthStatusPort;\n\t\t\tperform manageCharging.monitorAndControl {\n\t\t\t\tin batteryLevel = batteryLevelPort.batteryLevel;\n\t\t\t\tin batteryHealthStatus = batteryHealthStatusPort.batteryHealthStatus;\n\t\t\t\tout chargeCmd = chargeCmdPort.chargeCmd;\n\t\t\t}\n\t\t}\n\t\tinterface batteryLevelConnection connect battery.batteryLevelPort to chargingController.batteryLevelPort {\n\t\t\tref flow references manageCharging.batteryLevelFlow\n\t\t\t\tfrom source.batteryLevel to target.batteryLevel;\n\t\t}\n\t\tinterface chargeCmdConnection connect chargingController.chargeCmdPort to battery.chargeCmdPort {\n\t\t\tref flow references manageCharging.chargeCmdFlow\n\t\t\t\tfrom source.chargeCmd to target.chargeCmd;\n\t\t}\n\t\tinterface batteryHealthStatusConnection connect battery.batteryHealthStatusPort to chargingController.batteryHealthStatusPort {\n\t\t\tref flow references manageCharging.batteryHealthStatusFlow\n\t\t\t\tfrom source.batteryHealthStatus to target.batteryHealthStatus;\n\t\t}\n\t}\n\taction manageCharging {\n\t\taction receiveChargeCmd {\n\t\t\tin chargeCmd: ChargeCmd;\n\t\t\tout batteryLevel: BatteryLevel;\n\t\t\tout batteryHealthStatus: BatteryHealthStatus;\n\t\t}\n\t\taction monitorAndControl {\n\t\t\tin batteryLevel: BatteryLevel;\n\t\t\tin batteryHealthStatus: BatteryHealthStatus;\n\t\t\tout chargeCmd: ChargeCmd;\n\t\t}\n\t\tsuccession flow batteryLevelFlow from receiveChargeCmd.batteryLevel to monitorAndControl.batteryLevel;\n\t\tsuccession flow batteryHealthStatusFlow from receiveChargeCmd.batteryHealthStatus to monitorAndControl.batteryHealthStatus;\n\t\tsuccession flow chargeCmdFlow from monitorAndControl.chargeCmd to receiveChargeCmd.chargeCmd;\n\t}\n}",
    "package 'BatteryChargingSystem' {\n\tattribute def BatteryLevel {\n\t\tvalue: Real;\n\t\tunit: Percent;\n\t}\n\tattribute def ChargeCmd {\n\t\tvalue: Boolean;\n\t}\n\tport def BatteryLevelPort {\n\t\tout batteryLevel: BatteryLevel;\n\t}\n\tport def ChargeCmdPort {\n\t\tout chargeCmd: ChargeCmd;\n\t}\n\tpart context {\n\t\tpart battery {\n\t\t\tport batteryLevelPort: BatteryLevelPort;\n\t\t\tport chargeCmdPort: ~ChargeCmdPort;\n\t\t\tperform chargeControl.monitorBatteryLevel {\n\t\t\t\tout batteryLevel = batteryLevelPort.batteryLevel;\n\t\t\t}\n\t\t\tperform chargeControl.receiveChargeCmd {\n\t\t\t\tin chargeCmd = chargeCmdPort.chargeCmd;\n\t\t\t}\n\t\t}\n\t\tpart charger {\n\t\t\tport chargeCmdPort: ChargeCmdPort;\n\t\t\tport batteryLevelPort: ~BatteryLevelPort;\n\t\t\tperform chargeControl.controlCharging {\n\t\t\t\tin batteryLevel = batteryLevelPort.batteryLevel;\n\t\t\t\tout chargeCmd = chargeCmdPort.chargeCmd;\n\t\t\t}\n\t\t}\n\t\tinterface batteryToCharger connect battery.batteryLevelPort to charger.batteryLevelPort {\n\t\t\tref flow references chargeControl.batteryLevelFlow\n\t\t\t\tfrom source.batteryLevel to target.batteryLevel;\n\t\t}\n\t\tinterface chargerToBattery connect charger.chargeCmdPort to battery.chargeCmdPort {\n\t\t\tref flow references chargeControl.chargeCmdFlow\n\t\t\t\tfrom source.chargeCmd to target.chargeCmd;\n\t\t}\n\t}\n\taction chargeControl {\n\t\taction monitorBatteryLevel { out batteryLevel: BatteryLevel; }\n\t\taction controlCharging { \n\t\t\tin batteryLevel: BatteryLevel; \n\t\t\tout chargeCmd: ChargeCmd; \n\t\t}\n\t\taction receiveChargeCmd { in chargeCmd: ChargeCmd; }\n\t\tsuccession flow batteryLevelFlow from monitorBatteryLevel.batteryLevel to controlCharging.batteryLevel;\n\t\tsuccession flow chargeCmdFlow from controlCharging.chargeCmd to receiveChargeCmd.chargeCmd;\n\t}\n\tconstraint def ChargingLogic {\n\t\tcontext controlCharging\n\t\t// If batteryLevel.value < 100, chargeCmd.value = true; else chargeCmd.value = false\n\t\tchargeCmd.value = if batteryLevel.value < 100 then true else false endif;\n\t}\n}",
    "package 'CameraSystem' {\n\tattribute def SceneSelection;\n\tattribute def Image;\n\tattribute def Photo;\n\tattribute def PhotoRecord;\n\n\tport def SceneSelectionPort {\n\t\tout sceneSelection: SceneSelection;\n\t}\n\tport def ImagePort {\n\t\tout image: Image;\n\t}\n\tport def PhotoPort {\n\t\tout photo: Photo;\n\t}\n\tport def PhotoRecordPort {\n\t\tout photoRecord: PhotoRecord;\n\t}\n\n\tpart context {\n\t\tpart user {\n\t\t\tport sceneSelectionPort: SceneSelectionPort;\n\t\t\tperform captureScene.selectScene {\n\t\t\t\tout sceneSelection = sceneSelectionPort.sceneSelection;\n\t\t\t}\n\t\t}\n\t\tinterface userToCamera connect user.sceneSelectionPort to camera.sceneSelectionPort {\n\t\t\tref flow references captureScene.sceneSelectionFlow\n\t\t\t\tfrom source.sceneSelection to target.sceneSelection;\n\t\t}\n\t\tpart camera {\n\t\t\tport sceneSelectionPort: ~SceneSelectionPort;\n\t\t\tport imagePort: ImagePort;\n\t\t\tport photoPort: PhotoPort;\n\t\t\tport photoRecordPort: PhotoRecordPort;\n\n\t\t\tpart autofocusSubsystem {\n\t\t\t\tport sceneSelectionPort: ~SceneSelectionPort;\n\t\t\t\tport imagePort: ImagePort;\n\t\t\t\tperform captureScene.autofocus {\n\t\t\t\t\tin sceneSelection = sceneSelectionPort.sceneSelection;\n\t\t\t\t\tout image = imagePort.image;\n\t\t\t\t}\n\t\t\t}\n\t\t\tpart imagingSubsystem {\n\t\t\t\tport imagePort: ~ImagePort;\n\t\t\t\tport photoPort: PhotoPort;\n\t\t\t\tperform captureScene.captureImage {\n\t\t\t\t\tin image = imagePort.image;\n\t\t\t\t\tout photo = photoPort.photo;\n\t\t\t\t}\n\t\t\t}\n\t\t\tpart storageSubsystem {\n\t\t\t\tport photoPort: ~PhotoPort;\n\t\t\t\tport photoRecordPort: PhotoRecordPort;\n\t\t\t\tperform captureScene.recordPhoto {\n\t\t\t\t\tin photo = photoPort.photo;\n\t\t\t\t\tout photoRecord = photoRecordPort.photoRecord;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tinterface cameraSceneSelection connect sceneSelectionPort to autofocusSubsystem.sceneSelectionPort {\n\t\t\t\tref flow references captureScene.sceneSelectionFlow\n\t\t\t\t\tfrom source.sceneSelection to target.sceneSelection;\n\t\t\t}\n\t\t\tinterface autofocusToImaging connect autofocusSubsystem.imagePort to imagingSubsystem.imagePort {\n\t\t\t\tref flow references captureScene.imageFlow\n\t\t\t\t\tfrom source.image to target.image;\n\t\t\t}\n\t\t\tinterface imagingToStorage connect imagingSubsystem.photoPort to storageSubsystem.photoPort {\n\t\t\t\tref flow references captureScene.photoFlow\n\t\t\t\t\tfrom source.photo to target.photo;\n\t\t\t}\n\t\t\tinterface storageToRecord connect storageSubsystem.photoRecordPort to photoRecordPort {\n\t\t\t\tref flow references captureScene.photoRecordFlow\n\t\t\t\t\tfrom source.photoRecord to target.photoRecord;\n\t\t\t}\n\t\t}\n\t}\n\n\taction captureScene {\n\t\taction selectScene { out sceneSelection: SceneSelection; }\n\t\tsuccession flow sceneSelectionFlow from selectScene.sceneSelection to autofocus.sceneSelection;\n\t\taction autofocus { in sceneSelection; out image: Image; }\n\t\tsuccession flow imageFlow from autofocus.image to captureImage.image;\n\t\taction captureImage { in image; out photo: Photo; }\n\t\tsuccession flow photoFlow from captureImage.photo to recordPhoto.photo;\n\t\taction recordPhoto { in photo; out photoRecord: PhotoRecord; }\n\t\tsuccession flow photoRecordFlow from recordPhoto.photoRecord to context.camera.photoRecordPort.photoRecord;\n\t}\n}",
    "package 'DigitalCameraShooting' {\n\tattribute def SceneSelection;\n\tattribute def FocusCommand;\n\tattribute def FocusedScene;\n\tattribute def ImagingCommand;\n\tattribute def Image;\n\t\n\tport def SceneSelectionPort {\n\t\tout sceneSelection: SceneSelection;\n\t}\n\tport def FocusCommandPort {\n\t\tin focusCommand: FocusCommand;\n\t\tout focusedScene: FocusedScene;\n\t}\n\tport def ImagingCommandPort {\n\t\tin imagingCommand: ImagingCommand;\n\t\tout image: Image;\n\t}\n\t\n\tpart context {\n\t\tpart user {\n\t\t\tport sceneSelectionPort: SceneSelectionPort;\n\t\t\tperform shootingProcess.selectScene {\n\t\t\t\tout sceneSelection = sceneSelectionPort.sceneSelection;\n\t\t\t}\n\t\t}\n\t\tpart cameraController {\n\t\t\tport sceneSelectionPort: ~SceneSelectionPort;\n\t\t\tport focusCommandPort: FocusCommandPort;\n\t\t\tport imagingCommandPort: ImagingCommandPort;\n\t\t\tperform shootingProcess.automateShooting {\n\t\t\t\tin sceneSelection = sceneSelectionPort.sceneSelection;\n\t\t\t\tout focusCommand = focusCommandPort.focusCommand;\n\t\t\t\tin focusedScene = focusCommandPort.focusedScene;\n\t\t\t\tout imagingCommand = imagingCommandPort.imagingCommand;\n\t\t\t\tin image = imagingCommandPort.image;\n\t\t\t}\n\t\t}\n\t\tpart focusingModule {\n\t\t\tport focusCommandPort: ~FocusCommandPort;\n\t\t\tperform shootingProcess.focusScene {\n\t\t\t\tin focusCommand = focusCommandPort.focusCommand;\n\t\t\t\tout focusedScene = focusCommandPort.focusedScene;\n\t\t\t}\n\t\t}\n\t\tpart imagingModule {\n\t\t\tport imagingCommandPort: ~ImagingCommandPort;\n\t\t\tperform shootingProcess.captureImage {\n\t\t\t\tin imagingCommand = imagingCommandPort.imagingCommand;\n\t\t\t\tout image = imagingCommandPort.image;\n\t\t\t}\n\t\t}\n\t}\n\t\n\taction shootingProcess {\n\t\taction selectScene { out sceneSelection: SceneSelection; }\n\t\tsuccession flow sceneSelectionFlow from selectScene.sceneSelection to automateShooting.sceneSelection;\n\t\t\n\t\taction automateShooting {\n\t\t\tin sceneSelection: SceneSelection;\n\t\t\tout focusCommand: FocusCommand;\n\t\t\tin focusedScene: FocusedScene;\n\t\t\tout imagingCommand: ImagingCommand;\n\t\t\tin image: Image;\n\t\t}\n\t\tsuccession flow focusCommandFlow from automateShooting.focusCommand to focusScene.focusCommand;\n\t\tsuccession flow focusedSceneFlow from focusScene.focusedScene to automateShooting.focusedScene;\n\t\tsuccession flow imagingCommandFlow from automateShooting.imagingCommand to captureImage.imagingCommand;\n\t\tsuccession flow imageFlow from captureImage.image to automateShooting.image;\n\t\t\n\t\taction focusScene { in focusCommand: FocusCommand; out focusedScene: FocusedScene; }\n\t\taction captureImage { in imagingCommand: ImagingCommand; out image: Image; }\n\t}\n}",
    "package 'VehicleSimulation' {\n\tattribute def Mass;\n\tattribute def Position;\n\tattribute def Velocity;\n\tattribute def Power;\n\tattribute def TimeInterval;\n\tattribute def Trajectory;\n\n\tport def MassPort {\n\t\tin mass: Mass;\n\t}\n\tport def PositionPort {\n\t\tin initialPosition: Position;\n\t}\n\tport def VelocityPort {\n\t\tin initialVelocity: Velocity;\n\t}\n\tport def TimeIntervalPort {\n\t\tin timeInterval: TimeInterval;\n\t}\n\tport def PowerInputPort {\n\t\tin powerSequence: sequence<Power>;\n\t}\n\tport def TrajectoryPort {\n\t\tout trajectory: sequence<Position>;\n\t}\n\n\tpart context {\n\t\tpart user {\n\t\t\tport massPort: MassPort;\n\t\t\tport positionPort: PositionPort;\n\t\t\tport velocityPort: VelocityPort;\n\t\t\tport timeIntervalPort: TimeIntervalPort;\n\t\t\tport powerInputPort: PowerInputPort;\n\t\t\tperform simulateMotion.provideInputs {\n\t\t\t\tout mass = massPort.mass;\n\t\t\t\tout initialPosition = positionPort.initialPosition;\n\t\t\t\tout initialVelocity = velocityPort.initialVelocity;\n\t\t\t\tout timeInterval = timeIntervalPort.timeInterval;\n\t\t\t\tout powerSequence = powerInputPort.powerSequence;\n\t\t\t}\n\t\t}\n\t\tinterface userToSimulator connect user.massPort to simulator.massPort {\n\t\t\tref flow references simulateMotion.massFlow\n\t\t\t\tfrom source.mass to target.mass;\n\t\t}\n\t\tinterface userToSimulator2 connect user.positionPort to simulator.positionPort {\n\t\t\tref flow references simulateMotion.positionFlow\n\t\t\t\tfrom source.initialPosition to target.initialPosition;\n\t\t}\n\t\tinterface userToSimulator3 connect user.velocityPort to simulator.velocityPort {\n\t\t\tref flow references simulateMotion.velocityFlow\n\t\t\t\tfrom source.initialVelocity to target.initialVelocity;\n\t\t}\n\t\tinterface userToSimulator4 connect user.timeIntervalPort to simulator.timeIntervalPort {\n\t\t\tref flow references simulateMotion.timeIntervalFlow\n\t\t\t\tfrom source.timeInterval to target.timeInterval;\n\t\t}\n\t\tinterface userToSimulator5 connect user.powerInputPort to simulator.powerInputPort {\n\t\t\tref flow references simulateMotion.powerFlow\n\t\t\t\tfrom source.powerSequence to target.powerSequence;\n\t\t}\n\t\tpart simulator {\n\t\t\tport massPort: ~MassPort;\n\t\t\tport positionPort: ~PositionPort;\n\t\t\tport velocityPort: ~VelocityPort;\n\t\t\tport timeIntervalPort: ~TimeIntervalPort;\n\t\t\tport powerInputPort: ~PowerInputPort;\n\t\t\tport trajectoryPort: TrajectoryPort;\n\t\t\tperform simulateMotion.computeTrajectory {\n\t\t\t\tin mass = massPort.mass;\n\t\t\t\tin initialPosition = positionPort.initialPosition;\n\t\t\t\tin initialVelocity = velocityPort.initialVelocity;\n\t\t\t\tin timeInterval = timeIntervalPort.timeInterval;\n\t\t\t\tin powerSequence = powerInputPort.powerSequence;\n\t\t\t\tout trajectory = trajectoryPort.trajectory;\n\t\t\t}\n\t\t}\n\t\tinterface simulatorToUser connect simulator.trajectoryPort to user.trajectoryPort {\n\t\t\tref flow references simulateMotion.trajectoryFlow\n\t\t\t\tfrom source.trajectory to target.trajectory;\n\t\t}\n\t\tport trajectoryPort: TrajectoryPort;\n\t}\n\n\taction simulateMotion {\n\t\taction provideInputs {\n\t\t\tout mass: Mass;\n\t\t\tout initialPosition: Position;\n\t\t\tout initialVelocity: Velocity;\n\t\t\tout timeInterval: TimeInterval;\n\t\t\tout powerSequence: sequence<Power>;\n\t\t}\n\t\tsuccession flow massFlow from provideInputs.mass to computeTrajectory.mass;\n\t\tsuccession flow positionFlow from provideInputs.initialPosition to computeTrajectory.initialPosition;\n\t\tsuccession flow velocityFlow from provideInputs.initialVelocity to computeTrajectory.initialVelocity;\n\t\tsuccession flow timeIntervalFlow from provideInputs.timeInterval to computeTrajectory.timeInterval;\n\t\tsuccession flow powerFlow from provideInputs.powerSequence to computeTrajectory.powerSequence;\n\n\t\taction computeTrajectory {\n\t\t\tin mass: Mass;\n\t\t\tin initialPosition: Position;\n\t\t\tin initialVelocity: Velocity;\n\t\t\tin timeInterval: TimeInterval;\n\t\t\tin powerSequence: sequence<Power>;\n\t\t\tout trajectory: sequence<Position>;\n\t\t}\n\t\tsuccession flow trajectoryFlow from computeTrajectory.trajectory to provideOutputs.trajectory;\n\t\taction provideOutputs {\n\t\t\tin trajectory: sequence<Position>;\n\t\t}\n\t}\n}",
    "package 'CameraShootingSystem' {\n\tattribute def ShootCmd;\n\tattribute def Scene;\n\tattribute def Image;\n\tattribute def Photo;\n\n\tport def ShootCmdPort {\n\t\tout shootCmd: ShootCmd;\n\t}\n\tport def ScenePort {\n\t\tout scene: Scene;\n\t}\n\tport def ImagePort {\n\t\tout image: Image;\n\t}\n\tport def PhotoPort {\n\t\tout photo: Photo;\n\t}\n\n\tpart context {\n\t\tpart user {\n\t\t\tport shootCmdPort: ShootCmdPort;\n\t\t\tport scenePort: ScenePort;\n\t\t\tperform photoProcess.initiateShooting {\n\t\t\t\tout shootCmd = shootCmdPort.shootCmd;\n\t\t\t\tout scene = scenePort.scene;\n\t\t\t}\n\t\t}\n\t\tinterface userToCamera connect user.shootCmdPort to camera.shootCmdPort {\n\t\t\tref flow references photoProcess.shootCmdFlow\n\t\t\t\tfrom source.shootCmd to target.shootCmd;\n\t\t}\n\t\tinterface userSceneToCamera connect user.scenePort to camera.scenePort {\n\t\t\tref flow references photoProcess.sceneFlow\n\t\t\t\tfrom source.scene to target.scene;\n\t\t}\n\t\tpart camera {\n\t\t\tport shootCmdPort: ~ShootCmdPort;\n\t\t\tport scenePort: ~ScenePort;\n\t\t\tport imagePort: ImagePort;\n\t\t\tport photoPort: PhotoPort;\n\t\t\tperform photoProcess.focusScene {\n\t\t\t\tin shootCmd = shootCmdPort.shootCmd;\n\t\t\t\tin scene = scenePort.scene;\n\t\t\t\tout image = imagePort.image;\n\t\t\t}\n\t\t\tperform photoProcess.captureImage {\n\t\t\t\tin image = imagePort.image;\n\t\t\t\tout photo = photoPort.photo;\n\t\t\t}\n\t\t}\n\t\tinterface cameraToScreen connect camera.photoPort to screen.photoPort {\n\t\t\tref flow references photoProcess.photoFlow\n\t\t\t\tfrom source.photo to target.photo;\n\t\t}\n\t\tpart screen {\n\t\t\tport photoPort: ~PhotoPort;\n\t\t\tperform photoProcess.displayPhoto {\n\t\t\t\tin photo = photoPort.photo;\n\t\t\t}\n\t\t}\n\t}\n\n\taction photoProcess {\n\t\taction initiateShooting { out shootCmd: ShootCmd; out scene: Scene; }\n\t\tsuccession flow shootCmdFlow from initiateShooting.shootCmd to focusScene.shootCmd;\n\t\tsuccession flow sceneFlow from initiateShooting.scene to focusScene.scene;\n\t\taction focusScene { in shootCmd; in scene; out image: Image; }\n\t\tsuccession flow imageFlow from focusScene.image to captureImage.image;\n\t\taction captureImage { in image: Image; out photo: Photo; }\n\t\tsuccession flow photoFlow from captureImage.photo to displayPhoto.photo;\n\t\taction displayPhoto { in photo: Photo; }\n\t}\n}",
    "package 'CameraWorkflow' {\n\tattribute def Scene;\n\tattribute def Image;\n\tattribute def Picture;\n\n\tport def ViewPort {\n\t\tout scene: Scene;\n\t}\n\tport def DisplayPort {\n\t\tout picture: Picture;\n\t}\n\n\tpart context {\n\t\tpart user {\n\t\t\tport viewPort: ViewPort;\n\t\t\tperform processScene.selectScene {\n\t\t\t\tout scene = viewPort.scene;\n\t\t\t}\n\t\t}\n\t\tinterface userToCamera connect user.viewPort to camera.viewPort {\n\t\t\tref flow references processScene.sceneFlow\n\t\t\t\tfrom source.scene to target.scene;\n\t\t}\n\t\tpart camera {\n\t\t\tport viewPort: ~ViewPort;\n\t\t\tport displayPort: DisplayPort;\n\t\t\tperform processScene.focusScene {\n\t\t\t\tin scene = viewPort.scene;\n\t\t\t\tout image: Image;\n\t\t\t}\n\t\t\tperform processScene.captureImage {\n\t\t\t\tin image: Image;\n\t\t\t\tout picture: Picture;\n\t\t\t}\n\t\t\tperform processScene.displayPicture {\n\t\t\t\tin picture: Picture;\n\t\t\t\tout picture = displayPort.picture;\n\t\t\t}\n\t\t}\n\t}\n\n\taction processScene {\n\t\taction selectScene { out scene: Scene; }\n\t\tsuccession flow sceneFlow from selectScene.scene to focusScene.scene;\n\t\taction focusScene { in scene: Scene; out image: Image; }\n\t\tsuccession flow imageFlow from focusScene.image to captureImage.image;\n\t\taction captureImage { in image: Image; out picture: Picture; }\n\t\tsuccession flow pictureFlow from captureImage.picture to displayPicture.picture;\n\t\taction displayPicture { in picture: Picture; out picture: Picture; }\n\t}\n}",
    "package 'SensorManagement' {\n\tattribute def SensorStatus;\n\tattribute def UpdateCmd;\n\tattribute def SensorId;\n\tport def StatusPort {\n\t\tout status: SensorStatus;\n\t}\n\tport def UpdatePort {\n\t\tin updateCmd: UpdateCmd;\n\t}\n\tpart context {\n\t\tpart system {\n\t\t\tpart sensors: Sensor[*];\n\t\t\tperform manageSensors.monitorAndUpdate {\n\t\t\t\tin sensors;\n\t\t\t}\n\t\t}\n\t\tpart Sensor {\n\t\t\tattribute id: SensorId;\n\t\t\tport statusPort: StatusPort;\n\t\t\tport updatePort: UpdatePort;\n\t\t\tperform manageSensors.reportStatus {\n\t\t\t\tout status = statusPort.status;\n\t\t\t}\n\t\t\tperform manageSensors.receiveUpdate {\n\t\t\t\tin updateCmd = updatePort.updateCmd;\n\t\t\t}\n\t\t}\n\t}\n\taction manageSensors {\n\t\taction monitorAndUpdate {\n\t\t\tin sensors: Sensor[*];\n\t\t\titerate sensor in sensors {\n\t\t\t\tcall checkAndUpdate(sensor);\n\t\t\t}\n\t\t}\n\t\taction checkAndUpdate(sensor: Sensor) {\n\t\t\tcall reportStatus(sensor) -> status: SensorStatus;\n\t\t\tif status == #ready {\n\t\t\t\tcall sendUpdate(sensor);\n\t\t\t}\n\t\t}\n\t\taction reportStatus(sensor: Sensor) {\n\t\t\tout status: SensorStatus;\n\t\t}\n\t\taction sendUpdate(sensor: Sensor) {\n\t\t\tout updateCmd: UpdateCmd;\n\t\t\tcall receiveUpdate(sensor, updateCmd);\n\t\t}\n\t\taction receiveUpdate(sensor: Sensor, updateCmd: UpdateCmd) {}\n\t}\n}",
    "package 'VehicleStateManagement' {\n\tattribute def VehicleStartSignal;\n\tattribute def VehiclePowerOnSignal;\n\tattribute def VehicleShutdownSignal;\n\tattribute def VehicleState : enumeration { off, starting, on; }\n\n\tport def StartSignalPort {\n\t\tout startSignal: VehicleStartSignal;\n\t}\n\tport def PowerOnSignalPort {\n\t\tout powerOnSignal: VehiclePowerOnSignal;\n\t}\n\tport def ShutdownSignalPort {\n\t\tout shutdownSignal: VehicleShutdownSignal;\n\t}\n\tport def StatePort {\n\t\tout state: VehicleState;\n\t}\n\n\tpart context {\n\t\tpart controller {\n\t\t\tport startSignalPort: StartSignalPort;\n\t\t\tport powerOnSignalPort: PowerOnSignalPort;\n\t\t\tport shutdownSignalPort: ShutdownSignalPort;\n\t\t\tperform manageVehicleState.sendStartSignal {\n\t\t\t\tout startSignal = startSignalPort.startSignal;\n\t\t\t}\n\t\t\tperform manageVehicleState.sendPowerOnSignal {\n\t\t\t\tout powerOnSignal = powerOnSignalPort.powerOnSignal;\n\t\t\t}\n\t\t\tperform manageVehicleState.sendShutdownSignal {\n\t\t\t\tout shutdownSignal = shutdownSignalPort.shutdownSignal;\n\t\t\t}\n\t\t}\n\t\tpart vehicle {\n\t\t\tport startSignalPort: ~StartSignalPort;\n\t\t\tport powerOnSignalPort: ~PowerOnSignalPort;\n\t\t\tport shutdownSignalPort: ~ShutdownSignalPort;\n\t\t\tport statePort: StatePort;\n\t\t\tperform manageVehicleState.stateTransition {\n\t\t\t\tin startSignal = startSignalPort.startSignal;\n\t\t\t\tin powerOnSignal = powerOnSignalPort.powerOnSignal;\n\t\t\t\tin shutdownSignal = shutdownSignalPort.shutdownSignal;\n\t\t\t\tout state = statePort.state;\n\t\t\t}\n\t\t}\n\t\tinterface startSignalConnection connect controller.startSignalPort to vehicle.startSignalPort {\n\t\t\tref flow references manageVehicleState.startSignalFlow\n\t\t\t\tfrom source.startSignal to target.startSignal;\n\t\t}\n\t\tinterface powerOnSignalConnection connect controller.powerOnSignalPort to vehicle.powerOnSignalPort {\n\t\t\tref flow references manageVehicleState.powerOnSignalFlow\n\t\t\t\tfrom source.powerOnSignal to target.powerOnSignal;\n\t\t}\n\t\tinterface shutdownSignalConnection connect controller.shutdownSignalPort to vehicle.shutdownSignalPort {\n\t\t\tref flow references manageVehicleState.shutdownSignalFlow\n\t\t\t\tfrom source.shutdownSignal to target.shutdownSignal;\n\t\t}\n\t}\n\n\taction manageVehicleState {\n\t\taction sendStartSignal { out startSignal: VehicleStartSignal; }\n\t\taction sendPowerOnSignal { out powerOnSignal: VehiclePowerOnSignal; }\n\t\taction sendShutdownSignal { out shutdownSignal: VehicleShutdownSignal; }\n\n\t\taction stateTransition {\n\t\t\tin startSignal: VehicleStartSignal;\n\t\t\tin powerOnSignal: VehiclePowerOnSignal;\n\t\t\tin shutdownSignal: VehicleShutdownSignal;\n\t\t\tout state: VehicleState;\n\t\t\tbehavior {\n\t\t\t\tvar currentState: VehicleState = VehicleState.off;\n\t\t\t\tif (shutdownSignal) {\n\t\t\t\t\tcurrentState = VehicleState.off;\n\t\t\t\t} else if (currentState == VehicleState.off && startSignal) {\n\t\t\t\t\tcurrentState = VehicleState.starting;\n\t\t\t\t} else if (currentState == VehicleState.starting && powerOnSignal) {\n\t\t\t\t\tcurrentState = VehicleState.on;\n\t\t\t\t}\n\t\t\t\tstate = currentState;\n\t\t\t}\n\t\t}\n\n\t\tsuccession flow startSignalFlow from sendStartSignal.startSignal to stateTransition.startSignal;\n\t\tsuccession flow powerOnSignalFlow from sendPowerOnSignal.powerOnSignal to stateTransition.powerOnSignal;\n\t\tsuccession flow shutdownSignalFlow from sendShutdownSignal.shutdownSignal to stateTransition.shutdownSignal;\n\t}\n}",
    "package 'VehicleStateManagement' {\n\tattribute def VehicleStartSignal;\n\tattribute def VehicleOnSignal;\n\tattribute def VehicleOffSignal;\n\tattribute def VehicleState {\n\t\tenum {\n\t\t\toff,\n\t\t\tstarting,\n\t\t\ton\n\t\t}\n\t}\n\tport def ControlSignalPort {\n\t\tin startSignal: VehicleStartSignal;\n\t\tin onSignal: VehicleOnSignal;\n\t\tin offSignal: VehicleOffSignal;\n\t}\n\tport def StatePort {\n\t\tout state: VehicleState;\n\t}\n\tpart context {\n\t\tpart user {\n\t\t\tport controlSignalPort: ControlSignalPort;\n\t\t\tperform manageVehicle.sendControlSignal {\n\t\t\t\tout startSignal = controlSignalPort.startSignal;\n\t\t\t\tout onSignal = controlSignalPort.onSignal;\n\t\t\t\tout offSignal = controlSignalPort.offSignal;\n\t\t\t}\n\t\t}\n\t\tinterface userToSystem connect user.controlSignalPort to vehicleSystem.controlSignalPort {\n\t\t\tref flow references manageVehicle.startSignalFlow\n\t\t\t\tfrom source.startSignal to target.startSignal;\n\t\t\tref flow references manageVehicle.onSignalFlow\n\t\t\t\tfrom source.onSignal to target.onSignal;\n\t\t\tref flow references manageVehicle.offSignalFlow\n\t\t\t\tfrom source.offSignal to target.offSignal;\n\t\t}\n\t\tpart vehicleSystem {\n\t\t\tport controlSignalPort: ~ControlSignalPort;\n\t\t\tport statePort: StatePort;\n\t\t\tperform manageVehicle.stateManagement {\n\t\t\t\tin startSignal = controlSignalPort.startSignal;\n\t\t\t\tin onSignal = controlSignalPort.onSignal;\n\t\t\t\tin offSignal = controlSignalPort.offSignal;\n\t\t\t\tout state = statePort.state;\n\t\t\t}\n\t\t}\n\t}\n\taction manageVehicle {\n\t\taction sendControlSignal {\n\t\t\tout startSignal: VehicleStartSignal;\n\t\t\tout onSignal: VehicleOnSignal;\n\t\t\tout offSignal: VehicleOffSignal;\n\t\t}\n\t\taction stateManagement {\n\t\t\tin startSignal: VehicleStartSignal;\n\t\t\tin onSignal: VehicleOnSignal;\n\t\t\tin offSignal: VehicleOffSignal;\n\t\t\tout state: VehicleState;\n\t\t\tstateMachine VehicleStateMachine {\n\t\t\t\tstate off initial;\n\t\t\t\tstate starting;\n\t\t\t\tstate on;\n\t\t\t\ttransition from off to starting when startSignal;\n\t\t\t\ttransition from starting to on when onSignal;\n\t\t\t\ttransition from on to off when offSignal;\n\t\t\t}\n\t\t}\n\t\tsuccession flow startSignalFlow from sendControlSignal.startSignal to stateManagement.startSignal;\n\t\tsuccession flow onSignalFlow from sendControlSignal.onSignal to stateManagement.onSignal;\n\t\tsuccession flow offSignalFlow from sendControlSignal.offSignal to stateManagement.offSignal;\n\t}\n}",
    "package 'VehiclePowerManagement' {\n\tattribute def StartCmd;\n\tattribute def ShutdownCmd;\n\tattribute def StartedSignal;\n\tattribute def PowerStatus;\n\tattribute def SelfDiagnosisResult;\n\tattribute def SafetyOperationStatus;\n\n\tport def StartCmdPort {\n\t\tout startCmd: StartCmd;\n\t}\n\tport def ShutdownCmdPort {\n\t\tout shutdownCmd: ShutdownCmd;\n\t}\n\tport def StartedSignalPort {\n\t\tout startedSignal: StartedSignal;\n\t}\n\tport def PowerStatusPort {\n\t\tout powerStatus: PowerStatus;\n\t}\n\tport def SelfDiagnosisPort {\n\t\tout selfDiagnosisResult: SelfDiagnosisResult;\n\t}\n\tport def SafetyOperationPort {\n\t\tout safetyOperationStatus: SafetyOperationStatus;\n\t}\n\n\tpart context {\n\t\tpart user {\n\t\t\tport startCmdPort: StartCmdPort;\n\t\t\tport shutdownCmdPort: ShutdownCmdPort;\n\t\t\tperform managePower.sendStartCmd {\n\t\t\t\tout startCmd = startCmdPort.startCmd;\n\t\t\t}\n\t\t\tperform managePower.sendShutdownCmd {\n\t\t\t\tout shutdownCmd = shutdownCmdPort.shutdownCmd;\n\t\t\t}\n\t\t}\n\t\tpart vehiclePowerSystem {\n\t\t\tport startCmdPort: ~StartCmdPort;\n\t\t\tport shutdownCmdPort: ~ShutdownCmdPort;\n\t\t\tport startedSignalPort: StartedSignalPort;\n\t\t\tport powerStatusPort: PowerStatusPort;\n\t\t\tport selfDiagnosisPort: SelfDiagnosisPort;\n\t\t\tport safetyOperationPort: SafetyOperationPort;\n\n\t\t\tperform managePower.switchToStartPhase {\n\t\t\t\tin startCmd = startCmdPort.startCmd;\n\t\t\t\tout powerStatus = powerStatusPort.powerStatus;\n\t\t\t}\n\t\t\tperform managePower.switchToPoweredOn {\n\t\t\t\tin startedSignal = startedSignalPort.startedSignal;\n\t\t\t\tout powerStatus = powerStatusPort.powerStatus;\n\t\t\t}\n\t\t\tperform managePower.performSelfDiagnosis {\n\t\t\t\tin powerStatus = powerStatusPort.powerStatus;\n\t\t\t\tout selfDiagnosisResult = selfDiagnosisPort.selfDiagnosisResult;\n\t\t\t}\n\t\t\tperform managePower.supplyPowerToUnits {\n\t\t\t\tin powerStatus = powerStatusPort.powerStatus;\n\t\t\t}\n\t\t\tperform managePower.executeSafetyOperations {\n\t\t\t\tin shutdownCmd = shutdownCmdPort.shutdownCmd;\n\t\t\t\tout safetyOperationStatus = safetyOperationPort.safetyOperationStatus;\n\t\t\t}\n\t\t\tperform managePower.switchToOffState {\n\t\t\t\tin safetyOperationStatus = safetyOperationPort.safetyOperationStatus;\n\t\t\t\tout powerStatus = powerStatusPort.powerStatus;\n\t\t\t}\n\t\t}\n\t\tinterface userToSystem connect user.startCmdPort to vehiclePowerSystem.startCmdPort {\n\t\t\tref flow references managePower.startCmdFlow\n\t\t\t\tfrom source.startCmd to target.startCmd;\n\t\t}\n\t\tinterface userToSystemShutdown connect user.shutdownCmdPort to vehiclePowerSystem.shutdownCmdPort {\n\t\t\tref flow references managePower.shutdownCmdFlow\n\t\t\t\tfrom source.shutdownCmd to target.shutdownCmd;\n\t\t}\n\t}\n\n\taction managePower {\n\t\taction sendStartCmd { out startCmd: StartCmd; }\n\t\taction sendShutdownCmd { out shutdownCmd: ShutdownCmd; }\n\t\taction switchToStartPhase { in startCmd: StartCmd; out powerStatus: PowerStatus; }\n\t\taction switchToPoweredOn { in startedSignal: StartedSignal; out powerStatus: PowerStatus; }\n\t\taction performSelfDiagnosis { in powerStatus: PowerStatus; out selfDiagnosisResult: SelfDiagnosisResult; }\n\t\taction supplyPowerToUnits { in powerStatus: PowerStatus; }\n\t\taction executeSafetyOperations { in shutdownCmd: ShutdownCmd; out safetyOperationStatus: SafetyOperationStatus; }\n\t\taction switchToOffState { in safetyOperationStatus: SafetyOperationStatus; out powerStatus: PowerStatus; }\n\n\t\tsuccession flow startCmdFlow from sendStartCmd.startCmd to switchToStartPhase.startCmd;\n\t\tsuccession flow startedSignalFlow from switchToStartPhase.powerStatus to switchToPoweredOn.powerStatus;\n\t\tsuccession flow poweredOnFlow from switchToPoweredOn.powerStatus to performSelfDiagnosis.powerStatus;\n\t\tsuccession flow supplyPowerFlow from switchToPoweredOn.powerStatus to supplyPowerToUnits.powerStatus;\n\t\tsuccession flow shutdownCmdFlow from sendShutdownCmd.shutdownCmd to executeSafetyOperations.shutdownCmd;\n\t\tsuccession flow safetyOpFlow from executeSafetyOperations.safetyOperationStatus to switchToOffState.safetyOperationStatus;\n\t}\n}",
    "package 'VehicleControl' {\n\tattribute def StartSignal;\n\tattribute def ShutdownSignal;\n\tattribute def StartedSignal;\n\tattribute def VehicleStatus : enumeration { shutdown, startup, running; }\n\n\tport def StartSignalPort {\n\t\tout startSignal: StartSignal;\n\t}\n\tport def ShutdownSignalPort {\n\t\tout shutdownSignal: ShutdownSignal;\n\t}\n\tport def StartedSignalPort {\n\t\tout startedSignal: StartedSignal;\n\t}\n\tport def VehicleStatusPort {\n\t\tout vehicleStatus: VehicleStatus;\n\t}\n\n\tpart context {\n\t\tpart user {\n\t\t\tport startSignalPort: StartSignalPort;\n\t\t\tport shutdownSignalPort: ShutdownSignalPort;\n\t\t\tperform vehicleStateControl.sendStartSignal {\n\t\t\t\tout startSignal = startSignalPort.startSignal;\n\t\t\t}\n\t\t\tperform vehicleStateControl.sendShutdownSignal {\n\t\t\t\tout shutdownSignal = shutdownSignalPort.shutdownSignal;\n\t\t\t}\n\t\t}\n\t\tpart vehicleSystem {\n\t\t\tport startSignalPort: ~StartSignalPort;\n\t\t\tport shutdownSignalPort: ~ShutdownSignalPort;\n\t\t\tport startedSignalPort: StartedSignalPort;\n\t\t\tport vehicleStatusPort: VehicleStatusPort;\n\t\t\tperform vehicleStateControl.processSignals {\n\t\t\t\tin startSignal = startSignalPort.startSignal;\n\t\t\t\tin shutdownSignal = shutdownSignalPort.shutdownSignal;\n\t\t\t\tin startedSignal = startedSignalPort.startedSignal;\n\t\t\t\tout vehicleStatus = vehicleStatusPort.vehicleStatus;\n\t\t\t}\n\t\t}\n\t}\n\n\taction vehicleStateControl {\n\t\taction sendStartSignal { out startSignal: StartSignal; }\n\t\taction sendShutdownSignal { out shutdownSignal: ShutdownSignal; }\n\t\taction processSignals {\n\t\t\tin startSignal: StartSignal;\n\t\t\tin shutdownSignal: ShutdownSignal;\n\t\t\tin startedSignal: StartedSignal;\n\t\t\tout vehicleStatus: VehicleStatus;\n\t\t}\n\t\tsuccession flow startFlow from sendStartSignal.startSignal to processSignals.startSignal;\n\t\tsuccession flow shutdownFlow from sendShutdownSignal.shutdownSignal to processSignals.shutdownSignal;\n\t}\n\n\tstateMachine VehicleStateMachine {\n\t\tstate Shutdown initial;\n\t\tstate Startup;\n\t\tstate Running;\n\n\t\ttransition t1 from Shutdown to Startup\n\t\t\ttrigger startSignal: StartSignal;\n\t\ttransition t2 from Startup to Running\n\t\t\ttrigger startedSignal: StartedSignal;\n\t\ttransition t3 from Running to Shutdown\n\t\t\ttrigger shutdownSignal: ShutdownSignal;\n\t}\n}",
    "package 'VehiclePowerManagement' {\n\tattribute def StartSignal;\n\tattribute def OnSignal;\n\tattribute def OffSignal;\n\tattribute def OperatingState;\n\tattribute def HealthState;\n\n\tenum def VehicleOperatingStateEnum {\n\t\tOff,\n\t\tStart,\n\t\tOn\n\t}\n\n\tport def StartSignalPort {\n\t\tout startSignal: StartSignal;\n\t}\n\tport def OnSignalPort {\n\t\tout onSignal: OnSignal;\n\t}\n\tport def OffSignalPort {\n\t\tout offSignal: OffSignal;\n\t}\n\tport def OperatingStatePort {\n\t\tout operatingState: OperatingState;\n\t}\n\tport def HealthStatePort {\n\t\tout healthState: HealthState;\n\t}\n\n\tpart context {\n\t\tpart user {\n\t\t\tport startSignalPort: StartSignalPort;\n\t\t\tport onSignalPort: OnSignalPort;\n\t\t\tport offSignalPort: OffSignalPort;\n\t\t\tperform powerControl.sendStartSignal {\n\t\t\t\tout startSignal = startSignalPort.startSignal;\n\t\t\t}\n\t\t\tperform powerControl.sendOnSignal {\n\t\t\t\tout onSignal = onSignalPort.onSignal;\n\t\t\t}\n\t\t\tperform powerControl.sendOffSignal {\n\t\t\t\tout offSignal = offSignalPort.offSignal;\n\t\t\t}\n\t\t}\n\t\tpart vehicle {\n\t\t\tport startSignalPort: ~StartSignalPort;\n\t\t\tport onSignalPort: ~OnSignalPort;\n\t\t\tport offSignalPort: ~OffSignalPort;\n\t\t\tport operatingStatePort: OperatingStatePort;\n\t\t\tport healthStatePort: HealthStatePort;\n\t\t\tperform powerControl.manageOperatingState {\n\t\t\t\tin startSignal = startSignalPort.startSignal;\n\t\t\t\tin onSignal = onSignalPort.onSignal;\n\t\t\t\tin offSignal = offSignalPort.offSignal;\n\t\t\t\tout operatingState = operatingStatePort.operatingState;\n\t\t\t}\n\t\t\tperform healthManagement.monitorHealthState {\n\t\t\t\tout healthState = healthStatePort.healthState;\n\t\t\t}\n\t\t}\n\t\tinterface userToVehicleStart connect user.startSignalPort to vehicle.startSignalPort {\n\t\t\tref flow references powerControl.startSignalFlow\n\t\t\t\tfrom source.startSignal to target.startSignal;\n\t\t}\n\t\tinterface userToVehicleOn connect user.onSignalPort to vehicle.onSignalPort {\n\t\t\tref flow references powerControl.onSignalFlow\n\t\t\t\tfrom source.onSignal to target.onSignal;\n\t\t}\n\t\tinterface userToVehicleOff connect user.offSignalPort to vehicle.offSignalPort {\n\t\t\tref flow references powerControl.offSignalFlow\n\t\t\t\tfrom source.offSignal to target.offSignal;\n\t\t}\n\t}\n\n\taction powerControl {\n\t\taction sendStartSignal { out startSignal: StartSignal; }\n\t\taction sendOnSignal { out onSignal: OnSignal; }\n\t\taction sendOffSignal { out offSignal: OffSignal; }\n\t\tsuccession flow startSignalFlow from sendStartSignal.startSignal to manageOperatingState.startSignal;\n\t\tsuccession flow onSignalFlow from sendOnSignal.onSignal to manageOperatingState.onSignal;\n\t\tsuccession flow offSignalFlow from sendOffSignal.offSignal to manageOperatingState.offSignal;\n\t\taction manageOperatingState {\n\t\t\tin startSignal: StartSignal;\n\t\t\tin onSignal: OnSignal;\n\t\t\tin offSignal: OffSignal;\n\t\t\tout operatingState: OperatingState;\n\t\t\tstateMachine VehicleStateMachine {\n\t\t\t\tstate Off initial;\n\t\t\t\tstate Start;\n\t\t\t\tstate On;\n\t\t\t\ttransition OffToStart from Off to Start when startSignal;\n\t\t\t\ttransition StartToOn from Start to On when onSignal;\n\t\t\t\ttransition OnToOff from On to Off when offSignal;\n\t\t\t}\n\t\t}\n\t}\n\n\taction healthManagement {\n\t\taction monitorHealthState { out healthState: HealthState; }\n\t}\n}",
    "package 'VehicleHealthMonitoring' {\n\tattribute def Temperature;\n\tattribute def MaxAllowableTemperature;\n\tattribute def HealthStatus { enumeration { Normal, Degraded, Maintenance } }\n\tattribute def MaintenanceInterval;\n\tattribute def MaintenanceElapsedTime;\n\tattribute def OverTempWarning;\n\tattribute def MaintenanceDue;\n\tattribute def MaintenanceComplete;\n\tattribute def Time;\n\n\tport def TempSensePort {\n\t\tout temperature: Temperature;\n\t}\n\tport def MaxTempPort {\n\t\tout maxTemperature: MaxAllowableTemperature;\n\t}\n\tport def HealthStatusPort {\n\t\tout healthStatus: HealthStatus;\n\t}\n\tport def WarningPort {\n\t\tout overTempWarning: OverTempWarning;\n\t}\n\tport def MaintenancePort {\n\t\tout maintenanceDue: MaintenanceDue;\n\t\tin maintenanceComplete: MaintenanceComplete;\n\t}\n\tport def TimePort {\n\t\tout time: Time;\n\t}\n\n\tpart context {\n\t\tpart vehicle {\n\t\t\tport tempSensePort: TempSensePort;\n\t\t\tport maxTempPort: MaxTempPort;\n\t\t\tport healthStatusPort: ~HealthStatusPort;\n\t\t\tport warningPort: ~WarningPort;\n\t\t\tport maintenancePort: ~MaintenancePort;\n\t\t\tport timePort: TimePort;\n\t\t\tperform monitorAndManage.monitorVehicleHealth {\n\t\t\t\tin temperature = tempSensePort.temperature;\n\t\t\t\tin maxTemperature = maxTempPort.maxTemperature;\n\t\t\t\tin time = timePort.time;\n\t\t\t\tin maintenanceComplete = maintenancePort.maintenanceComplete;\n\t\t\t\tout healthStatus = healthStatusPort.healthStatus;\n\t\t\t\tout overTempWarning = warningPort.overTempWarning;\n\t\t\t\tout maintenanceDue = maintenancePort.maintenanceDue;\n\t\t\t}\n\t\t}\n\t}\n\n\taction monitorAndManage {\n\t\taction monitorVehicleHealth {\n\t\t\tin temperature: Temperature;\n\t\t\tin maxTemperature: MaxAllowableTemperature;\n\t\t\tin time: Time;\n\t\t\tin maintenanceComplete: MaintenanceComplete;\n\t\t\tout healthStatus: HealthStatus;\n\t\t\tout overTempWarning: OverTempWarning;\n\t\t\tout maintenanceDue: MaintenanceDue;\n\n\t\t\t// Over-temperature detection and status management\n\t\t\tif (temperature > maxTemperature) {\n\t\t\t\toverTempWarning = true;\n\t\t\t\thealthStatus = HealthStatus.Degraded;\n\t\t\t} else if (healthStatus == HealthStatus.Degraded && temperature <= maxTemperature) {\n\t\t\t\toverTempWarning = false;\n\t\t\t\thealthStatus = HealthStatus.Normal;\n\t\t\t}\n\n\t\t\t// Maintenance scheduling\n\t\t\tif (time >= nextMaintenanceTime) {\n\t\t\t\tmaintenanceDue = true;\n\t\t\t\thealthStatus = HealthStatus.Maintenance;\n\t\t\t\tmaintenanceStartTime = time;\n\t\t\t}\n\n\t\t\t// Maintenance completion and cycle update\n\t\t\tif (healthStatus == HealthStatus.Maintenance && maintenanceComplete) {\n\t\t\t\tnextMaintenanceTime = time + MaintenanceInterval;\n\t\t\t\tmaintenanceDue = false;\n\t\t\t\tmaintenanceStartTime = time;\n\t\t\t}\n\n\t\t\t// Automatic return to normal after 48 hours in maintenance\n\t\t\tif (healthStatus == HealthStatus.Maintenance && (time - maintenanceStartTime) >= 48h) {\n\t\t\t\thealthStatus = HealthStatus.Normal;\n\t\t\t}\n\t\t}\n\t}\n}",
    "package 'TimedServer' {\n\tattribute def StartCmd;\n\tattribute def RequestMsg;\n\tattribute def ResponseMsg;\n\tattribute def Time;\n\tattribute def DateTime;\n\t\n\tport def RequestPort {\n\t\tin startCmd: StartCmd;\n\t\tin requestMsg: RequestMsg;\n\t}\n\t\n\tpart context {\n\t\tpart server {\n\t\t\tport requestPort: RequestPort;\n\t\t\tpart localClock: LocalClock;\n\t\t\tstateMachine ServerStateMachine {\n\t\t\t\tstate Off {\n\t\t\t\t\tentry / setPowerState(\"off\");\n\t\t\t\t\ttransition to Waiting\n\t\t\t\t\t\twhen requestPort.startCmd received;\n\t\t\t\t\ttransition to Off\n\t\t\t\t\t\twhen localClock.time == dailyOffTime;\n\t\t\t\t}\n\t\t\t\tstate Waiting {\n\t\t\t\t\tentry / setPowerState(\"on\");\n\t\t\t\t\ttransition to Response\n\t\t\t\t\t\twhen requestPort.requestMsg received;\n\t\t\t\t\ttransition to Off\n\t\t\t\t\t\twhen localClock.time == dailyOffTime;\n\t\t\t\t}\n\t\t\t\tstate Response {\n\t\t\t\t\tentry / sendResponse();\n\t\t\t\t\tdo / wait(5 min);\n\t\t\t\t\ttransition to Waiting\n\t\t\t\t\t\tafter 5 min;\n\t\t\t\t\ttransition to Off\n\t\t\t\t\t\twhen localClock.time == dailyOffTime;\n\t\t\t\t}\n\t\t\t}\n\t\t\tperform timedService {\n\t\t\t\tin startCmd = requestPort.startCmd;\n\t\t\t\tin requestMsg = requestPort.requestMsg;\n\t\t\t\tin time = localClock.time;\n\t\t\t}\n\t\t}\n\t}\n\t\n\tpart def LocalClock {\n\t\tattribute time: DateTime;\n\t}\n\t\n\tconstant dailyOffTime: DateTime = DateTime(\"T23:59:00\");\n\t\n\taction timedService {\n\t\tin startCmd: StartCmd;\n\t\tin requestMsg: RequestMsg;\n\t\tin time: DateTime;\n\t}\n}",
    "package 'VehicleStartStopSystem' {\n\tattribute def StartSignal;\n\tattribute def StopSignal;\n\tattribute def PowerOnSignal;\n\tattribute def BrakePedalStatus;\n\tattribute def ControllerStartSignal;\n\tattribute def SelfCheckResult;\n\tattribute def PowerSupplyStatus;\n\tattribute def ParkingBrakeCmd;\n\n\tport def StartSignalPort {\n\t\tin startSignal: StartSignal;\n\t}\n\tport def StopSignalPort {\n\t\tin stopSignal: StopSignal;\n\t}\n\tport def PowerOnSignalPort {\n\t\tin powerOnSignal: PowerOnSignal;\n\t}\n\tport def BrakePedalStatusPort {\n\t\tin brakePedalStatus: BrakePedalStatus;\n\t}\n\tport def ControllerStartSignalPort {\n\t\tout controllerStartSignal: ControllerStartSignal;\n\t}\n\tport def SelfCheckResultPort {\n\t\tout selfCheckResult: SelfCheckResult;\n\t}\n\tport def PowerSupplyStatusPort {\n\t\tout powerSupplyStatus: PowerSupplyStatus;\n\t}\n\tport def ParkingBrakeCmdPort {\n\t\tout parkingBrakeCmd: ParkingBrakeCmd;\n\t}\n\n\tpart context {\n\t\tpart user {\n\t\t\tport startSignalPort: StartSignalPort;\n\t\t\tport stopSignalPort: StopSignalPort;\n\t\t\tport powerOnSignalPort: PowerOnSignalPort;\n\t\t\tport brakePedalStatusPort: BrakePedalStatusPort;\n\t\t\tperform startStopProcess.sendUserInputs {\n\t\t\t\tout startSignal = startSignalPort.startSignal;\n\t\t\t\tout stopSignal = stopSignalPort.stopSignal;\n\t\t\t\tout powerOnSignal = powerOnSignalPort.powerOnSignal;\n\t\t\t\tout brakePedalStatus = brakePedalStatusPort.brakePedalStatus;\n\t\t\t}\n\t\t}\n\t\tpart vehicleSystem {\n\t\t\tport startSignalPort: ~StartSignalPort;\n\t\t\tport stopSignalPort: ~StopSignalPort;\n\t\t\tport powerOnSignalPort: ~PowerOnSignalPort;\n\t\t\tport brakePedalStatusPort: ~BrakePedalStatusPort;\n\t\t\tport controllerStartSignalPort: ControllerStartSignalPort;\n\t\t\tport selfCheckResultPort: SelfCheckResultPort;\n\t\t\tport powerSupplyStatusPort: PowerSupplyStatusPort;\n\t\t\tport parkingBrakeCmdPort: ParkingBrakeCmdPort;\n\t\t\tperform startStopProcess.controlStartStop {\n\t\t\t\tin startSignal = startSignalPort.startSignal;\n\t\t\t\tin stopSignal = stopSignalPort.stopSignal;\n\t\t\t\tin powerOnSignal = powerOnSignalPort.powerOnSignal;\n\t\t\t\tin brakePedalStatus = brakePedalStatusPort.brakePedalStatus;\n\t\t\t\tout controllerStartSignal = controllerStartSignalPort.controllerStartSignal;\n\t\t\t\tout selfCheckResult = selfCheckResultPort.selfCheckResult;\n\t\t\t\tout powerSupplyStatus = powerSupplyStatusPort.powerSupplyStatus;\n\t\t\t\tout parkingBrakeCmd = parkingBrakeCmdPort.parkingBrakeCmd;\n\t\t\t}\n\t\t}\n\t\tpart controller {\n\t\t\tport controllerStartSignalPort: ~ControllerStartSignalPort;\n\t\t\tperform startStopProcess.receiveControllerStartSignal {\n\t\t\t\tin controllerStartSignal = controllerStartSignalPort.controllerStartSignal;\n\t\t\t}\n\t\t}\n\t}\n\n\taction startStopProcess {\n\t\taction sendUserInputs {\n\t\t\tout startSignal: StartSignal;\n\t\t\tout stopSignal: StopSignal;\n\t\t\tout powerOnSignal: PowerOnSignal;\n\t\t\tout brakePedalStatus: BrakePedalStatus;\n\t\t}\n\t\taction controlStartStop {\n\t\t\tin startSignal: StartSignal;\n\t\t\tin stopSignal: StopSignal;\n\t\t\tin powerOnSignal: PowerOnSignal;\n\t\t\tin brakePedalStatus: BrakePedalStatus;\n\t\t\tout controllerStartSignal: ControllerStartSignal;\n\t\t\tout selfCheckResult: SelfCheckResult;\n\t\t\tout powerSupplyStatus: PowerSupplyStatus;\n\t\t\tout parkingBrakeCmd: ParkingBrakeCmd;\n\t\t}\n\t\taction receiveControllerStartSignal {\n\t\t\tin controllerStartSignal: ControllerStartSignal;\n\t\t}\n\t\tsuccession flow startSignalFlow from sendUserInputs.startSignal to controlStartStop.startSignal;\n\t\tsuccession flow stopSignalFlow from sendUserInputs.stopSignal to controlStartStop.stopSignal;\n\t\tsuccession flow powerOnSignalFlow from sendUserInputs.powerOnSignal to controlStartStop.powerOnSignal;\n\t\tsuccession flow brakePedalStatusFlow from sendUserInputs.brakePedalStatus to controlStartStop.brakePedalStatus;\n\t\tsuccession flow controllerStartSignalFlow from controlStartStop.controllerStartSignal to receiveControllerStartSignal.controllerStartSignal;\n\t}\n}",
    "package 'VehicleStartStopSystem' {\n\tattribute def StartSignal;\n\tattribute def BrakePedalStatus;\n\tattribute def VehicleOnSignal;\n\tattribute def StartControlSignal;\n\tattribute def ShutdownSignal;\n\tattribute def PowerSupply;\n\tattribute def ParkingBrakeStatus;\n\tattribute def VehicleState; // {off, starting, started, shuttingDown}\n\n\tport def StartSignalPort {\n\t\tin startSignal: StartSignal;\n\t}\n\tport def BrakePedalPort {\n\t\tin brakePedalStatus: BrakePedalStatus;\n\t}\n\tport def VehicleOnSignalPort {\n\t\tin vehicleOnSignal: VehicleOnSignal;\n\t}\n\tport def StartControlPort {\n\t\tout startControlSignal: StartControlSignal;\n\t}\n\tport def ShutdownSignalPort {\n\t\tin shutdownSignal: ShutdownSignal;\n\t}\n\tport def PowerSupplyPort {\n\t\tout powerSupply: PowerSupply;\n\t}\n\tport def ParkingBrakePort {\n\t\tout parkingBrakeStatus: ParkingBrakeStatus;\n\t}\n\tport def VehicleStatePort {\n\t\tout vehicleState: VehicleState;\n\t}\n\n\tpart context {\n\t\tpart driver {\n\t\t\tport startSignalPort: StartSignalPort;\n\t\t\tport brakePedalPort: BrakePedalPort;\n\t\t\tport vehicleOnSignalPort: VehicleOnSignalPort;\n\t\t\tport shutdownSignalPort: ShutdownSignalPort;\n\t\t\tperform vehicleControl.sendStartSignal {\n\t\t\t\tout startSignal = startSignalPort.startSignal;\n\t\t\t\tout brakePedalStatus = brakePedalPort.brakePedalStatus;\n\t\t\t\tout vehicleOnSignal = vehicleOnSignalPort.vehicleOnSignal;\n\t\t\t\tout shutdownSignal = shutdownSignalPort.shutdownSignal;\n\t\t\t}\n\t\t}\n\t\tpart vehicleStartStopSystem {\n\t\t\tport startSignalPort: ~StartSignalPort;\n\t\t\tport brakePedalPort: ~BrakePedalPort;\n\t\t\tport vehicleOnSignalPort: ~VehicleOnSignalPort;\n\t\t\tport startControlPort: StartControlPort;\n\t\t\tport shutdownSignalPort: ~ShutdownSignalPort;\n\t\t\tport powerSupplyPort: PowerSupplyPort;\n\t\t\tport parkingBrakePort: ParkingBrakePort;\n\t\t\tport vehicleStatePort: VehicleStatePort;\n\t\t\tperform vehicleControl.manageVehicleState {\n\t\t\t\tin startSignal = startSignalPort.startSignal;\n\t\t\t\tin brakePedalStatus = brakePedalPort.brakePedalStatus;\n\t\t\t\tin vehicleOnSignal = vehicleOnSignalPort.vehicleOnSignal;\n\t\t\t\tin shutdownSignal = shutdownSignalPort.shutdownSignal;\n\t\t\t\tout startControlSignal = startControlPort.startControlSignal;\n\t\t\t\tout powerSupply = powerSupplyPort.powerSupply;\n\t\t\t\tout parkingBrakeStatus = parkingBrakePort.parkingBrakeStatus;\n\t\t\t\tout vehicleState = vehicleStatePort.vehicleState;\n\t\t\t}\n\t\t}\n\t\tpart vehicleController {\n\t\t\tport startControlPort: ~StartControlPort;\n\t\t\tport powerSupplyPort: ~PowerSupplyPort;\n\t\t\tport parkingBrakePort: ~ParkingBrakePort;\n\t\t\tport vehicleStatePort: ~VehicleStatePort;\n\t\t\tperform vehicleControl.vehicleOperation {\n\t\t\t\tin startControlSignal = startControlPort.startControlSignal;\n\t\t\t\tin powerSupply = powerSupplyPort.powerSupply;\n\t\t\t\tin parkingBrakeStatus = parkingBrakePort.parkingBrakeStatus;\n\t\t\t\tin vehicleState = vehicleStatePort.vehicleState;\n\t\t\t}\n\t\t}\n\t\tinterface driverToSystem connect driver.startSignalPort to vehicleStartStopSystem.startSignalPort {\n\t\t\tref flow references vehicleControl.startSignalFlow\n\t\t\t\tfrom source.startSignal to target.startSignal;\n\t\t}\n\t\tinterface driverToSystemBrake connect driver.brakePedalPort to vehicleStartStopSystem.brakePedalPort {\n\t\t\tref flow references vehicleControl.brakePedalFlow\n\t\t\t\tfrom source.brakePedalStatus to target.brakePedalStatus;\n\t\t}\n\t\tinterface driverToSystemOnSignal connect driver.vehicleOnSignalPort to vehicleStartStopSystem.vehicleOnSignalPort {\n\t\t\tref flow references vehicleControl.vehicleOnSignalFlow\n\t\t\t\tfrom source.vehicleOnSignal to target.vehicleOnSignal;\n\t\t}\n\t\tinterface driverToSystemShutdown connect driver.shutdownSignalPort to vehicleStartStopSystem.shutdownSignalPort {\n\t\t\tref flow references vehicleControl.shutdownSignalFlow\n\t\t\t\tfrom source.shutdownSignal to target.shutdownSignal;\n\t\t}\n\t\tinterface systemToControllerStart connect vehicleStartStopSystem.startControlPort to vehicleController.startControlPort {\n\t\t\tref flow references vehicleControl.startControlFlow\n\t\t\t\tfrom source.startControlSignal to target.startControlSignal;\n\t\t}\n\t\tinterface systemToControllerPower connect vehicleStartStopSystem.powerSupplyPort to vehicleController.powerSupplyPort {\n\t\t\tref flow references vehicleControl.powerSupplyFlow\n\t\t\t\tfrom source.powerSupply to target.powerSupply;\n\t\t}\n\t\tinterface systemToControllerParkingBrake connect vehicleStartStopSystem.parkingBrakePort to vehicleController.parkingBrakePort {\n\t\t\tref flow references vehicleControl.parkingBrakeFlow\n\t\t\t\tfrom source.parkingBrakeStatus to target.parkingBrakeStatus;\n\t\t}\n\t\tinterface systemToControllerState connect vehicleStartStopSystem.vehicleStatePort to vehicleController.vehicleStatePort {\n\t\t\tref flow references vehicleControl.vehicleStateFlow\n\t\t\t\tfrom source.vehicleState to target.vehicleState;\n\t\t}\n\t}\n\n\taction vehicleControl {\n\t\taction sendStartSignal {\n\t\t\tout startSignal: StartSignal;\n\t\t\tout brakePedalStatus: BrakePedalStatus;\n\t\t\tout vehicleOnSignal: VehicleOnSignal;\n\t\t\tout shutdownSignal: ShutdownSignal;\n\t\t}\n\t\taction manageVehicleState {\n\t\t\tin startSignal: StartSignal;\n\t\t\tin brakePedalStatus: BrakePedalStatus;\n\t\t\tin vehicleOnSignal: VehicleOnSignal;\n\t\t\tin shutdownSignal: ShutdownSignal;\n\t\t\tout startControlSignal: StartControlSignal;\n\t\t\tout powerSupply: PowerSupply;\n\t\t\tout parkingBrakeStatus: ParkingBrakeStatus;\n\t\t\tout vehicleState: VehicleState;\n\t\t}\n\t\taction vehicleOperation {\n\t\t\tin startControlSignal: StartControlSignal;\n\t\t\tin powerSupply: PowerSupply;\n\t\t\tin parkingBrakeStatus: ParkingBrakeStatus;\n\t\t\tin vehicleState: VehicleState;\n\t\t}\n\t\tsuccession flow startSignalFlow from sendStartSignal.startSignal to manageVehicleState.startSignal;\n\t\tsuccession flow brakePedalFlow from sendStartSignal.brakePedalStatus to manageVehicleState.brakePedalStatus;\n\t\tsuccession flow vehicleOnSignalFlow from sendStartSignal.vehicleOnSignal to manageVehicleState.vehicleOnSignal;\n\t\tsuccession flow shutdownSignalFlow from sendStartSignal.shutdownSignal to manageVehicleState.shutdownSignal;\n\t\tsuccession flow startControlFlow from manageVehicleState.startControlSignal to vehicleOperation.startControlSignal;\n\t\tsuccession flow powerSupplyFlow from manageVehicleState.powerSupply to vehicleOperation.powerSupply;\n\t\tsuccession flow parkingBrakeFlow from manageVehicleState.parkingBrakeStatus to vehicleOperation.parkingBrakeStatus;\n\t\tsuccession flow vehicleStateFlow from manageVehicleState.vehicleState to vehicleOperation.vehicleState;\n\t}\n}",
    "package 'CruiseControlSystem' {\n\tattribute def SetSpeedCmd;\n\tattribute def VehicleSpeed;\n\tattribute def FuelControlCmd;\n\n\tport def SetSpeedCmdPort {\n\t\tout setSpeedCmd: SetSpeedCmd;\n\t}\n\tport def VehicleSpeedPort {\n\t\tout vehicleSpeed: VehicleSpeed;\n\t}\n\tport def FuelControlCmdPort {\n\t\tout fuelControlCmd: FuelControlCmd;\n\t}\n\n\tpart context {\n\t\tpart driver {\n\t\t\tport setSpeedCmdPort: SetSpeedCmdPort;\n\t\t\tperform cruiseControl.sendSetSpeedCmd {\n\t\t\t\tout setSpeedCmd = setSpeedCmdPort.setSpeedCmd;\n\t\t\t}\n\t\t}\n\t\tpart cruiseController {\n\t\t\tport setSpeedCmdPort: ~SetSpeedCmdPort;\n\t\t\tport vehicleSpeedPort: ~VehicleSpeedPort;\n\t\t\tport fuelControlCmdPort: FuelControlCmdPort;\n\t\t\tperform cruiseControl.processCruiseControl {\n\t\t\t\tin setSpeedCmd = setSpeedCmdPort.setSpeedCmd;\n\t\t\t\tin vehicleSpeed = vehicleSpeedPort.vehicleSpeed;\n\t\t\t\tout fuelControlCmd = fuelControlCmdPort.fuelControlCmd;\n\t\t\t}\n\t\t}\n\t\tpart speedometer {\n\t\t\tport vehicleSpeedPort: VehicleSpeedPort;\n\t\t\tperform cruiseControl.measureVehicleSpeed {\n\t\t\t\tout vehicleSpeed = vehicleSpeedPort.vehicleSpeed;\n\t\t\t}\n\t\t}\n\t\tpart engine {\n\t\t\tport fuelControlCmdPort: ~FuelControlCmdPort;\n\t\t\tperform cruiseControl.adjustEngineOutput {\n\t\t\t\tin fuelControlCmd = fuelControlCmdPort.fuelControlCmd;\n\t\t\t}\n\t\t}\n\t\tpart vehicle {\n\t\t\t// Placeholder for vehicle-specific behaviors or attributes\n\t\t}\n\t\tinterface driverToCruiseController connect driver.setSpeedCmdPort to cruiseController.setSpeedCmdPort {\n\t\t\tref flow references cruiseControl.setSpeedCmdFlow\n\t\t\t\tfrom source.setSpeedCmd to target.setSpeedCmd;\n\t\t}\n\t\tinterface speedometerToCruiseController connect speedometer.vehicleSpeedPort to cruiseController.vehicleSpeedPort {\n\t\t\tref flow references cruiseControl.vehicleSpeedFlow\n\t\t\t\tfrom source.vehicleSpeed to target.vehicleSpeed;\n\t\t}\n\t\tinterface cruiseControllerToEngine connect cruiseController.fuelControlCmdPort to engine.fuelControlCmdPort {\n\t\t\tref flow references cruiseControl.fuelControlCmdFlow\n\t\t\t\tfrom source.fuelControlCmd to target.fuelControlCmd;\n\t\t}\n\t}\n\n\taction cruiseControl {\n\t\taction sendSetSpeedCmd { out setSpeedCmd: SetSpeedCmd; }\n\t\taction measureVehicleSpeed { out vehicleSpeed: VehicleSpeed; }\n\t\taction processCruiseControl {\n\t\t\tin setSpeedCmd: SetSpeedCmd;\n\t\t\tin vehicleSpeed: VehicleSpeed;\n\t\t\tout fuelControlCmd: FuelControlCmd;\n\t\t}\n\t\taction adjustEngineOutput { in fuelControlCmd: FuelControlCmd; }\n\n\t\tsuccession flow setSpeedCmdFlow from sendSetSpeedCmd.setSpeedCmd to processCruiseControl.setSpeedCmd;\n\t\tsuccession flow vehicleSpeedFlow from measureVehicleSpeed.vehicleSpeed to processCruiseControl.vehicleSpeed;\n\t\tsuccession flow fuelControlCmdFlow from processCruiseControl.fuelControlCmd to adjustEngineOutput.fuelControlCmd;\n\t}\n}",
    "package 'CruiseControlSystem' {\n\tattribute def SetSpeedCmd;\n\tattribute def VehicleSpeed;\n\tattribute def ThrottleCmd;\n\n\tport def SetSpeedCmdPort {\n\t\tout setSpeedCmd: SetSpeedCmd;\n\t}\n\tport def VehicleSpeedPort {\n\t\tout vehicleSpeed: VehicleSpeed;\n\t}\n\tport def ThrottleCmdPort {\n\t\tout throttleCmd: ThrottleCmd;\n\t}\n\n\tpart context {\n\t\tpart driver {\n\t\t\tport setSpeedCmdPort: SetSpeedCmdPort;\n\t\t\tperform cruiseControl.sendSetSpeedCmd {\n\t\t\t\tout setSpeedCmd = setSpeedCmdPort.setSpeedCmd;\n\t\t\t}\n\t\t}\n\t\tpart cruiseController {\n\t\t\tport setSpeedCmdPort: ~SetSpeedCmdPort;\n\t\t\tport vehicleSpeedPort: ~VehicleSpeedPort;\n\t\t\tport throttleCmdPort: ThrottleCmdPort;\n\t\t\tperform cruiseControl.processCruiseControl {\n\t\t\t\tin setSpeedCmd = setSpeedCmdPort.setSpeedCmd;\n\t\t\t\tin vehicleSpeed = vehicleSpeedPort.vehicleSpeed;\n\t\t\t\tout throttleCmd = throttleCmdPort.throttleCmd;\n\t\t\t}\n\t\t}\n\t\tpart speedometer {\n\t\t\tport vehicleSpeedPort: VehicleSpeedPort;\n\t\t\tperform cruiseControl.provideVehicleSpeed {\n\t\t\t\tout vehicleSpeed = vehicleSpeedPort.vehicleSpeed;\n\t\t\t}\n\t\t}\n\t\tpart engineSystem {\n\t\t\tport throttleCmdPort: ~ThrottleCmdPort;\n\t\t\tperform cruiseControl.receiveThrottleCmd {\n\t\t\t\tin throttleCmd = throttleCmdPort.throttleCmd;\n\t\t\t}\n\t\t}\n\t\tinterface driverToController connect driver.setSpeedCmdPort to cruiseController.setSpeedCmdPort {\n\t\t\tref flow references cruiseControl.setSpeedCmdFlow\n\t\t\t\tfrom source.setSpeedCmd to target.setSpeedCmd;\n\t\t}\n\t\tinterface speedometerToController connect speedometer.vehicleSpeedPort to cruiseController.vehicleSpeedPort {\n\t\t\tref flow references cruiseControl.vehicleSpeedFlow\n\t\t\t\tfrom source.vehicleSpeed to target.vehicleSpeed;\n\t\t}\n\t\tinterface controllerToEngine connect cruiseController.throttleCmdPort to engineSystem.throttleCmdPort {\n\t\t\tref flow references cruiseControl.throttleCmdFlow\n\t\t\t\tfrom source.throttleCmd to target.throttleCmd;\n\t\t}\n\t}\n\n\taction cruiseControl {\n\t\taction sendSetSpeedCmd { out setSpeedCmd: SetSpeedCmd; }\n\t\taction provideVehicleSpeed { out vehicleSpeed: VehicleSpeed; }\n\t\taction processCruiseControl {\n\t\t\tin setSpeedCmd: SetSpeedCmd;\n\t\t\tin vehicleSpeed: VehicleSpeed;\n\t\t\tout throttleCmd: ThrottleCmd;\n\t\t}\n\t\taction receiveThrottleCmd { in throttleCmd: ThrottleCmd; }\n\n\t\tsuccession flow setSpeedCmdFlow from sendSetSpeedCmd.setSpeedCmd to processCruiseControl.setSpeedCmd;\n\t\tsuccession flow vehicleSpeedFlow from provideVehicleSpeed.vehicleSpeed to processCruiseControl.vehicleSpeed;\n\t\tsuccession flow throttleCmdFlow from processCruiseControl.throttleCmd to receiveThrottleCmd.throttleCmd;\n\t}\n}",
    "package 'CruiseControl' {\n\tattribute def SetSpeedCmd;\n\tattribute def VehicleSpeed;\n\tattribute def ThrottleCmd;\n\n\tport def SetSpeedCmdPort {\n\t\tout setSpeedCmd: SetSpeedCmd;\n\t}\n\tport def VehicleSpeedPort {\n\t\tout vehicleSpeed: VehicleSpeed;\n\t}\n\tport def ThrottleCmdPort {\n\t\tout throttleCmd: ThrottleCmd;\n\t}\n\n\tpart context {\n\t\tpart driver {\n\t\t\tport setSpeedCmdPort: SetSpeedCmdPort;\n\t\t\tperform maintainSpeed.sendSetSpeedCmd {\n\t\t\t\tout setSpeedCmd = setSpeedCmdPort.setSpeedCmd;\n\t\t\t}\n\t\t}\n\t\tpart speedometer {\n\t\t\tport vehicleSpeedPort: VehicleSpeedPort;\n\t\t\tperform maintainSpeed.sendVehicleSpeed {\n\t\t\t\tout vehicleSpeed = vehicleSpeedPort.vehicleSpeed;\n\t\t\t}\n\t\t}\n\t\tpart cruiseController {\n\t\t\tport setSpeedCmdPort: ~SetSpeedCmdPort;\n\t\t\tport vehicleSpeedPort: ~VehicleSpeedPort;\n\t\t\tport throttleCmdPort: ThrottleCmdPort;\n\t\t\tperform maintainSpeed.processCruiseControl {\n\t\t\t\tin setSpeedCmd = setSpeedCmdPort.setSpeedCmd;\n\t\t\t\tin vehicleSpeed = vehicleSpeedPort.vehicleSpeed;\n\t\t\t\tout throttleCmd = throttleCmdPort.throttleCmd;\n\t\t\t}\n\t\t}\n\t\tpart engine {\n\t\t\tport throttleCmdPort: ~ThrottleCmdPort;\n\t\t\tperform maintainSpeed.receiveThrottleCmd {\n\t\t\t\tin throttleCmd = throttleCmdPort.throttleCmd;\n\t\t\t}\n\t\t}\n\t\tinterface driverToCruiseController connect driver.setSpeedCmdPort to cruiseController.setSpeedCmdPort {\n\t\t\tref flow references maintainSpeed.setSpeedCmdFlow\n\t\t\t\tfrom source.setSpeedCmd to target.setSpeedCmd;\n\t\t}\n\t\tinterface speedometerToCruiseController connect speedometer.vehicleSpeedPort to cruiseController.vehicleSpeedPort {\n\t\t\tref flow references maintainSpeed.vehicleSpeedFlow\n\t\t\t\tfrom source.vehicleSpeed to target.vehicleSpeed;\n\t\t}\n\t\tinterface cruiseControllerToEngine connect cruiseController.throttleCmdPort to engine.throttleCmdPort {\n\t\t\tref flow references maintainSpeed.throttleCmdFlow\n\t\t\t\tfrom source.throttleCmd to target.throttleCmd;\n\t\t}\n\t}\n\n\taction maintainSpeed {\n\t\taction sendSetSpeedCmd { out setSpeedCmd: SetSpeedCmd; }\n\t\taction sendVehicleSpeed { out vehicleSpeed: VehicleSpeed; }\n\t\taction processCruiseControl {\n\t\t\tin setSpeedCmd: SetSpeedCmd;\n\t\t\tin vehicleSpeed: VehicleSpeed;\n\t\t\tout throttleCmd: ThrottleCmd;\n\t\t}\n\t\taction receiveThrottleCmd { in throttleCmd: ThrottleCmd; }\n\n\t\tsuccession flow setSpeedCmdFlow from sendSetSpeedCmd.setSpeedCmd to processCruiseControl.setSpeedCmd;\n\t\tsuccession flow vehicleSpeedFlow from sendVehicleSpeed.vehicleSpeed to processCruiseControl.vehicleSpeed;\n\t\tsuccession flow throttleCmdFlow from processCruiseControl.throttleCmd to receiveThrottleCmd.throttleCmd;\n\t}\n}",
    "package 'AutomotiveCruiseControl' {\n\tattribute def SpeedSetting;\n\tattribute def VehicleSpeed;\n\tattribute def ThrottleCmd;\n\n\tport def SpeedSettingPort {\n\t\tout speedSetting: SpeedSetting;\n\t}\n\tport def VehicleSpeedPort {\n\t\tout vehicleSpeed: VehicleSpeed;\n\t}\n\tport def ThrottleCmdPort {\n\t\tout throttleCmd: ThrottleCmd;\n\t}\n\n\tpart context {\n\t\tpart driver {\n\t\t\tport speedSettingPort: SpeedSettingPort;\n\t\t\tperform cruiseControlWorkflow.sendSpeedSetting {\n\t\t\t\tout speedSetting = speedSettingPort.speedSetting;\n\t\t\t}\n\t\t}\n\t\tpart speedometer {\n\t\t\tport vehicleSpeedPort: VehicleSpeedPort;\n\t\t\tperform cruiseControlWorkflow.senseVehicleSpeed {\n\t\t\t\tout vehicleSpeed = vehicleSpeedPort.vehicleSpeed;\n\t\t\t}\n\t\t}\n\t\tpart cruiseController {\n\t\t\tport speedSettingPort: ~SpeedSettingPort;\n\t\t\tport vehicleSpeedPort: ~VehicleSpeedPort;\n\t\t\tport throttleCmdPort: ThrottleCmdPort;\n\t\t\tperform cruiseControlWorkflow.adjustThrottle {\n\t\t\t\tin speedSetting = speedSettingPort.speedSetting;\n\t\t\t\tin vehicleSpeed = vehicleSpeedPort.vehicleSpeed;\n\t\t\t\tout throttleCmd = throttleCmdPort.throttleCmd;\n\t\t\t}\n\t\t}\n\t\tpart engine {\n\t\t\tport throttleCmdPort: ~ThrottleCmdPort;\n\t\t\tperform cruiseControlWorkflow.receiveThrottleCmd {\n\t\t\t\tin throttleCmd = throttleCmdPort.throttleCmd;\n\t\t\t}\n\t\t}\n\t\tinterface driverToController connect driver.speedSettingPort to cruiseController.speedSettingPort {\n\t\t\tref flow references cruiseControlWorkflow.speedSettingFlow\n\t\t\t\tfrom source.speedSetting to target.speedSetting;\n\t\t}\n\t\tinterface speedometerToController connect speedometer.vehicleSpeedPort to cruiseController.vehicleSpeedPort {\n\t\t\tref flow references cruiseControlWorkflow.vehicleSpeedFlow\n\t\t\t\tfrom source.vehicleSpeed to target.vehicleSpeed;\n\t\t}\n\t\tinterface controllerToEngine connect cruiseController.throttleCmdPort to engine.throttleCmdPort {\n\t\t\tref flow references cruiseControlWorkflow.throttleCmdFlow\n\t\t\t\tfrom source.throttleCmd to target.throttleCmd;\n\t\t}\n\t}\n\n\taction cruiseControlWorkflow {\n\t\taction sendSpeedSetting { out speedSetting: SpeedSetting; }\n\t\taction senseVehicleSpeed { out vehicleSpeed: VehicleSpeed; }\n\t\taction adjustThrottle { \n\t\t\tin speedSetting: SpeedSetting; \n\t\t\tin vehicleSpeed: VehicleSpeed; \n\t\t\tout throttleCmd: ThrottleCmd; \n\t\t}\n\t\taction receiveThrottleCmd { in throttleCmd: ThrottleCmd; }\n\n\t\tsuccession flow speedSettingFlow from sendSpeedSetting.speedSetting to adjustThrottle.speedSetting;\n\t\tsuccession flow vehicleSpeedFlow from senseVehicleSpeed.vehicleSpeed to adjustThrottle.vehicleSpeed;\n\t\tsuccession flow throttleCmdFlow from adjustThrottle.throttleCmd to receiveThrottleCmd.throttleCmd;\n\t}\n}",
    "package 'CruiseControl' {\n\tattribute def SetSpeed;\n\tattribute def ActualSpeed;\n\tattribute def FuelControlCmd;\n\n\tport def SetSpeedPort {\n\t\tout setSpeed: SetSpeed;\n\t}\n\tport def ActualSpeedPort {\n\t\tout actualSpeed: ActualSpeed;\n\t}\n\tport def FuelControlCmdPort {\n\t\tout fuelControlCmd: FuelControlCmd;\n\t}\n\n\tpart context {\n\t\tpart driver {\n\t\t\tport setSpeedPort: SetSpeedPort;\n\t\t\tperform maintainCruise.sendSetSpeed {\n\t\t\t\tout setSpeed = setSpeedPort.setSpeed;\n\t\t\t}\n\t\t}\n\t\tpart cruiseControlInterface {\n\t\t\tport setSpeedPort: ~SetSpeedPort;\n\t\t\tperform maintainCruise.receiveSetSpeed {\n\t\t\t\tin setSpeed = setSpeedPort.setSpeed;\n\t\t\t}\n\t\t\tport setSpeedOutPort: SetSpeedPort;\n\t\t\tperform maintainCruise.forwardSetSpeed {\n\t\t\t\tin setSpeed = setSpeedPort.setSpeed;\n\t\t\t\tout setSpeed = setSpeedOutPort.setSpeed;\n\t\t\t}\n\t\t}\n\t\tpart cruiseController {\n\t\t\tport setSpeedPort: ~SetSpeedPort;\n\t\t\tport actualSpeedPort: ~ActualSpeedPort;\n\t\t\tport fuelControlCmdPort: FuelControlCmdPort;\n\t\t\tperform maintainCruise.controlSpeed {\n\t\t\t\tin setSpeed = setSpeedPort.setSpeed;\n\t\t\t\tin actualSpeed = actualSpeedPort.actualSpeed;\n\t\t\t\tout fuelControlCmd = fuelControlCmdPort.fuelControlCmd;\n\t\t\t}\n\t\t}\n\t\tpart speedSensor {\n\t\t\tport actualSpeedPort: ActualSpeedPort;\n\t\t\tperform maintainCruise.senseSpeed {\n\t\t\t\tout actualSpeed = actualSpeedPort.actualSpeed;\n\t\t\t}\n\t\t}\n\t\tpart engine {\n\t\t\tport fuelControlCmdPort: ~FuelControlCmdPort;\n\t\t\tperform maintainCruise.adjustEngine {\n\t\t\t\tin fuelControlCmd = fuelControlCmdPort.fuelControlCmd;\n\t\t\t}\n\t\t}\n\n\t\tinterface driverToInterface connect driver.setSpeedPort to cruiseControlInterface.setSpeedPort {\n\t\t\tref flow references maintainCruise.setSpeedFlow\n\t\t\t\tfrom source.setSpeed to target.setSpeed;\n\t\t}\n\t\tinterface interfaceToController connect cruiseControlInterface.setSpeedOutPort to cruiseController.setSpeedPort {\n\t\t\tref flow references maintainCruise.setSpeedFlow2\n\t\t\t\tfrom source.setSpeed to target.setSpeed;\n\t\t}\n\t\tinterface sensorToController connect speedSensor.actualSpeedPort to cruiseController.actualSpeedPort {\n\t\t\tref flow references maintainCruise.actualSpeedFlow\n\t\t\t\tfrom source.actualSpeed to target.actualSpeed;\n\t\t}\n\t\tinterface controllerToEngine connect cruiseController.fuelControlCmdPort to engine.fuelControlCmdPort {\n\t\t\tref flow references maintainCruise.fuelControlCmdFlow\n\t\t\t\tfrom source.fuelControlCmd to target.fuelControlCmd;\n\t\t}\n\t}\n\n\taction maintainCruise {\n\t\taction sendSetSpeed { out setSpeed: SetSpeed; }\n\t\taction receiveSetSpeed { in setSpeed: SetSpeed; }\n\t\tsuccession flow setSpeedFlow from sendSetSpeed.setSpeed to receiveSetSpeed.setSpeed;\n\n\t\taction forwardSetSpeed { in setSpeed: SetSpeed; out setSpeed: SetSpeed; }\n\t\tsuccession flow setSpeedFlow2 from receiveSetSpeed.setSpeed to forwardSetSpeed.setSpeed;\n\t\tsuccession flow setSpeedFlow3 from forwardSetSpeed.setSpeed to controlSpeed.setSpeed;\n\n\t\taction senseSpeed { out actualSpeed: ActualSpeed; }\n\t\tsuccession flow actualSpeedFlow from senseSpeed.actualSpeed to controlSpeed.actualSpeed;\n\n\t\taction controlSpeed { in setSpeed: SetSpeed; in actualSpeed: ActualSpeed; out fuelControlCmd: FuelControlCmd; }\n\t\tsuccession flow fuelControlCmdFlow from controlSpeed.fuelControlCmd to adjustEngine.fuelControlCmd;\n\n\t\taction adjustEngine { in fuelControlCmd: FuelControlCmd; }\n\t}\n}",
    "package 'CruiseControlSystem' {\n\tattribute def SetSpeedCmd;\n\tattribute def ActualSpeed;\n\tattribute def FuelCtrlCmd;\n\n\tport def SetSpeedCmdPort {\n\t\tout setSpeedCmd: SetSpeedCmd;\n\t}\n\tport def ActualSpeedPort {\n\t\tout actualSpeed: ActualSpeed;\n\t}\n\tport def FuelCtrlCmdPort {\n\t\tout fuelCtrlCmd: FuelCtrlCmd;\n\t}\n\n\tpart context {\n\t\tpart driver {\n\t\t\tport setSpeedCmdPort: SetSpeedCmdPort;\n\t\t\tperform cruiseControlInteraction.sendSetSpeedCmd {\n\t\t\t\tout setSpeedCmd = setSpeedCmdPort.setSpeedCmd;\n\t\t\t}\n\t\t}\n\t\tpart cruiseController {\n\t\t\tport setSpeedCmdPort: ~SetSpeedCmdPort;\n\t\t\tport actualSpeedPort: ~ActualSpeedPort;\n\t\t\tport fuelCtrlCmdPort: FuelCtrlCmdPort;\n\t\t\tperform cruiseControlInteraction.processSetSpeedCmd {\n\t\t\t\tin setSpeedCmd = setSpeedCmdPort.setSpeedCmd;\n\t\t\t}\n\t\t\tperform cruiseControlInteraction.readActualSpeed {\n\t\t\t\tin actualSpeed = actualSpeedPort.actualSpeed;\n\t\t\t}\n\t\t\tperform cruiseControlInteraction.generateFuelCtrlCmd {\n\t\t\t\tin setSpeedCmd;\n\t\t\t\tin actualSpeed;\n\t\t\t\tout fuelCtrlCmd = fuelCtrlCmdPort.fuelCtrlCmd;\n\t\t\t}\n\t\t}\n\t\tpart speedSensor {\n\t\t\tport actualSpeedPort: ActualSpeedPort;\n\t\t\tperform cruiseControlInteraction.provideActualSpeed {\n\t\t\t\tout actualSpeed = actualSpeedPort.actualSpeed;\n\t\t\t}\n\t\t}\n\t\tpart engineController {\n\t\t\tport fuelCtrlCmdPort: ~FuelCtrlCmdPort;\n\t\t\tport engineFuelCtrlCmdPort: FuelCtrlCmdPort;\n\t\t\tperform cruiseControlInteraction.processFuelCtrlCmd {\n\t\t\t\tin fuelCtrlCmd = fuelCtrlCmdPort.fuelCtrlCmd;\n\t\t\t\tout fuelCtrlCmd = engineFuelCtrlCmdPort.fuelCtrlCmd;\n\t\t\t}\n\t\t}\n\t\tpart engine {\n\t\t\tport fuelCtrlCmdPort: ~FuelCtrlCmdPort;\n\t\t\tperform cruiseControlInteraction.controlFuelFlow {\n\t\t\t\tin fuelCtrlCmd = fuelCtrlCmdPort.fuelCtrlCmd;\n\t\t\t}\n\t\t}\n\t\tinterface driverToCruiseController connect driver.setSpeedCmdPort to cruiseController.setSpeedCmdPort {\n\t\t\tref flow references cruiseControlInteraction.setSpeedCmdFlow\n\t\t\t\tfrom source.setSpeedCmd to target.setSpeedCmd;\n\t\t}\n\t\tinterface speedSensorToCruiseController connect speedSensor.actualSpeedPort to cruiseController.actualSpeedPort {\n\t\t\tref flow references cruiseControlInteraction.actualSpeedFlow\n\t\t\t\tfrom source.actualSpeed to target.actualSpeed;\n\t\t}\n\t\tinterface cruiseControllerToEngineController connect cruiseController.fuelCtrlCmdPort to engineController.fuelCtrlCmdPort {\n\t\t\tref flow references cruiseControlInteraction.fuelCtrlCmdFlow\n\t\t\t\tfrom source.fuelCtrlCmd to target.fuelCtrlCmd;\n\t\t}\n\t\tinterface engineControllerToEngine connect engineController.engineFuelCtrlCmdPort to engine.fuelCtrlCmdPort {\n\t\t\tref flow references cruiseControlInteraction.engineFuelCtrlCmdFlow\n\t\t\t\tfrom source.fuelCtrlCmd to target.fuelCtrlCmd;\n\t\t}\n\t}\n\n\taction cruiseControlInteraction {\n\t\taction sendSetSpeedCmd { out setSpeedCmd: SetSpeedCmd; }\n\t\taction processSetSpeedCmd { in setSpeedCmd: SetSpeedCmd; }\n\t\tsuccession flow setSpeedCmdFlow from sendSetSpeedCmd.setSpeedCmd to processSetSpeedCmd.setSpeedCmd;\n\n\t\taction provideActualSpeed { out actualSpeed: ActualSpeed; }\n\t\taction readActualSpeed { in actualSpeed: ActualSpeed; }\n\t\tsuccession flow actualSpeedFlow from provideActualSpeed.actualSpeed to readActualSpeed.actualSpeed;\n\n\t\taction generateFuelCtrlCmd {\n\t\t\tin setSpeedCmd: SetSpeedCmd;\n\t\t\tin actualSpeed: ActualSpeed;\n\t\t\tout fuelCtrlCmd: FuelCtrlCmd;\n\t\t}\n\t\tsuccession flow fuelCtrlCmdFlow from generateFuelCtrlCmd.fuelCtrlCmd to processFuelCtrlCmd.fuelCtrlCmd;\n\n\t\taction processFuelCtrlCmd {\n\t\t\tin fuelCtrlCmd: FuelCtrlCmd;\n\t\t\tout fuelCtrlCmd: FuelCtrlCmd;\n\t\t}\n\t\tsuccession flow engineFuelCtrlCmdFlow from processFuelCtrlCmd.fuelCtrlCmd to controlFuelFlow.fuelCtrlCmd;\n\n\t\taction controlFuelFlow { in fuelCtrlCmd: FuelCtrlCmd; }\n\t}\n}",
    "package 'VehicleLifecycleManagement' {\n\t\n\tattribute def Vehicle;\n\tattribute def Owner;\n\tattribute def Driver;\n\tattribute def Date;\n\tattribute def DrivingOperation;\n\tattribute def ScrappingInfo;\n\n\tport def VehiclePort {\n\t\tinout vehicle: Vehicle;\n\t}\n\tport def OwnerPort {\n\t\tinout owner: Owner;\n\t}\n\tport def DriverPort {\n\t\tinout driver: Driver;\n\t}\n\tport def DatePort {\n\t\tinout date: Date;\n\t}\n\tport def DrivingOperationPort {\n\t\tinout drivingOperation: DrivingOperation;\n\t}\n\tport def ScrappingInfoPort {\n\t\tinout scrappingInfo: ScrappingInfo;\n\t}\n\n\tpart context {\n\t\tpart vehicleLifecycleManager {\n\t\t\tport vehiclePort: VehiclePort;\n\t\t\tport ownerPort: OwnerPort;\n\t\t\tport driverPort: DriverPort;\n\t\t\tport datePort: DatePort;\n\t\t\tport drivingOperationPort: DrivingOperationPort;\n\t\t\tport scrappingInfoPort: ScrappingInfoPort;\n\n\t\t\tperform manageLifecycle.assembleVehicle {\n\t\t\t\tout vehicle = vehiclePort.vehicle;\n\t\t\t}\n\t\t\tperform manageLifecycle.deliverVehicle {\n\t\t\t\tin vehicle = vehiclePort.vehicle;\n\t\t\t\tout date = datePort.date;\n\t\t\t}\n\t\t\tperform manageLifecycle.transferOwnership {\n\t\t\t\tin vehicle = vehiclePort.vehicle;\n\t\t\t\tout owner = ownerPort.owner;\n\t\t\t\tout date = datePort.date;\n\t\t\t}\n\t\t\tperform manageLifecycle.recordDrivingOperation {\n\t\t\t\tin vehicle = vehiclePort.vehicle;\n\t\t\t\tin owner = ownerPort.owner;\n\t\t\t\tout driver = driverPort.driver;\n\t\t\t\tout drivingOperation = drivingOperationPort.drivingOperation;\n\t\t\t\tout date = datePort.date;\n\t\t\t}\n\t\t\tperform manageLifecycle.scrapVehicle {\n\t\t\t\tin vehicle = vehiclePort.vehicle;\n\t\t\t\tout scrappingInfo = scrappingInfoPort.scrappingInfo;\n\t\t\t\tout date = datePort.date;\n\t\t\t}\n\t\t}\n\t}\n\n\taction manageLifecycle {\n\t\taction assembleVehicle { out vehicle: Vehicle; }\n\t\taction deliverVehicle { in vehicle: Vehicle; out date: Date; }\n\t\taction transferOwnership { in vehicle: Vehicle; out owner: Owner; out date: Date; }\n\t\taction recordDrivingOperation { \n\t\t\tin vehicle: Vehicle; \n\t\t\tin owner: Owner; \n\t\t\tout driver: Driver; \n\t\t\tout drivingOperation: DrivingOperation; \n\t\t\tout date: Date; \n\t\t}\n\t\taction scrapVehicle { in vehicle: Vehicle; out scrappingInfo: ScrappingInfo; out date: Date; }\n\n\t\tsuccession flow assemblyToDelivery from assembleVehicle.vehicle to deliverVehicle.vehicle;\n\t\tsuccession flow deliveryToOwnership from deliverVehicle.vehicle to transferOwnership.vehicle;\n\t\tsuccession flow ownershipToDriving from transferOwnership.vehicle to recordDrivingOperation.vehicle;\n\t\tsuccession flow ownershipToDrivingOwner from transferOwnership.owner to recordDrivingOperation.owner;\n\t\tsuccession flow drivingToScrap from recordDrivingOperation.vehicle to scrapVehicle.vehicle;\n\t}\n\n\tinterface vehicleToManager connect context.vehicleLifecycleManager.vehiclePort to context.vehicleLifecycleManager.vehiclePort {\n\t\tref flow references manageLifecycle.assemblyToDelivery\n\t\t\tfrom source.vehicle to target.vehicle;\n\t}\n}",
    "package 'Vehicle' {\n\n\t// Attribute definitions\n\tattribute def Mass;\n\tattribute def GearSetting;\n\tattribute def AcceleratorPedalPosition;\n\tattribute def OperationalStatus {\n\t\tgearSetting: GearSetting;\n\t\tacceleratorPedalPosition: AcceleratorPedalPosition;\n\t}\n\n\t// Part definitions\n\tpart def Engine;\n\tpart def Wheel {\n\t\tattribute mass: Mass;\n\t\tattribute status;\n\t}\n\tpart def Driver; // External reference\n\n\t// Vehicle part definition\n\tpart def Vehicle {\n\t\tattribute mass: Mass;\n\t\tattribute operationalStatus: OperationalStatus;\n\t\tpart engine: Engine;\n\t\tpart wheels: Wheel[*];\n\t\tref driver: Driver;\n\t}\n\n\t// Vehicle instance with specific wheels\n\tinstance vehicle_1: Vehicle {\n\t\tmass = 1500;\n\t\toperationalStatus = {\n\t\t\tgearSetting = 'P';\n\t\t\tacceleratorPedalPosition = 0;\n\t\t};\n\t\tengine: Engine;\n\t\twheels = [\n\t\t\tleftFront: Wheel { mass = 20; status = 'OK'; },\n\t\t\trightFront: Wheel { mass = 20; status = 'OK'; }\n\t\t];\n\t\tdriver: Driver;\n\t}\n\n\t// Snapshots for tracking component status over time\n\tsnapshot vehicle_1_time1 {\n\t\tinstance vehicle_1.wheels.leftFront {\n\t\t\tstatus = 'OK';\n\t\t}\n\t\tinstance vehicle_1.wheels.rightFront {\n\t\t\tstatus = 'OK';\n\t\t}\n\t}\n\n\tsnapshot vehicle_1_time2 {\n\t\tinstance vehicle_1.wheels.leftFront {\n\t\t\tstatus = 'NeedsMaintenance';\n\t\t}\n\t\tinstance vehicle_1.wheels.rightFront {\n\t\t\tstatus = 'OK';\n\t\t}\n\t}\n}",
    "package 'CompositeVehicleSystem' {\n\n\t// Attribute definitions\n\tattribute def Mass : Real;\n\tattribute def Gear : Integer;\n\tattribute def AcceleratorPosition : Real;\n\tattribute def State;\n\tattribute def Time : Real;\n\n\t// Port definitions\n\tport def StatePort {\n\t\tout state: State;\n\t}\n\tport def MassPort {\n\t\tout mass: Mass;\n\t}\n\n\t// Part definitions\n\tpart def Engine {\n\t\t// Engine-specific attributes can be added here\n\t}\n\tpart def Driver {\n\t\t// Driver-specific attributes can be added here\n\t}\n\tpart def Vehicle {\n\t\tattribute mass: Mass;\n\t\tattribute state: State;\n\t\tpart engine: Engine;\n\t\tpart driver: Driver;\n\t\tport statePort: StatePort;\n\t\tport massPort: MassPort;\n\t}\n\n\t// State structure\n\tstruct def VehicleState {\n\t\tattribute gear: Gear;\n\t\tattribute accelerator: AcceleratorPosition;\n\t}\n\n\t// System context\n\tpart context {\n\t\tpart vehicle_1: Vehicle {\n\t\t\tmass = 2000.0;\n\t\t\tstate = VehicleState { gear = 0, accelerator = 0.0; };\n\t\t}\n\t}\n\n\t// State evolution over time\n\ttemporal scenario VehicleStateEvolution {\n\t\tparticipant v1: Vehicle = context.vehicle_1;\n\n\t\t// Initial state at t0\n\t\tat t0: Time = 0.0 {\n\t\t\tv1.mass = 2000.0;\n\t\t\tv1.state = VehicleState { gear = 0, accelerator = 0.0; };\n\t\t}\n\t\t// Next state at t1\n\t\tat t1: Time = 1.0 {\n\t\t\tv1.mass = 1500.0;\n\t\t\tv1.state = VehicleState { gear = 2, accelerator = 0.5; };\n\t\t}\n\t}\n\n\t// Relationships among components\n\tassociation VehicleHasEngine {\n\t\tend vehicle: Vehicle;\n\t\tend engine: Engine;\n\t}\n\tassociation VehicleHasDriver {\n\t\tend vehicle: Vehicle;\n\t\tend driver: Driver;\n\t}\n\n}",
    "package 'VehicleSystem' {\n\n\t// Attribute definitions\n\tattribute def Mass : Real;\n\tattribute def GearPosition : String;\n\tattribute def ThrottlePosition : Real;\n\tattribute def TimeSlice : Integer;\n\n\t// Driver definition\n\tclass Driver {\n\t\tattribute name : String;\n\t}\n\n\t// Engine definition\n\tclass Engine {\n\t}\n\n\t// Vehicle definition\n\tclass Vehicle {\n\t\tattribute mass : Mass;\n\t\tattribute gear : GearPosition;\n\t\tattribute throttle : ThrottlePosition;\n\t\tpart engine : Engine;\n\t\treference driver : Driver;\n\t}\n\n\t// Driver instances\n\tinstance Alice : Driver {\n\t\tname = \"Alice\";\n\t}\n\tinstance Bob : Driver {\n\t\tname = \"Bob\";\n\t}\n\n\t// Engine instance\n\tinstance MainEngine : Engine {}\n\n\t// Vehicle instances for time slices\n\tinstance Vehicle_t0 : Vehicle {\n\t\tmass = 2000.0;\n\t\tgear = \"neutral\";\n\t\tthrottle = 0.0;\n\t\tengine = MainEngine;\n\t\tdriver = Alice;\n\t}\n\tinstance Vehicle_t1 : Vehicle {\n\t\tmass = 1500.0;\n\t\tgear = \"second\";\n\t\tthrottle = 0.5;\n\t\tengine = MainEngine;\n\t\tdriver = Bob;\n\t}\n\n\t// Time slice context\n\tclass VehicleStateAtTime {\n\t\tattribute timeSlice : TimeSlice;\n\t\treference vehicle : Vehicle;\n\t}\n\n\t// State instances\n\tinstance State0 : VehicleStateAtTime {\n\t\ttimeSlice = 0;\n\t\tvehicle = Vehicle_t0;\n\t}\n\tinstance State1 : VehicleStateAtTime {\n\t\ttimeSlice = 1;\n\t\tvehicle = Vehicle_t1;\n\t}\n\n\t// Sequence of states\n\tassociation VehicleStateSequence {\n\t\tordered reference states : VehicleStateAtTime[2];\n\t}\n\tinstance VehicleHistory : VehicleStateSequence {\n\t\tstates = [State0, State1];\n\t}\n}",
    "package 'VehicleMassAggregation' {\n\tattribute def Mass {\n\t\tvalue: Real;\n\t\tunit: 'kg';\n\t}\n\tattribute def ComponentID {\n\t\tvalue: String;\n\t}\n\tport def MassPort {\n\t\tout mass: Mass;\n\t}\n\tport def ComponentIDPort {\n\t\tout componentID: ComponentID;\n\t}\n\tpart def Component {\n\t\tattribute componentID: ComponentID;\n\t\tattribute selfMass: Mass;\n\t\tpart subcomponents: Component[*];\n\t\toperation def getTotalMass(): Mass {\n\t\t\treturn selfMass + sum(subcomponents.getTotalMass());\n\t\t}\n\t\tport massPort: MassPort;\n\t\tport componentIDPort: ComponentIDPort;\n\t\tperform massAggregation.provideMass {\n\t\t\tout mass = getTotalMass();\n\t\t\tout componentID = componentID;\n\t\t}\n\t}\n\tpart def Engine extends Component {\n\t\t// Additional engine-specific attributes can be added here\n\t}\n\tpart def Transmission extends Component {\n\t\t// Additional transmission-specific attributes can be added here\n\t}\n\tpart def Vehicle extends Component {\n\t\tpart engine: Engine;\n\t\tpart transmission: Transmission;\n\t\tpart otherComponents: Component[*];\n\t\t// Vehicle's subcomponents include engine, transmission, and otherComponents\n\t\tsubcomponents = [engine, transmission] + otherComponents;\n\t}\n\tpart context {\n\t\tpart user {\n\t\t\tperform massAggregation.requestTotalMass {\n\t\t\t\tin vehicle: Vehicle;\n\t\t\t\tout totalMass: Mass = vehicle.getTotalMass();\n\t\t\t}\n\t\t}\n\t\tpart vehicle: Vehicle;\n\t}\n\taction massAggregation {\n\t\taction provideMass {\n\t\t\tout mass: Mass;\n\t\t\tout componentID: ComponentID;\n\t\t}\n\t\taction requestTotalMass {\n\t\t\tin vehicle: Vehicle;\n\t\t\tout totalMass: Mass;\n\t\t}\n\t}\n}",
    "package 'VehicleMassManagement' {\n\n\tattribute def Mass : Real;\n\tattribute def SerialNumber : String;\n\tattribute def VIN : String;\n\tattribute def MassThreshold : Real;\n\n\tpart def Component {\n\t\tattribute serialNumber : SerialNumber;\n\t\tattribute mass : Mass;\n\t\tpart subcomponents : Component[*];\n\t}\n\n\tpart def Engine extends Component {\n\t\t// Additional engine-specific attributes can be added here\n\t}\n\n\tpart def Transmission extends Component {\n\t\t// Additional transmission-specific attributes can be added here\n\t}\n\n\tpart def Vehicle {\n\t\tattribute vin : VIN;\n\t\tattribute mass : Mass;\n\t\tpart engine : Engine;\n\t\tpart transmission : Transmission;\n\t\tpart components : Component[*];\n\t}\n\n\taction def CalculateTotalMass {\n\t\tin vehicle : Vehicle;\n\t\tin threshold : MassThreshold;\n\t\tout totalMass : Mass;\n\n\t\t// Pseudocode for mass calculation:\n\t\t// totalMass = vehicle.mass\n\t\t//   + sum of mass of engine and transmission if >= threshold\n\t\t//   + sum of mass of all components and their subcomponents recursively if >= threshold\n\t}\n\n\tinterface def UserInputPort {\n\t\tin massData : Mass;\n\t\tin serialNumber : SerialNumber;\n\t}\n\n\tpart context {\n\t\tpart user {\n\t\t\tport userInput : UserInputPort;\n\t\t\tperform MassEntry.enterMassData {\n\t\t\t\tin massData = userInput.massData;\n\t\t\t\tin serialNumber = userInput.serialNumber;\n\t\t\t}\n\t\t}\n\t\tpart vehicleSystem {\n\t\t\tport userInput : ~UserInputPort;\n\t\t\tperform MassEntry.receiveMassData {\n\t\t\t\tin massData = userInput.massData;\n\t\t\t\tin serialNumber = userInput.serialNumber;\n\t\t\t}\n\t\t\tperform MassEntry.calculateTotalMass {\n\t\t\t\tin vehicle : Vehicle;\n\t\t\t\tin threshold : MassThreshold;\n\t\t\t\tout totalMass : Mass;\n\t\t\t}\n\t\t}\n\t\tinterface userToSystem connect user.userInput to vehicleSystem.userInput {\n\t\t\tref flow references MassEntry.massDataFlow\n\t\t\t\tfrom source.massData to target.massData;\n\t\t\tref flow references MassEntry.serialNumberFlow\n\t\t\t\tfrom source.serialNumber to target.serialNumber;\n\t\t}\n\t}\n\n\taction def MassEntry {\n\t\taction enterMassData {\n\t\t\tout massData : Mass;\n\t\t\tout serialNumber : SerialNumber;\n\t\t}\n\t\tsuccession flow massDataFlow from enterMassData.massData to receiveMassData.massData;\n\t\tsuccession flow serialNumberFlow from enterMassData.serialNumber to receiveMassData.serialNumber;\n\t\taction receiveMassData {\n\t\t\tin massData : Mass;\n\t\t\tin serialNumber : SerialNumber;\n\t\t}\n\t\taction calculateTotalMass {\n\t\t\tin vehicle : Vehicle;\n\t\t\tin threshold : MassThreshold;\n\t\t\tout totalMass : Mass;\n\t\t}\n\t}\n}",
    "package 'MassAggregationSystem' {\n\tattribute def simpleMass : Real;\n\tattribute def totalMass : Real;\n\n\tpart def simpleThing {\n\t\tattribute simpleMass : Real;\n\t\tattribute totalMass : Real;\n\t\tconstraint eq_totalMass_simple {\n\t\t\ttotalMass = simpleMass;\n\t\t}\n\t}\n\n\tpart def compositeThing {\n\t\tattribute simpleMass : Real;\n\t\tattribute totalMass : Real;\n\t\tpart subcomponents : massObject[*];\n\t\tconstraint eq_totalMass_composite {\n\t\t\ttotalMass = simpleMass + sum(subcomponents.totalMass);\n\t\t}\n\t}\n\n\tpart def massObject {\n\t\tattribute simpleMass : Real;\n\t\tattribute totalMass : Real;\n\t}\n\n\t// Specializations\n\tpart simpleThing specializes massObject;\n\tpart compositeThing specializes massObject;\n\n\tpart context {\n\t\tpart managedObject : massObject;\n\t\tperform massAggregation.aggregateMass {\n\t\t\tin simpleMass = managedObject.simpleMass;\n\t\t\tin totalMass = managedObject.totalMass;\n\t\t}\n\t}\n\t\n\taction massAggregation {\n\t\taction aggregateMass {\n\t\t\tin simpleMass : Real;\n\t\t\tin totalMass : Real;\n\t\t}\n\t}\n}",
    "package 'MassAggregationSystem' {\n\tattribute def Mass : Real;\n\tattribute def MinMassThreshold : Real;\n\n\tpart def Component {\n\t\tattribute basicMass : Mass;\n\t\tpart subcomponents : Component[*];\n\t\toperation totalMass() : Mass {\n\t\t\tbody: result = basicMass + sum(subcomponents.totalMass());\n\t\t}\n\t\toperation filteredTotalMass(minThreshold: MinMassThreshold) : Mass {\n\t\t\tbody: result = basicMass + sum(subcomponents->select(c | c.totalMass() >= minThreshold).totalMass());\n\t\t}\n\t}\n\n\tpart context {\n\t\tpart rootComponent : Component;\n\t}\n\n\taction MassAggregation {\n\t\taction calculateTotalMass {\n\t\t\tin component : Component;\n\t\t\tout totalMass : Mass;\n\t\t\tperform {\n\t\t\t\ttotalMass = component.totalMass();\n\t\t\t}\n\t\t}\n\t\taction calculateFilteredTotalMass {\n\t\t\tin component : Component;\n\t\t\tin minThreshold : MinMassThreshold;\n\t\t\tout filteredMass : Mass;\n\t\t\tperform {\n\t\t\t\tfilteredMass = component.filteredTotalMass(minThreshold);\n\t\t\t}\n\t\t}\n\t}\n}",
    "package 'VehicleDynamics' {\n\tattribute def WheelPower;\n\tattribute def AeroDragCoeff;\n\tattribute def FrictionCoeff;\n\tattribute def VehicleMass;\n\tattribute def Speed;\n\tattribute def PowerOutput;\n\tattribute def Acceleration;\n\tattribute def Position;\n\tattribute def Time;\n\tattribute def EffectivePower;\n\t\n\tport def InputParamPort {\n\t\tin wheelPower: WheelPower;\n\t\tin aeroDragCoeff: AeroDragCoeff;\n\t\tin frictionCoeff: FrictionCoeff;\n\t\tin vehicleMass: VehicleMass;\n\t\tin speed: Speed;\n\t}\n\tport def OutputParamPort {\n\t\tout powerOutput: PowerOutput;\n\t\tout acceleration: Acceleration;\n\t\tout speed: Speed;\n\t\tout position: Position;\n\t}\n\t\n\tpart context {\n\t\tpart user {\n\t\t\tport inputParamPort: InputParamPort;\n\t\t\tport outputParamPort: ~OutputParamPort;\n\t\t\tperform analyzeDynamics.provideInputParams {\n\t\t\t\tout wheelPower = inputParamPort.wheelPower;\n\t\t\t\tout aeroDragCoeff = inputParamPort.aeroDragCoeff;\n\t\t\t\tout frictionCoeff = inputParamPort.frictionCoeff;\n\t\t\t\tout vehicleMass = inputParamPort.vehicleMass;\n\t\t\t\tout speed = inputParamPort.speed;\n\t\t\t}\n\t\t}\n\t\tinterface userToSystem connect user.inputParamPort to vehicleDynamics.inputParamPort {\n\t\t\tref flow references analyzeDynamics.inputParamFlow\n\t\t\t\tfrom source.wheelPower to target.wheelPower,\n\t\t\t\tfrom source.aeroDragCoeff to target.aeroDragCoeff,\n\t\t\t\tfrom source.frictionCoeff to target.frictionCoeff,\n\t\t\t\tfrom source.vehicleMass to target.vehicleMass,\n\t\t\t\tfrom source.speed to target.speed;\n\t\t}\n\t\tpart vehicleDynamics {\n\t\t\tport inputParamPort: ~InputParamPort;\n\t\t\tport outputParamPort: OutputParamPort;\n\t\t\tperform analyzeDynamics.calculatePowerOutput {\n\t\t\t\tin wheelPower = inputParamPort.wheelPower;\n\t\t\t\tin aeroDragCoeff = inputParamPort.aeroDragCoeff;\n\t\t\t\tin frictionCoeff = inputParamPort.frictionCoeff;\n\t\t\t\tin vehicleMass = inputParamPort.vehicleMass;\n\t\t\t\tin speed = inputParamPort.speed;\n\t\t\t\tout powerOutput = outputParamPort.powerOutput;\n\t\t\t}\n\t\t\tperform analyzeDynamics.calculateAcceleration {\n\t\t\t\tin effectivePower;\n\t\t\t\tin vehicleMass;\n\t\t\t\tin speed;\n\t\t\t\tout acceleration = outputParamPort.acceleration;\n\t\t\t}\n\t\t\tperform analyzeDynamics.calculateSpeed {\n\t\t\t\tin acceleration;\n\t\t\t\tin initialSpeed: Speed;\n\t\t\t\tin time: Time;\n\t\t\t\tout speed = outputParamPort.speed;\n\t\t\t}\n\t\t\tperform analyzeDynamics.calculatePosition {\n\t\t\t\tin speed;\n\t\t\t\tin time;\n\t\t\t\tout position = outputParamPort.position;\n\t\t\t}\n\t\t}\n\t}\n\t\n\taction analyzeDynamics {\n\t\taction provideInputParams {\n\t\t\tout wheelPower: WheelPower;\n\t\t\tout aeroDragCoeff: AeroDragCoeff;\n\t\t\tout frictionCoeff: FrictionCoeff;\n\t\t\tout vehicleMass: VehicleMass;\n\t\t\tout speed: Speed;\n\t\t}\n\t\tsuccession flow inputParamFlow from provideInputParams.wheelPower to calculatePowerOutput.wheelPower,\n\t\t\tfrom provideInputParams.aeroDragCoeff to calculatePowerOutput.aeroDragCoeff,\n\t\t\tfrom provideInputParams.frictionCoeff to calculatePowerOutput.frictionCoeff,\n\t\t\tfrom provideInputParams.vehicleMass to calculatePowerOutput.vehicleMass,\n\t\t\tfrom provideInputParams.speed to calculatePowerOutput.speed;\n\t\t\n\t\taction calculatePowerOutput {\n\t\t\tin wheelPower: WheelPower;\n\t\t\tin aeroDragCoeff: AeroDragCoeff;\n\t\t\tin frictionCoeff: FrictionCoeff;\n\t\t\tin vehicleMass: VehicleMass;\n\t\t\tin speed: Speed;\n\t\t\tout powerOutput: PowerOutput;\n\t\t\tout effectivePower: EffectivePower;\n\t\t}\n\t\tsuccession flow powerOutputFlow from calculatePowerOutput.powerOutput to calculateAcceleration.effectivePower;\n\t\t\n\t\taction calculateAcceleration {\n\t\t\tin effectivePower: EffectivePower;\n\t\t\tin vehicleMass: VehicleMass;\n\t\t\tin speed: Speed;\n\t\t\tout acceleration: Acceleration;\n\t\t}\n\t\tsuccession flow accelerationFlow from calculateAcceleration.acceleration to calculateSpeed.acceleration;\n\t\t\n\t\taction calculateSpeed {\n\t\t\tin acceleration: Acceleration;\n\t\t\tin initialSpeed: Speed;\n\t\t\tin time: Time;\n\t\t\tout speed: Speed;\n\t\t}\n\t\tsuccession flow speedFlow from calculateSpeed.speed to calculatePosition.speed;\n\t\t\n\t\taction calculatePosition {\n\t\t\tin speed: Speed;\n\t\t\tin time: Time;\n\t\t\tout position: Position;\n\t\t}\n\t}\n}",
    "package 'VehicleDynamicsSimulation' {\n\tattribute def InitialSpeed;\n\tattribute def InitialPosition;\n\tattribute def TimeStep;\n\tattribute def VehicleMass;\n\tattribute def WheelEndPower;\n\tattribute def AeroDragCoeff;\n\tattribute def RollingResistCoeff;\n\tattribute def Acceleration;\n\tattribute def Speed;\n\tattribute def Position;\n\tattribute def DrivingPower;\n\t\n\tport def UserInputPort {\n\t\tin initialSpeed: InitialSpeed;\n\t\tin initialPosition: InitialPosition;\n\t\tin timeStep: TimeStep;\n\t\tin vehicleMass: VehicleMass;\n\t\tin aeroDragCoeff: AeroDragCoeff;\n\t\tin rollingResistCoeff: RollingResistCoeff;\n\t\tin wheelEndPower: WheelEndPower;\n\t}\n\t\n\tport def SimulationOutputPort {\n\t\tout acceleration: Acceleration;\n\t\tout speed: Speed;\n\t\tout position: Position;\n\t}\n\t\n\tpart context {\n\t\tpart user {\n\t\t\tport userInputPort: UserInputPort;\n\t\t\tperform simulateStraightLineDriving.setParameters {\n\t\t\t\tout initialSpeed = userInputPort.initialSpeed;\n\t\t\t\tout initialPosition = userInputPort.initialPosition;\n\t\t\t\tout timeStep = userInputPort.timeStep;\n\t\t\t\tout vehicleMass = userInputPort.vehicleMass;\n\t\t\t\tout aeroDragCoeff = userInputPort.aeroDragCoeff;\n\t\t\t\tout rollingResistCoeff = userInputPort.rollingResistCoeff;\n\t\t\t\tout wheelEndPower = userInputPort.wheelEndPower;\n\t\t\t}\n\t\t}\n\t\tpart simulationEngine {\n\t\t\tport userInputPort: ~UserInputPort;\n\t\t\tport simulationOutputPort: SimulationOutputPort;\n\t\t\tperform simulateStraightLineDriving.computeDynamics {\n\t\t\t\tin initialSpeed = userInputPort.initialSpeed;\n\t\t\t\tin initialPosition = userInputPort.initialPosition;\n\t\t\t\tin timeStep = userInputPort.timeStep;\n\t\t\t\tin vehicleMass = userInputPort.vehicleMass;\n\t\t\t\tin aeroDragCoeff = userInputPort.aeroDragCoeff;\n\t\t\t\tin rollingResistCoeff = userInputPort.rollingResistCoeff;\n\t\t\t\tin wheelEndPower = userInputPort.wheelEndPower;\n\t\t\t\tout acceleration = simulationOutputPort.acceleration;\n\t\t\t\tout speed = simulationOutputPort.speed;\n\t\t\t\tout position = simulationOutputPort.position;\n\t\t\t}\n\t\t}\n\t\tinterface userToEngine connect user.userInputPort to simulationEngine.userInputPort {\n\t\t\tref flow references simulateStraightLineDriving.parameterFlow\n\t\t\t\tfrom source.initialSpeed to target.initialSpeed,\n\t\t\t\tfrom source.initialPosition to target.initialPosition,\n\t\t\t\tfrom source.timeStep to target.timeStep,\n\t\t\t\tfrom source.vehicleMass to target.vehicleMass,\n\t\t\t\tfrom source.aeroDragCoeff to target.aeroDragCoeff,\n\t\t\t\tfrom source.rollingResistCoeff to target.rollingResistCoeff,\n\t\t\t\tfrom source.wheelEndPower to target.wheelEndPower;\n\t\t}\n\t}\n\t\n\taction simulateStraightLineDriving {\n\t\taction setParameters {\n\t\t\tout initialSpeed: InitialSpeed;\n\t\t\tout initialPosition: InitialPosition;\n\t\t\tout timeStep: TimeStep;\n\t\t\tout vehicleMass: VehicleMass;\n\t\t\tout aeroDragCoeff: AeroDragCoeff;\n\t\t\tout rollingResistCoeff: RollingResistCoeff;\n\t\t\tout wheelEndPower: WheelEndPower;\n\t\t}\n\t\tsuccession flow parameterFlow from setParameters.initialSpeed to computeDynamics.initialSpeed,\n\t\t\tfrom setParameters.initialPosition to computeDynamics.initialPosition,\n\t\t\tfrom setParameters.timeStep to computeDynamics.timeStep,\n\t\t\tfrom setParameters.vehicleMass to computeDynamics.vehicleMass,\n\t\t\tfrom setParameters.aeroDragCoeff to computeDynamics.aeroDragCoeff,\n\t\t\tfrom setParameters.rollingResistCoeff to computeDynamics.rollingResistCoeff,\n\t\t\tfrom setParameters.wheelEndPower to computeDynamics.wheelEndPower;\n\t\taction computeDynamics {\n\t\t\tin initialSpeed: InitialSpeed;\n\t\t\tin initialPosition: InitialPosition;\n\t\t\tin timeStep: TimeStep;\n\t\t\tin vehicleMass: VehicleMass;\n\t\t\tin aeroDragCoeff: AeroDragCoeff;\n\t\t\tin rollingResistCoeff: RollingResistCoeff;\n\t\t\tin wheelEndPower: WheelEndPower;\n\t\t\tout acceleration: Acceleration;\n\t\t\tout speed: Speed;\n\t\t\tout position: Position;\n\t\t\tout drivingPower: DrivingPower;\n\t\t}\n\t}\n}",
    "package 'VehicleDynamicsSimulation' {\n\tattribute def VehicleMass;\n\tattribute def WheelPower;\n\tattribute def AeroDragCoeff;\n\tattribute def RollingResistCoeff;\n\tattribute def Speed;\n\tattribute def Position;\n\tattribute def Acceleration;\n\tattribute def TimeStep;\n\tattribute def AirResistance;\n\tattribute def FrictionResistance;\n\tattribute def Displacement;\n\tattribute def DynamicState;\n\n\tport def UserInputPort {\n\t\tin vehicleMass: VehicleMass;\n\t\tin wheelPower: WheelPower;\n\t\tin aeroDragCoeff: AeroDragCoeff;\n\t\tin rollingResistCoeff: RollingResistCoeff;\n\t\tin initialSpeed: Speed;\n\t\tin initialPosition: Position;\n\t}\n\n\tport def StateOutputPort {\n\t\tout speed: Speed;\n\t\tout position: Position;\n\t\tout acceleration: Acceleration;\n\t\tout displacement: Displacement;\n\t\tout dynamicState: DynamicState;\n\t}\n\n\tpart context {\n\t\tpart user {\n\t\t\tport userInputPort: UserInputPort;\n\t\t\tperform simulateDynamics.provideInput {\n\t\t\t\tout vehicleMass = userInputPort.vehicleMass;\n\t\t\t\tout wheelPower = userInputPort.wheelPower;\n\t\t\t\tout aeroDragCoeff = userInputPort.aeroDragCoeff;\n\t\t\t\tout rollingResistCoeff = userInputPort.rollingResistCoeff;\n\t\t\t\tout initialSpeed = userInputPort.initialSpeed;\n\t\t\t\tout initialPosition = userInputPort.initialPosition;\n\t\t\t}\n\t\t}\n\t\tinterface userToSimulation connect user.userInputPort to simulation.userInputPort {\n\t\t\tref flow references simulateDynamics.inputFlow\n\t\t\t\tfrom source.vehicleMass to target.vehicleMass,\n\t\t\t\tfrom source.wheelPower to target.wheelPower,\n\t\t\t\tfrom source.aeroDragCoeff to target.aeroDragCoeff,\n\t\t\t\tfrom source.rollingResistCoeff to target.rollingResistCoeff,\n\t\t\t\tfrom source.initialSpeed to target.initialSpeed,\n\t\t\t\tfrom source.initialPosition to target.initialPosition;\n\t\t}\n\t\tpart simulation {\n\t\t\tport userInputPort: ~UserInputPort;\n\t\t\tport stateOutputPort: StateOutputPort;\n\t\t\tperform simulateDynamics.computeDynamics {\n\t\t\t\tin vehicleMass = userInputPort.vehicleMass;\n\t\t\t\tin wheelPower = userInputPort.wheelPower;\n\t\t\t\tin aeroDragCoeff = userInputPort.aeroDragCoeff;\n\t\t\t\tin rollingResistCoeff = userInputPort.rollingResistCoeff;\n\t\t\t\tin speed = userInputPort.initialSpeed;\n\t\t\t\tin position = userInputPort.initialPosition;\n\t\t\t\tout speed = stateOutputPort.speed;\n\t\t\t\tout position = stateOutputPort.position;\n\t\t\t\tout acceleration = stateOutputPort.acceleration;\n\t\t\t\tout displacement = stateOutputPort.displacement;\n\t\t\t\tout dynamicState = stateOutputPort.dynamicState;\n\t\t\t}\n\t\t}\n\t}\n\n\taction simulateDynamics {\n\t\taction provideInput {\n\t\t\tout vehicleMass: VehicleMass;\n\t\t\tout wheelPower: WheelPower;\n\t\t\tout aeroDragCoeff: AeroDragCoeff;\n\t\t\tout rollingResistCoeff: RollingResistCoeff;\n\t\t\tout initialSpeed: Speed;\n\t\t\tout initialPosition: Position;\n\t\t}\n\t\tsuccession flow inputFlow from provideInput.vehicleMass to computeDynamics.vehicleMass,\n\t\t\tfrom provideInput.wheelPower to computeDynamics.wheelPower,\n\t\t\tfrom provideInput.aeroDragCoeff to computeDynamics.aeroDragCoeff,\n\t\t\tfrom provideInput.rollingResistCoeff to computeDynamics.rollingResistCoeff,\n\t\t\tfrom provideInput.initialSpeed to computeDynamics.speed,\n\t\t\tfrom provideInput.initialPosition to computeDynamics.position;\n\t\taction computeDynamics {\n\t\t\tin vehicleMass: VehicleMass;\n\t\t\tin wheelPower: WheelPower;\n\t\t\tin aeroDragCoeff: AeroDragCoeff;\n\t\t\tin rollingResistCoeff: RollingResistCoeff;\n\t\t\tin speed: Speed;\n\t\t\tin position: Position;\n\t\t\tout speed: Speed;\n\t\t\tout position: Position;\n\t\t\tout acceleration: Acceleration;\n\t\t\tout displacement: Displacement;\n\t\t\tout dynamicState: DynamicState;\n\t\t}\n\t}\n}",
    "package 'VehicleLongitudinalDynamics' {\n\tattribute def Position;\n\tattribute def Velocity;\n\tattribute def Acceleration;\n\tattribute def Mass;\n\tattribute def Power;\n\tattribute def TimeInterval;\n\tattribute def DragCoefficient;\n\tattribute def FrictionCoefficient;\n\tattribute def AirDensity;\n\tattribute def FrontalArea;\n\tattribute def RollingResistance;\n\tattribute def FinalPosition;\n\tattribute def FinalVelocity;\n\n\tport def InputPort {\n\t\tin initialPosition: Position;\n\t\tin initialVelocity: Velocity;\n\t\tin mass: Mass;\n\t\tin drivePower: Power;\n\t\tin timeInterval: TimeInterval;\n\t\tin dragCoefficient: DragCoefficient;\n\t\tin frictionCoefficient: FrictionCoefficient;\n\t\tin airDensity: AirDensity;\n\t\tin frontalArea: FrontalArea;\n\t\tin rollingResistance: RollingResistance;\n\t}\n\n\tport def OutputPort {\n\t\tout acceleration: Acceleration;\n\t\tout finalVelocity: FinalVelocity;\n\t\tout finalPosition: FinalPosition;\n\t}\n\n\tpart context {\n\t\tpart user {\n\t\t\tport inputPort: InputPort;\n\t\t\tperform simulateLongitudinalMotion.provideInputs {\n\t\t\t\tout initialPosition = inputPort.initialPosition;\n\t\t\t\tout initialVelocity = inputPort.initialVelocity;\n\t\t\t\tout mass = inputPort.mass;\n\t\t\t\tout drivePower = inputPort.drivePower;\n\t\t\t\tout timeInterval = inputPort.timeInterval;\n\t\t\t\tout dragCoefficient = inputPort.dragCoefficient;\n\t\t\t\tout frictionCoefficient = inputPort.frictionCoefficient;\n\t\t\t\tout airDensity = inputPort.airDensity;\n\t\t\t\tout frontalArea = inputPort.frontalArea;\n\t\t\t\tout rollingResistance = inputPort.rollingResistance;\n\t\t\t}\n\t\t}\n\t\tinterface userToSystem connect user.inputPort to vehicleSystem.inputPort {\n\t\t\tref flow references simulateLongitudinalMotion.inputFlow\n\t\t\t\tfrom source to target;\n\t\t}\n\t\tpart vehicleSystem {\n\t\t\tport inputPort: ~InputPort;\n\t\t\tport outputPort: OutputPort;\n\t\t\tperform simulateLongitudinalMotion.computeDynamics {\n\t\t\t\tin initialPosition = inputPort.initialPosition;\n\t\t\t\tin initialVelocity = inputPort.initialVelocity;\n\t\t\t\tin mass = inputPort.mass;\n\t\t\t\tin drivePower = inputPort.drivePower;\n\t\t\t\tin timeInterval = inputPort.timeInterval;\n\t\t\t\tin dragCoefficient = inputPort.dragCoefficient;\n\t\t\t\tin frictionCoefficient = inputPort.frictionCoefficient;\n\t\t\t\tin airDensity = inputPort.airDensity;\n\t\t\t\tin frontalArea = inputPort.frontalArea;\n\t\t\t\tin rollingResistance = inputPort.rollingResistance;\n\t\t\t\tout acceleration = outputPort.acceleration;\n\t\t\t\tout finalVelocity = outputPort.finalVelocity;\n\t\t\t\tout finalPosition = outputPort.finalPosition;\n\t\t\t}\n\t\t}\n\t}\n\n\taction simulateLongitudinalMotion {\n\t\taction provideInputs {\n\t\t\tout initialPosition: Position;\n\t\t\tout initialVelocity: Velocity;\n\t\t\tout mass: Mass;\n\t\t\tout drivePower: Power;\n\t\t\tout timeInterval: TimeInterval;\n\t\t\tout dragCoefficient: DragCoefficient;\n\t\t\tout frictionCoefficient: FrictionCoefficient;\n\t\t\tout airDensity: AirDensity;\n\t\t\tout frontalArea: FrontalArea;\n\t\t\tout rollingResistance: RollingResistance;\n\t\t}\n\t\tsuccession flow inputFlow from provideInputs to computeDynamics;\n\t\taction computeDynamics {\n\t\t\tin initialPosition: Position;\n\t\t\tin initialVelocity: Velocity;\n\t\t\tin mass: Mass;\n\t\t\tin drivePower: Power;\n\t\t\tin timeInterval: TimeInterval;\n\t\t\tin dragCoefficient: DragCoefficient;\n\t\t\tin frictionCoefficient: FrictionCoefficient;\n\t\t\tin airDensity: AirDensity;\n\t\t\tin frontalArea: FrontalArea;\n\t\t\tin rollingResistance: RollingResistance;\n\t\t\tout acceleration: Acceleration;\n\t\t\tout finalVelocity: FinalVelocity;\n\t\t\tout finalPosition: FinalPosition;\n\t\t\tconstraint {\n\t\t\t\t// Calculate resistive forces\n\t\t\t\tairResistance = 0.5 * airDensity * dragCoefficient * frontalArea * initialVelocity^2;\n\t\t\t\trollingForce = mass * 9.81 * rollingResistance;\n\t\t\t\tfrictionForce = mass * 9.81 * frictionCoefficient;\n\t\t\t\ttotalResistance = airResistance + rollingForce + frictionForce;\n\n\t\t\t\t// Calculate tractive force from power\n\t\t\t\ttractiveForce = drivePower / max(initialVelocity, 0.1); // avoid div by zero\n\n\t\t\t\t// Net force and acceleration\n\t\t\t\tnetForce = tractiveForce - totalResistance;\n\t\t\t\tacceleration = netForce / mass;\n\n\t\t\t\t// Final velocity and position (assuming constant acceleration)\n\t\t\t\tfinalVelocity = initialVelocity + acceleration * timeInterval;\n\t\t\t\tfinalPosition = initialPosition + initialVelocity * timeInterval + 0.5 * acceleration * timeInterval^2;\n\t\t\t}\n\t\t}\n\t}\n}",
    "package 'VehicleMassManagement' {\n\tattribute def Mass;\n\tattribute def MassLimit;\n\tattribute def OverweightWarning;\n\n\tpart context {\n\t\tpart vehicle {\n\t\t\tpart chassis {\n\t\t\t\tattribute mass: Mass;\n\t\t\t}\n\t\t\tpart engine {\n\t\t\t\tattribute mass: Mass;\n\t\t\t}\n\t\t\tpart gearbox {\n\t\t\t\tattribute mass: Mass;\n\t\t\t}\n\t\t\tattribute totalMass: Mass;\n\t\t\tattribute massLimit: MassLimit = 2500;\n\t\t\tattribute overweightWarning: OverweightWarning;\n\n\t\t\tperform massManagement.calculateTotalMass {\n\t\t\t\tin chassisMass = chassis.mass;\n\t\t\t\tin engineMass = engine.mass;\n\t\t\t\tin gearboxMass = gearbox.mass;\n\t\t\t\tout totalMass = totalMass;\n\t\t\t}\n\t\t\tperform massManagement.checkMassLimit {\n\t\t\t\tin totalMass = totalMass;\n\t\t\t\tin massLimit = massLimit;\n\t\t\t\tout overweightWarning = overweightWarning;\n\t\t\t}\n\t\t}\n\t}\n\n\taction massManagement {\n\t\taction calculateTotalMass {\n\t\t\tin chassisMass: Mass;\n\t\t\tin engineMass: Mass;\n\t\t\tin gearboxMass: Mass;\n\t\t\tout totalMass: Mass;\n\t\t}\n\t\tsuccession flow totalMassFlow from calculateTotalMass.totalMass to checkMassLimit.totalMass;\n\n\t\taction checkMassLimit {\n\t\t\tin totalMass: Mass;\n\t\t\tin massLimit: MassLimit;\n\t\t\tout overweightWarning: OverweightWarning;\n\t\t}\n\t}\n}",
    "package 'VehicleMassBudget' {\n\tattribute def Mass {\n\t\tunit: 'kg';\n\t}\n\tattribute def MassLimit {\n\t\tunit: 'kg';\n\t}\n\tattribute def MassSum {\n\t\tunit: 'kg';\n\t}\n\tport def MassInputPort {\n\t\tin mass: Mass;\n\t}\n\tport def MassOutputPort {\n\t\tout massSum: MassSum;\n\t}\n\tpart context {\n\t\tpart vehicle {\n\t\t\tport chassisMassPort: MassInputPort;\n\t\t\tport engineMassPort: MassInputPort;\n\t\t\tport transmissionMassPort: MassInputPort;\n\t\t\tport otherMassPorts: MassInputPort[];\n\t\t\tport massSumPort: MassOutputPort;\n\t\t\tperform massBudgeting.aggregateMasses {\n\t\t\t\tin chassisMass = chassisMassPort.mass;\n\t\t\t\tin engineMass = engineMassPort.mass;\n\t\t\t\tin transmissionMass = transmissionMassPort.mass;\n\t\t\t\tin otherMasses = otherMassPorts.mass;\n\t\t\t\tout massSum = massSumPort.massSum;\n\t\t\t}\n\t\t}\n\t}\n\taction massBudgeting {\n\t\taction aggregateMasses {\n\t\t\tin chassisMass: Mass;\n\t\t\tin engineMass: Mass;\n\t\t\tin transmissionMass: Mass;\n\t\t\tin otherMasses: Mass[];\n\t\t\tout massSum: MassSum;\n\t\t\tconst massLimit: MassLimit = 2500 'kg';\n\t\t\tmassSum = chassisMass + engineMass + transmissionMass + sum(otherMasses);\n\t\t\trequirement massLimitConstraint {\n\t\t\t\tassert massSum <= massLimit;\n\t\t\t}\n\t\t\trequirement engineMassRecorded {\n\t\t\t\tassert engineMass >= 0 'kg';\n\t\t\t}\n\t\t\trequirement transmissionMassRecorded {\n\t\t\t\tassert transmissionMass >= 0 'kg';\n\t\t\t}\n\t\t}\n\t}\n\trequirement totalMassConstraint {\n\t\ttext \"The total mass of the complete vehicle, including chassis, engine, transmission, and all other components, shall not exceed 2,500 kilograms.\";\n\t}\n\trequirement componentMassEntry {\n\t\ttext \"The actual mass of each component shall be entered and measured in kilograms (kg).\";\n\t}\n\trequirement engineTransmissionManagement {\n\t\ttext \"The masses of the engine and transmission shall be separately recorded and managed as critical components.\";\n\t}\n\trequirement curbWeightControl {\n\t\ttext \"During preliminary design, vehicle curb weight shall be controlled by these mass constraints to support performance and energy optimization.\";\n\t}\n}",
    "package 'VehicleMassCompliance' {\n\tattribute def Mass : Real;\n\tattribute def MassLimit : Real = 2500.0;\n\t\n\tport def MassPort {\n\t\tout mass: Mass;\n\t}\n\t\n\tpart context {\n\t\tpart chassis {\n\t\t\tport massPort: MassPort;\n\t\t\tperform massAcquisition.sendChassisMass {\n\t\t\t\tout mass = massPort.mass;\n\t\t\t}\n\t\t}\n\t\tpart engine {\n\t\t\tport massPort: MassPort;\n\t\t\tperform massAcquisition.sendEngineMass {\n\t\t\t\tout mass = massPort.mass;\n\t\t\t}\n\t\t}\n\t\tpart transmission {\n\t\t\tport massPort: MassPort;\n\t\t\tperform massAcquisition.sendTransmissionMass {\n\t\t\t\tout mass = massPort.mass;\n\t\t\t}\n\t\t}\n\t\tpart vehicleMassComplianceSystem {\n\t\t\tport chassisMassPort: ~MassPort;\n\t\t\tport engineMassPort: ~MassPort;\n\t\t\tport transmissionMassPort: ~MassPort;\n\t\t\tperform massAcquisition.verifyTotalMass {\n\t\t\t\tin chassisMass = chassisMassPort.mass;\n\t\t\t\tin engineMass = engineMassPort.mass;\n\t\t\t\tin transmissionMass = transmissionMassPort.mass;\n\t\t\t\tout isCompliant: Boolean;\n\t\t\t}\n\t\t}\n\t\tinterface chassisToSystem connect chassis.massPort to vehicleMassComplianceSystem.chassisMassPort {\n\t\t\tref flow references massAcquisition.chassisMassFlow\n\t\t\t\tfrom source.mass to target.chassisMass;\n\t\t}\n\t\tinterface engineToSystem connect engine.massPort to vehicleMassComplianceSystem.engineMassPort {\n\t\t\tref flow references massAcquisition.engineMassFlow\n\t\t\t\tfrom source.mass to target.engineMass;\n\t\t}\n\t\tinterface transmissionToSystem connect transmission.massPort to vehicleMassComplianceSystem.transmissionMassPort {\n\t\t\tref flow references massAcquisition.transmissionMassFlow\n\t\t\t\tfrom source.mass to target.transmissionMass;\n\t\t}\n\t}\n\t\n\taction massAcquisition {\n\t\taction sendChassisMass { out mass: Mass; }\n\t\taction sendEngineMass { out mass: Mass; }\n\t\taction sendTransmissionMass { out mass: Mass; }\n\t\t\n\t\tsuccession flow chassisMassFlow from sendChassisMass.mass to verifyTotalMass.chassisMass;\n\t\tsuccession flow engineMassFlow from sendEngineMass.mass to verifyTotalMass.engineMass;\n\t\tsuccession flow transmissionMassFlow from sendTransmissionMass.mass to verifyTotalMass.transmissionMass;\n\t\t\n\t\taction verifyTotalMass {\n\t\t\tin chassisMass: Mass;\n\t\t\tin engineMass: Mass;\n\t\t\tin transmissionMass: Mass;\n\t\t\tout isCompliant: Boolean;\n\t\t\tconstraint def totalMassConstraint {\n\t\t\t\t(chassisMass + engineMass + transmissionMass) <= MassLimit\n\t\t\t}\n\t\t\tisCompliant = totalMassConstraint;\n\t\t}\n\t}\n}",
    "package 'VehicleWeightManagement' {\n\tattribute def Weight;\n\tattribute def WeightLimit {\n\t\tvalue: 2500;\n\t\tunit: 'kg';\n\t}\n\tattribute def Warning;\n\tattribute def Restriction;\n\n\tport def WeightPort {\n\t\tout weight: Weight;\n\t}\n\tport def WarningPort {\n\t\tout warning: Warning;\n\t}\n\tport def RestrictionPort {\n\t\tout restriction: Restriction;\n\t}\n\n\tpart context {\n\t\tpart chassis {\n\t\t\tport weightPort: WeightPort;\n\t\t\tperform manageWeight.provideChassisWeight {\n\t\t\t\tout weight = weightPort.weight;\n\t\t\t}\n\t\t}\n\t\tpart engine {\n\t\t\tport weightPort: WeightPort;\n\t\t\tperform manageWeight.provideEngineWeight {\n\t\t\t\tout weight = weightPort.weight;\n\t\t\t}\n\t\t}\n\t\tpart transmission {\n\t\t\tport weightPort: WeightPort;\n\t\t\tperform manageWeight.provideTransmissionWeight {\n\t\t\t\tout weight = weightPort.weight;\n\t\t\t}\n\t\t}\n\t\tpart weightManager {\n\t\t\tport chassisWeightPort: ~WeightPort;\n\t\t\tport engineWeightPort: ~WeightPort;\n\t\t\tport transmissionWeightPort: ~WeightPort;\n\t\t\tport warningPort: WarningPort;\n\t\t\tport restrictionPort: RestrictionPort;\n\t\t\tperform manageWeight.sumAndCheckWeight {\n\t\t\t\tin chassisWeight = chassisWeightPort.weight;\n\t\t\t\tin engineWeight = engineWeightPort.weight;\n\t\t\t\tin transmissionWeight = transmissionWeightPort.weight;\n\t\t\t\tout warning = warningPort.warning;\n\t\t\t\tout restriction = restrictionPort.restriction;\n\t\t\t}\n\t\t}\n\t\tinterface chassisToManager connect chassis.weightPort to weightManager.chassisWeightPort {\n\t\t\tref flow references manageWeight.chassisWeightFlow\n\t\t\t\tfrom source.weight to target.chassisWeight;\n\t\t}\n\t\tinterface engineToManager connect engine.weightPort to weightManager.engineWeightPort {\n\t\t\tref flow references manageWeight.engineWeightFlow\n\t\t\t\tfrom source.weight to target.engineWeight;\n\t\t}\n\t\tinterface transmissionToManager connect transmission.weightPort to weightManager.transmissionWeightPort {\n\t\t\tref flow references manageWeight.transmissionWeightFlow\n\t\t\t\tfrom source.weight to target.transmissionWeight;\n\t\t}\n\t}\n\n\taction manageWeight {\n\t\taction provideChassisWeight { out weight: Weight; }\n\t\taction provideEngineWeight { out weight: Weight; }\n\t\taction provideTransmissionWeight { out weight: Weight; }\n\t\tsuccession flow chassisWeightFlow from provideChassisWeight.weight to sumAndCheckWeight.chassisWeight;\n\t\tsuccession flow engineWeightFlow from provideEngineWeight.weight to sumAndCheckWeight.engineWeight;\n\t\tsuccession flow transmissionWeightFlow from provideTransmissionWeight.weight to sumAndCheckWeight.transmissionWeight;\n\t\taction sumAndCheckWeight {\n\t\t\tin chassisWeight: Weight;\n\t\t\tin engineWeight: Weight;\n\t\t\tin transmissionWeight: Weight;\n\t\t\tout warning: Warning;\n\t\t\tout restriction: Restriction;\n\t\t\tconstraint totalWeightLimit {\n\t\t\t\t(chassisWeight + engineWeight + transmissionWeight) <= WeightLimit.value;\n\t\t\t}\n\t\t\tcondition onExceedLimit {\n\t\t\t\tif (chassisWeight + engineWeight + transmissionWeight) > WeightLimit.value {\n\t\t\t\t\twarning = 'Weight limit exceeded';\n\t\t\t\t\trestriction = 'Apply restrictions';\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n}",
    "package 'VehicleSystem' {\n\n\t// Attribute definitions\n\tattribute def Mass;\n\tattribute def Force;\n\tattribute def Time;\n\tattribute def Velocity;\n\n\t// Part definitions\n\tpart def Chassis {\n\t\tattribute mass: Mass;\n\t}\n\tpart def Engine {\n\t\tattribute mass: Mass;\n\t}\n\tpart def Transmission {\n\t\tattribute mass: Mass;\n\t}\n\tpart def Vehicle {\n\t\tpart chassis: Chassis;\n\t\tpart engine: Engine;\n\t\tpart transmission: Transmission;\n\n\t\tattribute totalMass: Mass;\n\n\t\tconstraint def TotalMassConstraint {\n\t\t\ttotalMass = chassis.mass + engine.mass + transmission.mass;\n\t\t\ttotalMass <= 2500;\n\t\t\tchassis.mass > 0;\n\t\t\tengine.mass > 0;\n\t\t\ttransmission.mass > 0;\n\t\t}\n\t}\n\n\t// Dynamic behavior modeling\n\taction def VehicleDynamics {\n\t\tin initialVelocity: Velocity;\n\t\tin finalVelocity: Velocity;\n\t\tin mass: Mass;\n\t\tin force: Force;\n\t\tin time: Time;\n\n\t\tconstraint def MassPositive {\n\t\t\tmass > 0;\n\t\t}\n\n\t\tconstraint def NewtonSecondLaw {\n\t\t\tforce * time = mass * (finalVelocity - initialVelocity);\n\t\t}\n\t}\n\n\t// Context for system usage\n\tpart context {\n\t\tpart vehicle: Vehicle;\n\t\tperform VehicleDynamics {\n\t\t\tin mass = vehicle.totalMass;\n\t\t}\n\t}\n}",
    "package 'VehicleMaintenance' {\n\tattribute def VehicleId;\n\tattribute def Time;\n\tattribute def Duration;\n\tattribute def Temperature;\n\tattribute def Status;\n\tattribute def Interval;\n\tattribute def MaxTemperature;\n\tattribute def HealthStatus;\n\t\n\tenum StatusEnum {\n\t\tHealthy,\n\t\tUnderMaintenance\n\t}\n\t\n\tenum HealthStatusEnum {\n\t\tNormal,\n\t\tAbnormal\n\t}\n\t\n\tport def VehicleStatusPort {\n\t\tout status: StatusEnum;\n\t\tout healthStatus: HealthStatusEnum;\n\t}\n\t\n\tport def MaintenanceCmdPort {\n\t\tout startMaintenance: Boolean;\n\t\tout completeMaintenance: Boolean;\n\t}\n\t\n\tpart context {\n\t\tpart vehicle {\n\t\t\tattribute vehicleId: VehicleId;\n\t\t\tattribute nextMaintenanceTime: Time;\n\t\t\tattribute maintenanceInterval: Interval;\n\t\t\tattribute maxAllowedTemperature: MaxTemperature;\n\t\t\tattribute currentTemperature: Temperature;\n\t\t\tattribute status: StatusEnum = StatusEnum::Healthy;\n\t\t\tattribute healthStatus: HealthStatusEnum = HealthStatusEnum::Normal;\n\t\t\tattribute lastHealthyEndTime: Time;\n\t\t\tattribute maintenanceStartTime: Time;\n\t\t\tattribute maintenanceEndTime: Time;\n\t\t\t\n\t\t\tport statusPort: VehicleStatusPort;\n\t\t\tport maintenanceCmdPort: ~MaintenanceCmdPort;\n\t\t\t\n\t\t\tperform maintenanceProcess.scheduleMaintenance {\n\t\t\t\tin currentTime: Time;\n\t\t\t\tin maintenanceInterval: Interval = maintenanceInterval;\n\t\t\t\tin nextMaintenanceTime: Time = nextMaintenanceTime;\n\t\t\t\tin maxAllowedTemperature: MaxTemperature = maxAllowedTemperature;\n\t\t\t\tin currentTemperature: Temperature = currentTemperature;\n\t\t\t\tout status: StatusEnum = status;\n\t\t\t\tout healthStatus: HealthStatusEnum = healthStatus;\n\t\t\t\tout startMaintenance: Boolean;\n\t\t\t\tout completeMaintenance: Boolean;\n\t\t\t\tout maintenanceStartTime: Time = maintenanceStartTime;\n\t\t\t\tout maintenanceEndTime: Time = maintenanceEndTime;\n\t\t\t}\n\t\t}\n\t\t\n\t\tpart maintenanceManager {\n\t\t\tport maintenanceCmdPort: MaintenanceCmdPort;\n\t\t\tperform maintenanceProcess.manageMaintenance {\n\t\t\t\tin startMaintenance: Boolean = maintenanceCmdPort.startMaintenance;\n\t\t\t\tin completeMaintenance: Boolean = maintenanceCmdPort.completeMaintenance;\n\t\t\t}\n\t\t}\n\t\t\n\t\tinterface vehicleToManager connect vehicle.maintenanceCmdPort to maintenanceManager.maintenanceCmdPort {\n\t\t\tref flow references maintenanceProcess.maintenanceCmdFlow\n\t\t\t\tfrom source.startMaintenance to target.startMaintenance,\n\t\t\t\tfrom source.completeMaintenance to target.completeMaintenance;\n\t\t}\n\t}\n\t\n\taction maintenanceProcess {\n\t\taction scheduleMaintenance {\n\t\t\tin currentTime: Time;\n\t\t\tin maintenanceInterval: Interval;\n\t\t\tin nextMaintenanceTime: Time;\n\t\t\tin maxAllowedTemperature: MaxTemperature;\n\t\t\tin currentTemperature: Temperature;\n\t\t\tout status: StatusEnum;\n\t\t\tout healthStatus: HealthStatusEnum;\n\t\t\tout startMaintenance: Boolean;\n\t\t\tout completeMaintenance: Boolean;\n\t\t\tout maintenanceStartTime: Time;\n\t\t\tout maintenanceEndTime: Time;\n\t\t\t\n\t\t\t// Determine if maintenance time is reached\n\t\t\tif (currentTime >= nextMaintenanceTime) {\n\t\t\t\tstatus = StatusEnum::UnderMaintenance;\n\t\t\t\tstartMaintenance = true;\n\t\t\t} else {\n\t\t\t\tstatus = StatusEnum::Healthy;\n\t\t\t\tstartMaintenance = false;\n\t\t\t}\n\t\t}\n\t\t\n\t\tsuccession flow maintenanceCmdFlow from scheduleMaintenance.startMaintenance to manageMaintenance.startMaintenance;\n\t\tsuccession flow maintenanceCmdFlow2 from scheduleMaintenance.completeMaintenance to manageMaintenance.completeMaintenance;\n\t\t\n\t\taction manageMaintenance {\n\t\t\tin startMaintenance: Boolean;\n\t\t\tin completeMaintenance: Boolean;\n\t\t\t\n\t\t\t// Constraint: Maintenance must start after scheduled time\n\t\t\trequirement maintenanceStartAfterScheduled {\n\t\t\t\tassert manageMaintenance.maintenanceStartTime > scheduleMaintenance.nextMaintenanceTime;\n\t\t\t}\n\t\t\t\n\t\t\t// Constraint: Maintenance must start within 2 seconds after healthy state ends\n\t\t\trequirement maintenanceStartWithin2Sec {\n\t\t\t\tassert (manageMaintenance.maintenanceStartTime - scheduleMaintenance.lastHealthyEndTime) <= 2s;\n\t\t\t}\n\t\t\t\n\t\t\t// Constraint: Maintenance duration <= 48 hours\n\t\t\trequirement maintenanceDurationLimit {\n\t\t\t\tassert (manageMaintenance.maintenanceEndTime - manageMaintenance.maintenanceStartTime) <= 48h;\n\t\t\t}\n\t\t\t\n\t\t\t// On completion, update next maintenance time and restore health\n\t\t\tif (completeMaintenance) {\n\t\t\t\tscheduleMaintenance.nextMaintenanceTime = manageMaintenance.maintenanceEndTime + scheduleMaintenance.maintenanceInterval;\n\t\t\t\tscheduleMaintenance.status = StatusEnum::Healthy;\n\t\t\t\tscheduleMaintenance.healthStatus = HealthStatusEnum::Normal;\n\t\t\t}\n\t\t}\n\t}\n}",
    "package 'VehicleMassAndPower' {\n\tattribute def Mass;\n\tattribute def Torque;\n\tattribute def Speed;\n\tattribute def MassLimit;\n\tattribute def PositiveMass;\n\t\n\tport def TorquePort {\n\t\tout torque: Torque;\n\t}\n\tport def SpeedPort {\n\t\tout speed: Speed;\n\t}\n\tport def ClutchPort {\n\t\tin torque: Torque;\n\t}\n\t\n\tpart context {\n\t\tpart vehicle {\n\t\t\tattribute curbMass: Mass;\n\t\t\tattribute fuelMass: Mass;\n\t\t\tattribute maxMassLimit: MassLimit;\n\t\t\t\n\t\t\tperform massManagement.checkTotalMass {\n\t\t\t\tin curbMass = curbMass;\n\t\t\t\tin fuelMass = fuelMass;\n\t\t\t\tin maxMassLimit = maxMassLimit;\n\t\t\t}\n\t\t\t\n\t\t\tpart engine {\n\t\t\t\tport torquePort: TorquePort;\n\t\t\t\tport speedPort: SpeedPort;\n\t\t\t\tperform powerGeneration.generateTorque {\n\t\t\t\t\tin speed = speedPort.speed;\n\t\t\t\t\tout torque = torquePort.torque;\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\tpart clutch {\n\t\t\t\tport clutchPort: ClutchPort;\n\t\t\t\tport torquePort: ~TorquePort;\n\t\t\t\tperform powerTransmission.transmitTorque {\n\t\t\t\t\tin torque = torquePort.torque;\n\t\t\t\t\tout torque = clutchPort.torque;\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\tpart transmission {\n\t\t\t\tport clutchPort: ~ClutchPort;\n\t\t\t\tperform powerDelivery.receiveTorque {\n\t\t\t\t\tin torque = clutchPort.torque;\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\tinterface engineToClutch connect engine.torquePort to clutch.torquePort {\n\t\t\t\tref flow references powerTransmission.torqueFlow\n\t\t\t\t\tfrom source.torque to target.torque;\n\t\t\t}\n\t\t\tinterface clutchToTransmission connect clutch.clutchPort to transmission.clutchPort {\n\t\t\t\tref flow references powerDelivery.torqueFlow\n\t\t\t\t\tfrom source.torque to target.torque;\n\t\t\t}\n\t\t}\n\t}\n\t\n\taction massManagement {\n\t\taction checkTotalMass {\n\t\t\tin curbMass: Mass;\n\t\t\tin fuelMass: Mass;\n\t\t\tin maxMassLimit: MassLimit;\n\t\t\tassert (curbMass + fuelMass) <= maxMassLimit;\n\t\t\tassert fuelMass > 0;\n\t\t}\n\t}\n\t\n\taction powerGeneration {\n\t\taction generateTorque {\n\t\t\tin speed: Speed;\n\t\t\tout torque: Torque;\n\t\t\t// torque = f(speed) (speed curve mapping)\n\t\t}\n\t}\n\t\n\taction powerTransmission {\n\t\taction transmitTorque {\n\t\t\tin torque: Torque;\n\t\t\tout torque: Torque;\n\t\t}\n\t\tsuccession flow torqueFlow from transmitTorque.torque to powerDelivery.receiveTorque.torque;\n\t}\n\t\n\taction powerDelivery {\n\t\taction receiveTorque {\n\t\t\tin torque: Torque;\n\t\t}\n\t\tsuccession flow torqueFlow from powerTransmission.transmitTorque.torque to receiveTorque.torque;\n\t}\n}",
    "package 'VehicleSystem' {\n\n\tattribute def Mass;\n\tattribute def Torque;\n\tattribute def Speed;\n\tattribute def FuelMass;\n\tattribute def DryMass;\n\n\tpart context {\n\t\tpart vehicle {\n\t\t\tattribute dryMass: DryMass;\n\t\t\tattribute fuelMass: FuelMass;\n\t\t\tattribute totalMass: Mass;\n\t\t\tpart engine {\n\t\t\t\tport torqueOut: EngineTorquePort;\n\t\t\t\tperform powertrain.deliverTorque {\n\t\t\t\t\tout torque = torqueOut.torque;\n\t\t\t\t}\n\t\t\t}\n\t\t\tpart clutch {\n\t\t\t\tport torqueIn: ~EngineTorquePort;\n\t\t\t\tport torqueOut: ClutchTorquePort;\n\t\t\t\tperform powertrain.transmitTorque {\n\t\t\t\t\tin torque = torqueIn.torque;\n\t\t\t\t\tout torque = torqueOut.torque;\n\t\t\t\t}\n\t\t\t}\n\t\t\tpart transmission {\n\t\t\t\tport torqueIn: ~ClutchTorquePort;\n\t\t\t\tperform powertrain.receiveTorque {\n\t\t\t\t\tin torque = torqueIn.torque;\n\t\t\t\t}\n\t\t\t}\n\t\t\tinterface engineToClutch connect engine.torqueOut to clutch.torqueIn {\n\t\t\t\tref flow references powertrain.torqueFlow1\n\t\t\t\t\tfrom source.torque to target.torque;\n\t\t\t}\n\t\t\tinterface clutchToTransmission connect clutch.torqueOut to transmission.torqueIn {\n\t\t\t\tref flow references powertrain.torqueFlow2\n\t\t\t\t\tfrom source.torque to target.torque;\n\t\t\t}\n\t\t}\n\t}\n\n\tport def EngineTorquePort {\n\t\tout torque: Torque;\n\t}\n\tport def ClutchTorquePort {\n\t\tout torque: Torque;\n\t}\n\n\tconstraint def FullTankMassLimit {\n\t\t// total mass with full tank <= 2000 kg\n\t\t(vehicle.totalMass = vehicle.dryMass + vehicle.fuelMass) and\n\t\t(vehicle.totalMass <= 2000);\n\t}\n\tconstraint def EmptyTankMassLimit {\n\t\t// total mass with empty tank <= 1500 kg\n\t\t(vehicle.totalMass = vehicle.dryMass) and\n\t\t(vehicle.totalMass <= 1500);\n\t}\n\n\taction powertrain {\n\t\taction deliverTorque {\n\t\t\tout torque: Torque;\n\t\t\tin speed: Speed;\n\t\t\tconstraint def SpeedTorqueCurve {\n\t\t\t\t// torque must follow speed-torque curve (see Table 1)\n\t\t\t\ttorque = speedTorqueCurve(speed);\n\t\t\t}\n\t\t}\n\t\tsuccession flow torqueFlow1 from deliverTorque.torque to transmitTorque.torque;\n\t\taction transmitTorque {\n\t\t\tin torque: Torque;\n\t\t\tout torque: Torque;\n\t\t}\n\t\tsuccession flow torqueFlow2 from transmitTorque.torque to receiveTorque.torque;\n\t\taction receiveTorque {\n\t\t\tin torque: Torque;\n\t\t}\n\t}\n\n\tfunction def speedTorqueCurve(speed: Speed): Torque;\n}",
    "package 'VehicleSystem' {\n\tattribute def Mass;\n\tattribute def Torque;\n\tattribute def Speed;\n\tattribute def PerformanceTable;\n\n\tport def TorquePort {\n\t\tout torque: Torque;\n\t\tin speed: Speed;\n\t}\n\n\tport def ClutchInterface {\n\t\tout torque: Torque;\n\t}\n\n\tpart context {\n\t\tpart vehicle {\n\t\t\tattribute emptyMass: Mass;\n\t\t\tattribute fullMass: Mass;\n\t\t\trequirement massLimits {\n\t\t\t\temptyMass <= 1500 kg;\n\t\t\t\tfullMass <= 2000 kg;\n\t\t\t}\n\t\t\tpart engine {\n\t\t\t\tport torquePort: TorquePort;\n\t\t\t\tattribute performanceTable: PerformanceTable;\n\t\t\t\trequirement torquePerformance {\n\t\t\t\t\ttorquePort.torque varies with torquePort.speed;\n\t\t\t\t\ttorquePort.torque conforms to performanceTable;\n\t\t\t\t}\n\t\t\t\tport clutchInterface: ClutchInterface;\n\t\t\t\tperform transmitTorque {\n\t\t\t\t\tout torque = torquePort.torque;\n\t\t\t\t}\n\t\t\t\tsuccession flow torqueFlow from transmitTorque.torque to clutchInterface.torque;\n\t\t\t}\n\t\t\tpart transmission {\n\t\t\t\tport clutchInterface: ~ClutchInterface;\n\t\t\t\tperform receiveTorque {\n\t\t\t\t\tin torque = clutchInterface.torque;\n\t\t\t\t}\n\t\t\t}\n\t\t\tinterface engineToTransmission connect engine.clutchInterface to transmission.clutchInterface {\n\t\t\t\tref flow references transmitTorque.torqueFlow\n\t\t\t\t\tfrom source.torque to target.torque;\n\t\t\t}\n\t\t\trequirement vehiclePerformanceAndSafety {\n\t\t\t\tvehicle.emptyMass <= 1500 kg;\n\t\t\t\tvehicle.fullMass <= 2000 kg;\n\t\t\t\tengine.torquePort.torque conforms to engine.performanceTable;\n\t\t\t\tengine.clutchInterface transmits engine.torquePort.torque;\n\t\t\t}\n\t\t}\n\t}\n}",
    "package 'VehicleSystem' {\n\tattribute def Mass;\n\tattribute def Torque;\n\tattribute def Speed;\n\tattribute def CurbMass;\n\tattribute def FuelMass;\n\tattribute def TotalVehicleMass;\n\tattribute def TorqueCharacteristic;\n\tattribute def MassLimit;\n\tattribute def PowerDeliveryStatus;\n\n\tpart context {\n\t\tpart vehicle {\n\t\t\tattribute curbMass: CurbMass;\n\t\t\tattribute fuelMass: FuelMass;\n\t\t\tattribute totalVehicleMass: TotalVehicleMass;\n\t\t\tattribute massLimit: MassLimit;\n\t\t\tport enginePort: EnginePort;\n\t\t\tport clutchPort: ClutchPort;\n\t\t\tport gearboxPort: GearboxPort;\n\t\t\tperform vehicleMassControl.calculateTotalMass {\n\t\t\t\tin curbMass = curbMass;\n\t\t\t\tin fuelMass = fuelMass;\n\t\t\t\tout totalVehicleMass = totalVehicleMass;\n\t\t\t}\n\t\t\tperform vehicleMassControl.checkMassLimit {\n\t\t\t\tin totalVehicleMass = totalVehicleMass;\n\t\t\t\tin massLimit = massLimit;\n\t\t\t}\n\t\t\tperform powerTransmission.transmitTorque {\n\t\t\t\tin torque = enginePort.torque;\n\t\t\t\tin speed = enginePort.speed;\n\t\t\t\tout powerDeliveryStatus = gearboxPort.powerDeliveryStatus;\n\t\t\t}\n\t\t}\n\t\tpart engine {\n\t\t\tport enginePort: ~EnginePort;\n\t\t\tperform powerTransmission.generateTorque {\n\t\t\t\tout torque: Torque;\n\t\t\t\tout speed: Speed;\n\t\t\t\tout torqueCharacteristic: TorqueCharacteristic;\n\t\t\t}\n\t\t}\n\t\tpart clutch {\n\t\t\tport clutchPort: ~ClutchPort;\n\t\t\tport enginePort: EnginePort;\n\t\t\tport gearboxPort: GearboxPort;\n\t\t\tperform powerTransmission.clutchInterface {\n\t\t\t\tin torque = enginePort.torque;\n\t\t\t\tin speed = enginePort.speed;\n\t\t\t\tout torque = gearboxPort.torque;\n\t\t\t\tout speed = gearboxPort.speed;\n\t\t\t}\n\t\t}\n\t\tpart gearbox {\n\t\t\tport gearboxPort: ~GearboxPort;\n\t\t\tattribute powerDeliveryStatus: PowerDeliveryStatus;\n\t\t\tperform powerTransmission.receiveTorque {\n\t\t\t\tin torque = gearboxPort.torque;\n\t\t\t\tin speed = gearboxPort.speed;\n\t\t\t\tout powerDeliveryStatus = powerDeliveryStatus;\n\t\t\t}\n\t\t}\n\t}\n\n\tport def EnginePort {\n\t\tout torque: Torque;\n\t\tout speed: Speed;\n\t\tout torqueCharacteristic: TorqueCharacteristic;\n\t}\n\tport def ClutchPort {\n\t\tin torque: Torque;\n\t\tin speed: Speed;\n\t\tout torque: Torque;\n\t\tout speed: Speed;\n\t}\n\tport def GearboxPort {\n\t\tin torque: Torque;\n\t\tin speed: Speed;\n\t\tout powerDeliveryStatus: PowerDeliveryStatus;\n\t}\n\n\taction vehicleMassControl {\n\t\taction calculateTotalMass {\n\t\t\tin curbMass: CurbMass;\n\t\t\tin fuelMass: FuelMass;\n\t\t\tout totalVehicleMass: TotalVehicleMass;\n\t\t\t// totalVehicleMass = curbMass + fuelMass\n\t\t}\n\t\taction checkMassLimit {\n\t\t\tin totalVehicleMass: TotalVehicleMass;\n\t\t\tin massLimit: MassLimit;\n\t\t\t// assert totalVehicleMass <= massLimit\n\t\t}\n\t}\n\n\taction powerTransmission {\n\t\taction generateTorque {\n\t\t\tout torque: Torque;\n\t\t\tout speed: Speed;\n\t\t\tout torqueCharacteristic: TorqueCharacteristic;\n\t\t\t// torque generated as function of speed\n\t\t}\n\t\taction clutchInterface {\n\t\t\tin torque: Torque;\n\t\t\tin speed: Speed;\n\t\t\tout torque: Torque;\n\t\t\tout speed: Speed;\n\t\t\t// torque and speed transmitted through clutch\n\t\t}\n\t\taction transmitTorque {\n\t\t\tin torque: Torque;\n\t\t\tin speed: Speed;\n\t\t\tout powerDeliveryStatus: PowerDeliveryStatus;\n\t\t\t// power delivered to gearbox\n\t\t}\n\t\taction receiveTorque {\n\t\t\tin torque: Torque;\n\t\t\tin speed: Speed;\n\t\t\tout powerDeliveryStatus: PowerDeliveryStatus;\n\t\t\t// gearbox receives torque and speed\n\t\t}\n\t}\n\n\tconstraint def FullTankMassLimit {\n\t\tcontext vehicle\n\t\tcondition: (fuelMass = maxFuelMass) => (totalVehicleMass <= 2000 kg);\n\t}\n\tconstraint def EmptyTankMassLimit {\n\t\tcontext vehicle\n\t\tcondition: (fuelMass = 0 kg) => (totalVehicleMass <= 1500 kg);\n\t}\n\tconstraint def TotalVehicleMassCalculation {\n\t\tcontext vehicle\n\t\tcondition: totalVehicleMass = curbMass + fuelMass;\n\t}\n\tconstraint def TorqueTransmission {\n\t\tcontext clutch\n\t\tcondition: (enginePort.torque = gearboxPort.torque) and (enginePort.speed = gearboxPort.speed);\n\t}\n}",
    "package 'VehiclePerformanceAnalysis' {\n\n\t// Attribute definitions\n\tattribute def CurbWeight;\n\tattribute def Payload;\n\tattribute def WheelDiameter;\n\tattribute def TransmissionEfficiency;\n\tattribute def FuelEconomyUrban;\n\tattribute def FuelEconomyHighway;\n\tattribute def EnginePower;\n\tattribute def Acceleration;\n\tattribute def Speed;\n\tattribute def Position;\n\tattribute def Time;\n\tattribute def FuelConsumption;\n\tattribute def EnergyConsumptionTarget;\n\tattribute def DriveCycleScenario;\n\tattribute def FuelEconomyResult;\n\tattribute def ComplianceResult;\n\n\t// Port definitions\n\tport def VehicleConfigPort {\n\t\tin curbWeight: CurbWeight;\n\t\tin payload: Payload;\n\t\tin wheelDiameter: WheelDiameter;\n\t\tin transmissionEfficiency: TransmissionEfficiency;\n\t\tin fuelEconomyUrban: FuelEconomyUrban;\n\t\tin fuelEconomyHighway: FuelEconomyHighway;\n\t}\n\tport def DriveCyclePort {\n\t\tin driveCycleScenario: DriveCycleScenario;\n\t}\n\tport def AnalysisResultPort {\n\t\tout enginePower: EnginePower;\n\t\tout acceleration: Acceleration;\n\t\tout speed: Speed;\n\t\tout position: Position;\n\t\tout fuelEconomyResult: FuelEconomyResult;\n\t\tout complianceResult: ComplianceResult;\n\t}\n\n\t// Part structure\n\tpart context {\n\t\tpart user {\n\t\t\tport vehicleConfigPort: VehicleConfigPort;\n\t\t\tport driveCyclePort: DriveCyclePort;\n\t\t\tport analysisResultPort: ~AnalysisResultPort;\n\t\t\tperform vehicleAnalysisInput.inputVehicleConfig {\n\t\t\t\tout curbWeight = vehicleConfigPort.curbWeight;\n\t\t\t\tout payload = vehicleConfigPort.payload;\n\t\t\t\tout wheelDiameter = vehicleConfigPort.wheelDiameter;\n\t\t\t\tout transmissionEfficiency = vehicleConfigPort.transmissionEfficiency;\n\t\t\t\tout fuelEconomyUrban = vehicleConfigPort.fuelEconomyUrban;\n\t\t\t\tout fuelEconomyHighway = vehicleConfigPort.fuelEconomyHighway;\n\t\t\t}\n\t\t\tperform vehicleAnalysisInput.inputDriveCycle {\n\t\t\t\tout driveCycleScenario = driveCyclePort.driveCycleScenario;\n\t\t\t}\n\t\t\tperform vehicleAnalysisOutput.receiveAnalysisResults {\n\t\t\t\tin enginePower = analysisResultPort.enginePower;\n\t\t\t\tin acceleration = analysisResultPort.acceleration;\n\t\t\t\tin speed = analysisResultPort.speed;\n\t\t\t\tin position = analysisResultPort.position;\n\t\t\t\tin fuelEconomyResult = analysisResultPort.fuelEconomyResult;\n\t\t\t\tin complianceResult = analysisResultPort.complianceResult;\n\t\t\t}\n\t\t}\n\t\tpart vehiclePerformanceAnalyzer {\n\t\t\tport vehicleConfigPort: ~VehicleConfigPort;\n\t\t\tport driveCyclePort: ~DriveCyclePort;\n\t\t\tport analysisResultPort: AnalysisResultPort;\n\t\t\tperform vehicleAnalysis.processAnalysis {\n\t\t\t\tin curbWeight = vehicleConfigPort.curbWeight;\n\t\t\t\tin payload = vehicleConfigPort.payload;\n\t\t\t\tin wheelDiameter = vehicleConfigPort.wheelDiameter;\n\t\t\t\tin transmissionEfficiency = vehicleConfigPort.transmissionEfficiency;\n\t\t\t\tin fuelEconomyUrban = vehicleConfigPort.fuelEconomyUrban;\n\t\t\t\tin fuelEconomyHighway = vehicleConfigPort.fuelEconomyHighway;\n\t\t\t\tin driveCycleScenario = driveCyclePort.driveCycleScenario;\n\t\t\t\tout enginePower = analysisResultPort.enginePower;\n\t\t\t\tout acceleration = analysisResultPort.acceleration;\n\t\t\t\tout speed = analysisResultPort.speed;\n\t\t\t\tout position = analysisResultPort.position;\n\t\t\t\tout fuelEconomyResult = analysisResultPort.fuelEconomyResult;\n\t\t\t\tout complianceResult = analysisResultPort.complianceResult;\n\t\t\t}\n\t\t}\n\t}\n\n\t// Actions and flows\n\taction vehicleAnalysis {\n\t\taction inputVehicleConfig {\n\t\t\tout curbWeight: CurbWeight;\n\t\t\tout payload: Payload;\n\t\t\tout wheelDiameter: WheelDiameter;\n\t\t\tout transmissionEfficiency: TransmissionEfficiency;\n\t\t\tout fuelEconomyUrban: FuelEconomyUrban;\n\t\t\tout fuelEconomyHighway: FuelEconomyHighway;\n\t\t}\n\t\taction inputDriveCycle {\n\t\t\tout driveCycleScenario: DriveCycleScenario;\n\t\t}\n\t\taction processAnalysis {\n\t\t\tin curbWeight: CurbWeight;\n\t\t\tin payload: Payload;\n\t\t\tin wheelDiameter: WheelDiameter;\n\t\t\tin transmissionEfficiency: TransmissionEfficiency;\n\t\t\tin fuelEconomyUrban: FuelEconomyUrban;\n\t\t\tin fuelEconomyHighway: FuelEconomyHighway;\n\t\t\tin driveCycleScenario: DriveCycleScenario;\n\t\t\tout enginePower: EnginePower;\n\t\t\tout acceleration: Acceleration;\n\t\t\tout speed: Speed;\n\t\t\tout position: Position;\n\t\t\tout fuelEconomyResult: FuelEconomyResult;\n\t\t\tout complianceResult: ComplianceResult;\n\t\t}\n\t}\n\t\n\taction vehicleAnalysisOutput {\n\t\taction receiveAnalysisResults {\n\t\t\tin enginePower: EnginePower;\n\t\t\tin acceleration: Acceleration;\n\t\t\tin speed: Speed;\n\t\t\tin position: Position;\n\t\t\tin fuelEconomyResult: FuelEconomyResult;\n\t\t\tin complianceResult: ComplianceResult;\n\t\t}\n\t}\n\n\t// Requirement definitions\n\trequirement def VehicleDynamicPerformance {\n\t\ttext = \"The system shall model and calculate vehicle power demand, acceleration, speed, and position variations over time during straight-line driving.\"\n\t}\n\trequirement def VehicleConfigInput {\n\t\ttext = \"The system shall allow users to set vehicle attributes and driving cycles for analysis.\"\n\t}\n\trequirement def FuelEconomyCalculation {\n\t\ttext = \"The system shall calculate the vehicles fuel economy throughout the entire driving cycle.\"\n\t}\n\trequirement def ComplianceVerification {\n\t\ttext = \"The system shall verify compliance with specified energy consumption targets, such as fuel consumption per 100 kilometers or miles per gallon.\"\n\t}\n\trequirement def Configurability {\n\t\ttext = \"The system shall provide adjustable configuration options for vehicle parameters and drive cycle scenarios.\"\n\t}\n\trequirement def DataSupport {\n\t\ttext = \"The system shall provide data support and decision-making references for vehicle design optimization and energy consumption target achievement.\"\n\t}\n}",
    "package 'VehicleFuelEconomySimulation' {\n\tattribute def FuelEconomy_mpg;\n\tattribute def FuelEconomy_Lper100km;\n\tattribute def FuelConsumption;\n\tattribute def EnginePower;\n\tattribute def WheelPower;\n\tattribute def Acceleration;\n\tattribute def EnergyConsumption;\n\tattribute def CurbWeight;\n\tattribute def Load;\n\tattribute def WheelDiameter;\n\tattribute def TransmissionEfficiency;\n\tattribute def DrivingScenario;\n\tattribute def DrivingTrajectory;\n\tattribute def SpeedProfile;\n\tattribute def ComplianceResult;\n\n\tport def ScenarioInputPort {\n\t\tin scenario: DrivingScenario;\n\t\tin trajectory: DrivingTrajectory;\n\t\tin speedProfile: SpeedProfile;\n\t}\n\tport def VehicleParamPort {\n\t\tin curbWeight: CurbWeight;\n\t\tin load: Load;\n\t\tin wheelDiameter: WheelDiameter;\n\t\tin transmissionEfficiency: TransmissionEfficiency;\n\t}\n\tport def SimulationResultPort {\n\t\tout fuelEconomy_mpg: FuelEconomy_mpg;\n\t\tout fuelEconomy_Lper100km: FuelEconomy_Lper100km;\n\t\tout complianceResult: ComplianceResult;\n\t}\n\n\tpart context {\n\t\tpart user {\n\t\t\tport scenarioInputPort: ScenarioInputPort;\n\t\t\tport vehicleParamPort: VehicleParamPort;\n\t\t\tperform evaluateDesign.setInputs {\n\t\t\t\tin scenario = scenarioInputPort.scenario;\n\t\t\t\tin trajectory = scenarioInputPort.trajectory;\n\t\t\t\tin speedProfile = scenarioInputPort.speedProfile;\n\t\t\t\tin curbWeight = vehicleParamPort.curbWeight;\n\t\t\t\tin load = vehicleParamPort.load;\n\t\t\t\tin wheelDiameter = vehicleParamPort.wheelDiameter;\n\t\t\t\tin transmissionEfficiency = vehicleParamPort.transmissionEfficiency;\n\t\t\t}\n\t\t}\n\t\tpart simulationEngine {\n\t\t\tport scenarioInputPort: ~ScenarioInputPort;\n\t\t\tport vehicleParamPort: ~VehicleParamPort;\n\t\t\tport simulationResultPort: SimulationResultPort;\n\t\t\tperform evaluateDesign.simulateFuelEconomy {\n\t\t\t\tin scenario = scenarioInputPort.scenario;\n\t\t\t\tin trajectory = scenarioInputPort.trajectory;\n\t\t\t\tin speedProfile = scenarioInputPort.speedProfile;\n\t\t\t\tin curbWeight = vehicleParamPort.curbWeight;\n\t\t\t\tin load = vehicleParamPort.load;\n\t\t\t\tin wheelDiameter = vehicleParamPort.wheelDiameter;\n\t\t\t\tin transmissionEfficiency = vehicleParamPort.transmissionEfficiency;\n\t\t\t\tout fuelEconomy_mpg = simulationResultPort.fuelEconomy_mpg;\n\t\t\t\tout fuelEconomy_Lper100km = simulationResultPort.fuelEconomy_Lper100km;\n\t\t\t\tout complianceResult = simulationResultPort.complianceResult;\n\t\t\t}\n\t\t}\n\t}\n\n\taction evaluateDesign {\n\t\taction setInputs {\n\t\t\tin scenario: DrivingScenario;\n\t\t\tin trajectory: DrivingTrajectory;\n\t\t\tin speedProfile: SpeedProfile;\n\t\t\tin curbWeight: CurbWeight;\n\t\t\tin load: Load;\n\t\t\tin wheelDiameter: WheelDiameter;\n\t\t\tin transmissionEfficiency: TransmissionEfficiency;\n\t\t}\n\t\tsuccession flow inputFlow from setInputs to simulateFuelEconomy;\n\t\taction simulateFuelEconomy {\n\t\t\tin scenario: DrivingScenario;\n\t\t\tin trajectory: DrivingTrajectory;\n\t\t\tin speedProfile: SpeedProfile;\n\t\t\tin curbWeight: CurbWeight;\n\t\t\tin load: Load;\n\t\t\tin wheelDiameter: WheelDiameter;\n\t\t\tin transmissionEfficiency: TransmissionEfficiency;\n\t\t\tout fuelEconomy_mpg: FuelEconomy_mpg;\n\t\t\tout fuelEconomy_Lper100km: FuelEconomy_Lper100km;\n\t\t\tout complianceResult: ComplianceResult;\n\t\t}\n\t}\n\n\trequirement FuelEconomyRequirement {\n\t\ttext = \"The vehicle shall achieve a fuel economy exceeding 30 miles per gallon under both urban and highway driving scenarios.\"\n\t}\n\trequirement ComplianceRequirement {\n\t\ttext = \"The system shall assess whether the vehicle design meets energy-saving, emissions reduction, and regulatory compliance requirements based on simulation results.\"\n\t}\n}",
    "package 'EngineSelectionSystem' {\n\tattribute def EngineType;\n\tattribute def Power;\n\tattribute def Mass;\n\tattribute def Efficiency;\n\tattribute def Cost;\n\tattribute def EvaluationScore;\n\tattribute def Recommendation;\n\n\tport def EngineDataPort {\n\t\tout engineType: EngineType;\n\t\tout power: Power;\n\t\tout mass: Mass;\n\t\tout efficiency: Efficiency;\n\t\tout cost: Cost;\n\t}\n\n\tport def EvaluationPort {\n\t\tin evaluationScore: EvaluationScore;\n\t}\n\n\tport def RecommendationPort {\n\t\tout recommendation: Recommendation;\n\t}\n\n\tpart context {\n\t\tpart engineDatabase {\n\t\t\tport engineDataPort: EngineDataPort;\n\t\t\tperform engineSelection.collectEngineData {\n\t\t\t\tout engineType = engineDataPort.engineType;\n\t\t\t\tout power = engineDataPort.power;\n\t\t\t\tout mass = engineDataPort.mass;\n\t\t\t\tout efficiency = engineDataPort.efficiency;\n\t\t\t\tout cost = engineDataPort.cost;\n\t\t\t}\n\t\t}\n\t\tpart analysisModule {\n\t\t\tport engineDataPort: ~EngineDataPort;\n\t\t\tport evaluationPort: EvaluationPort;\n\t\t\tperform engineSelection.aggregateAndEvaluate {\n\t\t\t\tin engineType = engineDataPort.engineType;\n\t\t\t\tin power = engineDataPort.power;\n\t\t\t\tin mass = engineDataPort.mass;\n\t\t\t\tin efficiency = engineDataPort.efficiency;\n\t\t\t\tin cost = engineDataPort.cost;\n\t\t\t\tout evaluationScore = evaluationPort.evaluationScore;\n\t\t\t}\n\t\t}\n\t\tpart selectionModule {\n\t\t\tport evaluationPort: ~EvaluationPort;\n\t\t\tport recommendationPort: RecommendationPort;\n\t\t\tperform engineSelection.selectOptimalEngine {\n\t\t\t\tin evaluationScore = evaluationPort.evaluationScore;\n\t\t\t\tout recommendation = recommendationPort.recommendation;\n\t\t\t}\n\t\t}\n\t}\n\n\taction engineSelection {\n\t\taction collectEngineData {\n\t\t\tout engineType: EngineType;\n\t\t\tout power: Power;\n\t\t\tout mass: Mass;\n\t\t\tout efficiency: Efficiency;\n\t\t\tout cost: Cost;\n\t\t}\n\t\taction aggregateAndEvaluate {\n\t\t\tin engineType: EngineType;\n\t\t\tin power: Power;\n\t\t\tin mass: Mass;\n\t\t\tin efficiency: Efficiency;\n\t\t\tin cost: Cost;\n\t\t\tout evaluationScore: EvaluationScore;\n\t\t}\n\t\taction selectOptimalEngine {\n\t\t\tin evaluationScore: EvaluationScore;\n\t\t\tout recommendation: Recommendation;\n\t\t}\n\t\tsuccession flow engineDataFlow from collectEngineData.(engineType, power, mass, efficiency, cost) to aggregateAndEvaluate.(engineType, power, mass, efficiency, cost);\n\t\tsuccession flow evaluationFlow from aggregateAndEvaluate.evaluationScore to selectOptimalEngine.evaluationScore;\n\t}\n}",
    "package 'VehicleCurbWeightCheck' {\n\tattribute def Weight_kg;\n\tattribute def EvaluationResult;\n\tconstant def MaxCurbWeight_kg : Weight_kg = 2500;\n\tport def WeightDataPort {\n\t\tout weight: Weight_kg;\n\t}\n\tport def EvaluationResultPort {\n\t\tout result: EvaluationResult;\n\t}\n\tpart context {\n\t\tpart vehicle {\n\t\t\tport weightDataPort: WeightDataPort;\n\t\t\tperform curbWeightCheck.collectWeightData {\n\t\t\t\tout weight = weightDataPort.weight;\n\t\t\t}\n\t\t}\n\t\tpart weightProcessingUnit {\n\t\t\tport weightDataPort: ~WeightDataPort;\n\t\t\tport evaluationResultPort: EvaluationResultPort;\n\t\t\tperform curbWeightCheck.processWeightData {\n\t\t\t\tin weight = weightDataPort.weight;\n\t\t\t\tout processedWeight: Weight_kg;\n\t\t\t}\n\t\t\tperform curbWeightCheck.evaluateWeight {\n\t\t\t\tin processedWeight;\n\t\t\t\tout result = evaluationResultPort.result;\n\t\t\t}\n\t\t}\n\t\tinterface vehicleToProcessing connect vehicle.weightDataPort to weightProcessingUnit.weightDataPort {\n\t\t\tref flow references curbWeightCheck.weightDataFlow\n\t\t\t\tfrom source.weight to target.weight;\n\t\t}\n\t}\n\taction curbWeightCheck {\n\t\taction collectWeightData { out weight: Weight_kg; }\n\t\tsuccession flow weightDataFlow from collectWeightData.weight to processWeightData.weight;\n\t\taction processWeightData { in weight: Weight_kg; out processedWeight: Weight_kg; }\n\t\tsuccession flow processedWeightFlow from processWeightData.processedWeight to evaluateWeight.processedWeight;\n\t\taction evaluateWeight {\n\t\t\tin processedWeight: Weight_kg;\n\t\t\tout result: EvaluationResult;\n\t\t\tconstraint checkCurbWeight {\n\t\t\t\tprocessedWeight <= MaxCurbWeight_kg;\n\t\t\t}\n\t\t}\n\t}\n\tenumeration EvaluationResult {\n\t\tliteral Qualified;\n\t\tliteral Unqualified;\n\t}\n}",
    "package 'VehicleMassVerification' {\n\tattribute def VehicleId;\n\tattribute def Mass;\n\tattribute def MassStatus; // {Qualified, Unqualified}\n\tconstant def MASS_LIMIT: Mass = 2500;\n\n\tport def VehiclePort {\n\t\tout vehicleId: VehicleId;\n\t}\n\tport def MassPort {\n\t\tout mass: Mass;\n\t}\n\tport def MassStatusPort {\n\t\tout massStatus: MassStatus;\n\t}\n\n\tpart context {\n\t\tpart vehicle {\n\t\t\tport vehiclePort: VehiclePort;\n\t\t\tperform massVerification.sendVehicleId {\n\t\t\t\tout vehicleId = vehiclePort.vehicleId;\n\t\t\t}\n\t\t}\n\t\tpart weighingEquipment {\n\t\t\tport vehiclePort: ~VehiclePort;\n\t\t\tport massPort: MassPort;\n\t\t\tperform massVerification.measureMass {\n\t\t\t\tin vehicleId = vehiclePort.vehicleId;\n\t\t\t\tout mass = massPort.mass;\n\t\t\t}\n\t\t}\n\t\tpart massVerificationUnit {\n\t\t\tport massPort: ~MassPort;\n\t\t\tport massStatusPort: MassStatusPort;\n\t\t\tperform massVerification.verifyMass {\n\t\t\t\tin mass = massPort.mass;\n\t\t\t\tout massStatus = massStatusPort.massStatus;\n\t\t\t}\n\t\t}\n\t}\n\n\taction massVerification {\n\t\taction sendVehicleId { out vehicleId: VehicleId; }\n\t\tsuccession flow vehicleIdFlow from sendVehicleId.vehicleId to measureMass.vehicleId;\n\n\t\taction measureMass { in vehicleId: VehicleId; out mass: Mass; }\n\t\tsuccession flow massFlow from measureMass.mass to verifyMass.mass;\n\n\t\taction verifyMass {\n\t\t\tin mass: Mass;\n\t\t\tout massStatus: MassStatus;\n\t\t\t// If-then-else logic for qualification\n\t\t}\n\t\tsuccession flow statusFlow from verifyMass.massStatus;\n\t}\n}",
    "package 'TransportationSystem' {\n\tattribute def UserCmd;\n\tattribute def RideStatus;\n\tattribute def EnvData;\n\tattribute def ComfortLevel;\n\tattribute def SafetyStatus;\n\tattribute def InfrastructureStatus;\n\n\tport def UserCmdPort {\n\t\tout userCmd: UserCmd;\n\t}\n\tport def RideStatusPort {\n\t\tout rideStatus: RideStatus;\n\t}\n\tport def EnvDataPort {\n\t\tin envData: EnvData;\n\t}\n\tport def ComfortLevelPort {\n\t\tout comfortLevel: ComfortLevel;\n\t}\n\tport def SafetyStatusPort {\n\t\tout safetyStatus: SafetyStatus;\n\t}\n\tport def InfrastructureStatusPort {\n\t\tin infrastructureStatus: InfrastructureStatus;\n\t}\n\n\tpart context {\n\t\tpart driver {\n\t\t\tport userCmdPort: UserCmdPort;\n\t\t\tperform transportJourney.initiateRide {\n\t\t\t\tout userCmd = userCmdPort.userCmd;\n\t\t\t}\n\t\t}\n\t\tpart passenger[0..4] {\n\t\t\tport userCmdPort: UserCmdPort;\n\t\t\tperform transportJourney.requestRide {\n\t\t\t\tout userCmd = userCmdPort.userCmd;\n\t\t\t}\n\t\t}\n\t\tpart vehicle {\n\t\t\tport userCmdPort: ~UserCmdPort;\n\t\t\tport rideStatusPort: RideStatusPort;\n\t\t\tport comfortLevelPort: ComfortLevelPort;\n\t\t\tport safetyStatusPort: SafetyStatusPort;\n\t\t\tport envDataPort: EnvDataPort;\n\t\t\tport infrastructureStatusPort: InfrastructureStatusPort;\n\n\t\t\tperform transportJourney.provideTransport {\n\t\t\t\tin userCmd = userCmdPort.userCmd;\n\t\t\t\tin envData = envDataPort.envData;\n\t\t\t\tin infrastructureStatus = infrastructureStatusPort.infrastructureStatus;\n\t\t\t\tout rideStatus = rideStatusPort.rideStatus;\n\t\t\t\tout comfortLevel = comfortLevelPort.comfortLevel;\n\t\t\t\tout safetyStatus = safetyStatusPort.safetyStatus;\n\t\t\t}\n\t\t}\n\t\tpart environment {\n\t\t\tport envDataPort: ~EnvDataPort;\n\t\t\tperform transportJourney.provideEnvData {\n\t\t\t\tout envData = envDataPort.envData;\n\t\t\t}\n\t\t}\n\t\tpart infrastructure {\n\t\t\tport infrastructureStatusPort: ~InfrastructureStatusPort;\n\t\t\tperform transportJourney.provideInfrastructureStatus {\n\t\t\t\tout infrastructureStatus = infrastructureStatusPort.infrastructureStatus;\n\t\t\t}\n\t\t}\n\t}\n\n\taction transportJourney {\n\t\taction initiateRide { out userCmd: UserCmd; }\n\t\taction requestRide { out userCmd: UserCmd; }\n\t\tsuccession flow userCmdFlow from initiateRide.userCmd to provideTransport.userCmd;\n\t\tsuccession flow userCmdFlow2 from requestRide.userCmd to provideTransport.userCmd;\n\n\t\taction provideEnvData { out envData: EnvData; }\n\t\tsuccession flow envDataFlow from provideEnvData.envData to provideTransport.envData;\n\n\t\taction provideInfrastructureStatus { out infrastructureStatus: InfrastructureStatus; }\n\t\tsuccession flow infrastructureFlow from provideInfrastructureStatus.infrastructureStatus to provideTransport.infrastructureStatus;\n\n\t\taction provideTransport {\n\t\t\tin userCmd: UserCmd;\n\t\t\tin envData: EnvData;\n\t\t\tin infrastructureStatus: InfrastructureStatus;\n\t\t\tout rideStatus: RideStatus;\n\t\t\tout comfortLevel: ComfortLevel;\n\t\t\tout safetyStatus: SafetyStatus;\n\t\t}\n\t}\n}",
    "package 'TransportationSystem' {\n\tattribute def EnterCmd;\n\tattribute def ExitCmd;\n\tattribute def DriveCmd;\n\tattribute def RefuelCmd;\n\tattribute def EnvCondition;\n\tattribute def Location;\n\tattribute def OccupantStatus;\n\tattribute def FuelLevel;\n\n\tport def EnterPort {\n\t\tout enterCmd: EnterCmd;\n\t}\n\tport def ExitPort {\n\t\tout exitCmd: ExitCmd;\n\t}\n\tport def DrivePort {\n\t\tout driveCmd: DriveCmd;\n\t}\n\tport def RefuelPort {\n\t\tout refuelCmd: RefuelCmd;\n\t}\n\tport def EnvPort {\n\t\tout envCondition: EnvCondition;\n\t}\n\tport def LocationPort {\n\t\tout location: Location;\n\t}\n\tport def OccupantStatusPort {\n\t\tout occupantStatus: OccupantStatus;\n\t}\n\tport def FuelLevelPort {\n\t\tout fuelLevel: FuelLevel;\n\t}\n\n\tpart context {\n\t\tpart driver {\n\t\t\tport enterPort: EnterPort;\n\t\t\tport exitPort: ExitPort;\n\t\t\tport drivePort: DrivePort;\n\t\t\tport refuelPort: RefuelPort;\n\t\t\tperform transportScenario.enterVehicle {\n\t\t\t\tout enterCmd = enterPort.enterCmd;\n\t\t\t}\n\t\t\tperform transportScenario.exitVehicle {\n\t\t\t\tout exitCmd = exitPort.exitCmd;\n\t\t\t}\n\t\t\tperform transportScenario.operateVehicle {\n\t\t\t\tout driveCmd = drivePort.driveCmd;\n\t\t\t}\n\t\t\tperform transportScenario.refuelVehicle {\n\t\t\t\tout refuelCmd = refuelPort.refuelCmd;\n\t\t\t}\n\t\t}\n\t\tpart passenger[4] {\n\t\t\tport enterPort: EnterPort;\n\t\t\tport exitPort: ExitPort;\n\t\t\tperform transportScenario.enterVehicle {\n\t\t\t\tout enterCmd = enterPort.enterCmd;\n\t\t\t}\n\t\t\tperform transportScenario.exitVehicle {\n\t\t\t\tout exitCmd = exitPort.exitCmd;\n\t\t\t}\n\t\t}\n\t\tpart vehicle {\n\t\t\tport enterPort: ~EnterPort;\n\t\t\tport exitPort: ~ExitPort;\n\t\t\tport drivePort: ~DrivePort;\n\t\t\tport refuelPort: ~RefuelPort;\n\t\t\tport envPort: EnvPort;\n\t\t\tport locationPort: LocationPort;\n\t\t\tport occupantStatusPort: OccupantStatusPort;\n\t\t\tport fuelLevelPort: FuelLevelPort;\n\t\t\tperform transportScenario.receiveEnterCmd {\n\t\t\t\tin enterCmd = enterPort.enterCmd;\n\t\t\t\tout occupantStatus = occupantStatusPort.occupantStatus;\n\t\t\t}\n\t\t\tperform transportScenario.receiveExitCmd {\n\t\t\t\tin exitCmd = exitPort.exitCmd;\n\t\t\t\tout occupantStatus = occupantStatusPort.occupantStatus;\n\t\t\t}\n\t\t\tperform transportScenario.receiveDriveCmd {\n\t\t\t\tin driveCmd = drivePort.driveCmd;\n\t\t\t\tin envCondition = envPort.envCondition;\n\t\t\t\tout location = locationPort.location;\n\t\t\t}\n\t\t\tperform transportScenario.receiveRefuelCmd {\n\t\t\t\tin refuelCmd = refuelPort.refuelCmd;\n\t\t\t\tout fuelLevel = fuelLevelPort.fuelLevel;\n\t\t\t}\n\t\t}\n\t\tpart environment {\n\t\t\tport envPort: ~EnvPort;\n\t\t\tperform transportScenario.provideEnvCondition {\n\t\t\t\tout envCondition = envPort.envCondition;\n\t\t\t}\n\t\t}\n\t\tpart gasStation {\n\t\t\tport refuelPort: ~RefuelPort;\n\t\t\tperform transportScenario.provideRefuel {\n\t\t\t\tin refuelCmd = refuelPort.refuelCmd;\n\t\t\t}\n\t\t}\n\t}\n\n\taction transportScenario {\n\t\taction enterVehicle { out enterCmd: EnterCmd; }\n\t\taction exitVehicle { out exitCmd: ExitCmd; }\n\t\taction operateVehicle { out driveCmd: DriveCmd; }\n\t\taction refuelVehicle { out refuelCmd: RefuelCmd; }\n\t\taction provideEnvCondition { out envCondition: EnvCondition; }\n\t\taction provideRefuel { in refuelCmd: RefuelCmd; }\n\t\taction receiveEnterCmd { in enterCmd: EnterCmd; out occupantStatus: OccupantStatus; }\n\t\taction receiveExitCmd { in exitCmd: ExitCmd; out occupantStatus: OccupantStatus; }\n\t\taction receiveDriveCmd { in driveCmd: DriveCmd; in envCondition: EnvCondition; out location: Location; }\n\t\taction receiveRefuelCmd { in refuelCmd: RefuelCmd; out fuelLevel: FuelLevel; }\n\n\t\tsuccession flow enterFlow from enterVehicle.enterCmd to receiveEnterCmd.enterCmd;\n\t\tsuccession flow exitFlow from exitVehicle.exitCmd to receiveExitCmd.exitCmd;\n\t\tsuccession flow driveFlow from operateVehicle.driveCmd to receiveDriveCmd.driveCmd;\n\t\tsuccession flow envFlow from provideEnvCondition.envCondition to receiveDriveCmd.envCondition;\n\t\tsuccession flow refuelFlow from refuelVehicle.refuelCmd to provideRefuel.refuelCmd;\n\t\tsuccession flow refuelReceiveFlow from refuelVehicle.refuelCmd to receiveRefuelCmd.refuelCmd;\n\t}\n}",
    "package 'VehicleConfiguration' {\n\t\n\t// Engine and Transmission Types\n\tenumeration EngineType {\n\t\tliteral FourCylinder;\n\t\tliteral SixCylinder;\n\t}\n\t\n\tenumeration TransmissionType {\n\t\tliteral Manual;\n\t\tliteral Automatic;\n\t}\n\t\n\tenumeration CylinderDiameter {\n\t\tliteral Small;  // 70 mm\n\t\tliteral Large;  // 100 mm\n\t}\n\t\n\t// Cylinder definition\n\tpart def Cylinder {\n\t\tattribute diameter: CylinderDiameter;\n\t}\n\t\n\t// Engine definition\n\tpart def Engine {\n\t\tattribute engineType: EngineType;\n\t\tpart cylinders: Cylinder[*];\n\t\tconstraint engineCylinderCount {\n\t\t\tif engineType == EngineType::FourCylinder {\n\t\t\t\tcylinders->size() == 4;\n\t\t\t} else if engineType == EngineType::SixCylinder {\n\t\t\t\tcylinders->size() == 6;\n\t\t\t}\n\t\t}\n\t}\n\t\n\t// Transmission definition\n\tpart def Transmission {\n\t\tattribute transmissionType: TransmissionType;\n\t}\n\t\n\t// Vehicle definition with configuration constraints\n\tpart def Vehicle {\n\t\tpart engine: Engine;\n\t\tpart transmission: Transmission;\n\t\t\n\t\tconstraint validEngineTransmissionCombination {\n\t\t\t// Manual only with FourCylinder, SixCylinder only with Automatic\n\t\t\t(engine.engineType == EngineType::FourCylinder and transmission.transmissionType == TransmissionType::Manual)\n\t\t\tor\n\t\t\t(engine.engineType == EngineType::FourCylinder and transmission.transmissionType == TransmissionType::Automatic)\n\t\t\tor\n\t\t\t(engine.engineType == EngineType::SixCylinder and transmission.transmissionType == TransmissionType::Automatic);\n\t\t}\n\t\t\n\t\tconstraint prohibitManualWithSixCylinder {\n\t\t\tnot (engine.engineType == EngineType::SixCylinder and transmission.transmissionType == TransmissionType::Manual);\n\t\t}\n\t}\n\t\n\t// System context for configuration management\n\tpart context {\n\t\tpart vehicle: Vehicle;\n\t}\n}",
    "package 'ConfigurableEngine' {\n\tattribute def CylinderCount {\n\t\tallowedValues: { 4, 6 };\n\t}\n\tattribute def CylinderDiameter {\n\t\tallowedValues: { 70, 100 }; // in mm\n\t}\n\tpart def Cylinder {\n\t\tattribute diameter: CylinderDiameter;\n\t}\n\tpart def Engine {\n\t\tattribute cylinderCount: CylinderCount;\n\t\tpart cylinders: Cylinder[cylinderCount];\n\t}\n\tpart context {\n\t\tpart user {\n\t\t\tperform configureEngine.selectConfiguration {\n\t\t\t\tout cylinderCount: CylinderCount;\n\t\t\t\tout cylinderDiameter: CylinderDiameter;\n\t\t\t}\n\t\t}\n\t\tpart engine: Engine {\n\t\t\tcylinderCount = user.configureEngine.selectConfiguration.cylinderCount;\n\t\t\tfor i in 1..cylinderCount {\n\t\t\t\tcylinders[i].diameter = user.configureEngine.selectConfiguration.cylinderDiameter;\n\t\t\t}\n\t\t}\n\t}\n\taction configureEngine {\n\t\taction selectConfiguration {\n\t\t\tout cylinderCount: CylinderCount;\n\t\t\tout cylinderDiameter: CylinderDiameter;\n\t\t}\n\t}\n}\n",
    "package 'AutomotiveConfiguration' {\n\n\t// Engine and Cylinder Definitions\n\tblock Cylinder {\n\t\tattribute diameter: mm;\n\t}\n\t\n\tblock Engine {\n\t\tattribute cylinderCount: Integer;\n\t\tpart cylinders: Cylinder[cylinderCount];\n\t}\n\t\n\tblock Engine4Cyl extends Engine {\n\t\tconstant cylinderCount = 4;\n\t\tpart cylinders: Cylinder[4];\n\t}\n\t\n\tblock Engine6Cyl extends Engine {\n\t\tconstant cylinderCount = 6;\n\t\tpart cylinders: Cylinder[6];\n\t}\n\t\n\t// Cylinder Diameter Options\n\tenum mm { mm_70 = 70, mm_100 = 100; }\n\t\n\t// Transmission Definitions\n\tblock Transmission {}\n\tblock ManualTransmission extends Transmission {}\n\tblock AutomaticTransmission extends Transmission {}\n\t\n\t// Vehicle Definition\n\tblock Vehicle {\n\t\tpart engine: Engine;\n\t\tpart transmission: Transmission;\n\t}\n\t\n\t// Configuration Constraints\n\tconstraint block EngineTransmissionConstraint {\n\t\tparameter engine: Engine;\n\t\tparameter transmission: Transmission;\n\t\tconstraint {\n\t\t\t(if engine.isKindOf(Engine4Cyl)) implies transmission.isKindOf(ManualTransmission);\n\t\t\t(if engine.isKindOf(Engine6Cyl)) implies transmission.isKindOf(AutomaticTransmission);\n\t\t}\n\t}\n\t\n\t// Cylinder Diameter Constraint\n\tconstraint block CylinderDiameterConstraint {\n\t\tparameter cylinders: Cylinder[*];\n\t\tconstraint {\n\t\t\tfor (c in cylinders) {\n\t\t\t\t(c.diameter == mm.mm_70) or (c.diameter == mm.mm_100);\n\t\t\t}\n\t\t}\n\t}\n\t\n\t// Context for Configuration\n\tpart context {\n\t\tpart vehicle: Vehicle;\n\t\tapply EngineTransmissionConstraint(engine=vehicle.engine, transmission=vehicle.transmission);\n\t\tapply CylinderDiameterConstraint(cylinders=vehicle.engine.cylinders);\n\t}\n}",
    "package 'SystemAssembly' {\n\tattribute def MessageFormat;\n\tattribute def DataFormat;\n\n\tport def MessagePort {\n\t\tin message: MessageFormat;\n\t}\n\tport def DataPort {\n\t\tin data: DataFormat;\n\t}\n\n\tpart context {\n\t\tpart systemAssembly {\n\t\t\tpart computerSubsystem {\n\t\t\t\tport messagePort: MessagePort;\n\t\t\t\tport dataPort: DataPort;\n\t\t\t\tperform softwareDesign.utilizeFunctions {\n\t\t\t\t\tin message = messagePort.message;\n\t\t\t\t\tin data = dataPort.data;\n\t\t\t\t}\n\t\t\t}\n\t\t\tpart storageSubsystem {\n\t\t\t\tport messagePort: ~MessagePort;\n\t\t\t\tport dataPort: ~DataPort;\n\t\t\t\tperform softwareDesign.accessFormats {\n\t\t\t\t\tin message = messagePort.message;\n\t\t\t\t\tin data = dataPort.data;\n\t\t\t\t}\n\t\t\t}\n\t\t\tinterface computerToStorage connect computerSubsystem.messagePort to storageSubsystem.messagePort {\n\t\t\t\tref flow references softwareDesign.messageFlow\n\t\t\t\t\tfrom source.message to target.message;\n\t\t\t}\n\t\t\tinterface computerToStorageData connect computerSubsystem.dataPort to storageSubsystem.dataPort {\n\t\t\t\tref flow references softwareDesign.dataFlow\n\t\t\t\t\tfrom source.data to target.data;\n\t\t\t}\n\t\t}\n\t}\n\n\taction softwareDesign {\n\t\tattribute messageFormat: MessageFormat;\n\t\tattribute dataFormat: DataFormat;\n\n\t\taction defineMessageFormat { out message: MessageFormat; }\n\t\taction defineDataFormat { out data: DataFormat; }\n\n\t\tsuccession flow messageFlow from defineMessageFormat.message to utilizeFunctions.message;\n\t\tsuccession flow dataFlow from defineDataFormat.data to utilizeFunctions.data;\n\n\t\taction utilizeFunctions { in message: MessageFormat; in data: DataFormat; }\n\t\taction accessFormats { in message: MessageFormat; in data: DataFormat; }\n\t}\n\n\trequirement systemIntegration {\n\t\ttext \"The software and hardware of the system must work together seamlessly to ensure efficient, reliable, and compliant information storage, transmission, and processing according to the required data structure specifications.\"\n\t}\n}",
    "package 'PowertrainSystem' {\n\tattribute def Power;\n\tattribute def Torque;\n\n\tport def PowerPort {\n\t\tout power: Power;\n\t}\n\tport def TorquePort {\n\t\tout torque: Torque;\n\t}\n\n\tpart context {\n\t\tpart logicalLayer {\n\t\t\tpart powerProvider {\n\t\t\t\tport powerPort: PowerPort;\n\t\t\t\tperform managePowertrain.providePower {\n\t\t\t\t\tout power = powerPort.power;\n\t\t\t\t}\n\t\t\t}\n\t\t\tpart torqueGenerator {\n\t\t\t\tport powerPort: ~PowerPort;\n\t\t\t\tport torquePort: TorquePort;\n\t\t\t\tperform managePowertrain.generateTorque {\n\t\t\t\t\tin power = powerPort.power;\n\t\t\t\t\tout torque = torquePort.torque;\n\t\t\t\t}\n\t\t\t}\n\t\t\tinterface logicalPowerFlow connect powerProvider.powerPort to torqueGenerator.powerPort {\n\t\t\t\tref flow references managePowertrain.powerFlow\n\t\t\t\t\tfrom source.power to target.power;\n\t\t\t}\n\t\t}\n\t\tpart physicalLayer {\n\t\t\tpart powerUnit {\n\t\t\t\tport powerPort: ~PowerPort;\n\t\t\t\tport torquePort: ~TorquePort;\n\t\t\t\tperform managePowertrain.outputPowerAndTorque {\n\t\t\t\t\tin power = powerPort.power;\n\t\t\t\t\tout torque = torquePort.torque;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tinterface logicalToPhysicalMapping map logicalLayer.torqueGenerator to physicalLayer.powerUnit {\n\t\t\tref mapping references managePowertrain.mappingRelation\n\t\t\t\tfrom source.torque to target.torque;\n\t\t}\n\t}\n\n\taction managePowertrain {\n\t\taction providePower { out power: Power; }\n\t\tsuccession flow powerFlow from providePower.power to generateTorque.power;\n\t\taction generateTorque { in power: Power; out torque: Torque; }\n\t\tsuccession flow torqueFlow from generateTorque.torque to outputPowerAndTorque.torque;\n\t\taction outputPowerAndTorque { in power: Power; out torque: Torque; }\n\t\tmapping mappingRelation from generateTorque.torque to outputPowerAndTorque.torque;\n\t}\n}",
    "package 'PowerTransmissionSystem' {\n\n\t// Logical Layer\n\tattribute def Power;\n\tattribute def Torque;\n\n\tport def PowerPort {\n\t\tout power: Power;\n\t}\n\tport def TorquePort {\n\t\tout torque: Torque;\n\t}\n\n\tpart context {\n\t\t// Logical System\n\t\tpart logicalSystem {\n\t\t\tport powerPort: PowerPort;\n\t\t\tport torquePort: TorquePort;\n\t\t\tperform powerAndTorqueManagement.deliverPower {\n\t\t\t\tout power = powerPort.power;\n\t\t\t}\n\t\t\tperform powerAndTorqueManagement.generateTorque {\n\t\t\t\tout torque = torquePort.torque;\n\t\t\t}\n\t\t}\n\n\t\t// Logical Torque Generator\n\t\tpart torqueGenerator {\n\t\t\tport torquePort: ~TorquePort;\n\t\t\tperform powerAndTorqueManagement.generateTorque {\n\t\t\t\tout torque = torquePort.torque;\n\t\t\t}\n\t\t}\n\n\t\t// Logical Connections\n\t\tinterface logicalTorqueFlow connect torqueGenerator.torquePort to logicalSystem.torquePort {\n\t\t\tref flow references powerAndTorqueManagement.torqueFlow\n\t\t\t\tfrom source.torque to target.torque;\n\t\t}\n\t\tinterface logicalPowerFlow connect logicalSystem.powerPort to powertrain.powerPort {\n\t\t\tref flow references powerAndTorqueManagement.powerFlow\n\t\t\t\tfrom source.power to target.power;\n\t\t}\n\n\t\t// Physical Layer\n\t\tpart powertrain {\n\t\t\tport powerPort: ~PowerPort;\n\t\t\tport torquePort: TorquePort;\n\t\t\tpart engine {\n\t\t\t\tport torquePort: TorquePort;\n\t\t\t\tperform powerAndTorqueManagement.generateTorque {\n\t\t\t\t\tout torque = torquePort.torque;\n\t\t\t\t}\n\t\t\t}\n\t\t\t// Allocation: torqueGenerator allocated to powertrain\n\t\t\tallocate torqueGenerator to powertrain;\n\t\t\t// Allocation: generateTorque action allocated to engine\n\t\t\tallocate powerAndTorqueManagement.generateTorque to engine;\n\t\t}\n\n\t\t// Physical Connections\n\t\tinterface physicalTorqueFlow connect powertrain.engine.torquePort to powertrain.torquePort {\n\t\t\tref flow references powerAndTorqueManagement.torqueFlow\n\t\t\t\tfrom source.torque to target.torque;\n\t\t}\n\t}\n\n\taction powerAndTorqueManagement {\n\t\taction deliverPower { out power: Power; }\n\t\taction generateTorque { out torque: Torque; }\n\t\tsuccession flow powerFlow from deliverPower.power to generateTorque.power;\n\t\tsuccession flow torqueFlow from generateTorque.torque;\n\t}\n}",
    "package 'VehicleFeatureAnnotationSystem' {\n\tattribute def SafetyFeature;\n\tattribute def SecurityFeature;\n\tattribute def FeatureType {\n\t\tliteral safety;\n\t\tliteral security;\n\t}\n\tattribute def FeatureAssignment {\n\t\tfeatureType: FeatureType;\n\t}\n\tport def FeatureAnnotationPort {\n\t\tout featureAssignment: FeatureAssignment;\n\t}\n\tpart context {\n\t\tpart vehicle {\n\t\t\tpart interior: InteriorAssembly;\n\t\t\tpart body: BodyAssembly;\n\t\t}\n\t}\n\tblock InteriorAssembly {\n\t\tpart seatBelt: SeatBelt {\n\t\t\tport featureAnnotationPort: FeatureAnnotationPort;\n\t\t\tperform assignFeature {\n\t\t\t\tout featureAssignment = FeatureAssignment { featureType = FeatureType.safety; };\n\t\t\t}\n\t\t}\n\t\tpart frontSeat: FrontSeat;\n\t\tpart driverAirbag: DriverAirbag {\n\t\t\tport featureAnnotationPort: FeatureAnnotationPort;\n\t\t\tperform assignFeature {\n\t\t\t\tout featureAssignment = FeatureAssignment { featureType = FeatureType.safety; };\n\t\t\t}\n\t\t}\n\t\tpart alarmSystem: AlarmSystem {\n\t\t\tport featureAnnotationPort: FeatureAnnotationPort;\n\t\t\tperform assignFeature {\n\t\t\t\tout featureAssignment = FeatureAssignment { featureType = FeatureType.security; };\n\t\t\t}\n\t\t}\n\t}\n\tblock BodyAssembly {\n\t\tpart bodyShell: BodyShell;\n\t\tpart bumper: Bumper {\n\t\t\tport featureAnnotationPort: FeatureAnnotationPort;\n\t\t\tperform assignFeature {\n\t\t\t\tout featureAssignment = FeatureAssignment { featureType = FeatureType.safety; };\n\t\t\t}\n\t\t}\n\t\tpart keylessEntryDevice: KeylessEntryDevice {\n\t\t\tport featureAnnotationPort: FeatureAnnotationPort;\n\t\t\tperform assignFeature {\n\t\t\t\tout featureAssignment = FeatureAssignment { featureType = FeatureType.security; };\n\t\t\t}\n\t\t}\n\t}\n\tblock SeatBelt {}\n\tblock FrontSeat {}\n\tblock DriverAirbag {}\n\tblock AlarmSystem {}\n\tblock BodyShell {}\n\tblock Bumper {}\n\tblock KeylessEntryDevice {}\n\n\trequirement def SafetyRequirement {\n\t\ttext = \"The vehicle shall be equipped with basic safety features including seat belts, driver airbags, and bumpers.\";\n\t}\n\trequirement def SecurityRequirement {\n\t\ttext = \"The vehicle shall be equipped with security features including anti-theft alarms and keyless entry systems.\";\n\t}\n\trequirement def FeatureDistributionRequirement {\n\t\ttext = \"The system shall indicate the distribution of safety and security components within the vehicle structure.\";\n\t}\n\trequirement def UserConvenienceRequirement {\n\t\ttext = \"The system shall support user convenience and property security.\";\n\t}\n}",
    "package 'VehicleDynamicsSimulation' {\n\tattribute def InitialVelocity;\n\tattribute def InitialPosition;\n\tattribute def Acceleration;\n\tattribute def TimeStep;\n\tattribute def Velocity;\n\tattribute def Position;\n\tattribute def SimulationResults;\n\n\tport def UserInputPort {\n\t\tin initialVelocity: InitialVelocity;\n\t\tin initialPosition: InitialPosition;\n\t\tin acceleration: Acceleration;\n\t\tin timeStep: TimeStep;\n\t}\n\tport def SimulationOutputPort {\n\t\tout velocity: Velocity;\n\t\tout position: Position;\n\t\tout simulationResults: SimulationResults;\n\t}\n\n\tpart context {\n\t\tpart user {\n\t\t\tport userInputPort: UserInputPort;\n\t\t\tperform simulateVehicleDynamics.provideInputs {\n\t\t\t\tout initialVelocity = userInputPort.initialVelocity;\n\t\t\t\tout initialPosition = userInputPort.initialPosition;\n\t\t\t\tout acceleration = userInputPort.acceleration;\n\t\t\t\tout timeStep = userInputPort.timeStep;\n\t\t\t}\n\t\t}\n\t\tinterface userToSimulation connect user.userInputPort to simulation.userInputPort {\n\t\t\tref flow references simulateVehicleDynamics.inputFlow\n\t\t\t\tfrom source.initialVelocity to target.initialVelocity,\n\t\t\t\tfrom source.initialPosition to target.initialPosition,\n\t\t\t\tfrom source.acceleration to target.acceleration,\n\t\t\t\tfrom source.timeStep to target.timeStep;\n\t\t}\n\t\tpart simulation {\n\t\t\tport userInputPort: ~UserInputPort;\n\t\t\tport simulationOutputPort: SimulationOutputPort;\n\t\t\tperform simulateVehicleDynamics.runSimulation {\n\t\t\t\tin initialVelocity = userInputPort.initialVelocity;\n\t\t\t\tin initialPosition = userInputPort.initialPosition;\n\t\t\t\tin acceleration = userInputPort.acceleration;\n\t\t\t\tin timeStep = userInputPort.timeStep;\n\t\t\t\tout velocity = simulationOutputPort.velocity;\n\t\t\t\tout position = simulationOutputPort.position;\n\t\t\t\tout simulationResults = simulationOutputPort.simulationResults;\n\t\t\t}\n\t\t\tperform simulateVehicleDynamics.integrateWithModelCenter {\n\t\t\t\tin initialVelocity;\n\t\t\t\tin initialPosition;\n\t\t\t\tin acceleration;\n\t\t\t\tin timeStep;\n\t\t\t\tout velocity;\n\t\t\t\tout position;\n\t\t\t\tout simulationResults;\n\t\t\t}\n\t\t}\n\t\tinterface simulationToUser connect simulation.simulationOutputPort to user.simulationOutputPort {\n\t\t\tref flow references simulateVehicleDynamics.outputFlow\n\t\t\t\tfrom source.velocity to target.velocity,\n\t\t\t\tfrom source.position to target.position,\n\t\t\t\tfrom source.simulationResults to target.simulationResults;\n\t\t}\n\t}\n\n\taction simulateVehicleDynamics {\n\t\taction provideInputs {\n\t\t\tout initialVelocity: InitialVelocity;\n\t\t\tout initialPosition: InitialPosition;\n\t\t\tout acceleration: Acceleration;\n\t\t\tout timeStep: TimeStep;\n\t\t}\n\t\tsuccession flow inputFlow from provideInputs.initialVelocity to runSimulation.initialVelocity,\n\t\t\tfrom provideInputs.initialPosition to runSimulation.initialPosition,\n\t\t\tfrom provideInputs.acceleration to runSimulation.acceleration,\n\t\t\tfrom provideInputs.timeStep to runSimulation.timeStep;\n\t\taction runSimulation {\n\t\t\tin initialVelocity: InitialVelocity;\n\t\t\tin initialPosition: InitialPosition;\n\t\t\tin acceleration: Acceleration;\n\t\t\tin timeStep: TimeStep;\n\t\t\tout velocity: Velocity;\n\t\t\tout position: Position;\n\t\t\tout simulationResults: SimulationResults;\n\t\t}\n\t\taction integrateWithModelCenter {\n\t\t\tin initialVelocity: InitialVelocity;\n\t\t\tin initialPosition: InitialPosition;\n\t\t\tin acceleration: Acceleration;\n\t\t\tin timeStep: TimeStep;\n\t\t\tout velocity: Velocity;\n\t\t\tout position: Position;\n\t\t\tout simulationResults: SimulationResults;\n\t\t}\n\t\tsuccession flow outputFlow from runSimulation.velocity to provideOutputs.velocity,\n\t\t\tfrom runSimulation.position to provideOutputs.position,\n\t\t\tfrom runSimulation.simulationResults to provideOutputs.simulationResults;\n\t\taction provideOutputs {\n\t\t\tin velocity: Velocity;\n\t\t\tin position: Position;\n\t\t\tin simulationResults: SimulationResults;\n\t\t}\n\t}\n}",
    "package 'CarSafetyCompliance' {\n\n\tannotation def Safety;\n\n\tpackage 'SafetyFeatures' {\n\t\tpart def SeatBelt @Safety {\n\t\t\tattribute isMandatory: Boolean;\n\t\t}\n\t\tpart def Airbag @Safety {\n\t\t\tattribute isMandatory: Boolean;\n\t\t}\n\t\tpart def Bumper @Safety {\n\t\t\tattribute isMandatory: Boolean;\n\t\t}\n\t\tpart def ABS @Safety {\n\t\t\tattribute isMandatory: Boolean;\n\t\t}\n\t}\n\n\tpackage 'MandatorySafetyFeatures' {\n\t\timport SafetyFeatures.SeatBelt;\n\t\timport SafetyFeatures.Bumper;\n\n\t\tpart def MandatorySeatBelt extends SeatBelt {\n\t\t\tisMandatory = true;\n\t\t}\n\t\tpart def MandatoryBumper extends Bumper {\n\t\t\tisMandatory = true;\n\t\t}\n\t}\n\n\tpackage 'Car' {\n\t\tpart def Wheel {\n\t\t}\n\t\tpart def ABS extends SafetyFeatures.ABS {\n\t\t\tisMandatory = false;\n\t\t}\n\t\tpart def Airbag extends SafetyFeatures.Airbag {\n\t\t\tisMandatory = false;\n\t\t}\n\t\tpart def KeylessEntrySystem {\n\t\t}\n\t\tpart def SeatBelt1 extends SafetyFeatures.SeatBelt {\n\t\t\tisMandatory = true;\n\t\t}\n\t\tpart def SeatBelt2 extends SafetyFeatures.SeatBelt {\n\t\t\tisMandatory = true;\n\t\t}\n\t\tpart def Bumper extends SafetyFeatures.Bumper {\n\t\t\tisMandatory = true;\n\t\t}\n\t\tpart context CarSystem {\n\t\t\tpart seatBelt1: SeatBelt1;\n\t\t\tpart seatBelt2: SeatBelt2;\n\t\t\tpart airbag: Airbag;\n\t\t\tpart bumper: Bumper;\n\t\t\tpart wheel1: Wheel;\n\t\t\tpart wheel2: Wheel;\n\t\t\tpart abs: ABS;\n\t\t\tpart keylessEntry: KeylessEntrySystem;\n\t\t}\n\t}\n}",
    "package 'VehicleSafetyCompliance' {\n\n\t// Safety Feature Kind Enumeration\n\tenum SafetyFeatureKind {\n\t\tmandatory,\n\t\toptional\n\t}\n\n\t// Abstract Safety Feature\n\tfeature def SafetyFeature {\n\t\tattribute kind: SafetyFeatureKind;\n\t}\n\n\t// Vehicle Components\n\tpart def Vehicle {\n\t\tpart interior: Interior;\n\t\tpart body: Body;\n\t\tpart chassis: Chassis;\n\t}\n\n\t// Interior with Seat Belts and Airbag\n\tpart def Interior {\n\t\tpart seatBelt1: SeatBelt;\n\t\tpart seatBelt2: SeatBelt;\n\t\tpart driverAirbag: DriverAirbag;\n\t}\n\n\tpart def SeatBelt {\n\t\tfeature seatBeltFeature: SafetyFeature = SeatBeltFeature;\n\t}\n\n\tfeature def SeatBeltFeature: SafetyFeature {\n\t\tkind = SafetyFeatureKind::mandatory;\n\t}\n\n\tpart def DriverAirbag {\n\t\tfeature airbagFeature: SafetyFeature = DriverAirbagFeature;\n\t}\n\n\tfeature def DriverAirbagFeature: SafetyFeature {\n\t\tkind = SafetyFeatureKind::optional;\n\t}\n\n\t// Body with Bumper and Keyless Entry\n\tpart def Body {\n\t\tpart bumper: Bumper;\n\t\tpart keylessEntry: KeylessEntrySystem;\n\t}\n\n\tpart def Bumper {\n\t\tfeature bumperFeature: SafetyFeature = BumperFeature;\n\t}\n\n\tfeature def BumperFeature: SafetyFeature {\n\t\tkind = SafetyFeatureKind::mandatory;\n\t}\n\n\tpart def KeylessEntrySystem {\n\t\tfeature keylessEntryFeature: SafetyFeature = KeylessEntryFeature;\n\t}\n\n\tfeature def KeylessEntryFeature: SafetyFeature {\n\t\tkind = SafetyFeatureKind::optional;\n\t}\n\n\t// Chassis with Tires and ABS\n\tpart def Chassis {\n\t\tpart tire1: Tire;\n\t\tpart tire2: Tire;\n\t\tpart tire3: Tire;\n\t\tpart tire4: Tire;\n\t\tpart abs: ABS;\n\t}\n\n\tpart def Tire {\n\t\t// Tires are not explicitly safety features in this context\n\t}\n\n\tpart def ABS {\n\t\tfeature absFeature: SafetyFeature = ABSFeature;\n\t}\n\n\tfeature def ABSFeature: SafetyFeature {\n\t\tkind = SafetyFeatureKind::optional;\n\t}\n\n\t// Safety Management System\n\tpart def SafetyComplianceSystem {\n\t\tpart vehicle: Vehicle;\n\t\tperform manageSafetyFeatures {\n\t\t\tin vehicle;\n\t\t\tout complianceStatus: ComplianceStatus;\n\t\t}\n\t}\n\n\t// Compliance Status\n\tattribute def ComplianceStatus;\n\n\t// Safety Feature Registry and Categorization\n\taction manageSafetyFeatures {\n\t\tin vehicle: Vehicle;\n\t\tout complianceStatus: ComplianceStatus;\n\t\taction categorizeFeatures {\n\t\t\tin vehicle;\n\t\t\tout mandatoryFeatures: SafetyFeature[];\n\t\t\tout optionalFeatures: SafetyFeature[];\n\t\t}\n\t}\n\n}",
    "package 'RiskAndFailureManagement' {\n\tattribute def Situation;\n\tattribute def Cause;\n\tattribute def Failure;\n\tattribute def Probability;\n\tattribute def SeverityLevel;\n\tattribute def RiskScenario;\n\tattribute def CausalRelation;\n\n\tport def SituationPort {\n\t\tout situation: Situation;\n\t}\n\tport def CausePort {\n\t\tout cause: Cause;\n\t}\n\tport def FailurePort {\n\t\tout failure: Failure;\n\t}\n\tport def ProbabilityPort {\n\t\tout probability: Probability;\n\t}\n\tport def SeverityPort {\n\t\tout severity: SeverityLevel;\n\t}\n\tport def RiskScenarioPort {\n\t\tout riskScenario: RiskScenario;\n\t}\n\tport def CausalRelationPort {\n\t\tout causalRelation: CausalRelation;\n\t}\n\n\tpart context {\n\t\tpart user {\n\t\t\tport riskScenarioPort: RiskScenarioPort;\n\t\t\tperform riskAnalysis.defineRiskScenario {\n\t\t\t\tout riskScenario = riskScenarioPort.riskScenario;\n\t\t\t}\n\t\t}\n\t\tpart riskManager {\n\t\t\tport riskScenarioPort: ~RiskScenarioPort;\n\t\t\tport situationPort: SituationPort;\n\t\t\tport causePort: CausePort;\n\t\t\tport failurePort: FailurePort;\n\t\t\tport probabilityPort: ProbabilityPort;\n\t\t\tport severityPort: SeverityPort;\n\t\t\tport causalRelationPort: CausalRelationPort;\n\n\t\t\tperform riskAnalysis.modelSituation {\n\t\t\t\tout situation = situationPort.situation;\n\t\t\t}\n\t\t\tperform riskAnalysis.identifyCause {\n\t\t\t\tout cause = causePort.cause;\n\t\t\t\tout probability = probabilityPort.probability;\n\t\t\t}\n\t\t\tperform riskAnalysis.identifyFailure {\n\t\t\t\tout failure = failurePort.failure;\n\t\t\t\tout severity = severityPort.severity;\n\t\t\t}\n\t\t\tperform riskAnalysis.establishCausalRelation {\n\t\t\t\tout causalRelation = causalRelationPort.causalRelation;\n\t\t\t}\n\t\t\tperform riskAnalysis.analyzeScenario {\n\t\t\t\tin riskScenario = riskScenarioPort.riskScenario;\n\t\t\t\tin situation = situationPort.situation;\n\t\t\t\tin cause = causePort.cause;\n\t\t\t\tin failure = failurePort.failure;\n\t\t\t\tin probability = probabilityPort.probability;\n\t\t\t\tin severity = severityPort.severity;\n\t\t\t\tin causalRelation = causalRelationPort.causalRelation;\n\t\t\t}\n\t\t}\n\t}\n\n\taction riskAnalysis {\n\t\taction defineRiskScenario { out riskScenario: RiskScenario; }\n\t\taction modelSituation { out situation: Situation; }\n\t\taction identifyCause { out cause: Cause; out probability: Probability; }\n\t\taction identifyFailure { out failure: Failure; out severity: SeverityLevel; }\n\t\taction establishCausalRelation { out causalRelation: CausalRelation; }\n\t\taction analyzeScenario {\n\t\t\tin riskScenario: RiskScenario;\n\t\t\tin situation: Situation;\n\t\t\tin cause: Cause;\n\t\t\tin failure: Failure;\n\t\t\tin probability: Probability;\n\t\t\tin severity: SeverityLevel;\n\t\t\tin causalRelation: CausalRelation;\n\t\t}\n\t\tsuccession flow scenarioFlow from defineRiskScenario.riskScenario to analyzeScenario.riskScenario;\n\t\tsuccession flow situationFlow from modelSituation.situation to analyzeScenario.situation;\n\t\tsuccession flow causeFlow from identifyCause.cause to analyzeScenario.cause;\n\t\tsuccession flow probabilityFlow from identifyCause.probability to analyzeScenario.probability;\n\t\tsuccession flow failureFlow from identifyFailure.failure to analyzeScenario.failure;\n\t\tsuccession flow severityFlow from identifyFailure.severity to analyzeScenario.severity;\n\t\tsuccession flow causalRelationFlow from establishCausalRelation.causalRelation to analyzeScenario.causalRelation;\n\t}\n}",
    "package 'RiskMetadataManagement' {\n\tattribute def Probability;\n\tattribute def SeverityLevel;\n\tattribute def Description;\n\t\n\ttype def Scenario {\n\t\tattribute description: Description;\n\t\tattribute id: String;\n\t}\n\t\n\ttype def Cause {\n\t\tattribute description: Description;\n\t\tattribute probability: Probability;\n\t\tattribute id: String;\n\t}\n\t\n\ttype def Failure {\n\t\tattribute description: Description;\n\t\tattribute severity: SeverityLevel;\n\t\tattribute id: String;\n\t}\n\t\n\ttype def CausalRelationship {\n\t\tattribute sourceScenario: Scenario;\n\t\tattribute targetScenario: Scenario;\n\t\tattribute description: Description;\n\t}\n\t\n\ttype def RiskScenario {\n\t\tattribute scenarios: Set<Scenario>;\n\t\tattribute causes: Set<Cause>;\n\t\tattribute failures: Set<Failure>;\n\t\tattribute description: Description;\n\t}\n\t\n\tpart context {\n\t\tpart user {\n\t\t\tperform riskModeling.identifyScenario {\n\t\t\t\tout scenario: Scenario;\n\t\t\t}\n\t\t\tperform riskModeling.describeScenario {\n\t\t\t\tin scenario: Scenario;\n\t\t\t\tout description: Description;\n\t\t\t}\n\t\t\tperform riskModeling.identifyCause {\n\t\t\t\tin scenario: Scenario;\n\t\t\t\tout cause: Cause;\n\t\t\t}\n\t\t\tperform riskModeling.associateFailure {\n\t\t\t\tin scenario: Scenario;\n\t\t\t\tout failure: Failure;\n\t\t\t}\n\t\t\tperform riskModeling.defineCausalRelationship {\n\t\t\t\tin sourceScenario: Scenario;\n\t\t\t\tin targetScenario: Scenario;\n\t\t\t\tout causalRelationship: CausalRelationship;\n\t\t\t}\n\t\t\tperform riskModeling.composeRiskScenario {\n\t\t\t\tin scenarios: Set<Scenario>;\n\t\t\t\tin causes: Set<Cause>;\n\t\t\t\tin failures: Set<Failure>;\n\t\t\t\tout riskScenario: RiskScenario;\n\t\t\t}\n\t\t}\n\t}\n\t\n\taction riskModeling {\n\t\taction identifyScenario { out scenario: Scenario; }\n\t\taction describeScenario { in scenario: Scenario; out description: Description; }\n\t\taction identifyCause { in scenario: Scenario; out cause: Cause; }\n\t\taction associateFailure { in scenario: Scenario; out failure: Failure; }\n\t\taction defineCausalRelationship { \n\t\t\tin sourceScenario: Scenario; \n\t\t\tin targetScenario: Scenario; \n\t\t\tout causalRelationship: CausalRelationship; \n\t\t}\n\t\taction composeRiskScenario { \n\t\t\tin scenarios: Set<Scenario>; \n\t\t\tin causes: Set<Cause>; \n\t\t\tin failures: Set<Failure>; \n\t\t\tout riskScenario: RiskScenario; \n\t\t}\n\t}\n\t\n\tinterface metadataIntegration {\n\t\tattribute compatibleWith: Set<String>;\n\t}\n}",
    "package 'RiskAnalysisSystem' {\n\tattribute def BatteryLevel;\n\tattribute def BatteryFailureProbability;\n\tattribute def SeverityLevel;\n\tattribute def Risk;\n\tattribute def FailureConsequence;\n\tattribute def Threshold;\n\tattribute def Duration;\n\tattribute def State;\n\tattribute def Alert;\n\n\tport def BatteryLevelPort {\n\t\tout batteryLevel: BatteryLevel;\n\t}\n\tport def BatteryFailureProbabilityPort {\n\t\tout batteryFailureProbability: BatteryFailureProbability;\n\t}\n\tport def SeverityLevelPort {\n\t\tout severityLevel: SeverityLevel;\n\t}\n\tport def AlertPort {\n\t\tout alert: Alert;\n\t}\n\n\tpart context {\n\t\tpart equipment {\n\t\t\tpart battery {\n\t\t\t\tport batteryLevelPort: BatteryLevelPort;\n\t\t\t\tport batteryFailureProbabilityPort: BatteryFailureProbabilityPort;\n\t\t\t\tperform riskAnalysis.monitorBatteryLevel {\n\t\t\t\t\tout batteryLevel = batteryLevelPort.batteryLevel;\n\t\t\t\t}\n\t\t\t\tperform riskAnalysis.estimateBatteryFailureProbability {\n\t\t\t\t\tout batteryFailureProbability = batteryFailureProbabilityPort.batteryFailureProbability;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tpart riskAnalysisSystem {\n\t\t\tport batteryLevelPort: ~BatteryLevelPort;\n\t\t\tport batteryFailureProbabilityPort: ~BatteryFailureProbabilityPort;\n\t\t\tport severityLevelPort: SeverityLevelPort;\n\t\t\tport alertPort: AlertPort;\n\t\t\tperform riskAnalysis.detectBatteryAgingRisk {\n\t\t\t\tin batteryFailureProbability = batteryFailureProbabilityPort.batteryFailureProbability;\n\t\t\t\tout risk: Risk;\n\t\t\t}\n\t\t\tperform riskAnalysis.identifyLowBatteryRisk {\n\t\t\t\tin batteryLevel = batteryLevelPort.batteryLevel;\n\t\t\t\tin risk: Risk;\n\t\t\t\tout state: State;\n\t\t\t}\n\t\t\tperform riskAnalysis.analyzeLowBatteryState {\n\t\t\t\tin state: State;\n\t\t\t\tin duration: Duration;\n\t\t\t\tout failureConsequence: FailureConsequence;\n\t\t\t}\n\t\t\tperform riskAnalysis.assignSeverityLevel {\n\t\t\t\tin failureConsequence: FailureConsequence;\n\t\t\t\tout severityLevel = severityLevelPort.severityLevel;\n\t\t\t}\n\t\t\tperform riskAnalysis.generateAlert {\n\t\t\t\tin severityLevel = severityLevelPort.severityLevel;\n\t\t\t\tout alert = alertPort.alert;\n\t\t\t}\n\t\t}\n\t\tinterface batteryLevelConnection connect equipment.battery.batteryLevelPort to riskAnalysisSystem.batteryLevelPort {\n\t\t\tref flow references riskAnalysis.batteryLevelFlow\n\t\t\t\tfrom source.batteryLevel to target.batteryLevel;\n\t\t}\n\t\tinterface batteryFailureProbabilityConnection connect equipment.battery.batteryFailureProbabilityPort to riskAnalysisSystem.batteryFailureProbabilityPort {\n\t\t\tref flow references riskAnalysis.batteryFailureProbabilityFlow\n\t\t\t\tfrom source.batteryFailureProbability to target.batteryFailureProbability;\n\t\t}\n\t}\n\n\taction riskAnalysis {\n\t\taction monitorBatteryLevel { out batteryLevel: BatteryLevel; }\n\t\taction estimateBatteryFailureProbability { out batteryFailureProbability: BatteryFailureProbability; }\n\t\tsuccession flow batteryLevelFlow from monitorBatteryLevel.batteryLevel to identifyLowBatteryRisk.batteryLevel;\n\t\tsuccession flow batteryFailureProbabilityFlow from estimateBatteryFailureProbability.batteryFailureProbability to detectBatteryAgingRisk.batteryFailureProbability;\n\n\t\taction detectBatteryAgingRisk {\n\t\t\tin batteryFailureProbability: BatteryFailureProbability;\n\t\t\tout risk: Risk;\n\t\t}\n\t\taction identifyLowBatteryRisk {\n\t\t\tin batteryLevel: BatteryLevel;\n\t\t\tin risk: Risk;\n\t\t\tout state: State;\n\t\t}\n\t\taction analyzeLowBatteryState {\n\t\t\tin state: State;\n\t\t\tin duration: Duration;\n\t\t\tout failureConsequence: FailureConsequence;\n\t\t}\n\t\taction assignSeverityLevel {\n\t\t\tin failureConsequence: FailureConsequence;\n\t\t\tout severityLevel: SeverityLevel;\n\t\t}\n\t\taction generateAlert {\n\t\t\tin severityLevel: SeverityLevel;\n\t\t\tout alert: Alert;\n\t\t}\n\t\tsuccession flow riskFlow from detectBatteryAgingRisk.risk to identifyLowBatteryRisk.risk;\n\t\tsuccession flow stateFlow from identifyLowBatteryRisk.state to analyzeLowBatteryState.state;\n\t\tsuccession flow failureConsequenceFlow from analyzeLowBatteryState.failureConsequence to assignSeverityLevel.failureConsequence;\n\t\tsuccession flow severityLevelFlow from assignSeverityLevel.severityLevel to generateAlert.severityLevel;\n\t}\n}",
    "package 'SystemStructuralDecomposition' {\n\tattribute def Function;\n\tattribute def Capability;\n\tattribute def InterfaceDef;\n\t\n\tport def FunctionPort {\n\t\tout function: Function;\n\t}\n\tport def CapabilityPort {\n\t\tout capability: Capability;\n\t}\n\tport def InterfacePort {\n\t\tout interfaceDef: InterfaceDef;\n\t}\n\t\n\tpart context {\n\t\tpart system {\n\t\t\tport functionPort: FunctionPort;\n\t\t\tport capabilityPort: CapabilityPort;\n\t\t\tperform decomposeSystem.decomposeTopDown {\n\t\t\t\tout function = functionPort.function;\n\t\t\t\tout capability = capabilityPort.capability;\n\t\t\t}\n\t\t\tpart subsystem[1..*] {\n\t\t\t\tport functionPort: ~FunctionPort;\n\t\t\t\tport capabilityPort: ~CapabilityPort;\n\t\t\t\tport interfacePort: InterfacePort;\n\t\t\t\tperform decomposeSystem.decomposeSubsystem {\n\t\t\t\t\tin function = functionPort.function;\n\t\t\t\t\tin capability = capabilityPort.capability;\n\t\t\t\t\tout interfaceDef = interfacePort.interfaceDef;\n\t\t\t\t}\n\t\t\t\tpart component[1..*] {\n\t\t\t\t\tport functionPort: ~FunctionPort;\n\t\t\t\t\tport capabilityPort: ~CapabilityPort;\n\t\t\t\t\tport interfacePort: ~InterfacePort;\n\t\t\t\t\tperform decomposeSystem.decomposeComponent {\n\t\t\t\t\t\tin function = functionPort.function;\n\t\t\t\t\t\tin capability = capabilityPort.capability;\n\t\t\t\t\t\tin interfaceDef = interfacePort.interfaceDef;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\t\n\taction decomposeSystem {\n\t\taction decomposeTopDown {\n\t\t\tout function: Function;\n\t\t\tout capability: Capability;\n\t\t}\n\t\taction decomposeSubsystem {\n\t\t\tin function: Function;\n\t\t\tin capability: Capability;\n\t\t\tout interfaceDef: InterfaceDef;\n\t\t}\n\t\taction decomposeComponent {\n\t\t\tin function: Function;\n\t\t\tin capability: Capability;\n\t\t\tin interfaceDef: InterfaceDef;\n\t\t}\n\t}\n\t\n\tview def StructuralDecompositionView {\n\t\tsubjects: system, subsystem, component;\n\t\trelationships: system.subsystem, subsystem.component;\n\t\tinterfaces: subsystem.interfacePort, component.interfacePort;\n\t}\n\t\n\trole def SystemEngineer;\n\trole def IVVParty;\n\t\n\trequirement def StructuralDecompositionRequirement {\n\t\ttext \"\"\"The system shall provide a hierarchical structural decomposition into subsystems and components, with well-defined interfaces, enabling independent analysis and collaborative integration. The structure shall support verification of system integrity and modularity by system engineers and IV&V parties.\"\"\"\n\t\tsatisfies: StructuralDecompositionView;\n\t}\n}",
    "package 'AutomotiveSystemArchitecture' {\n\n\t// Safety attribute enumeration\n\tenum SafetyStatus {\n\t\tmandatory,\n\t\toptional,\n\t\tnone\n\t}\n\n\t// Interface definition for all components\n\tinterface def ComponentInterface {\n\t\t// Define interface features as needed\n\t}\n\n\t// Abstract component definition\n\tpart def Component {\n\t\tattribute name: String;\n\t\tattribute safetyStatus: SafetyStatus = SafetyStatus::none;\n\t\tport interfacePort: ComponentInterface;\n\t}\n\n\t// Root system component\n\tpart def RootSystemComponent : Component {\n\t\tattribute name = \"AutomotiveSystem\";\n\t\t// Decomposition of subsystems\n\t\tpart subsystems: Subsystem[1..*];\n\t}\n\n\t// Subsystem definition\n\tpart def Subsystem : Component {\n\t\tpart components: Component[1..*];\n\t}\n\n\t// Safety-related component definition\n\tpart def SafetyComponent : Component {\n\t\tattribute safetyStatus: SafetyStatus;\n\t}\n\n\t// Non-safety component definition\n\tpart def NonSafetyComponent : Component {\n\t\tattribute safetyStatus = SafetyStatus::none;\n\t}\n\n\t// Mandatory safety components\n\tpart def SeatBelt : SafetyComponent {\n\t\tattribute name = \"SeatBelt\";\n\t\tattribute safetyStatus = SafetyStatus::mandatory;\n\t}\n\tpart def Bumper : SafetyComponent {\n\t\tattribute name = \"Bumper\";\n\t\tattribute safetyStatus = SafetyStatus::mandatory;\n\t}\n\n\t// Optional safety components\n\tpart def Airbag : SafetyComponent {\n\t\tattribute name = \"DriverAirbag\";\n\t\tattribute safetyStatus = SafetyStatus::optional;\n\t}\n\tpart def ABS : SafetyComponent {\n\t\tattribute name = \"ABS\";\n\t\tattribute safetyStatus = SafetyStatus::optional;\n\t}\n\n\t// Example non-safety components\n\tpart def InfotainmentSystem : NonSafetyComponent {\n\t\tattribute name = \"InfotainmentSystem\";\n\t}\n\tpart def ClimateControl : NonSafetyComponent {\n\t\tattribute name = \"ClimateControl\";\n\t}\n\n\t// System context instantiation\n\tpart context {\n\t\tpart root: RootSystemComponent {\n\t\t\tpart subsystems[1]: Subsystem {\n\t\t\t\tattribute name = \"ChassisSubsystem\";\n\t\t\t\tpart components[1]: SeatBelt;\n\t\t\t\tpart components[2]: Bumper;\n\t\t\t\tpart components[3]: Airbag;\n\t\t\t\tpart components[4]: ABS;\n\t\t\t}\n\t\t\tpart subsystems[2]: Subsystem {\n\t\t\t\tattribute name = \"CabinSubsystem\";\n\t\t\t\tpart components[1]: InfotainmentSystem;\n\t\t\t\tpart components[2]: ClimateControl;\n\t\t\t}\n\t\t}\n\t}\n\n\t// View: Hierarchical structure (tree)\n\tview def HierarchyTreeView {\n\t\tsubjects: RootSystemComponent;\n\t\trepresentation tree {\n\t\t\tshow part::subsystems;\n\t\t\tshow part::components;\n\t\t}\n\t}\n\n\t// View: Safety components (tabular)\n\tview def SafetyComponentTable {\n\t\tsubjects: SafetyComponent;\n\t\trepresentation table {\n\t\t\tcolumn name;\n\t\t\tcolumn safetyStatus;\n\t\t}\n\t}\n\n\t// View: Non-safety components (tabular)\n\tview def NonSafetyComponentTable {\n\t\tsubjects: NonSafetyComponent;\n\t\trepresentation table {\n\t\t\tcolumn name;\n\t\t}\n\t}\n\n\t// View: All components with safety status (tabular)\n\tview def AllComponentSafetyStatusTable {\n\t\tsubjects: Component;\n\t\trepresentation table {\n\t\t\tcolumn name;\n\t\t\tcolumn safetyStatus;\n\t\t}\n\t}\n}",
    "package 'AutomotiveDomain' {\n\t// Fundamental concept:  (Automobile)\n\t// Alias:  (Car)\n\t// Represents a motor vehicle designed for road transport.\n\telement def  {\n\t\talias 'Car';\n\t\t// : \n\t\t// Note: This is a core component in the automotive domain.\n\t\tattribute torque: ;\n\t}\n\n\t// Physical quantity:  (Torque)\n\t// Represents the rotational force produced by the engine or motor.\n\tvalueType def  {\n\t\talias 'Torque';\n\t\t// :  (Nm)\n\t\tunit: 'Nm';\n\t\t// : \n\t}\n\n\t// Additional extensibility: Example of associating other physical quantities\n\t// valueType def  {\n\t// \talias 'Speed';\n\t// \tunit: 'km/h';\n\t// }\n\n\t// The model is designed for clarity and extensibility.\n\t// Developers can add more elements, value types, and associations as needed.\n}",
    "package 'AutomobileDocumentManagement' {\n\n\tattribute def AutomobileInfo;\n\tattribute def Document;\n\tattribute def PhysicalQuantity;\n\tattribute def ExplanatoryDocument;\n\tattribute def Query;\n\tattribute def ArchiveCmd;\n\tattribute def EntryCmd;\n\tattribute def Alias;\n\tattribute def ISQ_TorqueValue;\n\n\tport def EntryPort {\n\t\tin entryCmd: EntryCmd;\n\t\tin automobileInfo: AutomobileInfo;\n\t}\n\tport def QueryPort {\n\t\tin query: Query;\n\t\tout automobileInfo: AutomobileInfo;\n\t}\n\tport def ArchivePort {\n\t\tin archiveCmd: ArchiveCmd;\n\t\tin automobileInfo: AutomobileInfo;\n\t}\n\tport def DocumentPort {\n\t\tin document: Document;\n\t}\n\tport def ExplanatoryDocPort {\n\t\tin explanatoryDocument: ExplanatoryDocument;\n\t}\n\tport def PhysicalQuantityPort {\n\t\tin physicalQuantity: PhysicalQuantity;\n\t}\n\n\tpart context {\n\t\tpart user {\n\t\t\tport entryPort: EntryPort;\n\t\t\tport queryPort: QueryPort;\n\t\t\tport archivePort: ArchivePort;\n\t\t\tport documentPort: DocumentPort;\n\t\t\tport explanatoryDocPort: ExplanatoryDocPort;\n\t\t\tperform manageAutomobileDocs.enterAutomobileInfo {\n\t\t\t\tin entryCmd = entryPort.entryCmd;\n\t\t\t\tin automobileInfo = entryPort.automobileInfo;\n\t\t\t}\n\t\t\tperform manageAutomobileDocs.queryAutomobileInfo {\n\t\t\t\tin query = queryPort.query;\n\t\t\t\tout automobileInfo = queryPort.automobileInfo;\n\t\t\t}\n\t\t\tperform manageAutomobileDocs.archiveAutomobileInfo {\n\t\t\t\tin archiveCmd = archivePort.archiveCmd;\n\t\t\t\tin automobileInfo = archivePort.automobileInfo;\n\t\t\t}\n\t\t\tperform manageAutomobileDocs.addDocument {\n\t\t\t\tin document = documentPort.document;\n\t\t\t}\n\t\t\tperform manageAutomobileDocs.addExplanatoryDocument {\n\t\t\t\tin explanatoryDocument = explanatoryDocPort.explanatoryDocument;\n\t\t\t}\n\t\t}\n\t\tpart automobileRepository {\n\t\t\tport entryPort: ~EntryPort;\n\t\t\tport queryPort: ~QueryPort;\n\t\t\tport archivePort: ~ArchivePort;\n\t\t\tport documentPort: ~DocumentPort;\n\t\t\tport explanatoryDocPort: ~ExplanatoryDocPort;\n\t\t\tport physicalQuantityPort: ~PhysicalQuantityPort;\n\t\t\tperform manageAutomobileDocs.storeAutomobileInfo {\n\t\t\t\tin entryCmd = entryPort.entryCmd;\n\t\t\t\tin automobileInfo = entryPort.automobileInfo;\n\t\t\t}\n\t\t\tperform manageAutomobileDocs.retrieveAutomobileInfo {\n\t\t\t\tin query = queryPort.query;\n\t\t\t\tout automobileInfo = queryPort.automobileInfo;\n\t\t\t}\n\t\t\tperform manageAutomobileDocs.archiveAutomobileInfo {\n\t\t\t\tin archiveCmd = archivePort.archiveCmd;\n\t\t\t\tin automobileInfo = archivePort.automobileInfo;\n\t\t\t}\n\t\t\tperform manageAutomobileDocs.storeDocument {\n\t\t\t\tin document = documentPort.document;\n\t\t\t}\n\t\t\tperform manageAutomobileDocs.storeExplanatoryDocument {\n\t\t\t\tin explanatoryDocument = explanatoryDocPort.explanatoryDocument;\n\t\t\t}\n\t\t\tperform manageAutomobileDocs.linkPhysicalQuantity {\n\t\t\t\tin physicalQuantity = physicalQuantityPort.physicalQuantity;\n\t\t\t}\n\t\t}\n\t\tpart aliasManager {\n\t\t\tattribute automobileAlias: Alias = 'Car';\n\t\t\tperform manageAutomobileDocs.mapAlias {\n\t\t\t\tin alias = automobileAlias;\n\t\t\t\tout object = 'Automobile';\n\t\t\t}\n\t\t\tperform manageAutomobileDocs.addExplanatoryDocument {\n\t\t\t\tin explanatoryDocument = explanatoryDocPort.explanatoryDocument;\n\t\t\t}\n\t\t\tport explanatoryDocPort: ~ExplanatoryDocPort;\n\t\t}\n\t\tpart physicalQuantitySystem {\n\t\t\tport physicalQuantityPort: PhysicalQuantityPort;\n\t\t\tattribute torqueValue: ISQ_TorqueValue;\n\t\t\tperform manageAutomobileDocs.provideTorqueValue {\n\t\t\t\tout physicalQuantity = physicalQuantityPort.physicalQuantity;\n\t\t\t}\n\t\t}\n\t}\n\n\taction manageAutomobileDocs {\n\t\taction enterAutomobileInfo {\n\t\t\tin entryCmd: EntryCmd;\n\t\t\tin automobileInfo: AutomobileInfo;\n\t\t}\n\t\taction storeAutomobileInfo {\n\t\t\tin entryCmd: EntryCmd;\n\t\t\tin automobileInfo: AutomobileInfo;\n\t\t}\n\t\taction queryAutomobileInfo {\n\t\t\tin query: Query;\n\t\t\tout automobileInfo: AutomobileInfo;\n\t\t}\n\t\taction retrieveAutomobileInfo {\n\t\t\tin query: Query;\n\t\t\tout automobileInfo: AutomobileInfo;\n\t\t}\n\t\taction archiveAutomobileInfo {\n\t\t\tin archiveCmd: ArchiveCmd;\n\t\t\tin automobileInfo: AutomobileInfo;\n\t\t}\n\t\taction addDocument {\n\t\t\tin document: Document;\n\t\t}\n\t\taction storeDocument {\n\t\t\tin document: Document;\n\t\t}\n\t\taction addExplanatoryDocument {\n\t\t\tin explanatoryDocument: ExplanatoryDocument;\n\t\t}\n\t\taction storeExplanatoryDocument {\n\t\t\tin explanatoryDocument: ExplanatoryDocument;\n\t\t}\n\t\taction mapAlias {\n\t\t\tin alias: Alias;\n\t\t\tout object: String;\n\t\t}\n\t\taction linkPhysicalQuantity {\n\t\t\tin physicalQuantity: PhysicalQuantity;\n\t\t}\n\t\taction provideTorqueValue {\n\t\t\tout physicalQuantity: PhysicalQuantity;\n\t\t}\n\t}\n\n\t// Alias definition for \"Car\" as \"Automobile\"\n\talias Automobile as Car;\n\n\t// Physical quantity system compatibility (example: ISQ TorqueValue)\n\tattribute def ISQ_TorqueValue extends PhysicalQuantity;\n\n}",
    "package 'AutomobileInformationSystem' {\n\timport ScalarQuantities::*;\n\t\n\tattribute def TorqueValue;\n\t\n\talias Torque = TorqueValue;\n\t\n\tpart def Automobile {\n\t\tattribute torque: TorqueValue;\n\t}\n\t\n\talias Car = Automobile;\n\t\n\tpart context {\n\t\tpart automobile: Automobile;\n\t}\n}",
    "package 'VehicleSystem' {\n\tattribute def VehicleSize;\n\tattribute def CylinderCount;\n\t\n\tenum def VehicleSizeEnum {\n\t\tsmall,\n\t\tstandard,\n\t\tlarge\n\t}\n\t\n\tpart def Cylinder {\n\t\tattribute id: Integer;\n\t}\n\t\n\tpart def Engine {\n\t\tattribute cylinderCount: CylinderCount;\n\t\tpart cylinders: Cylinder[*];\n\t}\n\t\n\tpart def Vehicle {\n\t\tattribute size: VehicleSizeEnum;\n\t\tpart engine: Engine;\n\t}\n\t\n\tconstraint def CylinderCountConstraint {\n\t\tinputs: size: VehicleSizeEnum;\n\t\toutputs: count: Integer;\n\t\tbody: \n\t\t\tif size == VehicleSizeEnum::small then\n\t\t\t\tcount = 4\n\t\t\telse if size == VehicleSizeEnum::large then\n\t\t\t\tcount = 6\n\t\t\telse\n\t\t\t\tcount >= 4 and count <= 6;\n\t}\n\t\n\tbehavior def ConfigureEngineCylinders {\n\t\tinputs: v: Vehicle;\n\t\toutputs: configuredEngine: Engine;\n\t\tbody:\n\t\t\tlet c: Integer;\n\t\t\tCylinderCountConstraint(size = v.size, count = c);\n\t\t\tconfiguredEngine.cylinderCount = c;\n\t\t\tconfiguredEngine.cylinders = Cylinder[*](id in 1..c);\n\t}\n\t\n\tpart context {\n\t\tpart vehicle: Vehicle;\n\t\tperform configureCylinders: ConfigureEngineCylinders {\n\t\t\tin v = vehicle;\n\t\t\tout configuredEngine = vehicle.engine;\n\t\t}\n\t}\n}",
    "package 'FuelManagementSystem' {\n\tattribute def Fuel;\n\tattribute def FuelTemperature;\n\tattribute def FuelFlowCmd;\n\n\tport def FuelInterface {\n\t\tinout fuel: Fuel;\n\t}\n\n\tport def FuelTempPort {\n\t\tin fuelTemperature: FuelTemperature;\n\t}\n\n\tport def FuelFlowCmdPort {\n\t\tout fuelFlowCmd: FuelFlowCmd;\n\t}\n\n\tpart context {\n\t\tpart fuelTank {\n\t\t\tport fuelInterface: ~FuelInterface;\n\t\t\tperform manageFuelFlow.supplyFuel {\n\t\t\t\tout fuel = fuelInterface.fuel;\n\t\t\t}\n\t\t}\n\t\tpart engine {\n\t\t\tport fuelInterface: FuelInterface;\n\t\t\tperform manageFuelFlow.consumeFuel {\n\t\t\t\tin fuel = fuelInterface.fuel;\n\t\t\t}\n\t\t\tport fuelReturnInterface: ~FuelInterface;\n\t\t\tperform manageFuelFlow.returnFuel {\n\t\t\t\tout fuel = fuelReturnInterface.fuel;\n\t\t\t}\n\t\t}\n\t\tpart fuelReturnLine {\n\t\t\tport fuelInterface: FuelInterface;\n\t\t\tperform manageFuelFlow.receiveReturnedFuel {\n\t\t\t\tin fuel = fuelInterface.fuel;\n\t\t\t}\n\t\t}\n\t\tpart fuelManagementController {\n\t\t\tport fuelTempPort: FuelTempPort;\n\t\t\tport fuelFlowCmdPort: FuelFlowCmdPort;\n\t\t\tperform manageFuelFlow.monitorAndControl {\n\t\t\t\tin fuelTemperature = fuelTempPort.fuelTemperature;\n\t\t\t\tout fuelFlowCmd = fuelFlowCmdPort.fuelFlowCmd;\n\t\t\t}\n\t\t}\n\t\tinterface tankToEngine connect fuelTank.fuelInterface to engine.fuelInterface {\n\t\t\tref flow references manageFuelFlow.fuelSupplyFlow\n\t\t\t\tfrom source.fuel to target.fuel;\n\t\t}\n\t\tinterface engineToReturn connect engine.fuelReturnInterface to fuelReturnLine.fuelInterface {\n\t\t\tref flow references manageFuelFlow.fuelReturnFlow\n\t\t\t\tfrom source.fuel to target.fuel;\n\t\t}\n\t}\n\n\taction manageFuelFlow {\n\t\taction supplyFuel { out fuel: Fuel; }\n\t\taction consumeFuel { in fuel: Fuel; }\n\t\tsuccession flow fuelSupplyFlow from supplyFuel.fuel to consumeFuel.fuel;\n\n\t\taction returnFuel { out fuel: Fuel; }\n\t\taction receiveReturnedFuel { in fuel: Fuel; }\n\t\tsuccession flow fuelReturnFlow from returnFuel.fuel to receiveReturnedFuel.fuel;\n\n\t\taction monitorAndControl {\n\t\t\tin fuelTemperature: FuelTemperature;\n\t\t\tout fuelFlowCmd: FuelFlowCmd;\n\t\t}\n\t}\n}",
    "package 'VehicleStructuralArchitecture' {\n\n\tattribute def Mass;\n\tattribute def SteeringAngle;\n\n\tpart def Wheel {\n\t\tattribute name: String;\n\t}\n\n\tpart def Axle {\n\t\tattribute name: String;\n\t\tpart leftWheel: Wheel;\n\t\tpart rightWheel: Wheel;\n\t}\n\n\tpart def SteeringAxle extends Axle {\n\t\tattribute steeringAngle: SteeringAngle;\n\t}\n\n\tpart def AxleAssembly {\n\t\tattribute name: String;\n\t\tpart axle: Axle;\n\t}\n\n\tpart def SteeringAxleAssembly extends AxleAssembly {\n\t\tpart axle: SteeringAxle;\n\t}\n\n\tpart def Vehicle {\n\t\tattribute mass: Mass;\n\t\tpart frontAxleAssembly: AxleAssembly;\n\t\tpart rearAxleAssembly: AxleAssembly;\n\t}\n\n\tpart def VehicleWithSteering {\n\t\tattribute mass: Mass;\n\t\tpart frontAxleAssembly: SteeringAxleAssembly;\n\t\tpart rearAxleAssembly: AxleAssembly;\n\t}\n\n\tpart def VehicleWithNamedWheels {\n\t\tattribute mass: Mass;\n\t\tpart frontAxleAssembly: AxleAssembly {\n\t\t\tpart axle: Axle {\n\t\t\t\tpart leftWheel: Wheel { attribute name = 'FrontLeft'; }\n\t\t\t\tpart rightWheel: Wheel { attribute name = 'FrontRight'; }\n\t\t\t}\n\t\t}\n\t\tpart rearAxleAssembly: AxleAssembly {\n\t\t\tpart axle: Axle {\n\t\t\t\tpart leftWheel: Wheel { attribute name = 'RearLeft'; }\n\t\t\t\tpart rightWheel: Wheel { attribute name = 'RearRight'; }\n\t\t\t}\n\t\t}\n\t}\n\n\tpart context {\n\t\tpart exampleVehicle1: Vehicle {\n\t\t\tattribute mass = 1750;\n\t\t\tpart frontAxleAssembly: AxleAssembly {\n\t\t\t\tpart axle: Axle {\n\t\t\t\t\tpart leftWheel: Wheel { attribute name = 'FL'; }\n\t\t\t\t\tpart rightWheel: Wheel { attribute name = 'FR'; }\n\t\t\t\t}\n\t\t\t}\n\t\t\tpart rearAxleAssembly: AxleAssembly {\n\t\t\t\tpart axle: Axle {\n\t\t\t\t\tpart leftWheel: Wheel { attribute name = 'RL'; }\n\t\t\t\t\tpart rightWheel: Wheel { attribute name = 'RR'; }\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tpart exampleVehicle2: VehicleWithSteering {\n\t\t\tattribute mass = 2000;\n\t\t\tpart frontAxleAssembly: SteeringAxleAssembly {\n\t\t\t\tpart axle: SteeringAxle {\n\t\t\t\t\tattribute steeringAngle = 0.0;\n\t\t\t\t\tpart leftWheel: Wheel { attribute name = 'FL'; }\n\t\t\t\t\tpart rightWheel: Wheel { attribute name = 'FR'; }\n\t\t\t\t}\n\t\t\t}\n\t\t\tpart rearAxleAssembly: AxleAssembly {\n\t\t\t\tpart axle: Axle {\n\t\t\t\t\tpart leftWheel: Wheel { attribute name = 'RL'; }\n\t\t\t\t\tpart rightWheel: Wheel { attribute name = 'RR'; }\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n}"
]