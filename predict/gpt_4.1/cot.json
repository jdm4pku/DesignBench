[
    "package VehicleManagementSystem {\n\n    part Vehicle {\n        attribute mass: Real;\n        attribute currentStatus: VehicleStatus;\n        part engine: Engine;\n        reference driver: Driver;\n    }\n\n    type VehicleStatus {\n        attribute gearSetting: Integer;\n        attribute acceleratorPedalPosition: Real;\n    }\n\n    part Engine {\n        attribute engineId: String;\n        attribute power: Real;\n        attribute status: EngineStatus;\n    }\n\n    type EngineStatus {\n        attribute isRunning: Boolean;\n        attribute rpm: Real;\n    }\n\n    part Driver {\n        attribute driverId: String;\n        attribute name: String;\n        attribute licenseNumber: String;\n    }\n\n    // System requirements\n    requirement TrackAndManageVehicleParameters {\n        text \"The system shall enable comprehensive tracking and management of key parameters and operating status of vehicles.\"\n    }\n\n    requirement SupportBusinessAnalysis {\n        text \"The system shall support subsequent business analysis and operational needs based on tracked vehicle data.\"\n    }\n\n    // Relationships\n    association VehicleHasEngine {\n        end vehicle: Vehicle [1];\n        end engine: Engine [1];\n    }\n\n    association VehicleHasDriver {\n        end vehicle: Vehicle [1];\n        end driver: Driver [0..1];\n    }\n\n    association SystemManagesEngines {\n        end engine: Engine [*];\n    }\n\n    association SystemManagesDrivers {\n        end driver: Driver [*];\n    }\n}",
    "package VehicleSystem {\n\n    entity Personnel {}\n\n    entity Engine {}\n\n    entity Vehicle {}\n\n    entity ManuallyOperatedVehicle specializes Vehicle {\n        part driver: Personnel;\n    }\n\n    entity PoweredVehicle specializes Vehicle {\n        part engine: Engine;\n    }\n\n    entity ManuallyOperatedPoweredVehicle specializes ManuallyOperatedVehicle, PoweredVehicle {}\n\n}",
    "package VehicleStructure {\n\n    // Abstract base type for all vehicle components\n    abstract part type VehicleComponent;\n\n    // Engine is a type of VehicleComponent\n    part type Engine specializes VehicleComponent;\n\n    // Transmission is a type of VehicleComponent\n    part type Transmission specializes VehicleComponent;\n\n    // Wheel is a type of VehicleComponent\n    part type Wheel specializes VehicleComponent;\n\n    // Abstract base type for vehicles\n    abstract part type Vehicle {\n        // Each vehicle has exactly one engine\n        part engine: Engine [1];\n\n        // Each vehicle has exactly one transmission\n        part transmission: Transmission [1];\n\n        // Each vehicle has exactly four wheels\n        part wheels: Wheel [4];\n    }\n\n}",
    "package VehicleSystem {\n\n    // Abstract definition of Vehicle\n    part def Vehicle {\n        part engine: Engine;\n    }\n\n    // Abstract definition of Engine\n    part def Engine {\n        part cylinders: Cylinder[1..*];\n    }\n\n    // Cylinder definition\n    part def Cylinder {\n    }\n\n    // Small Engine with 4 cylinders\n    part def SmallEngine : Engine {\n        part cylinders: Cylinder[4];\n    }\n\n    // Large Engine with 6 cylinders\n    part def LargeEngine : Engine {\n        part cylinders: Cylinder[6];\n    }\n\n    // Small Vehicle with Small Engine\n    part def SmallVehicle : Vehicle {\n        part engine: SmallEngine;\n    }\n\n    // Large Vehicle with Large Engine\n    part def LargeVehicle : Vehicle {\n        part engine: LargeEngine;\n    }\n}",
    "package TrafficSignalSystem {\n\n    enum TrafficLightColor {\n        literal green;\n        literal yellow;\n        literal red;\n    }\n\n    part TrafficSignal {\n        attribute color: TrafficLightColor;\n    }\n\n    part GreenTrafficSignal specializes TrafficSignal {\n        constraint {\n            color == TrafficLightColor::green;\n        }\n    }\n\n    requirement TrafficLightColorIndication {\n        text \"The traffic signal shall explicitly indicate its current color (green, yellow, or red) to facilitate orderly traffic flow and management.\";\n    }\n\n}",
    "package InformationClassificationManagement {\n\n    enum InformationLevel {\n        Unclassified,\n        Confidential,\n        Secret\n    }\n\n    enum InformationColor {\n        Green,\n        Yellow,\n        Red\n    }\n\n    enum InformationCode {\n        uncl,\n        conf,\n        secr\n    }\n\n    enum GradeLevel {\n        A,\n        B,\n        C,\n        D,\n        F\n    }\n\n    value GradePoint : Real;\n\n    part InformationClassification {\n        attribute level : InformationLevel;\n        attribute code : InformationCode;\n        attribute color : InformationColor;\n    }\n\n    part GradeClassification {\n        attribute grade : GradeLevel;\n        attribute point : GradePoint;\n    }\n\n    constraint InformationLevelMapping {\n        (level == InformationLevel.Unclassified) implies (code == InformationCode.uncl and color == InformationColor.Green);\n        (level == InformationLevel.Confidential) implies (code == InformationCode.conf and color == InformationColor.Yellow);\n        (level == InformationLevel.Secret) implies (code == InformationCode.secr and color == InformationColor.Red);\n    }\n\n    constraint GradePointMapping {\n        (grade == GradeLevel.A) implies (point == 4.0);\n        (grade == GradeLevel.B) implies (point == 3.0);\n        (grade == GradeLevel.C) implies (point == 2.0);\n        (grade == GradeLevel.D) implies (point == 1.0);\n        (grade == GradeLevel.F) implies (point == 0.0);\n    }\n\n    requirement InformationClassificationRequirement {\n        text \"The system shall implement an information classification mechanism based on the traffic light principle, mapping information levels to codes and colors, and support grade classification with defined grade points.\"\n    }\n\n    requirement UsabilityRequirement {\n        text \"The system shall clearly distinguish and display information categories and grade levels to ensure users can easily and intuitively identify them during operation and management.\"\n    }\n}",
    "package VehicleSystem {\n\n    part type Cylinder {\n        // Fundamental component of the engine\n    }\n\n    part type Engine {\n        part cylinders: Cylinder[4..6];\n        // Engine consists of 4 to 6 cylinders\n    }\n\n    part type SmallVehicle {\n        part engine: Engine {\n            cylinders: Cylinder[4];\n        }\n        // Small vehicle engine has 4 cylinders\n    }\n\n    part type LargeVehicle {\n        part engine: Engine {\n            cylinders: Cylinder[6];\n        }\n        // Large vehicle engine has 6 cylinders\n    }\n\n    part type Vehicle {\n        // Abstract vehicle type\n    }\n\n    specialize SmallVehicle extends Vehicle;\n    specialize LargeVehicle extends Vehicle;\n\n}",
    "package VehicleModeling {\n\n    // Quality attribute definition\n    interface QualityAttribute {\n        attribute name: String;\n        attribute value: String;\n    }\n\n    // Fuel definition\n    part Fuel {\n        attribute name: String;\n        attribute type: String;\n    }\n\n    // Personnel definition\n    part Personnel {\n        attribute id: String;\n        attribute name: String;\n        attribute role: String;\n        attribute licenseNumber: String;\n    }\n\n    // FuelTank definition\n    part FuelTank {\n        attribute capacity: Real;\n        refuelable;\n        part storedFuel: Fuel;\n    }\n\n    // Driver information\n    part Driver refines Personnel {\n        attribute drivingExperience: Integer;\n    }\n\n    // Vehicle definition\n    part Vehicle {\n        attribute id: String;\n        attribute model: String;\n        attribute manufacturer: String;\n        attribute year: Integer;\n\n        part driver: Driver;\n        part fuelTank: FuelTank;\n        part qualityAttributes: QualityAttribute[0..*];\n    }\n\n    // System context\n    part VehicleModelingSystem {\n        part vehicles: Vehicle[0..*];\n        part fuels: Fuel[0..*];\n        part personnel: Personnel[0..*];\n    }\n}",
    "package automobile_wheel_assembly {\n\n    part type WheelAssembly {\n        part bearing: WheelBearingUnit;\n        part tire: Tire;\n        part hub: Hub;\n        part bolts: BoltConnection[*];\n    }\n\n    part type WheelBearingUnit {\n        // Additional properties or constraints can be added here\n    }\n\n    part type Tire {\n        part bead1: Bead;\n        part bead2: Bead;\n        constraint [bead1_on_rim1] {\n            bead1.isPressedOn == hub.rim1\n        }\n        constraint [bead2_on_rim2] {\n            bead2.isPressedOn == hub.rim2\n        }\n    }\n\n    part type Bead {\n        property isPressedOn: Rim;\n    }\n\n    part type Hub {\n        part rim1: Rim;\n        part rim2: Rim;\n        part mountingHoles: BoltMountingHole[*];\n        part threadedHoles: ThreadedHole[*];\n    }\n\n    part type Rim {\n        // Additional properties or constraints can be added here\n    }\n\n    part type BoltMountingHole {\n        // Additional properties or constraints can be added here\n    }\n\n    part type ThreadedHole {\n        // Additional properties or constraints can be added here\n    }\n\n    part type BoltConnection {\n        reference mountingHole: BoltMountingHole;\n        reference threadedHole: ThreadedHole;\n        constraint [bolt_connects_holes] {\n            mountingHole.connectedTo == threadedHole\n        }\n    }\n\n    constraint [tire_beads_sealed_and_fastened] {\n        Tire.bead1.isPressedOn == Hub.rim1 and\n        Tire.bead2.isPressedOn == Hub.rim2\n    }\n\n    constraint [hub_bolt_connections] {\n        forall (b: BoltConnection in WheelAssembly.bolts) {\n            exists (mh: BoltMountingHole in Hub.mountingHoles) {\n                b.mountingHole == mh\n            }\n            exists (th: ThreadedHole in Hub.threadedHoles) {\n                b.threadedHole == th\n            }\n        }\n    }\n\n    requirement [structural_strength] {\n        description: \"The wheel assembly must ensure structural strength and safety under operational loads.\"\n    }\n\n    requirement [detailed_relationships] {\n        description: \"The model shall describe the specific relationships and connection methods between each component for design, assembly, and maintenance support.\"\n    }\n\n}",
    "package FuelManagementSystem {\n\n    part FuelTankAssembly {\n        port fuelSupplyOut: out port <FuelFlow>;\n        port fuelReturnIn: in port <FuelFlow>;\n        port tempSensor: out port <TemperatureData>;\n    }\n\n    part Engine {\n        port fuelSupplyIn: in port <FuelFlow>;\n        port fuelReturnOut: out port <FuelFlow>;\n        port tempSensor: in port <TemperatureData>;\n    }\n\n    interface FuelFlow {\n        property flowRate: Real;\n        property pressure: Real;\n    }\n\n    interface TemperatureData {\n        property temperature: Real;\n        property timestamp: Time;\n    }\n\n    part UserInterface {\n        port fuelSupplyData: in port <FuelFlow>;\n        port fuelReturnData: in port <FuelFlow>;\n        port temperatureData: in port <TemperatureData>;\n    }\n\n    connection FuelSupplyConnection {\n        from FuelTankAssembly.fuelSupplyOut;\n        to Engine.fuelSupplyIn;\n    }\n\n    connection FuelReturnConnection {\n        from Engine.fuelReturnOut;\n        to FuelTankAssembly.fuelReturnIn;\n    }\n\n    connection TempDataConnection {\n        from FuelTankAssembly.tempSensor;\n        to Engine.tempSensor;\n    }\n\n    connection UISupplyDataConnection {\n        from FuelTankAssembly.fuelSupplyOut;\n        to UserInterface.fuelSupplyData;\n    }\n\n    connection UIReturnDataConnection {\n        from Engine.fuelReturnOut;\n        to UserInterface.fuelReturnData;\n    }\n\n    connection UITempDataConnection {\n        from FuelTankAssembly.tempSensor;\n        to UserInterface.temperatureData;\n    }\n\n    requirement FuelFlowManagement {\n        text \"The system shall manage fuel supply and return between the fuel tank assembly and the engine, ensuring safe and efficient operation.\"\n    }\n\n    requirement TemperatureMonitoring {\n        text \"The system shall detect and transmit temperature information at the fuel interface to ensure safety and efficiency.\"\n    }\n\n    requirement RealTimeMonitoring {\n        text \"The system shall provide users with real-time data on fuel supply, return flow, and temperature parameters for monitoring and control.\"\n    }\n\n    satisfies FuelFlowManagement by FuelSupplyConnection, FuelReturnConnection;\n    satisfies TemperatureMonitoring by TempDataConnection;\n    satisfies RealTimeMonitoring by UISupplyDataConnection, UIReturnDataConnection, UITempDataConnection;\n\n}",
    "package VehicleConfigurationVariants {\n\n    // Abstract definitions\n    part Vehicle {\n        attribute mass: Real = 1750; // kg\n        part frontAxle: FrontAxle;\n        part rearAxle: RearAxle;\n    }\n\n    part FrontAxle {\n        attribute mass: Real;\n        part tires: Tire[2] ordered;\n    }\n\n    part RearAxle {\n        attribute mass: Real;\n        part tires: Tire[2] ordered;\n    }\n\n    part Tire {\n        attribute mass: Real;\n    }\n\n    // Variant: Dedicated front axle with steering\n    part SteeringFrontAxle extends FrontAxle {\n        attribute steeringAngle: Real;\n    }\n\n    // Vehicle configuration variant: vehicle1_c1\n    part vehicle1_c1 extends Vehicle {\n        attribute mass: Real = 2000; // override mass\n        part frontAxle: SteeringFrontAxle {\n            attribute mass: Real = 150; // example override\n            attribute steeringAngle: Real = 35; // degrees, example value\n            part tires[0]: Tire {\n                attribute mass: Real = 12; // example override\n            }\n            part tires[1]: Tire {\n                attribute mass: Real = 12; // example override\n            }\n        }\n        part rearAxle: RearAxle {\n            attribute mass: Real = 140; // example override\n            part tires[0]: Tire {\n                attribute mass: Real = 13; // example override\n            }\n            part tires[1]: Tire {\n                attribute mass: Real = 13; // example override\n            }\n        }\n    }\n\n    // Example: Renaming and managing specific instances\n    part vehicle1_c1_frontAxle is vehicle1_c1.frontAxle;\n    part vehicle1_c1_rearAxle is vehicle1_c1.rearAxle;\n    part vehicle1_c1_frontLeftTire is vehicle1_c1.frontAxle.tires[0];\n    part vehicle1_c1_frontRightTire is vehicle1_c1.frontAxle.tires[1];\n    part vehicle1_c1_rearLeftTire is vehicle1_c1.rearAxle.tires[0];\n    part vehicle1_c1_rearRightTire is vehicle1_c1.rearAxle.tires[1];\n\n}",
    "package CouplingSystem {\n\n    part Vehicle {\n        // Vehicle does not own a coupling ball; references Hitch's ball\n        ref hitch: Hitch;\n    }\n\n    part Trailer {\n        // Trailer references the connector in the Hitch\n        ref hitch: Hitch;\n    }\n\n    part Hitch {\n        part ball: CouplingBall;\n        part connector: TrailerConnector;\n    }\n\n    part CouplingBall {\n        // Represents the physical ball for coupling\n    }\n\n    part TrailerConnector {\n        // Represents the trailer-side connector\n    }\n\n    part CouplingSystem {\n        part vehicle: Vehicle;\n        part trailer: Trailer;\n        part hitch: Hitch;\n\n        // Bind vehicle and trailer to the same hitch instance\n        vehicle.hitch = hitch;\n        trailer.hitch = hitch;\n    }\n\n    requirement Modularity {\n        text \"Each component (vehicle, trailer, hitch) can be independently attached or detached without affecting the operation of other components. The design supports reusability and flexible assembly.\"\n    }\n\n    requirement Reusability {\n        text \"The vehicle and trailer do not own coupling hardware directly but reference the hitch's components, allowing for flexible combinations and quick adaptation.\"\n    }\n\n    requirement Maintenance {\n        text \"The modular design simplifies maintenance by allowing independent removal and replacement of components.\"\n    }\n}",
    "package VehiclePowerTransmissionSystem {\n\n    part VehiclePowerTransmissionSystem {\n        // Top-level system part\n        part engine: Engine;\n        part transmission: Transmission;\n        part clutch: Clutch;\n        part driveshaft: Driveshaft;\n        part rearAxleAssembly: RearAxleAssembly;\n        part leftRearWheel: Wheel;\n        part rightRearWheel: Wheel;\n\n        // Internal connections\n        connect engine.powerOut to clutch.engineIn;\n        connect clutch.powerOut to transmission.input;\n        connect transmission.output to driveshaft.input;\n        connect driveshaft.output to rearAxleAssembly.input;\n        connect rearAxleAssembly.leftHalfShaft to leftRearWheel.axleInterface;\n        connect rearAxleAssembly.rightHalfShaft to rightRearWheel.axleInterface;\n        connect leftRearWheel.roadInterface to Road.surface;\n        connect rightRearWheel.roadInterface to Road.surface;\n\n        // Control signal\n        connect FuelCommandPort to engine.fuelCommand;\n    }\n\n    interface PowerPort;\n    interface ClutchPort;\n    interface FuelCommandPort;\n    interface AxleInterface;\n    interface RoadInterface;\n\n    part Engine {\n        port fuelCommand: FuelCommandPort in;\n        port powerOut: PowerPort out;\n        port clutchCoupling: ClutchPort;\n    }\n\n    part Clutch {\n        port engineIn: PowerPort in;\n        port powerOut: PowerPort out;\n        port clutchControl: ClutchPort;\n    }\n\n    part Transmission {\n        port input: PowerPort in;\n        port output: PowerPort out;\n    }\n\n    part Driveshaft {\n        port input: PowerPort in;\n        port output: PowerPort out;\n    }\n\n    part RearAxleAssembly {\n        part differential: Differential;\n        port input: PowerPort in;\n        port leftHalfShaft: AxleInterface out;\n        port rightHalfShaft: AxleInterface out;\n    }\n\n    part Differential {\n        port input: PowerPort in;\n        port leftOutput: AxleInterface out;\n        port rightOutput: AxleInterface out;\n    }\n\n    part Wheel {\n        port axleInterface: AxleInterface in;\n        port roadInterface: RoadInterface out;\n    }\n\n    part Road {\n        port surface: RoadInterface inout;\n    }\n}",
    "package IntegratedManagementSystem {\n\n    // Interface Definitions\n    interface pe {}\n    interface pf {}\n\n    // Signal Port Definitions\n    port signalPort {}\n\n    // Component Definitions\n    part c1 {\n        port pb : pe;\n        port s1 : signalPort;\n    }\n\n    part c2 {\n        port s2 : signalPort;\n    }\n\n    part c3 {\n        port pd : pf;\n        port s3 : signalPort;\n    }\n\n    part c4 {\n        port s4 : signalPort;\n    }\n\n    // First Decomposition: Subsystems b11 and b12\n    part b11 {\n        part c1_inst : c1;\n        part c2_inst : c2;\n\n        // Signal connection between c1 and c2\n        connector c1_to_c2 {\n            end1 : c1_inst.s1;\n            end2 : c2_inst.s2;\n        }\n\n        // Interface binding\n        binding pe_binding {\n            port : c1_inst.pb;\n            interface : pe;\n        }\n    }\n\n    part b12 {\n        part c3_inst : c3;\n        part c4_inst : c4;\n\n        // Signal connection between c3 and c4\n        connector c3_to_c4 {\n            end1 : c3_inst.s3;\n            end2 : c4_inst.s4;\n        }\n\n        // Interface binding\n        binding pf_binding {\n            port : c3_inst.pd;\n            interface : pf;\n        }\n    }\n\n    // Communication between b11 and b12 via interfaces pe and pf\n    connector b11_b12_comm {\n        end1 : b11.c1_inst.pb;\n        end2 : b12.c3_inst.pd;\n    }\n\n    // Second Decomposition: Modules b21 and b22, reusing c-level components\n    part b21 {\n        part c1_ref : c1;\n        part c2_ref : c2;\n\n        // Example of reorganized signal connection\n        connector c1_c2_reuse {\n            end1 : c1_ref.s1;\n            end2 : c2_ref.s2;\n        }\n    }\n\n    part b22 {\n        part c3_ref : c3;\n        part c4_ref : c4;\n\n        // Example of reorganized signal connection\n        connector c3_c4_reuse {\n            end1 : c3_ref.s3;\n            end2 : c4_ref.s4;\n        }\n    }\n\n    // Top-level System Definition\n    part IntegratedSystem {\n        part b11_inst : b11;\n        part b12_inst : b12;\n        part b21_inst : b21;\n        part b22_inst : b22;\n\n        // Communication between b11 and b12\n        connector sys_b11_b12_comm {\n            end1 : b11_inst.c1_inst.pb;\n            end2 : b12_inst.c3_inst.pd;\n        }\n    }\n}",
    "package automotive_powertrain {\n\n    part powertrain_system : PowertrainSystem;\n\n    interface FuelCommand {\n        in property fuel_level : Real;\n    }\n\n    interface EngineStartStopCommand {\n        in property start : Boolean;\n        in property stop : Boolean;\n    }\n\n    interface EngineTorque {\n        out property torque : Real;\n    }\n\n    interface TransmissionTorque {\n        out property torque : Real;\n    }\n\n    interface DriveshaftTorque {\n        out property torque : Real;\n    }\n\n    interface WheelTorque {\n        out property left_wheel_torque : Real;\n        out property right_wheel_torque : Real;\n    }\n\n    part PowertrainSystem {\n        port fuel_cmd : FuelCommand;\n        port eng_start_stop_cmd : EngineStartStopCommand;\n        port wheel_torque : WheelTorque;\n\n        part engine : Engine;\n        part transmission : Transmission;\n        part driveshaft : Driveshaft;\n        part wheel_distribution : WheelDistribution;\n\n        connect fuel_cmd to engine.fuel_cmd;\n        connect eng_start_stop_cmd to engine.start_stop_cmd;\n        connect engine.torque_out to transmission.torque_in;\n        connect transmission.torque_out to driveshaft.torque_in;\n        connect driveshaft.torque_out to wheel_distribution.torque_in;\n        connect wheel_distribution.torque_out to wheel_torque;\n    }\n\n    part Engine {\n        port fuel_cmd : FuelCommand;\n        port start_stop_cmd : EngineStartStopCommand;\n        port torque_out : EngineTorque;\n\n        constraint engine_operation {\n            if (start_stop_cmd.start and not start_stop_cmd.stop) {\n                torque_out.torque = f(fuel_cmd.fuel_level);\n            } else {\n                torque_out.torque = 0.0;\n            }\n        }\n    }\n\n    part Transmission {\n        port torque_in : EngineTorque;\n        port torque_out : TransmissionTorque;\n\n        property gear_ratio : Real = 4.0;\n\n        constraint transmission_amplification {\n            torque_out.torque = torque_in.torque * gear_ratio;\n        }\n    }\n\n    part Driveshaft {\n        port torque_in : TransmissionTorque;\n        port torque_out : DriveshaftTorque;\n\n        property efficiency : Real = 0.95;\n\n        constraint driveshaft_transmission {\n            torque_out.torque = torque_in.torque * efficiency;\n        }\n    }\n\n    part WheelDistribution {\n        port torque_in : DriveshaftTorque;\n        port torque_out : WheelTorque;\n\n        constraint torque_distribution {\n            torque_out.left_wheel_torque = torque_in.torque / 2.0;\n            torque_out.right_wheel_torque = torque_in.torque / 2.0;\n        }\n    }\n\n}",
    "system PowertrainControlSystem {\n\n    // Functional Requirements\n    function ReceiveFuelControlCommand {\n        in signal fuelControlCommand;\n        out event fuelCommandReceived;\n        description \"Receives a fuel control command and triggers the control sequence.\";\n    }\n\n    function StartEngine {\n        in event fuelCommandReceived;\n        out event engineStarted;\n        description \"Starts the engine upon receiving a fuel control command.\";\n    }\n\n    function GenerateTorque {\n        in event engineStarted;\n        out value torqueGenerated;\n        description \"Generates torque after engine start.\";\n    }\n\n    function AmplifyTorque {\n        in value torqueGenerated;\n        out value torqueAmplified;\n        description \"Amplifies the generated torque.\";\n    }\n\n    function TransmitTorque {\n        in value torqueAmplified;\n        out value torqueTransmitted;\n        description \"Transmits the amplified torque.\";\n    }\n\n    function DistributeTorque {\n        in value torqueTransmitted;\n        out value wheelTorque;\n        description \"Distributes transmitted torque to drive wheels.\";\n    }\n\n    function DetectStallSignal {\n        in signal stallSignal;\n        out event stallDetected;\n        description \"Detects a stall signal to halt operational processes.\";\n    }\n\n    function HaltOperations {\n        in event stallDetected;\n        description \"Halts relevant operational processes upon stall detection.\";\n    }\n\n    function EngineShutdownControl {\n        in signal shutdownCommand;\n        out event engineShutdown;\n        description \"Controls engine shutdown as required.\";\n    }\n\n    // Non-Functional Requirements\n    requirement EfficientPowerDelivery {\n        description \"The system shall ensure efficient and coordinated power delivery from fuel command to wheel output.\";\n    }\n\n    requirement ReliableResponse {\n        description \"The system shall provide reliable power response and handling experience to users.\";\n    }\n\n    // Structure\n    part engine : Engine;\n    part transmission : Transmission;\n    part driveWheels : DriveWheels;\n\n    // Behavior/Interaction\n    scenario PowertrainOperation {\n        ReceiveFuelControlCommand.fuelControlCommand -> ReceiveFuelControlCommand;\n        ReceiveFuelControlCommand.fuelCommandReceived -> StartEngine;\n        StartEngine.engineStarted -> GenerateTorque;\n        GenerateTorque.torqueGenerated -> AmplifyTorque;\n        AmplifyTorque.torqueAmplified -> TransmitTorque;\n        TransmitTorque.torqueTransmitted -> DistributeTorque;\n        DistributeTorque.wheelTorque -> driveWheels;\n    }\n\n    scenario StallHandling {\n        DetectStallSignal.stallSignal -> DetectStallSignal;\n        DetectStallSignal.stallDetected -> HaltOperations;\n    }\n\n    scenario EngineShutdown {\n        EngineShutdownControl.shutdownCommand -> EngineShutdownControl;\n        EngineShutdownControl.engineShutdown -> engine;\n    }\n}",
    "system VehiclePowertrainManagementSystem {\n    part driver: Driver\n    part engine: Engine\n    part transmission: Transmission\n    part wheels: Wheel[4]\n\n    interface FuelInputCommand {\n        in fuelCommand: Real\n    }\n\n    interface EngineStartSignal {\n        in startSignal: Boolean\n    }\n\n    interface EngineShutdownSignal {\n        in shutdownSignal: Boolean\n    }\n\n    interface EngineOutputTorque {\n        out torque: Real\n    }\n\n    interface TransmissionInputTorque {\n        in inputTorque: Real\n    }\n\n    interface TransmissionOutputTorque {\n        out outputTorque: Real\n    }\n\n    interface WheelInputTorque {\n        in wheelTorque: Real\n    }\n\n    requirement R1 {\n        text \"The system shall manage the vehicle powertrain based on the driver's fuel input command.\"\n    }\n\n    requirement R2 {\n        text \"When the engine start signal is activated, the system shall generate engine output torque based on the fuel command.\"\n    }\n\n    requirement R3 {\n        text \"The system shall amplify and transmit torque through the transmission.\"\n    }\n\n    requirement R4 {\n        text \"The system shall distribute torque to each wheel.\"\n    }\n\n    requirement R5 {\n        text \"When the engine shutdown signal is triggered, the power output process shall be terminated.\"\n    }\n\n    requirement R6 {\n        text \"The system shall ensure accurate and efficient automatic control of power demand response, torque transmission, and power distribution.\"\n    }\n\n    requirement R7 {\n        text \"The system shall enhance driving experience and improve energy efficiency.\"\n    }\n\n    behavior PowertrainManagement {\n        state initial Idle\n        state EngineRunning\n        state EngineShutdown\n\n        transition Idle -> EngineRunning when (engine.startSignal == true) {\n            effect {\n                engine.torque = engine.generateTorque(driver.fuelCommand)\n            }\n        }\n\n        transition EngineRunning -> EngineShutdown when (engine.shutdownSignal == true) {\n            effect {\n                engine.torque = 0\n                transmission.inputTorque = 0\n                transmission.outputTorque = 0\n                for (w in wheels) {\n                    w.wheelTorque = 0\n                }\n            }\n        }\n\n        transition EngineRunning -> EngineRunning when (engine.startSignal == true && engine.shutdownSignal == false) {\n            effect {\n                engine.torque = engine.generateTorque(driver.fuelCommand)\n                transmission.inputTorque = engine.torque\n                transmission.outputTorque = transmission.amplifyTorque(transmission.inputTorque)\n                for (w in wheels) {\n                    w.wheelTorque = transmission.outputTorque / 4\n                }\n            }\n        }\n    }\n\n    satisfies R1, R2, R3, R4, R5, R6, R7\n}",
    "package PowerConnectionSystem {\n\n    part Vehicle {\n        part frame: StructuralFrame;\n        part hitchBall: HitchBall;\n    }\n\n    part Trailer {\n        part frame: StructuralFrame;\n        part coupler: TrailerCoupler;\n    }\n\n    part PowerConnectionMechanism {\n        part connectionState: ConnectionState;\n        part safetyLock: SafetyLock;\n    }\n\n    enum ConnectionState {\n        Connected,\n        Disconnected\n    }\n\n    part StructuralFrame {}\n\n    part HitchBall {\n        relatesTo Vehicle.frame;\n    }\n\n    part TrailerCoupler {\n        relatesTo Trailer.frame;\n    }\n\n    part SafetyLock {\n        property isEngaged: Boolean;\n    }\n\n    requirement PowerConnectionFunction {\n        description \"The system shall enable the vehicle and trailer to be connected or disconnected via the hitching mechanism.\";\n    }\n\n    requirement SafeReliableOperation {\n        description \"The system shall allow users to safely and reliably connect or disconnect the trailer to/from the vehicle.\";\n    }\n\n    requirement FlexibleCombinationSeparation {\n        description \"The system shall support flexible combination and separation of vehicle and trailer to meet user requirements in various scenarios.\";\n    }\n\n    satisfies PowerConnectionMechanism -> PowerConnectionFunction;\n    satisfies PowerConnectionMechanism -> SafeReliableOperation;\n    satisfies PowerConnectionMechanism -> FlexibleCombinationSeparation;\n\n    association VehicleToTrailerConnection {\n        end vehicle: Vehicle;\n        end trailer: Trailer;\n        property state: ConnectionState;\n    }\n\n    constraint SafeConnection {\n        description \"Connection is only allowed when safetyLock.isEngaged is true.\";\n        expression \"PowerConnectionMechanism.safetyLock.isEngaged == true implies VehicleToTrailerConnection.state == Connected\";\n    }\n}",
    "package VehicleTrailerConnectionSystem {\n\n    part vehicle : Vehicle;\n    part trailer : Trailer;\n\n    interface connect();\n    interface disconnect();\n\n    requirement Safety {\n        description: \"The system shall ensure that the trailer is safely and reliably coupled to the vehicle when connected.\";\n    }\n\n    requirement Convenience {\n        description: \"The system shall allow users to conveniently connect or disconnect the trailer from the vehicle.\";\n    }\n\n    requirement SmoothDetachment {\n        description: \"The system shall ensure the trailer can be smoothly detached from the vehicle when not required.\";\n    }\n\n    block Vehicle {\n        part chassis : Chassis;\n        part towBall : TowBall;\n    }\n\n    block Trailer {\n        part frame : TrailerFrame;\n        part coupler : Coupler;\n    }\n\n    block Chassis {}\n\n    block TowBall {}\n\n    block TrailerFrame {}\n\n    block Coupler {}\n\n    association VehicleHasTowBall {\n        end vehicle : Vehicle;\n        end towBall : TowBall;\n    }\n\n    association TrailerHasCoupler {\n        end trailer : Trailer;\n        end coupler : Coupler;\n    }\n\n    association Connection {\n        end towBall : TowBall;\n        end coupler : Coupler;\n    }\n\n    stateMachine ConnectionStatus {\n        state Disconnected {\n            on connect() -> Connected;\n        }\n        state Connected {\n            on disconnect() -> Disconnected;\n        }\n    }\n\n    usecase HitchTrailer {\n        description: \"User connects the trailer to the vehicle using the tow ball and coupler.\";\n        subject: VehicleTrailerConnectionSystem;\n    }\n\n    usecase UnhitchTrailer {\n        description: \"User disconnects the trailer from the vehicle.\";\n        subject: VehicleTrailerConnectionSystem;\n    }\n}",
    "package TrailerConnectionModel {\n\n    part Vehicle {\n        part chassis: Chassis;\n        part towBall: TowBallDevice;\n    }\n\n    part Trailer {\n        part trailerChassis: Chassis;\n        part coupler: CouplerMechanism;\n    }\n\n    part Chassis {}\n\n    part TowBallDevice {}\n\n    part CouplerMechanism {\n        attribute engaged: Boolean;\n        operation engage(towBall: TowBallDevice): Boolean;\n        operation disengage(): Boolean;\n    }\n\n    association VehicleTrailerConnection {\n        end vehicle: Vehicle;\n        end trailer: Trailer;\n        constraint connectionState: \n            (trailer.coupler.engaged == true) implies (trailer.coupler isConnectedTo vehicle.towBall);\n    }\n\n    requirement DynamicConnectionReferenceModel {\n        text \"The system shall implement a dynamic connection reference model between a vehicle and a towed trailer.\"\n    }\n\n    requirement HitchingOperation {\n        text \"Users shall be able to connect (hitch) the trailer to the vehicle by engaging the coupler mechanism with the tow ball.\"\n    }\n\n    requirement UnhitchingOperation {\n        text \"Users shall be able to disconnect (unhitch) the trailer from the vehicle by disengaging the coupler mechanism from the tow ball.\"\n    }\n\n    requirement SecureLatch {\n        text \"When connected, the trailer’s coupler shall securely latch onto the vehicle’s tow ball.\"\n    }\n\n    requirement SmoothSeparation {\n        text \"Disconnection shall allow the vehicle and trailer to separate smoothly, ensuring safe and convenient attachment and detachment.\"\n    }\n\n    satisfies DynamicConnectionReferenceModel by VehicleTrailerConnection;\n    satisfies HitchingOperation by CouplerMechanism.engage;\n    satisfies UnhitchingOperation by CouplerMechanism.disengage;\n    satisfies SecureLatch by CouplerMechanism.engaged;\n    satisfies SmoothSeparation by CouplerMechanism.disengage;\n}",
    "package FuelSystem {\n\n    part FuelSystem {\n        part fuelTank: FuelTankAssembly;\n        part engine: Engine;\n        part supplyLine: FuelLine;\n        part returnLine: FuelLine;\n        part tempSensor: TemperatureSensor;\n\n        interface fuelSupplyInterface {\n            inout fuel: Fuel;\n        }\n\n        interface fuelReturnInterface {\n            inout fuel: Fuel;\n        }\n\n        interface tempMonitoringInterface {\n            out temperature: Temperature;\n        }\n\n        connect fuelTank.fuelSupplyPort to supplyLine.inlet;\n        connect supplyLine.outlet to engine.fuelInlet;\n        connect engine.fuelReturnPort to returnLine.inlet;\n        connect returnLine.outlet to fuelTank.fuelReturnPort;\n        connect tempSensor.measurePort to supplyLine.measurePoint;\n\n        satisfies FuelSystemRequirements;\n    }\n\n    part FuelTankAssembly {\n        port fuelSupplyPort: fuelSupplyInterface;\n        port fuelReturnPort: fuelReturnInterface;\n    }\n\n    part Engine {\n        port fuelInlet: fuelSupplyInterface;\n        port fuelReturnPort: fuelReturnInterface;\n    }\n\n    part FuelLine {\n        port inlet: fuelSupplyInterface;\n        port outlet: fuelSupplyInterface;\n        port measurePoint: tempMonitoringInterface;\n    }\n\n    part TemperatureSensor {\n        port measurePort: tempMonitoringInterface;\n    }\n\n    type Fuel;\n    type Temperature;\n\n    requirement FuelSystemRequirements {\n        description \"The fuel system shall provide stable and reliable fuel supply to the engine during vehicle operation.\";\n        description \"The system shall support fuel return from the engine to the fuel tank.\";\n        description \"The system shall monitor temperature during fuel flow to ensure safety and efficiency.\";\n        description \"The system shall provide interface connections between all components for smooth fuel flow.\";\n    }\n}",
    "package FuelDeliverySystem {\n\n    part StorageTank {\n        attribute maxCapacity: Real;\n        attribute currentLevel: Real;\n        outport fuelOut: Fuel;\n    }\n\n    part FuelPump {\n        inport fuelIn: Fuel;\n        outport fuelOut: Fuel;\n        attribute flowRate: Real;\n        operation startPump();\n        operation stopPump();\n    }\n\n    part VehicleFuelTank {\n        attribute maxCapacity: Real;\n        attribute currentLevel: Real;\n        inport fuelIn: Fuel;\n        operation monitorLevel(): Real;\n    }\n\n    part Vehicle {\n        part fuelTank: VehicleFuelTank;\n    }\n\n    flow Fuel {\n        quantity: Real;\n        unit: Litre;\n    }\n\n    connector StorageToPump {\n        from: StorageTank.fuelOut;\n        to: FuelPump.fuelIn;\n    }\n\n    connector PumpToVehicleTank {\n        from: FuelPump.fuelOut;\n        to: Vehicle.fuelTank.fuelIn;\n    }\n\n    requirement TimelyDelivery {\n        text \"The system shall deliver fuel to vehicles within a specified time window to ensure normal operation.\";\n    }\n\n    requirement SafeOperation {\n        text \"The system shall prevent fuel spillage and overfilling during transfer.\";\n    }\n\n    requirement AccurateMeasurement {\n        text \"The system shall monitor and report the current fuel level in the vehicle fuel tank in real-time.\";\n    }\n\n    requirement EndToEndManagement {\n        text \"The system shall manage fuel transfer from storage tank to vehicle fuel tank, tracking quantity changes at each stage.\";\n    }\n\n    scenario NormalFuelDelivery {\n        precondition StorageTank.currentLevel > 0;\n        action sequence {\n            FuelPump.startPump();\n            transfer Fuel from StorageTank.fuelOut to FuelPump.fuelIn;\n            transfer Fuel from FuelPump.fuelOut to Vehicle.fuelTank.fuelIn;\n            Vehicle.fuelTank.monitorLevel();\n            FuelPump.stopPump();\n        }\n        postcondition Vehicle.fuelTank.currentLevel increased;\n    }\n}",
    "package automobile_assembly_process {\n\n    // Block Definitions\n    block VehicleAssembly {\n        part body: Body;\n        // Initially, no gearbox or engine\n    }\n\n    block Gearbox {\n        // Gearbox properties and behaviors\n    }\n\n    block Engine {\n        // Engine properties and behaviors\n    }\n\n    block VehicleWithGearbox {\n        part body: Body;\n        part gearbox: Gearbox;\n        // No engine yet\n    }\n\n    block FullyAssembledVehicle {\n        part body: Body;\n        part gearbox: Gearbox;\n        part engine: Engine;\n        // Both gearbox and engine are present and functional\n    }\n\n    block Body {\n        // Represents the vehicle body/frame\n    }\n\n    // Actions (Assembly Steps)\n    action InstallGearbox {\n        input vehicle: VehicleAssembly;\n        input gearbox: Gearbox;\n        output vehicleWithGearbox: VehicleWithGearbox;\n    }\n\n    action InstallEngine {\n        input vehicleWithGearbox: VehicleWithGearbox;\n        input engine: Engine;\n        output fullyAssembledVehicle: FullyAssembledVehicle;\n    }\n\n    // Assembly Process Sequence\n    activity FinalAssemblyProcess {\n        input initialVehicle: VehicleAssembly;\n        input gearbox: Gearbox;\n        input engine: Engine;\n        output finalVehicle: FullyAssembledVehicle;\n\n        step installGearbox: InstallGearbox;\n        step installEngine: InstallEngine;\n\n        initialVehicle -> installGearbox.vehicle;\n        gearbox -> installGearbox.gearbox;\n        installGearbox.vehicleWithGearbox -> installEngine.vehicleWithGearbox;\n        engine -> installEngine.engine;\n        installEngine.fullyAssembledVehicle -> finalVehicle;\n    }\n\n    // Requirements\n    requirement req_sequence {\n        text \"The assembly process shall install the gearbox before the engine in a sequential and orderly manner.\"\n    }\n\n    requirement req_integrity {\n        text \"The fully assembled vehicle shall have independent, functional gearbox and engine units.\"\n    }\n\n    requirement req_standardization {\n        text \"The assembly process shall be standardized and efficient to meet production requirements.\"\n    }\n\n    // Satisfy relationships\n    satisfy FinalAssemblyProcess -> req_sequence;\n    satisfy FullyAssembledVehicle -> req_integrity;\n    satisfy FinalAssemblyProcess -> req_standardization;\n\n}",
    "system VehicleA_System {\n    \n    part vehicle: VehicleA;\n    part controller: VehicleController;\n\n    state_machine VehicleA_OperationSM {\n        state Off;\n        state Starting;\n        state Running;\n        state HealthManagement;\n        state Maintenance;\n        state Degraded;\n        state Normal;\n\n        transition Off_to_Starting {\n            source: Off;\n            target: Starting;\n            trigger: brakePedalPressed & startSignalReceived;\n        }\n\n        transition Starting_to_Running {\n            source: Starting;\n            target: Running;\n            trigger: vehicleOnSignalReceived;\n        }\n\n        transition Running_to_HealthManagement {\n            source: Running;\n            target: HealthManagement;\n            trigger: selfCheckFailed;\n        }\n\n        transition Running_to_Degraded {\n            source: Running;\n            target: Degraded;\n            trigger: temperature > safetyThreshold;\n            effect: sendOverTemperatureSignal();\n        }\n\n        transition Degraded_to_Normal {\n            source: Degraded;\n            target: Normal;\n            trigger: restoreToNormalSignalReceived;\n        }\n\n        transition Running_to_Maintenance {\n            source: Running;\n            target: Maintenance;\n            trigger: maintenanceRequestReceived;\n        }\n\n        transition Maintenance_to_Normal {\n            source: Maintenance;\n            target: Normal;\n            trigger: restoreToNormalSignalReceived;\n        }\n\n        transition Running_to_Off {\n            source: Running;\n            target: Off;\n            trigger: shutdownSignalReceived;\n            effect: applyParkingBrake();\n        }\n\n        entry Running {\n            do: performSelfCheck();\n            do: supplyPowerToVehicle();\n        }\n\n        entry Degraded {\n            do: setDegradedMode();\n        }\n\n        entry HealthManagement {\n            do: monitorHealth();\n        }\n\n        entry Maintenance {\n            do: performMaintenance();\n        }\n    }\n\n    interface VehicleA_Inputs {\n        in brakePedalPressed: Boolean;\n        in startSignalReceived: Boolean;\n        in vehicleOnSignalReceived: Boolean;\n        in shutdownSignalReceived: Boolean;\n        in maintenanceRequestReceived: Boolean;\n        in restoreToNormalSignalReceived: Boolean;\n        in temperature: Real;\n    }\n\n    interface VehicleA_Outputs {\n        out overTemperatureSignal: Boolean;\n        out parkingBrakeApplied: Boolean;\n        out healthStatus: HealthStatus;\n        out powerSupplied: Boolean;\n    }\n\n    constraint safetyConstraint {\n        description: \"Vehicle must not start unless brake pedal is pressed and start signal is received.\";\n        assert: (state == Starting) implies (brakePedalPressed and startSignalReceived);\n    }\n\n    constraint temperatureConstraint {\n        description: \"If temperature exceeds safety threshold, system must enter Degraded state and send over-temperature signal.\";\n        assert: (temperature > safetyThreshold) implies (state == Degraded and overTemperatureSignal);\n    }\n\n    requirement AutomatedResponse {\n        text: \"The system shall automatically respond to state transitions and health events without manual intervention.\";\n    }\n\n    requirement HealthMonitoring {\n        text: \"The system shall monitor vehicle health in real-time and output temperature and health status.\";\n    }\n\n    requirement SafetyControl {\n        text: \"The system shall ensure safe operation by enforcing state transition conditions and applying the parking brake when exiting Running state.\";\n    }\n\n    requirement Maintainability {\n        text: \"The system shall support Maintenance and Degraded states and allow restoration to Normal state upon receiving the appropriate signal.\";\n    }\n}\n\nblock VehicleA {\n    attribute temperature: Real;\n    attribute healthStatus: HealthStatus;\n}\n\nblock VehicleController {\n    operation sendOverTemperatureSignal();\n    operation applyParkingBrake();\n    operation performSelfCheck();\n    operation supplyPowerToVehicle();\n    operation setDegradedMode();\n    operation monitorHealth();\n    operation performMaintenance();\n}\n\nenum HealthStatus {\n    OK,\n    DEGRADED,\n    MAINTENANCE,\n    FAULT\n}",
    "package VehicleBehaviorSystem {\n\n    part vehicle : Vehicle;\n    part controller : VehicleController;\n\n    interface StartSignal;\n    interface BrakePedalPressed;\n    interface TemperatureSensor;\n    interface WarningSignal;\n    interface MaintenanceSignal;\n    interface FaultRecoverySignal;\n\n    attribute fuelType : String;\n    attribute maintenanceInterval : Duration;\n    attribute temperatureThreshold : Real;\n\n    requirement R1 {\n        description: \"Vehicle shall only start from shutdown state when brake pedal is pressed and start signal is received.\"\n    }\n    requirement R2 {\n        description: \"Vehicle shall perform self-inspection and power supply procedures after startup conditions are met.\"\n    }\n    requirement R3 {\n        description: \"System shall sense temperature in real time.\"\n    }\n    requirement R4 {\n        description: \"When overheating is detected, system shall send warning to controller, switch vehicle to degraded mode, and ensure safety.\"\n    }\n    requirement R5 {\n        description: \"Health management shall include regular maintenance and fault recovery to restore normal operation.\"\n    }\n    requirement R6 {\n        description: \"Controller shall process control and status signals for automatic start and shutdown.\"\n    }\n    requirement R7 {\n        description: \"System shall support configuration of fuel, maintenance intervals, and temperature thresholds.\"\n    }\n\n    part Vehicle {\n        attribute status : {Shutdown, Starting, Running, Degraded};\n        attribute healthStatus : {Normal, Fault, MaintenanceRequired, Recovering};\n        attribute temperature : Real;\n\n        operation start() {\n            precondition: status == Shutdown and brakePedalPressed and startSignalReceived;\n            postcondition: status == Starting;\n        }\n        operation performSelfInspection() {\n            precondition: status == Starting;\n            postcondition: status == Running;\n        }\n        operation supplyPower() {\n            precondition: status == Starting;\n            postcondition: status == Running;\n        }\n        operation monitorTemperature() {\n            effect: temperature = sense(TemperatureSensor);\n            if (temperature > temperatureThreshold) {\n                send(WarningSignal, controller);\n                status = Degraded;\n                ensureSafety();\n            }\n        }\n        operation ensureSafety() {\n            effect: // Safety mechanisms activated\n        }\n        operation scheduleMaintenance() {\n            trigger: timeSinceLastMaintenance >= maintenanceInterval;\n            effect: healthStatus = MaintenanceRequired;\n            send(MaintenanceSignal, controller);\n        }\n        operation recoverFromFault() {\n            trigger: healthStatus == Fault;\n            effect: healthStatus = Recovering;\n            send(FaultRecoverySignal, controller);\n        }\n        operation completeRecovery() {\n            precondition: healthStatus == Recovering;\n            postcondition: healthStatus = Normal;\n        }\n\n        port brakePedalPressed : BrakePedalPressed;\n        port startSignalReceived : StartSignal;\n        port temperatureSensor : TemperatureSensor;\n        port warningSignal : WarningSignal;\n        port maintenanceSignal : MaintenanceSignal;\n        port faultRecoverySignal : FaultRecoverySignal;\n    }\n\n    part VehicleController {\n        operation processStartRequest() {\n            receive(StartSignal, vehicle);\n            receive(BrakePedalPressed, vehicle);\n            if (vehicle.status == Shutdown and brakePedalPressed and startSignalReceived) {\n                vehicle.start();\n                vehicle.performSelfInspection();\n                vehicle.supplyPower();\n            }\n        }\n        operation processShutdownRequest() {\n            // Implementation for shutdown\n        }\n        operation receiveWarning() {\n            receive(WarningSignal, vehicle);\n            // Handle degraded mode and safety\n        }\n        operation processMaintenance() {\n            receive(MaintenanceSignal, vehicle);\n            // Schedule or perform maintenance\n        }\n        operation processFaultRecovery() {\n            receive(FaultRecoverySignal, vehicle);\n            // Initiate recovery procedures\n        }\n    }\n\n    constraint fuelTypeConfigurable {\n        fuelType in {\"Gasoline\", \"Diesel\", \"Electric\", \"Hybrid\"};\n    }\n    constraint temperatureThresholdConfigurable {\n        temperatureThreshold > 0.0;\n    }\n    constraint maintenanceIntervalConfigurable {\n        maintenanceInterval > 0.0;\n    }\n}",
    "package VehicleDynamicsSimulation {\n\n    import sysml::blocks;\n    import sysml::constraints;\n    import sysml::states;\n    import sysml::values;\n    import sysml::requirements;\n\n    requirement SimulationCapability {\n        text \"The system shall simulate the dynamic behavior of vehicles on roads at different time points, allowing users to define vehicle and road parameters, record snapshots, and analyze state transitions for vehicle dynamics and road adaptability assessment.\"\n    }\n\n    block Vehicle {\n        attribute mass: Real;\n        attribute position: Real[3]; // x, y, z coordinates\n        attribute velocity: Real[3];\n        attribute acceleration: Real[3];\n        operation updateState(time: Real, road: Road): VehicleState;\n    }\n\n    block Road {\n        attribute slopeAngle: Real; // degrees or radians\n        attribute frictionCoefficient: Real;\n    }\n\n    block SimulationSnapshot {\n        attribute time: Real;\n        attribute vehicleState: VehicleState;\n        attribute roadState: Road;\n    }\n\n    block SimulationSeries {\n        attribute snapshots: Sequence<SimulationSnapshot>;\n        operation recordSnapshot(time: Real, vehicle: Vehicle, road: Road): SimulationSnapshot;\n    }\n\n    state VehicleState {\n        state On;\n        state Driving;\n        state Off;\n        transition On -> Driving;\n        transition Driving -> Off;\n    }\n\n    constraint VehicleDynamics {\n        input mass: Real;\n        input velocity: Real[3];\n        input acceleration: Real[3];\n        input slopeAngle: Real;\n        input frictionCoefficient: Real;\n        // Placeholder for vehicle dynamics equations\n        // e.g., F = m*a, friction = mu*N, etc.\n    }\n\n    usecase DefineSimulationParameters {\n        text \"User defines vehicle mass, position, velocity, acceleration, road slope angle, and friction coefficient.\"\n    }\n\n    usecase RecordSnapshot {\n        text \"System records the state of the vehicle and road at a specific time point.\"\n    }\n\n    usecase AnalyzeStateTransitions {\n        text \"System enables tracking and analysis of vehicle state transitions (On, Driving, Off) over the simulation time series.\"\n    }\n\n    satisfies SimulationCapability by {\n        DefineSimulationParameters;\n        RecordSnapshot;\n        AnalyzeStateTransitions;\n    }\n}",
    "package automotive_config_mgmt {\n\n    part automobile {\n        part subsystemA : SubsystemA;\n        part subsystemB : SubsystemB;\n    }\n\n    abstract part SubsystemA;\n    part SubsystemA_Option1 specializes SubsystemA {\n        part component1 : Component1;\n        part component2 : Component2;\n    }\n    part SubsystemA_Option2 specializes SubsystemA {\n        part component2 : Component2;\n        part component3 : Component3;\n    }\n\n    abstract part SubsystemB;\n    part SubsystemB_Option1 specializes SubsystemB {\n        part component4 : Component4;\n        part component5 : Component5;\n    }\n    part SubsystemB_Option2 specializes SubsystemB {\n        part component5 : Component5;\n        part component6 : Component6;\n    }\n\n    part Component1;\n    part Component2;\n    part Component3;\n    part Component4;\n    part Component5;\n    part Component6;\n\n    constraint configuration_constraint(\n        a : SubsystemA,\n        b : SubsystemB\n    ) {\n        not (a isa SubsystemA_Option2 and not (b isa SubsystemB_Option1))\n    }\n\n    part ConfigurationA specializes automobile {\n        part subsystemA : SubsystemA_Option1;\n        part subsystemB : SubsystemB_Option1;\n    }\n\n    part ConfigurationB specializes automobile {\n        part subsystemA : SubsystemA_Option2;\n        part subsystemB : SubsystemB_Option1;\n    }\n}",
    "system ModularVehiclePlatform {\n\n    // Abstract Subsystems\n    abstract part SubsystemA {\n        port aPort;\n        // Allow flexible internal composition\n        part[0..*] internalComponentA : Component;\n    }\n\n    abstract part SubsystemB {\n        port bPort;\n        // Allow flexible internal composition\n        part[0..*] internalComponentB : Component;\n    }\n\n    // Component Definitions\n    part Part1 : Component;\n    part Part2 : Component;\n    part Part3 : Component {\n        port p1;\n    }\n    part Part4 : Component;\n    part Part5 : Component {\n        port p2;\n        // Behavioral variants\n        variant behavior {\n            option Variant1;\n            option Variant2;\n        }\n    }\n    part Part6 : Component;\n\n    // Subsystem Variants\n    part SubsystemA_Variant1 : SubsystemA {\n        part internalComponentA[1] : Part1;\n        part internalComponentA[1] : Part3;\n    }\n    part SubsystemA_Variant2 : SubsystemA {\n        part internalComponentA[1] : Part2;\n        part internalComponentA[1] : Part4;\n    }\n    part SubsystemB_Variant1 : SubsystemB {\n        part internalComponentB[1] : Part5;\n        part internalComponentB[1] : Part6;\n    }\n    part SubsystemB_Variant2 : SubsystemB {\n        part internalComponentB[1] : Part3;\n        part internalComponentB[1] : Part5;\n    }\n\n    // Vehicle Configuration Schemes\n    configuration VehicleConfigA {\n        part subsystemA : SubsystemA_Variant1;\n        part subsystemB : SubsystemB_Variant1;\n        connect subsystemA.aPort to subsystemB.bPort;\n        // Parameter and behavior customization\n        set subsystemB.internalComponentB[Part5].behavior = Variant1;\n    }\n\n    configuration VehicleConfigB {\n        part subsystemA : SubsystemA_Variant2;\n        part subsystemB : SubsystemB_Variant2;\n        connect subsystemA.aPort to subsystemB.bPort;\n        set subsystemB.internalComponentB[Part5].behavior = Variant2;\n    }\n\n    // System-level Constraints\n    constraint Consistency {\n        // Ensure at least one component in each subsystem\n        size(subsystemA.internalComponentA) >= 1;\n        size(subsystemB.internalComponentB) >= 1;\n        // Ensure only valid connections between subsystem ports\n        isConnected(subsystemA.aPort, subsystemB.bPort);\n        // Ensure no duplicate components in a single configuration\n        unique(subsystemA.internalComponentA + subsystemB.internalComponentB);\n    }\n\n    // Non-functional properties\n    property scalable : Boolean = true;\n    property configurable : Boolean = true;\n    property supportsVariantSelection : Boolean = true;\n    property supportsInteroperability : Boolean = true;\n}",
    "system VehicleProductLineConfigurator {\n\n    part engine: Engine;\n    part transmission: Transmission;\n    part wheels: Wheels;\n\n    requirement flexibleConfiguration {\n        description: \"The system shall provide flexible solutions for vehicle product line configuration, supporting multiple model variants and rapid adaptation to market demands.\";\n    }\n\n    requirement automaticMatching {\n        description: \"The system shall automatically match suitable combinations of engines, transmissions, and wheels based on performance requirements and user preferences.\";\n    }\n\n    requirement compatibilityEnforcement {\n        description: \"The system shall enforce configuration constraints to ensure compatibility among selected components and prevent unreasonable combinations.\";\n    }\n\n    requirement customization {\n        description: \"The system shall enable customized vehicles tailored to individual user needs.\";\n    }\n\n    requirement performanceMapping {\n        description: \"The system shall provide high performance and standard performance configuration schemes.\";\n    }\n\n    constraint highPerformanceConfig {\n        description: \"If high performance is required, then the configuration shall include a 6-cylinder engine, automatic transmission, and wide-rim wheels.\";\n        predicate: (performanceRequirement == High) implies\n            (engine.type == SixCylinder and\n             transmission.type == Automatic and\n             wheels.rim == Wide);\n    }\n\n    constraint standardPerformanceConfig {\n        description: \"If standard performance is required, then the configuration shall include a 4-cylinder engine, manual transmission, and narrow-rim wheels.\";\n        predicate: (performanceRequirement == Standard) implies\n            (engine.type == FourCylinder and\n             transmission.type == Manual and\n             wheels.rim == Narrow);\n    }\n\n    constraint componentCompatibility {\n        description: \"Selected engine, transmission, and wheels must be compatible.\";\n        predicate: compatible(engine, transmission, wheels);\n    }\n\n    constraint validConfiguration {\n        description: \"All configuration schemes must meet vehicle performance and component compatibility requirements.\";\n        predicate: isValidConfiguration(engine, transmission, wheels, performanceRequirement);\n    }\n\n    attribute performanceRequirement: PerformanceLevel;\n\n    enum PerformanceLevel {\n        High,\n        Standard\n    }\n\n    partSet modelVariants: VehicleModelVariant[*];\n\n}\n\nblock Engine {\n    attribute type: EngineType;\n}\n\nenum EngineType {\n    FourCylinder,\n    SixCylinder\n}\n\nblock Transmission {\n    attribute type: TransmissionType;\n}\n\nenum TransmissionType {\n    Manual,\n    Automatic\n}\n\nblock Wheels {\n    attribute rim: RimType;\n}\n\nenum RimType {\n    Narrow,\n    Wide\n}\n\nblock VehicleModelVariant {\n    attribute name: String;\n    // Additional attributes for variant-specific features\n}\n\nfunction compatible(e: Engine, t: Transmission, w: Wheels): Boolean;\nfunction isValidConfiguration(e: Engine, t: Transmission, w: Wheels, p: PerformanceLevel): Boolean;",
    "package AutomobileSpecification {\n\n    part VehicleSystem {\n        part vehicles: Vehicle[1..*];\n        part engines: Engine[1..*];\n        part transmissions: Transmission[1..*];\n        part driveInterfaces: DriveInterface[1..*];\n    }\n\n    part Vehicle {\n        attribute mass: Mass;\n        attribute fuelStatus: FuelStatus;\n        attribute maxAllowedMass: Mass;\n        reference engine: Engine;\n        reference transmission: Transmission;\n        reference driveInterface: DriveInterface;\n        attribute reliability: Reliability;\n    }\n\n    part Engine {\n        attribute maxTorque: Torque;\n        operation deliverTorque();\n    }\n\n    part Transmission {\n        operation receiveTorque();\n    }\n\n    part DriveInterface {\n        reference engine: Engine;\n        reference transmission: Transmission;\n        operation connect();\n    }\n\n    enum FuelStatus {\n        FULL,\n        EMPTY\n    }\n\n    type Mass {\n        value: Real;\n        unit: \"kg\";\n    }\n\n    type Torque {\n        value: Real;\n        unit: \"Nm\";\n    }\n\n    type Reliability {\n        value: Real;\n        unit: \"MTBF_hr\";\n    }\n\n    requirement VehicleMassGrades {\n        text \"The system shall support vehicles with different mass grades, such as 2000 kg and 2500 kg.\";\n        verify by MassGradeTest;\n    }\n\n    requirement VehicleMassCompliance {\n        text \"Each vehicle shall reflect its actual mass and comply with the corresponding maximum mass limitation to prevent overloading.\";\n        verify by MassComplianceTest;\n    }\n\n    requirement FuelStatusRegulation {\n        text \"The system shall regulate fuel status, requiring some vehicles to meet mass requirements when fully fueled, while others are accepted in an empty-fuel state.\";\n        verify by FuelStatusTest;\n    }\n\n    requirement PowertrainFunctionality {\n        text \"Vehicles shall have power delivery functionality, requiring the engine to output torque and be connected to the transmission via a drive interface for reliable power transfer.\";\n        verify by PowertrainTest;\n    }\n\n    requirement ReliabilityTracking {\n        text \"For specific models, the system shall track and fulfill reliability requirements, ensuring specified performance and durability throughout the vehicle lifecycle.\";\n        verify by ReliabilityTest;\n    }\n\n    allocation VehicleMassGrades to Vehicle.mass;\n    allocation VehicleMassCompliance to Vehicle.mass, Vehicle.maxAllowedMass;\n    allocation FuelStatusRegulation to Vehicle.fuelStatus;\n    allocation PowertrainFunctionality to Engine.deliverTorque, Transmission.receiveTorque, DriveInterface.connect;\n    allocation ReliabilityTracking to Vehicle.reliability;\n\n    validation MassGradeTest {\n        text \"Test that vehicles of 2000 kg and 2500 kg mass grades are defined and managed by the system.\";\n    }\n\n    validation MassComplianceTest {\n        text \"Test that each vehicle's actual mass does not exceed its maximum allowed mass.\";\n    }\n\n    validation FuelStatusTest {\n        text \"Test that vehicles meet mass requirements under specified fuel status conditions (full or empty).\";\n    }\n\n    validation PowertrainTest {\n        text \"Test that engine torque is delivered and received by the transmission via the drive interface.\";\n    }\n\n    validation ReliabilityTest {\n        text \"Test that vehicle reliability is tracked and meets specified lifecycle requirements.\";\n    }\n}",
    "system VehicleMassComplianceSystem {\n\n    part weighingEquipment : WeighingEquipment;\n    part testOperator : TestOperator;\n\n    interface Vehicle {\n        attribute actualMass : Mass;\n        operation getActualMass() : Mass;\n    }\n\n    attribute maximumPermissibleMass : Mass = 2500 kg;\n\n    action measureVehicleMass {\n        input vehicle : Vehicle;\n        output measuredMass : Mass;\n        do {\n            measuredMass = weighingEquipment.measure(vehicle);\n        }\n    }\n\n    action compareMass {\n        input measuredMass : Mass;\n        output isCompliant : Boolean;\n        do {\n            isCompliant = measuredMass <= maximumPermissibleMass;\n        }\n    }\n\n    action processVehicle {\n        input vehicle : Vehicle;\n        output complianceResult : ComplianceResult;\n        do {\n            let measuredMass = measureVehicleMass(vehicle);\n            let isCompliant = compareMass(measuredMass);\n            complianceResult = ComplianceResult {\n                vehicle: vehicle,\n                measuredMass: measuredMass,\n                isCompliant: isCompliant\n            };\n        }\n    }\n\n    action processMultipleVehicles {\n        input vehicles : Vehicle[];\n        output results : ComplianceResult[];\n        do {\n            results = [];\n            for (v in vehicles) {\n                let result = processVehicle(v);\n                results.append(result);\n            }\n        }\n    }\n\n    requirement MassCompliance {\n        description \"The system shall verify that the actual mass of each tested vehicle does not exceed the specified maximum permissible mass of 2,500 kg.\";\n        verify processVehicle;\n    }\n\n    requirement SequentialTesting {\n        description \"The system shall support sequential testing and result determination for multiple vehicles.\";\n        verify processMultipleVehicles;\n    }\n\n    requirement AutomatedComplianceManagement {\n        description \"The system shall provide a reliable and automated solution for compliance management of vehicle-related product quality.\";\n    }\n\n    type Mass {\n        unit : String;\n        value : Real;\n    }\n\n    type ComplianceResult {\n        vehicle : Vehicle;\n        measuredMass : Mass;\n        isCompliant : Boolean;\n    }\n\n}\n\nblock WeighingEquipment {\n    operation measure(vehicle : Vehicle) : Mass;\n}\n\nblock TestOperator {\n    operation operate(equipment : WeighingEquipment, vehicle : Vehicle) : Mass;\n}",
    "package WaterSupplyNetwork {\n\n    interface Spigot {\n        out port hotWater: WaterPort;\n        out port coldWater: WaterPort;\n    }\n\n    interface FaucetInlet {\n        in port hotWater: WaterPort;\n        in port coldWater: WaterPort;\n    }\n\n    part type SpigotBank {\n        port spigots: Spigot[];\n    }\n\n    part type Faucet {\n        port inlets: FaucetInlet;\n    }\n\n    part type WaterSupplyNetwork {\n        part mainSupply: SpigotBank;\n        part faucets: Faucet[];\n\n        constraint requirement ReliableDelivery {\n            description: \"The system shall reliably deliver hot and cold water from the main supply to all faucet inlets.\"\n        }\n\n        constraint requirement SimultaneousSupply {\n            description: \"The system shall support simultaneous supply of hot and cold water to multiple faucets.\"\n        }\n\n        constraint requirement CorrectConnection {\n            description: \"The system shall guarantee correct connection of hot and cold water pipelines between main supply and faucets.\"\n        }\n\n        constraint requirement SmoothTransmission {\n            description: \"The system shall ensure smooth transmission of water through all pipelines.\"\n        }\n\n        connect mainSupply.spigots[*].hotWater -> faucets[*].inlets.hotWater;\n        connect mainSupply.spigots[*].coldWater -> faucets[*].inlets.coldWater;\n    }\n\n    flow type WaterPort {\n        item: Water;\n        direction: inout;\n    }\n\n    item type Water {\n        property temperature: Temperature;\n    }\n\n    value type Temperature {\n        unit: \"Celsius\";\n    }\n}",
    "package VehicleQualityAnalysisSystem {\n\n    part VehicleQualityAnalysisSystem {\n        // Key Components\n        part vehicle: Vehicle;\n        part engine: Engine;\n        part transmission: Transmission;\n        part frontAxle: FrontAxleAssembly;\n        part rearAxle: RearAxleAssembly;\n\n        // User Interaction\n        interface QualityDataInput {\n            in qualityData: QualityData;\n        }\n\n        // Aggregation and Calculation\n        action aggregateComponentQuality {\n            in engineQuality: QualityData;\n            in transmissionQuality: QualityData;\n            in frontAxleQuality: QualityData;\n            in rearAxleQuality: QualityData;\n            out totalVehicleQuality: QualityData;\n        }\n\n        action calculateTotalMass {\n            in engineMass: Mass;\n            in transmissionMass: Mass;\n            in frontAxleMass: Mass;\n            in rearAxleMass: Mass;\n            out totalVehicleMass: Mass;\n        }\n\n        // Quality Analysis\n        requirement QualityAnalysisRequirement {\n            text = \"The system shall support the definition and management of quality analysis requirements for vehicles and their key components.\";\n        }\n\n        usecase DefineQualityAnalysisRequirement {\n            description = \"User defines quality analysis requirements for vehicle and components.\";\n        }\n\n        usecase FormulateAnalysisUseCase {\n            description = \"User formulates analysis use cases based on requirements.\";\n        }\n\n        usecase GenerateAnalysisTaskAndPlan {\n            description = \"System automatically generates analysis tasks and plans based on objectives.\";\n        }\n\n        usecase EvaluateAndTrackRequirements {\n            description = \"System performs comprehensive evaluation and requirements tracking for vehicle quality.\";\n        }\n\n        // Objectives and Support\n        requirement PerformanceOptimizationSupport {\n            text = \"The system shall provide scientific support for vehicle design and performance optimization.\";\n        }\n\n        requirement DevelopmentEfficiency {\n            text = \"The system shall improve overall development efficiency and product performance.\";\n        }\n    }\n\n    part Vehicle {\n        part engine: Engine;\n        part transmission: Transmission;\n        part frontAxle: FrontAxleAssembly;\n        part rearAxle: RearAxleAssembly;\n        attribute totalMass: Mass;\n        attribute totalQuality: QualityData;\n    }\n\n    part Engine {\n        attribute mass: Mass;\n        attribute quality: QualityData;\n    }\n\n    part Transmission {\n        attribute mass: Mass;\n        attribute quality: QualityData;\n    }\n\n    part FrontAxleAssembly {\n        attribute mass: Mass;\n        attribute quality: QualityData;\n    }\n\n    part RearAxleAssembly {\n        attribute mass: Mass;\n        attribute quality: QualityData;\n    }\n\n    type Mass is Real;\n    type QualityData;\n\n    // Non-functional requirements\n    requirement DataFoundation {\n        text = \"The system shall provide a data foundation for quality analysis.\";\n    }\n\n    requirement ComprehensiveEvaluation {\n        text = \"The system shall achieve comprehensive evaluation and requirements tracking for vehicle quality.\";\n    }\n}",
    "system VehiclePowertrainConfigurationOptimizer {\n\n    // Functional Requirements\n    requirement ProvideOptimalEngineConfiguration {\n        description: \"The system shall provide optimal solutions for vehicle powertrain configuration by selecting the best engine configuration based on multiple key performance indicators.\"\n    }\n\n    requirement SupportEngineStructureModeling {\n        description: \"The system shall support modeling of various engine structures, including but not limited to four-cylinder and six-cylinder engines.\"\n    }\n\n    requirement AutoAssembleEngineComponents {\n        description: \"The system shall automatically assemble related engine components such as cylinders, pistons, connecting rods, and crankshafts.\"\n    }\n\n    requirement PerformMultiAttributeTradeoffAnalysis {\n        description: \"The system shall perform trade-off analysis across multiple key performance indicators: power, mass, efficiency, reliability, and cost.\"\n    }\n\n    requirement EvaluateEngineSchemes {\n        description: \"The system shall comprehensively assess the performance data of different engine schemes using a pre-defined evaluation model.\"\n    }\n\n    requirement RecommendOptimalEngineSolution {\n        description: \"The system shall automatically recommend the optimal engine solution based on evaluation results.\"\n    }\n\n    requirement ProvideDecisionTransparency {\n        description: \"The system shall provide users with explanations on the rationality of engine selection, ensuring decision transparency and traceability.\"\n    }\n\n    // Non-Functional Requirements\n    requirement EnsurePerformanceEconomyBalance {\n        description: \"The system shall ensure the best balance between vehicle performance and economy in its recommendations.\"\n    }\n\n    // Key Performance Indicators\n    kpi Power\n    kpi Mass\n    kpi Efficiency\n    kpi Reliability\n    kpi Cost\n\n    // Structure\n    part engine: Engine\n    part evaluationModel: EvaluationModel\n    part tradeoffAnalyzer: TradeoffAnalyzer\n    part recommendationModule: RecommendationModule\n    part explanationModule: ExplanationModule\n\n    // Engine Structure\n    block Engine {\n        attribute type: EngineType\n        attribute cylinderCount: Integer\n        part cylinders: Cylinder[cylinderCount]\n        part pistons: Piston[cylinderCount]\n        part connectingRods: ConnectingRod[cylinderCount]\n        part crankshaft: Crankshaft\n    }\n\n    enum EngineType {\n        FourCylinder\n        SixCylinder\n        // Extendable for other engine types\n    }\n\n    block Cylinder {}\n    block Piston {}\n    block ConnectingRod {}\n    block Crankshaft {}\n\n    // Evaluation Model\n    block EvaluationModel {\n        input engine: Engine\n        output performanceData: PerformanceData\n        operation evaluate(engine: Engine): PerformanceData\n    }\n\n    block PerformanceData {\n        attribute power: Real\n        attribute mass: Real\n        attribute efficiency: Real\n        attribute reliability: Real\n        attribute cost: Real\n    }\n\n    // Trade-off Analyzer\n    block TradeoffAnalyzer {\n        input performanceData: PerformanceData[]\n        output tradeoffResults: TradeoffResults\n        operation analyze(data: PerformanceData[]): TradeoffResults\n    }\n\n    block TradeoffResults {\n        attribute rankedEngines: Engine[]\n        attribute scores: Real[]\n    }\n\n    // Recommendation Module\n    block RecommendationModule {\n        input tradeoffResults: TradeoffResults\n        output recommendedEngine: Engine\n        operation recommend(results: TradeoffResults): Engine\n    }\n\n    // Explanation Module\n    block ExplanationModule {\n        input recommendedEngine: Engine\n        input tradeoffResults: TradeoffResults\n        output explanation: String\n        operation generateExplanation(engine: Engine, results: TradeoffResults): String\n    }\n\n    // Use Cases\n    usecase ModelEngineStructures\n    usecase AssembleEngineComponents\n    usecase PerformTradeoffAnalysis\n    usecase EvaluateEngineSchemes\n    usecase RecommendOptimalEngine\n    usecase ProvideSelectionExplanation\n\n    // Relationships\n    realize ProvideOptimalEngineConfiguration\n    realize SupportEngineStructureModeling\n    realize AutoAssembleEngineComponents\n    realize PerformMultiAttributeTradeoffAnalysis\n    realize EvaluateEngineSchemes\n    realize RecommendOptimalEngineSolution\n    realize ProvideDecisionTransparency\n    realize EnsurePerformanceEconomyBalance\n\n    // Traceability\n    satisfy ProvideOptimalEngineConfiguration -> RecommendOptimalEngine\n    satisfy SupportEngineStructureModeling -> ModelEngineStructures\n    satisfy AutoAssembleEngineComponents -> AssembleEngineComponents\n    satisfy PerformMultiAttributeTradeoffAnalysis -> PerformTradeoffAnalysis\n    satisfy EvaluateEngineSchemes -> EvaluateEngineSchemes\n    satisfy RecommendOptimalEngineSolution -> RecommendOptimalEngine\n    satisfy ProvideDecisionTransparency -> ProvideSelectionExplanation\n    satisfy EnsurePerformanceEconomyBalance -> RecommendOptimalEngine\n\n}",
    "requirement FuelEconomyRegulatoryCompliance {\n    description: \"The system shall ensure that vehicle fuel economy meets regulatory and performance requirements for both urban and highway driving conditions.\"\n    satisfies: FuelEconomyUrban, FuelEconomyHighway\n}\n\nrequirement FuelEconomyUrban {\n    description: \"Under urban driving conditions, the vehicle’s range per gallon shall not be less than 25 miles.\"\n    measure: FuelEconomy\n    condition: UrbanDrivingScenario\n    minimum: 25 mi/gal\n}\n\nrequirement FuelEconomyHighway {\n    description: \"Under highway driving conditions, the vehicle’s range per gallon shall not be less than 30 miles.\"\n    measure: FuelEconomy\n    condition: HighwayDrivingScenario\n    minimum: 30 mi/gal\n}\n\nmeasure FuelEconomy {\n    unit: mi/gal\n    definition: \"Distance traveled per US gallon of fuel consumed (1 US gallon = 231 cubic inches).\"\n}\n\nscenario UrbanDrivingScenario {\n    description: \"Standard urban driving scenario with an additional load of 1,000 pounds.\"\n    load: 1000 lb\n    operating_conditions: Urban\n}\n\nscenario HighwayDrivingScenario {\n    description: \"Standard highway driving scenario with an additional load of 1,000 pounds.\"\n    load: 1000 lb\n    operating_conditions: Highway\n}\n\npart Vehicle {\n    property powertrain: Powertrain\n    property load: Load\n    property operating_conditions: OperatingConditions\n}\n\npart Powertrain {\n    // Details of powertrain modeling omitted for brevity\n}\n\npart Load {\n    value: mass [lb]\n}\n\npart OperatingConditions {\n    kind: {Urban, Highway}\n}\n\nanalysis FuelEconomyAssessment {\n    input: Vehicle\n    output: FuelEconomy\n    description: \"Analyzes vehicle fuel consumption under specified load and operating conditions to assess compliance with fuel economy requirements.\"\n    supports: FuelEconomyRegulatoryCompliance\n}",
    "system VehicleLongitudinalDynamicsSimulator {\n\n    // Functional Requirements\n    requirement InputVehicleParameters {\n        description: \"The system shall allow users to input vehicle mass, initial position, initial velocity, and segmented power output data.\"\n    }\n\n    requirement DynamicComputation {\n        description: \"The system shall calculate acceleration, velocity, and position at each time step using dynamic equations based on input power and operating conditions.\"\n    }\n\n    requirement OutputResults {\n        description: \"The system shall output sequences of acceleration, velocity, and displacement for the entire motion process.\"\n    }\n\n    requirement DataSupport {\n        description: \"The system shall provide data to support vehicle performance analysis, control strategy development, and driving behavior evaluation.\"\n    }\n\n    // Non-Functional Requirements\n    requirement TimeStepSpecification {\n        description: \"The system shall allow specification of the time step for dynamic calculations.\"\n    }\n\n    requirement Accuracy {\n        description: \"The system shall ensure accurate computation of dynamic variables.\"\n    }\n\n    // Structure\n    part vehicle: Vehicle\n    part simulator: DynamicsSimulator\n\n    // Interfaces\n    interface VehicleInput {\n        in mass: Real\n        in initialPosition: Real\n        in initialVelocity: Real\n        in powerOutput: PowerOutputSegment[]\n    }\n\n    interface SimulationOutput {\n        out accelerationSequence: Real[]\n        out velocitySequence: Real[]\n        out positionSequence: Real[]\n    }\n\n    // Usage\n    usecase SimulateLongitudinalDynamics {\n        input: VehicleInput\n        output: SimulationOutput\n        description: \"Simulate and analyze the longitudinal dynamic characteristics of vehicle motion.\"\n    }\n\n    // Relationships\n    satisfies InputVehicleParameters\n    satisfies DynamicComputation\n    satisfies OutputResults\n    satisfies DataSupport\n    satisfies TimeStepSpecification\n    satisfies Accuracy\n\n}\n\ntype PowerOutputSegment {\n    startTime: Real\n    endTime: Real\n    power: Real\n}\n\npart Vehicle {\n    mass: Real\n    initialPosition: Real\n    initialVelocity: Real\n}\n\npart DynamicsSimulator {\n    timeStep: Real\n    inputPower: PowerOutputSegment[]\n    computeAcceleration(): Real\n    computeVelocity(): Real\n    computePosition(): Real\n}",
    "package VehicleSystem {\n\n    part Vehicle {\n        attribute mass: Real = 2500.0; // kg\n\n        part frontAxleAssembly: FrontAxleAssembly;\n        part rearAxleAssembly: RearAxleAssembly;\n    }\n\n    part FrontAxleAssembly {\n        attribute mass: Real = 150.0; // kg\n\n        part leftFrontWheel: Wheel;\n        part rightFrontWheel: Wheel;\n        part frontAxle: FrontAxle;\n    }\n\n    part RearAxleAssembly {\n        attribute mass: Real = 250.0; // kg\n\n        part leftRearWheel: Wheel;\n        part rightRearWheel: Wheel;\n        part rearAxle: RearAxle;\n    }\n\n    part FrontAxle {\n        attribute mass: Real;\n        attribute steeringAngle: Real; // degrees\n    }\n\n    part RearAxle {\n        attribute mass: Real;\n    }\n\n    part Wheel {\n        // Additional attributes can be added as needed\n    }\n}",
    "package VehicleSafetySecuritySystem {\n\n    // Enumerations\n    enum FeatureType {\n        values: Safety, Security\n    }\n\n    enum Mandatoriness {\n        values: Mandatory, Optional\n    }\n\n    // Block Definitions\n    block Vehicle {\n        part seatBelt: SeatBelt\n        part bumper: Bumper\n        part airbag: Airbag\n        part abs: AntiLockBrakingSystem\n        part alarm: AlarmDevice\n        part keylessEntry: KeylessEntrySystem\n    }\n\n    block SeatBelt {\n        featureType: FeatureType = Safety\n        mandatoriness: Mandatoriness = Mandatory\n    }\n\n    block Bumper {\n        featureType: FeatureType = Safety\n        mandatoriness: Mandatoriness = Mandatory\n    }\n\n    block Airbag {\n        featureType: FeatureType = Safety\n        mandatoriness: Mandatoriness = Optional\n    }\n\n    block AntiLockBrakingSystem {\n        featureType: FeatureType = Safety\n        mandatoriness: Mandatoriness = Optional\n    }\n\n    block AlarmDevice {\n        featureType: FeatureType = Security\n        mandatoriness: Mandatoriness = Mandatory\n    }\n\n    block KeylessEntrySystem {\n        featureType: FeatureType = Security\n        mandatoriness: Mandatoriness = Optional\n    }\n\n    // System Functionality\n    block SafetySecurityManagementSystem {\n        part managedVehicle: Vehicle\n\n        operation filterComponentsByFeatureType(type: FeatureType): ComponentList\n        operation filterComponentsByMandatoriness(mandatory: Mandatoriness): ComponentList\n        operation displayConfigurationTree(): TreeView\n        operation displayConfigurationTable(): TableView\n    }\n\n    // Supporting Types\n    type ComponentList\n    type TreeView\n    type TableView\n\n    // Requirements\n    requirement R1 {\n        text: \"The system shall manage and display all vehicle safety and security-related features and components.\"\n    }\n\n    requirement R2 {\n        text: \"The system shall enable users to intuitively understand the safety and security configurations of the entire vehicle and its constituent parts.\"\n    }\n\n    requirement R3 {\n        text: \"The system shall distinguish between mandatory and optional safety features.\"\n    }\n\n    requirement R4 {\n        text: \"The system shall provide filtering and organization of components by safety or security features.\"\n    }\n\n    requirement R5 {\n        text: \"The system shall visualize configurations in tree structures or tables.\"\n    }\n\n    // Satisfy relationships\n    satisfy SafetySecurityManagementSystem -> R1\n    satisfy SafetySecurityManagementSystem -> R2\n    satisfy SafetySecurityManagementSystem -> R3\n    satisfy SafetySecurityManagementSystem -> R4\n    satisfy SafetySecurityManagementSystem -> R5\n\n}",
    "system SystemWithLayeredArchitecture {\n\n    attribute x: Real;\n    attribute y: Real;\n    attribute z: Real;\n    \n    constraint z_dependency {\n        z = f(x, y); // Replace f(x, y) with actual dependency logic\n    }\n\n    part applicationLayer: ApplicationLayer;\n    part serviceLayer: ServiceLayer;\n    part dataLayer: DataLayer;\n\n    // Layered dependencies\n    applicationLayer.uses serviceLayer;\n    serviceLayer.uses dataLayer;\n\n    // Responsibility and data flow constraints\n    constraint clear_responsibility {\n        applicationLayer doesNotUse dataLayer;\n        serviceLayer doesNotUse applicationLayer;\n        dataLayer doesNotUse serviceLayer;\n        dataLayer doesNotUse applicationLayer;\n    }\n\n    constraint smooth_data_flow {\n        applicationLayer.dataFlowTo serviceLayer;\n        serviceLayer.dataFlowTo dataLayer;\n        dataLayer.dataFlowTo serviceLayer;\n        serviceLayer.dataFlowTo applicationLayer;\n    }\n}\n\nblock ApplicationLayer {\n    // Application-specific operations\n    operation useService();\n}\n\nblock ServiceLayer {\n    // Service-specific operations\n    operation retrieveData();\n    operation storeData();\n}\n\nblock DataLayer {\n    // Data storage/retrieval operations\n    operation getData();\n    operation setData();\n}",
    "system PowertrainTorqueGenerationSystem {\n    \n    part logicLayer : LogicLayer\n    part physicalLayer : PhysicalLayer\n\n    requirement TorqueGeneration_Positive {\n        text \"The system shall generate torque greater than zero newton-meters during operation.\"\n    }\n\n    requirement TorqueMapping {\n        text \"The logic layer's torque generator function shall be allocated and mapped to the physical layer components (e.g., engine) to ensure actual torque generation and transmission.\"\n    }\n\n    function generateTorque {\n        out torque : Torque\n        constraint torque_positive {\n            torque.value > 0 N*m\n        }\n    }\n\n    part torqueGenerator : TorqueGenerator\n    part engine : Engine\n\n    allocate generateTorque to torqueGenerator\n    allocate generateTorque to engine\n\n    satisfy TorqueGeneration_Positive by generateTorque\n    satisfy TorqueMapping by torqueGenerator\n    satisfy TorqueMapping by engine\n\n    composition {\n        logicLayer.torqueGenerator = torqueGenerator\n        physicalLayer.engine = engine\n    }\n}\n\nblock LogicLayer {\n    part torqueGenerator : TorqueGenerator\n}\n\nblock PhysicalLayer {\n    part engine : Engine\n}\n\nblock TorqueGenerator {\n    function generateTorque\n}\n\nblock Engine {\n    function generateTorque\n}\n\ntype Torque {\n    value : Real\n    unit : \"N*m\"\n}",
    "package power_transmission_system {\n\n    // Functional (Logical) Model\n    part system {\n        function transmit_power;\n        function output_power;\n        function provide_power;\n        function generate_torque;\n        part torque_generator: torque_generator_component;\n    }\n\n    part torque_generator_component {\n        function generate_torque;\n    }\n\n    // Physical Model\n    part powertrain {\n        part engine: engine_component;\n    }\n\n    part engine_component {\n        function execute_torque_generation;\n    }\n\n    // Allocation: Logical to Physical Mapping\n    allocate system.torque_generator.generate_torque to powertrain.engine.execute_torque_generation;\n\n}",
    "package VehicleSafetyAndAntiTheftCatalogue {\n\n    // Functional Requirements\n    requirement BasicSafetyComponents {\n        description: \"The vehicle shall be equipped with basic safety components to ensure fundamental personal safety of occupants.\"\n    }\n\n    requirement MandatorySafetyComponents {\n        description: \"Front seat belts and bumpers shall be installed on the body and interior as mandatory safety components.\"\n    }\n\n    requirement OptionalSafetyFeatures {\n        description: \"Driver’s airbag and anti-lock braking system (ABS) may be installed depending on specific configurations.\"\n    }\n\n    requirement SecurityComponents {\n        description: \"The vehicle should be equipped with security components to enhance overall security and protective capability.\"\n    }\n\n    requirement AlarmSystem {\n        description: \"The vehicle should be equipped with an alarm system.\"\n    }\n\n    requirement KeylessEntrySystem {\n        description: \"The vehicle should be equipped with a keyless entry system.\"\n    }\n\n    // Non-Functional Requirements\n    requirement RegulatoryCompliance {\n        description: \"All mandatory safety components shall meet regulatory requirements.\"\n    }\n\n    requirement UserProtectionNeeds {\n        description: \"The vehicle shall meet users’ needs for basic safety and protection functions.\"\n    }\n\n    // Features\n    feature FrontSeatBelt {\n        description: \"Front seat belt installed on the body and interior.\"\n        satisfies: MandatorySafetyComponents\n    }\n\n    feature Bumper {\n        description: \"Bumper installed on the body and interior.\"\n        satisfies: MandatorySafetyComponents\n    }\n\n    feature DriverAirbag {\n        description: \"Driver’s airbag as an optional safety feature.\"\n        satisfies: OptionalSafetyFeatures\n    }\n\n    feature AntiLockBrakingSystem {\n        description: \"Anti-lock braking system (ABS) as an optional safety feature.\"\n        satisfies: OptionalSafetyFeatures\n    }\n\n    feature AlarmSystemFeature {\n        description: \"Alarm system as a security component.\"\n        satisfies: AlarmSystem\n    }\n\n    feature KeylessEntrySystemFeature {\n        description: \"Keyless entry system as a security component.\"\n        satisfies: KeylessEntrySystem\n    }\n\n    // Component Classification\n    classification SafetyComponent {\n        description: \"Component that affects vehicle safety.\"\n    }\n\n    classification SecurityComponent {\n        description: \"Component that affects vehicle anti-theft.\"\n    }\n\n    classification SafetyAndSecurityComponent {\n        description: \"Component that affects both safety and anti-theft.\"\n    }\n\n    // Mapping features to classifications\n    FrontSeatBelt specializes SafetyComponent\n    Bumper specializes SafetyComponent\n    DriverAirbag specializes SafetyComponent\n    AntiLockBrakingSystem specializes SafetyComponent\n    AlarmSystemFeature specializes SecurityComponent\n    KeylessEntrySystemFeature specializes SecurityComponent\n\n    // Vehicle System Definition\n    part Vehicle {\n        feature frontSeatBelt: FrontSeatBelt\n        feature bumper: Bumper\n        feature driverAirbag: DriverAirbag\n        feature abs: AntiLockBrakingSystem\n        feature alarmSystem: AlarmSystemFeature\n        feature keylessEntry: KeylessEntrySystemFeature\n    }\n\n}",
    "package FuelSystem {\n\n    part vehicle : Vehicle;\n\n    part fuelSystem : FuelSystem {\n        part fuelTankAssembly : FuelTankAssembly {\n            part fuelTank : FuelTank;\n            part fuelPump : FuelPump;\n        }\n        part fuelReturnLine : FuelReturnLine;\n        part fuelTemperatureSensor : FuelTemperatureSensor;\n    }\n\n    part fuelConsumingUnit : FuelConsumingUnit;\n\n    interface FuelFlow {\n        inout fuel : Fuel;\n    }\n\n    interface DataFlow {\n        out temperature : Temperature;\n    }\n\n    flowPort fuelOut : FuelFlow out;\n    flowPort fuelIn : FuelFlow in;\n    flowPort returnFuel : FuelFlow in;\n    flowPort tempData : DataFlow out;\n\n    connection fuelDelivery {\n        from fuelSystem.fuelTankAssembly.fuelPump.fuelOut\n        to fuelConsumingUnit.fuelIn;\n    }\n\n    connection fuelReturn {\n        from fuelConsumingUnit.returnFuel\n        to fuelSystem.fuelReturnLine.fuelIn;\n        from fuelSystem.fuelReturnLine.fuelOut\n        to fuelSystem.fuelTankAssembly.fuelTank.fuelIn;\n    }\n\n    connection temperatureMonitoring {\n        from fuelSystem.fuelTemperatureSensor.tempData\n        to vehicle.dataBus;\n    }\n\n    requirement FuelSupply {\n        description \"The system shall deliver pressurized fuel from the fuel tank to all fuel-consuming units.\"\n    }\n\n    requirement FuelReturn {\n        description \"The system shall return unused fuel from the fuel-consuming units back to the fuel tank.\"\n    }\n\n    requirement TemperatureMonitoring {\n        description \"The system shall monitor and transmit real-time fuel temperature information.\"\n    }\n\n    requirement InterfaceDefinition {\n        description \"The system shall clearly specify all fuel and data flow interfaces between components.\"\n    }\n\n    requirement Reliability {\n        description \"The system shall ensure reliable fuel supply and effective return management.\"\n    }\n\n    constraint Safety {\n        description \"Fuel temperature must be monitored to ensure safe operation.\"\n    }\n\n    constraint Efficiency {\n        description \"Fuel transport must be efficient as measured by minimal loss and optimal flow.\"\n    }\n}",
    "package VehicleSafetySecurityCompliance {\n\n    part Vehicle {\n        part interior: Interior\n        part body: Body\n        part chassis: Chassis\n        part security: Security\n    }\n\n    part Interior {\n        part seatBelt1: SeatBelt\n        part seatBelt2: SeatBelt\n        part airbag: Airbag\n    }\n\n    part Body {\n        part bumper: Bumper\n        part keylessEntry: KeylessEntrySystem\n    }\n\n    part Chassis {\n        part wheel1: Wheel\n        part wheel2: Wheel\n        part abs1: AntiLockBrakingSystem\n        part abs2: AntiLockBrakingSystem\n    }\n\n    part Security {\n        part antiTheftAlarm: AntiTheftAlarm\n    }\n\n    requirement SeatBeltRequirement {\n        text \"The vehicle interior must be equipped with two seat belts, which are mandatory safety features.\"\n        verify [interior.seatBelt1, interior.seatBelt2]\n        category: safety\n        mandatory: true\n    }\n\n    requirement AirbagRequirement {\n        text \"An airbag should also be installed in the cockpit, but its application is not mandatory.\"\n        verify [interior.airbag]\n        category: safety\n        mandatory: false\n    }\n\n    requirement AntiTheftAlarmRequirement {\n        text \"An anti-theft alarm device should be installed inside the vehicle to enhance security protection.\"\n        verify [security.antiTheftAlarm]\n        category: security\n        mandatory: true\n    }\n\n    requirement BumperRequirement {\n        text \"The vehicle body must be equipped with a bumper, which is a required safety component.\"\n        verify [body.bumper]\n        category: safety\n        mandatory: true\n    }\n\n    requirement KeylessEntryRequirement {\n        text \"The vehicle body is required to have a keyless entry system to improve security performance.\"\n        verify [body.keylessEntry]\n        category: security\n        mandatory: true\n    }\n\n    requirement WheelRequirement {\n        text \"The chassis structure is to be fitted with two wheels.\"\n        verify [chassis.wheel1, chassis.wheel2]\n        category: safety\n        mandatory: true\n    }\n\n    requirement ABSRequirement {\n        text \"The chassis is to be equipped with two sets of anti-lock braking systems, although the installation of such braking systems is not mandatory.\"\n        verify [chassis.abs1, chassis.abs2]\n        category: safety\n        mandatory: false\n    }\n\n    requirement IdentificationClassificationRequirement {\n        text \"All aforementioned components related to safety and security are subject to identification and classification management by the system to ensure compliance with regulations regarding critical safety and security functions.\"\n        verify [interior.seatBelt1, interior.seatBelt2, interior.airbag, body.bumper, body.keylessEntry, security.antiTheftAlarm, chassis.abs1, chassis.abs2]\n        category: compliance\n        mandatory: true\n    }\n}",
    "package VehicleSafetyAndSecuritySystem {\n\n    part VehicleSafetyAndSecurityComponentSystem {\n        part interior: Interior\n        part bodyAssembly: BodyAssembly\n        satisfies SafetyAndSecurityRequirements\n    }\n\n    part Interior {\n        part alarmSystem: AlarmSystem\n        part seatBelts: SeatBelts\n        part frontRowSeats: FrontRowSeats\n        part driverAirbag: Airbag\n    }\n\n    part BodyAssembly {\n        part vehicleBody: VehicleBody\n        part bumper: Bumper\n        part keylessEntrySystem: KeylessEntrySystem\n    }\n\n    part AlarmSystem {}\n    part SeatBelts {}\n    part FrontRowSeats {}\n    part Airbag {}\n    part VehicleBody {}\n    part Bumper {}\n    part KeylessEntrySystem {}\n\n    requirement SafetyAndSecurityRequirements {\n        text \"The system shall integrate safety and security functions to provide comprehensive protection and convenient user experience.\"\n        satisfies SafetyFeatures\n        satisfies SecurityFeatures\n    }\n\n    requirement SafetyFeatures {\n        text \"The system shall include seat belts, airbags, and bumpers to enhance protection of driver and passengers during driving.\"\n    }\n\n    requirement SecurityFeatures {\n        text \"The system shall include an onboard alarm and keyless entry system to support anti-theft and convenient access.\"\n    }\n\n    satisfies VehicleSafetyAndSecurityComponentSystem -> SafetyAndSecurityRequirements\n\n}",
    "package InformationSecurityManagement {\n\n    enum SecurityClassification {\n        Unclassified,\n        Confidential,\n        Secret\n    }\n\n    attribute securityClassification : SecurityClassification;\n\n    part Component {\n        attribute securityClassification : SecurityClassification;\n    }\n\n    constraint AllComponentsHaveClassification {\n        for each c in Component {\n            c.securityClassification != null;\n        }\n    }\n\n    behavior DisplayClassification {\n        input c : Component;\n        output classificationLabel : SecurityClassification;\n        precondition c.securityClassification != null;\n        postcondition classificationLabel == c.securityClassification;\n    }\n\n    requirement R1 {\n        text = \"Each component shall be assigned a security classification level: Unclassified, Confidential, or Secret.\"\n    }\n\n    requirement R2 {\n        text = \"When a component is marked as 'Confidential', the system shall recognize and display its classification attribute.\"\n    }\n\n    requirement R3 {\n        text = \"The system shall enable effective differentiation and protection of sensitive information during operation and document management based on component classification.\"\n    }\n}",
    "package automotive_ecu_communication {\n\n    part VehicleControlUnit {\n        port canBusIF: BusInterface;\n        port sensorIF: SensorInterface;\n    }\n\n    part EngineControlUnit {\n        port canBusIF: BusInterface;\n        port sensorIF: SensorInterface;\n    }\n\n    part CANBus {\n        port vcuIF: BusInterface;\n        port ecuIF: BusInterface;\n    }\n\n    interface BusInterface {\n        inout canData: CANMessage;\n    }\n\n    interface SensorInterface {\n        in sensorData: SensorData;\n        out controlSignal: ControlCommand;\n    }\n\n    type CANMessage {\n        attribute id: Integer;\n        attribute data: Byte[8];\n    }\n\n    type SensorData {\n        attribute value: Real;\n        attribute type: String;\n    }\n\n    type ControlCommand {\n        attribute commandType: String;\n        attribute value: Real;\n    }\n\n    connection vcu_can: VehicleControlUnit.canBusIF <-> CANBus.vcuIF;\n    connection ecu_can: EngineControlUnit.canBusIF <-> CANBus.ecuIF;\n\n    // Non-functional requirements\n    requirement Safety {\n        description: \"The system shall ensure safe communication and control between VCU and ECU, with fault detection and isolation capabilities.\";\n    }\n\n    requirement Performance {\n        description: \"The system shall support real-time data exchange with latency less than 10ms on the CAN bus.\";\n    }\n\n    requirement Expandability {\n        description: \"The system shall provide reserved sensor interfaces for future functional expansion.\";\n    }\n\n    // Information flow\n    flow vehicle_state: VehicleControlUnit.canBusIF.canData -> EngineControlUnit.canBusIF.canData;\n    flow engine_state: EngineControlUnit.canBusIF.canData -> VehicleControlUnit.canBusIF.canData;\n\n    // Sensor data exchange (reserved for future use)\n    flow sensor_to_vcu: VehicleControlUnit.sensorIF.sensorData;\n    flow sensor_to_ecu: EngineControlUnit.sensorIF.sensorData;\n\n}",
    "requirement BloodGlucoseMeterReliabilitySafety {\n    description \"Ensure high reliability and safety of the blood glucose meter during use.\"\n    rationale \"To prevent failure to measure blood glucose levels and treatment delays due to battery or measurement function issues.\"\n}\n\nrequirement BatteryStatusDetection {\n    description \"The system shall automatically detect the battery status, including depletion and inability to charge.\"\n    verify method \"Test and analysis of battery status detection under various battery conditions.\"\n}\n\nrequirement UserAlertOnBatteryIssue {\n    description \"The system shall promptly alert the user when the battery is depleted or cannot be charged.\"\n    verify method \"Demonstration of user alert mechanisms under simulated battery failure.\"\n}\n\nrequirement PreventiveMeasuresForBattery {\n    description \"The system shall implement preventive measures to avoid failure to measure blood glucose levels due to battery issues.\"\n    verify method \"Inspection of preventive design features and their effectiveness.\"\n}\n\nrequirement AlarmAndEmergencyResponse {\n    description \"The system shall provide appropriate alarm and emergency response mechanisms in case of abnormalities in the blood glucose measurement function.\"\n    verify method \"Test of alarm and emergency response under simulated measurement function abnormalities.\"\n}\n\nrequirement RiskManagement {\n    description \"The system requirements shall undergo rigorous approval, and management measures shall be established for key risk scenarios.\"\n    verify method \"Review of requirement approval records and risk management documentation.\"\n}\n\nrequirement ContinuousTherapeuticSupport {\n    description \"The system shall ensure patients receive timely, continuous, and safe therapeutic support under all circumstances.\"\n    verify method \"System-level validation under various operational and failure scenarios.\"\n}\n\nperformance requirement HighReliability {\n    description \"The system shall achieve a high reliability metric as defined by applicable medical device standards.\"\n    metric \"Reliability >= 99.9% during intended use period.\"\n}\n\nperformance requirement HighSafety {\n    description \"The system shall meet safety requirements as defined by applicable medical device standards.\"\n    metric \"No single point of failure shall result in unsafe operation.\"\n}\n\npart BloodGlucoseMeter {\n    satisfies BloodGlucoseMeterReliabilitySafety\n    satisfies BatteryStatusDetection\n    satisfies UserAlertOnBatteryIssue\n    satisfies PreventiveMeasuresForBattery\n    satisfies AlarmAndEmergencyResponse\n    satisfies RiskManagement\n    satisfies ContinuousTherapeuticSupport\n    satisfies HighReliability\n    satisfies HighSafety\n}",
    "package ScientificConstants {\n\n    // Mathematical Constants\n    constant e: Real = 2.71828182845904523536;\n    constant pi: Real = 3.14159265358979323846;\n\n    // Physical Constants\n    constant speedOfLight: Real = 299792458.0 @ m/s; // Speed of light in vacuum (exact, SI)\n    constant fineStructureConstant: Real = 0.0072973525693; // Dimensionless\n    constant electronToProtonMassRatio: Real = 0.000544617021487; // Dimensionless\n\n    // Scenario-based Constants\n    constant standardGravitationalAcceleration: Real = 9.80665 @ m/s^2; // Standard gravity on Earth (SI)\n    constant amplifierGainCoefficient_ModelX: Real = 45.0; // Example: dimensionless, specific to Model X\n\n    // Accessibility and Verification\n    requirement constantsAccessible {\n        description: \"All constants shall be accessible by system components and external interfaces.\"\n    }\n\n    requirement constantsVerifiable {\n        description: \"All constants shall be verifiable against authoritative scientific sources.\"\n    }\n\n    requirement constantsPrecision {\n        description: \"All constants shall provide at least 20 decimal digits of precision where applicable.\"\n    }\n\n    requirement constantsUnitAnnotation {\n        description: \"All physical constants shall have clear SI unit annotations.\"\n    }\n}",
    "package automotive::tire_specification {\n\n    type ManufacturerName : String;\n    type RimDiameter : Real;\n    type TireWidth : Integer;\n\n    part Tire {\n        attribute manufacturer : ManufacturerName;\n        attribute rimDiameter : RimDiameter;\n        attribute width : TireWidth;\n    }\n\n    instance FrenchTire : Tire {\n        manufacturer = \"Michelin\";\n        rimDiameter = 18.0;\n        width = 245;\n    }\n\n}",
    "model AutomotiveComponentModel {\n\n    import sysml::units::*;\n    import sysml::types::*;\n\n    // Tire definition\n    part Tire {\n        // Additional tire properties can be added here\n    }\n\n    // Wheel definition\n    part Wheel {\n        attribute hubDiameter: Length = 18 * inch; // 18 inches\n        attribute width: Length = 245 * millimeter; // 245 mm\n        attribute tireHeight: Length; // To be specified for outer diameter calculation\n\n        // Outer diameter is calculated as hub diameter + 2 * tire height\n        attribute outerDiameter: Length = hubDiameter + 2 * tireHeight;\n\n        part tire: Tire;\n    }\n\n    // Vehicle definition\n    part Vehicle {\n        attribute mass: Mass = 1200 * kilogram;\n        attribute length: Length = 4.82 * meter;\n\n        // Front wheels: left and right\n        part frontLeftWheel: Wheel;\n        part frontRightWheel: Wheel;\n    }\n}",
    "package powertrain_config {\n\n    enum EngineType {\n        four_cylinder,\n        six_cylinder\n    }\n\n    enum TransmissionType {\n        manual,\n        automatic\n    }\n\n    enum ModelType {\n        standard,\n        high_performance\n    }\n\n    part Vehicle {\n        attribute engine: EngineType;\n        attribute transmission: TransmissionType;\n        attribute model: ModelType;\n    }\n\n    constraint valid_engine_selection {\n        if Vehicle.model == ModelType.high_performance {\n            Vehicle.engine == EngineType.six_cylinder\n        } else {\n            Vehicle.engine == EngineType.four_cylinder\n        }\n    }\n\n    constraint valid_powertrain_combinations {\n        (Vehicle.engine == EngineType.four_cylinder and Vehicle.transmission == TransmissionType.manual)\n        or\n        (Vehicle.engine == EngineType.six_cylinder and Vehicle.transmission == TransmissionType.automatic)\n    }\n\n}",
    "package AutomotiveSystem {\n\n    part Vehicle {\n        attribute mass: Real = 1200.0; // kilograms\n        attribute length: Real = 4.82; // meters\n        part wheelAssemblies: WheelAssembly[*];\n    }\n\n    part WheelAssembly {\n        part wheel: Wheel;\n        part brakeDisc: BrakeDisc;\n        constraint brakeDiscDiameterLessThanWheelOuterDiameter {\n            brakeDisc.diameter < wheel.outerDiameter\n        }\n        constraint brakeDiscFitsRim {\n            brakeDisc.diameter < wheel.rim.diameter\n        }\n    }\n\n    part Wheel {\n        part rim: Rim;\n        part tire: Tire;\n        attribute outerDiameter: Real;\n        constraint calculateOuterDiameter {\n            // Outer diameter in mm: rim diameter (in mm) + 2 * tire height\n            outerDiameter = rim.diameter * 25.4 + 2 * tire.height\n        }\n    }\n\n    part Rim {\n        attribute diameter: Real = 18.0; // inches\n    }\n\n    part Tire {\n        attribute width: Real = 245.0; // millimeters\n        attribute height: Real = 45.0; // millimeters\n        attribute treadDepth: Real = 6.0; // millimeters\n        constraint treadDepthMinimum {\n            treadDepth >= 3.5\n        }\n    }\n\n    part BrakeDisc {\n        attribute radius: Real = 95.0; // millimeters\n        attribute diameter: Real;\n        constraint calculateDiameter {\n            diameter = 2 * radius\n        }\n    }\n\n    constraint allWheelAssembliesFitment {\n        for wa in Vehicle.wheelAssemblies {\n            wa.brakeDisc.diameter < wa.wheel.outerDiameter and\n            wa.brakeDisc.diameter < wa.wheel.rim.diameter * 25.4\n        }\n    }\n}",
    "package automotive_fuel_system {\n\n    requirement FuelSystemFunctional {\n        description \"The system shall provide efficient and safe circulation of fuel among all components, ensuring normal fuel supply to the engine and supporting both supply and return functions.\"\n    }\n\n    requirement FuelTankAssemblyOutlet {\n        description \"The fuel tank assembly shall provide an outlet interface for fuel delivery and a return interface for receiving returned fuel.\"\n    }\n\n    requirement FuelPumpFunction {\n        description \"The fuel pump shall pump fuel from the fuel tank and supply it to the engine, and shall be capable of receiving and handling returned fuel.\"\n    }\n\n    requirement FuelTemperatureMonitoring {\n        description \"The system shall monitor and transmit fuel temperature information.\"\n    }\n\n    part FuelTankAssembly {\n        port fuel_out: out interface FuelPort\n        port fuel_return: in interface FuelPort\n    }\n\n    part FuelPump {\n        port fuel_in: in interface FuelPort\n        port fuel_out: out interface FuelPort\n        port fuel_return: in interface FuelPort\n    }\n\n    part FuelTank {\n        port fuel_out: out interface FuelPort\n        port fuel_in: in interface FuelPort\n    }\n\n    interface FuelPort {\n        property flow_rate: Real\n        property pressure: Real\n        property temperature: Real\n    }\n\n    part FuelTemperatureSensor {\n        port temp_out: out interface TemperaturePort\n    }\n\n    interface TemperaturePort {\n        property temperature: Real\n    }\n\n    part Engine {\n        port fuel_in: in interface FuelPort\n        port fuel_return: out interface FuelPort\n    }\n\n    connection FuelDelivery {\n        from FuelPump.fuel_out\n        to Engine.fuel_in\n    }\n\n    connection FuelReturn {\n        from Engine.fuel_return\n        to FuelTankAssembly.fuel_return\n    }\n\n    connection PumpToTank {\n        from FuelTank.fuel_out\n        to FuelPump.fuel_in\n    }\n\n    connection PumpReturnToTank {\n        from FuelPump.fuel_return\n        to FuelTank.fuel_in\n    }\n\n    connection TempMonitoring {\n        from FuelTemperatureSensor.temp_out\n        to FuelTankAssembly\n    }\n\n    satisfies FuelTankAssembly -> FuelTankAssemblyOutlet\n    satisfies FuelPump -> FuelPumpFunction\n    satisfies FuelTankAssembly -> FuelSystemFunctional\n    satisfies FuelPump -> FuelSystemFunctional\n    satisfies FuelTank -> FuelSystemFunctional\n    satisfies FuelTemperatureSensor -> FuelTemperatureMonitoring\n\n}",
    "package PhysicalQuantitySystem {\n\n    import sysml::units::*;\n    import sysml::quantities::*;\n\n    part system: PhysicalQuantitySystem {\n        reqs: {\n            requirement SupportISQBaseQuantities {\n                text \"The system shall support management of data and units for ISQ base physical quantities: length, mass, time, electric current, temperature, amount of substance, and luminous intensity.\"\n            }\n            requirement AccurateRepresentation {\n                text \"The system shall ensure accurate representation and consistency of physical quantity information.\"\n            }\n            requirement UnitConversion {\n                text \"The system shall support unit conversion operations for all managed physical quantities.\"\n            }\n            requirement Extensibility {\n                text \"The system shall allow import and extension to cover additional physical quantities and units.\"\n            }\n            requirement DiverseUserNeeds {\n                text \"The system shall meet diverse user requirements for managing physical quantity systems.\"\n            }\n        }\n    }\n\n    quantity kind Length {}\n    quantity kind Mass {}\n    quantity kind Time {}\n    quantity kind ElectricCurrent {}\n    quantity kind ThermodynamicTemperature {}\n    quantity kind AmountOfSubstance {}\n    quantity kind LuminousIntensity {}\n\n    unit Meter: Length {}\n    unit Kilogram: Mass {}\n    unit Second: Time {}\n    unit Ampere: ElectricCurrent {}\n    unit Kelvin: ThermodynamicTemperature {}\n    unit Mole: AmountOfSubstance {}\n    unit Candela: LuminousIntensity {}\n\n    interface PhysicalQuantityManager {\n        operation importQuantityKind(kind: QuantityKind): Boolean\n        operation importUnit(unit: Unit): Boolean\n        operation convert(value: Real, from: Unit, to: Unit): Real\n        operation validateConsistency(quantity: Quantity): Boolean\n    }\n\n    part manager: PhysicalQuantityManager\n\n    constraint AccurateUnitMapping {\n        for all q: Quantity | validateConsistency(q)\n    }\n}",
    "package UnitSystemLibrary {\n\n    // Purpose: Standardized unit system library for ISQ and USCustomaryUnits interoperability\n\n    part isq: UnitSystem {\n        description = \"International System of Quantities (ISQ) unit system\"\n    }\n\n    part us_customary: UnitSystem {\n        description = \"United States Customary Units system\"\n    }\n\n    interface UnitConversion {\n        input source_unit: Unit\n        input target_unit: Unit\n        input value: Real\n        output converted_value: Real\n        constraint valid_conversion: source_unit.quantity_kind == target_unit.quantity_kind\n        requirement accuracy: Real { description = \"Conversion must maintain authoritative accuracy\" }\n    }\n\n    interface UnitManagement {\n        input unit: Unit\n        input action: UnitAction\n        output status: Status\n        requirement standardization: Boolean { description = \"All units must be standardized and authoritative\" }\n    }\n\n    interface UnitApplication {\n        input unit: Unit\n        input quantity: Real\n        output result: Real\n        requirement applicability: Boolean { description = \"Units must be applicable to engineering, scientific, and daily life contexts\" }\n    }\n\n    requirement Interoperability {\n        description = \"The system shall support seamless interoperability and adaptation between ISQ and USCustomaryUnits.\"\n    }\n\n    requirement Accuracy {\n        description = \"The system shall ensure authoritative accuracy for all unit conversions and representations.\"\n    }\n\n    requirement Standardization {\n        description = \"All unit types shall be standardized according to recognized authorities.\"\n    }\n\n    requirement Usability {\n        description = \"The system shall enable convenient management, conversion, and application of units.\"\n    }\n\n    requirement ErrorReduction {\n        description = \"The system shall reduce confusion and errors caused by inconsistent units.\"\n    }\n\n    requirement Efficiency {\n        description = \"The system shall enhance the efficiency and reliability of data processing and communication.\"\n    }\n\n    satisfies isq: UnitSystem\n    satisfies us_customary: UnitSystem\n    satisfies UnitConversion\n    satisfies UnitManagement\n    satisfies UnitApplication\n\n}",
    "package CarHeadlampTiltAdjustment {\n\n    import sysml::units;\n    import sysml::constraints;\n    import sysml::values;\n\n    unit deg : units::Angle = units::degree;\n\n    part HeadlampTiltAdjustmentKnob {\n        attribute beamTiltAngle : Real[deg];\n    }\n\n    constraint HeadlampTiltAngleRange {\n        input knob : HeadlampTiltAdjustmentKnob;\n        assert knob.beamTiltAngle >= 50.0 * deg;\n        assert knob.beamTiltAngle <= 80.0 * deg;\n    }\n\n    requirement HeadlampTiltAngleRequirement {\n        text \"The tilt angle of the headlamp beam, measured in degrees, shall be between 50 degrees and 80 degrees inclusive. Any value outside this range does not comply with safety and regulatory standards.\";\n        verify HeadlampTiltAngleRange;\n    }\n\n    value pi : Real = 3.141592653589793;\n    value e  : Real = 2.718281828459045;\n\n    constraint SIUnitsAdoption {\n        assert units::Angle == units::SI::Angle;\n    }\n\n    requirement SIUnitsRequirement {\n        text \"The system shall adopt the International System of Units (SI) and standard real number constants (such as pi and Euler’s number e) to ensure precision and consistency in calculations.\";\n        verify SIUnitsAdoption;\n    }\n}",
    "package DataTypeManagementSystem {\n\n    // Core Data Types\n    type UnsignedInteger {\n        constraint NonNegative {\n            self >= 0;\n        }\n    }\n\n    type UnsignedFloat {\n        constraint NonNegative {\n            self >= 0.0;\n        }\n    }\n\n    type DateTime;\n    type String;\n    type Boolean;\n\n    // Status Levels and Color Association\n    enum StatusLevel {\n        critical,\n        warning,\n        normal\n    }\n\n    enum StatusColor {\n        red,\n        yellow,\n        green\n    }\n\n    mapping StatusToColor {\n        input: StatusLevel;\n        output: StatusColor;\n        rule {\n            if input == StatusLevel::critical then output = StatusColor::red;\n            else if input == StatusLevel::warning then output = StatusColor::yellow;\n            else if input == StatusLevel::normal then output = StatusColor::green;\n        }\n    }\n\n    // Physical Dimension: Diameter\n    enum DiameterOption {\n        Small,\n        Medium,\n        Large\n    }\n\n    value_type Diameter {\n        base: UnsignedFloat;\n        unit: millimeter;\n        constraint AllowedValues {\n            self == 60.0 or self == 70.0 or self == 80.0;\n        }\n    }\n\n    mapping DiameterOptionToValue {\n        input: DiameterOption;\n        output: Diameter;\n        rule {\n            if input == DiameterOption::Small then output = 60.0[mm];\n            else if input == DiameterOption::Medium then output = 70.0[mm];\n            else if input == DiameterOption::Large then output = 80.0[mm];\n        }\n    }\n\n    // System Data Model\n    part SystemDataModel {\n        attribute unsignedIntValue: UnsignedInteger;\n        attribute unsignedFloatValue: UnsignedFloat;\n        attribute dateTimeValue: DateTime;\n        attribute stringValue: String;\n        attribute booleanValue: Boolean;\n\n        attribute statusLevel: StatusLevel;\n        attribute statusColor: StatusColor = StatusToColor(statusLevel);\n\n        attribute diameterOption: DiameterOption = DiameterOption::Small;\n        attribute diameter: Diameter = DiameterOptionToValue(diameterOption);\n    }\n\n}",
    "package SparePartsManagementSystem {\n\n    import ScalarValues::*;\n    import CollectionTypes::*;\n\n    // Person type definition\n    type Person {\n        attribute name: String;\n        attribute id: Integer;\n        attribute role: String;\n    }\n\n    // SparePart type definition\n    type SparePart {\n        attribute partNumber: String;\n        attribute description: String;\n        attribute quantity: Integer;\n    }\n\n    // Bag of SpareParts\n    type SparePartBag specializes Bag<SparePart>;\n\n    // List of Integers\n    type IntegerList specializes List<Integer>;\n\n    // Set of Strings\n    type StringSet specializes Set<String>;\n\n    // OrderedSet of Persons\n    type PersonnelOrderedSet specializes OrderedSet<Person>;\n\n    // Set of Persons\n    type PersonnelSet specializes Set<Person>;\n\n    // List of Personnel Sets (nested collection)\n    type PersonnelSetList specializes List<PersonnelSet>;\n\n    // Fixed-length Array of 4 Real numbers\n    type RealArray4 specializes Array<Real, 4>;\n\n    // System definition\n    part system: SparePartsManagementSystem {\n        attribute spareParts: SparePartBag;\n        attribute personnel: PersonnelOrderedSet;\n        attribute integerValues: IntegerList;\n        attribute stringValues: StringSet;\n        attribute personnelSets: PersonnelSetList;\n        attribute realValues: RealArray4;\n    }\n\n    // Business function integration interface\n    interface BusinessFunctionIntegration {\n        operation retrieveSpareParts(): SparePartBag;\n        operation retrievePersonnel(): PersonnelOrderedSet;\n        operation retrieveIntegerValues(): IntegerList;\n        operation retrieveStringValues(): StringSet;\n        operation retrievePersonnelSets(): PersonnelSetList;\n        operation retrieveRealValues(): RealArray4;\n        operation interactWithBusinessFunction(input: Any): Any;\n    }\n\n    // System implements business function integration\n    part system implements BusinessFunctionIntegration;\n\n}",
    "package TireInformationSystem {\n\n    import ScalarValues::*;\n    import SI::*;\n    import Units::*;\n\n    unit inch : Length = 0.0254 * meter;\n\n    type ManufacturerName : String;\n\n    type RimDiameter : Length;\n    type TireWidth : Length;\n\n    type Position3D {\n        x : Length;\n        y : Length;\n        z : Length;\n    }\n\n    part Tire {\n        attribute manufacturer : ManufacturerName;\n        attribute rimDiameter : RimDiameter;\n        attribute width : TireWidth;\n        attribute installationPosition? : Position3D;\n    }\n\n    part TireInformationSystem {\n        attribute tires : Tire[*];\n    }\n\n    // Example instance\n    instance Michelin_245_18 : Tire {\n        manufacturer = \"Michelin\";\n        rimDiameter = 18 * inch;\n        width = 245 * millimeter;\n        // installationPosition omitted (optional)\n    }\n\n    instance TireSystemExample : TireInformationSystem {\n        tires = { Michelin_245_18 };\n    }\n}",
    "package TrajectorySampling {\n\n    import sysml::units;\n    import sysml::datatypes;\n\n    // Value Types\n    value type Time {\n        base type: Real;\n        unit: units::second;\n    }\n\n    value type Position3D {\n        base type: datatypes::Vector3;\n        unit: units::meter;\n    }\n\n    value type Velocity3D {\n        base type: datatypes::Vector3;\n        unit: units::meter_per_second;\n    }\n\n    value type UTCTimestamp {\n        base type: String;\n        description: \"UTC timestamp in ISO 8601 format, e.g., 2020-08-23T22:42:32.924534Z\";\n    }\n\n    // Data Structure for a single sampling point\n    data SamplingPoint {\n        attribute time: Time;\n        attribute position: Position3D;\n        attribute velocity: Velocity3D;\n    }\n\n    // Data Structure for trajectory record\n    data TrajectoryRecord {\n        attribute reference_time_utc: UTCTimestamp;\n        attribute sampling_points: Sequence<SamplingPoint>;\n    }\n\n    // Requirement Definitions\n    requirement TrajectorySamplingRequirement {\n        text \"The system shall sample and record the spacecraft trajectory during the ascent phase. Each sampling point shall include time (relative to mission liftoff), position (3D Cartesian, meters), and velocity (3D Cartesian, meters per second). The system shall use the UTC liftoff time as reference time zero and record it. Multiple sampling points shall be recorded to support trajectory analysis and performance evaluation.\";\n    }\n\n    // Function Definition\n    function SampleTrajectory {\n        input reference_time_utc: UTCTimestamp;\n        output trajectory_record: TrajectoryRecord;\n        description \"Samples and records the spacecraft trajectory during ascent, associating each sample with time, position, and velocity.\";\n    }\n\n    // Non-functional Requirement\n    requirement AccuracyRequirement {\n        text \"The system shall provide accurate time, position, and velocity data to support subsequent trajectory analysis and performance evaluation.\";\n    }\n}",
    "package materials_alloy_management {\n\n    import units::si;\n\n    // Abstract definition for a Substance\n    abstract part type Substance {\n        attribute name: String;\n        attribute atomicMass: si::kilogram_per_mole; // Optional for non-elemental substances\n    }\n\n    // Material is a kind of Substance\n    part type Material specializes Substance {\n        // Additional material-specific attributes can be added here\n    }\n\n    // Metal is a kind of Material\n    part type Metal specializes Material {\n        // Metals may have additional properties in future\n    }\n\n    // Alloy is a Material composed of multiple Materials with mass fractions\n    part type Alloy specializes Material {\n        // Each component is a Material with a mass fraction\n        part components: ComponentMaterial[2..*];\n        attribute tensileStrength: si::newton_per_square_metre; // e.g., N/mm^2\n    }\n\n    // ComponentMaterial links a Material to its mass fraction in an Alloy\n    part type ComponentMaterial {\n        ref material: Material;\n        attribute massFraction: Real[0.0..1.0]; // Fraction of total mass\n    }\n\n    // Example instances of Metals\n    part iron: Metal {\n        name = \"Iron\";\n        atomicMass = 55.845 * si::gram_per_mole;\n    }\n\n    part carbon: Metal {\n        name = \"Carbon\";\n        atomicMass = 12.011 * si::gram_per_mole;\n    }\n\n    part manganese: Metal {\n        name = \"Manganese\";\n        atomicMass = 54.938 * si::gram_per_mole;\n    }\n\n    // Example instance of Alloy: Steel 980\n    part steel980: Alloy {\n        name = \"Steel 980\";\n        tensileStrength = 980 * si::newton_per_square_millimetre;\n\n        components = [\n            steel980_iron,\n            steel980_carbon,\n            steel980_manganese\n        ];\n    }\n\n    part steel980_iron: ComponentMaterial {\n        material = iron;\n        massFraction = 0.96;\n    }\n\n    part steel980_carbon: ComponentMaterial {\n        material = carbon;\n        massFraction = 0.02;\n    }\n\n    part steel980_manganese: ComponentMaterial {\n        material = manganese;\n        massFraction = 0.02;\n    }\n\n    // Non-functional requirements (as comments)\n    // - The system supports standardized SI units for all properties.\n    // - The system allows creation, editing, and expansion of material and alloy data.\n    // - The system provides traceability of each component's contribution to an alloy.\n    // - The system is extensible for additional properties and materials.\n\n}",
    "package EngineeringMaterialsDatabase {\n\n    import units::si;\n    import units::si::derived;\n\n    // Abstract definition of a material\n    abstract part Material {\n        attribute name: String;\n        attribute atomicMass: si::Mass?; // Optional, for elements\n        attribute composition: Composition?; // Optional, for pure elements\n        attribute mechanicalProperties: MechanicalProperties?;\n    }\n\n    // Composition information for alloys/metals\n    part Composition {\n        attribute constituents: ConstituentMaterial[1..*];\n    }\n\n    part ConstituentMaterial {\n        attribute elementName: String;\n        attribute massFraction: Real; // 0.0 .. 1.0\n    }\n\n    // Mechanical properties with unit management\n    part MechanicalProperties {\n        attribute tensileStrength: derived::Pressure; // e.g., N/mm^2\n        // Additional mechanical properties can be added here\n    }\n\n    // Specialization for metals and alloys\n    part Metal specializes Material {\n        attribute composition: Composition;\n    }\n\n    part Alloy specializes Metal {\n        // Additional attributes for alloys if needed\n    }\n\n    // Example: High-strength steel Steel_980\n    part Steel_980 specializes Alloy {\n        attribute name: String = \"Steel_980\";\n        attribute composition: Composition = Composition {\n            constituents = [\n                ConstituentMaterial { elementName = \"Iron\", massFraction = 0.96 },\n                ConstituentMaterial { elementName = \"Carbon\", massFraction = 0.002 },\n                ConstituentMaterial { elementName = \"Manganese\", massFraction = 0.018 }\n            ]\n        };\n        attribute mechanicalProperties: MechanicalProperties = MechanicalProperties {\n            tensileStrength = 980 * si::mega * si::pascal; // 980 MPa = 980 N/mm^2\n        };\n    }\n\n    // System requirements (non-functional)\n    requirement IntuitiveDataEntry {\n        text = \"The system shall provide intuitive data entry for engineering materials.\";\n    }\n\n    requirement StandardizedDataManagement {\n        text = \"The system shall support standardized and dimensional management of material properties, including unit conversion.\";\n    }\n\n    requirement FlexibleQuerying {\n        text = \"The system shall enable convenient querying and comparison of materials.\";\n    }\n\n    requirement ScientificRigor {\n        text = \"The system shall improve the efficiency and scientific rigor of materials engineering research, development, and application.\";\n    }\n\n    satisfies Steel_980 -> IntuitiveDataEntry;\n    satisfies Steel_980 -> StandardizedDataManagement;\n    satisfies Steel_980 -> FlexibleQuerying;\n    satisfies Steel_980 -> ScientificRigor;\n}",
    "system PubSubSystem {\n    \n    part producer: Producer[0..*];\n    part consumer: Consumer[0..*];\n    part server: PubSubServer;\n\n    interface Message {\n        attribute id: String;\n        attribute topic: String;\n        attribute content: String;\n        attribute timestamp: Time;\n    }\n\n    interface Topic {\n        attribute name: String;\n    }\n\n    interface Subscription {\n        attribute topic: String;\n        attribute subscriberId: String;\n    }\n\n    action Publish {\n        in message: Message;\n        out ack: Boolean;\n    }\n\n    action Subscribe {\n        in topic: String;\n        in subscriberId: String;\n        out ack: Boolean;\n    }\n\n    action Distribute {\n        in message: Message;\n        in subscribers: Consumer[1..*];\n        out deliveryStatus: Boolean;\n    }\n\n    part topicRegistry: TopicRegistry;\n\n    part subscriptionManager: SubscriptionManager;\n\n    part messageQueue: MessageQueue;\n\n    // Producer publishes message to server\n    producer -> server: Publish;\n\n    // Consumer subscribes to topic via server\n    consumer -> server: Subscribe;\n\n    // Server manages topic registry and subscriptions\n    server -> topicRegistry: manageTopics;\n    server -> subscriptionManager: manageSubscriptions;\n\n    // Server receives published message and enqueues it\n    server -> messageQueue: enqueueMessage;\n\n    // Server distributes messages to subscribers\n    server -> consumer: Distribute;\n\n    constraint promptDelivery {\n        description: \"Messages published by producers must be delivered to all relevant subscribers with minimal delay.\";\n    }\n\n    constraint accurateDelivery {\n        description: \"Subscribers must only receive messages for topics they have subscribed to.\";\n    }\n\n    constraint decoupledInteraction {\n        description: \"Producers and consumers are decoupled; consumers do not need to know publishers or other subscribers.\";\n    }\n\n    constraint efficientProcessing {\n        description: \"The system must efficiently manage and process message publishing, subscription, and distribution flows.\";\n    }\n}\n\nblock Producer {\n    action publish {\n        in message: Message;\n        out ack: Boolean;\n    }\n}\n\nblock Consumer {\n    action subscribe {\n        in topic: String;\n        out ack: Boolean;\n    }\n    action receive {\n        in message: Message;\n    }\n}\n\nblock PubSubServer {\n    part topicRegistry: TopicRegistry;\n    part subscriptionManager: SubscriptionManager;\n    part messageQueue: MessageQueue;\n\n    action receivePublish {\n        in message: Message;\n        out ack: Boolean;\n    }\n    action receiveSubscribe {\n        in topic: String;\n        in subscriberId: String;\n        out ack: Boolean;\n    }\n    action distributeMessage {\n        in message: Message;\n        in subscribers: Consumer[1..*];\n        out deliveryStatus: Boolean;\n    }\n}\n\nblock TopicRegistry {\n    attribute topics: Topic[0..*];\n    action registerTopic {\n        in topic: String;\n        out ack: Boolean;\n    }\n}\n\nblock SubscriptionManager {\n    attribute subscriptions: Subscription[0..*];\n    action addSubscription {\n        in topic: String;\n        in subscriberId: String;\n        out ack: Boolean;\n    }\n    action getSubscribers {\n        in topic: String;\n        out subscribers: Consumer[0..*];\n    }\n}\n\nblock MessageQueue {\n    attribute messages: Message[0..*];\n    action enqueue {\n        in message: Message;\n    }\n    action dequeue {\n        out message: Message;\n    }\n}",
    "package VehicleFuelSystem {\n\n    part fuelTankAssembly : FuelTankAssembly;\n    part engine : Engine;\n    part fuelSupplyLine : FuelLine;\n    part fuelReturnLine : FuelLine;\n    part fuelTemperatureSensor : FuelTemperatureSensor;\n\n    connection supplyConnection : FuelConnection {\n        from fuelTankAssembly.fuelOutlet\n        to engine.fuelInlet\n        via fuelSupplyLine\n    }\n\n    connection returnConnection : FuelConnection {\n        from engine.fuelReturnOutlet\n        to fuelTankAssembly.fuelReturnInlet\n        via fuelReturnLine\n    }\n\n    connection tempSensorConnection : SensorConnection {\n        from fuelTemperatureSensor.measurementPort\n        to fuelSupplyLine.sensorPort\n    }\n\n    requirement ContinuousFuelSupply {\n        text \"The system shall provide a continuous and stable supply of fuel from the fuel tank assembly to the engine during vehicle operation.\"\n    }\n\n    requirement FuelReturn {\n        text \"The system shall return unused fuel from the engine back to the fuel tank assembly to optimize resource utilization.\"\n    }\n\n    requirement FuelTemperatureMonitoring {\n        text \"The system shall monitor and transmit information on fuel temperature throughout the fuel flow process to ensure operational safety and efficiency.\"\n    }\n\n    part definition FuelTankAssembly {\n        port fuelOutlet : FuelPort;\n        port fuelReturnInlet : FuelPort;\n        operation supplyFuel();\n        operation receiveReturnedFuel();\n    }\n\n    part definition Engine {\n        port fuelInlet : FuelPort;\n        port fuelReturnOutlet : FuelPort;\n        operation consumeFuel();\n        operation returnUnusedFuel();\n    }\n\n    part definition FuelLine {\n        port sensorPort : SensorPort;\n    }\n\n    part definition FuelTemperatureSensor {\n        port measurementPort : SensorPort;\n        operation measureTemperature();\n        operation transmitTemperatureData();\n    }\n\n    interface FuelPort;\n    interface SensorPort;\n\n    interface FuelConnection {\n        from : FuelPort;\n        to : FuelPort;\n    }\n\n    interface SensorConnection {\n        from : SensorPort;\n        to : SensorPort;\n    }\n}",
    "system PublishSubscribeSystem {\n    \n    part producers: Producer[1..*];\n    part server: Server;\n    part consumers: Consumer[1..*];\n\n    interface TopicMessage {\n        attribute topic: String;\n        attribute payload: String;\n    }\n\n    interface SubscriptionRequest {\n        attribute topic: String;\n        attribute consumerId: String;\n    }\n\n    interface DeliveryConfirmation {\n        attribute messageId: String;\n        attribute consumerId: String;\n        attribute status: String;\n    }\n\n    action PublishMessage {\n        in message: TopicMessage;\n        out confirmation: DeliveryConfirmation;\n    }\n\n    action SubscribeToTopic {\n        in request: SubscriptionRequest;\n        out confirmation: DeliveryConfirmation;\n    }\n\n    action DeliverMessage {\n        in message: TopicMessage;\n        in consumer: Consumer;\n        out confirmation: DeliveryConfirmation;\n    }\n\n    part role Producer {\n        operation publish(message: TopicMessage): DeliveryConfirmation;\n    }\n\n    part role Consumer {\n        operation subscribe(request: SubscriptionRequest): DeliveryConfirmation;\n        operation receive(message: TopicMessage): DeliveryConfirmation;\n    }\n\n    part role Server {\n        operation receivePublish(message: TopicMessage): DeliveryConfirmation;\n        operation receiveSubscription(request: SubscriptionRequest): DeliveryConfirmation;\n        operation deliverToSubscribers(message: TopicMessage): DeliveryConfirmation[1..*];\n    }\n\n    constraint ReliableDelivery {\n        description: \"All published messages for a topic are delivered to all consumers subscribed to that topic.\";\n    }\n\n    constraint EfficientExchange {\n        description: \"The system shall ensure efficient information exchange between producers and consumers via the server.\";\n    }\n\n    requirement ReliableMessagePublishing {\n        text: \"The system shall reliably publish and distribute messages to all subscribed consumers.\";\n    }\n\n    requirement EfficientInformationExchange {\n        text: \"The system shall ensure efficient information exchange between different users.\";\n    }\n\n    relationship {\n        producers -> server: publish(message: TopicMessage);\n        consumers -> server: subscribe(request: SubscriptionRequest);\n        server -> consumers: deliverToSubscribers(message: TopicMessage);\n    }\n}",
    "system TransportationSystem {\n    part vehicle: Vehicle;\n    part driver: User;\n    part passengers: User[0..4];\n\n    requirement functional {\n        description: \"The system shall provide transportation services for users (driver and up to four passengers).\";\n    }\n    requirement functional {\n        description: \"The system shall allow users to enter (board) and exit (alight) the vehicle safely.\";\n    }\n    requirement functional {\n        description: \"The driver shall operate the vehicle to complete travel tasks.\";\n    }\n    requirement functional {\n        description: \"If the fuel level falls below 10% of maximum tank capacity, the driver may refuel at a gas station.\";\n    }\n    requirement functional {\n        description: \"The system shall consider environmental factors during operation.\";\n    }\n    requirement nonfunctional {\n        description: \"The system shall ensure efficient and safe travel experience.\";\n    }\n    requirement nonfunctional {\n        description: \"The system shall facilitate timely refueling during the journey.\";\n    }\n\n    scenario TransportationProcess {\n        action sequence {\n            driver.perform(board, vehicle);\n            for each p in passengers {\n                p.perform(board, vehicle);\n            }\n            driver.perform(operate, vehicle);\n            while (vehicle.fuelLevel > 0) {\n                if (vehicle.fuelLevel < 0.1 * vehicle.tankCapacity) {\n                    driver.perform(refuel, vehicle);\n                }\n                vehicle.perform(travel, environment);\n            }\n            for each p in passengers {\n                p.perform(alight, vehicle);\n            }\n            driver.perform(alight, vehicle);\n        }\n    }\n}\n\nblock Vehicle {\n    property fuelLevel: Real;\n    property tankCapacity: Real;\n    operation board(user: User);\n    operation alight(user: User);\n    operation travel(environment: Environment);\n    operation refuel();\n}\n\nblock User {\n    property role: enumeration { driver, passenger };\n    operation board(vehicle: Vehicle);\n    operation alight(vehicle: Vehicle);\n    operation operate(vehicle: Vehicle);\n}\n\nblock Environment {\n    property factors: String[];\n}",
    "system FuelSupplyReturnManagementSystem {\n\n    part fuelTank: FuelTankAssembly;\n    part engine: EngineUnit;\n\n    interface FuelInterface {\n        inout port fuelFlow: FuelPort;\n    }\n\n    port fuelOutlet: FuelPort;\n    port fuelReturn: FuelPort;\n\n    fuelTank.fuelOutlet -> engine.fuelInlet;\n    engine.fuelReturn -> fuelTank.fuelReturn;\n\n    fuelTank.fuelOutlet conformsTo FuelInterface.fuelFlow;\n    fuelTank.fuelReturn conformsTo FuelInterface.fuelFlow;\n    engine.fuelInlet conformsTo FuelInterface.fuelFlow;\n    engine.fuelReturn conformsTo FuelInterface.fuelFlow;\n\n    requirement ContinuousFuelSupply {\n        description: \"The engine shall continuously and reliably receive required fuel from the fuel tank for normal operation.\";\n    }\n\n    requirement FuelReturnSupport {\n        description: \"The system shall support fuel return from the engine to the fuel tank to enable efficient fuel circulation.\";\n    }\n\n    requirement RealTimeMonitoring {\n        description: \"The system shall monitor fuel parameters, including temperature, in real time during both supply and return processes.\";\n    }\n\n    requirement SafetyAndIntelligence {\n        description: \"The system shall improve the intelligence and safety of vehicle fuel management.\";\n    }\n}\n\npart FuelTankAssembly {\n    port fuelOutlet: FuelPort;\n    port fuelReturn: FuelPort;\n}\n\npart EngineUnit {\n    port fuelInlet: FuelPort;\n    port fuelReturn: FuelPort;\n}\n\ninterface FuelPort {\n    attribute fuelTemperature: Real;\n    // Additional attributes (e.g., pressure, flowRate) can be added as needed\n}",
    "package VehicleFuelSystem {\n\n    part VehicleFuelSystemManagementSystem {\n        part fuelTankAssembly: FuelTankAssembly;\n        part engine: Engine;\n\n        connector supplyLine: FuelLine {\n            end source: fuelTankAssembly.supplyPort;\n            end target: engine.supplyPort;\n        }\n\n        connector returnLine: FuelLine {\n            end source: engine.returnPort;\n            end target: fuelTankAssembly.returnPort;\n        }\n    }\n\n    part FuelTankAssembly {\n        port supplyPort: FuelPort;\n        port returnPort: FuelPort;\n    }\n\n    part Engine {\n        port supplyPort: FuelPort;\n        port returnPort: FuelPort;\n    }\n\n    interface FuelPort {\n        flow property fuelFlow: Fuel;\n        property fuelTemperature: Temperature;\n    }\n\n    type Fuel {\n        property flowRate: Real;\n        property pressure: Real;\n    }\n\n    type Temperature {\n        property value: Real;\n        property unit: String;\n    }\n\n    connector FuelLine {\n        end source: FuelPort;\n        end target: FuelPort;\n    }\n\n    requirement EfficientFuelSupply {\n        text \"The system shall efficiently supply fuel from the fuel tank to the engine.\"\n    }\n\n    requirement EfficientFuelReturn {\n        text \"The system shall efficiently return unused fuel from the engine to the fuel tank.\"\n    }\n\n    requirement FuelTemperatureMonitoring {\n        text \"Each fuel interface shall provide current fuel temperature information for monitoring and regulation.\"\n    }\n\n    requirement ReliableOperation {\n        text \"The system shall ensure reliable and safe fuel delivery during normal vehicle operation.\"\n    }\n\n    requirement InformationTracking {\n        text \"The system shall track fuel flow and temperature information during both supply and return processes.\"\n    }\n}",
    "system \"Photo Capture System\" {\n\n    feature user: Actor;\n    feature photo: Photo;\n    feature scene: Scene;\n\n    requirement \"Automatic Photo Acquisition\" {\n        text = \"The system shall enable users to obtain photos from real-world scenes by automatically performing focusing and capturing processes after scene selection, without manual intervention.\"\n    }\n\n    requirement \"Focusing Automation\" {\n        text = \"The system shall automatically perform focusing for the selected scene before capturing the photo.\"\n    }\n\n    requirement \"Intermediate Image Generation\" {\n        text = \"The system shall generate an intermediate focused image prior to capturing the final photo.\"\n    }\n\n    requirement \"Final Photo Output\" {\n        text = \"The system shall capture and output the final photo based on the focused image.\"\n    }\n\n    requirement \"User Simplicity\" {\n        text = \"The system shall not require manual intervention from the user during focusing and shooting processes.\"\n    }\n\n    usecase \"Obtain Photo from Scene\" {\n        actor user;\n        input scene;\n        output photo;\n        description = \"User selects a scene. The system automatically focuses, generates an intermediate image, captures, and outputs the final photo.\"\n    }\n\n    function \"Select Scene\" {\n        input user;\n        output scene;\n        description = \"User selects the desired real-world scene to capture.\"\n    }\n\n    function \"Auto Focus\" {\n        input scene;\n        output focusedImage: Image;\n        description = \"System automatically focuses on the selected scene and generates a focused intermediate image.\"\n    }\n\n    function \"Capture Photo\" {\n        input focusedImage;\n        output photo;\n        description = \"System captures and outputs the final photo based on the focused image.\"\n    }\n\n    scenario \"Photo Acquisition Workflow\" {\n        step selectScene: \"Select Scene\";\n        step autoFocus: \"Auto Focus\" after selectScene;\n        step capturePhoto: \"Capture Photo\" after autoFocus;\n    }\n\n    satisfies \"Automatic Photo Acquisition\" with \"Photo Acquisition Workflow\";\n    satisfies \"Focusing Automation\" with \"Auto Focus\";\n    satisfies \"Intermediate Image Generation\" with \"Auto Focus\";\n    satisfies \"Final Photo Output\" with \"Capture Photo\";\n    satisfies \"User Simplicity\" with \"Photo Acquisition Workflow\";\n}",
    "system PhotographyWorkflowSystem {\n\n    part user : User;\n    part scene : Scene;\n    part focusing : Focusing;\n    part shooting : Shooting;\n    part intermediateImage : Image;\n    part finalImage : Image;\n\n    requirement req_workflow_sequence {\n        text \"The system shall perform focusing before shooting, ensuring sequential workflow.\"\n    }\n\n    requirement req_focus_quality {\n        text \"The system shall ensure the image is in clear focus before shooting.\"\n    }\n\n    requirement req_output_quality {\n        text \"The system shall output high-quality final photographs.\"\n    }\n\n    requirement req_user_efficiency {\n        text \"The system operation process shall be concise and coherent, enabling efficient user workflow.\"\n    }\n\n    function selectScene(input: User, output: Scene) {\n        text \"User selects or sets a scene to be photographed.\"\n    }\n\n    function performFocusing(input: Scene, output: Image) {\n        text \"System automatically focuses on the selected scene and generates an intermediate image.\"\n    }\n\n    function performShooting(input: Image, output: Image) {\n        text \"System carries out shooting operation based on the focused image, outputting the final photograph.\"\n    }\n\n    scenario photographyWorkflow {\n        text \"Describes the sequential workflow from scene selection to final image output.\"\n        step 1: selectScene(user, scene);\n        step 2: performFocusing(scene, intermediateImage);\n        step 3: performShooting(intermediateImage, finalImage);\n    }\n\n    satisfies req_workflow_sequence with scenario photographyWorkflow;\n    satisfies req_focus_quality with performFocusing;\n    satisfies req_output_quality with performShooting;\n    satisfies req_user_efficiency with scenario photographyWorkflow;\n}",
    "System PhotographyWorkflowSystem {\n    \n    part user : User;\n    part scene : Scene;\n    part image : Image;\n    part photograph : Photograph;\n\n    interface PhotographyWorkflowSystemInterface {\n        in selectScene(scene: Scene);\n        out deliverPhotograph(photograph: Photograph);\n    }\n\n    requirement FunctionalRequirements {\n        text \"The system shall allow the user to select a specific scene.\";\n        text \"The system shall perform focusing on the selected scene to generate an image.\";\n        text \"The system shall perform shooting based on the image to produce a final photograph.\";\n        text \"The system shall automatically complete focusing and shooting steps.\";\n    }\n\n    requirement NonFunctionalRequirements {\n        text \"The system shall ensure high-quality photographs.\";\n        text \"The system shall provide a convenient workflow for users.\";\n        text \"The system shall not require users to manually handle intermediate image processing and conversion tasks.\";\n    }\n\n    action SelectScene {\n        in user: User;\n        out scene: Scene;\n    }\n\n    action FocusScene {\n        in scene: Scene;\n        out image: Image;\n    }\n\n    action ShootImage {\n        in image: Image;\n        out photograph: Photograph;\n    }\n\n    usecase PhotographyWorkflow {\n        actor user: User;\n        input scene: Scene;\n        output photograph: Photograph;\n\n        step selectScene: SelectScene;\n        step focusScene: FocusScene;\n        step shootImage: ShootImage;\n\n        flow {\n            selectScene -> focusScene -> shootImage;\n        }\n    }\n\n    satisfies FunctionalRequirements;\n    satisfies NonFunctionalRequirements;\n}",
    "system AutomatedPhotographySystem {\n    \n    part user: User;\n    part scene: ShootingScene;\n    part focusProcessor: FocusProcessor;\n    part image: Image;\n    part photograph: Photograph;\n    part shootingOperator: ShootingOperator;\n\n    requirement functional {\n        id = \"FR-1\";\n        text = \"The system shall accept a shooting scene input from the user.\";\n    }\n    requirement functional {\n        id = \"FR-2\";\n        text = \"The system shall perform focus processing on the provided scene to generate an image suitable for shooting.\";\n    }\n    requirement functional {\n        id = \"FR-3\";\n        text = \"The system shall convert the focused image into a photograph via a shooting operation.\";\n    }\n    requirement functional {\n        id = \"FR-4\";\n        text = \"The system shall integrate the focus and shooting operations into a seamless process.\";\n    }\n    requirement nonfunctional {\n        id = \"NFR-1\";\n        text = \"The system shall require minimal user intervention, not requiring users to manage focusing or shooting details.\";\n    }\n    requirement nonfunctional {\n        id = \"NFR-2\";\n        text = \"The system shall simplify the photography workflow for ease of use and efficiency.\";\n    }\n\n    interface UserInput {\n        in scene: ShootingScene;\n    }\n\n    interface PhotographOutput {\n        out photograph: Photograph;\n    }\n\n    behavior AutomatedPhotographyProcess {\n        input: scene: ShootingScene;\n        output: photograph: Photograph;\n\n        step focusProcessing {\n            action = focusProcessor.process(scene);\n            output: image: Image;\n        }\n        step shootingOperation {\n            action = shootingOperator.shoot(image);\n            output: photograph: Photograph;\n        }\n        flow {\n            focusProcessing -> shootingOperation;\n        }\n    }\n\n    satisfies AutomatedPhotographyProcess -> FR-1, FR-2, FR-3, FR-4, NFR-1, NFR-2;\n\n    expose UserInput;\n    expose PhotographOutput;\n}",
    "package PhotographyWorkflow {\n\n    part User\n    part PhotographyWorkflowSoftware\n\n    interface Scene\n    interface Image\n    interface Picture\n\n    action Focus {\n        in parameter scene: Scene;\n        out parameter image: Image;\n    }\n\n    action Shoot {\n        in parameter image: Image;\n        out parameter picture: Picture;\n    }\n\n    action Photograph {\n        in parameter scene: Scene;\n        out parameter picture: Picture;\n        perform {\n            let image: Image = Focus(scene);\n            let picture: Picture = Shoot(image);\n            return picture;\n        }\n    }\n\n    requirement AutomatedWorkflow {\n        text \"The system shall automatically perform focusing and imaging operations after the user inputs the desired scene, and output the required photograph without further user intervention.\"\n    }\n\n    requirement StreamlinedProcess {\n        text \"The system shall enable users to complete the entire photography process—from composition to photo output—through a single software package.\"\n    }\n\n    PhotographyWorkflowSoftware {\n        performs Photograph;\n        satisfies AutomatedWorkflow;\n        satisfies StreamlinedProcess;\n    }\n\n    User {\n        uses PhotographyWorkflowSoftware;\n        provides scene: Scene;\n        receives picture: Picture;\n    }\n\n    usecase CompletePhotographyProcess {\n        actor User;\n        system PhotographyWorkflowSoftware;\n        description \"User inputs desired scene; system focuses, shoots, and outputs photograph automatically.\"\n    }\n}",
    "system PhotographySystem {\n    \n    part user : User\n    part camera : Camera\n\n    interface PhotographyWorkflow {\n        operation selectScene(scene : Scene)\n        operation capturePhoto()\n    }\n\n    interface CameraControl {\n        operation focus(scene : Scene) : FocusResult\n        operation shoot() : Image\n    }\n\n    stateMachine PhotographyProcess {\n        state Idle\n        state SceneSelected\n        state Focusing\n        state Focused\n        state Shooting\n        state PhotoCaptured\n\n        transition Idle -> SceneSelected when user.selectScene(scene)\n        transition SceneSelected -> Focusing when camera.focus(scene)\n        transition Focusing -> Focused when camera.focus(scene).result == FocusResult.CLEAR\n        transition Focused -> Shooting when camera.shoot()\n        transition Shooting -> PhotoCaptured when camera.shoot().image != null\n        transition PhotoCaptured -> Idle when user.selectScene(scene)\n    }\n\n    requirement OneClickShooting {\n        text \"The system shall allow the user to capture a photo with a single action, automatically performing focusing and shooting in sequence.\"\n    }\n\n    requirement ImageClarity {\n        text \"The system shall ensure that the captured photo is only taken when the focus is clear.\"\n    }\n\n    requirement PhotoQuality {\n        text \"The system shall ensure the quality and clarity of the captured photos.\"\n    }\n\n    usecase CaptureScene {\n        actor user\n        description \"User selects a scene and initiates a one-click capture. The system focuses, checks clarity, and captures the photo if focus is clear.\"\n        includes [FocusScene, TakePhoto]\n    }\n\n    usecase FocusScene {\n        actor camera\n        description \"Camera automatically focuses on the selected scene.\"\n    }\n\n    usecase TakePhoto {\n        actor camera\n        description \"Camera captures the photo after confirming focus clarity.\"\n    }\n\n    satisfies OneClickShooting by CaptureScene\n    satisfies ImageClarity by FocusScene\n    satisfies PhotoQuality by TakePhoto\n}",
    "system \"PhotoCaptureSystem\" {\n\n    part user : User;\n    part scene : Scene;\n    part focusUnit : FocusUnit;\n    part imageProcessor : ImageProcessor;\n    part qualityEvaluator : FocusQualityEvaluator;\n    part shootingUnit : ShootingUnit;\n    part photo : Photo;\n\n    requirement \"AutomaticWorkflow\" {\n        text \"The system shall automatically link the workflow from scene input to photo output.\"\n    }\n\n    requirement \"FocusBeforeShooting\" {\n        text \"The system shall perform focusing and evaluate focus quality before shooting.\"\n    }\n\n    requirement \"ShootOnlyIfWellFocused\" {\n        text \"The system shall only proceed with shooting if the image is determined to be well-focused.\"\n    }\n\n    requirement \"HighPhotoQuality\" {\n        text \"The system shall improve the clarity and quality of the resulting photographs.\"\n    }\n\n    usecase \"CaptureHighQualityPhoto\" {\n        actor user;\n        scenario {\n            user selects scene;\n            focusUnit performs focusing on scene;\n            imageProcessor generates image;\n            qualityEvaluator evaluates focus quality;\n            if (focus quality is sufficient) {\n                shootingUnit performs shooting operation;\n                photo is produced;\n            }\n        }\n    }\n\n    interface \"SceneSelection\" {\n        in sceneInput : Scene;\n        out selectedScene : Scene;\n    }\n\n    interface \"Focusing\" {\n        in selectedScene : Scene;\n        out focusedImage : Image;\n    }\n\n    interface \"FocusQualityEvaluation\" {\n        in focusedImage : Image;\n        out focusQuality : QualityMetric;\n    }\n\n    interface \"ShootingOperation\" {\n        in focusedImage : Image;\n        in focusQuality : QualityMetric;\n        out photo : Photo;\n    }\n\n    behavior \"PhotoCaptureWorkflow\" {\n        input sceneInput : Scene;\n        output photo : Photo;\n\n        step selectScene {\n            output selectedScene : Scene;\n        }\n        step performFocusing {\n            input selectedScene : Scene;\n            output focusedImage : Image;\n        }\n        step evaluateFocusQuality {\n            input focusedImage : Image;\n            output focusQuality : QualityMetric;\n        }\n        step conditionalShooting {\n            input focusedImage : Image;\n            input focusQuality : QualityMetric;\n            output photo : Photo;\n            precondition focusQuality == \"WellFocused\";\n        }\n\n        flow {\n            sceneInput -> selectScene.selectedScene;\n            selectScene.selectedScene -> performFocusing.selectedScene;\n            performFocusing.focusedImage -> evaluateFocusQuality.focusedImage;\n            evaluateFocusQuality.focusQuality -> conditionalShooting.focusQuality;\n            performFocusing.focusedImage -> conditionalShooting.focusedImage;\n            conditionalShooting.photo -> photo;\n        }\n    }\n\n    satisfies \"AutomaticWorkflow\";\n    satisfies \"FocusBeforeShooting\";\n    satisfies \"ShootOnlyIfWellFocused\";\n    satisfies \"HighPhotoQuality\";\n}",
    "system PhotographyWorkflowSystem {\n\n    part user: User\n    part sceneSensor: SceneSensor\n    part focusModule: FocusModule\n    part imageProcessor: ImageProcessor\n    part shutter: Shutter\n    part display: Display\n\n    operation takePhoto()\n\n    state Initial\n    state SceneAcquired\n    state Focused\n    state ImageCaptured\n    state PhotoDisplayed\n\n    transition Initial -> SceneAcquired when takePhoto()\n    transition SceneAcquired -> Focused when sceneSensor.acquireScene()\n    transition Focused -> ImageCaptured when focusModule.focus(sceneSensor.scene) and imageProcessor.generateImage()\n    transition ImageCaptured -> PhotoDisplayed when shutter.shoot(imageProcessor.image)\n    transition PhotoDisplayed -> Initial when display.show(shutter.photo)\n\n    constraint seamlessIntegration: \n        \"The workflow from takePhoto trigger to photo display is automatic and requires no manual intervention between steps.\"\n\n    constraint userConvenience: \n        \"The user only needs to trigger takePhoto; all subsequent steps are performed automatically.\"\n\n    requirement R1: \n        \"The system shall acquire the current scene upon takePhoto trigger.\"\n    requirement R2: \n        \"The system shall perform automatic focusing using the acquired scene.\"\n    requirement R3: \n        \"The system shall generate an image after focusing.\"\n    requirement R4: \n        \"The system shall execute the shooting operation to produce the final photograph.\"\n    requirement R5: \n        \"The system shall display the resulting photo immediately after shooting.\"\n    requirement R6: \n        \"The system shall integrate all steps without requiring user intervention after takePhoto is triggered.\"\n\n    scenario CompletePhotographyWorkflow {\n        user.triggers(takePhoto())\n        sceneSensor.acquireScene()\n        focusModule.focus(sceneSensor.scene)\n        imageProcessor.generateImage()\n        shutter.shoot(imageProcessor.image)\n        display.show(shutter.photo)\n    }\n}",
    "system AutomaticBrakingControlSystem {\n\n    part vehicle : Vehicle;\n    part brakePedalSensor : BrakePedalSensor;\n    part tractionSensor : TractionSensor;\n    part brakeActuator : BrakeActuator;\n    part controlUnit : BrakingControlUnit;\n\n    interface input {\n        signal ignitionKeyTurnedToStart;\n        signal brakePedalStatus;\n        signal tractionData;\n    }\n\n    interface output {\n        signal brakePressureCommand;\n        signal modulationFrequencyCommand;\n    }\n\n    requirement functional AutomaticActivation {\n        text \"The system shall automatically activate when the vehicle ignition key is turned to the start position.\";\n    }\n\n    requirement functional ContinuousMonitoring {\n        text \"The system shall continuously monitor brake pedal status and traction information.\";\n    }\n\n    requirement functional IntelligentAdjustment {\n        text \"The system shall intelligently adjust brake pressure and modulation frequency based on brake pedal input and traction variations.\";\n    }\n\n    requirement functional DynamicRegulation {\n        text \"The system shall dynamically regulate braking without user intervention.\";\n    }\n\n    requirement nonfunctional Safety {\n        text \"The system shall ensure safe and reliable braking performance under various operating conditions.\";\n    }\n\n    requirement nonfunctional Comfort {\n        text \"The system shall enhance driving comfort during braking operations.\";\n    }\n\n    requirement nonfunctional OptimalOperation {\n        text \"The system shall maintain the braking system in its optimal state at all times.\";\n    }\n\n    behavior AutomaticBrakingControl {\n        input ignitionKeyTurnedToStart;\n        input brakePedalStatus;\n        input tractionData;\n        output brakePressureCommand;\n        output modulationFrequencyCommand;\n\n        state inactive;\n        state active;\n\n        transition activate\n            from inactive\n            to active\n            when ignitionKeyTurnedToStart;\n\n        transition monitorAndAdjust\n            from active\n            to active\n            do {\n                monitor(brakePedalStatus, tractionData);\n                evaluate(brakePedalStatus, tractionData);\n                adjust(brakePressureCommand, modulationFrequencyCommand);\n            };\n    }\n\n    satisfies AutomaticActivation;\n    satisfies ContinuousMonitoring;\n    satisfies IntelligentAdjustment;\n    satisfies DynamicRegulation;\n    satisfies Safety;\n    satisfies Comfort;\n    satisfies OptimalOperation;\n}",
    "system BatteryChargingControlSystem {\n    \n    part battery : Battery\n    part charger : Charger\n\n    interface BatteryLevelSensor {\n        out batteryLevel : Percentage\n    }\n\n    interface ChargerControl {\n        in chargeCommand : Boolean\n    }\n\n    requirement SafeCharging {\n        text \"The system shall ensure that the battery is charged safely without overcharging.\"\n    }\n\n    requirement EfficientCharging {\n        text \"The system shall efficiently charge the battery to full capacity.\"\n    }\n\n    requirement AutomaticOperation {\n        text \"The system shall automatically start charging when battery level is below 100% and stop charging when battery level reaches or exceeds 100%.\"\n    }\n\n    function MonitorBatteryLevel() : Percentage {\n        input: battery\n        output: batteryLevel\n        description: \"Monitors the current battery level in real time.\"\n    }\n\n    function StartCharging() {\n        input: batteryLevel\n        output: chargeCommand\n        precondition: batteryLevel < 100%\n        description: \"Automatically starts charging when battery level is below 100%.\"\n    }\n\n    function StopCharging() {\n        input: batteryLevel\n        output: chargeCommand\n        precondition: batteryLevel >= 100%\n        description: \"Automatically stops charging when battery level reaches or exceeds 100%.\"\n    }\n\n    constraint HealthyCharging {\n        description: \"Charging is only allowed when battery level is below 100%.\"\n        expression: (batteryLevel < 100%) -> (chargeCommand = true)\n    }\n\n    constraint NoOvercharge {\n        description: \"Charging is terminated when battery level reaches or exceeds 100%.\"\n        expression: (batteryLevel >= 100%) -> (chargeCommand = false)\n    }\n\n    usecase MonitorBattery {\n        description: \"Monitor the battery level in real time.\"\n        actor: BatteryChargingControlSystem\n    }\n\n    usecase AutomaticChargeControl {\n        description: \"Automatically control the charging process based on battery level.\"\n        actor: BatteryChargingControlSystem\n    }\n\n    usecase TerminateCharging {\n        description: \"Terminate charging when battery is fully charged.\"\n        actor: BatteryChargingControlSystem\n    }\n}",
    "system BatteryChargingSystem {\n\n    part battery : Battery;\n    part charger : Charger;\n    part monitor : BatteryMonitor;\n    part controller : ChargingController;\n\n    requirement ContinuousMonitoring {\n        text \"The system shall continuously monitor the battery level during charging.\"\n    }\n\n    requirement AutomaticControl {\n        text \"The system shall automatically control the charging process based on battery level.\"\n    }\n\n    requirement NoManualIntervention {\n        text \"The system shall operate without manual intervention during charging.\"\n    }\n\n    requirement PreventOvercharging {\n        text \"The system shall terminate charging when battery level reaches or exceeds 100% to prevent overcharging.\"\n    }\n\n    requirement SafeReliableCharging {\n        text \"The system shall ensure the battery is safely and reliably fully charged.\"\n    }\n\n    interface BatteryLevelProvider {\n        out batteryLevel: Percentage;\n    }\n\n    interface ChargingControl {\n        in enableCharging: Boolean;\n    }\n\n    part monitor implements BatteryLevelProvider;\n    part controller implements ChargingControl;\n\n    connection monitorToController : BatteryLevelProvider -> ChargingController;\n    connection controllerToCharger : ChargingControl -> Charger;\n\n    state_machine ChargingProcess {\n        state Idle {\n            on entry {\n                controller.enableCharging = false;\n            }\n            transition to Charging when (startChargingRequested);\n        }\n        state Charging {\n            on entry {\n                controller.enableCharging = true;\n            }\n            transition to Terminated when (monitor.batteryLevel >= 100%);\n            transition to Charging when (monitor.batteryLevel < 100%);\n        }\n        state Terminated {\n            on entry {\n                controller.enableCharging = false;\n            }\n        }\n    }\n\n    usecase MonitorBatteryLevel {\n        subject monitor;\n        description \"Continuously monitor and provide the current battery level as a percentage.\"\n    }\n\n    usecase ControlCharging {\n        subject controller;\n        description \"Automatically enable or disable charging based on battery level.\"\n    }\n\n    usecase TerminateCharging {\n        subject controller;\n        description \"Terminate charging when battery level reaches or exceeds 100%.\"\n    }\n\n    satisfies ContinuousMonitoring by MonitorBatteryLevel;\n    satisfies AutomaticControl by ControlCharging;\n    satisfies PreventOvercharging by TerminateCharging;\n    satisfies NoManualIntervention by ControlCharging;\n    satisfies SafeReliableCharging by ControlCharging, TerminateCharging;\n}",
    "system CameraSystem {\n    \n    part user: User\n    part autofocus: AutofocusSubsystem\n    part imaging: ImagingSubsystem\n    part storage: PhotoStorageSubsystem\n\n    interface UserInterface {\n        operation selectScene(scene: Scene)\n        operation confirmScene()\n        operation viewPhoto(photo: Photo)\n    }\n\n    interface AutofocusInterface {\n        operation focusOnObject(scene: Scene) returns (focusedImage: Image)\n    }\n\n    interface ImagingInterface {\n        operation captureImage(image: Image) returns (photo: Photo)\n    }\n\n    interface StorageInterface {\n        operation savePhoto(photo: Photo)\n        operation retrievePhoto(photoId: PhotoId) returns (photo: Photo)\n    }\n\n    scenario TakePhoto {\n        user.selectScene(scene)\n        autofocus.focusOnObject(scene) -> focusedImage\n        imaging.captureImage(focusedImage) -> photo\n        storage.savePhoto(photo)\n    }\n\n    requirement CameraFunctionality {\n        text \"The system shall allow the user to select a scene and automatically perform focusing and imaging to generate a high-quality photo.\"\n    }\n\n    requirement AutofocusRequirement {\n        text \"The autofocus subsystem shall automatically focus on objects within the selected scene to obtain a clear and realistic image.\"\n    }\n\n    requirement ImagingRequirement {\n        text \"The imaging subsystem shall capture the focused image as a photograph.\"\n    }\n\n    requirement StorageRequirement {\n        text \"All photos taken shall be recorded and saved by the system.\"\n    }\n\n    requirement UsabilityRequirement {\n        text \"Users shall not need to interact with or understand internal technical details; the system shall automate focusing and imaging operations.\"\n    }\n\n    satisfies CameraFunctionality\n    satisfies AutofocusRequirement\n    satisfies ImagingRequirement\n    satisfies StorageRequirement\n    satisfies UsabilityRequirement\n\n    part userInterface: UserInterface\n    part autofocusInterface: AutofocusInterface\n    part imagingInterface: ImagingInterface\n    part storageInterface: StorageInterface\n\n    connect userInterface to user\n    connect autofocusInterface to autofocus\n    connect imagingInterface to imaging\n    connect storageInterface to storage\n\n    connect userInterface.selectScene to autofocusInterface.focusOnObject\n    connect autofocusInterface.focusOnObject to imagingInterface.captureImage\n    connect imagingInterface.captureImage to storageInterface.savePhoto\n}\n\ntype Scene\ntype Image\ntype Photo\ntype PhotoId\n\nblock User\nblock AutofocusSubsystem\nblock ImagingSubsystem\nblock PhotoStorageSubsystem",
    "system ShootingProcessCamera {\n\t\n\t// Functional Requirements\n\trequirement R1: \"The system shall enable users to select the shooting scene.\"\n\trequirement R2: \"The system shall automatically focus on the selected scene.\"\n\trequirement R3: \"The system shall automatically generate an image that meets the requirements.\"\n\trequirement R4: \"The imaging module shall capture and produce the final photo.\"\n\trequirement R5: \"The entire shooting process shall be fully automated without manual focus or imaging initiation.\"\n\trequirement R6: \"All functional modules shall collaborate to complete the shooting and image acquisition process.\"\n\t\n\t// Non-Functional Requirements\n\trequirement R7: \"The system shall ensure an efficient and convenient shooting experience.\"\n\trequirement R8: \"The system shall output high-quality photos.\"\n\t\n\t// Use Case\n\tusecase UC1: \"User selects shooting scene\"\n\tusecase UC2: \"System automatically focuses on selected scene\"\n\tusecase UC3: \"System generates image\"\n\tusecase UC4: \"Imaging module captures and produces final photo\"\n\t\n\t// Actors\n\tactor User\n\t\n\t// Functions\n\tfunction SelectScene {\n\t\tin: User\n\t\tout: SceneSelection\n\t}\n\t\n\tfunction AutoFocus {\n\t\tin: SceneSelection\n\t\tout: FocusedScene\n\t}\n\t\n\tfunction GenerateImage {\n\t\tin: FocusedScene\n\t\tout: ImageData\n\t}\n\t\n\tfunction CapturePhoto {\n\t\tin: ImageData\n\t\tout: Photo\n\t}\n\t\n\t// Structure\n\tpart sceneSelector: SelectScene\n\tpart autoFocuser: AutoFocus\n\tpart imageGenerator: GenerateImage\n\tpart photoCapturer: CapturePhoto\n\t\n\t// Behavior\n\tbehavior ShootingProcess {\n\t\tstart -> sceneSelector\n\t\tsceneSelector -> autoFocuser\n\t\tautoFocuser -> imageGenerator\n\t\timageGenerator -> photoCapturer\n\t\tphotoCapturer -> end\n\t}\n\t\n\t// Satisfy relationships\n\tsatisfy sceneSelector -> R1\n\tsatisfy autoFocuser -> R2\n\tsatisfy imageGenerator -> R3\n\tsatisfy photoCapturer -> R4\n\tsatisfy ShootingProcess -> R5\n\tsatisfy ShootingProcess -> R6\n\tsatisfy ShootingProcess -> R7\n\tsatisfy photoCapturer -> R8\n\t\n\t// Use Case relationships\n\trealize UC1 by sceneSelector\n\trealize UC2 by autoFocuser\n\trealize UC3 by imageGenerator\n\trealize UC4 by photoCapturer\n}",
    "model VehicleMotionSimulation {\n\n    // Functional Requirements\n    requirement ProvideVehicleParameters {\n        description: \"The system shall allow users to input the vehicle's mass, initial position, initial velocity, and simulation time step interval.\"\n    }\n\n    requirement ProvidePowerInputSequence {\n        description: \"The system shall allow users to input a sequence of power values, one for each simulation time step.\"\n    }\n\n    requirement CalculateVehicleTrajectory {\n        description: \"The system shall calculate the vehicle's speed and position at each time step based on the provided inputs.\"\n    }\n\n    requirement OutputTrajectory {\n        description: \"The system shall output the vehicle's position at each time step.\"\n    }\n\n    // Non-Functional Requirements\n    requirement DeterministicComputation {\n        description: \"The simulation shall produce deterministic results for the same set of inputs.\"\n    }\n\n    requirement OneDimensionalMotion {\n        description: \"The simulation shall be limited to one-dimensional straight-line motion.\"\n    }\n\n    // Vehicle Parameters\n    part vehicle: Vehicle {\n        mass: Real;\n        position: Real;\n        velocity: Real;\n    }\n\n    // Simulation Parameters\n    part simulation: Simulation {\n        timeStep: Real;\n        powerInputSequence: Sequence<Real>;\n        trajectory: Sequence<Real>;\n    }\n\n    // Constraint: Initial Conditions\n    constraint InitialConditions {\n        vehicle.mass > 0;\n        simulation.timeStep > 0;\n    }\n\n    // Constraint: Power Input Sequence Length\n    constraint PowerInputSequenceLength {\n        size(simulation.powerInputSequence) > 0;\n    }\n\n    // Behavior: Simulate Vehicle Motion\n    behavior SimulateMotion {\n        input: \n            vehicle.mass, \n            vehicle.position, \n            vehicle.velocity, \n            simulation.timeStep, \n            simulation.powerInputSequence;\n        output: \n            simulation.trajectory;\n\n        do {\n            var pos = vehicle.position;\n            var vel = vehicle.velocity;\n            var traj = [];\n            for (pwr in simulation.powerInputSequence) {\n                // acceleration = power / (mass * velocity), handle v=0\n                var acc = (vel != 0) ? (pwr / (vehicle.mass * vel)) : 0;\n                vel = vel + acc * simulation.timeStep;\n                pos = pos + vel * simulation.timeStep;\n                traj = traj + [pos];\n            }\n            simulation.trajectory = traj;\n        }\n    }\n\n    // Satisfy relationships\n    satisfy ProvideVehicleParameters by vehicle;\n    satisfy ProvidePowerInputSequence by simulation;\n    satisfy CalculateVehicleTrajectory by SimulateMotion;\n    satisfy OutputTrajectory by simulation.trajectory;\n    satisfy DeterministicComputation by SimulateMotion;\n    satisfy OneDimensionalMotion by vehicle;\n\n}",
    "package CameraShootingSystem {\n\n    part system: CameraSystem;\n\n    part user: User;\n\n    interface SceneInput {\n        in scene: Scene;\n    }\n\n    interface PhotoOutput {\n        out photo: Photo;\n    }\n\n    type Scene;\n    type Image;\n    type Photo;\n\n    part CameraSystem {\n        port sceneInput: SceneInput;\n        port photoOutput: PhotoOutput;\n        part focusing: FocusingProcess;\n        part imageCapture: ImageCaptureProcess;\n        part photoDisplay: PhotoDisplayProcess;\n\n        constraint seamlessIntegration {\n            // Ensures automatic, seamless process flow\n            focusing.completed -> imageCapture.started;\n            imageCapture.completed -> photoDisplay.started;\n        }\n\n        behavior {\n            on sceneInput.scene {\n                focusing.focus(sceneInput.scene);\n                let img = focusing.image;\n                imageCapture.capture(img);\n                let p = imageCapture.photo;\n                photoDisplay.display(p);\n                photoOutput.photo = p;\n            }\n        }\n    }\n\n    part FocusingProcess {\n        in scene: Scene;\n        out image: Image;\n\n        behavior focus(s: Scene) {\n            // Focusing logic\n            image = obtainImage(s);\n            completed;\n        }\n    }\n\n    part ImageCaptureProcess {\n        in image: Image;\n        out photo: Photo;\n\n        behavior capture(img: Image) {\n            // Image capture logic\n            photo = generatePhoto(img);\n            completed;\n        }\n    }\n\n    part PhotoDisplayProcess {\n        in photo: Photo;\n\n        behavior display(p: Photo) {\n            // Display logic\n            showOnScreen(p);\n            completed;\n        }\n    }\n\n    part User {\n        port sceneInput: SceneInput;\n        port photoOutput: PhotoOutput;\n\n        behavior {\n            // User initiates shooting\n            let s = inputScene();\n            sceneInput.scene = s;\n            let p = photoOutput.photo;\n            viewPhoto(p);\n        }\n    }\n}",
    "system CameraInformationProcessingWorkflow {\n\n    part viewPort: ViewPort;\n    part displayPort: DisplayPort;\n    part imageProcessor: ImageProcessor;\n    part camera: Camera;\n    part screen: Screen;\n\n    interface UserInterface {\n        in selectScene(scene: Scene);\n        in shoot();\n    }\n\n    interface CameraInterface {\n        out image: Image;\n        out picture: Picture;\n    }\n\n    interface DisplayInterface {\n        in picture: Picture;\n    }\n\n    scenario CameraWorkflow {\n        user: UserInterface;\n        camera: CameraInterface;\n        display: DisplayInterface;\n\n        user.selectScene(scene);\n        camera.focusOn(scene) -> image;\n        camera.capture(image) -> picture;\n        display.display(picture);\n    }\n\n    behavior CameraInformationProcessingWorkflowBehavior {\n        state idle;\n        state sceneSelected;\n        state focused;\n        state imageCaptured;\n        state pictureDisplayed;\n\n        transition idle -> sceneSelected on viewPort.sceneSelected;\n        transition sceneSelected -> focused on camera.focusOn;\n        transition focused -> imageCaptured on camera.capture;\n        transition imageCaptured -> pictureDisplayed on displayPort.display;\n        transition pictureDisplayed -> idle on user.shoot;\n    }\n\n    requirement UserSimplicity {\n        text \"The user only needs to select a scene and shoot; all technical processes are handled automatically by the system.\";\n        kind = nonfunctional;\n    }\n\n    requirement AutomaticProcessing {\n        text \"The system shall automatically focus, capture, and display the photograph after the user initiates shooting.\";\n        kind = functional;\n    }\n}\n\nblock ViewPort {\n    port sceneSelected: out Scene;\n}\n\nblock DisplayPort {\n    port display: in Picture;\n}\n\nblock ImageProcessor {\n    port image: out Image;\n    port picture: out Picture;\n}\n\nblock Camera {\n    port focusOn: in Scene;\n    port capture: in Image;\n    port image: out Image;\n    port picture: out Picture;\n}\n\nblock Screen {\n    port display: in Picture;\n}\n\ntype Scene;\ntype Image;\ntype Picture;",
    "system SensorManagementSystem {\n\n    part sensors: Sensor[*];\n\n    requirement ManageMultipleSensors {\n        description \"The system shall manage multiple sensors.\";\n    }\n\n    requirement MonitorAndUpdateStatus {\n        description \"The system shall monitor and update the status of all sensors.\";\n    }\n\n    requirement AutoUpdateReadySensors {\n        description \"The system shall automatically update any sensor that is in a ready state.\";\n    }\n\n    requirement TraverseAndMaintainSensors {\n        description \"The system shall traverse all registered sensors and maintain those that are ready.\";\n    }\n\n    requirement ResponsivenessReliability {\n        description \"The system shall enhance responsiveness and reliability by keeping all available sensors up-to-date.\";\n        kind = nonfunctional;\n    }\n\n    behavior MonitorAndUpdate {\n        input sensors: Sensor[*];\n        do {\n            for each s in sensors {\n                if s.status == SensorStatus::ready {\n                    s.update();\n                }\n            }\n        }\n    }\n\n    satisfies ManageMultipleSensors;\n    satisfies MonitorAndUpdateStatus;\n    satisfies AutoUpdateReadySensors;\n    satisfies TraverseAndMaintainSensors;\n    satisfies ResponsivenessReliability;\n}\n\nblock Sensor {\n    attribute status: SensorStatus;\n    operation update();\n}\n\nenum SensorStatus {\n    ready;\n    not_ready;\n    error;\n}",
    "state machine VehicleStateManager {\n    state Off initial;\n    state Starting;\n    state On;\n\n    transition OffToStarting {\n        from Off;\n        to Starting;\n        trigger vehicle_start_signal;\n    }\n\n    transition StartingToOn {\n        from Starting;\n        to On;\n        trigger vehicle_power_on_signal;\n    }\n\n    transition AnyToOff {\n        from Off, Starting, On;\n        to Off;\n        trigger vehicle_shutdown_signal;\n    }\n}\n\nrequirement ReliableStateTransition {\n    text \"The system shall reliably ensure that the vehicle state responds appropriately to the corresponding control signals and safely and sequentially transitions between each state as specified.\"\n}",
    "package VehicleOperationalStatusSystem {\n\n    stateMachine VehicleOperationalStatusManager {\n        state Off initial;\n        state Starting;\n        state On;\n\n        transition OffToStarting {\n            source Off;\n            target Starting;\n            trigger VehicleStartSignal;\n        }\n\n        transition StartingToOn {\n            source Starting;\n            target On;\n            trigger VehicleOnSignal;\n        }\n\n        transition OnToOff {\n            source On;\n            target Off;\n            trigger VehicleOffSignal;\n        }\n    }\n\n    interface VehicleControlSignals {\n        signal VehicleStartSignal;\n        signal VehicleOnSignal;\n        signal VehicleOffSignal;\n    }\n\n    part VehicleOperationalStatusManagerPart : VehicleOperationalStatusManager;\n\n    satisfies VehicleOperationalStatusManagerPart -> VehicleControlSignals;\n}",
    "system VehiclePowerManagementSystem {\n\n    part vehicle: Vehicle;\n    part powerController: PowerController;\n    part selfDiagnosisUnit: SelfDiagnosisUnit;\n    part functionalUnits: FunctionalUnitSet;\n    part userInterface: UserInterface;\n\n    stateMachine PowerStateMachine {\n        state Off {\n            entry / powerController.cutOffPower();\n        }\n        state StartPhase {\n            entry / powerController.initiateStart();\n        }\n        state PoweredOn {\n            entry / {\n                powerController.supplyPower();\n                selfDiagnosisUnit.performSelfDiagnosis();\n            }\n            do / functionalUnits.supplyContinuousPower();\n        }\n        state Shutdown {\n            entry / {\n                powerController.engageParkingBrake();\n                powerController.prepareShutdown();\n            }\n        }\n\n        transition OffToStartPhase: Off -> StartPhase\n            trigger userInterface.vehicleStartCommand();\n\n        transition StartPhaseToPoweredOn: StartPhase -> PoweredOn\n            trigger vehicle.vehicleStartedSignal();\n\n        transition PoweredOnToShutdown: PoweredOn -> Shutdown\n            trigger userInterface.vehicleShutdownCommand();\n\n        transition ShutdownToOff: Shutdown -> Off\n            effect powerController.cutOffPower();\n    }\n\n    requirement IntelligentControl {\n        description \"The system shall automatically manage vehicle power states based on user and system signals.\"\n    }\n\n    requirement Safety {\n        description \"The system shall execute safety operations (e.g., parking brake engagement) before power-off.\"\n    }\n\n    requirement ContinuousPowerSupply {\n        description \"The system shall continuously supply power to all functional units during the powered-on state.\"\n    }\n\n    requirement SelfDiagnosis {\n        description \"The system shall perform self-diagnosis automatically during the powered-on state.\"\n    }\n\n    satisfies IntelligentControl;\n    satisfies Safety;\n    satisfies ContinuousPowerSupply;\n    satisfies SelfDiagnosis;\n}",
    "system VehicleControlSystem {\n\n    state_machine VehicleStateMachine {\n        state Shutdown initial;\n        state Startup;\n        state Running;\n\n        transition Shutdown_to_Startup {\n            source: Shutdown;\n            target: Startup;\n            trigger: VehicleStartSignal;\n        }\n\n        transition Startup_to_Running {\n            source: Startup;\n            target: Running;\n            trigger: VehicleStartedSignal;\n        }\n\n        transition Running_to_Shutdown {\n            source: Running;\n            target: Shutdown;\n            trigger: VehicleShutdownSignal;\n        }\n    }\n\n    signal VehicleStartSignal;\n    signal VehicleStartedSignal;\n    signal VehicleShutdownSignal;\n\n    property vehicleStatus: enum { Shutdown, Startup, Running };\n\n    requirement ManageVehicleStates {\n        text \"The system shall manage vehicle start-up, operation, and shutdown processes, enabling automatic switching among shutdown, start-up, and running states in response to user and system signals.\"\n    }\n\n    requirement AccurateSignalResponse {\n        text \"The system must accurately respond to vehicle start, started, and shutdown signals to ensure safe and convenient control of the vehicle’s start and stop processes.\"\n    }\n}",
    "system PowerManagementSystem {\n\t\n\tpart vehicle: Vehicle;\n\n}\n\nblock Vehicle {\n\n\tstate_machine OperatingStateMachine {\n\t\t\n\t\tstate Off {\n\t\t\tentry / vehicle.power := false;\n\t\t}\n\t\t\n\t\tstate Start {\n\t\t\tentry / vehicle.power := true;\n\t\t}\n\t\t\n\t\tstate On {\n\t\t\tentry / vehicle.power := true;\n\t\t}\n\t\t\n\t\ttransition Off_to_Start: Off -> Start\n\t\t\twhen (user.start_signal)\n\t\t\teffect / vehicle.startup();\n\n\t\ttransition Start_to_On: Start -> On\n\t\t\twhen (user.on_signal)\n\t\t\teffect / vehicle.complete_startup();\n\n\t\ttransition On_to_Off: On -> Off\n\t\t\twhen (user.off_signal)\n\t\t\teffect / vehicle.shutdown();\n\n\t\tinitial Off;\n\t}\n\n\tproperty power: Boolean;\n\t\n\toperation startup();\n\toperation complete_startup();\n\toperation shutdown();\n\n\t// Placeholder for future health state management\n\tstate_machine HealthStateMachine {\n\t\t// To be defined in future expansion\n\t}\n}\n\nactor user {\n\tproperty start_signal: Boolean;\n\tproperty on_signal: Boolean;\n\tproperty off_signal: Boolean;\n}",
    "system VehicleHealthManagementSystem {\n\n    part vehicle : Vehicle;\n    part controller : VehicleController;\n\n    state_machine HealthStatusSM {\n        state Normal;\n        state Degraded;\n        state Maintenance;\n\n        transition OverTempDetected {\n            source Normal;\n            target Degraded;\n            trigger vehicle.temperature > vehicle.maxAllowableTemperature;\n            effect {\n                controller.sendWarning(\"OverTemperature\");\n            }\n        }\n\n        transition TempRestored {\n            source Degraded;\n            target Normal;\n            trigger vehicle.temperature <= vehicle.maxAllowableTemperature;\n        }\n\n        transition MaintenanceDue {\n            source Normal;\n            target Maintenance;\n            trigger now() >= vehicle.nextMaintenanceTime;\n        }\n\n        transition MaintenanceDueFromDegraded {\n            source Degraded;\n            target Maintenance;\n            trigger now() >= vehicle.nextMaintenanceTime;\n        }\n\n        transition MaintenanceCompleted {\n            source Maintenance;\n            target Normal;\n            trigger maintenanceCompleted and maintenanceDuration >= 48h;\n            effect {\n                vehicle.nextMaintenanceTime = now() + vehicle.maintenanceInterval;\n            }\n        }\n    }\n\n    property maxAllowableTemperature : Real;\n    property maintenanceInterval : Duration;\n    property nextMaintenanceTime : Time;\n    property temperature : Real;\n    property maintenanceCompleted : Boolean;\n    property maintenanceDuration : Duration;\n\n    constraint OverTemperatureDetection {\n        vehicle.temperature > vehicle.maxAllowableTemperature implies HealthStatusSM.state == Degraded;\n    }\n\n    constraint MaintenanceEntry {\n        now() >= vehicle.nextMaintenanceTime implies HealthStatusSM.state == Maintenance;\n    }\n\n    constraint MaintenanceExit {\n        HealthStatusSM.state == Maintenance and maintenanceDuration >= 48h and maintenanceCompleted implies HealthStatusSM.state == Normal;\n    }\n\n    requirement AutomaticOperation {\n        text \"The system shall automatically monitor vehicle temperature, compare it to the maximum allowable value, and manage health status transitions without manual intervention.\";\n    }\n\n    requirement OverTemperatureWarning {\n        text \"If the vehicle temperature exceeds the maximum allowable value, the system shall send an over-temperature warning to the vehicle controller.\";\n    }\n\n    requirement MaintenanceScheduling {\n        text \"The system shall enter maintenance status at scheduled intervals and update the next maintenance cycle after completion.\";\n    }\n\n    requirement MaintenanceDuration {\n        text \"After maintenance status has lasted for 48 hours, the vehicle shall automatically return to normal operating status.\";\n    }\n\n    requirement SafetyReliability {\n        text \"The system shall enhance safety and reliability by timely detection and management of over-temperature and maintenance needs.\";\n    }\n}",
    "system ServerSystem {\n    \n    part server: Server;\n    port requestPort: RequestPort;\n    part localClock: Clock;\n\n    constraint dailyOffTime: \n        localClock.time == time(\"11:59:00\") implies server.state == ServerState.off;\n}\n\nblock Server {\n    port requestPort: RequestPort;\n    part localClock: Clock;\n\n    enum ServerState { off, waiting, response }\n    state state: ServerState = ServerState.off;\n\n    statemachine ServerBehavior {\n        state Off {\n            entry / state = ServerState.off;\n            transition to Waiting \n                when requestPort.received(\"start\") \n                / state = ServerState.waiting;\n        }\n        state Waiting {\n            entry / state = ServerState.waiting;\n            transition to Response \n                when requestPort.received(\"request\") \n                / state = ServerState.response;\n            transition to Off \n                when localClock.time == time(\"11:59:00\") \n                / state = ServerState.off;\n        }\n        state Response {\n            entry / state = ServerState.response;\n            transition to Waiting \n                after duration(\"PT5M\") \n                / state = ServerState.waiting;\n            transition to Off \n                when localClock.time == time(\"11:59:00\") \n                / state = ServerState.off;\n        }\n        initial -> Off;\n    }\n}\n\ninterface RequestPort {\n    in event received(command: String);\n}\n\nblock Clock {\n    property time: Time;\n}\n\ntype Time = String;\n",
    "system VehicleStartStopSystem {\n\n    state OffState {\n        transition onStartSignal -> StartProcess;\n    }\n\n    state StartProcess {\n        transition when (brakePedalDepressed and powerOnSignalReceived) -> OperatingState {\n            action {\n                sendStartSignalToController();\n            }\n        }\n    }\n\n    state OperatingState {\n        entry {\n            performSelfCheck();\n            supplyPowerContinuously();\n        }\n        transition onStopSignal -> OffState {\n            action {\n                applyParkingBrake();\n            }\n        }\n    }\n\n    input signal startSignal;\n    input signal stopSignal;\n    input signal powerOnSignal;\n    input boolean brakePedalDepressed;\n\n    output signal startSignalToController;\n    output action applyParkingBrake;\n    output action performSelfCheck;\n    output action supplyPowerContinuously;\n\n    requirement Safety {\n        description: \"The system shall ensure safe and reliable start-stop process and coordinated control with the controller.\";\n    }\n\n    requirement ParkingSafety {\n        description: \"The system shall automatically apply the parking brake upon leaving the operating state.\";\n    }\n\n    requirement PowerSupply {\n        description: \"The system shall continuously supply power to the vehicle in the operating state.\";\n    }\n\n    requirement SelfCheck {\n        description: \"The system shall perform a self-check upon entering the operating state.\";\n    }\n\n    behavior {\n        initial state OffState;\n    }\n}",
    "system VehicleStartStopControlSystem {\n    \n    part vehicleController: VehicleController;\n    part brakePedal: BrakePedal;\n    part parkingBrake: ParkingBrake;\n    part powerSupply: PowerSupply;\n    part driverInterface: DriverInterface;\n\n    stateMachine VehicleStartStopStateMachine {\n        state Off {\n            entry / powerSupply.deactivate();\n        }\n        state StartUp {\n            entry / vehicleController.initiateStart();\n        }\n        state Started {\n            entry / {\n                vehicleController.performSelfCheck();\n                powerSupply.activate();\n            }\n        }\n        state ShutDown {\n            entry / {\n                parkingBrake.apply();\n                powerSupply.deactivate();\n            }\n        }\n\n        transition Off -> StartUp when driverInterface.vehicleStartSignalReceived();\n        transition StartUp -> Started when brakePedal.isDepressed() and driverInterface.vehicleOnSignalReceived();\n        transition Started -> ShutDown when driverInterface.shutdownSignalReceived();\n        transition ShutDown -> Off when parkingBrake.isApplied();\n    }\n\n    requirement FunctionalRequirements {\n        req1: The system shall only allow vehicle start when the brake pedal is depressed and a vehicle-on signal is received.\n        req2: The system shall perform a self-check upon entering the started state.\n        req3: The system shall continuously supply power to the vehicle while in the started state.\n        req4: The system shall only allow shutdown when a shutdown signal is received.\n        req5: The system shall ensure the parking brake is applied before completing shutdown.\n    }\n\n    requirement NonFunctionalRequirements {\n        req6: The system shall improve convenience and safety of vehicle operation.\n        req7: The system shall automate start, operation, and shutdown processes.\n    }\n\n    interface VehicleController {\n        operation initiateStart();\n        operation performSelfCheck();\n    }\n\n    interface BrakePedal {\n        operation isDepressed(): Boolean;\n    }\n\n    interface ParkingBrake {\n        operation apply();\n        operation isApplied(): Boolean;\n    }\n\n    interface PowerSupply {\n        operation activate();\n        operation deactivate();\n    }\n\n    interface DriverInterface {\n        operation vehicleStartSignalReceived(): Boolean;\n        operation vehicleOnSignalReceived(): Boolean;\n        operation shutdownSignalReceived(): Boolean;\n    }\n}",
    "package CruiseControlSystem {\n\n    part Driver driver;\n    part CruiseController cruiseController;\n    part Speedometer speedometer;\n    part Engine engine;\n    part Vehicle vehicle;\n\n    interface SetSpeedCommand {\n        attribute desiredSpeed: Real;\n    }\n\n    interface ActualSpeedInfo {\n        attribute actualSpeed: Real;\n    }\n\n    interface FuelControlCommand {\n        attribute fuelAdjustment: Real;\n    }\n\n    event SetSpeedEvent {\n        out setSpeed: SetSpeedCommand;\n    }\n\n    event ActualSpeedEvent {\n        out actualSpeed: ActualSpeedInfo;\n    }\n\n    event FuelControlEvent {\n        out fuelControl: FuelControlCommand;\n    }\n\n    part Driver {\n        port setSpeedOut: SetSpeedEvent;\n    }\n\n    part CruiseController {\n        port setSpeedIn: SetSpeedEvent;\n        port actualSpeedIn: ActualSpeedEvent;\n        port fuelControlOut: FuelControlEvent;\n    }\n\n    part Speedometer {\n        port actualSpeedOut: ActualSpeedEvent;\n    }\n\n    part Engine {\n        port fuelControlIn: FuelControlEvent;\n    }\n\n    part Vehicle {\n        // Placeholder for vehicle dynamics and integration\n    }\n\n    connection driverToController {\n        from driver.setSpeedOut;\n        to cruiseController.setSpeedIn;\n    }\n\n    connection speedometerToController {\n        from speedometer.actualSpeedOut;\n        to cruiseController.actualSpeedIn;\n    }\n\n    connection controllerToEngine {\n        from cruiseController.fuelControlOut;\n        to engine.fuelControlIn;\n    }\n\n    // Requirement: The system shall maintain the vehicle speed at the set value as commanded by the driver.\n    requirement MaintainSetSpeed {\n        text \"The cruise control system shall maintain the vehicle speed at the set value as commanded by the driver.\";\n    }\n\n    // Requirement: The system shall allow the driver to activate and set the desired speed.\n    requirement SetSpeedByDriver {\n        text \"The system shall allow the driver to activate and set the desired speed.\";\n    }\n\n    // Requirement: The cruise controller shall receive actual speed from the speedometer.\n    requirement ReceiveActualSpeed {\n        text \"The cruise controller shall receive actual speed information from the speedometer.\";\n    }\n\n    // Requirement: The cruise controller shall send fuel control commands to the engine.\n    requirement SendFuelControl {\n        text \"The cruise controller shall send fuel control commands to the engine.\";\n    }\n\n    // Requirement: The engine shall adjust output to maintain the set speed.\n    requirement EngineAdjustOutput {\n        text \"The engine shall adjust its output according to the received fuel control commands to maintain the set speed.\";\n    }\n}",
    "package CruiseControlSystem {\n\n    part vehicle : Vehicle;\n    part driver : Driver;\n    part cruiseController : CruiseController;\n    part speedometer : Speedometer;\n    part engineSystem : EngineSystem;\n\n    interface SetSpeedCommand {\n        in speed : Real;\n    }\n\n    interface ThrottleControlCommand {\n        in throttleValue : Real;\n    }\n\n    interface VehicleSpeedInfo {\n        out speed : Real;\n    }\n\n    part CruiseController {\n        port setSpeedIn : SetSpeedCommand;\n        port speedIn : VehicleSpeedInfo;\n        port throttleOut : ThrottleControlCommand;\n\n        attribute setSpeed : Real;\n        attribute actualSpeed : Real;\n        attribute throttleValue : Real;\n\n        operation receiveSetSpeed(speed : Real) {\n            setSpeed = speed;\n        }\n\n        operation acquireActualSpeed(speed : Real) {\n            actualSpeed = speed;\n        }\n\n        operation computeThrottle() {\n            throttleValue = calculateThrottle(setSpeed, actualSpeed);\n        }\n\n        operation sendThrottleCommand() {\n            throttleOut.throttleValue = throttleValue;\n        }\n\n        function calculateThrottle(setSpeed : Real, actualSpeed : Real) : Real {\n            return (setSpeed - actualSpeed) * gain;\n        }\n\n        attribute gain : Real = 1.0;\n    }\n\n    part Speedometer {\n        port speedOut : VehicleSpeedInfo;\n\n        attribute currentSpeed : Real;\n\n        operation measureSpeed() {\n            speedOut.speed = currentSpeed;\n        }\n    }\n\n    part EngineSystem {\n        port throttleIn : ThrottleControlCommand;\n\n        operation adjustPower(throttleValue : Real) {\n            // Adjust engine power output\n        }\n    }\n\n    part Driver {\n        port setSpeedOut : SetSpeedCommand;\n\n        operation setCruiseSpeed(speed : Real) {\n            setSpeedOut.speed = speed;\n        }\n    }\n\n    part Vehicle {\n        part speedometer : Speedometer;\n        part engineSystem : EngineSystem;\n    }\n\n    connection driverToController : Driver.setSpeedOut -> CruiseController.setSpeedIn;\n    connection speedometerToController : Speedometer.speedOut -> CruiseController.speedIn;\n    connection controllerToEngine : CruiseController.throttleOut -> EngineSystem.throttleIn;\n\n    requirement AutomaticSpeedControl {\n        text \"The system shall automatically adjust the vehicle speed to match the set speed provided by the driver.\"\n    }\n\n    requirement RealTimeSpeedAcquisition {\n        text \"The cruise controller shall acquire real-time vehicle speed information from the speedometer.\"\n    }\n\n    requirement ThrottleControl {\n        text \"The cruise controller shall generate and send throttle control commands to the engine system based on the difference between set speed and actual speed.\"\n    }\n\n    requirement DriverIntentResponse {\n        text \"The system shall respond automatically to the driver's set speed command.\"\n    }\n\n    requirement ComfortAndSafety {\n        text \"The system shall improve driving comfort and safety by maintaining the set speed.\"\n    }\n}",
    "system CruiseControlSystem {\n    \n    part driver: Driver\n    part cruiseController: CruiseController\n    part speedometer: Speedometer\n    part engine: Engine\n\n    interface SetSpeedCommand {\n        attribute setSpeed: Real\n    }\n\n    interface VehicleSpeedInfo {\n        attribute currentSpeed: Real\n    }\n\n    interface ThrottleControlCommand {\n        attribute throttleValue: Real\n    }\n\n    // Driver sends set speed command to Cruise Controller\n    driver -> cruiseController: SetSpeedCommand\n\n    // Speedometer provides current speed to Cruise Controller\n    speedometer -> cruiseController: VehicleSpeedInfo\n\n    // Cruise Controller sends throttle command to Engine\n    cruiseController -> engine: ThrottleControlCommand\n\n    // Engine affects vehicle speed, which is sensed by Speedometer\n    engine -> speedometer: VehicleSpeedInfo\n\n    // Requirement: System shall maintain vehicle speed at set speed\n    requirement MaintainSetSpeed {\n        text \"The system shall maintain the vehicle speed at the set speed specified by the driver within acceptable tolerance.\"\n    }\n\n    // Requirement: System shall allow driver to set target speed\n    requirement AllowSetSpeed {\n        text \"The system shall allow the driver to set a target speed via the in-vehicle control interface.\"\n    }\n\n    // Requirement: System shall automatically control throttle to maintain speed\n    requirement AutoThrottleControl {\n        text \"The system shall automatically control the engine throttle to maintain the set speed without continuous driver input.\"\n    }\n}\n\nblock Driver {\n    port out setSpeedCmd: SetSpeedCommand\n}\n\nblock CruiseController {\n    port in setSpeedCmd: SetSpeedCommand\n    port in vehicleSpeed: VehicleSpeedInfo\n    port out throttleCmd: ThrottleControlCommand\n\n    operation calculateThrottle(setSpeed: Real, currentSpeed: Real): Real\n}\n\nblock Speedometer {\n    port out vehicleSpeed: VehicleSpeedInfo\n}\n\nblock Engine {\n    port in throttleCmd: ThrottleControlCommand\n    port out vehicleSpeed: VehicleSpeedInfo\n}",
    "package CruiseControlSystem {\n\n    part vehicle: Vehicle;\n    part driver: Driver;\n    part cruiseController: CruiseController;\n    part engine: Engine;\n    part speedometer: Speedometer;\n\n    interface SpeedSettingRequest {\n        in desiredSpeed: Real;\n    }\n\n    interface ThrottleCommand {\n        in throttleValue: Real;\n    }\n\n    interface SpeedFeedback {\n        out currentSpeed: Real;\n    }\n\n    requirement MaintainCruisingSpeed {\n        text \"The system shall maintain the vehicle speed at the driver-set value with accuracy and smoothness.\"\n    }\n\n    requirement PromptResponse {\n        text \"The system shall promptly process and transmit the driver’s speed setting request.\"\n    }\n\n    requirement RealTimeFeedback {\n        text \"The system shall use real-time speed feedback from the speedometer.\"\n    }\n\n    requirement ComfortAndConvenience {\n        text \"The system shall ensure convenience and comfort for the driver during cruise control operation.\"\n    }\n\n    part CruiseControlSystem {\n        part driver: Driver;\n        part cruiseController: CruiseController;\n        part engine: Engine;\n        part speedometer: Speedometer;\n    }\n\n    behavior CruiseControlWorkflow {\n        input desiredSpeed: Real;\n        output throttleValue: Real;\n\n        state Idle;\n        state SetSpeed;\n        state MaintainSpeed;\n\n        transition Idle -> SetSpeed when (driver.sendsSpeedSettingRequest);\n        transition SetSpeed -> MaintainSpeed when (cruiseController.receivesSpeedSettingRequest);\n        transition MaintainSpeed -> Idle when (driver.deactivatesCruiseControl);\n\n        action SetSpeed {\n            cruiseController.setCruisingSpeed(desiredSpeed);\n        }\n\n        action MaintainSpeed {\n            loop {\n                speedometer.measure(currentSpeed);\n                cruiseController.calculateThrottle(desiredSpeed, currentSpeed);\n                cruiseController.sendThrottleCommand(throttleValue);\n                engine.applyThrottle(throttleValue);\n            }\n        }\n    }\n\n    part Driver {\n        port speedSettingRequest: SpeedSettingRequest;\n        operation sendsSpeedSettingRequest(desiredSpeed: Real);\n        operation deactivatesCruiseControl();\n    }\n\n    part CruiseController {\n        port speedSettingRequest: SpeedSettingRequest;\n        port throttleCommand: ThrottleCommand;\n        port speedFeedback: SpeedFeedback;\n\n        operation setCruisingSpeed(desiredSpeed: Real);\n        operation calculateThrottle(desiredSpeed: Real, currentSpeed: Real): Real;\n        operation sendThrottleCommand(throttleValue: Real);\n        receives speedSettingRequest;\n        receives speedFeedback;\n        sends throttleCommand;\n    }\n\n    part Engine {\n        port throttleCommand: ThrottleCommand;\n        operation applyThrottle(throttleValue: Real);\n        receives throttleCommand;\n    }\n\n    part Speedometer {\n        port speedFeedback: SpeedFeedback;\n        operation measure(currentSpeed: Real);\n        sends speedFeedback;\n    }\n\n    CruiseControlSystem.driver.speedSettingRequest -> CruiseControlSystem.cruiseController.speedSettingRequest;\n    CruiseControlSystem.speedometer.speedFeedback -> CruiseControlSystem.cruiseController.speedFeedback;\n    CruiseControlSystem.cruiseController.throttleCommand -> CruiseControlSystem.engine.throttleCommand;\n\n    satisfies CruiseControlSystem with MaintainCruisingSpeed, PromptResponse, RealTimeFeedback, ComfortAndConvenience;\n}",
    "package automotive.cruise_control {\n\n    part Vehicle {\n        part cruiseController: CruiseController;\n        part engine: Engine;\n        part speedSensor: SpeedSensor;\n        part cruiseControlInterface: CruiseControlInterface;\n    }\n\n    interface SetSpeedCommand {\n        in setSpeed: Real;\n    }\n\n    interface ActualSpeedFeedback {\n        out actualSpeed: Real;\n    }\n\n    interface FuelControlCommand {\n        out fuelControl: Real;\n    }\n\n    part CruiseControlInterface {\n        port setSpeedOut: SetSpeedCommand;\n    }\n\n    part SpeedSensor {\n        port actualSpeedOut: ActualSpeedFeedback;\n    }\n\n    part Engine {\n        port fuelControlIn: FuelControlCommand;\n    }\n\n    part CruiseController {\n        port setSpeedIn: SetSpeedCommand;\n        port actualSpeedIn: ActualSpeedFeedback;\n        port fuelControlOut: FuelControlCommand;\n    }\n\n    connection setSpeedCmd: CruiseControlInterface.setSpeedOut -> CruiseController.setSpeedIn;\n    connection speedFeedback: SpeedSensor.actualSpeedOut -> CruiseController.actualSpeedIn;\n    connection fuelCmd: CruiseController.fuelControlOut -> Engine.fuelControlIn;\n\n    requirement MaintainTargetSpeed {\n        text \"The system shall maintain the vehicle speed as close as possible to the target speed set by the driver.\";\n    }\n\n    requirement RealTimeSpeedDetection {\n        text \"The system shall obtain real-time actual speed information from the speed sensor.\";\n    }\n\n    requirement EfficientAccurateCommunication {\n        text \"All components shall exchange information efficiently and accurately via data ports.\";\n    }\n\n    requirement SimpleDriverOperation {\n        text \"The system shall provide a simple interface for the driver to set the target speed.\";\n    }\n\n    requirement ReliableOperation {\n        text \"The system shall operate reliably under all normal driving conditions.\";\n    }\n\n    satisfies Vehicle -> MaintainTargetSpeed;\n    satisfies Vehicle -> RealTimeSpeedDetection;\n    satisfies Vehicle -> EfficientAccurateCommunication;\n    satisfies Vehicle -> SimpleDriverOperation;\n    satisfies Vehicle -> ReliableOperation;\n\n}",
    "package CruiseControlSystem {\n\n    part Vehicle {\n        part driver: Driver;\n        part cruiseController: CruiseController;\n        part speedSensor: SpeedSensor;\n        part engineController: EngineController;\n        part engine: Engine;\n    }\n\n    interface SetSpeedCommand {\n        in setSpeed: Real;\n    }\n\n    interface SpeedInfo {\n        out speed: Real;\n    }\n\n    interface FuelControlCommand {\n        out fuelCommand: Real;\n    }\n\n    interface EngineFuelControl {\n        in fuelCommand: Real;\n    }\n\n    part Driver {\n        port setSpeedOut: SetSpeedCommand;\n    }\n\n    part CruiseController {\n        port setSpeedIn: SetSpeedCommand;\n        port speedIn: SpeedInfo;\n        port fuelCommandOut: FuelControlCommand;\n    }\n\n    part SpeedSensor {\n        port speedOut: SpeedInfo;\n    }\n\n    part EngineController {\n        port fuelCommandIn: FuelControlCommand;\n        port engineFuelOut: EngineFuelControl;\n    }\n\n    part Engine {\n        port engineFuelIn: EngineFuelControl;\n    }\n\n    connection driverToCruiseController: SetSpeedCommand (\n        source: Vehicle.driver.setSpeedOut,\n        target: Vehicle.cruiseController.setSpeedIn\n    );\n\n    connection speedSensorToCruiseController: SpeedInfo (\n        source: Vehicle.speedSensor.speedOut,\n        target: Vehicle.cruiseController.speedIn\n    );\n\n    connection cruiseControllerToEngineController: FuelControlCommand (\n        source: Vehicle.cruiseController.fuelCommandOut,\n        target: Vehicle.engineController.fuelCommandIn\n    );\n\n    connection engineControllerToEngine: EngineFuelControl (\n        source: Vehicle.engineController.engineFuelOut,\n        target: Vehicle.engine.engineFuelIn\n    );\n\n    requirement ReliableOperation {\n        text \"The system shall ensure reliable message delivery between all components.\"\n    }\n\n    requirement EfficientOperation {\n        text \"The system shall process and transmit commands with minimal latency.\"\n    }\n\n    requirement SafeOperation {\n        text \"The system shall prevent unsafe speed or fuel commands.\"\n    }\n\n    requirement StandardizedInterfaces {\n        text \"All message interfaces between components shall be standardized.\"\n    }\n}",
    "package VehicleLifecycleManagement {\n\n    part VehicleLifecycleSystem {\n        part vehicles: Vehicle[*];\n    }\n\n    part Vehicle {\n        attribute vin: String;\n        attribute assemblyDate: DateTime;\n        part delivery: Delivery;\n        part ownerships: OwnershipPeriod[*];\n        part scrapping: ScrappingInfo?;\n    }\n\n    part Delivery {\n        attribute deliveryDate: DateTime;\n        attribute initialOwner: Owner;\n    }\n\n    part OwnershipPeriod {\n        attribute startDate: DateTime;\n        attribute endDate: DateTime?;\n        attribute owner: Owner;\n        part drivingRecords: DrivingRecord[*];\n    }\n\n    part Owner {\n        attribute ownerId: String;\n        attribute name: String;\n        attribute contactInfo: String;\n    }\n\n    part DrivingRecord {\n        attribute driveDateTime: DateTime;\n        attribute driver: Driver;\n        attribute operationDetails: String?;\n    }\n\n    part Driver {\n        attribute driverId: String;\n        attribute name: String;\n        attribute licenseNumber: String;\n    }\n\n    part ScrappingInfo {\n        attribute scrappingDate: DateTime;\n        attribute deregistrationNumber: String?;\n        attribute notes: String?;\n    }\n\n    requirement R1 {\n        text = \"The system shall record the assembly and delivery stages for each vehicle.\"\n    }\n\n    requirement R2 {\n        text = \"The system shall record the specific delivery date at the time of delivery for each vehicle.\"\n    }\n\n    requirement R3 {\n        text = \"The system shall record all ownership changes, with each stage traceable to a unique owner.\"\n    }\n\n    requirement R4 {\n        text = \"The system shall record and track different drivers for each ownership period, specifying the actual driver for each driving operation.\"\n    }\n\n    requirement R5 {\n        text = \"The system shall record scrapping or de-registration information when the vehicle reaches end-of-use.\"\n    }\n\n    requirement R6 {\n        text = \"The system shall support inquiry and traceability of all lifecycle-related data.\"\n    }\n\n    satisfies VehicleLifecycleSystem -> R1, R2, R3, R4, R5, R6;\n}",
    "package vehicle_model {\n\n    // Definition of Operational Status\n    part type OperationalStatus {\n        attribute gear_setting: integer;\n        attribute accelerator_pedal_position: real;\n    }\n\n    // Definition of Wheel\n    part type Wheel {\n        attribute id: string;\n        attribute status: string;\n    }\n\n    // Definition of Engine\n    part type Engine {\n        attribute status: string;\n    }\n\n    // Definition of Driver (external reference)\n    external part type Driver;\n\n    // Definition of Vehicle\n    part type Vehicle {\n        attribute mass: real;\n        attribute operational_status: OperationalStatus;\n        part engine: Engine;\n        part wheels: Wheel[2..*];\n        reference driver: Driver;\n    }\n\n    // Vehicle Instance: vehicle_1\n    part vehicle_1: Vehicle {\n        mass = 1500.0;\n        operational_status = OperationalStatus {\n            gear_setting = 1;\n            accelerator_pedal_position = 0.0;\n        };\n        engine = Engine {\n            status = \"off\";\n        };\n        wheels = [\n            Wheel {\n                id = \"left_front\";\n                status = \"idle\";\n            },\n            Wheel {\n                id = \"right_front\";\n                status = \"idle\";\n            }\n        ];\n        // driver reference to be bound externally\n    }\n\n    // Snapshots for tracking component status over time\n    snapshot vehicle_1_time1 {\n        vehicle_1.operational_status.gear_setting = 1;\n        vehicle_1.operational_status.accelerator_pedal_position = 0.0;\n        vehicle_1.engine.status = \"off\";\n        vehicle_1.wheels[0].status = \"idle\";\n        vehicle_1.wheels[1].status = \"idle\";\n    }\n\n    snapshot vehicle_1_time2 {\n        vehicle_1.operational_status.gear_setting = 2;\n        vehicle_1.operational_status.accelerator_pedal_position = 0.5;\n        vehicle_1.engine.status = \"on\";\n        vehicle_1.wheels[0].status = \"rotating\";\n        vehicle_1.wheels[1].status = \"rotating\";\n    }\n}",
    "package VehicleSystem {\n\n    part type Engine {\n        // Engine attributes and behaviors can be defined here\n    }\n\n    part type Driver {\n        // Driver attributes and behaviors can be defined here\n    }\n\n    part type Vehicle {\n        attribute mass: Real;\n        attribute state: VehicleState;\n        part engine: Engine;\n        part driver: Driver;\n    }\n\n    type VehicleState {\n        attribute gear: Integer;\n        attribute acceleratorPosition: Real;\n    }\n\n    part Vehicle_1: Vehicle {\n        // Initial state at t0\n        at t0 {\n            mass = 2000.0;\n            state = VehicleState {\n                gear = 0;\n                acceleratorPosition = 0.0;\n            };\n        }\n        // State at t1\n        at t1 {\n            mass = 1500.0;\n            state = VehicleState {\n                gear = 2;\n                acceleratorPosition = 0.5;\n            };\n        }\n    }\n\n    // Relationships among components\n    association VehicleHasEngine {\n        end vehicle: Vehicle;\n        end engine: Engine;\n    }\n\n    association VehicleHasDriver {\n        end vehicle: Vehicle;\n        end driver: Driver;\n    }\n}",
    "package VehicleModel {\n\n    // Define enumeration for GearPosition\n    enum GearPosition {\n        neutral,\n        first,\n        second,\n        third,\n        fourth,\n        fifth,\n        reverse\n    }\n\n    // Define Driver\n    part Driver {\n        attribute name: String;\n    }\n\n    // Define Engine\n    part Engine {\n        // Engine properties can be expanded as needed\n    }\n\n    // Define Vehicle State\n    state VehicleState {\n        attribute mass: Real; // kg\n        attribute gear: GearPosition;\n        attribute throttlePedalPosition: Real; // 0.0 to 1.0\n        reference driver: Driver;\n    }\n\n    // Define Vehicle\n    part Vehicle {\n        attribute currentState: VehicleState;\n        part engine: Engine;\n    }\n\n    // Define specific drivers\n    part Alice: Driver {\n        name = \"Alice\";\n    }\n    part Bob: Driver {\n        name = \"Bob\";\n    }\n\n    // Define time slices as snapshots of vehicle state\n    snapshot InitialState {\n        subject: Vehicle;\n        currentState.mass = 2000.0;\n        currentState.gear = GearPosition.neutral;\n        currentState.throttlePedalPosition = 0.0;\n        currentState.driver = Alice;\n    }\n\n    snapshot SecondState {\n        subject: Vehicle;\n        currentState.mass = 1500.0;\n        currentState.gear = GearPosition.second;\n        currentState.throttlePedalPosition = 0.5;\n        currentState.driver = Bob;\n    }\n\n}",
    "package VehicleMassAggregation {\n\n    import sysml::units;\n    import sysml::datatypes;\n\n    // Define Mass as a quantity kind\n    quantity kind Mass : units::kilogram;\n\n    // Abstract Component definition\n    abstract part definition Component {\n        attribute id: String;\n        attribute name: String;\n        attribute ownMass: Mass;\n        part subcomponents: Component[0..*];\n        attribute totalMass: Mass = ownMass + sum(subcomponents.totalMass);\n    }\n\n    // Engine as a specific component\n    part definition Engine extends Component {\n        // Additional engine-specific attributes can be added here\n    }\n\n    // Transmission as a specific component\n    part definition Transmission extends Component {\n        // Additional transmission-specific attributes can be added here\n    }\n\n    // Vehicle as a composite component\n    part definition Vehicle extends Component {\n        part engine: Engine;\n        part transmission: Transmission;\n        // Other vehicle-specific components can be added here\n    }\n\n    // Example instance of a vehicle\n    part Vehicle1: Vehicle {\n        id = \"V001\";\n        name = \"Sedan\";\n        ownMass = 800.0[units::kilogram];\n        engine = Engine1;\n        transmission = Transmission1;\n        subcomponents = {engine, transmission, Body1};\n    }\n\n    part Engine1: Engine {\n        id = \"E001\";\n        name = \"V6 Engine\";\n        ownMass = 180.0[units::kilogram];\n        subcomponents = {};\n    }\n\n    part Transmission1: Transmission {\n        id = \"T001\";\n        name = \"Automatic Transmission\";\n        ownMass = 90.0[units::kilogram];\n        subcomponents = {};\n    }\n\n    part Body1: Component {\n        id = \"B001\";\n        name = \"Vehicle Body\";\n        ownMass = 400.0[units::kilogram];\n        subcomponents = {};\n    }\n\n}",
    "package VehicleMassManagement {\n\n    import sysml::blocks;\n    import sysml::constraints;\n    import sysml::values;\n    import sysml::functions;\n\n    block Component {\n        attribute serialNumber: String;\n        attribute mass: Real;\n        part subcomponents: Component[*];\n    }\n\n    block Engine extends Component {\n        // Additional engine-specific attributes can be added here\n    }\n\n    block Transmission extends Component {\n        // Additional transmission-specific attributes can be added here\n    }\n\n    block Vehicle {\n        attribute VIN: String;\n        attribute mass: Real;\n        part engine: Engine;\n        part transmission: Transmission;\n        part components: Component[*];\n    }\n\n    constraint def TotalComponentMass(self: Component): Real {\n        self.mass + sum(self.subcomponents->map(c | TotalComponentMass(c)))\n    }\n\n    constraint def FilteredComponentMass(self: Component, threshold: Real): Real {\n        let filtered = self.subcomponents->select(c | c.mass >= threshold);\n        self.mass + sum(filtered->map(c | FilteredComponentMass(c, threshold)))\n    }\n\n    constraint def TotalVehicleMass(self: Vehicle): Real {\n        self.mass\n        + TotalComponentMass(self.engine)\n        + TotalComponentMass(self.transmission)\n        + sum(self.components->map(c | TotalComponentMass(c)))\n    }\n\n    constraint def FilteredVehicleMass(self: Vehicle, threshold: Real): Real {\n        self.mass\n        + FilteredComponentMass(self.engine, threshold)\n        + FilteredComponentMass(self.transmission, threshold)\n        + sum(self.components->map(c | FilteredComponentMass(c, threshold)))\n    }\n\n    // Example usage scenario\n    scenario MassInputAndSummary {\n        input vehicle: Vehicle;\n        input engineMass: Real;\n        input transmissionMass: Real;\n        input componentMasses: Real[*];\n        input threshold: Real;\n\n        // Assign input masses\n        vehicle.engine.mass := engineMass;\n        vehicle.transmission.mass := transmissionMass;\n        for i in 1..componentMasses->size() {\n            vehicle.components[i].mass := componentMasses[i];\n        }\n\n        output totalMass: Real = TotalVehicleMass(vehicle);\n        output filteredMass: Real = FilteredVehicleMass(vehicle, threshold);\n    }\n}",
    "package massAggregationSystem {\n\n    // Abstract definition for any object with mass\n    part definition MassObject {\n        attribute simpleMass: Real;\n        attribute totalMass: Real;\n    }\n\n    // Basic object: totalMass = simpleMass\n    part definition SimpleThing specializes MassObject {\n        constraint eq_totalMass: totalMass = simpleMass;\n    }\n\n    // Composite object: has subcomponents, totalMass = simpleMass + sum(subcomponents.totalMass)\n    part definition CompositeThing specializes MassObject {\n        part subcomponents: MassObject[*];\n        constraint eq_totalMass: totalMass = simpleMass + sum(subcomponents.totalMass);\n    }\n\n    // System context for quality aggregation management\n    part definition MassAggregationSystem {\n        part managedObjects: MassObject[*];\n    }\n}",
    "package MassManagementSystem {\n\n    // Requirement Definitions\n    requirement MassAggregation {\n        description \"The system shall aggregate and manage the mass of objects with mass attributes, including subcomponents.\"\n    }\n\n    requirement HierarchicalDecomposition {\n        description \"The system shall support hierarchical decomposition of objects and subcomponents.\"\n    }\n\n    requirement TotalMassCalculation {\n        description \"The system shall automatically calculate the total mass of an object, including all subcomponents.\"\n    }\n\n    requirement MassThresholdFiltering {\n        description \"The system shall support mass-based filtering and aggregation of components using a minimum mass threshold.\"\n    }\n\n    requirement FlexibleAggregation {\n        description \"The system shall enable flexible aggregation of mass information from different dimensions.\"\n    }\n\n    // Value Types\n    value type Mass {\n        unit = kilogram;\n        quantity kind = mass;\n    }\n\n    // Interface Blocks\n    interface block MassObject {\n        attribute basicMass: Mass;\n        part subcomponents: MassObject[0..*];\n        operation totalMass(): Mass;\n        operation filteredTotalMass(minMass: Mass): Mass;\n    }\n\n    // Constraint Definitions\n    constraint TotalMassComputation {\n        input self: MassObject;\n        output total: Mass;\n        let total = self.basicMass + sum(self.subcomponents->collect(sc | sc.totalMass()));\n    }\n\n    constraint FilteredTotalMassComputation {\n        input self: MassObject;\n        input minMass: Mass;\n        output total: Mass;\n        let total = self.basicMass + sum(self.subcomponents->select(sc | sc.basicMass >= minMass)->collect(sc | sc.filteredTotalMass(minMass)));\n    }\n\n    // Use Case\n    usecase AggregateMass {\n        description \"Aggregate and manage mass for hierarchical objects and subcomponents, supporting filtering and flexible aggregation.\"\n    }\n\n    // Satisfy Relationships\n    satisfy MassAggregation by MassObject;\n    satisfy HierarchicalDecomposition by MassObject;\n    satisfy TotalMassCalculation by TotalMassComputation;\n    satisfy MassThresholdFiltering by FilteredTotalMassComputation;\n    satisfy FlexibleAggregation by MassObject;\n\n}",
    "package VehicleDynamicsAnalysis {\n\n    requirement CalculateCoreParameters {\n        description \"The system shall calculate core vehicle dynamics parameters: power output, acceleration, speed, and position under various operating conditions.\"\n    }\n\n    requirement AccuratePowerCalculation {\n        description \"The system shall accurately calculate the vehicle’s actual available power output based on wheel power, aerodynamic drag coefficient, friction coefficient, vehicle mass, and speed.\"\n    }\n\n    requirement AccelerationComputation {\n        description \"The system shall deduce the vehicle’s acceleration based on effective power, mass, and current speed.\"\n    }\n\n    requirement SpeedCalculation {\n        description \"The system shall calculate the vehicle’s speed at any given moment using acceleration, initial speed, and time.\"\n    }\n\n    requirement DisplacementEstimation {\n        description \"The system shall estimate vehicle displacement based on speed and time.\"\n    }\n\n    requirement HighAccuracy {\n        description \"The system shall provide high accuracy in all calculations.\"\n    }\n\n    requirement ClearLogicalRelationships {\n        description \"The system shall maintain clear logical relationships between all parameters.\"\n    }\n\n    requirement EngineeringConvenience {\n        description \"The results shall be convenient for practical engineering applications.\"\n    }\n\n    interface VehicleDynamicsInputs {\n        in parameter wheelPower: Real;\n        in parameter aeroDragCoeff: Real;\n        in parameter frictionCoeff: Real;\n        in parameter vehicleMass: Real;\n        in parameter speed: Real;\n        in parameter initialSpeed: Real;\n        in parameter time: Real;\n    }\n\n    interface VehicleDynamicsOutputs {\n        out parameter availablePower: Real;\n        out parameter acceleration: Real;\n        out parameter currentSpeed: Real;\n        out parameter displacement: Real;\n    }\n\n    function calculateAvailablePower(\n        wheelPower: Real,\n        aeroDragCoeff: Real,\n        frictionCoeff: Real,\n        vehicleMass: Real,\n        speed: Real\n    ): Real;\n\n    function calculateAcceleration(\n        availablePower: Real,\n        vehicleMass: Real,\n        speed: Real\n    ): Real;\n\n    function calculateSpeed(\n        initialSpeed: Real,\n        acceleration: Real,\n        time: Real\n    ): Real;\n\n    function calculateDisplacement(\n        initialSpeed: Real,\n        acceleration: Real,\n        time: Real\n    ): Real;\n\n    part VehicleDynamicsSystem {\n        satisfies CalculateCoreParameters;\n        satisfies AccuratePowerCalculation;\n        satisfies AccelerationComputation;\n        satisfies SpeedCalculation;\n        satisfies DisplacementEstimation;\n        satisfies HighAccuracy;\n        satisfies ClearLogicalRelationships;\n        satisfies EngineeringConvenience;\n\n        uses VehicleDynamicsInputs;\n        uses VehicleDynamicsOutputs;\n\n        operation performVehicleDynamicsAnalysis(\n            in wheelPower: Real,\n            in aeroDragCoeff: Real,\n            in frictionCoeff: Real,\n            in vehicleMass: Real,\n            in speed: Real,\n            in initialSpeed: Real,\n            in time: Real\n        ) {\n            let availablePower = calculateAvailablePower(wheelPower, aeroDragCoeff, frictionCoeff, vehicleMass, speed);\n            let acceleration = calculateAcceleration(availablePower, vehicleMass, speed);\n            let currentSpeed = calculateSpeed(initialSpeed, acceleration, time);\n            let displacement = calculateDisplacement(initialSpeed, acceleration, time);\n        }\n    }\n}",
    "system VehicleStraightLineDynamics {\n\n    part vehicle: Vehicle;\n    part environment: Environment;\n    part simulation: SimulationController;\n\n    interface input {\n        in initialSpeed: Real; // m/s\n        in initialPosition: Real; // m\n        in timeStep: Real; // s\n        in totalMass: Real; // kg\n        in wheelEndPower: Real; // W\n        in aeroDragCoeff: Real; // dimensionless\n        in rollingResistCoeff: Real; // dimensionless\n        in frontalArea: Real; // m^2\n        in airDensity: Real; // kg/m^3\n    }\n\n    interface output {\n        out acceleration: Real; // m/s^2\n        out speed: Real; // m/s\n        out position: Real; // m\n        out drivingPower: Real; // W\n    }\n\n    constraint aerodynamicDragForce {\n        aerodynamicDrag = 0.5 * input.airDensity * input.frontalArea * input.aeroDragCoeff * speed^2;\n    }\n\n    constraint rollingResistanceForce {\n        rollingResistance = input.rollingResistCoeff * input.totalMass * 9.81;\n    }\n\n    constraint totalResistiveForce {\n        totalResistance = aerodynamicDrag + rollingResistance;\n    }\n\n    constraint drivingPowerAvailable {\n        drivingPower = input.wheelEndPower;\n    }\n\n    constraint accelerationCalculation {\n        acceleration = (drivingPower / speed - totalResistance) / input.totalMass;\n    }\n\n    constraint speedUpdate {\n        speed = previousSpeed + acceleration * input.timeStep;\n    }\n\n    constraint positionUpdate {\n        position = previousPosition + previousSpeed * input.timeStep + 0.5 * acceleration * input.timeStep^2;\n    }\n\n    requirement R1 {\n        description: \"The system shall allow users to set key parameters including initial speed, position, time step, mass, wheel-end power, aerodynamic drag coefficient, rolling resistance coefficient, frontal area, and air density.\";\n    }\n\n    requirement R2 {\n        description: \"The system shall compute acceleration, speed, and position at each time step considering aerodynamic drag and rolling resistance.\";\n    }\n\n    requirement R3 {\n        description: \"The system shall provide accurate physical modeling suitable for performance analysis, energy consumption simulation, and driving strategy optimization.\";\n    }\n\n}\n\nblock Vehicle {\n    attribute mass: Real;\n    attribute frontalArea: Real;\n    attribute aeroDragCoeff: Real;\n    attribute rollingResistCoeff: Real;\n}\n\nblock Environment {\n    attribute airDensity: Real;\n}\n\nblock SimulationController {\n    attribute timeStep: Real;\n    attribute initialSpeed: Real;\n    attribute initialPosition: Real;\n    attribute wheelEndPower: Real;\n}",
    "model VehicleDynamicsSimulation {\n\n    // Functional Requirements\n    requirement ComputeVehicleDynamics {\n        description: \"The system shall compute and update vehicle speed and position at each time step based on user input parameters and dynamic resistances.\"\n    }\n\n    requirement AcceptUserInputs {\n        description: \"The system shall accept user input parameters: vehicle mass, wheel power, aerodynamic drag coefficient, rolling resistance coefficient, initial speed, and initial position.\"\n    }\n\n    requirement AccountForResistances {\n        description: \"The system shall account for air resistance (aerodynamic drag) and frictional resistance (rolling resistance) in the vehicle dynamics computation.\"\n    }\n\n    requirement PredictDynamicStates {\n        description: \"The system shall predict vehicle velocity, acceleration, displacement, and other dynamic states over time.\"\n    }\n\n    requirement SupportPerformanceAnalysis {\n        description: \"The system shall assist end users in analyzing vehicle performance under different operating conditions.\"\n    }\n\n    // Non-Functional Requirements\n    requirement Automation {\n        description: \"The system shall automate the simulation and management of vehicle dynamics.\"\n    }\n\n    requirement Efficiency {\n        description: \"The system shall efficiently manage computational resources during simulation.\"\n    }\n\n    // User Inputs\n    interface UserInput {\n        in vehicleMass: Real;\n        in wheelPower: Real;\n        in dragCoefficient: Real;\n        in rollingResistanceCoefficient: Real;\n        in initialSpeed: Real;\n        in initialPosition: Real;\n    }\n\n    // Outputs\n    interface SimulationOutput {\n        out velocity: Real;\n        out acceleration: Real;\n        out position: Real;\n        out time: Real;\n    }\n\n    // Main System Block\n    part VehicleDynamicsSystem {\n        input: UserInput;\n        output: SimulationOutput;\n    }\n\n    // Internal States\n    state VehicleState {\n        speed: Real;\n        position: Real;\n        acceleration: Real;\n        time: Real;\n    }\n\n    // Behavior: Dynamics Computation\n    behavior ComputeDynamics {\n        input: UserInput;\n        inout: VehicleState;\n        output: SimulationOutput;\n\n        do {\n            // Pseudocode for dynamics computation\n            // At each time step:\n            // 1. Calculate total resistance force = aerodynamic drag + rolling resistance\n            // 2. Compute net force = (wheelPower / speed) - total resistance force\n            // 3. Compute acceleration = net force / vehicle mass\n            // 4. Update speed and position\n            // 5. Output updated states\n        }\n    }\n\n    // Relationships\n    VehicleDynamicsSystem {\n        uses ComputeDynamics;\n        exposes UserInput;\n        exposes SimulationOutput;\n    }\n\n    // Satisfy Requirements\n    ComputeDynamics satisfies ComputeVehicleDynamics;\n    VehicleDynamicsSystem satisfies AcceptUserInputs;\n    ComputeDynamics satisfies AccountForResistances;\n    ComputeDynamics satisfies PredictDynamicStates;\n    VehicleDynamicsSystem satisfies SupportPerformanceAnalysis;\n    VehicleDynamicsSystem satisfies Automation;\n    VehicleDynamicsSystem satisfies Efficiency;\n}",
    "system VehicleLongitudinalDynamics {\n\n    // Functional Requirements\n    requirement ProvideInitialConditions {\n        description: \"The system shall accept initial position, initial velocity, vehicle mass, wheel-end drive power, and time interval as user inputs.\"\n    }\n\n    requirement CalculateLongitudinalDynamics {\n        description: \"The system shall calculate acceleration, final velocity, and final position of the vehicle over the specified time interval.\"\n    }\n\n    requirement ConsiderResistances {\n        description: \"The system shall consider air resistance, frictional resistance, and other relevant resistances in the dynamic calculations.\"\n    }\n\n    requirement EnsurePhysicalConsistency {\n        description: \"The system shall ensure physical consistency and accuracy in the motion simulation.\"\n    }\n\n    // Non-Functional Requirements\n    requirement SuitabilityForLinearMotion {\n        description: \"The system shall be suitable for scenarios involving linear uniformly accelerated motion.\"\n    }\n\n    requirement SupportPerformanceEvaluation {\n        description: \"The system shall provide a computational basis for vehicle system dynamics modeling and performance evaluation.\"\n    }\n\n    // Parameters\n    parameter initialPosition: Real;\n    parameter initialVelocity: Real;\n    parameter vehicleMass: Real;\n    parameter drivePower: Real;\n    parameter timeInterval: Real;\n    parameter dragCoefficient: Real;\n    parameter frictionCoefficient: Real;\n    parameter airDensity: Real;\n    parameter frontalArea: Real;\n    parameter gravity: Real = 9.81;\n\n    // States\n    state position: Real;\n    state velocity: Real;\n    state acceleration: Real;\n\n    // Constraints\n    constraint AirResistance {\n        input v: Real;\n        output F_air: Real;\n        F_air = 0.5 * airDensity * dragCoefficient * frontalArea * v^2;\n    }\n\n    constraint FrictionResistance {\n        output F_friction: Real;\n        F_friction = frictionCoefficient * vehicleMass * gravity;\n    }\n\n    constraint NetForce {\n        input v: Real;\n        output F_net: Real;\n        F_drive = drivePower / max(v, 0.1); // Avoid division by zero\n        F_air = 0.5 * airDensity * dragCoefficient * frontalArea * v^2;\n        F_friction = frictionCoefficient * vehicleMass * gravity;\n        F_net = F_drive - F_air - F_friction;\n    }\n\n    constraint Acceleration {\n        input F_net: Real;\n        output a: Real;\n        a = F_net / vehicleMass;\n    }\n\n    constraint KinematicEquations {\n        input v0: Real;\n        input a: Real;\n        input t: Real;\n        output v1: Real;\n        output x1: Real;\n        v1 = v0 + a * t;\n        x1 = initialPosition + v0 * t + 0.5 * a * t^2;\n    }\n\n    // Behavior\n    action CalculateDynamics {\n        input initialPosition: Real;\n        input initialVelocity: Real;\n        input vehicleMass: Real;\n        input drivePower: Real;\n        input timeInterval: Real;\n        input dragCoefficient: Real;\n        input frictionCoefficient: Real;\n        input airDensity: Real;\n        input frontalArea: Real;\n        output acceleration: Real;\n        output finalVelocity: Real;\n        output finalPosition: Real;\n\n        // Step 1: Calculate resistances\n        let F_air = 0.5 * airDensity * dragCoefficient * frontalArea * initialVelocity^2;\n        let F_friction = frictionCoefficient * vehicleMass * gravity;\n\n        // Step 2: Calculate drive force\n        let F_drive = drivePower / max(initialVelocity, 0.1);\n\n        // Step 3: Net force and acceleration\n        let F_net = F_drive - F_air - F_friction;\n        let a = F_net / vehicleMass;\n\n        // Step 4: Kinematic equations\n        let v1 = initialVelocity + a * timeInterval;\n        let x1 = initialPosition + initialVelocity * timeInterval + 0.5 * a * timeInterval^2;\n\n        acceleration = a;\n        finalVelocity = v1;\n        finalPosition = x1;\n    }\n}",
    "package VehicleMassManagement {\n\n    requirement MaximumVehicleMass {\n        description \"The total mass of the vehicle must not exceed 2,500 kilograms.\"\n        constraint totalMass <= 2500 kg;\n    }\n\n    part Chassis {\n        attribute mass: Real[kg];\n    }\n\n    part Engine {\n        attribute mass: Real[kg];\n    }\n\n    part Gearbox {\n        attribute mass: Real[kg];\n    }\n\n    part Vehicle {\n        part chassis: Chassis;\n        part engine: Engine;\n        part gearbox: Gearbox;\n\n        attribute totalMass: Real[kg] = chassis.mass + engine.mass + gearbox.mass;\n    }\n\n    constraint OverweightWarning {\n        input totalMass: Real[kg];\n        output warning: Boolean;\n        expr warning = totalMass > 2500 kg;\n    }\n\n    satisfies VehicleSatisfiesMassRequirement {\n        subject vehicle: Vehicle;\n        requirement MaximumVehicleMass;\n        expr vehicle.totalMass <= 2500 kg;\n    }\n\n    usecase CalculateAndCheckVehicleMass {\n        input vehicle: Vehicle;\n        output warning: Boolean;\n        expr warning = vehicle.totalMass > 2500 kg;\n    }\n}",
    "package VehicleMassBudget {\n\n    requirement VehicleTotalMassLimit {\n        description \"The total mass of the complete vehicle, including chassis, engine, and transmission, shall not exceed 2,500 kilograms.\"\n        constraint totalMassConstraint {\n            input componentMasses: Real[];\n            output totalMass: Real;\n            totalMass = sum(componentMasses);\n            totalMass <= 2500.0;\n        }\n    }\n\n    requirement ComponentMassEntry {\n        description \"The actual mass of each major component (chassis, engine, transmission) shall be entered and measured in kilograms (kg).\"\n        constraint massUnitConstraint {\n            input componentMass: Real;\n            // All masses must be in kilograms\n            // (Assume unit enforcement in implementation)\n        }\n    }\n\n    requirement EngineAndTransmissionMassManagement {\n        description \"The masses of the engine and transmission shall be separately recorded and managed as critical components.\"\n        constraint engineTransmissionConstraint {\n            input engineMass: Real;\n            input transmissionMass: Real;\n            // Engine and transmission masses must be individually tracked\n        }\n    }\n\n    requirement CurbWeightControl {\n        description \"During preliminary design, the system shall control vehicle curb weight through mass constraints to support performance and energy optimization.\"\n        refine VehicleTotalMassLimit;\n        refine EngineAndTransmissionMassManagement;\n    }\n\n    part Vehicle {\n        part chassis: Component;\n        part engine: Engine;\n        part transmission: Transmission;\n        part otherComponents: Component[];\n    }\n\n    part Component {\n        attribute mass: Real;\n    }\n\n    part Engine extends Component {}\n    part Transmission extends Component {}\n\n    constraint block MassBudgeting {\n        input chassisMass: Real;\n        input engineMass: Real;\n        input transmissionMass: Real;\n        input otherComponentMasses: Real[];\n        output totalVehicleMass: Real;\n        totalVehicleMass = chassisMass + engineMass + transmissionMass + sum(otherComponentMasses);\n        totalVehicleMass <= 2500.0;\n    }\n\n    view VehicleMassSummary {\n        part vehicle: Vehicle;\n        attribute totalMass: Real = vehicle.chassis.mass + vehicle.engine.mass + vehicle.transmission.mass + sum(vehicle.otherComponents.mass);\n        attribute engineMass: Real = vehicle.engine.mass;\n        attribute transmissionMass: Real = vehicle.transmission.mass;\n    }\n}",
    "package VehicleMassCompliance {\n\n    part Vehicle {\n        part chassis: Chassis;\n        part engine: Engine;\n        part transmission: Transmission;\n    }\n\n    part Chassis {\n        attribute mass: Real;\n    }\n\n    part Engine {\n        attribute mass: Real;\n    }\n\n    part Transmission {\n        attribute mass: Real;\n    }\n\n    requirement VehicleMassLimit {\n        text \"The total mass of the vehicle (chassis, engine, transmission) shall not exceed 2,500 kilograms.\";\n    }\n\n    constraint VehicleTotalMassConstraint {\n        input chassis_mass: Real;\n        input engine_mass: Real;\n        input transmission_mass: Real;\n        output total_mass: Real;\n        output is_compliant: Boolean;\n        total_mass = chassis_mass + engine_mass + transmission_mass;\n        is_compliant = total_mass <= 2500.0;\n    }\n\n    satisfies VehicleMassLimit by VehicleTotalMassConstraint;\n\n    interface VehicleMassDataReceiver {\n        input chassis_mass: Real;\n        input engine_mass: Real;\n        input transmission_mass: Real;\n        output is_compliant: Boolean;\n    }\n\n    behavior VehicleMassVerification {\n        input chassis_mass: Real;\n        input engine_mass: Real;\n        input transmission_mass: Real;\n        output is_compliant: Boolean;\n        do {\n            let total_mass = chassis_mass + engine_mass + transmission_mass;\n            is_compliant = total_mass <= 2500.0;\n        }\n    }\n\n    VehicleMassDataReceiver implements VehicleMassVerification;\n\n    Vehicle {\n        chassis.mass -> VehicleMassDataReceiver.chassis_mass;\n        engine.mass -> VehicleMassDataReceiver.engine_mass;\n        transmission.mass -> VehicleMassDataReceiver.transmission_mass;\n    }\n\n}",
    "system VehicleWeightManagementSystem {\n\n    part chassis: Component\n    part engine: Component\n    part transmission: Component\n\n    property totalWeight: Mass\n    property weightLimit: Mass = 2500 kg\n\n    constraint SumOfComponentWeights {\n        totalWeight = chassis.weight + engine.weight + transmission.weight\n    }\n\n    constraint WeightLimitNotExceeded {\n        totalWeight <= weightLimit\n    }\n\n    requirement WeightLimitRequirement {\n        text \"The combined weight of the chassis, engine, and transmission shall not exceed 2,500 kilograms.\"\n        verify WeightLimitNotExceeded\n    }\n\n    requirement WeightRecordingRequirement {\n        text \"The system shall record and manage the weight of each main component (chassis, engine, transmission).\"\n    }\n\n    requirement WeightInputRequirement {\n        text \"The system shall require the weight data for the chassis, engine, and transmission as inputs.\"\n    }\n\n    requirement WeightSummationRequirement {\n        text \"The system shall automatically sum the weights of the chassis, engine, and transmission.\"\n        verify SumOfComponentWeights\n    }\n\n    requirement OverweightWarningRequirement {\n        text \"The system shall provide a warning or impose restrictions if the total weight exceeds 2,500 kilograms.\"\n    }\n\n    requirement ComplianceRequirement {\n        text \"The system shall ensure that the designed vehicle’s total weight complies with relevant regulatory requirements for legality, compliance, and safety.\"\n    }\n\n}\n\ncomponent Component {\n    property weight: Mass\n}",
    "package VehicleSystem {\n\n    part Vehicle {\n        part chassis: Chassis;\n        part engine: Engine;\n        part transmission: Transmission;\n\n        attribute totalMass: Real;\n        constraint totalMassCalculation {\n            totalMass = chassis.mass + engine.mass + transmission.mass;\n        }\n        constraint totalMassLimit {\n            totalMass <= 2500.0;\n        }\n    }\n\n    part Chassis {\n        attribute mass: Real;\n        constraint massPositive {\n            mass > 0.0;\n        }\n    }\n\n    part Engine {\n        attribute mass: Real;\n        constraint massPositive {\n            mass > 0.0;\n        }\n    }\n\n    part Transmission {\n        attribute mass: Real;\n        constraint massPositive {\n            mass > 0.0;\n        }\n    }\n\n    behavior VehicleDynamics {\n        input initialVelocity: Real;\n        input finalVelocity: Real;\n        input mass: Real;\n        input force: Real;\n        input time: Real;\n\n        constraint massPositive {\n            mass > 0.0;\n        }\n        constraint dynamicsEquation {\n            force * time = mass * (finalVelocity - initialVelocity);\n        }\n    }\n}",
    "system VehicleMaintenanceManager {\n\n    part vehicles: Vehicle[0..*];\n\n    requirement R1: \"Each vehicle shall have a specific next maintenance time, a fixed maintenance interval, and a maximum allowed temperature recorded.\";\n\n    requirement R2: \"The system shall automatically determine if a vehicle has reached its scheduled maintenance time.\";\n\n    requirement R3: \"When scheduled maintenance time is reached, the vehicle status shall switch to 'under maintenance'.\";\n\n    requirement R4: \"The actual maintenance start time shall be later than the scheduled maintenance time.\";\n\n    requirement R5: \"Maintenance must be initiated within 2 seconds after the previous healthy state ends.\";\n\n    requirement R6: \"The duration of maintenance shall not exceed 48 hours.\";\n\n    requirement R7: \"After maintenance completion, the next maintenance time shall be postponed according to the maintenance interval, and health status restored to normal.\";\n\n    state_machine VehicleMaintenanceSM for Vehicle {\n        state Healthy;\n        state UnderMaintenance;\n        transition ToMaintenance from Healthy to UnderMaintenance\n            when (now >= self.nextMaintenanceTime)\n            effect {\n                assert self.maintenanceStartTime > self.nextMaintenanceTime;\n                assert self.maintenanceStartTime - self.healthyEndTime <= 2[s];\n            };\n        transition ToHealthy from UnderMaintenance to Healthy\n            when (self.maintenanceComplete)\n            effect {\n                assert self.maintenanceDuration <= 48[h];\n                self.nextMaintenanceTime = self.nextMaintenanceTime + self.maintenanceInterval;\n                self.status = \"Healthy\";\n            };\n    }\n\n    interface Vehicle {\n        attribute nextMaintenanceTime: Time;\n        attribute maintenanceInterval: Duration;\n        attribute maxAllowedTemperature: Real;\n        attribute maintenanceStartTime: Time;\n        attribute healthyEndTime: Time;\n        attribute maintenanceDuration: Duration;\n        attribute maintenanceComplete: Boolean;\n        attribute status: String;\n    }\n}",
    "requirement MaximumVehicleMass {\n    description \"The total mass of the vehicle, including curb weight and fuel mass, must not exceed the specified maximum mass limit.\"\n    subject -> Vehicle\n    constraint {\n        Vehicle.totalMass <= Vehicle.maximumAllowedMass\n    }\n}\n\nrequirement PositiveFuelMass {\n    description \"The fuel mass must be a positive value.\"\n    subject -> Vehicle\n    constraint {\n        Vehicle.fuelMass > 0 kg\n    }\n}\n\nrequirement EngineTorqueCurve {\n    description \"The engine must generate torque according to the specified speed-torque curve.\"\n    subject -> Engine\n    constraint {\n        Engine.torque == Engine.torqueCurve(Engine.speed)\n    }\n}\n\nrequirement TorqueTransmission {\n    description \"The torque produced by the engine must be effectively transmitted to the transmission through the clutch interface.\"\n    subject -> [Engine, Clutch, Transmission]\n    constraint {\n        Clutch.inputTorque == Engine.torque\n        Transmission.inputTorque == Clutch.outputTorque\n    }\n}\n\nrequirement SmoothPowerDelivery {\n    description \"Power must be smoothly delivered to the vehicle’s drive system.\"\n    subject -> [Engine, Clutch, Transmission, DriveSystem]\n    constraint {\n        smooth(DriveSystem.inputPower)\n    }\n}",
    "package VehicleSystemRequirements {\n\n    requirement VehicleMassFullTank {\n        description: \"With a full fuel tank, the vehicle’s total mass must not exceed 2000 kg.\"\n        constraint: self.vehicle_total_mass_full_tank <= 2000 kg;\n    }\n\n    requirement VehicleMassEmptyTank {\n        description: \"With an empty fuel tank, the vehicle’s total mass must not exceed 1500 kg.\"\n        constraint: self.vehicle_total_mass_empty_tank <= 1500 kg;\n    }\n\n    requirement VehicleMassCalculation {\n        description: \"The sum of the vehicle’s dry mass and fuel mass must meet the maximum allowable mass under different operating conditions.\"\n        constraint: self.vehicle_total_mass_full_tank = self.vehicle_dry_mass + self.fuel_mass_full_tank;\n        constraint: self.vehicle_total_mass_empty_tank = self.vehicle_dry_mass;\n    }\n\n    requirement EngineTorqueTransmission {\n        description: \"The engine must be capable of transmitting its generated torque to the transmission via the clutch interface.\"\n        constraint: self.engine.torque_output = self.clutch.torque_input;\n        constraint: self.clutch.torque_output = self.transmission.torque_input;\n    }\n\n    requirement EnginePerformance {\n        description: \"The engine is required to deliver the necessary torque according to the speed-torque curve (see Table 1).\"\n        constraint: self.engine.torque_output = speed_torque_curve(self.engine.speed);\n    }\n\n    requirement PowertrainPerformance {\n        description: \"The system must regulate vehicle mass control, as well as the interface and performance of the powertrain, ensuring safety and effectiveness of power transmission.\"\n        refine: VehicleMassFullTank, VehicleMassEmptyTank, EngineTorqueTransmission, EnginePerformance;\n    }\n\n    part vehicle {\n        type: Vehicle;\n    }\n\n    part engine {\n        type: Engine;\n    }\n\n    part clutch {\n        type: Clutch;\n    }\n\n    part transmission {\n        type: Transmission;\n    }\n\n    part fuel_tank {\n        type: FuelTank;\n    }\n\n    part vehicle_dry_mass: Real;\n    part fuel_mass_full_tank: Real;\n    part vehicle_total_mass_full_tank: Real;\n    part vehicle_total_mass_empty_tank: Real;\n\n    function speed_torque_curve(speed: Real): Real;\n\n    relate engine.torque_output to clutch.torque_input;\n    relate clutch.torque_output to transmission.torque_input;\n\n}",
    "requirement VehicleMassLimits {\n    description: \"The vehicle's total mass must not exceed 2000 kg when fully fueled, and not exceed 1500 kg when empty.\"\n    subject: Vehicle\n    constraint: [\n        self.mass_when_fueled <= 2000 kg,\n        self.mass_when_empty <= 1500 kg\n    ]\n}\n\nrequirement EngineTorqueTransmission {\n    description: \"The engine must effectively transmit its generated torque to the transmission system through a clutch interface.\"\n    subject: Engine\n    constraint: [\n        self.torque_output -> ClutchInterface.input_torque,\n        ClutchInterface.output_torque -> Transmission.input_torque\n    ]\n}\n\nrequirement EngineTorquePerformance {\n    description: \"The torque generated by the engine should vary with speed, conforming to the relevant performance table specifications.\"\n    subject: Engine\n    constraint: [\n        forall(speed in EngineSpeedTable.speeds) {\n            self.torque_at(speed) == EnginePerformanceTable.torque_at(speed)\n        }\n    ]\n}\n\npart Vehicle {\n    attribute mass_when_fueled: Real [unit = kg];\n    attribute mass_when_empty: Real [unit = kg];\n    part engine: Engine;\n}\n\npart Engine {\n    attribute torque_output: Real [unit = Nm];\n    operation torque_at(speed: Real [unit = rpm]): Real [unit = Nm];\n    port ClutchInterface: TorquePort;\n}\n\npart Transmission {\n    port input_torque: TorquePort;\n}\n\ninterface TorquePort {\n    flow torque: Real [unit = Nm];\n}\n\ntable EnginePerformanceTable {\n    column speed: Real [unit = rpm];\n    column torque: Real [unit = Nm];\n}\n\ntable EngineSpeedTable {\n    column speeds: Real [unit = rpm];\n}\n\npart ClutchInterface {\n    port input_torque: TorquePort;\n    port output_torque: TorquePort;\n}",
    "requirement VehicleMassLimit {\n    description: \"The actual mass of the vehicle must not exceed specified limits under defined operating conditions.\"\n    criterion: \n        (for fuelTank.state == full) => (vehicle.curbMass + fuel.mass <= 2000 kg);\n        (for fuelTank.state == empty) => (vehicle.curbMass + fuel.mass <= 1500 kg);\n}\n\nrequirement TotalVehicleMassCalculation {\n    description: \"Total vehicle mass is defined as the sum of the vehicle’s curb mass and the fuel mass.\"\n    criterion: totalVehicleMass == vehicle.curbMass + fuel.mass;\n}\n\nrequirement EngineTorqueCapability {\n    description: \"The engine must be capable of generating the specified torque characteristics at various speeds.\"\n    criterion: engine.torqueProfile(speed) >= specifiedTorqueProfile(speed);\n}\n\nrequirement TorqueTransmissionToGearbox {\n    description: \"The generated engine torque must be effectively transmitted to the gearbox through the clutch interface to ensure smooth power delivery.\"\n    criterion: \n        clutch.transmits(engine.outputTorque) == true;\n        powerDelivery.smoothness >= specifiedSmoothnessThreshold;\n}\n\nrequirement ComplianceWithDesignAndSafety {\n    description: \"Vehicle mass control and power transmission must comply with design and safety standards.\"\n    criterion: \n        VehicleMassLimit.satisfied == true;\n        TorqueTransmissionToGearbox.satisfied == true;\n        conformsTo(designStandards);\n        conformsTo(safetyStandards);\n}",
    "package VehicleDynamicPerformanceAnalysis {\n\n    import sysml::standard;\n\n    part VehicleSystem {\n        attribute curbWeight: Mass;\n        attribute payload: Mass;\n        attribute wheelDiameter: Length;\n        attribute transmissionEfficiency: Real [0.0..1.0];\n        attribute fuelEconomyUrban: FuelEconomy;\n        attribute fuelEconomyHighway: FuelEconomy;\n        attribute configuration: VehicleConfiguration;\n    }\n\n    part VehicleConfiguration {\n        attribute curbWeight: Mass;\n        attribute payload: Mass;\n        attribute wheelDiameter: Length;\n        attribute transmissionEfficiency: Real [0.0..1.0];\n        attribute fuelEconomyUrban: FuelEconomy;\n        attribute fuelEconomyHighway: FuelEconomy;\n    }\n\n    part DrivingCycle {\n        attribute timeSeries: TimeSeries;\n        attribute positionSeries: PositionSeries;\n        attribute speedSeries: SpeedSeries;\n    }\n\n    part TimeSeries {\n        attribute times: List<Time>;\n    }\n\n    part PositionSeries {\n        attribute positions: List<Length>;\n    }\n\n    part SpeedSeries {\n        attribute speeds: List<Speed>;\n    }\n\n    part DynamicPerformanceAnalyzer {\n        reference vehicle: VehicleSystem;\n        reference drivingCycle: DrivingCycle;\n\n        operation calculatePowerDemand(): Power;\n        operation calculateAcceleration(): AccelerationSeries;\n        operation calculateSpeed(): SpeedSeries;\n        operation calculatePosition(): PositionSeries;\n        operation calculateFuelEconomy(): FuelEconomy;\n        operation verifyCompliance(target: EnergyConsumptionTarget): ComplianceResult;\n    }\n\n    part EnergyConsumptionTarget {\n        attribute fuelConsumptionPer100km: FuelConsumption;\n        attribute milesPerGallon: FuelEconomy;\n    }\n\n    part ComplianceResult {\n        attribute isCompliant: Boolean;\n        attribute details: String;\n    }\n\n    part UserInterface {\n        operation setVehicleAttributes(configuration: VehicleConfiguration);\n        operation setDrivingCycle(drivingCycle: DrivingCycle);\n        operation analyzePerformance(): AnalysisReport;\n        operation checkCompliance(target: EnergyConsumptionTarget): ComplianceResult;\n    }\n\n    part AnalysisReport {\n        attribute powerDemandSeries: List<Power>;\n        attribute accelerationSeries: List<Acceleration>;\n        attribute speedSeries: List<Speed>;\n        attribute positionSeries: List<Length>;\n        attribute fuelEconomy: FuelEconomy;\n    }\n\n    requirement R1_PerformanceModeling {\n        text \"The system shall model and calculate power demand, acceleration, speed, and position variations over time during straight-line driving.\"\n    }\n\n    requirement R2_VehicleAttributesConfig {\n        text \"The system shall allow users to set vehicle attributes including curb weight, payload, wheel diameter, transmission efficiency, and fuel economy under urban and highway conditions.\"\n    }\n\n    requirement R3_DrivingCycleInput {\n        text \"The system shall allow users to input driving cycles with time-stamped position and speed information.\"\n    }\n\n    requirement R4_FuelEconomyCalculation {\n        text \"The system shall calculate the vehicle’s fuel economy throughout the entire driving cycle.\"\n    }\n\n    requirement R5_ComplianceVerification {\n        text \"The system shall support compliance verification based on specified energy consumption targets (e.g., fuel consumption per 100 kilometers or miles per gallon).\"\n    }\n\n    requirement R6_ConfigurationOptions {\n        text \"The system shall provide adjustable configuration options for vehicle parameters and drive cycle scenarios.\"\n    }\n\n    requirement R7_DataSupport {\n        text \"The system shall provide data support and decision-making references for vehicle design optimization and achievement of energy consumption targets.\"\n    }\n\n    satisfies VehicleSystem -> R2_VehicleAttributesConfig;\n    satisfies DrivingCycle -> R3_DrivingCycleInput;\n    satisfies DynamicPerformanceAnalyzer -> R1_PerformanceModeling;\n    satisfies DynamicPerformanceAnalyzer -> R4_FuelEconomyCalculation;\n    satisfies DynamicPerformanceAnalyzer -> R5_ComplianceVerification;\n    satisfies UserInterface -> R6_ConfigurationOptions;\n    satisfies UserInterface -> R7_DataSupport;\n\n}",
    "package VehicleFuelEconomySimulationAnalysis {\n\n    requirement FuelEconomyRequirement {\n        description: \"The vehicle must achieve fuel economy exceeding 30 miles per gallon under both urban and highway driving scenarios.\"\n        criterion: fuelEconomy > 30 [mi/gal]\n    }\n\n    requirement RegulatoryCompliance {\n        description: \"The vehicle must comply with energy-saving and emissions reduction regulations in real-world scenarios.\"\n    }\n\n    scenario UrbanDrivingScenario {\n        description: \"Simulate urban driving with variable speed and stop-go conditions.\"\n        input: drivingTrajectory, speedProfile\n    }\n\n    scenario HighwayDrivingScenario {\n        description: \"Simulate highway driving with steady and high-speed conditions.\"\n        input: drivingTrajectory, speedProfile\n    }\n\n    interface VehicleParameters {\n        in curbWeight: mass\n        in load: mass\n        in wheelDiameter: length\n        in transmissionEfficiency: ratio\n        in dragCoefficient: real\n        in frontalArea: area\n        in rollingResistanceCoefficient: real\n        in engineEfficiency: ratio\n        in fuelEnergyDensity: energy_per_mass\n    }\n\n    function CalculateWheelPower {\n        in speed: velocity\n        in acceleration: acceleration\n        in vehicleParams: VehicleParameters\n        out wheelPower: power\n        body: \"Apply vehicle dynamics equations to compute required wheel power.\"\n    }\n\n    function CalculateEnginePowerDemand {\n        in wheelPower: power\n        in transmissionEfficiency: ratio\n        out enginePower: power\n        body: \"Estimate engine power demand based on wheel power and transmission efficiency.\"\n    }\n\n    function CalculateFuelConsumption {\n        in enginePower: power\n        in engineEfficiency: ratio\n        in fuelEnergyDensity: energy_per_mass\n        in time: duration\n        out fuelConsumed: mass\n        body: \"Compute fuel consumption from engine power, efficiency, and fuel energy density over time.\"\n    }\n\n    function CalculateFuelEconomy {\n        in distance: length\n        in fuelConsumed: mass\n        out fuelEconomy_mpg: real\n        out fuelEconomy_L_per_100km: real\n        body: \"Convert fuel consumption and distance to miles per gallon and liters per 100 kilometers.\"\n    }\n\n    analysis FuelEconomySimulation {\n        input: scenario: {UrbanDrivingScenario, HighwayDrivingScenario}\n        input: vehicleParams: VehicleParameters\n        output: fuelEconomy_mpg: real\n        output: fuelEconomy_L_per_100km: real\n        output: meetsRequirement: boolean\n        step {\n            wheelPower = CalculateWheelPower(scenario.speedProfile, scenario.drivingTrajectory.acceleration, vehicleParams)\n            enginePower = CalculateEnginePowerDemand(wheelPower, vehicleParams.transmissionEfficiency)\n            fuelConsumed = CalculateFuelConsumption(enginePower, vehicleParams.engineEfficiency, vehicleParams.fuelEnergyDensity, scenario.drivingTrajectory.time)\n            (fuelEconomy_mpg, fuelEconomy_L_per_100km) = CalculateFuelEconomy(scenario.drivingTrajectory.distance, fuelConsumed)\n            meetsRequirement = fuelEconomy_mpg > 30\n        }\n    }\n\n    verification FuelEconomyVerification {\n        verify FuelEconomyRequirement by FuelEconomySimulation\n        verify RegulatoryCompliance by FuelEconomySimulation\n    }\n}",
    "package EngineSelectionAnalysis {\n\n    // Define key performance indicators\n    value definition Power {\n        type: Real;\n        unit: \"kW\";\n        description: \"Engine power output\";\n    }\n\n    value definition Mass {\n        type: Real;\n        unit: \"kg\";\n        description: \"Engine mass\";\n    }\n\n    value definition Efficiency {\n        type: Real;\n        unit: \"percent\";\n        description: \"Engine efficiency\";\n    }\n\n    value definition Cost {\n        type: Real;\n        unit: \"USD\";\n        description: \"Engine cost\";\n    }\n\n    // Engine type enumeration\n    enum EngineType {\n        FourCylinder,\n        SixCylinder\n    }\n\n    // Engine candidate definition\n    part definition EngineCandidate {\n        attribute engineType: EngineType;\n        attribute power: Power;\n        attribute mass: Mass;\n        attribute efficiency: Efficiency;\n        attribute cost: Cost;\n    }\n\n    // Aggregation and calculation of KPIs\n    action definition AggregateKPIs {\n        in candidates: EngineCandidate[];\n        out aggregatedKPIs: AggregatedKPIs[];\n    }\n\n    // Aggregated KPI structure\n    part definition AggregatedKPIs {\n        attribute engineType: EngineType;\n        attribute totalPower: Power;\n        attribute totalMass: Mass;\n        attribute averageEfficiency: Efficiency;\n        attribute totalCost: Cost;\n    }\n\n    // Unified evaluation function\n    value definition EvaluationScore {\n        type: Real;\n        description: \"Comprehensive evaluation score for engine selection\";\n    }\n\n    function definition EvaluateEngine {\n        in kpis: AggregatedKPIs;\n        out score: EvaluationScore;\n        // The function implementation is domain-specific and not shown here\n    }\n\n    // Engine selection process\n    action definition SelectOptimalEngine {\n        in candidates: EngineCandidate[];\n        out optimalEngine: EngineCandidate;\n        // The action implementation is domain-specific and not shown here\n    }\n\n    // System definition\n    part definition EngineSelectionSystem {\n        attribute candidates: EngineCandidate[];\n        attribute optimalEngine: EngineCandidate;\n        action aggregateKPIs: AggregateKPIs;\n        action selectOptimalEngine: SelectOptimalEngine;\n    }\n\n    // Non-functional requirements\n    requirement definition MaximizePerformance {\n        text: \"The system shall maximize engine performance based on power and efficiency.\";\n    }\n\n    requirement definition MaximizeEconomicEfficiency {\n        text: \"The system shall maximize economic efficiency by minimizing cost.\";\n    }\n\n    requirement definition AutomaticRecommendation {\n        text: \"The system shall automatically recommend the optimal engine based on comprehensive evaluation.\";\n    }\n}",
    "package VehicleWeightCheck {\n\n    requirement CurbWeightLimit {\n        description \"The curb weight of each vehicle must be less than or equal to 2,500 kilograms.\"\n        constraint [curbWeight <= 2500 kg]\n    }\n\n    requirement DataCollection {\n        description \"The system shall collect the actual weight data of the vehicle.\"\n    }\n\n    requirement DataProcessing {\n        description \"The system shall process the collected weight data.\"\n    }\n\n    requirement WeightEvaluation {\n        description \"The system shall evaluate the processed data to determine if the vehicle meets the curb weight standard and produce a qualified or unqualified result.\"\n    }\n\n    activity VehicleCurbWeightCheck {\n        step collectWeightData: action \"Collect actual weight data of the vehicle.\"\n        step processWeightData: action \"Process the collected weight data.\"\n        step evaluateWeight: action \"Evaluate processed data against curb weight standard.\"\n        step outputResult: action \"Output qualified or unqualified evaluation result.\"\n        flow collectWeightData -> processWeightData -> evaluateWeight -> outputResult\n    }\n\n    interface VehicleWeightData {\n        out actualWeight: Real [kg]\n        out processedWeight: Real [kg]\n        out evaluationResult: Enumeration {Qualified, Unqualified}\n    }\n\n    part VehicleWeightCheckSystem {\n        activityRef: VehicleCurbWeightCheck\n        satisfies CurbWeightLimit\n        satisfies DataCollection\n        satisfies DataProcessing\n        satisfies WeightEvaluation\n        port weightData: VehicleWeightData\n    }\n}",
    "package VehicleMassVerification {\n\n    import ScalarValues::*;\n    import Units::*;\n    import StandardDataTypes::*;\n\n    part Vehicle {\n        attribute mass: Mass;\n    }\n\n    part WeighingEquipment {\n        operation measure_mass(vehicle: Vehicle): Mass;\n    }\n\n    part MassVerificationUnit {\n        operation verify_mass(vehicle: Vehicle, measured_mass: Mass): VerificationResult;\n    }\n\n    enum VerificationResult {\n        Qualified,\n        Unqualified\n    }\n\n    requirement MassLimit {\n        text \"The mass of each vehicle shall not exceed 2,500 kilograms.\";\n        constraint mass_limit: vehicle.mass <= 2500 kg;\n    }\n\n    requirement IndependentVerification {\n        text \"The mass verification process shall be carried out independently for each vehicle.\";\n    }\n\n    requirement Compliance {\n        text \"All vehicles involved in verification shall comply with relevant standards and regulatory requirements.\";\n    }\n\n    function MassVerificationProcess(vehicle: Vehicle): VerificationResult {\n        measured_mass = WeighingEquipment.measure_mass(vehicle);\n        result = MassVerificationUnit.verify_mass(vehicle, measured_mass);\n        return result;\n    }\n\n    constraint MassVerificationLogic {\n        context MassVerificationUnit::verify_mass(vehicle: Vehicle, measured_mass: Mass)\n        body:\n            if measured_mass <= 2500 kg then\n                return VerificationResult::Qualified;\n            else\n                return VerificationResult::Unqualified;\n    }\n\n    usecase VerifyVehicleMass {\n        input vehicle: Vehicle;\n        output result: VerificationResult;\n        scenario:\n            result = MassVerificationProcess(vehicle);\n    }\n\n}",
    "system TransportationSystem {\n    \n    part driver: Person;\n    part passengers: Person[0..4];\n    part vehicle: Vehicle;\n\n    requirement functional ProvideTransportation {\n        description: \"The system shall provide convenient and efficient transportation for end users.\"\n    }\n\n    requirement functional SupportMultipleOccupants {\n        description: \"The system shall support a driver and up to four passengers sharing a vehicle.\"\n    }\n\n    requirement functional EnableEntryExit {\n        description: \"The system shall allow users to freely enter and exit the vehicle in a simple and smooth manner.\"\n    }\n\n    requirement functional CompleteJourney {\n        description: \"The system shall enable users to travel from a starting point to a destination.\"\n    }\n\n    requirement functional IntegrateEnvironmentalFactors {\n        description: \"The system shall consider and integrate surrounding environmental factors to ensure safety and sustainability.\"\n    }\n\n    requirement functional InfrastructureCompatibility {\n        description: \"The system shall be compatible with related infrastructure such as gas stations.\"\n    }\n\n    requirement nonfunctional Safety {\n        description: \"The system shall ensure the safety of all occupants throughout the journey.\"\n    }\n\n    requirement nonfunctional Comfort {\n        description: \"The system shall provide a comfortable ride experience for all occupants.\"\n    }\n\n    requirement nonfunctional HumanCenteredOperation {\n        description: \"The system’s operation shall be centered on human needs, focusing on ride experience and convenience.\"\n    }\n\n    requirement nonfunctional Sustainability {\n        description: \"The system shall ensure sustainability during operation.\"\n    }\n\n    requirement nonfunctional Convenience {\n        description: \"The system shall assist passengers and drivers in smoothly completing daily transportation tasks.\"\n    }\n\n    satisfies ProvideTransportation;\n    satisfies SupportMultipleOccupants;\n    satisfies EnableEntryExit;\n    satisfies CompleteJourney;\n    satisfies IntegrateEnvironmentalFactors;\n    satisfies InfrastructureCompatibility;\n    satisfies Safety;\n    satisfies Comfort;\n    satisfies HumanCenteredOperation;\n    satisfies Sustainability;\n    satisfies Convenience;\n}",
    "system TransportationSystem {\n    \n    part vehicle: Vehicle;\n    part driver: Person;\n    part passengers: Person[0..4];\n    part environment: Environment;\n    part gasStation: GasStation;\n\n    requirement SafeTransport {\n        description: \"The system shall safely transport a driver and up to four passengers from the starting point to the destination.\"\n    }\n\n    requirement SimpleConvenientInteraction {\n        description: \"The system shall ensure that interactions among all participants are simple and convenient.\"\n    }\n\n    requirement DailyTransportationNeeds {\n        description: \"The system shall meet the primary needs of daily transportation.\"\n    }\n\n    scenario TransportationProcess {\n        step enterVehicle {\n            action: driver and passengers enter vehicle;\n        }\n        step operateVehicle {\n            action: driver operates vehicle under influence of environment;\n        }\n        step refuelIfNeeded {\n            condition: vehicle.fuelLevel < vehicle.fuelThreshold;\n            action: driver refuels vehicle at gasStation;\n        }\n        step arriveAtDestination {\n            action: vehicle arrives at destination;\n        }\n        step exitVehicle {\n            action: driver and passengers exit vehicle;\n        }\n    }\n}\n\nblock Vehicle {\n    property fuelLevel: Real;\n    property fuelThreshold: Real = 10.0;\n    property occupancy: Integer[0..5];\n}\n\nblock Person {\n    property role: String; // \"driver\" or \"passenger\"\n}\n\nblock Environment {\n    property conditions: String;\n}\n\nblock GasStation {\n    property location: String;\n}",
    "package VehicleProductLine {\n\n    part Vehicle {\n        attribute engine: Engine;\n        attribute transmission: Transmission;\n\n        constraint validCombination {\n            (engine.type == EngineType.FourCylinder and transmission.type == TransmissionType.Manual)\n            or\n            (engine.type == EngineType.FourCylinder and transmission.type == TransmissionType.Automatic)\n            or\n            (engine.type == EngineType.SixCylinder and transmission.type == TransmissionType.Automatic)\n        }\n        constraint manualOnlyWithFourCylinder {\n            transmission.type == TransmissionType.Manual implies engine.type == EngineType.FourCylinder\n        }\n        constraint sixCylinderOnlyWithAutomatic {\n            engine.type == EngineType.SixCylinder implies transmission.type == TransmissionType.Automatic\n        }\n    }\n\n    part Engine {\n        attribute type: EngineType;\n        attribute cylinders: Cylinder[1..*];\n\n        constraint correctCylinderCount {\n            (type == EngineType.FourCylinder and cylinders->size() == 4)\n            or\n            (type == EngineType.SixCylinder and cylinders->size() == 6)\n        }\n    }\n\n    enum EngineType {\n        FourCylinder,\n        SixCylinder\n    }\n\n    part Cylinder {\n        attribute diameter: CylinderDiameter;\n    }\n\n    enum CylinderDiameter {\n        Small,   // 70 mm\n        Large    // 100 mm\n    }\n\n    part Transmission {\n        attribute type: TransmissionType;\n    }\n\n    enum TransmissionType {\n        Manual,\n        Automatic\n    }\n}",
    "package EngineConfigurable {\n\n    part type Cylinder {\n        attribute diameter: Real;\n    }\n\n    part type Engine {\n        attribute numCylinders: Integer;\n        part cylinders: Cylinder [numCylinders];\n    }\n\n    constraint CylinderDiameterAllowed {\n        context Cylinder\n        assert diameter == 70.0 or diameter == 100.0;\n    }\n\n    constraint EngineCylinderCountAllowed {\n        context Engine\n        assert numCylinders == 4 or numCylinders == 6;\n    }\n\n    variant FourCylinderEngine specializes Engine {\n        numCylinders = 4;\n    }\n\n    variant SixCylinderEngine specializes Engine {\n        numCylinders = 6;\n    }\n\n    usecase ConfigureEngine {\n        description \"User selects engine variant (4 or 6 cylinders) and cylinder diameter (70 mm or 100 mm) for each cylinder to adjust performance and size.\"\n    }\n}",
    "package automotiveConfigSpace {\n\n    // Engine abstract definition\n    abstract part Engine {\n        attribute cylinderCount: Integer;\n        attribute cylinderDiameter: Integer; // in mm\n    }\n\n    // 4-cylinder engine specialization\n    part FourCylinderEngine specializes Engine {\n        cylinderCount = 4;\n        attribute cylinderDiameter: Integer; // 70 or 100\n    }\n\n    // 6-cylinder engine specialization\n    part SixCylinderEngine specializes Engine {\n        cylinderCount = 6;\n        attribute cylinderDiameter: Integer; // 70 or 100\n    }\n\n    // Transmission abstract definition\n    abstract part Transmission {\n    }\n\n    // Manual transmission specialization\n    part ManualTransmission specializes Transmission {\n    }\n\n    // Automatic transmission specialization\n    part AutomaticTransmission specializes Transmission {\n    }\n\n    // Vehicle configuration\n    part Vehicle {\n        attribute selectedCylinderDiameter: Integer; // 70 or 100\n\n        // Only one engine and one transmission per vehicle\n        part engine: Engine;\n        part transmission: Transmission;\n\n        // Constraint: Cylinder diameter must be 70 or 100\n        constraint cylinderDiameterSpec {\n            (selectedCylinderDiameter = 70) or (selectedCylinderDiameter = 100)\n        }\n\n        // Constraint: Engine's cylinder diameter matches selected\n        constraint engineCylinderDiameterMatch {\n            engine.cylinderDiameter = selectedCylinderDiameter\n        }\n\n        // Constraint: Only one engine type can be selected\n        constraint oneEngineType {\n            (engine isa FourCylinderEngine) xor (engine isa SixCylinderEngine)\n        }\n\n        // Constraint: Only one transmission type can be selected\n        constraint oneTransmissionType {\n            (transmission isa ManualTransmission) xor (transmission isa AutomaticTransmission)\n        }\n\n        // Constraint: Engine and transmission compatibility\n        constraint engineTransmissionCompatibility {\n            ((engine isa FourCylinderEngine) and (transmission isa ManualTransmission)) or\n            ((engine isa SixCylinderEngine) and (transmission isa AutomaticTransmission))\n        }\n    }\n}",
    "system SystemAssembly {\n    part computer: ComputerSubsystem;\n    part storage: StorageSubsystem;\n    part software: SoftwareDesign;\n\n    constraint seamless_integration {\n        computer.integrates(software.allFunctions);\n        storage.accesses(software.messageFormat, software.dataFormat);\n        computer.hardware.software_compatible(software);\n        storage.hardware.software_compatible(software);\n    }\n\n    constraint efficient_reliable_compliant {\n        information_storage.efficiency >= required_efficiency;\n        information_transmission.reliability >= required_reliability;\n        information_processing.compliance == data_structure_specifications;\n    }\n}\n\nblock ComputerSubsystem {\n    part hardware: ComputerHardware;\n    part software: ComputerSoftware;\n\n    constraint utilizes_software_functions {\n        software.implements(allFunctions from parent.software);\n    }\n}\n\nblock StorageSubsystem {\n    part hardware: StorageHardware;\n    part software: StorageSoftware;\n\n    constraint compatible_with_formats {\n        software.supports(parent.software.messageFormat, parent.software.dataFormat);\n        hardware.supports(parent.software.messageFormat, parent.software.dataFormat);\n    }\n}\n\nblock SoftwareDesign {\n    attribute messageFormat: MessageFormat;\n    attribute dataFormat: DataFormat;\n    attribute allFunctions: FunctionSet;\n}\n\nblock MessageFormat {\n    attribute structure: StructureSpec;\n    attribute encoding: EncodingSpec;\n}\n\nblock DataFormat {\n    attribute schema: SchemaSpec;\n    attribute validationRules: ValidationRuleSet;\n}\n\nblock ComputerHardware {\n    constraint supports_software {\n        supports(parent.parent.software.allFunctions);\n    }\n}\n\nblock ComputerSoftware {\n    constraint implements_functions {\n        implements(parent.parent.software.allFunctions);\n    }\n}\n\nblock StorageHardware {\n    constraint supports_formats {\n        supports(parent.parent.software.messageFormat, parent.parent.software.dataFormat);\n    }\n}\n\nblock StorageSoftware {\n    constraint supports_formats {\n        supports(parent.parent.software.messageFormat, parent.parent.software.dataFormat);\n    }\n}\n\nflow information_storage: InformationFlow;\nflow information_transmission: InformationFlow;\nflow information_processing: InformationFlow;\n\nrequirement required_efficiency {\n    text \"The system shall store, transmit, and process information with efficiency as specified in the data structure specifications.\";\n}\n\nrequirement required_reliability {\n    text \"The system shall ensure reliable information storage, transmission, and processing.\";\n}\n\nrequirement data_structure_specifications {\n    text \"The system shall comply with the required data structure specifications for all information flows.\";\n}",
    "system PowertrainSystem {\n    part logicalLayer : LogicalLayer;\n    part physicalLayer : PhysicalLayer;\n\n    requirement EfficientAllocationAndManagement {\n        description \"The system shall achieve efficient allocation and management of the powertrain system.\"\n    }\n\n    requirement FunctionalMapping {\n        description \"The torque generator in the logical layer shall be effectively mapped to the corresponding power unit in the physical layer.\"\n    }\n\n    requirement PowerAndTorqueCapabilities {\n        description \"The system shall provide power transmission and torque output capabilities to meet user demands for power performance.\"\n    }\n\n    satisfies EfficientAllocationAndManagement;\n    satisfies FunctionalMapping;\n    satisfies PowerAndTorqueCapabilities;\n}\n\nblock LogicalLayer {\n    part torqueGenerator : TorqueGenerator;\n    // Additional logical components can be added here\n}\n\nblock TorqueGenerator {\n    operation providePower();\n    operation generateTorque();\n    operation convertPowerToTorque();\n}\n\nblock PhysicalLayer {\n    part powerUnit : PowerUnit;\n    // Additional physical components can be added here\n}\n\nblock PowerUnit {\n    operation outputPower();\n    operation generateTorque();\n}\n\nmapping TorqueGeneratorToPowerUnit {\n    from logicalLayer.torqueGenerator;\n    to physicalLayer.powerUnit;\n    rationale \"Ensures that logical torque generation is realized in physical hardware.\"\n    satisfies FunctionalMapping;\n}\n\nallocation TorqueToPowerUnitAllocation {\n    from logicalLayer.torqueGenerator;\n    to physicalLayer.powerUnit;\n    rationale \"Allocates logical torque generation functions to the physical power unit.\"\n}\n\nconstraint PowerAndTorqueRealization {\n    assert physicalLayer.powerUnit.generateTorque() == logicalLayer.torqueGenerator.generateTorque();\n    assert physicalLayer.powerUnit.outputPower() == logicalLayer.torqueGenerator.providePower();\n}",
    "system PowerTransmissionSystem {\n    feature outputPower: flow[power];\n    feature outputTorque: flow[torque];\n\n    requirement ProvidePower {\n        description: \"The system shall provide power output for vehicle operation.\";\n    }\n\n    requirement GenerateTorque {\n        description: \"The system shall generate torque for vehicle operation.\";\n    }\n\n    capability DeliverPower {\n        satisfies ProvidePower;\n        output: outputPower;\n    }\n\n    capability GenerateTorqueCapability {\n        satisfies GenerateTorque;\n        output: outputTorque;\n    }\n\n    part logical {\n        part torqueGenerator: TorqueGenerator;\n    }\n\n    part physical {\n        part powertrain: Powertrain;\n    }\n\n    allocate logical.torqueGenerator to physical.powertrain;\n}\n\nblock TorqueGenerator {\n    action generateTorque {\n        output: torque: torque;\n    }\n}\n\nblock Powertrain {\n    part engine: Engine;\n}\n\nblock Engine {\n    action generateTorque {\n        output: torque: torque;\n    }\n}\n\nallocate PowerTransmissionSystem.logical.torqueGenerator.generateTorque to PowerTransmissionSystem.physical.powertrain.engine.generateTorque;",
    "package VehicleFeatureAnnotationSystem {\n\n    part Vehicle {\n        part interior: InteriorAssembly;\n        part body: BodyAssembly;\n    }\n\n    part InteriorAssembly {\n        part seatBelts: SeatBelt[2..*];\n        part frontSeats: FrontSeat[2];\n        part driverAirbag: DriverAirbag;\n        part alarmSystem: AntiTheftAlarm;\n    }\n\n    part BodyAssembly {\n        part bodyShell: BodyShell;\n        part bumpers: Bumper[2];\n        part keylessEntry: KeylessEntryDevice;\n    }\n\n    part SeatBelt {\n        attribute location: String;\n        satisfies SafetyRequirement;\n    }\n\n    part FrontSeat {\n        attribute position: String;\n    }\n\n    part DriverAirbag {\n        satisfies SafetyRequirement;\n    }\n\n    part AntiTheftAlarm {\n        satisfies SecurityRequirement;\n    }\n\n    part BodyShell {\n        satisfies SafetyRequirement;\n    }\n\n    part Bumper {\n        attribute position: String;\n        satisfies SafetyRequirement;\n    }\n\n    part KeylessEntryDevice {\n        satisfies SecurityRequirement;\n        satisfies ConvenienceRequirement;\n    }\n\n    requirement SafetyRequirement {\n        description = \"Provides occupant protection in the event of a collision.\";\n    }\n\n    requirement SecurityRequirement {\n        description = \"Prevents unauthorized access and theft of the vehicle.\";\n    }\n\n    requirement ConvenienceRequirement {\n        description = \"Enhances user convenience for vehicle access.\";\n    }\n\n    allocation {\n        Vehicle.interior.seatBelts -> SafetyRequirement;\n        Vehicle.interior.driverAirbag -> SafetyRequirement;\n        Vehicle.body.bumpers -> SafetyRequirement;\n        Vehicle.body.bodyShell -> SafetyRequirement;\n        Vehicle.interior.alarmSystem -> SecurityRequirement;\n        Vehicle.body.keylessEntry -> SecurityRequirement;\n        Vehicle.body.keylessEntry -> ConvenienceRequirement;\n    }\n}",
    "system VehicleDynamicsSimulationSystem {\n    \n    part vehicle: Vehicle\n    part userInterface: UserInterface\n    part modelCenterIntegration: ModelCenterIntegration\n    part simulationEngine: SimulationEngine\n\n    requirement AutomatedSimulationAndAnalysis {\n        text \"The system shall be capable of performing automated simulation and analysis of vehicle dynamic behavior.\"\n    }\n\n    requirement UserInputParameters {\n        text \"Users should be able to input the vehicle’s initial velocity, initial position, acceleration at a specific moment, and the time step.\"\n    }\n\n    requirement ModelCenterIntegration {\n        text \"Through integration with the ModelCenter analysis tool, the system shall automatically calculate and output the vehicle’s velocity and position after the specified time step based on the given physical model.\"\n    }\n\n    requirement AccurateDataTransfer {\n        text \"The system must ensure accurate data transfer and reliable output of simulation results.\"\n    }\n\n    requirement ConvenientParameterOutput {\n        text \"The system shall enable users to conveniently obtain key dynamic parameters to support vehicle performance analysis and design optimization.\"\n    }\n\n    satisfies AutomatedSimulationAndAnalysis\n    satisfies UserInputParameters\n    satisfies ModelCenterIntegration\n    satisfies AccurateDataTransfer\n    satisfies ConvenientParameterOutput\n\n    interface SimulationInput {\n        in initialVelocity: Real\n        in initialPosition: Real\n        in acceleration: Real\n        in timeStep: Real\n    }\n\n    interface SimulationOutput {\n        out finalVelocity: Real\n        out finalPosition: Real\n    }\n\n    part simulationSession: SimulationSession {\n        uses SimulationInput\n        uses SimulationOutput\n    }\n\n    constraint VehicleKinematics {\n        input initialVelocity: Real\n        input initialPosition: Real\n        input acceleration: Real\n        input timeStep: Real\n        output finalVelocity: Real\n        output finalPosition: Real\n\n        finalVelocity = initialVelocity + acceleration * timeStep;\n        finalPosition = initialPosition + initialVelocity * timeStep + 0.5 * acceleration * timeStep^2;\n    }\n\n    simulationSession.VehicleKinematics(initialVelocity, initialPosition, acceleration, timeStep, finalVelocity, finalPosition)\n\n    allocate simulationSession to simulationEngine\n    allocate simulationEngine to modelCenterIntegration\n    allocate userInterface to simulationSession\n\n}\n\nblock Vehicle {\n    attribute mass: Real\n    attribute model: String\n}\n\nblock UserInterface {\n    operation getUserInput(): SimulationInput\n    operation displayResults(output: SimulationOutput)\n}\n\nblock ModelCenterIntegration {\n    operation transferData(input: SimulationInput): Boolean\n    operation receiveResults(): SimulationOutput\n}\n\nblock SimulationEngine {\n    operation runSimulation(input: SimulationInput): SimulationOutput\n}\n\nblock SimulationSession {\n    uses SimulationInput\n    uses SimulationOutput\n}",
    "package SafetyFeatures {\n    part SeatBelt @Safety {\n        multiplicity: 2;\n        isMandatory: true;\n    }\n    part Airbag @Safety {\n        isMandatory: false;\n        location: \"driver\";\n    }\n    part Bumper @Safety {\n        isMandatory: true;\n        location: \"body\";\n    }\n    part ABS @Safety {\n        isMandatory: false;\n        location: \"wheelAssembly\";\n    }\n}\n\npackage MandatorySafetyFeatures {\n    import SafetyFeatures.SeatBelt;\n    import SafetyFeatures.Bumper;\n}\n\npackage Car {\n    part interior {\n        part seatBelts: SafetyFeatures.SeatBelt[2];\n        part airbag: SafetyFeatures.Airbag?;\n    }\n    part body {\n        part bumper: SafetyFeatures.Bumper;\n        part keylessEntrySystem {\n            isMandatory: false;\n        }\n    }\n    part wheelAssembly {\n        part wheels {\n            multiplicity: 2;\n        }\n        part abs: SafetyFeatures.ABS?;\n    }\n}",
    "package VehicleSafetyCompliance {\n\n    part Vehicle {\n        part interior: Interior\n        part body: Body\n        part chassis: Chassis\n        part safetyManager: SafetyManager\n    }\n\n    part Interior {\n        part seatBelt1: SeatBelt\n        part seatBelt2: SeatBelt\n        // Both seat belts are required safety features\n    }\n\n    part Body {\n        part bumper: Bumper\n        [mandatory]\n        part keylessEntrySystem: KeylessEntrySystem\n        [optional]\n    }\n\n    part Chassis {\n        part tires: Tire[4]\n        // Number of tires is fixed\n        part abs: ABS\n        [optional]\n    }\n\n    part SeatBelt {\n        feature safetyFeature: SafetyFeature\n        [mandatory]\n    }\n\n    part Bumper {\n        feature safetyFeature: SafetyFeature\n        [mandatory]\n    }\n\n    part KeylessEntrySystem {\n        feature safetyFeature: SafetyFeature\n        [optional]\n    }\n\n    part ABS {\n        feature safetyFeature: SafetyFeature\n        [optional]\n    }\n\n    part Airbag {\n        feature safetyFeature: SafetyFeature\n        [optional]\n    }\n\n    part SafetyManager {\n        part requiredSafetyFeatures: SafetyFeature[0..*]\n        part optionalSafetyFeatures: SafetyFeature[0..*]\n        constraint manageSafetyFeatures {\n            // All required safety features must be present in the vehicle\n            forall (feature in requiredSafetyFeatures) {\n                Vehicle.hasFeature(feature)\n            }\n        }\n        constraint categorizeSafetyFeatures {\n            // Distinguish between mandatory and optional safety features\n            requiredSafetyFeatures = {\n                Interior.seatBelt1.safetyFeature,\n                Interior.seatBelt2.safetyFeature,\n                Body.bumper.safetyFeature\n            }\n            optionalSafetyFeatures = {\n                Body.keylessEntrySystem.safetyFeature,\n                Chassis.abs.safetyFeature,\n                Airbag.safetyFeature\n            }\n        }\n    }\n\n    part SafetyFeature {\n        attribute isMandatory: Boolean\n        attribute complianceStandard: String\n    }\n\n    part Tire {\n        // Tire is not a safety feature per se, but is a fixed part of chassis\n    }\n\n    // Airbag is optional and only for driver\n    part DriverAirbag: Airbag\n\n}",
    "package RiskAndFailureManagementSystem {\n\n    // Functional Requirements\n    requirement IdentifySituations {\n        description: \"The system shall identify and describe various possible situations relevant to risks and failures.\"\n    }\n\n    requirement RecordCauses {\n        description: \"The system shall record the causes leading to the occurrence of each situation.\"\n    }\n\n    requirement RecordProbability {\n        description: \"The system shall record the probability of each cause.\"\n    }\n\n    requirement RecordFailures {\n        description: \"The system shall identify and describe potential failures resulting from situations.\"\n    }\n\n    requirement RecordSeverity {\n        description: \"The system shall record the severity level of each failure.\"\n    }\n\n    requirement EstablishCausalRelationships {\n        description: \"The system shall establish and analyze causal relationships among situations, causes, and failures.\"\n    }\n\n    requirement ModelRiskScenarios {\n        description: \"The system shall support comprehensive modeling of different risk scenarios.\"\n    }\n\n    requirement EvaluateAndManageRisks {\n        description: \"The system shall enable users to evaluate and manage potential risks and failures.\"\n    }\n\n    requirement SupportDecisionMaking {\n        description: \"The system shall provide a basis for risk control and decision-making.\"\n    }\n\n    // Non-Functional Requirements\n    requirement ComprehensiveModeling {\n        description: \"The system shall provide all-round and comprehensive risk scenario modeling capabilities.\"\n    }\n\n    requirement Usability {\n        description: \"The system shall be user-friendly to facilitate risk evaluation and management.\"\n    }\n\n    // Domain Concepts\n    type Situation {\n        description: \"A possible state or event relevant to risk or failure.\"\n        attribute description: String;\n    }\n\n    type Cause {\n        description: \"A factor that may lead to the occurrence of a situation.\"\n        attribute description: String;\n        attribute probability: Real;\n    }\n\n    type Failure {\n        description: \"A potential failure resulting from a situation.\"\n        attribute description: String;\n        attribute severity: Integer;\n    }\n\n    type RiskScenario {\n        description: \"A comprehensive model of a risk situation, including causes and failures.\"\n        attribute name: String;\n        part situations: Situation[0..*];\n        part causes: Cause[0..*];\n        part failures: Failure[0..*];\n        association causalRelationships: CausalRelationship[0..*];\n    }\n\n    type CausalRelationship {\n        description: \"Represents a causal link between a cause, a situation, and a failure.\"\n        reference cause: Cause;\n        reference situation: Situation;\n        reference failure: Failure;\n    }\n\n    // Use Cases\n    usecase IdentifyAndDescribeSituations {\n        description: \"User identifies and describes possible situations.\"\n    }\n\n    usecase RecordCauseProbability {\n        description: \"User records the probability of each cause.\"\n    }\n\n    usecase RecordFailureSeverity {\n        description: \"User records the severity level of each failure.\"\n    }\n\n    usecase AnalyzeCausalRelationships {\n        description: \"User analyzes the sequence and impact mechanisms among situations, causes, and failures.\"\n    }\n\n    usecase ModelRiskScenario {\n        description: \"User models a comprehensive risk scenario.\"\n    }\n\n    usecase EvaluateAndManageRisk {\n        description: \"User evaluates and manages potential risks and failures.\"\n    }\n\n    // Relationships\n    satisfies IdentifySituations -> IdentifyAndDescribeSituations;\n    satisfies RecordCauses -> IdentifyAndDescribeSituations;\n    satisfies RecordProbability -> RecordCauseProbability;\n    satisfies RecordFailures -> IdentifyAndDescribeSituations;\n    satisfies RecordSeverity -> RecordFailureSeverity;\n    satisfies EstablishCausalRelationships -> AnalyzeCausalRelationships;\n    satisfies ModelRiskScenarios -> ModelRiskScenario;\n    satisfies EvaluateAndManageRisks -> EvaluateAndManageRisk;\n    satisfies SupportDecisionMaking -> EvaluateAndManageRisk;\n    satisfies ComprehensiveModeling -> ModelRiskScenario;\n    satisfies Usability -> EvaluateAndManageRisk;\n\n}",
    "package RiskMetadataManagement {\n\n    import sysml::standard;\n\n    // Fundamental Concepts\n\n    concept Scenario {\n        description: String;\n        causes: set of Cause;\n        failures: set of Failure;\n        relatedScenarios: set of Scenario;\n    }\n\n    concept Cause {\n        description: String;\n        probability: Real[0.0..1.0];\n    }\n\n    concept Failure {\n        description: String;\n        severity: SeverityLevel;\n    }\n\n    enum SeverityLevel {\n        Minor,\n        Moderate,\n        Major,\n        Critical\n    }\n\n    // Causal Relationship between Scenarios\n\n    association ScenarioCausalRelation {\n        source: Scenario;\n        target: Scenario;\n        description: String;\n    }\n\n    // Risk Scenario: Combination of Scenarios, Causes, Failures\n\n    concept RiskScenario {\n        scenarios: set of Scenario;\n        causes: set of Cause;\n        failures: set of Failure;\n        description: String;\n    }\n\n    // System Metadata for Integration\n\n    concept RiskMetadata {\n        riskScenarios: set of RiskScenario;\n        scenarios: set of Scenario;\n        causes: set of Cause;\n        failures: set of Failure;\n        conformsTo: set of String; // e.g., references to modeling language standards\n    }\n\n    // Example Usage\n\n    instance ExampleCause1: Cause {\n        description = \"Component overheating\";\n        probability = 0.15;\n    }\n\n    instance ExampleFailure1: Failure {\n        description = \"System shutdown\";\n        severity = SeverityLevel::Major;\n    }\n\n    instance ExampleScenario1: Scenario {\n        description = \"High load operation\";\n        causes = { ExampleCause1 };\n        failures = { ExampleFailure1 };\n        relatedScenarios = {};\n    }\n\n    instance ExampleRiskScenario1: RiskScenario {\n        scenarios = { ExampleScenario1 };\n        causes = { ExampleCause1 };\n        failures = { ExampleFailure1 };\n        description = \"Risk of shutdown due to overheating during high load\";\n    }\n\n    instance RiskMetadataInstance: RiskMetadata {\n        riskScenarios = { ExampleRiskScenario1 };\n        scenarios = { ExampleScenario1 };\n        causes = { ExampleCause1 };\n        failures = { ExampleFailure1 };\n        conformsTo = { \"SysMLv2\", \"ISO 31000\" };\n    }\n}",
    "system EquipmentRiskAnalysis {\n\n    part battery: Battery;\n\n    requirement continuous_battery_monitoring {\n        text \"The system shall continuously monitor the battery level during operation.\"\n    }\n\n    requirement detect_battery_aging {\n        text \"The system shall detect increased probability of battery failure due to aging or other factors.\"\n    }\n\n    requirement identify_risk_battery_aging {\n        text \"The system shall identify the risk that battery aging may lead to low battery level.\"\n    }\n\n    requirement low_battery_detection {\n        text \"The system shall determine when the battery level falls below the minimum threshold and identify the 'low battery' state.\"\n    }\n\n    requirement prolonged_low_battery_analysis {\n        text \"The system shall analyze situations where the low battery state persists for a prolonged period without recovery.\"\n    }\n\n    requirement automatic_shutdown_on_prolonged_low_battery {\n        text \"If the low battery state persists, the device may automatically shut down, resulting in the failure consequence of 'device shutdown.'\"\n    }\n\n    requirement assign_severity_level {\n        text \"For high-level failures that may interrupt critical device functions, the system shall assign an appropriate severity level to alert users and maintenance personnel.\"\n    }\n\n    requirement timely_intervention {\n        text \"The system shall enable timely intervention to mitigate potential risks and ensure reliable operation and normal usage needs.\"\n    }\n\n    state_machine BatteryMonitoringSM {\n        state NormalOperation;\n        state LowBattery;\n        state ProlongedLowBattery;\n        state DeviceShutdown;\n\n        transition NormalOperation -> LowBattery {\n            trigger: battery.level < battery.minimum_threshold;\n            effect: set_state(LowBattery);\n        }\n\n        transition LowBattery -> ProlongedLowBattery {\n            trigger: duration_in_state(LowBattery) > allowed_duration;\n            effect: set_state(ProlongedLowBattery);\n        }\n\n        transition ProlongedLowBattery -> DeviceShutdown {\n            trigger: not battery.level_recovered;\n            effect: shutdown_device();\n        }\n\n        transition LowBattery -> NormalOperation {\n            trigger: battery.level >= battery.minimum_threshold;\n            effect: set_state(NormalOperation);\n        }\n    }\n\n    risk BatteryAgingRisk {\n        source: battery.aging;\n        consequence: LowBattery;\n        description: \"Battery aging increases the probability of low battery level.\"\n    }\n\n    failure LowBattery {\n        cause: BatteryAgingRisk;\n        effect: \"Device may enter low battery state.\"\n        severity: assign_severity_level;\n    }\n\n    failure DeviceShutdown {\n        cause: LowBattery;\n        effect: \"Device automatically shuts down due to prolonged low battery.\"\n        severity: \"High\";\n    }\n\n    interface Battery {\n        attribute level: Real;\n        attribute minimum_threshold: Real;\n        attribute aging: Boolean;\n        attribute level_recovered: Boolean;\n    }\n\n    attribute allowed_duration: Duration;\n}",
    "system System\n{\n    part subsystems: Subsystem[1..*];\n}\n\npart Subsystem\n{\n    part components: Component[1..*];\n    interface subsystemInterface;\n    satisfies SubsystemFunctionality;\n}\n\npart Component\n{\n    interface componentInterface;\n    satisfies ComponentFunctionality;\n}\n\ninterface subsystemInterface\n{\n    inout data: SubsystemData;\n}\n\ninterface componentInterface\n{\n    inout data: ComponentData;\n}\n\nrequirement SystemStructuralDecomposition\n{\n    text \"The system shall be decomposed into multiple subsystems and components in a top-down hierarchical structure, ensuring full coverage of functions and capabilities at each level.\";\n}\n\nrequirement InterfaceDefinition\n{\n    text \"Interfaces between system components shall be well defined to enable independent understanding, analysis, and effective collaboration.\";\n}\n\nrequirement StructuralViewForIVV\n{\n    text \"The structural view shall enable system engineers and IV&V parties to comprehend, verify, and validate the system’s integrity and modular design, ensuring all functional and performance requirements are met.\";\n}\n\nfunction SubsystemFunctionality\n{\n    text \"Defines the required functions and capabilities for each subsystem.\";\n}\n\nfunction ComponentFunctionality\n{\n    text \"Defines the required functions and capabilities for each component.\";\n}\n\ntype SubsystemData\n{\n    // Define data exchanged at subsystem level\n}\n\ntype ComponentData\n{\n    // Define data exchanged at component level\n}\n\nsatisfy SystemStructuralDecomposition by System;\nsatisfy InterfaceDefinition by Subsystem, Component;\nsatisfy StructuralViewForIVV by System;",
    "// Root System Definition\nsystem AutomotiveSystem {\n    part body: Body\n    part powertrain: Powertrain\n    part chassis: Chassis\n    part interior: Interior\n    part electronics: Electronics\n}\n\n// Subsystem Definitions\nblock Body {\n    part frontBumper: Bumper\n    part rearBumper: Bumper\n    part doors: Door[4]\n    part roof: Roof\n}\n\nblock Powertrain {\n    part engine: Engine\n    part transmission: Transmission\n    part fuelSystem: FuelSystem\n}\n\nblock Chassis {\n    part wheels: Wheel[4]\n    part suspension: Suspension\n    part brakes: Brakes\n}\n\nblock Interior {\n    part seats: Seat[5]\n    part seatBelts: SeatBelt[5]\n    part dashboard: Dashboard\n    part steeringWheel: SteeringWheel\n    part driverAirbag: DriverAirbag?\n}\n\nblock Electronics {\n    part abs: ABS?\n    part infotainment: InfotainmentSystem\n    part lighting: LightingSystem\n}\n\n// Component Definitions\nblock Bumper {\n    attribute safety: SafetyAttribute = mandatory\n}\n\nblock SeatBelt {\n    attribute safety: SafetyAttribute = mandatory\n}\n\nblock DriverAirbag {\n    attribute safety: SafetyAttribute = optional\n}\n\nblock ABS {\n    attribute safety: SafetyAttribute = optional\n}\n\nblock Door {}\nblock Roof {}\nblock Engine {}\nblock Transmission {}\nblock FuelSystem {}\nblock Wheel {}\nblock Suspension {}\nblock Brakes {}\nblock Seat {}\nblock Dashboard {}\nblock SteeringWheel {}\nblock InfotainmentSystem {}\nblock LightingSystem {}\n\n// Safety Attribute Enumeration\nenum SafetyAttribute {\n    mandatory\n    optional\n}\n\n// Interface Definitions\ninterface ICrashProtection {}\ninterface IBrakingControl {}\ninterface IRestraintSystem {}\n\n// Interface Usage\nBumper implements ICrashProtection\nSeatBelt implements IRestraintSystem\nDriverAirbag implements IRestraintSystem\nABS implements IBrakingControl\n\n// Views\n\n// Hierarchical Structure Tree View\nview AutomotiveSystem_Hierarchy {\n    tree AutomotiveSystem\n}\n\n// Safety Components Table View\nview SafetyComponents_Table {\n    table {\n        column Component\n        column SafetyAttribute\n        row { \"frontBumper\", \"mandatory\" }\n        row { \"rearBumper\", \"mandatory\" }\n        row { \"seatBelts\", \"mandatory\" }\n        row { \"driverAirbag\", \"optional\" }\n        row { \"abs\", \"optional\" }\n    }\n}\n\n// Non-Safety Components Table View\nview NonSafetyComponents_Table {\n    table {\n        column Component\n        row { \"doors\" }\n        row { \"roof\" }\n        row { \"engine\" }\n        row { \"transmission\" }\n        row { \"fuelSystem\" }\n        row { \"wheels\" }\n        row { \"suspension\" }\n        row { \"brakes\" }\n        row { \"seats\" }\n        row { \"dashboard\" }\n        row { \"steeringWheel\" }\n        row { \"infotainment\" }\n        row { \"lighting\" }\n    }\n}",
    "// Automotive Domain Standard Model\npackage automotive_domain {\n\n    // Fundamental concept: Automobile\n    part Automobile {\n        // Alias for communication in various scenarios\n        alias: \"汽车 (Car)\";\n        // Explanatory comment\n        annotation: \"Represents a motor vehicle designed for road use, typically having four wheels and powered by an internal combustion engine or electric motor. Core component in the automotive domain.\";\n    }\n\n    // Physical Quantity: Torque\n    quantity Torque {\n        // Alias for clarity\n        alias: \"扭矩 (Torque)\";\n        // Explanatory comment\n        annotation: \"A measure of the rotational force applied to the automobile's drivetrain, typically expressed in Newton-meters (Nm). Essential for characterizing vehicle performance.\";\n        unit: \"N·m\";\n    }\n\n    // Association: Automobile has Torque as a characteristic\n    relation Automobile_has_Torque {\n        from: Automobile;\n        to: Torque;\n        annotation: \"Associates the automobile with its torque characteristic, enabling standardized expression of performance attributes.\";\n    }\n\n    // Non-functional requirements\n    annotation: \"The model is designed for clarity, extensibility, and ease of integration, supporting development and maintenance of automotive-related systems. Comprehensive comments and standardized aliases facilitate understanding and communication among developers and users.\";\n}",
    "package AutomobileDocumentManagementPlatform {\n\n    // Core object: Automobile, with alias Car\n    type Automobile {\n        alias: Car;\n        description: \"Represents an automobile; core object for documentation and information management.\";\n    }\n\n    // Physical quantity system compatibility (e.g., ISQ standard)\n    import isq::TorqueValue;\n    import isq::*; // Import all ISQ standard physical quantities\n\n    // Document object, can be explanatory or technical\n    type Document {\n        description: \"A document associated with an Automobile or its alias, providing explanatory or technical information.\";\n        property content: String;\n        property author: String;\n        property createdDate: DateTime;\n        property lastModifiedDate: DateTime;\n        property relatedTo: Automobile;\n        property documentType: DocumentType;\n    }\n\n    enum DocumentType {\n        Explanatory;\n        Technical;\n        Specification;\n        Archive;\n        Other;\n    }\n\n    // User object\n    type User {\n        description: \"A user of the platform who can enter, query, and archive information.\";\n        property userId: String;\n        property name: String;\n        property role: UserRole;\n    }\n\n    enum UserRole {\n        Admin;\n        Editor;\n        Viewer;\n    }\n\n    // Functional requirements as actions\n    action EnterAutomobileInformation {\n        input automobile: Automobile;\n        input document: Document;\n        input user: User;\n        output confirmation: Boolean;\n        description: \"Allows a user to enter information and documentation about an automobile.\";\n    }\n\n    action QueryAutomobileInformation {\n        input searchTerm: String;\n        input user: User;\n        output results: Set<Automobile>;\n        description: \"Allows a user to query information and documentation using Automobile or its alias Car.\";\n    }\n\n    action ArchiveAutomobileInformation {\n        input automobile: Automobile;\n        input document: Document;\n        input user: User;\n        output confirmation: Boolean;\n        description: \"Allows a user to archive information and documentation about an automobile.\";\n    }\n\n    // Non-functional requirements as constraints\n    constraint PhysicalQuantityStandardCompatibility {\n        description: \"All physical quantities referenced in documentation must comply with ISQ standards (e.g., TorqueValue).\";\n    }\n\n    constraint AliasSupport {\n        description: \"The system must support 'Car' as an alias for 'Automobile' for flexible search and operation.\";\n    }\n\n    constraint DocumentationTraceability {\n        description: \"All documents and their associations must be clearly annotated and traceable.\";\n    }\n\n    constraint ProfessionalismAccuracy {\n        description: \"Documentation must support unified referencing and management of professional physical quantities.\";\n    }\n}",
    "import scalar_physical_quantities::TorqueValue;\nimport scalar_physical_quantities::*;\n\n// Automobile domain model\ntype Automobile {\n    // Properties specific to an automobile\n    torque: TorqueValue;\n}\n\n// Alias for Automobile\nalias Car = Automobile;\n\n// Alias for TorqueValue\nalias Torque = TorqueValue;\n\n// System context for managing automobile information\nsystem AutomobileInformationManagementSystem {\n    automobiles: set of Automobile;\n}",
    "package VehicleSystem {\n\n    part Vehicle {\n        attribute size: Size;\n        part engine: Engine;\n    }\n\n    enum Size {\n        Small,\n        Standard,\n        Large\n    }\n\n    part Engine {\n        attribute cylinderCount: Integer;\n        part[1..*] cylinder: Cylinder;\n    }\n\n    part Cylinder {}\n\n    constraint StandardVehicleCylinderCount {\n        context Vehicle v\n        if v.size == Size::Standard then\n            v.engine.cylinderCount >= 4 and v.engine.cylinderCount <= 6\n        endif\n    }\n\n    constraint SmallVehicleCylinderCount {\n        context Vehicle v\n        if v.size == Size::Small then\n            v.engine.cylinderCount == 4\n        endif\n    }\n\n    constraint LargeVehicleCylinderCount {\n        context Vehicle v\n        if v.size == Size::Large then\n            v.engine.cylinderCount == 6\n        endif\n    }\n\n    constraint EngineCylinderConfiguration {\n        context Engine e\n        e.cylinderCount == size(e.cylinder)\n    }\n\n    constraint VehicleEngineCylinderAutoConfig {\n        context Vehicle v\n        if v.size == Size::Small then\n            v.engine.cylinderCount == 4\n        else if v.size == Size::Large then\n            v.engine.cylinderCount == 6\n        else if v.size == Size::Standard then\n            v.engine.cylinderCount >= 4 and v.engine.cylinderCount <= 6\n        endif\n    }\n}",
    "System FuelManagementSystem {\n    \n    part fuelTank: FuelTank;\n    part engine: Engine;\n    part fuelSupplyInterface: FuelInterface;\n    part fuelReturnInterface: FuelInterface;\n\n    requirement manageFuelFlow {\n        text \"The system shall be capable of managing fuel flow, ensuring that fuel can be delivered from the fuel tank to the engine and supporting fuel return.\";\n    }\n\n    requirement monitorManageFuelTemperature {\n        text \"During operation, the system shall monitor and manage the temperature of the fuel.\";\n    }\n\n    requirement realizeFuelSupplyReturn {\n        text \"The system shall realize fuel supply and return through fuel interfaces.\";\n    }\n\n    requirement standardizedInterfaces {\n        text \"The fuel tank and the engine shall be connected via standardized fuel interfaces to ensure the reliability and safety of fuel flow.\";\n    }\n\n    interface FuelInterface {\n        inout fuel: Fuel;\n        inout temperature: Temperature;\n    }\n\n    part fuelFlowController: FuelFlowController;\n\n    connection supplyConnection: FuelConnection {\n        from fuelTank.fuelOut;\n        to engine.fuelIn;\n        via fuelSupplyInterface;\n    }\n\n    connection returnConnection: FuelConnection {\n        from engine.fuelReturnOut;\n        to fuelTank.fuelReturnIn;\n        via fuelReturnInterface;\n    }\n\n    constraint ensureReliabilitySafety {\n        text \"Fuel interfaces shall be standardized to ensure reliability and safety of fuel flow.\";\n    }\n}\n\nblock FuelTank {\n    port fuelOut: FuelInterface;\n    port fuelReturnIn: FuelInterface;\n}\n\nblock Engine {\n    port fuelIn: FuelInterface;\n    port fuelReturnOut: FuelInterface;\n}\n\nblock FuelFlowController {\n    reference fuelTank: FuelTank;\n    reference engine: Engine;\n\n    operation monitorFuelTemperature();\n    operation manageFuelFlow();\n}\n\ntype Fuel;\ntype Temperature;\n\nassociation FuelConnection {\n    end source: FuelInterface;\n    end target: FuelInterface;\n}",
    "package VehicleStructuralArchitecture {\n\n    part Vehicle {\n        attribute mass: Real; // kg\n\n        part frontAxleAssembly: AxleAssembly;\n        part rearAxleAssembly: AxleAssembly;\n    }\n\n    part AxleAssembly {\n        part axle: Axle;\n        part leftWheel: Wheel;\n        part rightWheel: Wheel;\n    }\n\n    part Axle {}\n\n    part FrontAxle extends Axle {\n        attribute steeringAngle: Real; // degrees\n    }\n\n    part Wheel {}\n\n    // Example vehicle configurations\n\n    instance Vehicle_1750kg: Vehicle {\n        mass = 1750;\n        frontAxleAssembly: AxleAssembly {\n            axle: FrontAxle {\n                steeringAngle = 0;\n            }\n            leftWheel: Wheel {}\n            rightWheel: Wheel {}\n        }\n        rearAxleAssembly: AxleAssembly {\n            axle: Axle {}\n            leftWheel: Wheel {}\n            rightWheel: Wheel {}\n        }\n    }\n\n    instance Vehicle_2000kg_Steerable: Vehicle {\n        mass = 2000;\n        frontAxleAssembly: AxleAssembly {\n            axle: FrontAxle {\n                steeringAngle = 30;\n            }\n            leftWheel: Wheel {}\n            rightWheel: Wheel {}\n        }\n        rearAxleAssembly: AxleAssembly {\n            axle: Axle {}\n            leftWheel: Wheel {}\n            rightWheel: Wheel {}\n        }\n    }\n\n    // Configuration with individually named wheels\n\n    part AxleAssemblyWithNamedWheels extends AxleAssembly {\n        part leftWheel: Wheel {\n            attribute name: String = \"Left\";\n        }\n        part rightWheel: Wheel {\n            attribute name: String = \"Right\";\n        }\n    }\n\n    instance Vehicle_NamedWheels: Vehicle {\n        mass = 1800;\n        frontAxleAssembly: AxleAssemblyWithNamedWheels {\n            axle: FrontAxle {\n                steeringAngle = 15;\n            }\n            leftWheel: Wheel {\n                name = \"FrontLeft\";\n            }\n            rightWheel: Wheel {\n                name = \"FrontRight\";\n            }\n        }\n        rearAxleAssembly: AxleAssemblyWithNamedWheels {\n            axle: Axle {}\n            leftWheel: Wheel {\n                name = \"RearLeft\";\n            }\n            rightWheel: Wheel {\n                name = \"RearRight\";\n            }\n        }\n    }\n}"
]