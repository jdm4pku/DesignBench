[
    "package 'VehicleManagementSystem' {\n    attribute def Mass;\n    attribute def GearSetting;\n    attribute def AcceleratorPosition;\n    \n    part def VehicleStatus {\n        attribute gearSetting: GearSetting;\n        attribute acceleratorPosition: AcceleratorPosition;\n    }\n    \n    part def Engine {\n        attribute engineId;\n        attribute engineType;\n        attribute power;\n    }\n    \n    part def Driver {\n        attribute driverId;\n        attribute name;\n        attribute licenseNumber;\n    }\n    \n    part def Vehicle {\n        attribute vehicleId;\n        attribute mass: Mass;\n        attribute currentStatus: VehicleStatus;\n        \n        part engine: Engine[1];\n        ref driver: Driver[0..1];\n    }\n    \n    part vehicleManagementSystem {\n        part vehicles: Vehicle[*];\n        part engines: Engine[*];\n        part drivers: Driver[*];\n    }\n}",
    "package 'VehicleSystem' {\n    part def Personnel;\n    part def Engine;\n    \n    part def Vehicle {\n        abstract;\n    }\n    \n    part def ManuallyOperatedVehicle :> Vehicle {\n        part driver : Personnel[1];\n    }\n    \n    part def PoweredVehicle :> Vehicle {\n        part engine : Engine[1];\n    }\n    \n    part def ManuallyOperatedPoweredVehicle :> ManuallyOperatedVehicle, PoweredVehicle;\n}",
    "package 'VehicleStructure' {\n    part def VehicleComponent;\n    \n    part def Engine :> VehicleComponent;\n    part def Transmission :> VehicleComponent;\n    part def Wheel :> VehicleComponent;\n    \n    part def Vehicle {\n        part engine : Engine[1];\n        part transmission : Transmission[1];\n        part wheels : Wheel[4];\n    }\n}",
    "package 'VehicleSystem' {\n    abstract part def Vehicle {\n        abstract part engine : Engine;\n    }\n    \n    abstract part def Engine {\n        abstract part cylinders : Cylinder[*];\n    }\n    \n    part def Cylinder;\n    \n    part def SmallEngine :> Engine {\n        part redefines cylinders : Cylinder[4];\n    }\n    \n    part def LargeEngine :> Engine {\n        part redefines cylinders : Cylinder[6];\n    }\n    \n    part def SmallVehicle :> Vehicle {\n        part redefines engine : SmallEngine;\n    }\n    \n    part def LargeVehicle :> Vehicle {\n        part redefines engine : LargeEngine;\n    }\n}",
    "package 'TrafficSignalSystem' {\n\tenum def TrafficLightColor {\n\t\tgreen;\n\t\tyellow;\n\t\tred;\n\t}\n\t\n\tpart def TrafficSignal {\n\t\tattribute currentColor : TrafficLightColor;\n\t}\n\t\n\tpart def GreenTrafficSignal :> TrafficSignal {\n\t\tattribute redefines currentColor : TrafficLightColor = TrafficLightColor::green;\n\t}\n\t\n\tpart trafficSignalSystem {\n\t\tpart trafficSignal : TrafficSignal;\n\t\tpart greenTrafficSignal : GreenTrafficSignal;\n\t}\n}",
    "package 'InformationClassificationSystem' {\n    enum def ClassificationLevel {\n        enum unclassified;\n        enum confidential;\n        enum secret;\n    }\n    \n    enum def ClassificationCode {\n        enum uncl;\n        enum conf;\n        enum secr;\n    }\n    \n    enum def ClassificationColor {\n        enum green;\n        enum yellow;\n        enum red;\n    }\n    \n    enum def GradeLevel {\n        enum A;\n        enum B;\n        enum C;\n        enum D;\n        enum F;\n    }\n    \n    attribute def GradePoints : Real;\n    \n    attribute def Information {\n        attribute level : ClassificationLevel;\n        attribute code : ClassificationCode;\n        attribute color : ClassificationColor;\n    }\n    \n    attribute def Grade {\n        attribute level : GradeLevel;\n        attribute points : GradePoints;\n    }\n    \n    constraint def ClassificationMapping {\n        constraint unclassifiedMapping {\n            (level == ClassificationLevel::unclassified) == \n            (code == ClassificationCode::uncl) == \n            (color == ClassificationColor::green)\n        }\n        constraint confidentialMapping {\n            (level == ClassificationLevel::confidential) == \n            (code == ClassificationCode::conf) == \n            (color == ClassificationColor::yellow)\n        }\n        constraint secretMapping {\n            (level == ClassificationLevel::secret) == \n            (code == ClassificationCode::secr) == \n            (color == ClassificationColor::red)\n        }\n    }\n    \n    constraint def GradeMapping {\n        constraint gradeAMapping {\n            (level == GradeLevel::A) == (points == 4.0)\n        }\n        constraint gradeBMapping {\n            (level == GradeLevel::B) == (points == 3.0)\n        }\n        constraint gradeCMapping {\n            (level == GradeLevel::C) == (points == 2.0)\n        }\n        constraint gradeDMapping {\n            (level == GradeLevel::D) == (points == 1.0)\n        }\n        constraint gradeFMapping {\n            (level == GradeLevel::F) == (points == 0.0)\n        }\n    }\n    \n    part def InformationManager {\n        attribute classifiedInfo : Information[*];\n        attribute grades : Grade[*];\n        \n        assert constraint classificationConstraint : ClassificationMapping;\n        assert constraint gradeConstraint : GradeMapping;\n    }\n}",
    "package 'VehicleSystem' {\n    part def Vehicle {\n        part engine : Engine[1];\n    }\n    \n    part def SmallVehicle :> Vehicle {\n        part engine : Engine[1] :>> Vehicle::engine {\n            part cylinder : Cylinder[4] :>> Engine::cylinder;\n        }\n    }\n    \n    part def LargeVehicle :> Vehicle {\n        part engine : Engine[1] :>> Vehicle::engine {\n            part cylinder : Cylinder[6] :>> Engine::cylinder;\n        }\n    }\n    \n    part def Engine {\n        part cylinder : Cylinder[4..6];\n    }\n    \n    part def Cylinder;\n}",
    "package 'VehicleSystem' {\n    attribute def Quality;\n    attribute def FuelType;\n    attribute def PersonnelInfo;\n    \n    part def FuelTank {\n        attribute fuelType: FuelType;\n        attribute capacity: Real;\n    }\n    \n    part def Driver {\n        attribute info: PersonnelInfo;\n    }\n    \n    part def Vehicle {\n        attribute quality: Quality;\n        part fuelTank: FuelTank;\n        ref driver: Driver;\n    }\n    \n    part vehicleModel {\n        part vehicle: Vehicle;\n        part driver: Driver;\n        \n        connection vehicleDriverAssociation connect vehicle.driver to driver;\n    }\n}",
    "package 'WheelAssembly' {\n    part def WheelBearingUnit;\n    part def Tire {\n        part bead[2];\n    }\n    part def Hub {\n        part rim[2];\n        part mountingHole[*];\n    }\n    part def Bolt;\n    part def ThreadedHole;\n    \n    interface def BeadRimConnection {\n        end bead;\n        end rim;\n    }\n    \n    interface def BoltConnection {\n        end bolt : Bolt;\n        end threadedHole : ThreadedHole;\n    }\n    \n    part wheelAssembly {\n        part wheelBearingUnit : WheelBearingUnit;\n        part tire : Tire;\n        part hub : Hub;\n        part threadedHole[*] : ThreadedHole;\n        part bolt[*] : Bolt;\n        \n        interface beadRimConnection[2] : BeadRimConnection \n            connect tire.bead[1] to hub.rim[1],\n                    tire.bead[2] to hub.rim[2];\n        \n        interface boltConnection[*] : BoltConnection\n            connect bolt to threadedHole;\n        \n        bind hub.mountingHole[1..*] = threadedHole[1..*];\n    }\n}",
    "package 'FuelFlowManagement' {\n\tattribute def Fuel;\n\tattribute def Temperature;\n\tattribute def FlowData;\n\t\n\tport def FuelSupplyPort {\n\t\tout fuel: Fuel;\n\t\tout temperature: Temperature;\n\t}\n\t\n\tport def FuelReturnPort {\n\t\tin fuel: Fuel;\n\t\tout temperature: Temperature;\n\t}\n\t\n\tport def DataPort {\n\t\tout flowData: FlowData;\n\t}\n\t\n\tpart context {\n\t\tpart fuelTankAssembly {\n\t\t\tport fuelSupplyPort: FuelSupplyPort;\n\t\t\tport fuelReturnPort: FuelReturnPort;\n\t\t\tport dataPort: DataPort;\n\t\t\t\n\t\t\tperform manageFuelFlow.supplyFuel {\n\t\t\t\tout fuel = fuelSupplyPort.fuel;\n\t\t\t\tout temperature = fuelSupplyPort.temperature;\n\t\t\t\tout flowData = dataPort.flowData;\n\t\t\t}\n\t\t\t\n\t\t\tperform manageFuelFlow.receiveReturnFuel {\n\t\t\t\tin fuel = fuelReturnPort.fuel;\n\t\t\t\tout temperature = fuelReturnPort.temperature;\n\t\t\t\tout flowData = dataPort.flowData;\n\t\t\t}\n\t\t}\n\t\t\n\t\tinterface fuelSupplyInterface connect fuelTankAssembly.fuelSupplyPort to engine.fuelSupplyPort {\n\t\t\tref flow references manageFuelFlow.fuelSupplyFlow\n\t\t\t\tfrom source.fuel to target.fuel;\n\t\t\tref flow references manageFuelFlow.supplyTempFlow\n\t\t\t\tfrom source.temperature to target.temperature;\n\t\t}\n\t\t\n\t\tinterface fuelReturnInterface connect engine.fuelReturnPort to fuelTankAssembly.fuelReturnPort {\n\t\t\tref flow references manageFuelFlow.fuelReturnFlow\n\t\t\t\tfrom source.fuel to target.fuel;\n\t\t\tref flow references manageFuelFlow.returnTempFlow\n\t\t\t\tfrom source.temperature to target.temperature;\n\t\t}\n\t\t\n\t\tpart engine {\n\t\t\tport fuelSupplyPort: ~FuelSupplyPort;\n\t\t\tport fuelReturnPort: ~FuelReturnPort;\n\t\t\t\n\t\t\tperform manageFuelFlow.consumeFuel {\n\t\t\t\tin fuel = fuelSupplyPort.fuel;\n\t\t\t\tin temperature = fuelSupplyPort.temperature;\n\t\t\t\tout returnFuel = fuelReturnPort.fuel;\n\t\t\t\tout returnTemperature = fuelReturnPort.temperature;\n\t\t\t}\n\t\t}\n\t\t\n\t\tpart user {\n\t\t\tport dataPort: ~DataPort;\n\t\t\t\n\t\t\tperform manageFuelFlow.monitorFuelFlow {\n\t\t\t\tin flowData = dataPort.flowData;\n\t\t\t}\n\t\t}\n\t\t\n\t\tinterface dataInterface connect fuelTankAssembly.dataPort to user.dataPort {\n\t\t\tref flow references manageFuelFlow.dataFlow\n\t\t\t\tfrom source.flowData to target.flowData;\n\t\t}\n\t}\n\t\n\taction manageFuelFlow {\n\t\taction supplyFuel { out fuel: Fuel; out temperature: Temperature; out flowData: FlowData; }\n\t\tsuccession flow fuelSupplyFlow from supplyFuel.fuel to consumeFuel.fuel;\n\t\tsuccession flow supplyTempFlow from supplyFuel.temperature to consumeFuel.temperature;\n\t\t\n\t\taction consumeFuel { in fuel: Fuel; in temperature: Temperature; out returnFuel: Fuel; out returnTemperature: Temperature; }\n\t\tsuccession flow fuelReturnFlow from consumeFuel.returnFuel to receiveReturnFuel.fuel;\n\t\tsuccession flow returnTempFlow from consumeFuel.returnTemperature to receiveReturnFuel.temperature;\n\t\t\n\t\taction receiveReturnFuel { in fuel: Fuel; out temperature: Temperature; out flowData: FlowData; }\n\t\tsuccession flow dataFlow from supplyFuel.flowData to monitorFuelFlow.flowData;\n\t\tsuccession flow dataFlow2 from receiveReturnFuel.flowData to monitorFuelFlow.flowData;\n\t\t\n\t\taction monitorFuelFlow { in flowData: FlowData; }\n\t}\n}",
    "package 'VehicleConfigurationSystem' {\n    attribute def MassValue :> ISQ::mass;\n    attribute def SteeringAngleValue :> ISQ::angle;\n    \n    part def Tire {\n        attribute mass : MassValue;\n    }\n    \n    part def Axle {\n        attribute mass : MassValue;\n        part tires : Tire[2] ordered;\n    }\n    \n    part def FrontAxle :> Axle {\n        attribute steeringAngle : SteeringAngleValue;\n    }\n    \n    part def RearAxle :> Axle;\n    \n    part def Vehicle {\n        attribute mass : MassValue default 1750 [kg];\n        part frontAxle : Axle[1];\n        part rearAxle : Axle[1];\n    }\n    \n    part vehicle1_c1 : Vehicle {\n        attribute :>> mass = 2000 [kg];\n        part :>> frontAxle : FrontAxle {\n            part :>> tires {\n                ref tire1 : Tire;\n                ref tire2 : Tire;\n            }\n        }\n        part :>> rearAxle : RearAxle {\n            part :>> tires {\n                ref tire3 : Tire;\n                ref tire4 : Tire;\n            }\n        }\n    }\n}",
    "package 'VehicleTrailerCoupling' {\n    attribute def CouplingForce;\n    attribute def ConnectionStatus;\n    \n    port def CouplingBallPort {\n        out couplingForce : CouplingForce;\n        out connectionStatus : ConnectionStatus;\n    }\n    \n    port def CouplingConnectorPort {\n        in couplingForce : CouplingForce;\n        in connectionStatus : ConnectionStatus;\n    }\n    \n    part def Hitch {\n        part couplingBall {\n            port ballPort : CouplingBallPort;\n        }\n        part couplingConnector {\n            port connectorPort : CouplingConnectorPort;\n        }\n    }\n    \n    part context {\n        part vehicle {\n            ref hitchBall : Hitch::couplingBall;\n            perform towingOperation.provideCouplingForce {\n                out couplingForce = hitchBall.ballPort.couplingForce;\n                out connectionStatus = hitchBall.ballPort.connectionStatus;\n            }\n        }\n        \n        part hitch : Hitch;\n        \n        part trailer {\n            ref hitchConnector : Hitch::couplingConnector;\n            perform towingOperation.receiveCouplingForce {\n                in couplingForce = hitchConnector.connectorPort.couplingForce;\n                in connectionStatus = hitchConnector.connectorPort.connectionStatus;\n            }\n        }\n        \n        interface ballToConnector connect hitch.couplingBall.ballPort to hitch.couplingConnector.connectorPort {\n            ref flow references towingOperation.couplingForceFlow\n                from source.couplingForce to target.couplingForce;\n            ref flow references towingOperation.connectionStatusFlow\n                from source.connectionStatus to target.connectionStatus;\n        }\n    }\n    \n    action towingOperation {\n        action provideCouplingForce { \n            out couplingForce : CouplingForce; \n            out connectionStatus : ConnectionStatus;\n        }\n        succession flow couplingForceFlow from provideCouplingForce.couplingForce to receiveCouplingForce.couplingForce;\n        succession flow connectionStatusFlow from provideCouplingForce.connectionStatus to receiveCouplingForce.connectionStatus;\n        action receiveCouplingForce { \n            in couplingForce : CouplingForce;\n            in connectionStatus : ConnectionStatus;\n        }\n    }\n}",
    "package 'VehiclePowerTransmission' {\n    attribute def FuelCommand;\n    attribute def Power;\n    attribute def ClutchSignal;\n    attribute def Torque;\n    attribute def RoadForce;\n    \n    port def FuelCommandPort {\n        in fuelCmd : FuelCommand;\n    }\n    \n    port def PowerPort {\n        out power : Power;\n    }\n    \n    port def PowerInputPort {\n        in power : Power;\n    }\n    \n    port def ClutchPort {\n        out clutchSignal : ClutchSignal;\n    }\n    \n    port def ClutchInputPort {\n        in clutchSignal : ClutchSignal;\n    }\n    \n    port def TorquePort {\n        out torque : Torque;\n    }\n    \n    port def TorqueInputPort {\n        in torque : Torque;\n    }\n    \n    port def WheelGroundPort {\n        out roadForce : RoadForce;\n    }\n    \n    port def RoadSurfacePort {\n        in roadForce : RoadForce;\n    }\n    \n    part def Engine {\n        port fuelCommandPort : FuelCommandPort;\n        port powerPort : PowerPort;\n        port clutchPort : ClutchPort;\n    }\n    \n    part def Transmission {\n        port powerInputPort : PowerInputPort;\n        port clutchInputPort : ClutchInputPort;\n        port powerOutputPort : PowerPort;\n    }\n    \n    part def Clutch {\n        port clutchInputPort : ClutchInputPort;\n        port powerInputPort : PowerInputPort;\n        port powerOutputPort : PowerPort;\n    }\n    \n    part def DriveShaft {\n        port powerInputPort : PowerInputPort;\n        port torqueOutputPort : TorquePort;\n    }\n    \n    part def Differential {\n        port torqueInputPort : TorqueInputPort;\n        port leftTorquePort : TorquePort;\n        port rightTorquePort : TorquePort;\n    }\n    \n    part def HalfShaft {\n        port torqueInputPort : TorqueInputPort;\n        port torqueOutputPort : TorquePort;\n    }\n    \n    part def Wheel {\n        port torqueInputPort : TorqueInputPort;\n        port wheelGroundPort : WheelGroundPort;\n    }\n    \n    part def RearAxleAssembly {\n        port torqueInputPort : TorqueInputPort;\n        \n        part differential : Differential;\n        part leftHalfShaft : HalfShaft;\n        part rightHalfShaft : HalfShaft;\n        \n        interface diffToLeftShaft connect differential.leftTorquePort to leftHalfShaft.torqueInputPort;\n        interface diffToRightShaft connect differential.rightTorquePort to rightHalfShaft.torqueInputPort;\n        \n        bind torqueInputPort = differential.torqueInputPort;\n        \n        port leftTorqueOutput : TorquePort;\n        port rightTorqueOutput : TorquePort;\n        \n        bind leftTorqueOutput = leftHalfShaft.torqueOutputPort;\n        bind rightTorqueOutput = rightHalfShaft.torqueOutputPort;\n    }\n    \n    part vehiclePowerSystem {\n        part engine : Engine;\n        part clutch : Clutch;\n        part transmission : Transmission;\n        part driveShaft : DriveShaft;\n        part rearAxle : RearAxleAssembly;\n        part leftRearWheel : Wheel;\n        part rightRearWheel : Wheel;\n        part roadSurface {\n            port leftRoadPort : RoadSurfacePort;\n            port rightRoadPort : RoadSurfacePort;\n        }\n        \n        interface engineToClutch connect engine.powerPort to clutch.powerInputPort;\n        interface engineClutchControl connect engine.clutchPort to clutch.clutchInputPort;\n        interface clutchToTransmission connect clutch.powerOutputPort to transmission.powerInputPort;\n        interface transmissionClutchControl connect engine.clutchPort to transmission.clutchInputPort;\n        interface transmissionToDriveShaft connect transmission.powerOutputPort to driveShaft.powerInputPort;\n        interface driveShaftToRearAxle connect driveShaft.torqueOutputPort to rearAxle.torqueInputPort;\n        interface rearAxleToLeftWheel connect rearAxle.leftTorqueOutput to leftRearWheel.torqueInputPort;\n        interface rearAxleToRightWheel connect rearAxle.rightTorqueOutput to rightRearWheel.torqueInputPort;\n        interface leftWheelToRoad connect leftRearWheel.wheelGroundPort to roadSurface.leftRoadPort;\n        interface rightWheelToRoad connect rightRearWheel.wheelGroundPort to roadSurface.rightRoadPort;\n    }\n}",
    "package 'MultiArchitectureSystem' {\n    port def SignalPort;\n    \n    part def C1 {\n        port pb: SignalPort;\n    }\n    \n    part def C2 {\n        port pc: SignalPort;\n    }\n    \n    part def C3 {\n        port pd: SignalPort;\n    }\n    \n    part def C4 {\n        port pe: SignalPort;\n    }\n    \n    part def B11 {\n        part c1: C1;\n        part c2: C2;\n        port pe: SignalPort;\n        \n        interface c1ToC2 connect c1.pb to c2.pc;\n        bind pe = c1.pb;\n    }\n    \n    part def B12 {\n        part c3: C3;\n        part c4: C4;\n        port pf: SignalPort;\n        \n        interface c3ToC4 connect c3.pd to c4.pe;\n        bind pf = c3.pd;\n    }\n    \n    part def B21 {\n        ref part c1: C1;\n        ref part c2: C2;\n        ref part c3: C3;\n        ref part c4: C4;\n    }\n    \n    part def B22 {\n        ref part c1: C1;\n        ref part c2: C2;\n        ref part c3: C3;\n        ref part c4: C4;\n    }\n    \n    part system {\n        variant part decomposition1 {\n            part b11: B11;\n            part b12: B12;\n            \n            interface b11ToB12 connect b11.pe to b12.pf;\n        }\n        \n        variant part decomposition2 {\n            part b21: B21;\n            part b22: B22;\n        }\n    }\n}",
    "package 'AutomotivePowertrain' {\n\tattribute def FuelCommand;\n\tattribute def StartStopCommand;\n\tattribute def EngineTorque;\n\tattribute def TransmissionTorque;\n\tattribute def DriveshaftTorque;\n\tattribute def WheelTorque;\n\t\n\tport def FuelCommandPort {\n\t\tout fuelCommand: FuelCommand;\n\t}\n\tport def StartStopCommandPort {\n\t\tout startStopCommand: StartStopCommand;\n\t}\n\tport def EngineTorquePort {\n\t\tout engineTorque: EngineTorque;\n\t}\n\tport def TransmissionTorquePort {\n\t\tout transmissionTorque: TransmissionTorque;\n\t}\n\tport def DriveshaftTorquePort {\n\t\tout driveshaftTorque: DriveshaftTorque;\n\t}\n\tport def WheelTorquePort {\n\t\tout wheelTorque: WheelTorque;\n\t}\n\t\n\tpart context {\n\t\tpart user {\n\t\t\tport fuelCommandPort: FuelCommandPort;\n\t\t\tport startStopCommandPort: StartStopCommandPort;\n\t\t\tperform powerTransmission.sendFuelCommand {\n\t\t\t\tout fuelCommand = fuelCommandPort.fuelCommand;\n\t\t\t}\n\t\t\tperform powerTransmission.sendStartStopCommand {\n\t\t\t\tout startStopCommand = startStopCommandPort.startStopCommand;\n\t\t\t}\n\t\t}\n\t\t\n\t\tinterface userToEngine connect user.fuelCommandPort to engine.fuelCommandPort {\n\t\t\tref flow references powerTransmission.fuelCommandFlow\n\t\t\t\tfrom source.fuelCommand to target.fuelCommand;\n\t\t}\n\t\tinterface userToEngineControl connect user.startStopCommandPort to engine.startStopCommandPort {\n\t\t\tref flow references powerTransmission.startStopCommandFlow\n\t\t\t\tfrom source.startStopCommand to target.startStopCommand;\n\t\t}\n\t\t\n\t\tpart engine {\n\t\t\tport fuelCommandPort: ~FuelCommandPort;\n\t\t\tport startStopCommandPort: ~StartStopCommandPort;\n\t\t\tport engineTorquePort: EngineTorquePort;\n\t\t\tperform powerTransmission.generateEngineTorque {\n\t\t\t\tin fuelCommand = fuelCommandPort.fuelCommand;\n\t\t\t\tin startStopCommand = startStopCommandPort.startStopCommand;\n\t\t\t\tout engineTorque = engineTorquePort.engineTorque;\n\t\t\t}\n\t\t}\n\t\t\n\t\tinterface engineToTransmission connect engine.engineTorquePort to transmission.engineTorquePort {\n\t\t\tref flow references powerTransmission.engineTorqueFlow\n\t\t\t\tfrom source.engineTorque to target.engineTorque;\n\t\t}\n\t\t\n\t\tpart transmission {\n\t\t\tport engineTorquePort: ~EngineTorquePort;\n\t\t\tport transmissionTorquePort: TransmissionTorquePort;\n\t\t\tperform powerTransmission.amplifyTorque {\n\t\t\t\tin engineTorque = engineTorquePort.engineTorque;\n\t\t\t\tout transmissionTorque = transmissionTorquePort.transmissionTorque;\n\t\t\t}\n\t\t}\n\t\t\n\t\tinterface transmissionToDriveshaft connect transmission.transmissionTorquePort to driveshaft.transmissionTorquePort {\n\t\t\tref flow references powerTransmission.transmissionTorqueFlow\n\t\t\t\tfrom source.transmissionTorque to target.transmissionTorque;\n\t\t}\n\t\t\n\t\tpart driveshaft {\n\t\t\tport transmissionTorquePort: ~TransmissionTorquePort;\n\t\t\tport driveshaftTorquePort: DriveshaftTorquePort;\n\t\t\tperform powerTransmission.transmitTorque {\n\t\t\t\tin transmissionTorque = transmissionTorquePort.transmissionTorque;\n\t\t\t\tout driveshaftTorque = driveshaftTorquePort.driveshaftTorque;\n\t\t\t}\n\t\t}\n\t\t\n\t\tinterface driveshaftToLeftWheel connect driveshaft.driveshaftTorquePort to leftWheel.driveshaftTorquePort {\n\t\t\tref flow references powerTransmission.leftWheelTorqueFlow\n\t\t\t\tfrom source.driveshaftTorque to target.driveshaftTorque;\n\t\t}\n\t\t\n\t\tinterface driveshaftToRightWheel connect driveshaft.driveshaftTorquePort to rightWheel.driveshaftTorquePort {\n\t\t\tref flow references powerTransmission.rightWheelTorqueFlow\n\t\t\t\tfrom source.driveshaftTorque to target.driveshaftTorque;\n\t\t}\n\t\t\n\t\tpart leftWheel {\n\t\t\tport driveshaftTorquePort: ~DriveshaftTorquePort;\n\t\t\tperform powerTransmission.distributeLeftWheelTorque {\n\t\t\t\tin driveshaftTorque = driveshaftTorquePort.driveshaftTorque;\n\t\t\t}\n\t\t}\n\t\t\n\t\tpart rightWheel {\n\t\t\tport driveshaftTorquePort: ~DriveshaftTorquePort;\n\t\t\tperform powerTransmission.distributeRightWheelTorque {\n\t\t\t\tin driveshaftTorque = driveshaftTorquePort.driveshaftTorque;\n\t\t\t}\n\t\t}\n\t}\n\t\n\taction powerTransmission {\n\t\taction sendFuelCommand { out fuelCommand: FuelCommand; }\n\t\taction sendStartStopCommand { out startStopCommand: StartStopCommand; }\n\t\tsuccession flow fuelCommandFlow from sendFuelCommand.fuelCommand to generateEngineTorque.fuelCommand;\n\t\tsuccession flow startStopCommandFlow from sendStartStopCommand.startStopCommand to generateEngineTorque.startStopCommand;\n\t\taction generateEngineTorque { in fuelCommand; in startStopCommand; out engineTorque: EngineTorque; }\n\t\tsuccession flow engineTorqueFlow from generateEngineTorque.engineTorque to amplifyTorque.engineTorque;\n\t\taction amplifyTorque { in engineTorque; out transmissionTorque: TransmissionTorque; }\n\t\tsuccession flow transmissionTorqueFlow from amplifyTorque.transmissionTorque to transmitTorque.transmissionTorque;\n\t\taction transmitTorque { in transmissionTorque; out driveshaftTorque: DriveshaftTorque; }\n\t\tsuccession flow leftWheelTorqueFlow from transmitTorque.driveshaftTorque to distributeLeftWheelTorque.driveshaftTorque;\n\t\tsuccession flow rightWheelTorqueFlow from transmitTorque.driveshaftTorque to distributeRightWheelTorque.driveshaftTorque;\n\t\taction distributeLeftWheelTorque { in driveshaftTorque; }\n\t\taction distributeRightWheelTorque { in driveshaftTorque; }\n\t}\n}",
    "package 'AutomotivePowertrain' {\n\tattribute def FuelControlCmd;\n\tattribute def StallSignal;\n\tattribute def Torque;\n\tattribute def AmplifiedTorque;\n\tattribute def TransmittedTorque;\n\tattribute def WheelTorque;\n\t\n\tport def FuelControlCmdPort {\n\t\tin fuelControlCmd : FuelControlCmd;\n\t}\n\tport def StallSignalPort {\n\t\tin stallSignal : StallSignal;\n\t}\n\tport def TorquePort {\n\t\tout torque : Torque;\n\t}\n\tport def AmplifiedTorquePort {\n\t\tout amplifiedTorque : AmplifiedTorque;\n\t}\n\tport def TransmittedTorquePort {\n\t\tout transmittedTorque : TransmittedTorque;\n\t}\n\tport def WheelTorquePort {\n\t\tout wheelTorque : WheelTorque;\n\t}\n\t\n\tpart context {\n\t\tpart controller {\n\t\t\tport fuelControlCmdPort : FuelControlCmdPort;\n\t\t\tport stallSignalPort : StallSignalPort;\n\t\t\tperform powerDelivery.sendFuelCommand {\n\t\t\t\tout fuelControlCmd = fuelControlCmdPort.fuelControlCmd;\n\t\t\t}\n\t\t\tperform powerDelivery.sendStallSignal {\n\t\t\t\tout stallSignal = stallSignalPort.stallSignal;\n\t\t\t}\n\t\t}\n\t\t\n\t\tinterface controllerToEngine connect controller.fuelControlCmdPort to engine.fuelControlCmdPort {\n\t\t\tref flow references powerDelivery.fuelCmdFlow\n\t\t\t\tfrom source.fuelControlCmd to target.fuelControlCmd;\n\t\t}\n\t\t\n\t\tinterface controllerToEngineStall connect controller.stallSignalPort to engine.stallSignalPort {\n\t\t\tref flow references powerDelivery.stallFlow\n\t\t\t\tfrom source.stallSignal to target.stallSignal;\n\t\t}\n\t\t\n\t\tpart engine {\n\t\t\tport fuelControlCmdPort : ~FuelControlCmdPort;\n\t\t\tport stallSignalPort : ~StallSignalPort;\n\t\t\tport torquePort : TorquePort;\n\t\t\tperform powerDelivery.startEngine {\n\t\t\t\tin fuelControlCmd = fuelControlCmdPort.fuelControlCmd;\n\t\t\t\tin stallSignal = stallSignalPort.stallSignal;\n\t\t\t}\n\t\t\tperform powerDelivery.generateTorque {\n\t\t\t\tin stallSignal = stallSignalPort.stallSignal;\n\t\t\t\tout torque = torquePort.torque;\n\t\t\t}\n\t\t}\n\t\t\n\t\tinterface engineToTransmission connect engine.torquePort to transmission.torquePort {\n\t\t\tref flow references powerDelivery.torqueFlow\n\t\t\t\tfrom source.torque to target.torque;\n\t\t}\n\t\t\n\t\tpart transmission {\n\t\t\tport torquePort : ~TorquePort;\n\t\t\tport amplifiedTorquePort : AmplifiedTorquePort;\n\t\t\tperform powerDelivery.amplifyTorque {\n\t\t\t\tin torque = torquePort.torque;\n\t\t\t\tout amplifiedTorque = amplifiedTorquePort.amplifiedTorque;\n\t\t\t}\n\t\t}\n\t\t\n\t\tinterface transmissionToDriveline connect transmission.amplifiedTorquePort to driveline.amplifiedTorquePort {\n\t\t\tref flow references powerDelivery.amplifiedTorqueFlow\n\t\t\t\tfrom source.amplifiedTorque to target.amplifiedTorque;\n\t\t}\n\t\t\n\t\tpart driveline {\n\t\t\tport amplifiedTorquePort : ~AmplifiedTorquePort;\n\t\t\tport transmittedTorquePort : TransmittedTorquePort;\n\t\t\tperform powerDelivery.transmitTorque {\n\t\t\t\tin amplifiedTorque = amplifiedTorquePort.amplifiedTorque;\n\t\t\t\tout transmittedTorque = transmittedTorquePort.transmittedTorque;\n\t\t\t}\n\t\t}\n\t\t\n\t\tinterface drivelineToWheels connect driveline.transmittedTorquePort to wheels.transmittedTorquePort {\n\t\t\tref flow references powerDelivery.transmittedTorqueFlow\n\t\t\t\tfrom source.transmittedTorque to target.transmittedTorque;\n\t\t}\n\t\t\n\t\tpart wheels {\n\t\t\tport transmittedTorquePort : ~TransmittedTorquePort;\n\t\t\tport wheelTorquePort : WheelTorquePort;\n\t\t\tperform powerDelivery.distributeTorque {\n\t\t\t\tin transmittedTorque = transmittedTorquePort.transmittedTorque;\n\t\t\t\tout wheelTorque = wheelTorquePort.wheelTorque;\n\t\t\t}\n\t\t}\n\t}\n\t\n\taction powerDelivery {\n\t\taction sendFuelCommand { out fuelControlCmd : FuelControlCmd; }\n\t\taction sendStallSignal { out stallSignal : StallSignal; }\n\t\tsuccession flow fuelCmdFlow from sendFuelCommand.fuelControlCmd to startEngine.fuelControlCmd;\n\t\tsuccession flow stallFlow from sendStallSignal.stallSignal to startEngine.stallSignal;\n\t\taction startEngine { in fuelControlCmd : FuelControlCmd; in stallSignal : StallSignal; }\n\t\tsuccession from startEngine to generateTorque;\n\t\taction generateTorque { in stallSignal : StallSignal; out torque : Torque; }\n\t\tsuccession flow torqueFlow from generateTorque.torque to amplifyTorque.torque;\n\t\taction amplifyTorque { in torque : Torque; out amplifiedTorque : AmplifiedTorque; }\n\t\tsuccession flow amplifiedTorqueFlow from amplifyTorque.amplifiedTorque to transmitTorque.amplifiedTorque;\n\t\taction transmitTorque { in amplifiedTorque : AmplifiedTorque; out transmittedTorque : TransmittedTorque; }\n\t\tsuccession flow transmittedTorqueFlow from transmitTorque.transmittedTorque to distributeTorque.transmittedTorque;\n\t\taction distributeTorque { in transmittedTorque : TransmittedTorque; out wheelTorque : WheelTorque; }\n\t}\n}",
    "package 'VehiclePowertrainSystem' {\n\tattribute def FuelCommand;\n\tattribute def EngineStartSignal;\n\tattribute def EngineShutdownSignal;\n\tattribute def EngineTorque;\n\tattribute def TransmissionTorque;\n\tattribute def WheelTorque;\n\t\n\tport def FuelCommandPort {\n\t\tout fuelCommand: FuelCommand;\n\t}\n\tport def EngineControlPort {\n\t\tout engineStartSignal: EngineStartSignal;\n\t\tout engineShutdownSignal: EngineShutdownSignal;\n\t}\n\tport def EngineTorquePort {\n\t\tout engineTorque: EngineTorque;\n\t}\n\tport def TransmissionTorquePort {\n\t\tout transmissionTorque: TransmissionTorque;\n\t}\n\tport def WheelTorquePort {\n\t\tout wheelTorque: WheelTorque;\n\t}\n\t\n\tpart context {\n\t\tpart driver {\n\t\t\tport fuelCommandPort: FuelCommandPort;\n\t\t\tport engineControlPort: EngineControlPort;\n\t\t\tperform powerManagement.provideFuelCommand {\n\t\t\t\tout fuelCommand = fuelCommandPort.fuelCommand;\n\t\t\t}\n\t\t\tperform powerManagement.provideEngineControl {\n\t\t\t\tout engineStartSignal = engineControlPort.engineStartSignal;\n\t\t\t\tout engineShutdownSignal = engineControlPort.engineShutdownSignal;\n\t\t\t}\n\t\t}\n\t\t\n\t\tinterface driverToEngine connect driver.fuelCommandPort to engine.fuelCommandPort {\n\t\t\tref flow references powerManagement.fuelCommandFlow\n\t\t\t\tfrom source.fuelCommand to target.fuelCommand;\n\t\t}\n\t\tinterface driverToEngineControl connect driver.engineControlPort to engine.engineControlPort {\n\t\t\tref flow references powerManagement.engineStartFlow\n\t\t\t\tfrom source.engineStartSignal to target.engineStartSignal;\n\t\t\tref flow references powerManagement.engineShutdownFlow\n\t\t\t\tfrom source.engineShutdownSignal to target.engineShutdownSignal;\n\t\t}\n\t\t\n\t\tpart engine {\n\t\t\tport fuelCommandPort: ~FuelCommandPort;\n\t\t\tport engineControlPort: ~EngineControlPort;\n\t\t\tport engineTorquePort: EngineTorquePort;\n\t\t\tperform powerManagement.generateEngineTorque {\n\t\t\t\tin fuelCommand = fuelCommandPort.fuelCommand;\n\t\t\t\tin engineStartSignal = engineControlPort.engineStartSignal;\n\t\t\t\tin engineShutdownSignal = engineControlPort.engineShutdownSignal;\n\t\t\t\tout engineTorque = engineTorquePort.engineTorque;\n\t\t\t}\n\t\t}\n\t\t\n\t\tinterface engineToTransmission connect engine.engineTorquePort to transmission.engineTorquePort {\n\t\t\tref flow references powerManagement.engineTorqueFlow\n\t\t\t\tfrom source.engineTorque to target.engineTorque;\n\t\t}\n\t\t\n\t\tpart transmission {\n\t\t\tport engineTorquePort: ~EngineTorquePort;\n\t\t\tport transmissionTorquePort: TransmissionTorquePort;\n\t\t\tperform powerManagement.amplifyTransmitTorque {\n\t\t\t\tin engineTorque = engineTorquePort.engineTorque;\n\t\t\t\tout transmissionTorque = transmissionTorquePort.transmissionTorque;\n\t\t\t}\n\t\t}\n\t\t\n\t\tinterface transmissionToWheels connect transmission.transmissionTorquePort to wheels.transmissionTorquePort {\n\t\t\tref flow references powerManagement.transmissionTorqueFlow\n\t\t\t\tfrom source.transmissionTorque to target.transmissionTorque;\n\t\t}\n\t\t\n\t\tpart wheels {\n\t\t\tport transmissionTorquePort: ~TransmissionTorquePort;\n\t\t\tport wheelTorquePort: WheelTorquePort;\n\t\t\tperform powerManagement.distributeTorque {\n\t\t\t\tin transmissionTorque = transmissionTorquePort.transmissionTorque;\n\t\t\t\tout wheelTorque = wheelTorquePort.wheelTorque;\n\t\t\t}\n\t\t}\n\t}\n\t\n\taction powerManagement {\n\t\taction provideFuelCommand { out fuelCommand: FuelCommand; }\n\t\taction provideEngineControl { \n\t\t\tout engineStartSignal: EngineStartSignal; \n\t\t\tout engineShutdownSignal: EngineShutdownSignal;\n\t\t}\n\t\tsuccession flow fuelCommandFlow from provideFuelCommand.fuelCommand to generateEngineTorque.fuelCommand;\n\t\tsuccession flow engineStartFlow from provideEngineControl.engineStartSignal to generateEngineTorque.engineStartSignal;\n\t\tsuccession flow engineShutdownFlow from provideEngineControl.engineShutdownSignal to generateEngineTorque.engineShutdownSignal;\n\t\taction generateEngineTorque { \n\t\t\tin fuelCommand: FuelCommand;\n\t\t\tin engineStartSignal: EngineStartSignal;\n\t\t\tin engineShutdownSignal: EngineShutdownSignal;\n\t\t\tout engineTorque: EngineTorque; \n\t\t}\n\t\tsuccession flow engineTorqueFlow from generateEngineTorque.engineTorque to amplifyTransmitTorque.engineTorque;\n\t\taction amplifyTransmitTorque { \n\t\t\tin engineTorque: EngineTorque; \n\t\t\tout transmissionTorque: TransmissionTorque; \n\t\t}\n\t\tsuccession flow transmissionTorqueFlow from amplifyTransmitTorque.transmissionTorque to distributeTorque.transmissionTorque;\n\t\taction distributeTorque { \n\t\t\tin transmissionTorque: TransmissionTorque; \n\t\t\tout wheelTorque: WheelTorque;\n\t\t}\n\t}\n}",
    "package 'VehicleTrailerHitchSystem' {\n\tattribute def ConnectionState;\n\tattribute def Force;\n\t\n\tport def ConnectionStatePort {\n\t\tout connectionState : ConnectionState;\n\t}\n\t\n\tport def ForcePort {\n\t\tinout force : Force;\n\t}\n\t\n\tpart context {\n\t\tpart vehicle {\n\t\t\tpart vehicleFrame {\n\t\t\t\tpart hitchBall {\n\t\t\t\t\tport forcePort : ForcePort;\n\t\t\t\t\tport connectionStatePort : ConnectionStatePort;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t\n\t\tpart trailer {\n\t\t\tpart trailerFrame {\n\t\t\t\tpart trailerCoupler {\n\t\t\t\t\tport forcePort : ~ForcePort;\n\t\t\t\t\tport connectionStatePort : ~ConnectionStatePort;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t\n\t\tinterface hitchConnection connect vehicle.vehicleFrame.hitchBall.forcePort to trailer.trailerFrame.trailerCoupler.forcePort {\n\t\t\tref flow references powerCoupling.forceTransmission\n\t\t\t\tfrom source.force to target.force;\n\t\t}\n\t\t\n\t\tinterface connectionStatus connect vehicle.vehicleFrame.hitchBall.connectionStatePort to trailer.trailerFrame.trailerCoupler.connectionStatePort {\n\t\t\tref flow references powerCoupling.connectionFlow\n\t\t\t\tfrom source.connectionState to target.connectionState;\n\t\t}\n\t\t\n\t\tpart user {\n\t\t\tperform powerCoupling.initiateConnection;\n\t\t\tperform powerCoupling.initiateDisconnection;\n\t\t}\n\t}\n\t\n\taction powerCoupling {\n\t\taction initiateConnection {\n\t\t\tout connectionState : ConnectionState;\n\t\t}\n\t\t\n\t\taction initiateDisconnection {\n\t\t\tout connectionState : ConnectionState;\n\t\t}\n\t\t\n\t\tflow connectionFlow from initiateConnection.connectionState to maintainConnection.connectionState;\n\t\tflow connectionFlow from initiateDisconnection.connectionState to maintainConnection.connectionState;\n\t\t\n\t\taction maintainConnection {\n\t\t\tin connectionState : ConnectionState;\n\t\t\tinout force : Force;\n\t\t}\n\t\t\n\t\tflow forceTransmission from maintainConnection.force to maintainConnection.force;\n\t}\n}",
    "package 'VehicleTrailerConnection' {\n\tattribute def ConnectionCmd;\n\tattribute def ConnectionStatus;\n\t\n\tport def ConnectionCmdPort {\n\t\tout connectionCmd : ConnectionCmd;\n\t}\n\t\n\tport def ConnectionStatusPort {\n\t\tout connectionStatus : ConnectionStatus;\n\t}\n\t\n\tpart def TowBall;\n\tpart def Coupler;\n\t\n\tpart context {\n\t\tpart user {\n\t\t\tport connectionCmdPort : ConnectionCmdPort;\n\t\t\tperform manageConnection.sendConnectionCmd {\n\t\t\t\tout connectionCmd = connectionCmdPort.connectionCmd;\n\t\t\t}\n\t\t}\n\t\t\n\t\tinterface userToVehicle connect user.connectionCmdPort to vehicle.connectionCmdPort {\n\t\t\tref flow references manageConnection.connectionCmdFlow\n\t\t\t\tfrom source.connectionCmd to target.connectionCmd;\n\t\t}\n\t\t\n\t\tpart vehicle {\n\t\t\tpart chassis {\n\t\t\t\tpart towBall : TowBall;\n\t\t\t}\n\t\t\tport connectionCmdPort : ~ConnectionCmdPort;\n\t\t\tport connectionStatusPort : ConnectionStatusPort;\n\t\t\tperform manageConnection.executeConnection {\n\t\t\t\tin connectionCmd = connectionCmdPort.connectionCmd;\n\t\t\t\tout connectionStatus = connectionStatusPort.connectionStatus;\n\t\t\t}\n\t\t}\n\t\t\n\t\tinterface vehicleToTrailer connect vehicle.connectionStatusPort to trailer.connectionStatusPort {\n\t\t\tref flow references manageConnection.connectionStatusFlow\n\t\t\t\tfrom source.connectionStatus to target.connectionStatus;\n\t\t}\n\t\t\n\t\tpart trailer {\n\t\t\tpart trailerFrame {\n\t\t\t\tpart coupler : Coupler;\n\t\t\t}\n\t\t\tport connectionStatusPort : ~ConnectionStatusPort;\n\t\t\tperform manageConnection.updateConnectionState {\n\t\t\t\tin connectionStatus = connectionStatusPort.connectionStatus;\n\t\t\t}\n\t\t}\n\t}\n\t\n\taction manageConnection {\n\t\taction sendConnectionCmd { out connectionCmd : ConnectionCmd; }\n\t\tsuccession flow connectionCmdFlow from sendConnectionCmd.connectionCmd to executeConnection.connectionCmd;\n\t\taction executeConnection { in connectionCmd; out connectionStatus : ConnectionStatus; }\n\t\tsuccession flow connectionStatusFlow from executeConnection.connectionStatus to updateConnectionState.connectionStatus;\n\t\taction updateConnectionState { in connectionStatus : ConnectionStatus; }\n\t}\n}",
    "package 'VehicleTrailerConnection' {\n\tattribute def HitchCmd;\n\tattribute def UnhitchCmd;\n\tattribute def LatchStatus;\n\t\n\tport def HitchCmdPort {\n\t\tout hitchCmd : HitchCmd;\n\t}\n\t\n\tport def UnhitchCmdPort {\n\t\tout unhitchCmd : UnhitchCmd;\n\t}\n\t\n\tport def LatchStatusPort {\n\t\tout latchStatus : LatchStatus;\n\t}\n\t\n\tpart context {\n\t\tpart user {\n\t\t\tport hitchCmdPort : HitchCmdPort;\n\t\t\tport unhitchCmdPort : UnhitchCmdPort;\n\t\t\t\n\t\t\tperform trailerOperation.sendHitchCmd {\n\t\t\t\tout hitchCmd = hitchCmdPort.hitchCmd;\n\t\t\t}\n\t\t\t\n\t\t\tperform trailerOperation.sendUnhitchCmd {\n\t\t\t\tout unhitchCmd = unhitchCmdPort.unhitchCmd;\n\t\t\t}\n\t\t}\n\t\t\n\t\tpart vehicle {\n\t\t\tpart chassis {\n\t\t\t\tpart towBall {\n\t\t\t\t\tport latchStatusPort : ~LatchStatusPort;\n\t\t\t\t\t\n\t\t\t\t\tperform trailerOperation.provideLatchPoint {\n\t\t\t\t\t\tin latchStatus = latchStatusPort.latchStatus;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t\n\t\tpart trailer {\n\t\t\tpart trailerChassis {\n\t\t\t\tpart couplerMechanism {\n\t\t\t\t\tport hitchCmdPort : ~HitchCmdPort;\n\t\t\t\t\tport unhitchCmdPort : ~UnhitchCmdPort;\n\t\t\t\t\tport latchStatusPort : LatchStatusPort;\n\t\t\t\t\t\n\t\t\t\t\tperform trailerOperation.engageWithTowBall {\n\t\t\t\t\t\tin hitchCmd = hitchCmdPort.hitchCmd;\n\t\t\t\t\t\tout latchStatus = latchStatusPort.latchStatus;\n\t\t\t\t\t}\n\t\t\t\t\t\n\t\t\t\t\tperform trailerOperation.disengageFromTowBall {\n\t\t\t\t\t\tin unhitchCmd = unhitchCmdPort.unhitchCmd;\n\t\t\t\t\t\tout latchStatus = latchStatusPort.latchStatus;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t\n\t\tinterface userToTrailer connect user.hitchCmdPort to trailer.trailerChassis.couplerMechanism.hitchCmdPort {\n\t\t\tref flow references trailerOperation.hitchCmdFlow\n\t\t\t\tfrom source.hitchCmd to target.hitchCmd;\n\t\t}\n\t\t\n\t\tinterface userToTrailerUnhitch connect user.unhitchCmdPort to trailer.trailerChassis.couplerMechanism.unhitchCmdPort {\n\t\t\tref flow references trailerOperation.unhitchCmdFlow\n\t\t\t\tfrom source.unhitchCmd to target.unhitchCmd;\n\t\t}\n\t\t\n\t\tinterface trailerToVehicle connect trailer.trailerChassis.couplerMechanism.latchStatusPort to vehicle.chassis.towBall.latchStatusPort {\n\t\t\tref flow references trailerOperation.latchStatusFlow\n\t\t\t\tfrom source.latchStatus to target.latchStatus;\n\t\t}\n\t}\n\t\n\taction trailerOperation {\n\t\taction sendHitchCmd { out hitchCmd : HitchCmd; }\n\t\tsuccession flow hitchCmdFlow from sendHitchCmd.hitchCmd to engageWithTowBall.hitchCmd;\n\t\t\n\t\taction engageWithTowBall { in hitchCmd : HitchCmd; out latchStatus : LatchStatus; }\n\t\tsuccession flow latchStatusFlow from engageWithTowBall.latchStatus to provideLatchPoint.latchStatus;\n\t\t\n\t\taction provideLatchPoint { in latchStatus : LatchStatus; }\n\t\t\n\t\taction sendUnhitchCmd { out unhitchCmd : UnhitchCmd; }\n\t\tsuccession flow unhitchCmdFlow from sendUnhitchCmd.unhitchCmd to disengageFromTowBall.unhitchCmd;\n\t\t\n\t\taction disengageFromTowBall { in unhitchCmd : UnhitchCmd; out latchStatus : LatchStatus; }\n\t}\n}",
    "package 'FuelSystem' {\n\tattribute def Fuel;\n\tattribute def Temperature;\n\t\n\tport def FuelSupplyPort {\n\t\tout fuel : Fuel;\n\t\tout temperature : Temperature;\n\t}\n\t\n\tport def FuelReturnPort {\n\t\tin fuel : Fuel;\n\t\tin temperature : Temperature;\n\t}\n\t\n\tpart def FuelTankAssembly {\n\t\tport fuelSupplyPort : FuelSupplyPort;\n\t\tport fuelReturnPort : FuelReturnPort;\n\t\t\n\t\tperform fuelCirculation.supplyFuel {\n\t\t\tout fuel = fuelSupplyPort.fuel;\n\t\t\tout temperature = fuelSupplyPort.temperature;\n\t\t}\n\t\t\n\t\tperform fuelCirculation.receiveFuel {\n\t\t\tin fuel = fuelReturnPort.fuel;\n\t\t\tin temperature = fuelReturnPort.temperature;\n\t\t}\n\t}\n\t\n\tpart def Engine {\n\t\tport fuelSupplyPort : ~FuelSupplyPort;\n\t\tport fuelReturnPort : ~FuelReturnPort;\n\t\t\n\t\tperform fuelCirculation.consumeFuel {\n\t\t\tin fuel = fuelSupplyPort.fuel;\n\t\t\tin temperature = fuelSupplyPort.temperature;\n\t\t\tout returnFuel = fuelReturnPort.fuel;\n\t\t\tout returnTemperature = fuelReturnPort.temperature;\n\t\t}\n\t}\n\t\n\tpart motorVehicle {\n\t\tpart fuelTank : FuelTankAssembly;\n\t\tpart engine : Engine;\n\t\t\n\t\tinterface fuelSupplyInterface connect fuelTank.fuelSupplyPort to engine.fuelSupplyPort {\n\t\t\tref flow references fuelCirculation.fuelSupplyFlow\n\t\t\t\tfrom source.fuel to target.fuel;\n\t\t\tref flow references fuelCirculation.tempSupplyFlow\n\t\t\t\tfrom source.temperature to target.temperature;\n\t\t}\n\t\t\n\t\tinterface fuelReturnInterface connect engine.fuelReturnPort to fuelTank.fuelReturnPort {\n\t\t\tref flow references fuelCirculation.fuelReturnFlow\n\t\t\t\tfrom source.fuel to target.fuel;\n\t\t\tref flow references fuelCirculation.tempReturnFlow\n\t\t\t\tfrom source.temperature to target.temperature;\n\t\t}\n\t}\n\t\n\taction fuelCirculation {\n\t\taction supplyFuel { out fuel : Fuel; out temperature : Temperature; }\n\t\tsuccession flow fuelSupplyFlow from supplyFuel.fuel to consumeFuel.fuel;\n\t\tsuccession flow tempSupplyFlow from supplyFuel.temperature to consumeFuel.temperature;\n\t\t\n\t\taction consumeFuel { \n\t\t\tin fuel : Fuel; \n\t\t\tin temperature : Temperature;\n\t\t\tout returnFuel : Fuel;\n\t\t\tout returnTemperature : Temperature;\n\t\t}\n\t\tsuccession flow fuelReturnFlow from consumeFuel.returnFuel to receiveFuel.fuel;\n\t\tsuccession flow tempReturnFlow from consumeFuel.returnTemperature to receiveFuel.temperature;\n\t\t\n\t\taction receiveFuel { in fuel : Fuel; in temperature : Temperature; }\n\t}\n}",
    "package 'FuelDeliverySystem' {\n\tattribute def Fuel;\n\tattribute def FuelLevel;\n\tattribute def MaxCapacity;\n\t\n\tport def FuelOutPort {\n\t\tout fuel: Fuel;\n\t}\n\t\n\tport def FuelInPort {\n\t\tin fuel: Fuel;\n\t}\n\t\n\tport def FuelTransferPort {\n\t\tin fuelIn: Fuel;\n\t\tout fuelOut: Fuel;\n\t}\n\t\n\tpart context {\n\t\tpart storageTank {\n\t\t\tport fuelOutPort: FuelOutPort;\n\t\t\tperform fuelDelivery.storeFuel {\n\t\t\t\tout fuel = fuelOutPort.fuel;\n\t\t\t}\n\t\t}\n\t\t\n\t\tinterface storageTankToPump connect storageTank.fuelOutPort to fuelPump.fuelInPort {\n\t\t\tref flow references fuelDelivery.storageToPumpFlow\n\t\t\t\tfrom source.fuel to target.fuel;\n\t\t}\n\t\t\n\t\tpart fuelPump {\n\t\t\tport fuelInPort: FuelInPort;\n\t\t\tport fuelOutPort: FuelOutPort;\n\t\t\tperform fuelDelivery.pumpFuel {\n\t\t\t\tin fuel = fuelInPort.fuel;\n\t\t\t\tout fuel = fuelOutPort.fuel;\n\t\t\t}\n\t\t}\n\t\t\n\t\tinterface pumpToVehicle connect fuelPump.fuelOutPort to vehicle.fuelInPort {\n\t\t\tref flow references fuelDelivery.pumpToVehicleFlow\n\t\t\t\tfrom source.fuel to target.fuel;\n\t\t}\n\t\t\n\t\tpart vehicle {\n\t\t\tpart fuelTank {\n\t\t\t\tattribute currentLevel: FuelLevel;\n\t\t\t\tattribute maxCapacity: MaxCapacity;\n\t\t\t\tport fuelInPort: FuelInPort;\n\t\t\t\tperform fuelDelivery.receiveFuel {\n\t\t\t\t\tin fuel = fuelInPort.fuel;\n\t\t\t\t}\n\t\t\t}\n\t\t\tport fuelInPort: FuelInPort = fuelTank.fuelInPort;\n\t\t}\n\t}\n\t\n\taction fuelDelivery {\n\t\taction storeFuel { out fuel: Fuel; }\n\t\tsuccession flow storageToPumpFlow from storeFuel.fuel to pumpFuel.fuel;\n\t\taction pumpFuel { in fuel: Fuel; out fuel: Fuel; }\n\t\tsuccession flow pumpToVehicleFlow from pumpFuel.fuel to receiveFuel.fuel;\n\t\taction receiveFuel { in fuel: Fuel; }\n\t}\n}",
    "package 'AutomobileAssembly' {\n\tpart def VehicleAssembly;\n\tpart def Gearbox;\n\tpart def Engine;\n\tpart def VehicleWithoutEngine;\n\tpart def CompleteVehicle;\n\t\n\taction def InstallGearbox {\n\t\tin vehicleAssembly : VehicleAssembly;\n\t\tin gearbox : Gearbox;\n\t\tout vehicleWithoutEngine : VehicleWithoutEngine;\n\t}\n\t\n\taction def InstallEngine {\n\t\tin vehicleWithoutEngine : VehicleWithoutEngine;\n\t\tin engine : Engine;\n\t\tout completeVehicle : CompleteVehicle;\n\t}\n\t\n\tpart assemblyLine {\n\t\tpart initialAssembly : VehicleAssembly;\n\t\tpart gearboxUnit : Gearbox;\n\t\tpart engineUnit : Engine;\n\t\t\n\t\tperform assembleVehicle {\n\t\t\taction installGearbox : InstallGearbox {\n\t\t\t\tin vehicleAssembly = initialAssembly;\n\t\t\t\tin gearbox = gearboxUnit;\n\t\t\t\tout vehicleWithoutEngine;\n\t\t\t}\n\t\t\t\n\t\t\tflow from installGearbox.vehicleWithoutEngine to installEngine.vehicleWithoutEngine;\n\t\t\t\n\t\t\taction installEngine : InstallEngine {\n\t\t\t\tin vehicleWithoutEngine;\n\t\t\t\tin engine = engineUnit;\n\t\t\t\tout completeVehicle;\n\t\t\t}\n\t\t\t\n\t\t\tout finalVehicle = installEngine.completeVehicle;\n\t\t}\n\t\t\n\t\tpart finalVehicle : CompleteVehicle {\n\t\t\tpart gearbox : Gearbox;\n\t\t\tpart engine : Engine;\n\t\t}\n\t}\n}",
    "package 'VehicleControlSystem' {\n    attribute def StartSignal;\n    attribute def BrakePedalSignal;\n    attribute def VehicleOnSignal;\n    attribute def Temperature;\n    attribute def OverTempSignal;\n    attribute def RestoreSignal;\n    attribute def ShutdownSignal;\n    attribute def PowerSupply;\n    attribute def ParkingBrakeSignal;\n    \n    port def ControlSignalPort {\n        in startSignal: StartSignal;\n        in brakePedalSignal: BrakePedalSignal;\n        in vehicleOnSignal: VehicleOnSignal;\n        in restoreSignal: RestoreSignal;\n        in shutdownSignal: ShutdownSignal;\n    }\n    \n    port def HealthMonitorPort {\n        out temperature: Temperature;\n        out overTempSignal: OverTempSignal;\n    }\n    \n    port def ActuatorPort {\n        out powerSupply: PowerSupply;\n        out parkingBrakeSignal: ParkingBrakeSignal;\n    }\n    \n    part def VehicleA {\n        port controlPort: ControlSignalPort;\n        port healthPort: HealthMonitorPort;\n        port actuatorPort: ActuatorPort;\n        \n        exhibit state vehicleStates {\n            entry state off;\n            state starting;\n            state running {\n                entry action {\n                    perform selfCheck;\n                    perform supplyPower;\n                }\n                exit action {\n                    perform applyParkingBrake;\n                }\n            }\n            \n            transition off_to_starting\n                first off\n                accept controlPort.brakePedalSignal\n                accept controlPort.startSignal\n                then starting;\n                \n            transition starting_to_running\n                first starting\n                accept controlPort.vehicleOnSignal\n                then running;\n                \n            transition running_to_off\n                first running\n                accept controlPort.shutdownSignal\n                then off;\n        }\n        \n        exhibit state healthStates parallel {\n            state normal;\n            state degraded;\n            state maintenance;\n            \n            transition normal_to_degraded\n                first normal\n                when temperature > safetyThreshold\n                do send overTempSignal to healthPort.overTempSignal\n                then degraded;\n                \n            transition degraded_to_normal\n                first degraded\n                accept controlPort.restoreSignal\n                then normal;\n                \n            transition maintenance_to_normal\n                first maintenance\n                accept controlPort.restoreSignal\n                then normal;\n        }\n        \n        action selfCheck;\n        action supplyPower {\n            out powerSupply = actuatorPort.powerSupply;\n        }\n        action applyParkingBrake {\n            out parkingBrakeSignal = actuatorPort.parkingBrakeSignal;\n        }\n        action monitorTemperature {\n            out temperature = healthPort.temperature;\n        }\n        \n        attribute safetyThreshold: Temperature;\n        attribute temperature: Temperature;\n    }\n    \n    part def VehicleController {\n        port controlOutPort: ~ControlSignalPort;\n        port healthInPort: ~HealthMonitorPort;\n        \n        exhibit state controllerStates {\n            state idle;\n            state active;\n            state emergency;\n            \n            transition idle_to_active\n                first idle\n                do send startSignal to controlOutPort.startSignal\n                then active;\n                \n            transition active_to_emergency\n                first active\n                accept healthInPort.overTempSignal\n                then emergency;\n                \n            transition active_to_idle\n                first active\n                do send shutdownSignal to controlOutPort.shutdownSignal\n                then idle;\n        }\n    }\n    \n    part context {\n        part vehicleA: VehicleA;\n        part controller: VehicleController;\n        \n        interface controlInterface connect controller.controlOutPort to vehicleA.controlPort;\n        interface healthInterface connect vehicleA.healthPort to controller.healthInPort;\n    }\n}",
    "package 'VehicleSystem' {\n    attribute def StartSignal;\n    attribute def BrakePedalSignal;\n    attribute def Temperature;\n    attribute def WarningSignal;\n    attribute def HealthStatus;\n    attribute def Fuel;\n    attribute def MaintenanceInterval;\n    attribute def TemperatureThreshold;\n    \n    port def ControlSignalPort {\n        in startSignal: StartSignal;\n        in brakePedalSignal: BrakePedalSignal;\n    }\n    \n    port def StatusSignalPort {\n        out warningSignal: WarningSignal;\n        out healthStatus: HealthStatus;\n    }\n    \n    port def SensorDataPort {\n        in temperature: Temperature;\n    }\n    \n    part def Vehicle {\n        attribute fuel: Fuel;\n        attribute maintenanceInterval: MaintenanceInterval;\n        attribute temperatureThreshold: TemperatureThreshold;\n        \n        port controlPort: ControlSignalPort;\n        port statusPort: StatusSignalPort;\n        port sensorPort: SensorDataPort;\n        \n        state vehicleStates {\n            entry state shutdown;\n            state running;\n            state degraded;\n            \n            transition shutdown_to_running\n                first shutdown\n                accept controlPort.startSignal\n                if controlPort.brakePedalSignal\n                then running;\n                \n            transition running_to_degraded\n                first running\n                if sensorPort.temperature > temperatureThreshold\n                do send statusPort.warningSignal\n                then degraded;\n                \n            transition degraded_to_running\n                first degraded\n                if sensorPort.temperature <= temperatureThreshold\n                then running;\n        }\n    }\n    \n    part def VehicleController {\n        port controlOutPort: ~ControlSignalPort;\n        port statusInPort: ~StatusSignalPort;\n        \n        perform action processVehicleStatus {\n            in warningSignal = statusInPort.warningSignal;\n            in healthStatus = statusInPort.healthStatus;\n        }\n        \n        perform action sendControlSignals {\n            out startSignal = controlOutPort.startSignal;\n            out brakePedalSignal = controlOutPort.brakePedalSignal;\n        }\n    }\n    \n    part vehicleSystem {\n        part vehicle: Vehicle;\n        part controller: VehicleController;\n        \n        interface controlInterface connect controller.controlOutPort to vehicle.controlPort;\n        interface statusInterface connect vehicle.statusPort to controller.statusInPort;\n        \n        perform action manageVehicleOperation {\n            action startup {\n                in brakePedalSignal: BrakePedalSignal;\n                in startSignal: StartSignal;\n            }\n            \n            action monitorTemperature {\n                in temperature: Temperature;\n                out warningSignal: WarningSignal;\n            }\n            \n            action performMaintenance {\n                in healthStatus: HealthStatus;\n            }\n            \n            succession flow startupFlow from startup to monitorTemperature;\n            succession flow monitorFlow from monitorTemperature to performMaintenance;\n        }\n    }\n}",
    "package 'VehicleSimulation' {\n    attribute def Mass;\n    attribute def Position;\n    attribute def Velocity;\n    attribute def Acceleration;\n    attribute def Angle;\n    attribute def FrictionCoefficient;\n    attribute def Time;\n    attribute def VehicleState;\n    attribute def SimulationParameters {\n        mass: Mass;\n        position: Position;\n        velocity: Velocity;\n        acceleration: Acceleration;\n    }\n    attribute def RoadParameters {\n        slope: Angle;\n        friction: FrictionCoefficient;\n    }\n    attribute def Snapshot {\n        time: Time;\n        vehicleState: VehicleState;\n        position: Position;\n        velocity: Velocity;\n        acceleration: Acceleration;\n    }\n    \n    port def SimulationInputPort {\n        in simulationParams: SimulationParameters;\n        in roadParams: RoadParameters;\n    }\n    port def SnapshotOutputPort {\n        out snapshot: Snapshot;\n    }\n    \n    part context {\n        part user {\n            port simulationInputPort: SimulationInputPort;\n            perform spatiotemporalSimulation.defineParameters {\n                out simulationParams = simulationInputPort.simulationParams;\n                out roadParams = simulationInputPort.roadParams;\n            }\n        }\n        \n        interface userToSimulator connect user.simulationInputPort to simulator.simulationInputPort {\n            ref flow references spatiotemporalSimulation.simulationParamsFlow\n                from source.simulationParams to target.simulationParams;\n            ref flow references spatiotemporalSimulation.roadParamsFlow\n                from source.roadParams to target.roadParams;\n        }\n        \n        part simulator {\n            port simulationInputPort: ~SimulationInputPort;\n            port snapshotOutputPort: SnapshotOutputPort;\n            \n            perform spatiotemporalSimulation.simulateVehicleDynamics {\n                in simulationParams = simulationInputPort.simulationParams;\n                in roadParams = simulationInputPort.roadParams;\n                out snapshot = snapshotOutputPort.snapshot;\n            }\n        }\n        \n        part dataRecorder {\n            port snapshotOutputPort: ~SnapshotOutputPort;\n            perform spatiotemporalSimulation.recordSnapshots {\n                in snapshot = snapshotOutputPort.snapshot;\n            }\n        }\n        \n        interface simulatorToRecorder connect simulator.snapshotOutputPort to dataRecorder.snapshotOutputPort {\n            ref flow references spatiotemporalSimulation.snapshotFlow\n                from source.snapshot to target.snapshot;\n        }\n    }\n    \n    action spatiotemporalSimulation {\n        action defineParameters {\n            out simulationParams: SimulationParameters;\n            out roadParams: RoadParameters;\n        }\n        succession flow simulationParamsFlow from defineParameters.simulationParams to simulateVehicleDynamics.simulationParams;\n        succession flow roadParamsFlow from defineParameters.roadParams to simulateVehicleDynamics.roadParams;\n        \n        action simulateVehicleDynamics {\n            in simulationParams: SimulationParameters;\n            in roadParams: RoadParameters;\n            out snapshot: Snapshot;\n        }\n        succession flow snapshotFlow from simulateVehicleDynamics.snapshot to recordSnapshots.snapshot;\n        \n        action recordSnapshots {\n            in snapshot: Snapshot;\n        }\n    }\n}",
    "package 'AutomotiveConfigurationManagement' {\n    part def Component1;\n    part def Component2;\n    part def Component3;\n    part def Component4;\n    part def Component5;\n    part def Component6;\n    \n    part def SubsystemA {\n        variant part config1 {\n            part component1: Component1;\n            part component2: Component2;\n        }\n        variant part config2 {\n            part component2: Component2;\n            part component3: Component3;\n        }\n    }\n    \n    part def SubsystemB {\n        variant part config1 {\n            part component4: Component4;\n            part component5: Component5;\n        }\n        variant part config2 {\n            part component5: Component5;\n            part component6: Component6;\n        }\n    }\n    \n    part def Automobile {\n        part subsystemA: SubsystemA[0..1];\n        part subsystemB: SubsystemB[0..1];\n        \n        constraint configurationConstraint {\n            (subsystemA.config2 == null) or (subsystemB.config2 != null);\n        }\n    }\n    \n    part configurationA: Automobile {\n        part :>> subsystemA {\n            part :>> config1;\n        }\n        part :>> subsystemB {\n            part :>> config1;\n        }\n    }\n    \n    part configurationB: Automobile {\n        part :>> subsystemA {\n            part :>> config2;\n        }\n        part :>> subsystemB {\n            part :>> config1;\n        }\n    }\n}",
    "package 'ModularVehiclePlatform' {\n    part def Part1;\n    part def Part2;\n    part def Part3 {\n        port p1;\n    }\n    part def Part4;\n    part def Part5 {\n        port p2;\n        variant action behaviorVariant1;\n        variant action behaviorVariant2;\n    }\n    part def Part6;\n    \n    abstract part def SubsystemA {\n        abstract part components[*];\n        abstract port subsystemPortA;\n    }\n    \n    abstract part def SubsystemB {\n        abstract part components[*];\n        abstract port subsystemPortB;\n    }\n    \n    part def SubsystemAVariant1 :> SubsystemA {\n        part components[2] {\n            part component1 : Part1;\n            part component2 : Part3;\n        }\n    }\n    \n    part def SubsystemAVariant2 :> SubsystemA {\n        part components[3] {\n            part component1 : Part2;\n            part component2 : Part4;\n            part component3 : Part5;\n        }\n    }\n    \n    part def SubsystemBVariant1 :> SubsystemB {\n        part components[2] {\n            part component1 : Part4;\n            part component2 : Part6;\n        }\n    }\n    \n    part def SubsystemBVariant2 :> SubsystemB {\n        part components[3] {\n            part component1 : Part3;\n            part component2 : Part5;\n            part component3 : Part6;\n        }\n    }\n    \n    part def VehicleConfiguration {\n        abstract part subsystemA : SubsystemA;\n        abstract part subsystemB : SubsystemB;\n        interface subsystemInterface connect subsystemA.subsystemPortA to subsystemB.subsystemPortB;\n    }\n    \n    part def VehicleConfigA :> VehicleConfiguration {\n        part subsystemA : SubsystemAVariant1;\n        part subsystemB : SubsystemBVariant1;\n    }\n    \n    part def VehicleConfigB :> VehicleConfiguration {\n        part subsystemA : SubsystemAVariant2;\n        part subsystemB : SubsystemBVariant2;\n    }\n    \n    constraint def ConfigurationConsistency {\n        doc /* Ensures configuration consistency and rationality */\n    }\n    \n    allocation def ComponentAllocation {\n        end feature components : Part1[*];\n        end feature subsystems : SubsystemA[*];\n    }\n}",
    "package 'VehicleProductLine' {\n    attribute def PerformanceLevel;\n    attribute def EngineType;\n    attribute def TransmissionType;\n    attribute def WheelType;\n    attribute def ConfigurationRequest;\n    attribute def VehicleConfiguration;\n    \n    port def ConfigRequestPort {\n        in configRequest : ConfigurationRequest;\n    }\n    \n    port def VehicleConfigPort {\n        out vehicleConfig : VehicleConfiguration;\n    }\n    \n    part def Engine {\n        attribute cylinders : Integer;\n        attribute engineType : EngineType;\n    }\n    \n    part def Transmission {\n        attribute transmissionType : TransmissionType;\n    }\n    \n    part def Wheel {\n        attribute rimType : String;\n        attribute wheelType : WheelType;\n    }\n    \n    part context {\n        part customer {\n            port configRequestPort : ConfigRequestPort;\n            perform configureVehicle.specifyRequirements {\n                out configRequest = configRequestPort.configRequest;\n            }\n        }\n        \n        interface customerToConfigurator connect customer.configRequestPort to configurator.configRequestPort {\n            ref flow references configureVehicle.configRequestFlow\n                from source.configRequest to target.configRequest;\n        }\n        \n        part configurator {\n            port configRequestPort : ~ConfigRequestPort;\n            port vehicleConfigPort : VehicleConfigPort;\n            \n            perform configureVehicle.selectComponents {\n                in configRequest = configRequestPort.configRequest;\n                out vehicleConfig = vehicleConfigPort.vehicleConfig;\n            }\n            \n            constraint highPerformanceConfig {\n                doc /* When high performance is required, configure 6-cylinder engine, \n                       automatic transmission, and wide-rim wheels */\n            }\n            \n            constraint standardPerformanceConfig {\n                doc /* For standard performance, configure 4-cylinder engine, \n                       manual transmission, and narrow-rim wheels */\n            }\n            \n            constraint compatibilityConstraints {\n                doc /* Ensure compatibility among engine, transmission, and wheels */\n            }\n        }\n        \n        interface configuratorToVehicle connect configurator.vehicleConfigPort to vehicle.vehicleConfigPort {\n            ref flow references configureVehicle.vehicleConfigFlow\n                from source.vehicleConfig to target.vehicleConfig;\n        }\n        \n        part vehicle {\n            port vehicleConfigPort : ~VehicleConfigPort;\n            \n            part engine : Engine;\n            part transmission : Transmission;\n            part wheels : Wheel[4];\n            \n            perform configureVehicle.assembleVehicle {\n                in vehicleConfig = vehicleConfigPort.vehicleConfig;\n            }\n        }\n    }\n    \n    action configureVehicle {\n        action specifyRequirements { out configRequest : ConfigurationRequest; }\n        succession flow configRequestFlow from specifyRequirements.configRequest to selectComponents.configRequest;\n        action selectComponents { in configRequest; out vehicleConfig : VehicleConfiguration; }\n        succession flow vehicleConfigFlow from selectComponents.vehicleConfig to assembleVehicle.vehicleConfig;\n        action assembleVehicle { in vehicleConfig : VehicleConfiguration; }\n    }\n}",
    "package 'VehicleManagementSystem' {\n    attribute def Mass;\n    attribute def FuelStatus;\n    attribute def Torque;\n    attribute def Reliability;\n    \n    enum def MassGrade {\n        enum mass2000kg;\n        enum mass2500kg;\n    }\n    \n    enum def FuelState {\n        enum fullyFueled;\n        enum emptyFuel;\n    }\n    \n    requirement def VehicleMassRequirement {\n        doc /* Vehicle must reflect actual mass and comply with maximum mass limitations */\n        attribute massGrade: MassGrade;\n        attribute maxMass: Mass;\n    }\n    \n    requirement def FuelStatusRequirement {\n        doc /* Vehicle must meet mass requirements based on fuel state */\n        attribute requiredFuelState: FuelState;\n    }\n    \n    requirement def PowerDeliveryRequirement {\n        doc /* Engine must output torque and connect to transmission */\n        attribute minTorque: Torque;\n    }\n    \n    requirement def ReliabilityRequirement {\n        doc /* Vehicle must maintain performance throughout lifecycle */\n        attribute reliabilityTarget: Reliability;\n    }\n    \n    port def TorquePort {\n        out torque: Torque;\n    }\n    \n    interface def DriveInterface {\n        end engineEnd: TorquePort;\n        end transmissionEnd: ~TorquePort;\n    }\n    \n    part def Engine {\n        port torqueOut: TorquePort;\n        attribute outputTorque: Torque;\n        \n        perform action produceTorque {\n            out torque = torqueOut.torque;\n        }\n    }\n    \n    part def Transmission {\n        port torqueIn: ~TorquePort;\n        \n        perform action receiveTorque {\n            in torque = torqueIn.torque;\n        }\n    }\n    \n    part def Vehicle {\n        attribute actualMass: Mass;\n        attribute fuelStatus: FuelState;\n        attribute reliability: Reliability;\n        \n        part engine: Engine;\n        part transmission: Transmission;\n        \n        interface driveConnection: DriveInterface connect \n            engine.torqueOut to transmission.torqueIn;\n            \n        satisfy massReq: VehicleMassRequirement;\n        satisfy fuelReq: FuelStatusRequirement;\n        satisfy powerReq: PowerDeliveryRequirement;\n        satisfy reliabilityReq: ReliabilityRequirement;\n    }\n    \n    part vehicleManagementContext {\n        part vehicle2000kg: Vehicle {\n            :>> actualMass = 2000;\n            :>> fuelStatus = FuelState::fullyFueled;\n        }\n        \n        part vehicle2500kg: Vehicle {\n            :>> actualMass = 2500;\n            :>> fuelStatus = FuelState::emptyFuel;\n        }\n    }\n}",
    "package 'VehicleMassCompliance' {\n\tattribute def Mass;\n\tattribute def ComplianceStatus;\n\tattribute def MaxPermissibleMass;\n\t\n\tport def VehiclePort {\n\t\tin vehicle : Vehicle;\n\t}\n\t\n\tport def MassPort {\n\t\tout mass : Mass;\n\t}\n\t\n\tport def CompliancePort {\n\t\tout status : ComplianceStatus;\n\t}\n\t\n\tpart def Vehicle {\n\t\tattribute actualMass : Mass;\n\t}\n\t\n\tpart context {\n\t\tpart testOperator {\n\t\t\tport vehiclePort : VehiclePort;\n\t\t\tport massPort : ~MassPort;\n\t\t\t\n\t\t\tperform verifyCompliance.measureMass {\n\t\t\t\tin vehicle = vehiclePort.vehicle;\n\t\t\t\tout mass = massPort.mass;\n\t\t\t}\n\t\t}\n\t\t\n\t\tpart weighingEquipment {\n\t\t\tport vehiclePort : ~VehiclePort;\n\t\t\tport massPort : MassPort;\n\t\t}\n\t\t\n\t\tinterface operatorToEquipment connect testOperator.vehiclePort to weighingEquipment.vehiclePort {\n\t\t\tref flow references verifyCompliance.vehicleFlow\n\t\t\t\tfrom source.vehicle to target.vehicle;\n\t\t}\n\t\t\n\t\tinterface equipmentToOperator connect weighingEquipment.massPort to testOperator.massPort {\n\t\t\tref flow references verifyCompliance.massFlow\n\t\t\t\tfrom source.mass to target.mass;\n\t\t}\n\t\t\n\t\tpart complianceSystem {\n\t\t\tattribute maxPermissibleMass : MaxPermissibleMass = 2500;\n\t\t\tport massPort : ~MassPort;\n\t\t\tport compliancePort : CompliancePort;\n\t\t\t\n\t\t\tperform verifyCompliance.determineCompliance {\n\t\t\t\tin mass = massPort.mass;\n\t\t\t\tin maxMass = maxPermissibleMass;\n\t\t\t\tout status = compliancePort.status;\n\t\t\t}\n\t\t}\n\t\t\n\t\tinterface operatorToSystem connect testOperator.massPort to complianceSystem.massPort {\n\t\t\tref flow references verifyCompliance.massToSystemFlow\n\t\t\t\tfrom source.mass to target.mass;\n\t\t}\n\t}\n\t\n\taction verifyCompliance {\n\t\taction measureMass { \n\t\t\tin vehicle : Vehicle; \n\t\t\tout mass : Mass;\n\t\t}\n\t\t\n\t\tsuccession flow vehicleFlow from measureMass.vehicle to measureMass;\n\t\tsuccession flow massFlow from measureMass.mass to measureMass;\n\t\tsuccession flow massToSystemFlow from measureMass.mass to determineCompliance.mass;\n\t\t\n\t\taction determineCompliance { \n\t\t\tin mass : Mass;\n\t\t\tin maxMass : MaxPermissibleMass;\n\t\t\tout status : ComplianceStatus;\n\t\t}\n\t}\n}",
    "package 'WaterSupplyNetwork' {\n\tattribute def HotWater;\n\tattribute def ColdWater;\n\t\n\tport def HotWaterPort {\n\t\tout hotWater: HotWater;\n\t}\n\t\n\tport def ColdWaterPort {\n\t\tout coldWater: ColdWater;\n\t}\n\t\n\tport def FaucetInlet {\n\t\tin hotWater: HotWater;\n\t\tin coldWater: ColdWater;\n\t}\n\t\n\tpart def Spigot {\n\t\tport hotWaterOut: HotWaterPort;\n\t\tport coldWaterOut: ColdWaterPort;\n\t}\n\t\n\tpart def Faucet {\n\t\tport inlet: FaucetInlet;\n\t}\n\t\n\tpart def SpigotBank {\n\t\tpart hotSpigot: Spigot;\n\t\tpart coldSpigot: Spigot;\n\t}\n\t\n\tpart context {\n\t\tpart spigotBank: SpigotBank {\n\t\t\tperform supplyWater.provideHotWater {\n\t\t\t\tout hotWater = hotSpigot.hotWaterOut.hotWater;\n\t\t\t}\n\t\t\tperform supplyWater.provideColdWater {\n\t\t\t\tout coldWater = coldSpigot.coldWaterOut.coldWater;\n\t\t\t}\n\t\t}\n\t\t\n\t\tpart faucets: Faucet[1..*] {\n\t\t\tperform supplyWater.receiveWater {\n\t\t\t\tin hotWater = inlet.hotWater;\n\t\t\t\tin coldWater = inlet.coldWater;\n\t\t\t}\n\t\t}\n\t\t\n\t\tinterface hotWaterConnection connect spigotBank.hotSpigot.hotWaterOut to faucets.inlet {\n\t\t\tref flow references supplyWater.hotWaterFlow\n\t\t\t\tfrom source.hotWater to target.hotWater;\n\t\t}\n\t\t\n\t\tinterface coldWaterConnection connect spigotBank.coldSpigot.coldWaterOut to faucets.inlet {\n\t\t\tref flow references supplyWater.coldWaterFlow\n\t\t\t\tfrom source.coldWater to target.coldWater;\n\t\t}\n\t}\n\t\n\taction supplyWater {\n\t\taction provideHotWater { out hotWater: HotWater; }\n\t\taction provideColdWater { out coldWater: ColdWater; }\n\t\taction receiveWater { in hotWater: HotWater; in coldWater: ColdWater; }\n\t\t\n\t\tsuccession flow hotWaterFlow from provideHotWater.hotWater to receiveWater.hotWater;\n\t\tsuccession flow coldWaterFlow from provideColdWater.coldWater to receiveWater.coldWater;\n\t}\n}",
    "package 'VehicleQualityAnalysis' {\n    attribute def Mass;\n    attribute def QualityData;\n    attribute def AnalysisRequirement;\n    attribute def AnalysisObjective;\n    attribute def AnalysisTask;\n    attribute def AnalysisPlan;\n    attribute def QualityEvaluation;\n    \n    port def QualityDataPort {\n        in qualityData: QualityData;\n    }\n    \n    port def MassPort {\n        out mass: Mass;\n    }\n    \n    port def AnalysisPort {\n        in analysisRequirement: AnalysisRequirement;\n        in analysisObjective: AnalysisObjective;\n        out analysisTask: AnalysisTask;\n        out analysisPlan: AnalysisPlan;\n        out qualityEvaluation: QualityEvaluation;\n    }\n    \n    part def Component {\n        port qualityDataPort: QualityDataPort;\n        port massPort: MassPort;\n        attribute componentMass: Mass;\n    }\n    \n    part vehicle {\n        part engine: Component;\n        part transmission: Component;\n        part frontAxleAssembly: Component;\n        part rearAxleAssembly: Component;\n        \n        attribute totalMass: Mass;\n        \n        calc constraint {\n            totalMass == engine.componentMass + transmission.componentMass + \n                        frontAxleAssembly.componentMass + rearAxleAssembly.componentMass\n        }\n        \n        port vehicleQualityPort: QualityDataPort;\n        port vehicleMassPort: MassPort {\n            out mass = totalMass;\n        }\n    }\n    \n    part qualityAnalysisSystem {\n        port analysisPort: AnalysisPort;\n        \n        perform analyzeVehicleQuality {\n            in analysisRequirement = analysisPort.analysisRequirement;\n            in analysisObjective = analysisPort.analysisObjective;\n            out analysisTask = analysisPort.analysisTask;\n            out analysisPlan = analysisPort.analysisPlan;\n            out qualityEvaluation = analysisPort.qualityEvaluation;\n        }\n    }\n    \n    part user {\n        port qualityInputPort: ~QualityDataPort;\n        port analysisInputPort: ~AnalysisPort;\n        \n        perform inputQualityData {\n            out qualityData = qualityInputPort.qualityData;\n        }\n        \n        perform defineAnalysisRequirements {\n            out analysisRequirement = analysisInputPort.analysisRequirement;\n            out analysisObjective = analysisInputPort.analysisObjective;\n        }\n        \n        perform receiveAnalysisResults {\n            in analysisTask = analysisInputPort.analysisTask;\n            in analysisPlan = analysisInputPort.analysisPlan;\n            in qualityEvaluation = analysisInputPort.qualityEvaluation;\n        }\n    }\n    \n    interface userToVehicle connect user.qualityInputPort to vehicle.vehicleQualityPort;\n    interface userToEngine connect user.qualityInputPort to vehicle.engine.qualityDataPort;\n    interface userToTransmission connect user.qualityInputPort to vehicle.transmission.qualityDataPort;\n    interface userToFrontAxle connect user.qualityInputPort to vehicle.frontAxleAssembly.qualityDataPort;\n    interface userToRearAxle connect user.qualityInputPort to vehicle.rearAxleAssembly.qualityDataPort;\n    interface userToAnalysisSystem connect user.analysisInputPort to qualityAnalysisSystem.analysisPort;\n    \n    action analyzeVehicleQuality {\n        in analysisRequirement: AnalysisRequirement;\n        in analysisObjective: AnalysisObjective;\n        out analysisTask: AnalysisTask;\n        out analysisPlan: AnalysisPlan;\n        out qualityEvaluation: QualityEvaluation;\n    }\n}",
    "package 'PowertrainOptimization' {\n    attribute def PowerOutput;\n    attribute def Mass;\n    attribute def Efficiency;\n    attribute def Reliability;\n    attribute def Cost;\n    attribute def EngineConfig;\n    attribute def OptimalSolution;\n    attribute def PerformanceData;\n    attribute def TradeOffResult;\n    \n    port def ConfigRequestPort {\n        out configRequest : EngineConfig;\n    }\n    \n    port def PerformanceDataPort {\n        out performanceData : PerformanceData;\n    }\n    \n    port def OptimalSolutionPort {\n        out optimalSolution : OptimalSolution;\n    }\n    \n    port def TradeOffResultPort {\n        out tradeOffResult : TradeOffResult;\n    }\n    \n    part context {\n        part user {\n            port configRequestPort : ConfigRequestPort;\n            perform optimizePowertrain.requestOptimization {\n                out configRequest = configRequestPort.configRequest;\n            }\n        }\n        \n        interface userToSystem connect user.configRequestPort to optimizationSystem.configRequestPort {\n            ref flow references optimizePowertrain.configFlow\n                from source.configRequest to target.configRequest;\n        }\n        \n        part optimizationSystem {\n            port configRequestPort : ~ConfigRequestPort;\n            port performanceDataPort : PerformanceDataPort;\n            port tradeOffResultPort : TradeOffResultPort;\n            port optimalSolutionPort : OptimalSolutionPort;\n            \n            perform optimizePowertrain.modelEngineStructures {\n                in configRequest = configRequestPort.configRequest;\n                out performanceData = performanceDataPort.performanceData;\n            }\n            \n            perform optimizePowertrain.conductTradeOffAnalysis {\n                in performanceData = performanceDataPort.performanceData;\n                out tradeOffResult = tradeOffResultPort.tradeOffResult;\n            }\n            \n            perform optimizePowertrain.recommendOptimalSolution {\n                in tradeOffResult = tradeOffResultPort.tradeOffResult;\n                out optimalSolution = optimalSolutionPort.optimalSolution;\n            }\n        }\n        \n        interface systemToEngineModeler connect optimizationSystem.performanceDataPort to engineModeler.performanceDataPort {\n            ref flow references optimizePowertrain.performanceFlow\n                from source.performanceData to target.performanceData;\n        }\n        \n        part engineModeler {\n            port performanceDataPort : ~PerformanceDataPort;\n            \n            part fourCylinderEngine {\n                attribute power : PowerOutput;\n                attribute mass : Mass;\n                attribute efficiency : Efficiency;\n                attribute reliability : Reliability;\n                attribute cost : Cost;\n            }\n            \n            part sixCylinderEngine {\n                attribute power : PowerOutput;\n                attribute mass : Mass;\n                attribute efficiency : Efficiency;\n                attribute reliability : Reliability;\n                attribute cost : Cost;\n            }\n        }\n        \n        interface systemToAnalyzer connect optimizationSystem.tradeOffResultPort to tradeOffAnalyzer.tradeOffResultPort {\n            ref flow references optimizePowertrain.tradeOffFlow\n                from source.tradeOffResult to target.tradeOffResult;\n        }\n        \n        part tradeOffAnalyzer {\n            port tradeOffResultPort : ~TradeOffResultPort;\n        }\n    }\n    \n    action optimizePowertrain {\n        action requestOptimization { out configRequest : EngineConfig; }\n        succession flow configFlow from requestOptimization.configRequest to modelEngineStructures.configRequest;\n        action modelEngineStructures { in configRequest; out performanceData : PerformanceData; }\n        succession flow performanceFlow from modelEngineStructures.performanceData to conductTradeOffAnalysis.performanceData;\n        action conductTradeOffAnalysis { in performanceData; out tradeOffResult : TradeOffResult; }\n        succession flow tradeOffFlow from conductTradeOffAnalysis.tradeOffResult to recommendOptimalSolution.tradeOffResult;\n        action recommendOptimalSolution { in tradeOffResult; out optimalSolution : OptimalSolution; }\n    }\n}",
    "package 'FuelEconomySystem' {\n    import ISQ::*;\n    import SI::*;\n    import USCustomaryUnits::*;\n    \n    attribute def FuelVolume :> ScalarQuantityValue {\n        attribute redefines num: Real;\n        attribute redefines mRef: VolumeUnit;\n    }\n    \n    attribute def Distance :> ScalarQuantityValue {\n        attribute redefines num: Real;\n        attribute redefines mRef: LengthUnit;\n    }\n    \n    attribute def Mass :> ScalarQuantityValue {\n        attribute redefines num: Real;\n        attribute redefines mRef: MassUnit;\n    }\n    \n    attribute def FuelEconomy :> ScalarQuantityValue {\n        attribute redefines num: Real;\n        attribute redefines mRef: LengthUnit / VolumeUnit;\n    }\n    \n    attribute def DrivingCondition {\n        attribute scenario: String;\n    }\n    \n    port def FuelConsumptionPort {\n        in fuelVolume: FuelVolume;\n        in distance: Distance;\n        out fuelEconomy: FuelEconomy;\n    }\n    \n    port def LoadPort {\n        in additionalLoad: Mass;\n    }\n    \n    port def DrivingConditionPort {\n        in condition: DrivingCondition;\n    }\n    \n    requirement def FuelEconomyRequirement {\n        doc /* The vehicle fuel economy must meet regulatory requirements */\n        \n        attribute urbanMinimum: FuelEconomy = 25 [mi/gal];\n        attribute highwayMinimum: FuelEconomy = 30 [mi/gal];\n        attribute testLoad: Mass = 1000 [lb];\n        \n        requirement urbanFuelEconomy {\n            doc /* Under urban driving conditions, range per gallon must not be less than 25 miles */\n            assume constraint { condition.scenario == \"urban\" }\n            require constraint { measuredFuelEconomy >= urbanMinimum }\n        }\n        \n        requirement highwayFuelEconomy {\n            doc /* Under highway driving conditions, range per gallon must not be less than 30 miles */\n            assume constraint { condition.scenario == \"highway\" }\n            require constraint { measuredFuelEconomy >= highwayMinimum }\n        }\n        \n        attribute condition: DrivingCondition;\n        attribute measuredFuelEconomy: FuelEconomy;\n    }\n    \n    part vehicle {\n        port fuelPort: FuelConsumptionPort;\n        port loadPort: LoadPort;\n        port conditionPort: DrivingConditionPort;\n        \n        part powertrain {\n            perform fuelEconomyAnalysis.consumeFuel {\n                in fuelVolume = fuelPort.fuelVolume;\n                in distance = fuelPort.distance;\n                in load = loadPort.additionalLoad;\n                in condition = conditionPort.condition;\n                out fuelEconomy = fuelPort.fuelEconomy;\n            }\n        }\n        \n        satisfy req: FuelEconomyRequirement {\n            attribute redefines measuredFuelEconomy = fuelPort.fuelEconomy;\n            attribute redefines condition = conditionPort.condition;\n        }\n    }\n    \n    part testEnvironment {\n        port fuelPort: ~FuelConsumptionPort;\n        port loadPort: ~LoadPort;\n        port conditionPort: ~DrivingConditionPort;\n        \n        perform fuelEconomyAnalysis.setupTest {\n            out load = loadPort.additionalLoad;\n            out condition = conditionPort.condition;\n        }\n        \n        perform fuelEconomyAnalysis.measureConsumption {\n            out fuelVolume = fuelPort.fuelVolume;\n            out distance = fuelPort.distance;\n            in fuelEconomy = fuelPort.fuelEconomy;\n        }\n    }\n    \n    interface vehicleToTest connect vehicle.fuelPort to testEnvironment.fuelPort;\n    interface vehicleLoadInterface connect vehicle.loadPort to testEnvironment.loadPort;\n    interface vehicleConditionInterface connect vehicle.conditionPort to testEnvironment.conditionPort;\n    \n    action fuelEconomyAnalysis {\n        action setupTest {\n            out load: Mass;\n            out condition: DrivingCondition;\n        }\n        \n        action measureConsumption {\n            out fuelVolume: FuelVolume;\n            out distance: Distance;\n            in fuelEconomy: FuelEconomy;\n        }\n        \n        action consumeFuel {\n            in fuelVolume: FuelVolume;\n            in distance: Distance;\n            in load: Mass;\n            in condition: DrivingCondition;\n            out fuelEconomy: FuelEconomy;\n        }\n        \n        flow from setupTest.load to consumeFuel.load;\n        flow from setupTest.condition to consumeFuel.condition;\n        flow from measureConsumption.fuelVolume to consumeFuel.fuelVolume;\n        flow from measureConsumption.distance to consumeFuel.distance;\n        flow from consumeFuel.fuelEconomy to measureConsumption.fuelEconomy;\n    }\n}",
    "package 'VehicleDynamicsSimulation' {\n\tattribute def Mass;\n\tattribute def Position;\n\tattribute def Velocity;\n\tattribute def Power;\n\tattribute def TimeStep;\n\tattribute def Acceleration;\n\tattribute def Time;\n\t\n\tport def SimulationInputPort {\n\t\tin mass : Mass;\n\t\tin initialPosition : Position;\n\t\tin initialVelocity : Velocity;\n\t\tin powerData : Power[*];\n\t\tin timeStep : TimeStep;\n\t}\n\t\n\tport def SimulationOutputPort {\n\t\tout accelerationSequence : Acceleration[*];\n\t\tout velocitySequence : Velocity[*];\n\t\tout positionSequence : Position[*];\n\t}\n\t\n\tpart context {\n\t\tpart user {\n\t\t\tport simulationInputPort : SimulationInputPort;\n\t\t\tperform analyzeVehicleDynamics.provideInputData {\n\t\t\t\tout mass = simulationInputPort.mass;\n\t\t\t\tout initialPosition = simulationInputPort.initialPosition;\n\t\t\t\tout initialVelocity = simulationInputPort.initialVelocity;\n\t\t\t\tout powerData = simulationInputPort.powerData;\n\t\t\t\tout timeStep = simulationInputPort.timeStep;\n\t\t\t}\n\t\t}\n\t\t\n\t\tinterface userToSimulator connect user.simulationInputPort to simulator.simulationInputPort {\n\t\t\tref flow references analyzeVehicleDynamics.inputDataFlow\n\t\t\t\tfrom source.mass to target.mass;\n\t\t\tref flow references analyzeVehicleDynamics.inputDataFlow\n\t\t\t\tfrom source.initialPosition to target.initialPosition;\n\t\t\tref flow references analyzeVehicleDynamics.inputDataFlow\n\t\t\t\tfrom source.initialVelocity to target.initialVelocity;\n\t\t\tref flow references analyzeVehicleDynamics.inputDataFlow\n\t\t\t\tfrom source.powerData to target.powerData;\n\t\t\tref flow references analyzeVehicleDynamics.inputDataFlow\n\t\t\t\tfrom source.timeStep to target.timeStep;\n\t\t}\n\t\t\n\t\tpart simulator {\n\t\t\tport simulationInputPort : ~SimulationInputPort;\n\t\t\tport simulationOutputPort : SimulationOutputPort;\n\t\t\t\n\t\t\tperform analyzeVehicleDynamics.computeDynamics {\n\t\t\t\tin mass = simulationInputPort.mass;\n\t\t\t\tin initialPosition = simulationInputPort.initialPosition;\n\t\t\t\tin initialVelocity = simulationInputPort.initialVelocity;\n\t\t\t\tin powerData = simulationInputPort.powerData;\n\t\t\t\tin timeStep = simulationInputPort.timeStep;\n\t\t\t\tout accelerationSequence = simulationOutputPort.accelerationSequence;\n\t\t\t\tout velocitySequence = simulationOutputPort.velocitySequence;\n\t\t\t\tout positionSequence = simulationOutputPort.positionSequence;\n\t\t\t}\n\t\t}\n\t}\n\t\n\taction analyzeVehicleDynamics {\n\t\taction provideInputData {\n\t\t\tout mass : Mass;\n\t\t\tout initialPosition : Position;\n\t\t\tout initialVelocity : Velocity;\n\t\t\tout powerData : Power[*];\n\t\t\tout timeStep : TimeStep;\n\t\t}\n\t\t\n\t\tsuccession flow inputDataFlow from provideInputData to computeDynamics;\n\t\t\n\t\taction computeDynamics {\n\t\t\tin mass : Mass;\n\t\t\tin initialPosition : Position;\n\t\t\tin initialVelocity : Velocity;\n\t\t\tin powerData : Power[*];\n\t\t\tin timeStep : TimeStep;\n\t\t\tout accelerationSequence : Acceleration[*];\n\t\t\tout velocitySequence : Velocity[*];\n\t\t\tout positionSequence : Position[*];\n\t\t}\n\t}\n}",
    "package 'Vehicle System' {\n    attribute def Mass :> ISQ::mass;\n    attribute def SteeringAngle :> ISQ::angle;\n    \n    part def Wheel {\n        attribute mass : Mass;\n    }\n    \n    part def FrontAxle {\n        attribute mass : Mass;\n        attribute steeringAngle : SteeringAngle;\n    }\n    \n    part def RearAxle {\n        attribute mass : Mass;\n    }\n    \n    part def FrontAxleAssembly {\n        attribute mass : Mass = 150 [kg];\n        \n        part leftFrontWheel : Wheel;\n        part rightFrontWheel : Wheel;\n        part frontAxle : FrontAxle;\n    }\n    \n    part def RearAxleAssembly {\n        attribute mass : Mass = 250 [kg];\n        \n        part leftRearWheel : Wheel;\n        part rightRearWheel : Wheel;\n        part rearAxle : RearAxle;\n    }\n    \n    part def Vehicle {\n        attribute totalMass : Mass = 2500 [kg];\n        \n        part frontAxleAssembly : FrontAxleAssembly;\n        part rearAxleAssembly : RearAxleAssembly;\n    }\n}",
    "package 'VehicleSafetySecuritySystem' {\n    attribute def SafetyFeature;\n    attribute def SecurityFeature;\n    attribute def ComponentInfo;\n    attribute def FilterCriteria;\n    attribute def DisplayFormat;\n    \n    enum def SafetyType {\n        mandatory;\n        optional;\n    }\n    \n    enum def DisplayType {\n        tree;\n        table;\n    }\n    \n    port def ComponentInfoPort {\n        out componentInfo: ComponentInfo;\n    }\n    \n    port def FilterPort {\n        in filterCriteria: FilterCriteria;\n    }\n    \n    port def DisplayPort {\n        out displayFormat: DisplayFormat;\n    }\n    \n    part def VehicleComponent {\n        attribute name: String;\n        attribute isSafety: Boolean;\n        attribute isSecurity: Boolean;\n        attribute safetyType: SafetyType[0..1];\n    }\n    \n    part def SeatBelt :> VehicleComponent {\n        attribute redefines isSafety = true;\n        attribute redefines safetyType = SafetyType::mandatory;\n    }\n    \n    part def Airbag :> VehicleComponent {\n        attribute redefines isSafety = true;\n        attribute redefines safetyType = SafetyType::optional;\n    }\n    \n    part def Bumper :> VehicleComponent {\n        attribute redefines isSafety = true;\n        attribute redefines safetyType = SafetyType::mandatory;\n    }\n    \n    part def ABS :> VehicleComponent {\n        attribute redefines isSafety = true;\n        attribute redefines safetyType = SafetyType::optional;\n    }\n    \n    part def Alarm :> VehicleComponent {\n        attribute redefines isSecurity = true;\n    }\n    \n    part def KeylessEntry :> VehicleComponent {\n        attribute redefines isSecurity = true;\n    }\n    \n    part context {\n        part user {\n            port filterPort: FilterPort;\n            port displayPort: ~DisplayPort;\n            perform manageSafetySecurityDisplay.requestFiltering {\n                out filterCriteria = filterPort.filterCriteria;\n            }\n            perform manageSafetySecurityDisplay.viewDisplay {\n                in displayFormat = displayPort.displayFormat;\n            }\n        }\n        \n        interface userToSystem connect user.filterPort to safetySecuritySystem.filterPort;\n        interface systemToUser connect safetySecuritySystem.displayPort to user.displayPort;\n        \n        part vehicle {\n            part seatBelts: SeatBelt[1..*];\n            part airbags: Airbag[0..*];\n            part bumpers: Bumper[1..*];\n            part abs: ABS[0..1];\n            part alarms: Alarm[0..*];\n            part keylessEntries: KeylessEntry[0..*];\n            \n            port componentPort: ComponentInfoPort;\n        }\n        \n        interface vehicleToSystem connect vehicle.componentPort to safetySecuritySystem.componentPort;\n        \n        part safetySecuritySystem {\n            port filterPort: ~FilterPort;\n            port componentPort: ~ComponentInfoPort;\n            port displayPort: DisplayPort;\n            \n            perform manageSafetySecurityDisplay.filterComponents {\n                in filterCriteria = filterPort.filterCriteria;\n                in componentInfo = componentPort.componentInfo;\n            }\n            \n            perform manageSafetySecurityDisplay.organizeComponents {\n                in item filterResult;\n                out item organizedData;\n            }\n            \n            perform manageSafetySecurityDisplay.visualizeComponents {\n                in item organizedData;\n                out displayFormat = displayPort.displayFormat;\n            }\n        }\n    }\n    \n    action manageSafetySecurityDisplay {\n        action requestFiltering { out filterCriteria: FilterCriteria; }\n        action filterComponents { in filterCriteria: FilterCriteria; in componentInfo: ComponentInfo; out filterResult; }\n        succession flow filterFlow from requestFiltering.filterCriteria to filterComponents.filterCriteria;\n        action organizeComponents { in filterResult; out organizedData; }\n        succession flow organizeFlow from filterComponents.filterResult to organizeComponents.filterResult;\n        action visualizeComponents { in organizedData; out displayFormat: DisplayFormat; }\n        succession flow visualizeFlow from organizeComponents.organizedData to visualizeComponents.organizedData;\n        action viewDisplay { in displayFormat: DisplayFormat; }\n        succession flow displayFlow from visualizeComponents.displayFormat to viewDisplay.displayFormat;\n    }\n}",
    "package 'LayeredSystem' {\n\tattribute def X;\n\tattribute def Y;\n\tattribute def Z;\n\tattribute def Request;\n\tattribute def Response;\n\tattribute def Data;\n\t\n\tport def RequestPort {\n\t\tout request: Request;\n\t}\n\tport def ResponsePort {\n\t\tin response: Response;\n\t}\n\tport def ServiceRequestPort {\n\t\tout serviceRequest: Request;\n\t}\n\tport def ServiceResponsePort {\n\t\tin serviceResponse: Response;\n\t}\n\tport def DataRequestPort {\n\t\tout dataRequest: Request;\n\t}\n\tport def DataResponsePort {\n\t\tin dataResponse: Response;\n\t}\n\t\n\tpart system {\n\t\tattribute x: X;\n\t\tattribute y: Y;\n\t\tattribute z: Z {\n\t\t\t:>> z = derive(x, y);\n\t\t}\n\t\t\n\t\tpart applicationLayer {\n\t\t\tport requestPort: RequestPort;\n\t\t\tport responsePort: ResponsePort;\n\t\t\tperform processFlow.applicationProcess {\n\t\t\t\tout request = requestPort.request;\n\t\t\t\tin response = responsePort.response;\n\t\t\t}\n\t\t}\n\t\t\n\t\tinterface appToService connect applicationLayer.requestPort to serviceLayer.serviceRequestPort {\n\t\t\tref flow references processFlow.appToServiceFlow\n\t\t\t\tfrom source.request to target.serviceRequest;\n\t\t}\n\t\t\n\t\tinterface serviceToApp connect serviceLayer.serviceResponsePort to applicationLayer.responsePort {\n\t\t\tref flow references processFlow.serviceToAppFlow\n\t\t\t\tfrom source.serviceResponse to target.response;\n\t\t}\n\t\t\n\t\tpart serviceLayer {\n\t\t\tport serviceRequestPort: ~ServiceRequestPort;\n\t\t\tport serviceResponsePort: ServiceResponsePort;\n\t\t\tport dataRequestPort: DataRequestPort;\n\t\t\tport dataResponsePort: DataResponsePort;\n\t\t\tperform processFlow.serviceProcess {\n\t\t\t\tin serviceRequest = serviceRequestPort.serviceRequest;\n\t\t\t\tout serviceResponse = serviceResponsePort.serviceResponse;\n\t\t\t\tout dataRequest = dataRequestPort.dataRequest;\n\t\t\t\tin dataResponse = dataResponsePort.dataResponse;\n\t\t\t}\n\t\t}\n\t\t\n\t\tinterface serviceToData connect serviceLayer.dataRequestPort to dataLayer.dataRequestPort {\n\t\t\tref flow references processFlow.serviceToDataFlow\n\t\t\t\tfrom source.dataRequest to target.dataRequest;\n\t\t}\n\t\t\n\t\tinterface dataToService connect dataLayer.dataResponsePort to serviceLayer.dataResponsePort {\n\t\t\tref flow references processFlow.dataToServiceFlow\n\t\t\t\tfrom source.dataResponse to target.dataResponse;\n\t\t}\n\t\t\n\t\tpart dataLayer {\n\t\t\tport dataRequestPort: ~DataRequestPort;\n\t\t\tport dataResponsePort: DataResponsePort;\n\t\t\tperform processFlow.dataProcess {\n\t\t\t\tin dataRequest = dataRequestPort.dataRequest;\n\t\t\t\tout dataResponse = dataResponsePort.dataResponse;\n\t\t\t}\n\t\t}\n\t}\n\t\n\taction processFlow {\n\t\taction applicationProcess { out request: Request; in response: Response; }\n\t\tsuccession flow appToServiceFlow from applicationProcess.request to serviceProcess.serviceRequest;\n\t\taction serviceProcess { \n\t\t\tin serviceRequest: Request; \n\t\t\tout serviceResponse: Response;\n\t\t\tout dataRequest: Request;\n\t\t\tin dataResponse: Response;\n\t\t}\n\t\tsuccession flow serviceToDataFlow from serviceProcess.dataRequest to dataProcess.dataRequest;\n\t\taction dataProcess { in dataRequest: Request; out dataResponse: Response; }\n\t\tsuccession flow dataToServiceFlow from dataProcess.dataResponse to serviceProcess.dataResponse;\n\t\tsuccession flow serviceToAppFlow from serviceProcess.serviceResponse to applicationProcess.response;\n\t}\n\t\n\tcalc def derive(x: X, y: Y): Z;\n}",
    "package 'PowertrainSystem' {\n\tattribute def Torque :> ISQ::TorqueValue;\n\tattribute def PowerCommand;\n\t\n\tport def PowerCommandPort {\n\t\tin powerCommand : PowerCommand;\n\t}\n\t\n\tport def TorquePort {\n\t\tout torque : Torque;\n\t}\n\t\n\tpart def TorqueGenerator {\n\t\tport powerCommandPort : PowerCommandPort;\n\t\tport torquePort : TorquePort;\n\t\t\n\t\tperform generateTorque {\n\t\t\tin powerCommand = powerCommandPort.powerCommand;\n\t\t\tout torque = torquePort.torque;\n\t\t}\n\t}\n\t\n\tpart def Engine :> TorqueGenerator;\n\t\n\tpart powertrainContext {\n\t\tpart controller {\n\t\t\tport powerCommandPort : ~PowerCommandPort;\n\t\t\tperform torqueGeneration.sendPowerCommand {\n\t\t\t\tout powerCommand = powerCommandPort.powerCommand;\n\t\t\t}\n\t\t}\n\t\t\n\t\tinterface controllerToPowertrain connect controller.powerCommandPort to powertrain.powerCommandPort {\n\t\t\tref flow references torqueGeneration.powerCommandFlow\n\t\t\t\tfrom source.powerCommand to target.powerCommand;\n\t\t}\n\t\t\n\t\tpart powertrain : Engine {\n\t\t\tport powerCommandPort : PowerCommandPort;\n\t\t\tport torquePort : TorquePort;\n\t\t\t\n\t\t\tperform torqueGeneration.generateTorque {\n\t\t\t\tin powerCommand = powerCommandPort.powerCommand;\n\t\t\t\tout torque = torquePort.torque;\n\t\t\t\tassert constraint { torque > 0 [N*m] }\n\t\t\t}\n\t\t}\n\t\t\n\t\tpart drivetrain {\n\t\t\tport torquePort : ~TorquePort;\n\t\t\tperform torqueGeneration.transmitTorque {\n\t\t\t\tin torque = torquePort.torque;\n\t\t\t}\n\t\t}\n\t\t\n\t\tinterface powertrainToDrivetrain connect powertrain.torquePort to drivetrain.torquePort {\n\t\t\tref flow references torqueGeneration.torqueFlow\n\t\t\t\tfrom source.torque to target.torque;\n\t\t}\n\t}\n\t\n\taction torqueGeneration {\n\t\taction sendPowerCommand { out powerCommand : PowerCommand; }\n\t\tsuccession flow powerCommandFlow from sendPowerCommand.powerCommand to generateTorque.powerCommand;\n\t\taction generateTorque { in powerCommand : PowerCommand; out torque : Torque; }\n\t\tsuccession flow torqueFlow from generateTorque.torque to transmitTorque.torque;\n\t\taction transmitTorque { in torque : Torque; }\n\t}\n}",
    "package 'PowerSystem' {\n\tattribute def Power;\n\tattribute def Torque;\n\t\n\tport def PowerPort {\n\t\tout power: Power;\n\t}\n\t\n\tport def TorquePort {\n\t\tout torque: Torque;\n\t}\n\t\n\tpart def System {\n\t\tport powerPort: PowerPort;\n\t\tport torquePort: TorquePort;\n\t\t\n\t\tperform providePower {\n\t\t\tout power = powerPort.power;\n\t\t}\n\t\t\n\t\tperform generateTorque {\n\t\t\tout torque = torquePort.torque;\n\t\t}\n\t\t\n\t\tpart torqueGenerator {\n\t\t\tperform generateTorque :>> System.generateTorque;\n\t\t}\n\t\t\n\t\tpart powertrain {\n\t\t\tpart engine {\n\t\t\t\tperform generateTorque :>> System.torqueGenerator.generateTorque;\n\t\t\t}\n\t\t}\n\t}\n}",
    "package 'VehicleSafetyAndAntiTheftCatalogue' {\n    abstract part def Component {\n        attribute isMandatory: Boolean default false;\n    }\n    \n    abstract part def SafetyComponent :> Component {\n        attribute affectsSafety: Boolean default true;\n    }\n    \n    abstract part def AntiTheftComponent :> Component {\n        attribute affectsAntiTheft: Boolean default true;\n    }\n    \n    abstract part def SafetyAndAntiTheftComponent :> Component {\n        attribute affectsSafety: Boolean default true;\n        attribute affectsAntiTheft: Boolean default true;\n    }\n    \n    part def FrontSeatBelt :> SafetyComponent {\n        attribute :>> isMandatory = true;\n    }\n    \n    part def Bumper :> SafetyComponent {\n        attribute :>> isMandatory = true;\n    }\n    \n    part def DriverAirbag :> SafetyComponent {\n        attribute :>> isMandatory = false;\n    }\n    \n    part def AntiLockBrakingSystem :> SafetyComponent {\n        attribute :>> isMandatory = false;\n    }\n    \n    part def AlarmSystem :> AntiTheftComponent {\n        attribute :>> isMandatory = false;\n    }\n    \n    part def KeylessEntrySystem :> AntiTheftComponent {\n        attribute :>> isMandatory = false;\n    }\n    \n    part vehicle {\n        part bodyAndInterior {\n            part frontSeatBelts: FrontSeatBelt[2];\n            part bumpers: Bumper[2];\n        }\n        \n        part safetyComponents {\n            part driverAirbag: DriverAirbag[0..1];\n            part abs: AntiLockBrakingSystem[0..1];\n        }\n        \n        part securityComponents {\n            part alarmSystem: AlarmSystem[0..1];\n            part keylessEntry: KeylessEntrySystem[0..1];\n        }\n    }\n}",
    "package 'FuelSystem' {\n\tattribute def Fuel;\n\tattribute def FuelTemperature;\n\t\n\tport def FuelSupplyPort {\n\t\tout fuel: Fuel;\n\t}\n\t\n\tport def FuelReturnPort {\n\t\tin fuel: Fuel;\n\t}\n\t\n\tport def FuelTemperaturePort {\n\t\tout temperature: FuelTemperature;\n\t}\n\t\n\tpart vehicle {\n\t\tpart fuelTankAssembly {\n\t\t\tpart fuelTank {\n\t\t\t\tport supplyPort: FuelSupplyPort;\n\t\t\t\tport returnPort: FuelReturnPort;\n\t\t\t\tperform manageFuel.storeFuel {\n\t\t\t\t\tout fuel = supplyPort.fuel;\n\t\t\t\t\tin returnFuel = returnPort.fuel;\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\tpart fuelPump {\n\t\t\t\tport intakePort: ~FuelSupplyPort;\n\t\t\t\tport deliveryPort: FuelSupplyPort;\n\t\t\t\tport temperaturePort: FuelTemperaturePort;\n\t\t\t\tperform manageFuel.pressurizeFuel {\n\t\t\t\t\tin fuel = intakePort.fuel;\n\t\t\t\t\tout pressurizedFuel = deliveryPort.fuel;\n\t\t\t\t\tout temperature = temperaturePort.temperature;\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\tinterface tankToPump connect fuelTank.supplyPort to fuelPump.intakePort {\n\t\t\t\tref flow references manageFuel.tankToPumpFlow\n\t\t\t\t\tfrom source.fuel to target.fuel;\n\t\t\t}\n\t\t}\n\t\t\n\t\tpart fuelConsumingUnits {\n\t\t\tport supplyPort: ~FuelSupplyPort;\n\t\t\tport returnPort: FuelReturnPort;\n\t\t\tperform manageFuel.consumeFuel {\n\t\t\t\tin fuel = supplyPort.fuel;\n\t\t\t\tout unusedFuel = returnPort.fuel;\n\t\t\t}\n\t\t}\n\t\t\n\t\tinterface pumpToConsumers connect fuelTankAssembly.fuelPump.deliveryPort to fuelConsumingUnits.supplyPort {\n\t\t\tref flow references manageFuel.pumpToConsumersFlow\n\t\t\t\tfrom source.fuel to target.fuel;\n\t\t}\n\t\t\n\t\tinterface consumersToTank connect fuelConsumingUnits.returnPort to fuelTankAssembly.fuelTank.returnPort {\n\t\t\tref flow references manageFuel.returnFlow\n\t\t\t\tfrom source.fuel to target.fuel;\n\t\t}\n\t}\n\t\n\taction manageFuel {\n\t\taction storeFuel { out fuel: Fuel; in returnFuel: Fuel; }\n\t\tsuccession flow tankToPumpFlow from storeFuel.fuel to pressurizeFuel.fuel;\n\t\taction pressurizeFuel { in fuel: Fuel; out pressurizedFuel: Fuel; out temperature: FuelTemperature; }\n\t\tsuccession flow pumpToConsumersFlow from pressurizeFuel.pressurizedFuel to consumeFuel.fuel;\n\t\taction consumeFuel { in fuel: Fuel; out unusedFuel: Fuel; }\n\t\tsuccession flow returnFlow from consumeFuel.unusedFuel to storeFuel.returnFuel;\n\t}\n}",
    "package 'VehicleSafetySecuritySystem' {\n    attribute def SafetyClassification;\n    attribute def SecurityClassification;\n    attribute def ComplianceStatus;\n    \n    part def SeatBelt {\n        attribute isMandatory : Boolean = true;\n        attribute safetyClass : SafetyClassification;\n    }\n    \n    part def Airbag {\n        attribute isMandatory : Boolean = false;\n        attribute safetyClass : SafetyClassification;\n    }\n    \n    part def AntiTheftAlarm {\n        attribute securityClass : SecurityClassification;\n    }\n    \n    part def Bumper {\n        attribute isMandatory : Boolean = true;\n        attribute safetyClass : SafetyClassification;\n    }\n    \n    part def KeylessEntrySystem {\n        attribute isMandatory : Boolean = true;\n        attribute securityClass : SecurityClassification;\n    }\n    \n    part def Wheel {\n        attribute safetyClass : SafetyClassification;\n    }\n    \n    part def AntiLockBrakingSystem {\n        attribute isMandatory : Boolean = false;\n        attribute safetyClass : SafetyClassification;\n    }\n    \n    part vehicle {\n        part interior {\n            part seatBelt1 : SeatBelt;\n            part seatBelt2 : SeatBelt;\n            part cockpit {\n                part airbag : Airbag;\n            }\n            part antiTheftAlarm : AntiTheftAlarm;\n        }\n        \n        part body {\n            part bumper : Bumper;\n            part keylessEntry : KeylessEntrySystem;\n        }\n        \n        part chassis {\n            part wheel1 : Wheel;\n            part wheel2 : Wheel;\n            part abs1 : AntiLockBrakingSystem;\n            part abs2 : AntiLockBrakingSystem;\n        }\n        \n        attribute complianceStatus : ComplianceStatus;\n    }\n}",
    "package 'VehicleSafetySecuritySystem' {\n    part def Interior {\n        part alarmSystem;\n        part seatBelts;\n        part frontRowSeats;\n        part driversAirbag;\n    }\n    \n    part def BodyAssembly {\n        part vehicleBody;\n        part bumper;\n        part keylessEntrySystem;\n    }\n    \n    part def SafetyFeatures {\n        ref seatBelts;\n        ref airbag;\n        ref bumper;\n    }\n    \n    part def SecurityFeatures {\n        ref alarmSystem;\n        ref keylessEntrySystem;\n    }\n    \n    part vehicleSafetySecurityComponent {\n        part interior : Interior {\n            part alarmSystem;\n            part seatBelts;\n            part frontRowSeats;\n            part driversAirbag;\n        }\n        \n        part bodyAssembly : BodyAssembly {\n            part vehicleBody;\n            part bumper;\n            part keylessEntrySystem;\n        }\n        \n        part safetyFeatures : SafetyFeatures {\n            ref seatBelts = interior.seatBelts;\n            ref airbag = interior.driversAirbag;\n            ref bumper = bodyAssembly.bumper;\n        }\n        \n        part securityFeatures : SecurityFeatures {\n            ref alarmSystem = interior.alarmSystem;\n            ref keylessEntrySystem = bodyAssembly.keylessEntrySystem;\n        }\n    }\n}",
    "package 'SecurityClassificationSystem' {\n\tattribute def ClassificationLevel;\n\tattribute def ComponentID;\n\tattribute def ClassificationAttribute;\n\t\n\tport def ComponentPort {\n\t\tin componentID : ComponentID;\n\t\tout classificationLevel : ClassificationLevel;\n\t\tout classificationAttribute : ClassificationAttribute;\n\t}\n\t\n\tport def ClassificationPort {\n\t\tin componentID : ComponentID;\n\t\tin classificationLevel : ClassificationLevel;\n\t\tout classificationAttribute : ClassificationAttribute;\n\t}\n\t\n\tpart context {\n\t\tpart component {\n\t\t\tport componentPort : ComponentPort;\n\t\t\tperform classifyAndLabel.provideComponent {\n\t\t\t\tout componentID = componentPort.componentID;\n\t\t\t\tin classificationLevel = componentPort.classificationLevel;\n\t\t\t\tin classificationAttribute = componentPort.classificationAttribute;\n\t\t\t}\n\t\t}\n\t\t\n\t\tinterface componentToClassifier connect component.componentPort to classifier.classificationPort {\n\t\t\tref flow references classifyAndLabel.componentFlow\n\t\t\t\tfrom source.componentID to target.componentID;\n\t\t\tref flow references classifyAndLabel.levelFlow\n\t\t\t\tfrom target.classificationLevel to source.classificationLevel;\n\t\t\tref flow references classifyAndLabel.attributeFlow\n\t\t\t\tfrom target.classificationAttribute to source.classificationAttribute;\n\t\t}\n\t\t\n\t\tpart classifier {\n\t\t\tport classificationPort : ~ClassificationPort;\n\t\t\tperform classifyAndLabel.assignClassification {\n\t\t\t\tin componentID = classificationPort.componentID;\n\t\t\t\tout classificationLevel = classificationPort.classificationLevel;\n\t\t\t\tout classificationAttribute = classificationPort.classificationAttribute;\n\t\t\t}\n\t\t}\n\t}\n\t\n\taction classifyAndLabel {\n\t\taction provideComponent { \n\t\t\tout componentID : ComponentID; \n\t\t\tin classificationLevel : ClassificationLevel;\n\t\t\tin classificationAttribute : ClassificationAttribute;\n\t\t}\n\t\tsuccession flow componentFlow from provideComponent.componentID to assignClassification.componentID;\n\t\taction assignClassification { \n\t\t\tin componentID : ComponentID; \n\t\t\tout classificationLevel : ClassificationLevel;\n\t\t\tout classificationAttribute : ClassificationAttribute;\n\t\t}\n\t\tsuccession flow levelFlow from assignClassification.classificationLevel to provideComponent.classificationLevel;\n\t\tsuccession flow attributeFlow from assignClassification.classificationAttribute to provideComponent.classificationAttribute;\n\t}\n}",
    "package 'AutomotiveECUSystem' {\n    attribute def ControlSignal;\n    attribute def EngineStatus;\n    attribute def VehicleStatus;\n    attribute def CANMessage;\n    attribute def SensorData;\n    \n    port def ControlSignalPort {\n        out controlSignal: ControlSignal;\n    }\n    \n    port def EngineStatusPort {\n        out engineStatus: EngineStatus;\n    }\n    \n    port def VehicleStatusPort {\n        out vehicleStatus: VehicleStatus;\n    }\n    \n    port def CANMessagePort {\n        inout canMessage: CANMessage;\n    }\n    \n    port def SensorDataPort {\n        in sensorData: SensorData;\n    }\n    \n    part def BusInterface {\n        port systemPort: CANMessagePort;\n        port busPort: CANMessagePort;\n    }\n    \n    part vehicleControlSystem {\n        part vcu {\n            port controlPort: ControlSignalPort;\n            port statusPort: VehicleStatusPort;\n            port canPort: CANMessagePort;\n            port sensorPort: SensorDataPort;\n            \n            part vcuBusIF: BusInterface {\n                bind systemPort = canPort;\n            }\n            \n            perform vehicleOperation.monitorVehicle {\n                in sensorData = sensorPort.sensorData;\n                out vehicleStatus = statusPort.vehicleStatus;\n                out controlSignal = controlPort.controlSignal;\n                inout canMessage = canPort.canMessage;\n            }\n        }\n        \n        part ecu {\n            port controlPort: ~ControlSignalPort;\n            port statusPort: EngineStatusPort;\n            port canPort: CANMessagePort;\n            port sensorPort: SensorDataPort;\n            \n            part ecuBusIF: BusInterface {\n                bind systemPort = canPort;\n            }\n            \n            perform vehicleOperation.controlEngine {\n                in controlSignal = controlPort.controlSignal;\n                in sensorData = sensorPort.sensorData;\n                out engineStatus = statusPort.engineStatus;\n                inout canMessage = canPort.canMessage;\n            }\n        }\n        \n        part canBus {\n            port vcuPort: CANMessagePort;\n            port ecuPort: CANMessagePort;\n        }\n        \n        interface vcuToCanBus connect vcu.vcuBusIF.busPort to canBus.vcuPort;\n        interface ecuToCanBus connect ecu.ecuBusIF.busPort to canBus.ecuPort;\n        interface canBusComm connect canBus.vcuPort to canBus.ecuPort;\n    }\n    \n    action vehicleOperation {\n        action monitorVehicle {\n            in sensorData: SensorData;\n            out vehicleStatus: VehicleStatus;\n            out controlSignal: ControlSignal;\n            inout canMessage: CANMessage;\n        }\n        \n        action controlEngine {\n            in controlSignal: ControlSignal;\n            in sensorData: SensorData;\n            out engineStatus: EngineStatus;\n            inout canMessage: CANMessage;\n        }\n        \n        flow from monitorVehicle.canMessage to controlEngine.canMessage;\n        flow from controlEngine.canMessage to monitorVehicle.canMessage;\n    }\n}",
    "package 'BloodGlucoseMeter' {\n\tattribute def BatteryStatus;\n\tattribute def Alert;\n\tattribute def GlucoseReading;\n\tattribute def MeasurementCommand;\n\t\n\tport def BatteryStatusPort {\n\t\tout batteryStatus: BatteryStatus;\n\t}\n\tport def AlertPort {\n\t\tout alert: Alert;\n\t}\n\tport def GlucoseReadingPort {\n\t\tout glucoseReading: GlucoseReading;\n\t}\n\tport def MeasurementCommandPort {\n\t\tout measurementCommand: MeasurementCommand;\n\t}\n\t\n\tpart context {\n\t\tpart battery {\n\t\t\tport batteryStatusPort: BatteryStatusPort;\n\t\t\tperform ensureReliableOperation.provideBatteryStatus {\n\t\t\t\tout batteryStatus = batteryStatusPort.batteryStatus;\n\t\t\t}\n\t\t}\n\t\t\n\t\tinterface batteryToMonitor connect battery.batteryStatusPort to batteryMonitor.batteryStatusPort {\n\t\t\tref flow references ensureReliableOperation.batteryStatusFlow\n\t\t\t\tfrom source.batteryStatus to target.batteryStatus;\n\t\t}\n\t\t\n\t\tpart batteryMonitor {\n\t\t\tport batteryStatusPort: ~BatteryStatusPort;\n\t\t\tport alertPort: AlertPort;\n\t\t\tperform ensureReliableOperation.detectBatteryIssues {\n\t\t\t\tin batteryStatus = batteryStatusPort.batteryStatus;\n\t\t\t\tout alert = alertPort.alert;\n\t\t\t}\n\t\t}\n\t\t\n\t\tinterface monitorToUser connect batteryMonitor.alertPort to user.alertPort {\n\t\t\tref flow references ensureReliableOperation.alertFlow\n\t\t\t\tfrom source.alert to target.alert;\n\t\t}\n\t\t\n\t\tpart user {\n\t\t\tport alertPort: ~AlertPort;\n\t\t\tport measurementCommandPort: MeasurementCommandPort;\n\t\t\tperform ensureReliableOperation.receiveAlert {\n\t\t\t\tin alert = alertPort.alert;\n\t\t\t}\n\t\t\tperform ensureReliableOperation.requestMeasurement {\n\t\t\t\tout measurementCommand = measurementCommandPort.measurementCommand;\n\t\t\t}\n\t\t}\n\t\t\n\t\tinterface userToMeasurementSystem connect user.measurementCommandPort to measurementSystem.measurementCommandPort {\n\t\t\tref flow references ensureReliableOperation.measurementCommandFlow\n\t\t\t\tfrom source.measurementCommand to target.measurementCommand;\n\t\t}\n\t\t\n\t\tpart measurementSystem {\n\t\t\tport measurementCommandPort: ~MeasurementCommandPort;\n\t\t\tport glucoseReadingPort: GlucoseReadingPort;\n\t\t\tport emergencyAlertPort: AlertPort;\n\t\t\tperform ensureReliableOperation.measureGlucose {\n\t\t\t\tin measurementCommand = measurementCommandPort.measurementCommand;\n\t\t\t\tout glucoseReading = glucoseReadingPort.glucoseReading;\n\t\t\t}\n\t\t\tperform ensureReliableOperation.triggerEmergencyResponse {\n\t\t\t\tout alert = emergencyAlertPort.alert;\n\t\t\t}\n\t\t}\n\t\t\n\t\tinterface measurementToUser connect measurementSystem.glucoseReadingPort to user.glucoseReadingPort {\n\t\t\tref flow references ensureReliableOperation.glucoseReadingFlow\n\t\t\t\tfrom source.glucoseReading to target.glucoseReading;\n\t\t}\n\t\t\n\t\tpart user {\n\t\t\tport glucoseReadingPort: ~GlucoseReadingPort;\n\t\t\tperform ensureReliableOperation.receiveGlucoseReading {\n\t\t\t\tin glucoseReading = glucoseReadingPort.glucoseReading;\n\t\t\t}\n\t\t}\n\t}\n\t\n\taction ensureReliableOperation {\n\t\taction provideBatteryStatus { out batteryStatus: BatteryStatus; }\n\t\tsuccession flow batteryStatusFlow from provideBatteryStatus.batteryStatus to detectBatteryIssues.batteryStatus;\n\t\taction detectBatteryIssues { in batteryStatus: BatteryStatus; out alert: Alert; }\n\t\tsuccession flow alertFlow from detectBatteryIssues.alert to receiveAlert.alert;\n\t\taction receiveAlert { in alert: Alert; }\n\t\taction requestMeasurement { out measurementCommand: MeasurementCommand; }\n\t\tsuccession flow measurementCommandFlow from requestMeasurement.measurementCommand to measureGlucose.measurementCommand;\n\t\taction measureGlucose { in measurementCommand: MeasurementCommand; out glucoseReading: GlucoseReading; }\n\t\tsuccession flow glucoseReadingFlow from measureGlucose.glucoseReading to receiveGlucoseReading.glucoseReading;\n\t\taction receiveGlucoseReading { in glucoseReading: GlucoseReading; }\n\t\taction triggerEmergencyResponse { out alert: Alert; }\n\t}\n}",
    "package 'ScientificConstants' {\n    attribute def MathematicalConstant :> Real;\n    attribute def PhysicalConstant :> Real;\n    attribute def ContextConstant :> Real;\n    \n    attribute eulerNumber : MathematicalConstant = 2.71828182845904523536;\n    attribute pi : MathematicalConstant = 3.14159265358979323846;\n    \n    attribute speedOfLight : PhysicalConstant = 299792458.0;\n    attribute fineStructureConstant : PhysicalConstant = 0.0072973525693;\n    attribute electronProtonMassRatio : PhysicalConstant = 0.00054386734428;\n    \n    attribute earthGravity : ContextConstant = 9.80665;\n    attribute modelXAmplifierGain : ContextConstant = 25.0;\n    \n    part def ConstantsProvider {\n        attribute mathConstants[*] : MathematicalConstant;\n        attribute physicalConstants[*] : PhysicalConstant;\n        attribute contextConstants[*] : ContextConstant;\n        \n        port constantsPort : ConstantsAccessPort;\n    }\n    \n    port def ConstantsAccessPort {\n        out providedConstants : Real[*];\n    }\n    \n    part scientificComputingSystem {\n        part constantsLibrary : ConstantsProvider {\n            attribute :>> mathConstants = (eulerNumber, pi);\n            attribute :>> physicalConstants = (speedOfLight, fineStructureConstant, electronProtonMassRatio);\n            attribute :>> contextConstants = (earthGravity, modelXAmplifierGain);\n        }\n        \n        part computationModule {\n            port constantsPort : ~ConstantsAccessPort;\n            \n            perform accessConstants {\n                in constants = constantsPort.providedConstants;\n            }\n        }\n        \n        interface constantsInterface connect constantsLibrary.constantsPort to computationModule.constantsPort;\n    }\n}",
    "package 'AutomotiveTireSpecification' {\n    attribute def ManufacturerName : String;\n    attribute def RimDiameter : Real;\n    attribute def TireWidth : Integer;\n    \n    part def Tire {\n        attribute manufacturer : ManufacturerName;\n        attribute rimDiameter : RimDiameter;\n        attribute width : TireWidth;\n    }\n    \n    part frenchTire : Tire {\n        attribute manufacturer = \"Michelin\";\n        attribute rimDiameter = 18.0;\n        attribute width = 245;\n    }\n}",
    "package 'AutomotiveComponent' {\n    import ISQ::*;\n    import SI::*;\n    import USCustomaryUnits::*;\n    \n    attribute def MassValue :> ISQ::mass;\n    attribute def LengthValue :> ISQ::length;\n    attribute def DiameterValue :> ISQ::length;\n    attribute def WidthValue :> ISQ::length;\n    \n    part def Vehicle {\n        attribute mass : MassValue = 1200 [kg];\n        attribute length : LengthValue = 4.82 [m];\n        \n        part leftFrontWheel : Wheel;\n        part rightFrontWheel : Wheel;\n    }\n    \n    part def Wheel {\n        attribute hubDiameter : DiameterValue = 18 ['in'];\n        attribute width : WidthValue = 245 [mm];\n        attribute outerDiameter : DiameterValue;\n        \n        part tire : Tire;\n        \n        constraint { outerDiameter == hubDiameter + 2 * tire.height }\n    }\n    \n    part def Tire {\n        attribute height : LengthValue;\n    }\n}",
    "package 'VehiclePowertrain' {\n    enum def EngineType {\n        enum fourCylinder;\n        enum sixCylinder;\n    }\n    \n    enum def TransmissionType {\n        enum manual;\n        enum automatic;\n    }\n    \n    attribute def PerformanceLevel {\n        attribute isHighPerformance: Boolean;\n    }\n    \n    part def Engine {\n        attribute engineType: EngineType;\n    }\n    \n    part def Transmission {\n        attribute transmissionType: TransmissionType;\n    }\n    \n    part def Vehicle {\n        attribute performanceLevel: PerformanceLevel;\n        part engine: Engine[1];\n        part transmission: Transmission[1];\n        \n        constraint engineSelection {\n            if performanceLevel.isHighPerformance then\n                engine.engineType == EngineType::sixCylinder\n            else\n                engine.engineType == EngineType::fourCylinder\n        }\n        \n        constraint validPowertrainCombination {\n            (engine.engineType == EngineType::fourCylinder and \n             transmission.transmissionType == TransmissionType::manual) or\n            (engine.engineType == EngineType::sixCylinder and \n             transmission.transmissionType == TransmissionType::automatic)\n        }\n    }\n}",
    "package 'AutomotiveComponents' {\n    import ISQ::*;\n    import SI::*;\n    \n    attribute def Mass :> ISQ::mass;\n    attribute def Length :> ISQ::length;\n    attribute def Diameter :> ISQ::diameter;\n    attribute def Width :> ISQ::width;\n    attribute def Height :> ISQ::height;\n    attribute def Depth :> ISQ::length;\n    attribute def Radius :> ISQ::radius;\n    \n    part def Vehicle {\n        attribute mass: Mass = 1200 [kg];\n        attribute length: Length = 4.82 [m];\n        \n        part wheelAssemblies: WheelAssembly[4];\n    }\n    \n    part def WheelAssembly {\n        part wheel: Wheel;\n        part brakeDisc: BrakeDisc;\n        \n        constraint fitmentConstraint {\n            brakeDisc.diameter < wheel.outerDiameter\n        }\n    }\n    \n    part def Wheel {\n        part rim: Rim;\n        part tire: Tire;\n        \n        attribute outerDiameter: Diameter = rim.diameter + 2 * tire.height;\n    }\n    \n    part def Rim {\n        attribute diameter: Diameter = 18 [inch];\n    }\n    \n    part def Tire {\n        attribute width: Width = 245 [mm];\n        attribute height: Height = 45 [mm];\n        attribute treadDepth: Depth = 6.0 [mm];\n        \n        constraint safetyConstraint {\n            treadDepth >= 3.5 [mm]\n        }\n    }\n    \n    part def BrakeDisc {\n        attribute radius: Radius = 95 [mm];\n        attribute diameter: Diameter = 2 * radius;\n    }\n}",
    "package 'AutomotiveFuelSystem' {\n\tattribute def Fuel;\n\tattribute def Temperature;\n\t\n\tport def FuelSupplyPort {\n\t\tout fuel : Fuel;\n\t}\n\t\n\tport def FuelReturnPort {\n\t\tin fuel : Fuel;\n\t}\n\t\n\tport def TemperaturePort {\n\t\tout temperature : Temperature;\n\t}\n\t\n\tpart def FuelTankAssembly {\n\t\tport fuelSupplyPort : FuelSupplyPort;\n\t\tport fuelReturnPort : FuelReturnPort;\n\t\tport temperaturePort : TemperaturePort;\n\t\t\n\t\tpart fuelPump : FuelPump {\n\t\t\tport tankFuelInPort : ~FuelSupplyPort;\n\t\t\tport engineFuelOutPort : FuelSupplyPort;\n\t\t\tport engineFuelReturnPort : FuelReturnPort;\n\t\t}\n\t\t\n\t\tpart fuelTank : FuelTank {\n\t\t\tport fuelOutPort : FuelSupplyPort;\n\t\t\tport fuelInPort : FuelReturnPort;\n\t\t}\n\t\t\n\t\tinterface tankToPump connect fuelTank.fuelOutPort to fuelPump.tankFuelInPort;\n\t\tinterface pumpToAssemblySupply connect fuelPump.engineFuelOutPort to fuelSupplyPort;\n\t\tinterface assemblyReturnToPump connect fuelReturnPort to fuelPump.engineFuelReturnPort;\n\t}\n\t\n\tpart def FuelPump {\n\t\tport tankFuelInPort : ~FuelSupplyPort;\n\t\tport engineFuelOutPort : FuelSupplyPort;\n\t\tport engineFuelReturnPort : FuelReturnPort;\n\t\t\n\t\tperform fuelCirculation.pumpFuel {\n\t\t\tin fuel = tankFuelInPort.fuel;\n\t\t\tout fuel = engineFuelOutPort.fuel;\n\t\t}\n\t\t\n\t\tperform fuelCirculation.receiveReturnFuel {\n\t\t\tin fuel = engineFuelReturnPort.fuel;\n\t\t}\n\t}\n\t\n\tpart def FuelTank {\n\t\tport fuelOutPort : FuelSupplyPort;\n\t\tport fuelInPort : FuelReturnPort;\n\t\t\n\t\tperform fuelCirculation.storeFuel {\n\t\t\tout fuel = fuelOutPort.fuel;\n\t\t\tin fuel = fuelInPort.fuel;\n\t\t}\n\t}\n\t\n\tpart def Engine {\n\t\tport fuelInPort : ~FuelSupplyPort;\n\t\tport fuelOutPort : ~FuelReturnPort;\n\t\t\n\t\tperform fuelCirculation.consumeFuel {\n\t\t\tin fuel = fuelInPort.fuel;\n\t\t\tout fuel = fuelOutPort.fuel;\n\t\t}\n\t}\n\t\n\tpart context {\n\t\tpart fuelTankAssembly : FuelTankAssembly;\n\t\tpart engine : Engine;\n\t\t\n\t\tinterface assemblyToEngine connect fuelTankAssembly.fuelSupplyPort to engine.fuelInPort {\n\t\t\tref flow references fuelCirculation.supplyFlow\n\t\t\t\tfrom source.fuel to target.fuel;\n\t\t}\n\t\t\n\t\tinterface engineToAssembly connect engine.fuelOutPort to fuelTankAssembly.fuelReturnPort {\n\t\t\tref flow references fuelCirculation.returnFlow\n\t\t\t\tfrom source.fuel to target.fuel;\n\t\t}\n\t}\n\t\n\taction fuelCirculation {\n\t\taction storeFuel { out fuel : Fuel; in fuel : Fuel; }\n\t\taction pumpFuel { in fuel : Fuel; out fuel : Fuel; }\n\t\tsuccession flow supplyFlow from pumpFuel.fuel to consumeFuel.fuel;\n\t\taction consumeFuel { in fuel : Fuel; out fuel : Fuel; }\n\t\tsuccession flow returnFlow from consumeFuel.fuel to receiveReturnFuel.fuel;\n\t\taction receiveReturnFuel { in fuel : Fuel; }\n\t}\n}",
    "package 'PhysicalQuantityManagementSystem' {\n    import ISQ::*;\n    \n    attribute def PhysicalQuantityData;\n    attribute def UnitData;\n    attribute def ConversionRequest;\n    attribute def ConversionResult;\n    \n    port def QuantityDataPort {\n        in quantityData: PhysicalQuantityData;\n        out processedData: PhysicalQuantityData;\n    }\n    \n    port def UnitConversionPort {\n        in conversionRequest: ConversionRequest;\n        out conversionResult: ConversionResult;\n    }\n    \n    part def PhysicalQuantityManager {\n        attribute quantities: PhysicalQuantityData[*];\n        attribute units: UnitData[*];\n        \n        port quantityPort: QuantityDataPort;\n        port conversionPort: UnitConversionPort;\n        \n        perform manageQuantities {\n            in data = quantityPort.quantityData;\n            out processed = quantityPort.processedData;\n        }\n        \n        perform convertUnits {\n            in request = conversionPort.conversionRequest;\n            out result = conversionPort.conversionResult;\n        }\n    }\n    \n    part context {\n        part user {\n            port quantityDataPort: ~QuantityDataPort;\n            port unitConversionPort: ~UnitConversionPort;\n            \n            perform quantityManagement.inputQuantityData {\n                out quantityData = quantityDataPort.quantityData;\n            }\n            \n            perform quantityManagement.requestConversion {\n                out conversionRequest = unitConversionPort.conversionRequest;\n            }\n        }\n        \n        part quantitySystem: PhysicalQuantityManager {\n            port quantityPort: QuantityDataPort;\n            port conversionPort: UnitConversionPort;\n            \n            perform quantityManagement.processQuantityData {\n                in quantityData = quantityPort.quantityData;\n                out processedData = quantityPort.processedData;\n            }\n            \n            perform quantityManagement.performConversion {\n                in conversionRequest = conversionPort.conversionRequest;\n                out conversionResult = conversionPort.conversionResult;\n            }\n        }\n        \n        interface userToSystem connect user.quantityDataPort to quantitySystem.quantityPort {\n            ref flow references quantityManagement.quantityDataFlow\n                from source.quantityData to target.quantityData;\n            ref flow references quantityManagement.processedDataFlow\n                from target.processedData to source.processedData;\n        }\n        \n        interface userToSystemConversion connect user.unitConversionPort to quantitySystem.conversionPort {\n            ref flow references quantityManagement.conversionRequestFlow\n                from source.conversionRequest to target.conversionRequest;\n            ref flow references quantityManagement.conversionResultFlow\n                from target.conversionResult to source.conversionResult;\n        }\n    }\n    \n    action quantityManagement {\n        action inputQuantityData { out quantityData: PhysicalQuantityData; }\n        succession flow quantityDataFlow from inputQuantityData.quantityData to processQuantityData.quantityData;\n        action processQuantityData { in quantityData: PhysicalQuantityData; out processedData: PhysicalQuantityData; }\n        succession flow processedDataFlow from processQuantityData.processedData to inputQuantityData;\n        \n        action requestConversion { out conversionRequest: ConversionRequest; }\n        succession flow conversionRequestFlow from requestConversion.conversionRequest to performConversion.conversionRequest;\n        action performConversion { in conversionRequest: ConversionRequest; out conversionResult: ConversionResult; }\n        succession flow conversionResultFlow from performConversion.conversionResult to requestConversion;\n    }\n}",
    "package 'UnitSystemLibrary' {\n    attribute def Quantity;\n    attribute def Unit;\n    attribute def ConversionFactor;\n    \n    port def QuantityPort {\n        inout quantity : Quantity;\n    }\n    \n    port def UnitPort {\n        out unit : Unit;\n    }\n    \n    port def ConversionPort {\n        in sourceUnit : Unit;\n        in targetUnit : Unit;\n        out conversionFactor : ConversionFactor;\n    }\n    \n    part context {\n        part user {\n            port quantityPort : QuantityPort;\n            port unitRequestPort : UnitPort;\n            \n            perform unitManagement.requestUnitConversion {\n                out quantity = quantityPort.quantity;\n                in unit = unitRequestPort.unit;\n            }\n        }\n        \n        interface userToUnitSystem connect user.quantityPort to unitSystem.quantityPort {\n            ref flow references unitManagement.quantityFlow\n                from source.quantity to target.quantity;\n        }\n        \n        interface userToUnitSystem2 connect user.unitRequestPort to unitSystem.unitProviderPort {\n            ref flow references unitManagement.unitFlow\n                from target.unit to source.unit;\n        }\n        \n        part unitSystem {\n            port quantityPort : ~QuantityPort;\n            port unitProviderPort : ~UnitPort;\n            port isqPort : ConversionPort;\n            port usCustomaryPort : ConversionPort;\n            \n            perform unitManagement.processUnitRequest {\n                inout quantity = quantityPort.quantity;\n                out unit = unitProviderPort.unit;\n            }\n            \n            perform unitManagement.convertUnits {\n                in sourceUnit = isqPort.sourceUnit;\n                in targetUnit = usCustomaryPort.targetUnit;\n                out conversionFactor;\n            }\n        }\n        \n        part isqLibrary {\n            port conversionPort : ~ConversionPort;\n            \n            perform unitManagement.provideISQUnits {\n                out unit = conversionPort.sourceUnit;\n            }\n        }\n        \n        part usCustomaryLibrary {\n            port conversionPort : ~ConversionPort;\n            \n            perform unitManagement.provideUSCustomaryUnits {\n                out unit = conversionPort.targetUnit;\n            }\n        }\n        \n        interface systemToISQ connect unitSystem.isqPort to isqLibrary.conversionPort;\n        interface systemToUSCustomary connect unitSystem.usCustomaryPort to usCustomaryLibrary.conversionPort;\n    }\n    \n    action unitManagement {\n        action requestUnitConversion { out quantity : Quantity; in unit : Unit; }\n        succession flow quantityFlow from requestUnitConversion.quantity to processUnitRequest.quantity;\n        succession flow unitFlow from processUnitRequest.unit to requestUnitConversion.unit;\n        \n        action processUnitRequest { inout quantity : Quantity; out unit : Unit; }\n        succession flow processFlow from processUnitRequest to convertUnits;\n        \n        action convertUnits { in sourceUnit : Unit; in targetUnit : Unit; out conversionFactor : ConversionFactor; }\n        flow from provideISQUnits.unit to convertUnits.sourceUnit;\n        flow from provideUSCustomaryUnits.unit to convertUnits.targetUnit;\n        \n        action provideISQUnits { out unit : Unit; }\n        action provideUSCustomaryUnits { out unit : Unit; }\n    }\n}",
    "package 'HeadlampTiltValidation' {\n\timport ISQ::*;\n\timport SI::*;\n\timport ScalarValues::*;\n\t\n\tattribute def TiltAngle :> ScalarQuantityValue {\n\t\tattribute quantityDimension = ISQ::angle;\n\t\tattribute measurementUnit = SI::degree;\n\t}\n\t\n\tattribute def ValidationResult {\n\t\tattribute isValid: Boolean;\n\t\tattribute measuredAngle: TiltAngle;\n\t}\n\t\n\tport def TiltAnglePort {\n\t\tin tiltAngle: TiltAngle;\n\t}\n\t\n\tport def ValidationResultPort {\n\t\tout validationResult: ValidationResult;\n\t}\n\t\n\tpart headlampTiltValidationSystem {\n\t\tattribute minValidAngle: TiltAngle = 50 [SI::degree];\n\t\tattribute maxValidAngle: TiltAngle = 80 [SI::degree];\n\t\t\n\t\tport tiltAnglePort: TiltAnglePort;\n\t\tport validationResultPort: ValidationResultPort;\n\t\t\n\t\tperform validateTiltAngle {\n\t\t\tin tiltAngle = tiltAnglePort.tiltAngle;\n\t\t\tout validationResult = validationResultPort.validationResult;\n\t\t}\n\t}\n\t\n\taction validateTiltAngle {\n\t\tin tiltAngle: TiltAngle;\n\t\tout validationResult: ValidationResult;\n\t\t\n\t\tbind validationResult.measuredAngle = tiltAngle;\n\t\tbind validationResult.isValid = (tiltAngle >= 50 [SI::degree] and tiltAngle <= 80 [SI::degree]);\n\t}\n}",
    "package 'DataManagementSystem' {\n    import ScalarValues::*;\n    \n    attribute def UnsignedInteger :> Integer {\n        assert constraint { self >= 0 }\n    }\n    \n    attribute def UnsignedFloat :> Real {\n        assert constraint { self >= 0.0 }\n    }\n    \n    attribute def DateTime :> String;\n    \n    attribute def StatusLevel :> String {\n        assert constraint { self == \"critical\" or self == \"warning\" or self == \"normal\" }\n    }\n    \n    attribute def ColorLabel :> String {\n        assert constraint { self == \"red\" or self == \"yellow\" or self == \"green\" }\n    }\n    \n    attribute def DiameterSize :> String {\n        assert constraint { self == \"Small (60 mm)\" or self == \"Medium (70 mm)\" or self == \"Large (80 mm)\" }\n    }\n    \n    attribute def Diameter {\n        attribute size: DiameterSize default \"Small (60 mm)\";\n        attribute value: UnsignedFloat;\n        assert constraint {\n            (size == \"Small (60 mm)\" implies value == 60.0) and\n            (size == \"Medium (70 mm)\" implies value == 70.0) and\n            (size == \"Large (80 mm)\" implies value == 80.0)\n        }\n    }\n    \n    calc def statusToColor {\n        in status: StatusLevel;\n        return color: ColorLabel = \n            if status == \"critical\" then \"red\"\n            else if status == \"warning\" then \"yellow\" \n            else \"green\";\n    }\n    \n    part dataManager {\n        attribute unsignedInt: UnsignedInteger;\n        attribute unsignedFloat: UnsignedFloat;\n        attribute dateTime: DateTime;\n        attribute stringValue: String;\n        attribute booleanValue: Boolean;\n        attribute currentStatus: StatusLevel;\n        attribute statusColor: ColorLabel = statusToColor(currentStatus);\n        attribute diameter: Diameter;\n    }\n}",
    "package 'CollectionManagementSystem' {\n    part def SparePart;\n    part def Person;\n    \n    attribute def Integer;\n    attribute def String;\n    attribute def Real;\n    \n    part def CollectionManager {\n        attribute spareParts : SparePart[*] nonunique;\n        attribute integers : Integer[*] ordered;\n        attribute strings : String[*] unique;\n        attribute personnel : Person[*] ordered unique;\n        attribute personnelGroups : Person[*] unique [*] ordered;\n        attribute realNumbers : Real[4];\n    }\n    \n    part collectionSystem : CollectionManager {\n        perform manageCollections {\n            action archiveSpareParts {\n                inout parts : SparePart[*] nonunique = spareParts;\n            }\n            \n            action storeIntegers {\n                inout intList : Integer[*] ordered = integers;\n            }\n            \n            action manageStrings {\n                inout stringSet : String[*] unique = strings;\n            }\n            \n            action managePersonnel {\n                inout personOrderedSet : Person[*] ordered unique = personnel;\n            }\n            \n            action managePersonnelGroups {\n                inout personSetList : Person[*] unique [*] ordered = personnelGroups;\n            }\n            \n            action processRealNumbers {\n                inout realArray : Real[4] = realNumbers;\n            }\n        }\n    }\n}",
    "package 'TireInformationSystem' {\n    attribute def ManufacturerName;\n    attribute def RimDiameter;\n    attribute def TireWidth;\n    attribute def InstallationPosition[0..1] {\n        attribute x: Real;\n        attribute y: Real;\n        attribute z: Real;\n    }\n    \n    part def Tire {\n        attribute manufacturer: ManufacturerName;\n        attribute rimDiameter: RimDiameter;\n        attribute tireWidth: TireWidth;\n        attribute position: InstallationPosition[0..1];\n    }\n    \n    part tireInventory {\n        part michelinTire: Tire {\n            attribute redefines manufacturer = \"Michelin\";\n            attribute redefines rimDiameter = 18;\n            attribute redefines tireWidth = 245;\n        }\n    }\n}",
    "package 'SpacecraftTrajectorySystem' {\n\tattribute def Time;\n\tattribute def Position;\n\tattribute def Velocity;\n\tattribute def TrajectoryData {\n\t\ttime: Time;\n\t\tposition: Position;\n\t\tvelocity: Velocity;\n\t}\n\t\n\tport def TrajectoryDataPort {\n\t\tout trajectoryData: TrajectoryData;\n\t}\n\t\n\tport def SampledDataPort {\n\t\tin trajectoryData: TrajectoryData;\n\t}\n\t\n\tpart context {\n\t\tpart spacecraft {\n\t\t\tport trajectoryDataPort: TrajectoryDataPort;\n\t\t\tperform recordTrajectory.generateTrajectoryData {\n\t\t\t\tout trajectoryData = trajectoryDataPort.trajectoryData;\n\t\t\t}\n\t\t}\n\t\t\n\t\tinterface spacecraftToRecorder connect spacecraft.trajectoryDataPort to trajectoryRecorder.sampledDataPort {\n\t\t\tref flow references recordTrajectory.trajectoryDataFlow\n\t\t\t\tfrom source.trajectoryData to target.trajectoryData;\n\t\t}\n\t\t\n\t\tpart trajectoryRecorder {\n\t\t\tport sampledDataPort: SampledDataPort;\n\t\t\tperform recordTrajectory.sampleAndStore {\n\t\t\t\tin trajectoryData = sampledDataPort.trajectoryData;\n\t\t\t}\n\t\t}\n\t}\n\t\n\taction recordTrajectory {\n\t\taction generateTrajectoryData { out trajectoryData: TrajectoryData; }\n\t\tsuccession flow trajectoryDataFlow from generateTrajectoryData.trajectoryData to sampleAndStore.trajectoryData;\n\t\taction sampleAndStore { in trajectoryData: TrajectoryData; }\n\t}\n}",
    "package 'AlloyManagementSystem' {\n    import ISQ::*;\n    import SI::*;\n    \n    attribute def AtomicMass :> ISQ::mass;\n    attribute def MassFraction :> ISQ::dimensionless;\n    attribute def TensileStrength :> ISQ::pressure;\n    \n    attribute def SubstanceProperties {\n        attribute atomicMass: AtomicMass;\n    }\n    \n    attribute def MechanicalProperties {\n        attribute tensileStrength: TensileStrength;\n    }\n    \n    part def Substance {\n        attribute properties: SubstanceProperties;\n    }\n    \n    part def Material :> Substance;\n    \n    part def Metal :> Material;\n    \n    part def AlloyComponent {\n        ref material: Material;\n        attribute massFraction: MassFraction;\n    }\n    \n    part def Alloy :> Material {\n        attribute mechanicalProperties: MechanicalProperties;\n        part components: AlloyComponent[2..*];\n        \n        constraint {\n            sum(components.massFraction) == 1.0\n        }\n    }\n    \n    part iron: Metal {\n        attribute :>> properties {\n            :>> atomicMass = 55.845 [g/mol];\n        }\n    }\n    \n    part carbon: Metal {\n        attribute :>> properties {\n            :>> atomicMass = 12.011 [g/mol];\n        }\n    }\n    \n    part manganese: Metal {\n        attribute :>> properties {\n            :>> atomicMass = 54.938 [g/mol];\n        }\n    }\n    \n    part steel980: Alloy {\n        attribute :>> mechanicalProperties {\n            :>> tensileStrength = 980 [N/mm^2];\n        }\n        \n        part :>> components {\n            part ironComponent: AlloyComponent {\n                :>> material = iron;\n                :>> massFraction = 0.982;\n            }\n            part carbonComponent: AlloyComponent {\n                :>> material = carbon;\n                :>> massFraction = 0.008;\n            }\n            part manganeseComponent: AlloyComponent {\n                :>> material = manganese;\n                :>> massFraction = 0.010;\n            }\n        }\n    }\n}",
    "package 'EngineeringMaterialsDatabase' {\n    import ISQ::*;\n    import SI::*;\n    \n    attribute def AtomicMass :> ScalarQuantityValue {\n        attribute quantityDimension redefines ISQ::mass;\n        attribute measurementUnit redefines SI::kg;\n    }\n    \n    attribute def MassFraction :> ScalarQuantityValue {\n        attribute quantityDimension redefines ISQ::dimensionOne;\n    }\n    \n    attribute def TensileStrength :> ScalarQuantityValue {\n        attribute quantityDimension redefines ISQ::pressure;\n        attribute measurementUnit redefines SI::'N/mm²';\n    }\n    \n    abstract part def Material {\n        attribute atomicMass: AtomicMass;\n        attribute massFraction: MassFraction[0..*];\n    }\n    \n    part def Metal :> Material {\n        attribute composition: Composition[0..*];\n    }\n    \n    part def Alloy :> Metal {\n        part constituents: Material[1..*];\n        attribute constituentMassFractions: MassFraction[1..*];\n    }\n    \n    attribute def Composition {\n        attribute element: Material;\n        attribute fraction: MassFraction;\n    }\n    \n    attribute def MechanicalProperties {\n        attribute tensileStrength: TensileStrength;\n    }\n    \n    part def Steel :> Alloy {\n        attribute mechanicalProperties: MechanicalProperties;\n    }\n    \n    part steel_980: Steel {\n        part :>> constituents {\n            part iron: Metal {\n                attribute :>> massFraction = 0.978;\n            }\n            part carbon: Material {\n                attribute :>> massFraction = 0.002;\n            }\n            part manganese: Metal {\n                attribute :>> massFraction = 0.020;\n            }\n        }\n        attribute :>> mechanicalProperties {\n            attribute :>> tensileStrength = 980 ['N/mm²'];\n        }\n    }\n    \n    action def QueryMaterial {\n        in materialId;\n        out materialData: Material;\n    }\n    \n    action def CompareMaterials {\n        in material1: Material;\n        in material2: Material;\n        out comparisonResult;\n    }\n    \n    action def AddMaterial {\n        in newMaterial: Material;\n        out success: Boolean;\n    }\n}",
    "package 'PubSubSystem' {\n\tattribute def Message;\n\tattribute def Topic;\n\tattribute def Subscription;\n\t\n\tport def PublishPort {\n\t\tin topic : Topic;\n\t\tin message : Message;\n\t}\n\t\n\tport def SubscribePort {\n\t\tin topic : Topic;\n\t\tout subscription : Subscription;\n\t}\n\t\n\tport def ReceivePort {\n\t\tout topic : Topic;\n\t\tout message : Message;\n\t}\n\t\n\tpart context {\n\t\tpart producer {\n\t\t\tport publishPort : PublishPort;\n\t\t\tperform messaging.publishMessage {\n\t\t\t\tout topic = publishPort.topic;\n\t\t\t\tout message = publishPort.message;\n\t\t\t}\n\t\t}\n\t\t\n\t\tinterface producerToServer connect producer.publishPort to server.publishPort {\n\t\t\tref flow references messaging.publishFlow\n\t\t\t\tfrom source.topic to target.topic;\n\t\t\tref flow references messaging.publishFlow\n\t\t\t\tfrom source.message to target.message;\n\t\t}\n\t\t\n\t\tpart server {\n\t\t\tport publishPort : ~PublishPort;\n\t\t\tport subscribePort : ~SubscribePort;\n\t\t\tport distributePort : ReceivePort;\n\t\t\t\n\t\t\tperform messaging.routeMessage {\n\t\t\t\tin topic = publishPort.topic;\n\t\t\t\tin message = publishPort.message;\n\t\t\t\tin subscription = subscribePort.subscription;\n\t\t\t\tout distributeTopic = distributePort.topic;\n\t\t\t\tout distributeMessage = distributePort.message;\n\t\t\t}\n\t\t}\n\t\t\n\t\tinterface serverToConsumer connect server.distributePort to consumer.receivePort {\n\t\t\tref flow references messaging.distributeFlow\n\t\t\t\tfrom source.topic to target.topic;\n\t\t\tref flow references messaging.distributeFlow\n\t\t\t\tfrom source.message to target.message;\n\t\t}\n\t\t\n\t\tinterface consumerToServer connect consumer.subscribePort to server.subscribePort {\n\t\t\tref flow references messaging.subscribeFlow\n\t\t\t\tfrom source.topic to target.topic;\n\t\t\tref flow references messaging.subscribeFlow\n\t\t\t\tfrom source.subscription to target.subscription;\n\t\t}\n\t\t\n\t\tpart consumer {\n\t\t\tport subscribePort : SubscribePort;\n\t\t\tport receivePort : ~ReceivePort;\n\t\t\t\n\t\t\tperform messaging.subscribe {\n\t\t\t\tout topic = subscribePort.topic;\n\t\t\t\tin subscription = subscribePort.subscription;\n\t\t\t}\n\t\t\t\n\t\t\tperform messaging.receiveMessage {\n\t\t\t\tin topic = receivePort.topic;\n\t\t\t\tin message = receivePort.message;\n\t\t\t}\n\t\t}\n\t}\n\t\n\taction messaging {\n\t\taction publishMessage { out topic : Topic; out message : Message; }\n\t\tsuccession flow publishFlow from publishMessage to routeMessage;\n\t\t\n\t\taction subscribe { out topic : Topic; in subscription : Subscription; }\n\t\tsuccession flow subscribeFlow from subscribe to routeMessage;\n\t\t\n\t\taction routeMessage { \n\t\t\tin topic : Topic; \n\t\t\tin message : Message; \n\t\t\tin subscription : Subscription;\n\t\t\tout distributeTopic : Topic;\n\t\t\tout distributeMessage : Message;\n\t\t}\n\t\tsuccession flow distributeFlow from routeMessage to receiveMessage;\n\t\t\n\t\taction receiveMessage { in topic : Topic; in message : Message; }\n\t}\n}",
    "package 'VehicleFuelSystem' {\n\tattribute def Fuel;\n\tattribute def FuelTemperature;\n\t\n\tport def FuelSupplyPort {\n\t\tout fuel: Fuel;\n\t\tout fuelTemp: FuelTemperature;\n\t}\n\t\n\tport def FuelReturnPort {\n\t\tin fuel: Fuel;\n\t\tout fuelTemp: FuelTemperature;\n\t}\n\t\n\tpart vehicle {\n\t\tpart fuelTankAssembly {\n\t\t\tport supplyPort: FuelSupplyPort;\n\t\t\tport returnPort: ~FuelReturnPort;\n\t\t\t\n\t\t\tperform fuelFlow.supplyFuel {\n\t\t\t\tout fuel = supplyPort.fuel;\n\t\t\t\tout fuelTemp = supplyPort.fuelTemp;\n\t\t\t}\n\t\t\t\n\t\t\tperform fuelFlow.receiveFuel {\n\t\t\t\tin fuel = returnPort.fuel;\n\t\t\t\tout fuelTemp = returnPort.fuelTemp;\n\t\t\t}\n\t\t}\n\t\t\n\t\tpart engine {\n\t\t\tport supplyPort: ~FuelSupplyPort;\n\t\t\tport returnPort: FuelReturnPort;\n\t\t\t\n\t\t\tperform fuelFlow.consumeFuel {\n\t\t\t\tin fuel = supplyPort.fuel;\n\t\t\t\tin fuelTemp = supplyPort.fuelTemp;\n\t\t\t\tout unusedFuel = returnPort.fuel;\n\t\t\t\tout returnTemp = returnPort.fuelTemp;\n\t\t\t}\n\t\t}\n\t\t\n\t\tinterface fuelSupplyLine connect fuelTankAssembly.supplyPort to engine.supplyPort {\n\t\t\tref flow references fuelFlow.supplyFlow\n\t\t\t\tfrom source.fuel to target.fuel;\n\t\t\tref flow references fuelFlow.supplyTempFlow\n\t\t\t\tfrom source.fuelTemp to target.fuelTemp;\n\t\t}\n\t\t\n\t\tinterface fuelReturnLine connect engine.returnPort to fuelTankAssembly.returnPort {\n\t\t\tref flow references fuelFlow.returnFlow\n\t\t\t\tfrom source.fuel to target.fuel;\n\t\t\tref flow references fuelFlow.returnTempFlow\n\t\t\t\tfrom source.fuelTemp to target.fuelTemp;\n\t\t}\n\t}\n\t\n\taction fuelFlow {\n\t\taction supplyFuel { out fuel: Fuel; out fuelTemp: FuelTemperature; }\n\t\tsuccession flow supplyFlow from supplyFuel.fuel to consumeFuel.fuel;\n\t\tsuccession flow supplyTempFlow from supplyFuel.fuelTemp to consumeFuel.fuelTemp;\n\t\t\n\t\taction consumeFuel { \n\t\t\tin fuel: Fuel; \n\t\t\tin fuelTemp: FuelTemperature;\n\t\t\tout unusedFuel: Fuel;\n\t\t\tout returnTemp: FuelTemperature;\n\t\t}\n\t\tsuccession flow returnFlow from consumeFuel.unusedFuel to receiveFuel.fuel;\n\t\tsuccession flow returnTempFlow from consumeFuel.returnTemp to receiveFuel.fuelTemp;\n\t\t\n\t\taction receiveFuel { in fuel: Fuel; out fuelTemp: FuelTemperature; }\n\t}\n}",
    "package 'PublishSubscribeSystem' {\n\tattribute def Topic;\n\tattribute def Message;\n\tattribute def SubscriptionRequest;\n\t\n\tport def SubscriptionPort {\n\t\tout subscriptionRequest : SubscriptionRequest;\n\t}\n\t\n\tport def MessagePublishPort {\n\t\tout message : Message;\n\t}\n\t\n\tport def MessageDeliveryPort {\n\t\tout message : Message;\n\t}\n\t\n\tpart context {\n\t\tpart consumer[1..*] {\n\t\t\tport subscriptionPort : SubscriptionPort;\n\t\t\tport messageDeliveryPort : ~MessageDeliveryPort;\n\t\t\t\n\t\t\tperform messageFlow.subscribe {\n\t\t\t\tout subscriptionRequest = subscriptionPort.subscriptionRequest;\n\t\t\t}\n\t\t\t\n\t\t\tperform messageFlow.receiveMessage {\n\t\t\t\tin message = messageDeliveryPort.message;\n\t\t\t}\n\t\t}\n\t\t\n\t\tinterface consumerToServer connect consumer.subscriptionPort to server.subscriptionPort {\n\t\t\tref flow references messageFlow.subscriptionFlow\n\t\t\t\tfrom source.subscriptionRequest to target.subscriptionRequest;\n\t\t}\n\t\t\n\t\tinterface serverToConsumer connect server.messageDeliveryPort to consumer.messageDeliveryPort {\n\t\t\tref flow references messageFlow.deliveryFlow\n\t\t\t\tfrom source.message to target.message;\n\t\t}\n\t\t\n\t\tpart server {\n\t\t\tport subscriptionPort : ~SubscriptionPort;\n\t\t\tport messagePublishPort : ~MessagePublishPort;\n\t\t\tport messageDeliveryPort : MessageDeliveryPort;\n\t\t\t\n\t\t\tperform messageFlow.processSubscription {\n\t\t\t\tin subscriptionRequest = subscriptionPort.subscriptionRequest;\n\t\t\t}\n\t\t\t\n\t\t\tperform messageFlow.routeMessage {\n\t\t\t\tin message = messagePublishPort.message;\n\t\t\t\tout message = messageDeliveryPort.message;\n\t\t\t}\n\t\t}\n\t\t\n\t\tpart producer[1..*] {\n\t\t\tport messagePublishPort : MessagePublishPort;\n\t\t\t\n\t\t\tperform messageFlow.publishMessage {\n\t\t\t\tout message = messagePublishPort.message;\n\t\t\t}\n\t\t}\n\t\t\n\t\tinterface producerToServer connect producer.messagePublishPort to server.messagePublishPort {\n\t\t\tref flow references messageFlow.publishFlow\n\t\t\t\tfrom source.message to target.message;\n\t\t}\n\t}\n\t\n\taction messageFlow {\n\t\taction subscribe { out subscriptionRequest : SubscriptionRequest; }\n\t\tsuccession flow subscriptionFlow from subscribe.subscriptionRequest to processSubscription.subscriptionRequest;\n\t\taction processSubscription { in subscriptionRequest : SubscriptionRequest; }\n\t\t\n\t\taction publishMessage { out message : Message; }\n\t\tsuccession flow publishFlow from publishMessage.message to routeMessage.message;\n\t\taction routeMessage { in message : Message; out message : Message; }\n\t\tsuccession flow deliveryFlow from routeMessage.message to receiveMessage.message;\n\t\taction receiveMessage { in message : Message; }\n\t}\n}",
    "package 'TransportationSystem' {\n\tattribute def FuelLevel;\n\tattribute def TravelCommand;\n\tattribute def BoardingRequest;\n\tattribute def RefuelRequest;\n\t\n\tport def TravelCommandPort {\n\t\tout travelCommand : TravelCommand;\n\t}\n\tport def FuelLevelPort {\n\t\tout fuelLevel : FuelLevel;\n\t}\n\tport def BoardingRequestPort {\n\t\tout boardingRequest : BoardingRequest;\n\t}\n\tport def RefuelRequestPort {\n\t\tout refuelRequest : RefuelRequest;\n\t}\n\t\n\tpart context {\n\t\tpart driver {\n\t\t\tport travelCommandPort : TravelCommandPort;\n\t\t\tport refuelRequestPort : RefuelRequestPort;\n\t\t\tport boardingRequestPort : BoardingRequestPort;\n\t\t\t\n\t\t\tperform transportation.operateVehicle {\n\t\t\t\tout travelCommand = travelCommandPort.travelCommand;\n\t\t\t}\n\t\t\tperform transportation.requestRefuel {\n\t\t\t\tout refuelRequest = refuelRequestPort.refuelRequest;\n\t\t\t}\n\t\t\tperform transportation.enterVehicle {\n\t\t\t\tout boardingRequest = boardingRequestPort.boardingRequest;\n\t\t\t}\n\t\t}\n\t\t\n\t\tpart passengers[0..4] {\n\t\t\tport boardingRequestPort : BoardingRequestPort;\n\t\t\t\n\t\t\tperform transportation.enterVehicle {\n\t\t\t\tout boardingRequest = boardingRequestPort.boardingRequest;\n\t\t\t}\n\t\t}\n\t\t\n\t\tinterface driverToVehicle connect driver.travelCommandPort to vehicle.travelCommandPort {\n\t\t\tref flow references transportation.travelCommandFlow\n\t\t\t\tfrom source.travelCommand to target.travelCommand;\n\t\t}\n\t\t\n\t\tinterface driverBoardingToVehicle connect driver.boardingRequestPort to vehicle.boardingRequestPort {\n\t\t\tref flow references transportation.boardingFlow\n\t\t\t\tfrom source.boardingRequest to target.boardingRequest;\n\t\t}\n\t\t\n\t\tinterface passengerToVehicle connect passengers.boardingRequestPort to vehicle.boardingRequestPort {\n\t\t\tref flow references transportation.boardingFlow\n\t\t\t\tfrom source.boardingRequest to target.boardingRequest;\n\t\t}\n\t\t\n\t\tinterface vehicleToGasStation connect vehicle.refuelRequestPort to gasStation.refuelRequestPort {\n\t\t\tref flow references transportation.refuelFlow\n\t\t\t\tfrom source.refuelRequest to target.refuelRequest;\n\t\t}\n\t\t\n\t\tpart vehicle {\n\t\t\tport travelCommandPort : ~TravelCommandPort;\n\t\t\tport boardingRequestPort : ~BoardingRequestPort;\n\t\t\tport fuelLevelPort : FuelLevelPort;\n\t\t\tport refuelRequestPort : RefuelRequestPort;\n\t\t\t\n\t\t\tperform transportation.transport {\n\t\t\t\tin travelCommand = travelCommandPort.travelCommand;\n\t\t\t\tin boardingRequest = boardingRequestPort.boardingRequest;\n\t\t\t\tout fuelLevel = fuelLevelPort.fuelLevel;\n\t\t\t\tout refuelRequest = refuelRequestPort.refuelRequest;\n\t\t\t}\n\t\t}\n\t\t\n\t\tpart gasStation {\n\t\t\tport refuelRequestPort : ~RefuelRequestPort;\n\t\t\t\n\t\t\tperform transportation.provideFuel {\n\t\t\t\tin refuelRequest = refuelRequestPort.refuelRequest;\n\t\t\t}\n\t\t}\n\t\t\n\t\tpart environment {\n\t\t\tperform transportation.affectTravel;\n\t\t}\n\t}\n\t\n\taction transportation {\n\t\taction enterVehicle { out boardingRequest : BoardingRequest; }\n\t\tsuccession flow boardingFlow from enterVehicle.boardingRequest to transport.boardingRequest;\n\t\t\n\t\taction operateVehicle { out travelCommand : TravelCommand; }\n\t\tsuccession flow travelCommandFlow from operateVehicle.travelCommand to transport.travelCommand;\n\t\t\n\t\taction transport { \n\t\t\tin travelCommand : TravelCommand; \n\t\t\tin boardingRequest : BoardingRequest;\n\t\t\tout fuelLevel : FuelLevel; \n\t\t\tout refuelRequest : RefuelRequest;\n\t\t}\n\t\t\n\t\tsuccession flow refuelFlow from transport.refuelRequest to provideFuel.refuelRequest;\n\t\taction provideFuel { in refuelRequest : RefuelRequest; }\n\t\t\n\t\taction requestRefuel { out refuelRequest : RefuelRequest; }\n\t\taction affectTravel;\n\t\taction exitVehicle;\n\t}\n}",
    "package 'FuelSystem' {\n\tattribute def Fuel;\n\tattribute def Temperature;\n\t\n\tport def FuelPort {\n\t\tinout fuel : Fuel;\n\t\tout temperature : Temperature;\n\t}\n\t\n\tpart context {\n\t\tpart fuelTank {\n\t\t\tport fuelOutletPort : FuelPort;\n\t\t\tperform fuelManagement.supplyFuel {\n\t\t\t\tout fuel = fuelOutletPort.fuel;\n\t\t\t\tout temperature = fuelOutletPort.temperature;\n\t\t\t}\n\t\t\tperform fuelManagement.receiveFuelReturn {\n\t\t\t\tin fuel = fuelOutletPort.fuel;\n\t\t\t}\n\t\t}\n\t\t\n\t\tinterface fuelInterface connect fuelTank.fuelOutletPort to engine.fuelInletPort {\n\t\t\tref flow references fuelManagement.fuelSupplyFlow\n\t\t\t\tfrom source.fuel to target.fuel;\n\t\t\tref flow references fuelManagement.fuelReturnFlow\n\t\t\t\tfrom target.fuel to source.fuel;\n\t\t\tref flow references fuelManagement.temperatureFlow\n\t\t\t\tfrom source.temperature to target.temperature;\n\t\t}\n\t\t\n\t\tpart engine {\n\t\t\tport fuelInletPort : ~FuelPort;\n\t\t\tperform fuelManagement.consumeFuel {\n\t\t\t\tin fuel = fuelInletPort.fuel;\n\t\t\t\tin temperature = fuelInletPort.temperature;\n\t\t\t}\n\t\t\tperform fuelManagement.returnFuel {\n\t\t\t\tout fuel = fuelInletPort.fuel;\n\t\t\t}\n\t\t}\n\t}\n\t\n\taction fuelManagement {\n\t\taction supplyFuel { out fuel : Fuel; out temperature : Temperature; }\n\t\tsuccession flow fuelSupplyFlow from supplyFuel.fuel to consumeFuel.fuel;\n\t\tsuccession flow temperatureFlow from supplyFuel.temperature to consumeFuel.temperature;\n\t\taction consumeFuel { in fuel : Fuel; in temperature : Temperature; }\n\t\taction returnFuel { out fuel : Fuel; }\n\t\tsuccession flow fuelReturnFlow from returnFuel.fuel to receiveFuelReturn.fuel;\n\t\taction receiveFuelReturn { in fuel : Fuel; }\n\t}\n}",
    "package 'FuelSystem' {\n\tattribute def Fuel;\n\tattribute def Temperature;\n\t\n\tport def FuelSupplyPort {\n\t\tout fuel: Fuel;\n\t\tout temperature: Temperature;\n\t}\n\t\n\tport def FuelReturnPort {\n\t\tin fuel: Fuel;\n\t\tout temperature: Temperature;\n\t}\n\t\n\tpart fuelSystemContext {\n\t\tpart fuelTankAssembly {\n\t\t\tport supplyPort: FuelSupplyPort;\n\t\t\tport returnPort: FuelReturnPort;\n\t\t\t\n\t\t\tperform manageFuel.supplyFuel {\n\t\t\t\tout fuel = supplyPort.fuel;\n\t\t\t\tout temperature = supplyPort.temperature;\n\t\t\t}\n\t\t\t\n\t\t\tperform manageFuel.receiveFuel {\n\t\t\t\tin fuel = returnPort.fuel;\n\t\t\t\tout temperature = returnPort.temperature;\n\t\t\t}\n\t\t}\n\t\t\n\t\tinterface fuelSupplyInterface connect fuelTankAssembly.supplyPort to engine.supplyPort {\n\t\t\tref flow references manageFuel.fuelSupplyFlow\n\t\t\t\tfrom source.fuel to target.fuel;\n\t\t\tref flow references manageFuel.supplyTempFlow\n\t\t\t\tfrom source.temperature to target.temperature;\n\t\t}\n\t\t\n\t\tinterface fuelReturnInterface connect engine.returnPort to fuelTankAssembly.returnPort {\n\t\t\tref flow references manageFuel.fuelReturnFlow\n\t\t\t\tfrom source.fuel to target.fuel;\n\t\t\tref flow references manageFuel.returnTempFlow\n\t\t\t\tfrom source.temperature to target.temperature;\n\t\t}\n\t\t\n\t\tpart engine {\n\t\t\tport supplyPort: ~FuelSupplyPort;\n\t\t\tport returnPort: ~FuelReturnPort;\n\t\t\t\n\t\t\tperform manageFuel.consumeFuel {\n\t\t\t\tin fuel = supplyPort.fuel;\n\t\t\t\tin temperature = supplyPort.temperature;\n\t\t\t\tout returnFuel = returnPort.fuel;\n\t\t\t\tout returnTemperature = returnPort.temperature;\n\t\t\t}\n\t\t}\n\t}\n\t\n\taction manageFuel {\n\t\taction supplyFuel { out fuel: Fuel; out temperature: Temperature; }\n\t\tsuccession flow fuelSupplyFlow from supplyFuel.fuel to consumeFuel.fuel;\n\t\tsuccession flow supplyTempFlow from supplyFuel.temperature to consumeFuel.temperature;\n\t\t\n\t\taction consumeFuel { \n\t\t\tin fuel: Fuel; \n\t\t\tin temperature: Temperature;\n\t\t\tout returnFuel: Fuel;\n\t\t\tout returnTemperature: Temperature;\n\t\t}\n\t\tsuccession flow fuelReturnFlow from consumeFuel.returnFuel to receiveFuel.fuel;\n\t\tsuccession flow returnTempFlow from consumeFuel.returnTemperature to receiveFuel.temperature;\n\t\t\n\t\taction receiveFuel { in fuel: Fuel; out temperature: Temperature; }\n\t}\n}",
    "package 'PhotoCaptureSystem' {\n\tattribute def SceneSelection;\n\tattribute def FocusedImage;\n\tattribute def Photo;\n\t\n\tport def SceneSelectionPort {\n\t\tout sceneSelection : SceneSelection;\n\t}\n\t\n\tport def FocusedImagePort {\n\t\tout focusedImage : FocusedImage;\n\t}\n\t\n\tport def PhotoPort {\n\t\tout photo : Photo;\n\t}\n\t\n\tpart context {\n\t\tpart user {\n\t\t\tport sceneSelectionPort : SceneSelectionPort;\n\t\t\tperform capturePhoto.selectScene {\n\t\t\t\tout sceneSelection = sceneSelectionPort.sceneSelection;\n\t\t\t}\n\t\t}\n\t\t\n\t\tinterface userToSystem connect user.sceneSelectionPort to photoSystem.sceneSelectionPort {\n\t\t\tref flow references capturePhoto.sceneSelectionFlow\n\t\t\t\tfrom source.sceneSelection to target.sceneSelection;\n\t\t}\n\t\t\n\t\tpart photoSystem {\n\t\t\tport sceneSelectionPort : ~SceneSelectionPort;\n\t\t\tport focusedImagePort : FocusedImagePort;\n\t\t\tport photoPort : PhotoPort;\n\t\t\t\n\t\t\tperform capturePhoto.autoFocus {\n\t\t\t\tin sceneSelection = sceneSelectionPort.sceneSelection;\n\t\t\t\tout focusedImage = focusedImagePort.focusedImage;\n\t\t\t}\n\t\t\t\n\t\t\tperform capturePhoto.captureImage {\n\t\t\t\tin focusedImage = focusedImagePort.focusedImage;\n\t\t\t\tout photo = photoPort.photo;\n\t\t\t}\n\t\t}\n\t}\n\t\n\taction capturePhoto {\n\t\taction selectScene { out sceneSelection : SceneSelection; }\n\t\tsuccession flow sceneSelectionFlow from selectScene.sceneSelection to autoFocus.sceneSelection;\n\t\taction autoFocus { in sceneSelection : SceneSelection; out focusedImage : FocusedImage; }\n\t\tsuccession flow focusedImageFlow from autoFocus.focusedImage to captureImage.focusedImage;\n\t\taction captureImage { in focusedImage : FocusedImage; out photo : Photo; }\n\t}\n}",
    "package 'PhotographySystem' {\n\tattribute def Scene;\n\tattribute def FocusedImage;\n\tattribute def FinalPhotograph;\n\t\n\tport def ScenePort {\n\t\tout scene : Scene;\n\t}\n\t\n\tport def FocusedImagePort {\n\t\tout focusedImage : FocusedImage;\n\t}\n\t\n\tport def FinalPhotographPort {\n\t\tout finalPhotograph : FinalPhotograph;\n\t}\n\t\n\tpart context {\n\t\tpart user {\n\t\t\tport scenePort : ScenePort;\n\t\t\tperform photographyWorkflow.selectScene {\n\t\t\t\tout scene = scenePort.scene;\n\t\t\t}\n\t\t}\n\t\t\n\t\tinterface userToSystem connect user.scenePort to photographySystem.scenePort {\n\t\t\tref flow references photographyWorkflow.sceneFlow\n\t\t\t\tfrom source.scene to target.scene;\n\t\t}\n\t\t\n\t\tpart photographySystem {\n\t\t\tport scenePort : ~ScenePort;\n\t\t\tport focusedImagePort : FocusedImagePort;\n\t\t\tport finalPhotographPort : FinalPhotographPort;\n\t\t\t\n\t\t\tperform photographyWorkflow.focusing {\n\t\t\t\tin scene = scenePort.scene;\n\t\t\t\tout focusedImage = focusedImagePort.focusedImage;\n\t\t\t}\n\t\t\t\n\t\t\tperform photographyWorkflow.shooting {\n\t\t\t\tin focusedImage = focusedImagePort.focusedImage;\n\t\t\t\tout finalPhotograph = finalPhotographPort.finalPhotograph;\n\t\t\t}\n\t\t}\n\t}\n\t\n\taction photographyWorkflow {\n\t\taction selectScene { out scene : Scene; }\n\t\tsuccession flow sceneFlow from selectScene.scene to focusing.scene;\n\t\taction focusing { in scene : Scene; out focusedImage : FocusedImage; }\n\t\tsuccession flow focusedImageFlow from focusing.focusedImage to shooting.focusedImage;\n\t\taction shooting { in focusedImage : FocusedImage; out finalPhotograph : FinalPhotograph; }\n\t}\n}",
    "package 'PhotographySystem' {\n\tattribute def Scene;\n\tattribute def Image;\n\tattribute def Photograph;\n\t\n\tport def ScenePort {\n\t\tout scene : Scene;\n\t}\n\t\n\tport def ImagePort {\n\t\tout image : Image;\n\t}\n\t\n\tport def PhotographPort {\n\t\tout photograph : Photograph;\n\t}\n\t\n\tpart context {\n\t\tpart user {\n\t\t\tport scenePort : ScenePort;\n\t\t\tperform capturePhotograph.selectScene {\n\t\t\t\tout scene = scenePort.scene;\n\t\t\t}\n\t\t}\n\t\t\n\t\tinterface userToSystem connect user.scenePort to photographySystem.scenePort {\n\t\t\tref flow references capturePhotograph.sceneFlow\n\t\t\t\tfrom source.scene to target.scene;\n\t\t}\n\t\t\n\t\tpart photographySystem {\n\t\t\tport scenePort : ~ScenePort;\n\t\t\tport imagePort : ImagePort;\n\t\t\tport photographPort : PhotographPort;\n\t\t\t\n\t\t\tperform capturePhotograph.focus {\n\t\t\t\tin scene = scenePort.scene;\n\t\t\t\tout image = imagePort.image;\n\t\t\t}\n\t\t\t\n\t\t\tperform capturePhotograph.shoot {\n\t\t\t\tin image = imagePort.image;\n\t\t\t\tout photograph = photographPort.photograph;\n\t\t\t}\n\t\t}\n\t}\n\t\n\taction capturePhotograph {\n\t\taction selectScene { out scene : Scene; }\n\t\tsuccession flow sceneFlow from selectScene.scene to focus.scene;\n\t\taction focus { in scene : Scene; out image : Image; }\n\t\tsuccession flow imageFlow from focus.image to shoot.image;\n\t\taction shoot { in image : Image; out photograph : Photograph; }\n\t}\n}",
    "package 'AutomatedPhotographySystem' {\n\tattribute def Scene;\n\tattribute def FocusedImage;\n\tattribute def Photograph;\n\t\n\tport def ScenePort {\n\t\tout scene : Scene;\n\t}\n\t\n\tport def FocusedImagePort {\n\t\tout focusedImage : FocusedImage;\n\t}\n\t\n\tport def PhotographPort {\n\t\tout photograph : Photograph;\n\t}\n\t\n\tpart context {\n\t\tpart user {\n\t\t\tport scenePort : ScenePort;\n\t\t\tperform automatePhotography.provideScene {\n\t\t\t\tout scene = scenePort.scene;\n\t\t\t}\n\t\t}\n\t\t\n\t\tinterface userToSystem connect user.scenePort to photographySystem.scenePort {\n\t\t\tref flow references automatePhotography.sceneFlow\n\t\t\t\tfrom source.scene to target.scene;\n\t\t}\n\t\t\n\t\tpart photographySystem {\n\t\t\tport scenePort : ~ScenePort;\n\t\t\tport focusedImagePort : FocusedImagePort;\n\t\t\tport photographPort : PhotographPort;\n\t\t\t\n\t\t\tperform automatePhotography.focusScene {\n\t\t\t\tin scene = scenePort.scene;\n\t\t\t\tout focusedImage = focusedImagePort.focusedImage;\n\t\t\t}\n\t\t\t\n\t\t\tperform automatePhotography.capturePhotograph {\n\t\t\t\tin focusedImage = focusedImagePort.focusedImage;\n\t\t\t\tout photograph = photographPort.photograph;\n\t\t\t}\n\t\t}\n\t}\n\t\n\taction automatePhotography {\n\t\taction provideScene { out scene : Scene; }\n\t\tsuccession flow sceneFlow from provideScene.scene to focusScene.scene;\n\t\taction focusScene { in scene : Scene; out focusedImage : FocusedImage; }\n\t\tsuccession flow focusedImageFlow from focusScene.focusedImage to capturePhotograph.focusedImage;\n\t\taction capturePhotograph { in focusedImage : FocusedImage; out photograph : Photograph; }\n\t}\n}",
    "package 'PhotographyWorkflow' {\n\tattribute def Scene;\n\tattribute def Image;\n\tattribute def Picture;\n\t\n\tport def ScenePort {\n\t\tin scene : Scene;\n\t}\n\t\n\tport def ImagePort {\n\t\tout image : Image;\n\t}\n\t\n\tport def PicturePort {\n\t\tout picture : Picture;\n\t}\n\t\n\tpart context {\n\t\tpart user {\n\t\t\tport scenePort : ScenePort;\n\t\t\tperform photographyProcess.provideScene {\n\t\t\t\tout scene = scenePort.scene;\n\t\t\t}\n\t\t}\n\t\t\n\t\tinterface userToSystem connect user.scenePort to photographySystem.scenePort {\n\t\t\tref flow references photographyProcess.sceneFlow\n\t\t\t\tfrom source.scene to target.scene;\n\t\t}\n\t\t\n\t\tpart photographySystem {\n\t\t\tport scenePort : ~ScenePort;\n\t\t\tport imagePort : ImagePort;\n\t\t\tport picturePort : PicturePort;\n\t\t\t\n\t\t\tperform photographyProcess.focus {\n\t\t\t\tin scene = scenePort.scene;\n\t\t\t\tout image = imagePort.image;\n\t\t\t}\n\t\t\t\n\t\t\tperform photographyProcess.shoot {\n\t\t\t\tin image = imagePort.image;\n\t\t\t\tout picture = picturePort.picture;\n\t\t\t}\n\t\t}\n\t}\n\t\n\taction photographyProcess {\n\t\taction provideScene { out scene : Scene; }\n\t\tsuccession flow sceneFlow from provideScene.scene to focus.scene;\n\t\taction focus { in scene : Scene; out image : Image; }\n\t\tsuccession flow imageFlow from focus.image to shoot.image;\n\t\taction shoot { in image : Image; out picture : Picture; }\n\t}\n}",
    "package 'CameraSystem' {\n\tattribute def Scene;\n\tattribute def FocusStatus;\n\tattribute def Image;\n\t\n\tport def ScenePort {\n\t\tout scene : Scene;\n\t}\n\t\n\tport def FocusStatusPort {\n\t\tout focusStatus : FocusStatus;\n\t}\n\t\n\tport def ImagePort {\n\t\tout image : Image;\n\t}\n\t\n\tpart context {\n\t\tpart user {\n\t\t\tport scenePort : ScenePort;\n\t\t\tperform capturePhoto.selectScene {\n\t\t\t\tout scene = scenePort.scene;\n\t\t\t}\n\t\t}\n\t\t\n\t\tinterface userToCamera connect user.scenePort to camera.scenePort {\n\t\t\tref flow references capturePhoto.sceneFlow\n\t\t\t\tfrom source.scene to target.scene;\n\t\t}\n\t\t\n\t\tpart camera {\n\t\t\tport scenePort : ~ScenePort;\n\t\t\tport imagePort : ImagePort;\n\t\t\t\n\t\t\tperform capturePhoto.focusScene {\n\t\t\t\tin scene = scenePort.scene;\n\t\t\t\tout focusStatus : FocusStatus;\n\t\t\t}\n\t\t\t\n\t\t\tperform capturePhoto.takePhoto {\n\t\t\t\tin focusStatus : FocusStatus;\n\t\t\t\tout image = imagePort.image;\n\t\t\t}\n\t\t}\n\t}\n\t\n\taction capturePhoto {\n\t\taction selectScene { out scene : Scene; }\n\t\tsuccession flow sceneFlow from selectScene.scene to focusScene.scene;\n\t\taction focusScene { in scene : Scene; out focusStatus : FocusStatus; }\n\t\tsuccession flow focusFlow from focusScene.focusStatus to takePhoto.focusStatus;\n\t\taction takePhoto { in focusStatus : FocusStatus; out image : Image; }\n\t}\n}",
    "package 'PhotographySystem' {\n\tattribute def Scene;\n\tattribute def Image;\n\tattribute def FocusQuality;\n\tattribute def Photo;\n\t\n\tport def ScenePort {\n\t\tout scene : Scene;\n\t}\n\t\n\tport def ImagePort {\n\t\tout image : Image;\n\t}\n\t\n\tport def PhotoPort {\n\t\tout photo : Photo;\n\t}\n\t\n\tpart context {\n\t\tpart user {\n\t\t\tport scenePort : ScenePort;\n\t\t\tport photoPort : ~PhotoPort;\n\t\t\t\n\t\t\tperform capturePhoto.selectScene {\n\t\t\t\tout scene = scenePort.scene;\n\t\t\t}\n\t\t\t\n\t\t\tperform capturePhoto.receivePhoto {\n\t\t\t\tin photo = photoPort.photo;\n\t\t\t}\n\t\t}\n\t\t\n\t\tinterface userToSystem connect user.scenePort to photographySystem.scenePort {\n\t\t\tref flow references capturePhoto.sceneFlow\n\t\t\t\tfrom source.scene to target.scene;\n\t\t}\n\t\t\n\t\tinterface systemToUser connect photographySystem.photoPort to user.photoPort {\n\t\t\tref flow references capturePhoto.photoFlow\n\t\t\t\tfrom source.photo to target.photo;\n\t\t}\n\t\t\n\t\tpart photographySystem {\n\t\t\tport scenePort : ~ScenePort;\n\t\t\tport photoPort : PhotoPort;\n\t\t\t\n\t\t\tperform capturePhoto.focusOnScene {\n\t\t\t\tin scene = scenePort.scene;\n\t\t\t\tout image : Image;\n\t\t\t}\n\t\t\t\n\t\t\tperform capturePhoto.evaluateFocus {\n\t\t\t\tin image : Image;\n\t\t\t\tout focusQuality : FocusQuality;\n\t\t\t}\n\t\t\t\n\t\t\tperform capturePhoto.shootPhoto {\n\t\t\t\tin image : Image;\n\t\t\t\tin focusQuality : FocusQuality;\n\t\t\t\tout photo = photoPort.photo;\n\t\t\t}\n\t\t}\n\t}\n\t\n\taction capturePhoto {\n\t\taction selectScene { out scene : Scene; }\n\t\tsuccession flow sceneFlow from selectScene.scene to focusOnScene.scene;\n\t\t\n\t\taction focusOnScene { in scene : Scene; out image : Image; }\n\t\tsuccession flow imageFlow from focusOnScene.image to evaluateFocus.image;\n\t\t\n\t\taction evaluateFocus { in image : Image; out focusQuality : FocusQuality; }\n\t\tsuccession flow focusFlow from evaluateFocus.focusQuality to shootPhoto.focusQuality;\n\t\tsuccession flow imageToShootFlow from focusOnScene.image to shootPhoto.image;\n\t\t\n\t\taction shootPhoto { in image : Image; in focusQuality : FocusQuality; out photo : Photo; }\n\t\tsuccession flow photoFlow from shootPhoto.photo to receivePhoto.photo;\n\t\t\n\t\taction receivePhoto { in photo : Photo; }\n\t}\n}",
    "package 'PhotographySystem' {\n\tattribute def TriggerCmd;\n\tattribute def Scene;\n\tattribute def FocusData;\n\tattribute def Image;\n\tattribute def Photo;\n\t\n\tport def TriggerCmdPort {\n\t\tout triggerCmd : TriggerCmd;\n\t}\n\tport def ScenePort {\n\t\tout scene : Scene;\n\t}\n\tport def FocusDataPort {\n\t\tout focusData : FocusData;\n\t}\n\tport def ImagePort {\n\t\tout image : Image;\n\t}\n\tport def PhotoPort {\n\t\tout photo : Photo;\n\t}\n\t\n\tpart context {\n\t\tpart user {\n\t\t\tport triggerCmdPort : TriggerCmdPort;\n\t\t\tperform photographyWorkflow.triggerTakePhoto {\n\t\t\t\tout triggerCmd = triggerCmdPort.triggerCmd;\n\t\t\t}\n\t\t}\n\t\t\n\t\tinterface userToSystem connect user.triggerCmdPort to cameraSystem.triggerCmdPort {\n\t\t\tref flow references photographyWorkflow.triggerFlow\n\t\t\t\tfrom source.triggerCmd to target.triggerCmd;\n\t\t}\n\t\t\n\t\tpart cameraSystem {\n\t\t\tport triggerCmdPort : ~TriggerCmdPort;\n\t\t\tport scenePort : ScenePort;\n\t\t\tport focusDataPort : FocusDataPort;\n\t\t\tport imagePort : ImagePort;\n\t\t\tport photoPort : PhotoPort;\n\t\t\t\n\t\t\tperform photographyWorkflow.acquireScene {\n\t\t\t\tin triggerCmd = triggerCmdPort.triggerCmd;\n\t\t\t\tout scene = scenePort.scene;\n\t\t\t}\n\t\t\t\n\t\t\tperform photographyWorkflow.performFocus {\n\t\t\t\tin scene = scenePort.scene;\n\t\t\t\tout focusData = focusDataPort.focusData;\n\t\t\t}\n\t\t\t\n\t\t\tperform photographyWorkflow.generateImage {\n\t\t\t\tin focusData = focusDataPort.focusData;\n\t\t\t\tout image = imagePort.image;\n\t\t\t}\n\t\t\t\n\t\t\tperform photographyWorkflow.executeShoot {\n\t\t\t\tin image = imagePort.image;\n\t\t\t\tout photo = photoPort.photo;\n\t\t\t}\n\t\t\t\n\t\t\tperform photographyWorkflow.displayPhoto {\n\t\t\t\tin photo = photoPort.photo;\n\t\t\t}\n\t\t}\n\t}\n\t\n\taction photographyWorkflow {\n\t\taction triggerTakePhoto { out triggerCmd : TriggerCmd; }\n\t\tsuccession flow triggerFlow from triggerTakePhoto.triggerCmd to acquireScene.triggerCmd;\n\t\t\n\t\taction acquireScene { in triggerCmd : TriggerCmd; out scene : Scene; }\n\t\tsuccession flow sceneFlow from acquireScene.scene to performFocus.scene;\n\t\t\n\t\taction performFocus { in scene : Scene; out focusData : FocusData; }\n\t\tsuccession flow focusFlow from performFocus.focusData to generateImage.focusData;\n\t\t\n\t\taction generateImage { in focusData : FocusData; out image : Image; }\n\t\tsuccession flow imageFlow from generateImage.image to executeShoot.image;\n\t\t\n\t\taction executeShoot { in image : Image; out photo : Photo; }\n\t\tsuccession flow photoFlow from executeShoot.photo to displayPhoto.photo;\n\t\t\n\t\taction displayPhoto { in photo : Photo; }\n\t}\n}",
    "package 'AutomaticBrakingControl' {\n\tattribute def KeyPosition;\n\tattribute def BrakePressure;\n\tattribute def TractionInfo;\n\tattribute def AdjustedBrakePressure;\n\tattribute def ModulationFrequency;\n\t\n\tport def KeyPositionPort {\n\t\tout keyPosition : KeyPosition;\n\t}\n\tport def BrakePressurePort {\n\t\tout brakePressure : BrakePressure;\n\t}\n\tport def TractionInfoPort {\n\t\tout tractionInfo : TractionInfo;\n\t}\n\tport def AdjustedBrakePressurePort {\n\t\tout adjustedBrakePressure : AdjustedBrakePressure;\n\t\tout modulationFrequency : ModulationFrequency;\n\t}\n\t\n\tpart context {\n\t\tpart user {\n\t\t\tport keyPositionPort: KeyPositionPort;\n\t\t\tperform automaticBraking.turnKey {\n\t\t\t\tout keyPosition = keyPositionPort.keyPosition;\n\t\t\t}\n\t\t}\n\t\tinterface userToSystem connect user.keyPositionPort to brakingSystem.keyPositionPort {\n\t\t\tref flow references automaticBraking.keyPositionFlow\n\t\t\t\tfrom source.keyPosition to target.keyPosition;\n\t\t}\n\t\tpart driver {\n\t\t\tport brakePressurePort: BrakePressurePort;\n\t\t\tperform automaticBraking.pressBrakePedal {\n\t\t\t\tout brakePressure = brakePressurePort.brakePressure;\n\t\t\t}\n\t\t}\n\t\tinterface driverToSystem connect driver.brakePressurePort to brakingSystem.brakePressurePort {\n\t\t\tref flow references automaticBraking.brakePressureFlow\n\t\t\t\tfrom source.brakePressure to target.brakePressure;\n\t\t}\n\t\tpart road {\n\t\t\tport tractionInfoPort: TractionInfoPort;\n\t\t\tperform automaticBraking.provideTractionInfo {\n\t\t\t\tout tractionInfo = tractionInfoPort.tractionInfo;\n\t\t\t}\n\t\t}\n\t\tinterface roadToSystem connect road.tractionInfoPort to brakingSystem.tractionInfoPort {\n\t\t\tref flow references automaticBraking.tractionInfoFlow\n\t\t\t\tfrom source.tractionInfo to target.tractionInfo;\n\t\t}\n\t\tpart brakingSystem {\n\t\t\tport keyPositionPort: ~KeyPositionPort;\n\t\t\tport brakePressurePort: ~BrakePressurePort;\n\t\t\tport tractionInfoPort: ~TractionInfoPort;\n\t\t\tport adjustedBrakePressurePort: AdjustedBrakePressurePort;\n\t\t\tperform automaticBraking.activateSystem {\n\t\t\t\tin keyPosition = keyPositionPort.keyPosition;\n\t\t\t}\n\t\t\tperform automaticBraking.monitorInputs {\n\t\t\t\tin brakePressure = brakePressurePort.brakePressure;\n\t\t\t\tin tractionInfo = tractionInfoPort.tractionInfo;\n\t\t\t}\n\t\t\tperform automaticBraking.adjustBraking {\n\t\t\t\tout adjustedBrakePressure = adjustedBrakePressurePort.adjustedBrakePressure;\n\t\t\t\tout modulationFrequency = adjustedBrakePressurePort.modulationFrequency;\n\t\t\t}\n\t\t}\n\t\tpart vehicle {\n\t\t\tport adjustedBrakePressurePort: ~AdjustedBrakePressurePort;\n\t\t\tperform automaticBraking.applyBraking {\n\t\t\t\tin adjustedBrakePressure = adjustedBrakePressurePort.adjustedBrakePressure;\n\t\t\t\tin modulationFrequency = adjustedBrakePressurePort.modulationFrequency;\n\t\t\t}\n\t\t}\n\t\tinterface systemToVehicle connect brakingSystem.adjustedBrakePressurePort to vehicle.adjustedBrakePressurePort {\n\t\t\tref flow references automaticBraking.adjustedBrakePressureFlow\n\t\t\t\tfrom source.adjustedBrakePressure to target.adjustedBrakePressure;\n\t\t\tref flow references automaticBraking.modulationFrequencyFlow\n\t\t\t\tfrom source.modulationFrequency to target.modulationFrequency;\n\t\t}\n\t}\n\taction automaticBraking {\n\t\taction turnKey { out keyPosition: KeyPosition; }\n\t\tsuccession flow keyPositionFlow from turnKey.keyPosition to activateSystem.keyPosition;\n\t\taction activateSystem { in keyPosition: KeyPosition; }\n\t\taction pressBrakePedal { out brakePressure: BrakePressure; }\n\t\tsuccession flow brakePressureFlow from pressBrakePedal.brakePressure to monitorInputs.brakePressure;\n\t\taction provideTractionInfo { out tractionInfo: TractionInfo; }\n\t\tsuccession flow tractionInfoFlow from provideTractionInfo.tractionInfo to monitorInputs.tractionInfo;\n\t\taction monitorInputs { in brakePressure: BrakePressure; in tractionInfo: TractionInfo; }\n\t\tsuccession from monitorInputs to adjustBraking;\n\t\taction adjustBraking { out adjustedBrakePressure: AdjustedBrakePressure; out modulationFrequency: ModulationFrequency; }\n\t\tsuccession flow adjustedBrakePressureFlow from adjustBraking.adjustedBrakePressure to applyBraking.adjustedBrakePressure;\n\t\tsuccession flow modulationFrequencyFlow from adjustBraking.modulationFrequency to applyBraking.modulationFrequency;\n\t\taction applyBraking { in adjustedBrakePressure: AdjustedBrakePressure; in modulationFrequency: ModulationFrequency; }\n\t}\n}",
    "package 'BatteryChargingControlSystem' {\n\tattribute def BatteryLevel;\n\tattribute def ChargingPower;\n\tattribute def ChargingStatus;\n\t\n\tport def BatteryLevelPort {\n\t\tout batteryLevel : BatteryLevel;\n\t}\n\t\n\tport def ChargingPowerPort {\n\t\tin chargingPower : ChargingPower;\n\t}\n\t\n\tport def ChargingControlPort {\n\t\tout chargingStatus : ChargingStatus;\n\t}\n\t\n\tpart context {\n\t\tpart battery {\n\t\t\tport batteryLevelPort : BatteryLevelPort;\n\t\t\tport chargingPowerPort : ChargingPowerPort;\n\t\t\t\n\t\t\tperform automaticChargingControl.provideBatteryLevel {\n\t\t\t\tout batteryLevel = batteryLevelPort.batteryLevel;\n\t\t\t}\n\t\t\t\n\t\t\tperform automaticChargingControl.receiveCharge {\n\t\t\t\tin chargingPower = chargingPowerPort.chargingPower;\n\t\t\t}\n\t\t}\n\t\t\n\t\tinterface batteryToController connect battery.batteryLevelPort to chargingController.batteryLevelPort {\n\t\t\tref flow references automaticChargingControl.batteryLevelFlow\n\t\t\t\tfrom source.batteryLevel to target.batteryLevel;\n\t\t}\n\t\t\n\t\tpart chargingController {\n\t\t\tport batteryLevelPort : ~BatteryLevelPort;\n\t\t\tport chargingControlPort : ChargingControlPort;\n\t\t\t\n\t\t\tperform automaticChargingControl.monitorAndControl {\n\t\t\t\tin batteryLevel = batteryLevelPort.batteryLevel;\n\t\t\t\tout chargingStatus = chargingControlPort.chargingStatus;\n\t\t\t}\n\t\t}\n\t\t\n\t\tinterface controllerToCharger connect chargingController.chargingControlPort to charger.chargingControlPort {\n\t\t\tref flow references automaticChargingControl.chargingControlFlow\n\t\t\t\tfrom source.chargingStatus to target.chargingStatus;\n\t\t}\n\t\t\n\t\tpart charger {\n\t\t\tport chargingControlPort : ~ChargingControlPort;\n\t\t\tport chargingPowerPort : ~ChargingPowerPort;\n\t\t\t\n\t\t\tperform automaticChargingControl.supplyCharge {\n\t\t\t\tin chargingStatus = chargingControlPort.chargingStatus;\n\t\t\t\tout chargingPower = chargingPowerPort.chargingPower;\n\t\t\t}\n\t\t}\n\t\t\n\t\tinterface chargerToBattery connect charger.chargingPowerPort to battery.chargingPowerPort {\n\t\t\tref flow references automaticChargingControl.chargingPowerFlow\n\t\t\t\tfrom source.chargingPower to target.chargingPower;\n\t\t}\n\t}\n\t\n\taction automaticChargingControl {\n\t\taction provideBatteryLevel { out batteryLevel : BatteryLevel; }\n\t\tsuccession flow batteryLevelFlow from provideBatteryLevel.batteryLevel to monitorAndControl.batteryLevel;\n\t\taction monitorAndControl { in batteryLevel : BatteryLevel; out chargingStatus : ChargingStatus; }\n\t\tsuccession flow chargingControlFlow from monitorAndControl.chargingStatus to supplyCharge.chargingStatus;\n\t\taction supplyCharge { in chargingStatus : ChargingStatus; out chargingPower : ChargingPower; }\n\t\tsuccession flow chargingPowerFlow from supplyCharge.chargingPower to receiveCharge.chargingPower;\n\t\taction receiveCharge { in chargingPower : ChargingPower; }\n\t}\n}",
    "package 'BatteryChargingSystem' {\n\tattribute def BatteryLevel;\n\tattribute def ChargingPower;\n\tattribute def ChargingStatus;\n\t\n\tport def BatteryLevelPort {\n\t\tout batteryLevel : BatteryLevel;\n\t}\n\t\n\tport def ChargingPowerPort {\n\t\tin chargingPower : ChargingPower;\n\t}\n\t\n\tport def ChargingStatusPort {\n\t\tout chargingStatus : ChargingStatus;\n\t}\n\t\n\tpart context {\n\t\tpart charger {\n\t\t\tport chargingStatusPort : ChargingStatusPort;\n\t\t\tport chargingPowerPort : ~ChargingPowerPort;\n\t\t\t\n\t\t\tperform chargingProcess.supplyPower {\n\t\t\t\tin chargingStatus = chargingStatusPort.chargingStatus;\n\t\t\t\tout chargingPower = chargingPowerPort.chargingPower;\n\t\t\t}\n\t\t}\n\t\t\n\t\tinterface chargerToBattery connect charger.chargingPowerPort to battery.chargingPowerPort {\n\t\t\tref flow references chargingProcess.chargingPowerFlow\n\t\t\t\tfrom source.chargingPower to target.chargingPower;\n\t\t}\n\t\t\n\t\tpart battery {\n\t\t\tport chargingPowerPort : ChargingPowerPort;\n\t\t\tport batteryLevelPort : BatteryLevelPort;\n\t\t\t\n\t\t\tperform chargingProcess.replenishBattery {\n\t\t\t\tin chargingPower = chargingPowerPort.chargingPower;\n\t\t\t\tout batteryLevel = batteryLevelPort.batteryLevel;\n\t\t\t}\n\t\t}\n\t\t\n\t\tinterface batteryToController connect battery.batteryLevelPort to controller.batteryLevelPort {\n\t\t\tref flow references chargingProcess.batteryLevelFlow\n\t\t\t\tfrom source.batteryLevel to target.batteryLevel;\n\t\t}\n\t\t\n\t\tpart controller {\n\t\t\tport batteryLevelPort : ~BatteryLevelPort;\n\t\t\tport chargingStatusPort : ~ChargingStatusPort;\n\t\t\t\n\t\t\tperform chargingProcess.monitorAndControl {\n\t\t\t\tin batteryLevel = batteryLevelPort.batteryLevel;\n\t\t\t\tout chargingStatus = chargingStatusPort.chargingStatus;\n\t\t\t}\n\t\t}\n\t\t\n\t\tinterface controllerToCharger connect controller.chargingStatusPort to charger.chargingStatusPort {\n\t\t\tref flow references chargingProcess.chargingStatusFlow\n\t\t\t\tfrom source.chargingStatus to target.chargingStatus;\n\t\t}\n\t}\n\t\n\taction chargingProcess {\n\t\taction monitorAndControl { \n\t\t\tin batteryLevel : BatteryLevel; \n\t\t\tout chargingStatus : ChargingStatus;\n\t\t}\n\t\tsuccession flow chargingStatusFlow from monitorAndControl.chargingStatus to supplyPower.chargingStatus;\n\t\t\n\t\taction supplyPower { \n\t\t\tin chargingStatus : ChargingStatus; \n\t\t\tout chargingPower : ChargingPower;\n\t\t}\n\t\tsuccession flow chargingPowerFlow from supplyPower.chargingPower to replenishBattery.chargingPower;\n\t\t\n\t\taction replenishBattery { \n\t\t\tin chargingPower : ChargingPower; \n\t\t\tout batteryLevel : BatteryLevel;\n\t\t}\n\t\tsuccession flow batteryLevelFlow from replenishBattery.batteryLevel to monitorAndControl.batteryLevel;\n\t}\n}",
    "package 'CameraSystem' {\n\tattribute def Scene;\n\tattribute def FocusData;\n\tattribute def Image;\n\tattribute def Photo;\n\t\n\tport def ScenePort {\n\t\tout scene : Scene;\n\t}\n\tport def FocusDataPort {\n\t\tout focusData : FocusData;\n\t}\n\tport def ImagePort {\n\t\tout image : Image;\n\t}\n\tport def PhotoPort {\n\t\tout photo : Photo;\n\t}\n\t\n\tpart context {\n\t\tpart user {\n\t\t\tport scenePort : ScenePort;\n\t\t\tperform takePhoto.selectScene {\n\t\t\t\tout scene = scenePort.scene;\n\t\t\t}\n\t\t}\n\t\t\n\t\tinterface userToCamera connect user.scenePort to camera.scenePort {\n\t\t\tref flow references takePhoto.sceneFlow\n\t\t\t\tfrom source.scene to target.scene;\n\t\t}\n\t\t\n\t\tpart camera {\n\t\t\tport scenePort : ~ScenePort;\n\t\t\tport photoPort : PhotoPort;\n\t\t\t\n\t\t\tpart autofocusSubsystem {\n\t\t\t\tport scenePort : ~ScenePort;\n\t\t\t\tport focusDataPort : FocusDataPort;\n\t\t\t\tperform takePhoto.autoFocus {\n\t\t\t\t\tin scene = scenePort.scene;\n\t\t\t\t\tout focusData = focusDataPort.focusData;\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\tpart imagingSubsystem {\n\t\t\t\tport focusDataPort : ~FocusDataPort;\n\t\t\t\tport imagePort : ImagePort;\n\t\t\t\tperform takePhoto.captureImage {\n\t\t\t\t\tin focusData = focusDataPort.focusData;\n\t\t\t\t\tout image = imagePort.image;\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\tinterface autofocusToImaging connect autofocusSubsystem.focusDataPort to imagingSubsystem.focusDataPort {\n\t\t\t\tref flow references takePhoto.focusFlow\n\t\t\t\t\tfrom source.focusData to target.focusData;\n\t\t\t}\n\t\t\t\n\t\t\tperform takePhoto.savePhoto {\n\t\t\t\tin image = imagingSubsystem.imagePort.image;\n\t\t\t\tout photo = photoPort.photo;\n\t\t\t}\n\t\t}\n\t}\n\t\n\taction takePhoto {\n\t\taction selectScene { out scene : Scene; }\n\t\tsuccession flow sceneFlow from selectScene.scene to autoFocus.scene;\n\t\taction autoFocus { in scene : Scene; out focusData : FocusData; }\n\t\tsuccession flow focusFlow from autoFocus.focusData to captureImage.focusData;\n\t\taction captureImage { in focusData : FocusData; out image : Image; }\n\t\tsuccession flow imageFlow from captureImage.image to savePhoto.image;\n\t\taction savePhoto { in image : Image; out photo : Photo; }\n\t}\n}",
    "package 'DigitalCamera' {\n\tattribute def SceneSelection;\n\tattribute def FocusData;\n\tattribute def ImageData;\n\tattribute def Photo;\n\t\n\tport def SceneSelectionPort {\n\t\tout sceneSelection : SceneSelection;\n\t}\n\tport def FocusDataPort {\n\t\tout focusData : FocusData;\n\t}\n\tport def ImageDataPort {\n\t\tout imageData : ImageData;\n\t}\n\tport def PhotoPort {\n\t\tout photo : Photo;\n\t}\n\t\n\tpart context {\n\t\tpart user {\n\t\t\tport sceneSelectionPort : SceneSelectionPort;\n\t\t\tperform capturePhoto.selectScene {\n\t\t\t\tout sceneSelection = sceneSelectionPort.sceneSelection;\n\t\t\t}\n\t\t}\n\t\t\n\t\tinterface userToCamera connect user.sceneSelectionPort to camera.sceneSelectionPort {\n\t\t\tref flow references capturePhoto.sceneSelectionFlow\n\t\t\t\tfrom source.sceneSelection to target.sceneSelection;\n\t\t}\n\t\t\n\t\tpart camera {\n\t\t\tport sceneSelectionPort : ~SceneSelectionPort;\n\t\t\tport focusDataPort : FocusDataPort;\n\t\t\tport imageDataPort : ImageDataPort;\n\t\t\tport photoPort : PhotoPort;\n\t\t\t\n\t\t\tperform capturePhoto.autoFocus {\n\t\t\t\tin sceneSelection = sceneSelectionPort.sceneSelection;\n\t\t\t\tout focusData = focusDataPort.focusData;\n\t\t\t}\n\t\t\t\n\t\t\tperform capturePhoto.generateImage {\n\t\t\t\tin focusData = focusDataPort.focusData;\n\t\t\t\tout imageData = imageDataPort.imageData;\n\t\t\t}\n\t\t\t\n\t\t\tperform capturePhoto.captureAndProduce {\n\t\t\t\tin imageData = imageDataPort.imageData;\n\t\t\t\tout photo = photoPort.photo;\n\t\t\t}\n\t\t}\n\t}\n\t\n\taction capturePhoto {\n\t\taction selectScene { out sceneSelection : SceneSelection; }\n\t\tsuccession flow sceneSelectionFlow from selectScene.sceneSelection to autoFocus.sceneSelection;\n\t\taction autoFocus { in sceneSelection : SceneSelection; out focusData : FocusData; }\n\t\tsuccession flow focusDataFlow from autoFocus.focusData to generateImage.focusData;\n\t\taction generateImage { in focusData : FocusData; out imageData : ImageData; }\n\t\tsuccession flow imageDataFlow from generateImage.imageData to captureAndProduce.imageData;\n\t\taction captureAndProduce { in imageData : ImageData; out photo : Photo; }\n\t}\n}",
    "package 'VehicleSimulation' {\n\tattribute def Mass;\n\tattribute def Position;\n\tattribute def Velocity;\n\tattribute def Power;\n\tattribute def TimeStep;\n\tattribute def Trajectory;\n\t\n\tport def SimulationInputPort {\n\t\tin mass: Mass;\n\t\tin initialPosition: Position;\n\t\tin initialVelocity: Velocity;\n\t\tin timeStep: TimeStep;\n\t\tin powerSequence: Power[*];\n\t}\n\t\n\tport def SimulationOutputPort {\n\t\tout trajectory: Trajectory;\n\t}\n\t\n\tpart context {\n\t\tpart user {\n\t\t\tport simulationInputPort: SimulationInputPort;\n\t\t\tperform simulateVehicleMotion.provideInputs {\n\t\t\t\tout mass = simulationInputPort.mass;\n\t\t\t\tout initialPosition = simulationInputPort.initialPosition;\n\t\t\t\tout initialVelocity = simulationInputPort.initialVelocity;\n\t\t\t\tout timeStep = simulationInputPort.timeStep;\n\t\t\t\tout powerSequence = simulationInputPort.powerSequence;\n\t\t\t}\n\t\t}\n\t\t\n\t\tinterface userToSimulator connect user.simulationInputPort to simulator.simulationInputPort {\n\t\t\tref flow references simulateVehicleMotion.massFlow\n\t\t\t\tfrom source.mass to target.mass;\n\t\t\tref flow references simulateVehicleMotion.initialPositionFlow\n\t\t\t\tfrom source.initialPosition to target.initialPosition;\n\t\t\tref flow references simulateVehicleMotion.initialVelocityFlow\n\t\t\t\tfrom source.initialVelocity to target.initialVelocity;\n\t\t\tref flow references simulateVehicleMotion.timeStepFlow\n\t\t\t\tfrom source.timeStep to target.timeStep;\n\t\t\tref flow references simulateVehicleMotion.powerSequenceFlow\n\t\t\t\tfrom source.powerSequence to target.powerSequence;\n\t\t}\n\t\t\n\t\tpart simulator {\n\t\t\tport simulationInputPort: ~SimulationInputPort;\n\t\t\tport simulationOutputPort: SimulationOutputPort;\n\t\t\tperform simulateVehicleMotion.calculateTrajectory {\n\t\t\t\tin mass = simulationInputPort.mass;\n\t\t\t\tin initialPosition = simulationInputPort.initialPosition;\n\t\t\t\tin initialVelocity = simulationInputPort.initialVelocity;\n\t\t\t\tin timeStep = simulationInputPort.timeStep;\n\t\t\t\tin powerSequence = simulationInputPort.powerSequence;\n\t\t\t\tout trajectory = simulationOutputPort.trajectory;\n\t\t\t}\n\t\t}\n\t}\n\t\n\taction simulateVehicleMotion {\n\t\taction provideInputs {\n\t\t\tout mass: Mass;\n\t\t\tout initialPosition: Position;\n\t\t\tout initialVelocity: Velocity;\n\t\t\tout timeStep: TimeStep;\n\t\t\tout powerSequence: Power[*];\n\t\t}\n\t\tsuccession flow massFlow from provideInputs.mass to calculateTrajectory.mass;\n\t\tsuccession flow initialPositionFlow from provideInputs.initialPosition to calculateTrajectory.initialPosition;\n\t\tsuccession flow initialVelocityFlow from provideInputs.initialVelocity to calculateTrajectory.initialVelocity;\n\t\tsuccession flow timeStepFlow from provideInputs.timeStep to calculateTrajectory.timeStep;\n\t\tsuccession flow powerSequenceFlow from provideInputs.powerSequence to calculateTrajectory.powerSequence;\n\t\taction calculateTrajectory {\n\t\t\tin mass: Mass;\n\t\t\tin initialPosition: Position;\n\t\t\tin initialVelocity: Velocity;\n\t\t\tin timeStep: TimeStep;\n\t\t\tin powerSequence: Power[*];\n\t\t\tout trajectory: Trajectory;\n\t\t}\n\t}\n}",
    "package 'CameraSystem' {\n\tattribute def Scene;\n\tattribute def Image;\n\tattribute def Photo;\n\t\n\tport def ScenePort {\n\t\tout scene : Scene;\n\t}\n\t\n\tport def ImagePort {\n\t\tout image : Image;\n\t}\n\t\n\tport def PhotoPort {\n\t\tout photo : Photo;\n\t}\n\t\n\tpart context {\n\t\tpart user {\n\t\t\tport scenePort : ScenePort;\n\t\t\tperform shootAndDisplay.inputScene {\n\t\t\t\tout scene = scenePort.scene;\n\t\t\t}\n\t\t}\n\t\t\n\t\tinterface userToCamera connect user.scenePort to camera.scenePort {\n\t\t\tref flow references shootAndDisplay.sceneFlow\n\t\t\t\tfrom source.scene to target.scene;\n\t\t}\n\t\t\n\t\tpart camera {\n\t\t\tport scenePort : ~ScenePort;\n\t\t\tport imagePort : ImagePort;\n\t\t\tport photoPort : PhotoPort;\n\t\t\t\n\t\t\tperform shootAndDisplay.focusScene {\n\t\t\t\tin scene = scenePort.scene;\n\t\t\t\tout image = imagePort.image;\n\t\t\t}\n\t\t\t\n\t\t\tperform shootAndDisplay.captureImage {\n\t\t\t\tin image = imagePort.image;\n\t\t\t\tout photo = photoPort.photo;\n\t\t\t}\n\t\t}\n\t\t\n\t\tinterface cameraToDisplay connect camera.photoPort to display.photoPort {\n\t\t\tref flow references shootAndDisplay.photoFlow\n\t\t\t\tfrom source.photo to target.photo;\n\t\t}\n\t\t\n\t\tpart display {\n\t\t\tport photoPort : ~PhotoPort;\n\t\t\tperform shootAndDisplay.displayPhoto {\n\t\t\t\tin photo = photoPort.photo;\n\t\t\t}\n\t\t}\n\t}\n\t\n\taction shootAndDisplay {\n\t\taction inputScene { out scene : Scene; }\n\t\tsuccession flow sceneFlow from inputScene.scene to focusScene.scene;\n\t\taction focusScene { in scene : Scene; out image : Image; }\n\t\tsuccession flow imageFlow from focusScene.image to captureImage.image;\n\t\taction captureImage { in image : Image; out photo : Photo; }\n\t\tsuccession flow photoFlow from captureImage.photo to displayPhoto.photo;\n\t\taction displayPhoto { in photo : Photo; }\n\t}\n}",
    "package 'CameraSystem' {\n\tattribute def Scene;\n\tattribute def Image;\n\tattribute def Picture;\n\t\n\tport def ViewPort {\n\t\tin scene: Scene;\n\t}\n\t\n\tport def DisplayPort {\n\t\tout picture: Picture;\n\t}\n\t\n\tpart context {\n\t\tpart user {\n\t\t\tport viewPort: ~ViewPort;\n\t\t\tperform processImage.selectScene {\n\t\t\t\tout scene = viewPort.scene;\n\t\t\t}\n\t\t}\n\t\t\n\t\tinterface userToCamera connect user.viewPort to camera.viewPort {\n\t\t\tref flow references processImage.sceneFlow\n\t\t\t\tfrom target.scene to source.scene;\n\t\t}\n\t\t\n\t\tpart camera {\n\t\t\tport viewPort: ViewPort;\n\t\t\tport displayPort: DisplayPort;\n\t\t\t\n\t\t\tperform processImage.focusScene {\n\t\t\t\tin scene = viewPort.scene;\n\t\t\t\tout image;\n\t\t\t}\n\t\t\t\n\t\t\tperform processImage.captureImage {\n\t\t\t\tin image;\n\t\t\t\tout picture;\n\t\t\t}\n\t\t\t\n\t\t\tperform processImage.displayPicture {\n\t\t\t\tin picture;\n\t\t\t\tout displayPicture = displayPort.picture;\n\t\t\t}\n\t\t}\n\t}\n\t\n\taction processImage {\n\t\taction selectScene { out scene: Scene; }\n\t\tsuccession flow sceneFlow from selectScene.scene to focusScene.scene;\n\t\taction focusScene { in scene: Scene; out image: Image; }\n\t\tsuccession flow imageFlow from focusScene.image to captureImage.image;\n\t\taction captureImage { in image: Image; out picture: Picture; }\n\t\tsuccession flow pictureFlow from captureImage.picture to displayPicture.picture;\n\t\taction displayPicture { in picture: Picture; out displayPicture: Picture; }\n\t}\n}",
    "package 'SensorManagementSystem' {\n\tattribute def SensorID;\n\tattribute def SensorStatus;\n\tattribute def UpdateCommand;\n\tattribute def ReadyState;\n\t\n\tport def StatusPort {\n\t\tout status : SensorStatus;\n\t}\n\t\n\tport def UpdatePort {\n\t\tin updateCmd : UpdateCommand;\n\t}\n\t\n\tpart def Sensor {\n\t\tattribute id : SensorID;\n\t\tport statusPort : StatusPort;\n\t\tport updatePort : UpdatePort;\n\t\t\n\t\tperform maintainSensors.reportStatus {\n\t\t\tout status = statusPort.status;\n\t\t}\n\t\t\n\t\tperform maintainSensors.receiveUpdate {\n\t\t\tin updateCmd = updatePort.updateCmd;\n\t\t}\n\t}\n\t\n\tpart context {\n\t\tpart managementSystem {\n\t\t\tport statusPort[*] : ~StatusPort;\n\t\t\tport updatePort[*] : ~UpdatePort;\n\t\t\t\n\t\t\tperform maintainSensors.monitorSensors {\n\t\t\t\tin status[*] = statusPort.status;\n\t\t\t\tout readySensors[*] : ReadyState;\n\t\t\t}\n\t\t\t\n\t\t\tperform maintainSensors.updateReadySensors {\n\t\t\t\tin readySensors[*] : ReadyState;\n\t\t\t\tout updateCmd[*] = updatePort.updateCmd;\n\t\t\t}\n\t\t}\n\t\t\n\t\tpart sensors[*] : Sensor;\n\t\t\n\t\tinterface sensorToSystem[*] connect sensors.statusPort to managementSystem.statusPort {\n\t\t\tref flow references maintainSensors.statusFlow\n\t\t\t\tfrom source.status to target.status;\n\t\t}\n\t\t\n\t\tinterface systemToSensor[*] connect managementSystem.updatePort to sensors.updatePort {\n\t\t\tref flow references maintainSensors.updateFlow\n\t\t\t\tfrom source.updateCmd to target.updateCmd;\n\t\t}\n\t}\n\t\n\taction maintainSensors {\n\t\taction reportStatus[*] { out status : SensorStatus; }\n\t\tsuccession flow statusFlow[*] from reportStatus.status to monitorSensors.status;\n\t\t\n\t\taction monitorSensors { \n\t\t\tin status[*] : SensorStatus; \n\t\t\tout readySensors[*] : ReadyState;\n\t\t}\n\t\tsuccession flow readyFlow from monitorSensors.readySensors to updateReadySensors.readySensors;\n\t\t\n\t\taction updateReadySensors { \n\t\t\tin readySensors[*] : ReadyState;\n\t\t\tout updateCmd[*] : UpdateCommand;\n\t\t}\n\t\tsuccession flow updateFlow[*] from updateReadySensors.updateCmd to receiveUpdate.updateCmd;\n\t\t\n\t\taction receiveUpdate[*] { in updateCmd : UpdateCommand; }\n\t}\n}",
    "package 'VehicleStateManagement' {\n\tattribute def StartSignal;\n\tattribute def PowerOnSignal;\n\tattribute def ShutdownSignal;\n\t\n\tport def ControlSignalPort {\n\t\tin startSignal : StartSignal;\n\t\tin powerOnSignal : PowerOnSignal;\n\t\tin shutdownSignal : ShutdownSignal;\n\t}\n\t\n\tpart vehicle {\n\t\tport controlPort : ControlSignalPort;\n\t\t\n\t\texhibit state vehicleStates {\n\t\t\tentry; then off;\n\t\t\t\n\t\t\tstate off;\n\t\t\ttransition off_to_starting\n\t\t\t\tfirst off\n\t\t\t\taccept controlPort.startSignal\n\t\t\t\tthen starting;\n\t\t\t\n\t\t\tstate starting;\n\t\t\ttransition starting_to_on\n\t\t\t\tfirst starting\n\t\t\t\taccept controlPort.powerOnSignal\n\t\t\t\tthen on;\n\t\t\ttransition starting_to_off\n\t\t\t\tfirst starting\n\t\t\t\taccept controlPort.shutdownSignal\n\t\t\t\tthen off;\n\t\t\t\n\t\t\tstate on;\n\t\t\ttransition on_to_off\n\t\t\t\tfirst on\n\t\t\t\taccept controlPort.shutdownSignal\n\t\t\t\tthen off;\n\t\t}\n\t}\n}",
    "package 'VehicleOperationalSystem' {\n\tattribute def VehicleStartSignal;\n\tattribute def VehicleOnSignal;\n\tattribute def VehicleOffSignal;\n\t\n\tstate def VehicleStates {\n\t\tentry state off;\n\t\tstate starting;\n\t\tstate on;\n\t\t\n\t\ttransition off_to_starting\n\t\t\tfirst off\n\t\t\taccept vehicleStartSignal : VehicleStartSignal\n\t\t\tthen starting;\n\t\t\t\n\t\ttransition starting_to_on\n\t\t\tfirst starting\n\t\t\taccept vehicleOnSignal : VehicleOnSignal\n\t\t\tthen on;\n\t\t\t\n\t\ttransition on_to_off\n\t\t\tfirst on\n\t\t\taccept vehicleOffSignal : VehicleOffSignal\n\t\t\tthen off;\n\t}\n\t\n\tpart vehicleController {\n\t\texhibit vehicleStates : VehicleStates;\n\t}\n}",
    "package 'VehiclePowerManagement' {\n\tattribute def StartCmd;\n\tattribute def ShutdownCmd;\n\tattribute def VehicleStartedSignal;\n\tattribute def PowerSupply;\n\tattribute def DiagnosticData;\n\tattribute def ParkingBrakeSignal;\n\t\n\tport def StartCmdPort {\n\t\tout startCmd : StartCmd;\n\t}\n\tport def ShutdownCmdPort {\n\t\tout shutdownCmd : ShutdownCmd;\n\t}\n\tport def VehicleStartedSignalPort {\n\t\tin vehicleStartedSignal : VehicleStartedSignal;\n\t}\n\tport def PowerSupplyPort {\n\t\tout powerSupply : PowerSupply;\n\t}\n\tport def DiagnosticDataPort {\n\t\tout diagnosticData : DiagnosticData;\n\t}\n\tport def ParkingBrakeSignalPort {\n\t\tout parkingBrakeSignal : ParkingBrakeSignal;\n\t}\n\t\n\tpart context {\n\t\tpart user {\n\t\t\tport startCmdPort : StartCmdPort;\n\t\t\tport shutdownCmdPort : ShutdownCmdPort;\n\t\t\tperform managePowerStatus.sendStartCmd {\n\t\t\t\tout startCmd = startCmdPort.startCmd;\n\t\t\t}\n\t\t\tperform managePowerStatus.sendShutdownCmd {\n\t\t\t\tout shutdownCmd = shutdownCmdPort.shutdownCmd;\n\t\t\t}\n\t\t}\n\t\t\n\t\tinterface userToSystem connect user.startCmdPort to powerManagementSystem.startCmdPort {\n\t\t\tref flow references managePowerStatus.startCmdFlow\n\t\t\t\tfrom source.startCmd to target.startCmd;\n\t\t}\n\t\t\n\t\tinterface userToSystemShutdown connect user.shutdownCmdPort to powerManagementSystem.shutdownCmdPort {\n\t\t\tref flow references managePowerStatus.shutdownCmdFlow\n\t\t\t\tfrom source.shutdownCmd to target.shutdownCmd;\n\t\t}\n\t\t\n\t\tpart powerManagementSystem {\n\t\t\tport startCmdPort : ~StartCmdPort;\n\t\t\tport shutdownCmdPort : ~ShutdownCmdPort;\n\t\t\tport vehicleStartedSignalPort : VehicleStartedSignalPort;\n\t\t\tport powerSupplyPort : PowerSupplyPort;\n\t\t\tport diagnosticDataPort : DiagnosticDataPort;\n\t\t\tport parkingBrakeSignalPort : ParkingBrakeSignalPort;\n\t\t\t\n\t\t\tperform managePowerStatus.switchToStartPhase {\n\t\t\t\tin startCmd = startCmdPort.startCmd;\n\t\t\t}\n\t\t\tperform managePowerStatus.enterPoweredOnState {\n\t\t\t\tin vehicleStartedSignal = vehicleStartedSignalPort.vehicleStartedSignal;\n\t\t\t\tout powerSupply = powerSupplyPort.powerSupply;\n\t\t\t\tout diagnosticData = diagnosticDataPort.diagnosticData;\n\t\t\t}\n\t\t\tperform managePowerStatus.executeSafetyOperations {\n\t\t\t\tin shutdownCmd = shutdownCmdPort.shutdownCmd;\n\t\t\t\tout parkingBrakeSignal = parkingBrakeSignalPort.parkingBrakeSignal;\n\t\t\t}\n\t\t}\n\t\t\n\t\tpart vehicleFunctionalUnits {\n\t\t\tport powerSupplyPort : ~PowerSupplyPort;\n\t\t\tperform managePowerStatus.receivePower {\n\t\t\t\tin powerSupply = powerSupplyPort.powerSupply;\n\t\t\t}\n\t\t}\n\t\t\n\t\tinterface systemToFunctionalUnits connect powerManagementSystem.powerSupplyPort to vehicleFunctionalUnits.powerSupplyPort {\n\t\t\tref flow references managePowerStatus.powerSupplyFlow\n\t\t\t\tfrom source.powerSupply to target.powerSupply;\n\t\t}\n\t}\n\t\n\taction managePowerStatus {\n\t\taction sendStartCmd { out startCmd : StartCmd; }\n\t\tsuccession flow startCmdFlow from sendStartCmd.startCmd to switchToStartPhase.startCmd;\n\t\taction switchToStartPhase { in startCmd : StartCmd; }\n\t\tsuccession flow startPhaseFlow from switchToStartPhase to enterPoweredOnState;\n\t\taction enterPoweredOnState { \n\t\t\tin vehicleStartedSignal : VehicleStartedSignal; \n\t\t\tout powerSupply : PowerSupply;\n\t\t\tout diagnosticData : DiagnosticData;\n\t\t}\n\t\tsuccession flow powerSupplyFlow from enterPoweredOnState.powerSupply to receivePower.powerSupply;\n\t\taction receivePower { in powerSupply : PowerSupply; }\n\t\taction sendShutdownCmd { out shutdownCmd : ShutdownCmd; }\n\t\tsuccession flow shutdownCmdFlow from sendShutdownCmd.shutdownCmd to executeSafetyOperations.shutdownCmd;\n\t\taction executeSafetyOperations { \n\t\t\tin shutdownCmd : ShutdownCmd;\n\t\t\tout parkingBrakeSignal : ParkingBrakeSignal;\n\t\t}\n\t}\n}",
    "package 'VehicleControl' {\n\tattribute def StartSignal;\n\tattribute def StartedSignal;\n\tattribute def ShutdownSignal;\n\tattribute def VehicleStatus;\n\t\n\tport def ControlSignalPort {\n\t\tin startSignal : StartSignal;\n\t\tin startedSignal : StartedSignal;\n\t\tin shutdownSignal : ShutdownSignal;\n\t}\n\t\n\tport def StatusPort {\n\t\tout vehicleStatus : VehicleStatus;\n\t}\n\t\n\tpart vehicleSystem {\n\t\tport controlPort : ControlSignalPort;\n\t\tport statusPort : StatusPort;\n\t\t\n\t\texhibit state vehicleStates {\n\t\t\tentry; then shutdown;\n\t\t\t\n\t\t\tstate shutdown {\n\t\t\t\tentry assign statusPort.vehicleStatus = \"shutdown\";\n\t\t\t\ttransition to startup\n\t\t\t\t\twhen controlPort.startSignal;\n\t\t\t}\n\t\t\t\n\t\t\tstate startup {\n\t\t\t\tentry assign statusPort.vehicleStatus = \"startup\";\n\t\t\t\ttransition to running\n\t\t\t\t\twhen controlPort.startedSignal;\n\t\t\t}\n\t\t\t\n\t\t\tstate running {\n\t\t\t\tentry assign statusPort.vehicleStatus = \"running\";\n\t\t\t\ttransition to shutdown\n\t\t\t\t\twhen controlPort.shutdownSignal;\n\t\t\t}\n\t\t}\n\t}\n}",
    "package 'VehiclePowerManagement' {\n    attribute def StartSignal;\n    attribute def OnSignal;\n    attribute def OffSignal;\n    attribute def PowerState;\n    \n    port def ControlSignalPort {\n        out startSignal: StartSignal;\n        out onSignal: OnSignal;\n        out offSignal: OffSignal;\n    }\n    \n    port def PowerStatePort {\n        out powerState: PowerState;\n    }\n    \n    part context {\n        part user {\n            port controlSignalPort: ControlSignalPort;\n            perform managePower.sendControlSignals {\n                out startSignal = controlSignalPort.startSignal;\n                out onSignal = controlSignalPort.onSignal;\n                out offSignal = controlSignalPort.offSignal;\n            }\n        }\n        \n        interface userToVehicle connect user.controlSignalPort to vehicle.controlSignalPort {\n            ref flow references managePower.startSignalFlow\n                from source.startSignal to target.startSignal;\n            ref flow references managePower.onSignalFlow\n                from source.onSignal to target.onSignal;\n            ref flow references managePower.offSignalFlow\n                from source.offSignal to target.offSignal;\n        }\n        \n        part vehicle {\n            port controlSignalPort: ~ControlSignalPort;\n            port powerStatePort: PowerStatePort;\n            \n            perform managePower.controlPowerState {\n                in startSignal = controlSignalPort.startSignal;\n                in onSignal = controlSignalPort.onSignal;\n                in offSignal = controlSignalPort.offSignal;\n                out powerState = powerStatePort.powerState;\n            }\n        }\n    }\n    \n    action managePower {\n        action sendControlSignals {\n            out startSignal: StartSignal;\n            out onSignal: OnSignal;\n            out offSignal: OffSignal;\n        }\n        \n        succession flow startSignalFlow from sendControlSignals.startSignal to controlPowerState.startSignal;\n        succession flow onSignalFlow from sendControlSignals.onSignal to controlPowerState.onSignal;\n        succession flow offSignalFlow from sendControlSignals.offSignal to controlPowerState.offSignal;\n        \n        action controlPowerState {\n            in startSignal: StartSignal;\n            in onSignal: OnSignal;\n            in offSignal: OffSignal;\n            out powerState: PowerState;\n        }\n    }\n}",
    "package 'VehicleHealthMonitoring' {\n\tattribute def Temperature;\n\tattribute def TemperatureThreshold;\n\tattribute def WarningSignal;\n\tattribute def HealthStatus;\n\tattribute def MaintenanceInterval;\n\tattribute def MaintenanceStatus;\n\t\n\tport def TemperaturePort {\n\t\tin temperature: Temperature;\n\t}\n\tport def WarningPort {\n\t\tout warning: WarningSignal;\n\t}\n\tport def StatusPort {\n\t\tout status: HealthStatus;\n\t}\n\tport def MaintenancePort {\n\t\tin maintenanceComplete: MaintenanceStatus;\n\t\tout maintenanceRequired: MaintenanceStatus;\n\t}\n\t\n\tpart context {\n\t\tpart vehicle {\n\t\t\tport temperaturePort: TemperaturePort;\n\t\t\tport maintenancePort: ~MaintenancePort;\n\t\t\tperform monitorHealth.provideTemperature {\n\t\t\t\tout temperature = temperaturePort.temperature;\n\t\t\t}\n\t\t\tperform monitorHealth.performMaintenance {\n\t\t\t\tin maintenanceRequired = maintenancePort.maintenanceRequired;\n\t\t\t\tout maintenanceComplete = maintenancePort.maintenanceComplete;\n\t\t\t}\n\t\t}\n\t\t\n\t\tinterface vehicleToMonitor connect vehicle.temperaturePort to healthMonitor.temperaturePort {\n\t\t\tref flow references monitorHealth.temperatureFlow\n\t\t\t\tfrom source.temperature to target.temperature;\n\t\t}\n\t\t\n\t\tinterface monitorToController connect healthMonitor.warningPort to vehicleController.warningPort {\n\t\t\tref flow references monitorHealth.warningFlow\n\t\t\t\tfrom source.warning to target.warning;\n\t\t}\n\t\t\n\t\tinterface monitorToVehicle connect healthMonitor.maintenancePort to vehicle.maintenancePort {\n\t\t\tref flow references monitorHealth.maintenanceFlow\n\t\t\t\tfrom source.maintenanceRequired to target.maintenanceRequired;\n\t\t}\n\t\t\n\t\tpart healthMonitor {\n\t\t\tport temperaturePort: ~TemperaturePort;\n\t\t\tport warningPort: WarningPort;\n\t\t\tport statusPort: StatusPort;\n\t\t\tport maintenancePort: MaintenancePort;\n\t\t\t\n\t\t\tperform monitorHealth.checkTemperature {\n\t\t\t\tin temperature = temperaturePort.temperature;\n\t\t\t\tout warning = warningPort.warning;\n\t\t\t\tout status = statusPort.status;\n\t\t\t}\n\t\t\t\n\t\t\tperform monitorHealth.scheduleMaintenance {\n\t\t\t\tout maintenanceRequired = maintenancePort.maintenanceRequired;\n\t\t\t\tin maintenanceComplete = maintenancePort.maintenanceComplete;\n\t\t\t}\n\t\t}\n\t\t\n\t\tpart vehicleController {\n\t\t\tport warningPort: ~WarningPort;\n\t\t\tperform monitorHealth.receiveWarning {\n\t\t\t\tin warning = warningPort.warning;\n\t\t\t}\n\t\t}\n\t}\n\t\n\taction monitorHealth {\n\t\taction provideTemperature { out temperature: Temperature; }\n\t\tsuccession flow temperatureFlow from provideTemperature.temperature to checkTemperature.temperature;\n\t\t\n\t\taction checkTemperature { \n\t\t\tin temperature: Temperature; \n\t\t\tout warning: WarningSignal;\n\t\t\tout status: HealthStatus;\n\t\t}\n\t\tsuccession flow warningFlow from checkTemperature.warning to receiveWarning.warning;\n\t\t\n\t\taction receiveWarning { in warning: WarningSignal; }\n\t\t\n\t\taction scheduleMaintenance {\n\t\t\tout maintenanceRequired: MaintenanceStatus;\n\t\t\tin maintenanceComplete: MaintenanceStatus;\n\t\t}\n\t\tsuccession flow maintenanceFlow from scheduleMaintenance.maintenanceRequired to performMaintenance.maintenanceRequired;\n\t\t\n\t\taction performMaintenance {\n\t\t\tin maintenanceRequired: MaintenanceStatus;\n\t\t\tout maintenanceComplete: MaintenanceStatus;\n\t\t}\n\t}\n}",
    "package 'TimedServer' {\n    attribute def Request;\n    attribute def StartCmd;\n    attribute def Time;\n    \n    port def RequestPort {\n        in request : Request;\n        in startCmd : StartCmd;\n    }\n    \n    port def TimePort {\n        in currentTime : Time;\n    }\n    \n    part server {\n        port requestPort : RequestPort;\n        port timePort : TimePort;\n        \n        exhibit state serverBehavior {\n            entry; then off;\n            \n            state off {\n                transition startTransition\n                    first off\n                    accept startCmd : StartCmd via requestPort\n                    then waiting;\n                    \n                transition dailyReset\n                    first waiting\n                    accept currentTime : Time via timePort\n                    if currentTime == \"11:59:00\"\n                    then off;\n                    \n                transition dailyResetFromResponse\n                    first response\n                    accept currentTime : Time via timePort\n                    if currentTime == \"11:59:00\"\n                    then off;\n            }\n            \n            state waiting {\n                transition requestTransition\n                    first waiting\n                    accept request : Request via requestPort\n                    then response;\n            }\n            \n            state response {\n                entry / {\n                    doc /* Wait for 5 minutes */\n                }\n                transition timeoutTransition\n                    first response\n                    after 5 [minute]\n                    then waiting;\n            }\n        }\n    }\n    \n    part clock {\n        port timePort : ~TimePort;\n        perform action {\n            out currentTime = timePort.currentTime;\n        }\n    }\n    \n    interface clockToServer connect clock.timePort to server.timePort;\n}",
    "package 'VehicleStartStopSystem' {\n\tattribute def StartSignal;\n\tattribute def StopSignal;\n\tattribute def PowerOnSignal;\n\tattribute def BrakePedalSignal;\n\tattribute def ControllerStartSignal;\n\tattribute def ParkingBrakeSignal;\n\tattribute def PowerSupply;\n\t\n\tport def StartSignalPort {\n\t\tin startSignal : StartSignal;\n\t}\n\tport def StopSignalPort {\n\t\tin stopSignal : StopSignal;\n\t}\n\tport def PowerOnSignalPort {\n\t\tin powerOnSignal : PowerOnSignal;\n\t}\n\tport def BrakePedalPort {\n\t\tin brakePedalSignal : BrakePedalSignal;\n\t}\n\tport def ControllerStartPort {\n\t\tout controllerStartSignal : ControllerStartSignal;\n\t}\n\tport def ParkingBrakePort {\n\t\tout parkingBrakeSignal : ParkingBrakeSignal;\n\t}\n\tport def PowerSupplyPort {\n\t\tout powerSupply : PowerSupply;\n\t}\n\t\n\tpart def VehicleStartStopController {\n\t\tport startSignalPort : StartSignalPort;\n\t\tport stopSignalPort : StopSignalPort;\n\t\tport powerOnSignalPort : PowerOnSignalPort;\n\t\tport brakePedalPort : BrakePedalPort;\n\t\tport controllerStartPort : ControllerStartPort;\n\t\tport parkingBrakePort : ParkingBrakePort;\n\t\tport powerSupplyPort : PowerSupplyPort;\n\t\t\n\t\texhibit state vehicleStates {\n\t\t\tentry state off;\n\t\t\tstate starting;\n\t\t\tstate operating;\n\t\t\t\n\t\t\ttransition off_to_starting\n\t\t\t\tfirst off\n\t\t\t\taccept startSignalPort.startSignal\n\t\t\t\tthen starting;\n\t\t\t\t\n\t\t\ttransition starting_to_operating\n\t\t\t\tfirst starting\n\t\t\t\taccept brakePedalPort.brakePedalSignal\n\t\t\t\taccept powerOnSignalPort.powerOnSignal\n\t\t\t\tdo send controllerStartPort.controllerStartSignal\n\t\t\t\tthen operating;\n\t\t\t\t\n\t\t\ttransition operating_to_off\n\t\t\t\tfirst operating\n\t\t\t\taccept stopSignalPort.stopSignal\n\t\t\t\tdo send parkingBrakePort.parkingBrakeSignal\n\t\t\t\tthen off;\n\t\t}\n\t\t\n\t\taction performSelfCheck;\n\t\taction supplyPower {\n\t\t\tout powerSupply = powerSupplyPort.powerSupply;\n\t\t}\n\t\t\n\t\tstate operating {\n\t\t\tentry performSelfCheck;\n\t\t\tdo supplyPower;\n\t\t}\n\t}\n\t\n\tpart vehicleSystem {\n\t\tpart controller : VehicleStartStopController;\n\t\tpart externalController {\n\t\t\tport controllerStartPort : ~ControllerStartPort;\n\t\t}\n\t\tpart parkingBrake {\n\t\t\tport parkingBrakePort : ~ParkingBrakePort;\n\t\t}\n\t\tpart vehicle {\n\t\t\tport powerSupplyPort : ~PowerSupplyPort;\n\t\t}\n\t\t\n\t\tinterface controllerInterface connect controller.controllerStartPort to externalController.controllerStartPort;\n\t\tinterface parkingBrakeInterface connect controller.parkingBrakePort to parkingBrake.parkingBrakePort;\n\t\tinterface powerInterface connect controller.powerSupplyPort to vehicle.powerSupplyPort;\n\t}\n}",
    "package 'VehicleStartStopSystem' {\n\tattribute def StartSignal;\n\tattribute def BrakePedalSignal;\n\tattribute def VehicleOnSignal;\n\tattribute def StartControlSignal;\n\tattribute def ShutdownSignal;\n\tattribute def ParkingBrakeSignal;\n\tattribute def PowerSupply;\n\tattribute def SelfCheckStatus;\n\t\n\tport def StartSignalPort {\n\t\tout startSignal : StartSignal;\n\t}\n\tport def BrakePedalPort {\n\t\tout brakePedalSignal : BrakePedalSignal;\n\t}\n\tport def VehicleOnSignalPort {\n\t\tout vehicleOnSignal : VehicleOnSignal;\n\t}\n\tport def StartControlPort {\n\t\tout startControlSignal : StartControlSignal;\n\t}\n\tport def ShutdownSignalPort {\n\t\tout shutdownSignal : ShutdownSignal;\n\t}\n\tport def ParkingBrakePort {\n\t\tout parkingBrakeSignal : ParkingBrakeSignal;\n\t}\n\tport def PowerSupplyPort {\n\t\tout powerSupply : PowerSupply;\n\t}\n\tport def SelfCheckPort {\n\t\tout selfCheckStatus : SelfCheckStatus;\n\t}\n\t\n\tpart context {\n\t\tpart driver {\n\t\t\tport startSignalPort : StartSignalPort;\n\t\t\tport brakePedalPort : BrakePedalPort;\n\t\t\tport vehicleOnSignalPort : VehicleOnSignalPort;\n\t\t\tport shutdownSignalPort : ShutdownSignalPort;\n\t\t\t\n\t\t\tperform vehicleOperation.initiateStart {\n\t\t\t\tout startSignal = startSignalPort.startSignal;\n\t\t\t}\n\t\t\tperform vehicleOperation.pressBrake {\n\t\t\t\tout brakePedalSignal = brakePedalPort.brakePedalSignal;\n\t\t\t}\n\t\t\tperform vehicleOperation.sendVehicleOn {\n\t\t\t\tout vehicleOnSignal = vehicleOnSignalPort.vehicleOnSignal;\n\t\t\t}\n\t\t\tperform vehicleOperation.initiateShutdown {\n\t\t\t\tout shutdownSignal = shutdownSignalPort.shutdownSignal;\n\t\t\t}\n\t\t}\n\t\t\n\t\tinterface driverToSystem connect driver.startSignalPort to startStopSystem.startSignalPort {\n\t\t\tref flow references vehicleOperation.startSignalFlow\n\t\t\t\tfrom source.startSignal to target.startSignal;\n\t\t}\n\t\tinterface driverBrakeToSystem connect driver.brakePedalPort to startStopSystem.brakePedalPort {\n\t\t\tref flow references vehicleOperation.brakeSignalFlow\n\t\t\t\tfrom source.brakePedalSignal to target.brakePedalSignal;\n\t\t}\n\t\tinterface driverVehicleOnToSystem connect driver.vehicleOnSignalPort to startStopSystem.vehicleOnSignalPort {\n\t\t\tref flow references vehicleOperation.vehicleOnSignalFlow\n\t\t\t\tfrom source.vehicleOnSignal to target.vehicleOnSignal;\n\t\t}\n\t\tinterface driverShutdownToSystem connect driver.shutdownSignalPort to startStopSystem.shutdownSignalPort {\n\t\t\tref flow references vehicleOperation.shutdownSignalFlow\n\t\t\t\tfrom source.shutdownSignal to target.shutdownSignal;\n\t\t}\n\t\t\n\t\tpart startStopSystem {\n\t\t\tport startSignalPort : ~StartSignalPort;\n\t\t\tport brakePedalPort : ~BrakePedalPort;\n\t\t\tport vehicleOnSignalPort : ~VehicleOnSignalPort;\n\t\t\tport shutdownSignalPort : ~ShutdownSignalPort;\n\t\t\tport startControlPort : StartControlPort;\n\t\t\tport parkingBrakePort : ParkingBrakePort;\n\t\t\tport powerSupplyPort : PowerSupplyPort;\n\t\t\tport selfCheckPort : SelfCheckPort;\n\t\t\t\n\t\t\tperform vehicleOperation.processStartup {\n\t\t\t\tin startSignal = startSignalPort.startSignal;\n\t\t\t\tin brakePedalSignal = brakePedalPort.brakePedalSignal;\n\t\t\t\tin vehicleOnSignal = vehicleOnSignalPort.vehicleOnSignal;\n\t\t\t\tout startControlSignal = startControlPort.startControlSignal;\n\t\t\t}\n\t\t\tperform vehicleOperation.performSelfCheck {\n\t\t\t\tout selfCheckStatus = selfCheckPort.selfCheckStatus;\n\t\t\t}\n\t\t\tperform vehicleOperation.supplyPower {\n\t\t\t\tout powerSupply = powerSupplyPort.powerSupply;\n\t\t\t}\n\t\t\tperform vehicleOperation.processShutdown {\n\t\t\t\tin shutdownSignal = shutdownSignalPort.shutdownSignal;\n\t\t\t\tout parkingBrakeSignal = parkingBrakePort.parkingBrakeSignal;\n\t\t\t}\n\t\t}\n\t\t\n\t\tinterface systemToController connect startStopSystem.startControlPort to vehicleController.startControlPort {\n\t\t\tref flow references vehicleOperation.startControlFlow\n\t\t\t\tfrom source.startControlSignal to target.startControlSignal;\n\t\t}\n\t\tinterface systemToParkingBrake connect startStopSystem.parkingBrakePort to parkingBrake.parkingBrakePort {\n\t\t\tref flow references vehicleOperation.parkingBrakeFlow\n\t\t\t\tfrom source.parkingBrakeSignal to target.parkingBrakeSignal;\n\t\t}\n\t\t\n\t\tpart vehicleController {\n\t\t\tport startControlPort : ~StartControlPort;\n\t\t\tperform vehicleOperation.startVehicle {\n\t\t\t\tin startControlSignal = startControlPort.startControlSignal;\n\t\t\t}\n\t\t}\n\t\t\n\t\tpart parkingBrake {\n\t\t\tport parkingBrakePort : ~ParkingBrakePort;\n\t\t\tperform vehicleOperation.applyParkingBrake {\n\t\t\t\tin parkingBrakeSignal = parkingBrakePort.parkingBrakeSignal;\n\t\t\t}\n\t\t}\n\t}\n\t\n\taction vehicleOperation {\n\t\taction initiateStart { out startSignal : StartSignal; }\n\t\tsuccession flow startSignalFlow from initiateStart.startSignal to processStartup.startSignal;\n\t\t\n\t\taction pressBrake { out brakePedalSignal : BrakePedalSignal; }\n\t\tsuccession flow brakeSignalFlow from pressBrake.brakePedalSignal to processStartup.brakePedalSignal;\n\t\t\n\t\taction sendVehicleOn { out vehicleOnSignal : VehicleOnSignal; }\n\t\tsuccession flow vehicleOnSignalFlow from sendVehicleOn.vehicleOnSignal to processStartup.vehicleOnSignal;\n\t\t\n\t\taction processStartup { \n\t\t\tin startSignal : StartSignal; \n\t\t\tin brakePedalSignal : BrakePedalSignal;\n\t\t\tin vehicleOnSignal : VehicleOnSignal;\n\t\t\tout startControlSignal : StartControlSignal; \n\t\t}\n\t\tsuccession flow startControlFlow from processStartup.startControlSignal to startVehicle.startControlSignal;\n\t\t\n\t\taction startVehicle { in startControlSignal : StartControlSignal; }\n\t\tsuccession from startVehicle to performSelfCheck;\n\t\tsuccession from startVehicle to supplyPower;\n\t\t\n\t\taction performSelfCheck { out selfCheckStatus : SelfCheckStatus; }\n\t\taction supplyPower { out powerSupply : PowerSupply; }\n\t\t\n\t\taction initiateShutdown { out shutdownSignal : ShutdownSignal; }\n\t\tsuccession flow shutdownSignalFlow from initiateShutdown.shutdownSignal to processShutdown.shutdownSignal;\n\t\t\n\t\taction processShutdown { \n\t\t\tin shutdownSignal : ShutdownSignal; \n\t\t\tout parkingBrakeSignal : ParkingBrakeSignal;\n\t\t}\n\t\tsuccession flow parkingBrakeFlow from processShutdown.parkingBrakeSignal to applyParkingBrake.parkingBrakeSignal;\n\t\t\n\t\taction applyParkingBrake { in parkingBrakeSignal : ParkingBrakeSignal; }\n\t}\n}",
    "package 'CruiseControlSystem' {\n\tattribute def SetSpeedCmd;\n\tattribute def ActualSpeed;\n\tattribute def FuelControlCmd;\n\t\n\tport def SetSpeedCmdPort {\n\t\tout setSpeedCmd : SetSpeedCmd;\n\t}\n\tport def ActualSpeedPort {\n\t\tout actualSpeed : ActualSpeed;\n\t}\n\tport def FuelControlCmdPort {\n\t\tout fuelControlCmd : FuelControlCmd;\n\t}\n\t\n\tpart context {\n\t\tpart driver {\n\t\t\tport setSpeedCmdPort : SetSpeedCmdPort;\n\t\t\tperform cruiseControl.sendSetSpeedCmd {\n\t\t\t\tout setSpeedCmd = setSpeedCmdPort.setSpeedCmd;\n\t\t\t}\n\t\t}\n\t\t\n\t\tinterface driverToCruiseController connect driver.setSpeedCmdPort to cruiseController.setSpeedCmdPort {\n\t\t\tref flow references cruiseControl.setSpeedCmdFlow\n\t\t\t\tfrom source.setSpeedCmd to target.setSpeedCmd;\n\t\t}\n\t\t\n\t\tpart vehicle {\n\t\t\tpart cruiseController {\n\t\t\t\tport setSpeedCmdPort : ~SetSpeedCmdPort;\n\t\t\t\tport actualSpeedPort : ~ActualSpeedPort;\n\t\t\t\tport fuelControlCmdPort : FuelControlCmdPort;\n\t\t\t\tperform cruiseControl.generateFuelControlCmd {\n\t\t\t\t\tin setSpeedCmd = setSpeedCmdPort.setSpeedCmd;\n\t\t\t\t\tin actualSpeed = actualSpeedPort.actualSpeed;\n\t\t\t\t\tout fuelControlCmd = fuelControlCmdPort.fuelControlCmd;\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\tpart speedometer {\n\t\t\t\tport actualSpeedPort : ActualSpeedPort;\n\t\t\t\tperform cruiseControl.collectActualSpeed {\n\t\t\t\t\tout actualSpeed = actualSpeedPort.actualSpeed;\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\tpart engine {\n\t\t\t\tport fuelControlCmdPort : ~FuelControlCmdPort;\n\t\t\t\tperform cruiseControl.adjustOutput {\n\t\t\t\t\tin fuelControlCmd = fuelControlCmdPort.fuelControlCmd;\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\tinterface speedometerToCruiseController connect speedometer.actualSpeedPort to cruiseController.actualSpeedPort {\n\t\t\t\tref flow references cruiseControl.actualSpeedFlow\n\t\t\t\t\tfrom source.actualSpeed to target.actualSpeed;\n\t\t\t}\n\t\t\t\n\t\t\tinterface cruiseControllerToEngine connect cruiseController.fuelControlCmdPort to engine.fuelControlCmdPort {\n\t\t\t\tref flow references cruiseControl.fuelControlCmdFlow\n\t\t\t\t\tfrom source.fuelControlCmd to target.fuelControlCmd;\n\t\t\t}\n\t\t}\n\t}\n\t\n\taction cruiseControl {\n\t\taction sendSetSpeedCmd { out setSpeedCmd : SetSpeedCmd; }\n\t\taction collectActualSpeed { out actualSpeed : ActualSpeed; }\n\t\tsuccession flow setSpeedCmdFlow from sendSetSpeedCmd.setSpeedCmd to generateFuelControlCmd.setSpeedCmd;\n\t\tsuccession flow actualSpeedFlow from collectActualSpeed.actualSpeed to generateFuelControlCmd.actualSpeed;\n\t\taction generateFuelControlCmd { in setSpeedCmd; in actualSpeed; out fuelControlCmd : FuelControlCmd; }\n\t\tsuccession flow fuelControlCmdFlow from generateFuelControlCmd.fuelControlCmd to adjustOutput.fuelControlCmd;\n\t\taction adjustOutput { in fuelControlCmd : FuelControlCmd; }\n\t}\n}",
    "package 'CruiseControl' {\n\tattribute def SetSpeedCmd;\n\tattribute def VehicleSpeed;\n\tattribute def ThrottleCmd;\n\t\n\tport def SetSpeedCmdPort {\n\t\tout setSpeedCmd : SetSpeedCmd;\n\t}\n\tport def VehicleSpeedPort {\n\t\tout vehicleSpeed : VehicleSpeed;\n\t}\n\tport def ThrottlePort {\n\t\tout throttleCmd : ThrottleCmd;\n\t}\n\t\n\tpart context {\n\t\tpart driver {\n\t\t\tport setSpeedCmdPort : SetSpeedCmdPort;\n\t\t\tperform cruiseOperation.sendSetSpeed {\n\t\t\t\tout setSpeedCmd = setSpeedCmdPort.setSpeedCmd;\n\t\t\t}\n\t\t}\n\t\t\n\t\tinterface driverToController connect driver.setSpeedCmdPort to cruiseController.setSpeedCmdPort {\n\t\t\tref flow references cruiseOperation.setSpeedFlow\n\t\t\t\tfrom source.setSpeedCmd to target.setSpeedCmd;\n\t\t}\n\t\t\n\t\tpart cruiseController {\n\t\t\tport setSpeedCmdPort : ~SetSpeedCmdPort;\n\t\t\tport vehicleSpeedPort : ~VehicleSpeedPort;\n\t\t\tport throttlePort : ThrottlePort;\n\t\t\tperform cruiseOperation.controlSpeed {\n\t\t\t\tin setSpeedCmd = setSpeedCmdPort.setSpeedCmd;\n\t\t\t\tin vehicleSpeed = vehicleSpeedPort.vehicleSpeed;\n\t\t\t\tout throttleCmd = throttlePort.throttleCmd;\n\t\t\t}\n\t\t}\n\t\t\n\t\tpart speedometer {\n\t\t\tport vehicleSpeedPort : VehicleSpeedPort;\n\t\t\tperform cruiseOperation.measureSpeed {\n\t\t\t\tout vehicleSpeed = vehicleSpeedPort.vehicleSpeed;\n\t\t\t}\n\t\t}\n\t\t\n\t\tinterface speedometerToController connect speedometer.vehicleSpeedPort to cruiseController.vehicleSpeedPort {\n\t\t\tref flow references cruiseOperation.speedFlow\n\t\t\t\tfrom source.vehicleSpeed to target.vehicleSpeed;\n\t\t}\n\t\t\n\t\tpart engine {\n\t\t\tport throttlePort : ~ThrottlePort;\n\t\t\tperform cruiseOperation.adjustPower {\n\t\t\t\tin throttleCmd = throttlePort.throttleCmd;\n\t\t\t}\n\t\t}\n\t\t\n\t\tinterface controllerToEngine connect cruiseController.throttlePort to engine.throttlePort {\n\t\t\tref flow references cruiseOperation.throttleFlow\n\t\t\t\tfrom source.throttleCmd to target.throttleCmd;\n\t\t}\n\t}\n\t\n\taction cruiseOperation {\n\t\taction sendSetSpeed { out setSpeedCmd : SetSpeedCmd; }\n\t\taction measureSpeed { out vehicleSpeed : VehicleSpeed; }\n\t\tsuccession flow setSpeedFlow from sendSetSpeed.setSpeedCmd to controlSpeed.setSpeedCmd;\n\t\tsuccession flow speedFlow from measureSpeed.vehicleSpeed to controlSpeed.vehicleSpeed;\n\t\taction controlSpeed { in setSpeedCmd; in vehicleSpeed; out throttleCmd : ThrottleCmd; }\n\t\tsuccession flow throttleFlow from controlSpeed.throttleCmd to adjustPower.throttleCmd;\n\t\taction adjustPower { in throttleCmd : ThrottleCmd; }\n\t}\n}",
    "package 'CruiseControl' {\n\tattribute def SetSpeedCmd;\n\tattribute def CurrentSpeed;\n\tattribute def ThrottleCmd;\n\t\n\tport def SetSpeedCmdPort {\n\t\tout setSpeedCmd : SetSpeedCmd;\n\t}\n\tport def CurrentSpeedPort {\n\t\tout currentSpeed : CurrentSpeed;\n\t}\n\tport def ThrottlePort {\n\t\tout throttleCmd : ThrottleCmd;\n\t}\n\t\n\tpart context {\n\t\tpart driver {\n\t\t\tport setSpeedCmdPort : SetSpeedCmdPort;\n\t\t\tperform maintainSpeed.sendSetSpeedCmd {\n\t\t\t\tout setSpeedCmd = setSpeedCmdPort.setSpeedCmd;\n\t\t\t}\n\t\t}\n\t\t\n\t\tinterface driverToController connect driver.setSpeedCmdPort to cruiseController.setSpeedCmdPort {\n\t\t\tref flow references maintainSpeed.setSpeedFlow\n\t\t\t\tfrom source.setSpeedCmd to target.setSpeedCmd;\n\t\t}\n\t\t\n\t\tpart cruiseController {\n\t\t\tport setSpeedCmdPort : ~SetSpeedCmdPort;\n\t\t\tport currentSpeedPort : ~CurrentSpeedPort;\n\t\t\tport throttlePort : ThrottlePort;\n\t\t\tperform maintainSpeed.calculateThrottle {\n\t\t\t\tin setSpeedCmd = setSpeedCmdPort.setSpeedCmd;\n\t\t\t\tin currentSpeed = currentSpeedPort.currentSpeed;\n\t\t\t\tout throttleCmd = throttlePort.throttleCmd;\n\t\t\t}\n\t\t}\n\t\t\n\t\tpart speedometer {\n\t\t\tport currentSpeedPort : CurrentSpeedPort;\n\t\t\tperform maintainSpeed.measureSpeed {\n\t\t\t\tout currentSpeed = currentSpeedPort.currentSpeed;\n\t\t\t}\n\t\t}\n\t\t\n\t\tinterface speedometerToController connect speedometer.currentSpeedPort to cruiseController.currentSpeedPort {\n\t\t\tref flow references maintainSpeed.speedFlow\n\t\t\t\tfrom source.currentSpeed to target.currentSpeed;\n\t\t}\n\t\t\n\t\tpart engine {\n\t\t\tport throttlePort : ~ThrottlePort;\n\t\t\tperform maintainSpeed.adjustOutput {\n\t\t\t\tin throttleCmd = throttlePort.throttleCmd;\n\t\t\t}\n\t\t}\n\t\t\n\t\tinterface controllerToEngine connect cruiseController.throttlePort to engine.throttlePort {\n\t\t\tref flow references maintainSpeed.throttleFlow\n\t\t\t\tfrom source.throttleCmd to target.throttleCmd;\n\t\t}\n\t}\n\t\n\taction maintainSpeed {\n\t\taction sendSetSpeedCmd { out setSpeedCmd : SetSpeedCmd; }\n\t\taction measureSpeed { out currentSpeed : CurrentSpeed; }\n\t\tsuccession flow setSpeedFlow from sendSetSpeedCmd.setSpeedCmd to calculateThrottle.setSpeedCmd;\n\t\tsuccession flow speedFlow from measureSpeed.currentSpeed to calculateThrottle.currentSpeed;\n\t\taction calculateThrottle { in setSpeedCmd; in currentSpeed; out throttleCmd : ThrottleCmd; }\n\t\tsuccession flow throttleFlow from calculateThrottle.throttleCmd to adjustOutput.throttleCmd;\n\t\taction adjustOutput { in throttleCmd : ThrottleCmd; }\n\t}\n}",
    "package 'CruiseControl' {\n\tattribute def SpeedCmd;\n\tattribute def Speed;\n\tattribute def ThrottleCmd;\n\t\n\tport def SpeedCmdPort {\n\t\tout speedCmd : SpeedCmd;\n\t}\n\tport def SpeedPort {\n\t\tout speed : Speed;\n\t}\n\tport def ThrottleCmdPort {\n\t\tout throttleCmd : ThrottleCmd;\n\t}\n\t\n\tpart context {\n\t\tpart driver {\n\t\t\tport speedCmdPort : SpeedCmdPort;\n\t\t\tperform maintainSpeed.sendSpeedCmd {\n\t\t\t\tout speedCmd = speedCmdPort.speedCmd;\n\t\t\t}\n\t\t}\n\t\t\n\t\tinterface driverToController connect driver.speedCmdPort to cruiseController.speedCmdPort {\n\t\t\tref flow references maintainSpeed.speedCmdFlow\n\t\t\t\tfrom source.speedCmd to target.speedCmd;\n\t\t}\n\t\t\n\t\tpart cruiseController {\n\t\t\tport speedCmdPort : ~SpeedCmdPort;\n\t\t\tport speedPort : ~SpeedPort;\n\t\t\tport throttleCmdPort : ThrottleCmdPort;\n\t\t\tperform maintainSpeed.calculateThrottle {\n\t\t\t\tin speedCmd = speedCmdPort.speedCmd;\n\t\t\t\tin speed = speedPort.speed;\n\t\t\t\tout throttleCmd = throttleCmdPort.throttleCmd;\n\t\t\t}\n\t\t}\n\t\t\n\t\tinterface speedometerToController connect speedometer.speedPort to cruiseController.speedPort {\n\t\t\tref flow references maintainSpeed.speedFlow\n\t\t\t\tfrom source.speed to target.speed;\n\t\t}\n\t\t\n\t\tinterface controllerToEngine connect cruiseController.throttleCmdPort to engine.throttleCmdPort {\n\t\t\tref flow references maintainSpeed.throttleFlow\n\t\t\t\tfrom source.throttleCmd to target.throttleCmd;\n\t\t}\n\t\t\n\t\tpart speedometer {\n\t\t\tport speedPort : SpeedPort;\n\t\t\tperform maintainSpeed.senseSpeed {\n\t\t\t\tout speed = speedPort.speed;\n\t\t\t}\n\t\t}\n\t\t\n\t\tpart engine {\n\t\t\tport throttleCmdPort : ~ThrottleCmdPort;\n\t\t\tperform maintainSpeed.adjustThrottle {\n\t\t\t\tin throttleCmd = throttleCmdPort.throttleCmd;\n\t\t\t}\n\t\t}\n\t}\n\t\n\taction maintainSpeed {\n\t\taction sendSpeedCmd { out speedCmd : SpeedCmd; }\n\t\taction senseSpeed { out speed : Speed; }\n\t\tsuccession flow speedCmdFlow from sendSpeedCmd.speedCmd to calculateThrottle.speedCmd;\n\t\tsuccession flow speedFlow from senseSpeed.speed to calculateThrottle.speed;\n\t\taction calculateThrottle { in speedCmd; in speed; out throttleCmd : ThrottleCmd; }\n\t\tsuccession flow throttleFlow from calculateThrottle.throttleCmd to adjustThrottle.throttleCmd;\n\t\taction adjustThrottle { in throttleCmd : ThrottleCmd; }\n\t}\n}",
    "package 'CruiseControl' {\n\tattribute def SetSpeed;\n\tattribute def ActualSpeed;\n\tattribute def FuelCommand;\n\t\n\tport def SetSpeedPort {\n\t\tout setSpeed : SetSpeed;\n\t}\n\tport def ActualSpeedPort {\n\t\tout actualSpeed : ActualSpeed;\n\t}\n\tport def FuelCommandPort {\n\t\tout fuelCommand : FuelCommand;\n\t}\n\t\n\tpart context {\n\t\tpart driver {\n\t\t\tport setSpeedPort : SetSpeedPort;\n\t\t\tperform maintainSpeed.sendSetSpeed {\n\t\t\t\tout setSpeed = setSpeedPort.setSpeed;\n\t\t\t}\n\t\t}\n\t\t\n\t\tinterface driverToCruiseController connect driver.setSpeedPort to cruiseController.setSpeedPort {\n\t\t\tref flow references maintainSpeed.setSpeedFlow\n\t\t\t\tfrom source.setSpeed to target.setSpeed;\n\t\t}\n\t\t\n\t\tpart cruiseController {\n\t\t\tport setSpeedPort : ~SetSpeedPort;\n\t\t\tport actualSpeedPort : ~ActualSpeedPort;\n\t\t\tport fuelCommandPort : FuelCommandPort;\n\t\t\tperform maintainSpeed.controlSpeed {\n\t\t\t\tin setSpeed = setSpeedPort.setSpeed;\n\t\t\t\tin actualSpeed = actualSpeedPort.actualSpeed;\n\t\t\t\tout fuelCommand = fuelCommandPort.fuelCommand;\n\t\t\t}\n\t\t}\n\t\t\n\t\tpart speedSensor {\n\t\t\tport actualSpeedPort : ActualSpeedPort;\n\t\t\tperform maintainSpeed.detectSpeed {\n\t\t\t\tout actualSpeed = actualSpeedPort.actualSpeed;\n\t\t\t}\n\t\t}\n\t\t\n\t\tinterface speedSensorToCruiseController connect speedSensor.actualSpeedPort to cruiseController.actualSpeedPort {\n\t\t\tref flow references maintainSpeed.actualSpeedFlow\n\t\t\t\tfrom source.actualSpeed to target.actualSpeed;\n\t\t}\n\t\t\n\t\tpart engine {\n\t\t\tport fuelCommandPort : ~FuelCommandPort;\n\t\t\tperform maintainSpeed.adjustFuel {\n\t\t\t\tin fuelCommand = fuelCommandPort.fuelCommand;\n\t\t\t}\n\t\t}\n\t\t\n\t\tinterface cruiseControllerToEngine connect cruiseController.fuelCommandPort to engine.fuelCommandPort {\n\t\t\tref flow references maintainSpeed.fuelCommandFlow\n\t\t\t\tfrom source.fuelCommand to target.fuelCommand;\n\t\t}\n\t}\n\t\n\taction maintainSpeed {\n\t\taction sendSetSpeed { out setSpeed : SetSpeed; }\n\t\taction detectSpeed { out actualSpeed : ActualSpeed; }\n\t\tsuccession flow setSpeedFlow from sendSetSpeed.setSpeed to controlSpeed.setSpeed;\n\t\tsuccession flow actualSpeedFlow from detectSpeed.actualSpeed to controlSpeed.actualSpeed;\n\t\taction controlSpeed { in setSpeed : SetSpeed; in actualSpeed : ActualSpeed; out fuelCommand : FuelCommand; }\n\t\tsuccession flow fuelCommandFlow from controlSpeed.fuelCommand to adjustFuel.fuelCommand;\n\t\taction adjustFuel { in fuelCommand : FuelCommand; }\n\t}\n}",
    "package 'CruiseControlSystem' {\n\tattribute def SetSpeedCmd;\n\tattribute def ActualSpeed;\n\tattribute def FuelControlCmd;\n\t\n\tport def SetSpeedCmdPort {\n\t\tout setSpeedCmd : SetSpeedCmd;\n\t}\n\tport def ActualSpeedPort {\n\t\tout actualSpeed : ActualSpeed;\n\t}\n\tport def FuelControlCmdPort {\n\t\tout fuelControlCmd : FuelControlCmd;\n\t}\n\t\n\tpart context {\n\t\tpart driver {\n\t\t\tport setSpeedCmdPort : SetSpeedCmdPort;\n\t\t\tperform cruiseOperation.sendSetSpeedCmd {\n\t\t\t\tout setSpeedCmd = setSpeedCmdPort.setSpeedCmd;\n\t\t\t}\n\t\t}\n\t\t\n\t\tinterface driverToCruiseController connect driver.setSpeedCmdPort to cruiseController.setSpeedCmdPort {\n\t\t\tref flow references cruiseOperation.setSpeedCmdFlow\n\t\t\t\tfrom source.setSpeedCmd to target.setSpeedCmd;\n\t\t}\n\t\t\n\t\tpart cruiseController {\n\t\t\tport setSpeedCmdPort : ~SetSpeedCmdPort;\n\t\t\tport actualSpeedPort : ~ActualSpeedPort;\n\t\t\tport fuelControlCmdPort : FuelControlCmdPort;\n\t\t\tperform cruiseOperation.processCruiseControl {\n\t\t\t\tin setSpeedCmd = setSpeedCmdPort.setSpeedCmd;\n\t\t\t\tin actualSpeed = actualSpeedPort.actualSpeed;\n\t\t\t\tout fuelControlCmd = fuelControlCmdPort.fuelControlCmd;\n\t\t\t}\n\t\t}\n\t\t\n\t\tpart speedSensor {\n\t\t\tport actualSpeedPort : ActualSpeedPort;\n\t\t\tperform cruiseOperation.readSpeed {\n\t\t\t\tout actualSpeed = actualSpeedPort.actualSpeed;\n\t\t\t}\n\t\t}\n\t\t\n\t\tinterface speedSensorToCruiseController connect speedSensor.actualSpeedPort to cruiseController.actualSpeedPort {\n\t\t\tref flow references cruiseOperation.actualSpeedFlow\n\t\t\t\tfrom source.actualSpeed to target.actualSpeed;\n\t\t}\n\t\t\n\t\tinterface cruiseControllerToEngineController connect cruiseController.fuelControlCmdPort to engineController.fuelControlCmdPort {\n\t\t\tref flow references cruiseOperation.fuelControlCmdFlow\n\t\t\t\tfrom source.fuelControlCmd to target.fuelControlCmd;\n\t\t}\n\t\t\n\t\tpart engineController {\n\t\t\tport fuelControlCmdPort : ~FuelControlCmdPort;\n\t\t\tport engineFuelControlCmdPort : FuelControlCmdPort;\n\t\t\tperform cruiseOperation.processEngineControl {\n\t\t\t\tin fuelControlCmd = fuelControlCmdPort.fuelControlCmd;\n\t\t\t\tout fuelControlCmd = engineFuelControlCmdPort.fuelControlCmd;\n\t\t\t}\n\t\t}\n\t\t\n\t\tinterface engineControllerToEngine connect engineController.engineFuelControlCmdPort to engine.fuelControlCmdPort {\n\t\t\tref flow references cruiseOperation.engineFuelControlCmdFlow\n\t\t\t\tfrom source.fuelControlCmd to target.fuelControlCmd;\n\t\t}\n\t\t\n\t\tpart engine {\n\t\t\tport fuelControlCmdPort : ~FuelControlCmdPort;\n\t\t\tperform cruiseOperation.controlFuelFlow {\n\t\t\t\tin fuelControlCmd = fuelControlCmdPort.fuelControlCmd;\n\t\t\t}\n\t\t}\n\t}\n\t\n\taction cruiseOperation {\n\t\taction sendSetSpeedCmd { out setSpeedCmd : SetSpeedCmd; }\n\t\taction readSpeed { out actualSpeed : ActualSpeed; }\n\t\tsuccession flow setSpeedCmdFlow from sendSetSpeedCmd.setSpeedCmd to processCruiseControl.setSpeedCmd;\n\t\tsuccession flow actualSpeedFlow from readSpeed.actualSpeed to processCruiseControl.actualSpeed;\n\t\taction processCruiseControl { in setSpeedCmd; in actualSpeed; out fuelControlCmd : FuelControlCmd; }\n\t\tsuccession flow fuelControlCmdFlow from processCruiseControl.fuelControlCmd to processEngineControl.fuelControlCmd;\n\t\taction processEngineControl { in fuelControlCmd; out fuelControlCmd : FuelControlCmd; }\n\t\tsuccession flow engineFuelControlCmdFlow from processEngineControl.fuelControlCmd to controlFuelFlow.fuelControlCmd;\n\t\taction controlFuelFlow { in fuelControlCmd : FuelControlCmd; }\n\t}\n}",
    "package 'VehicleLifecycleManagement' {\n\tattribute def VehicleID;\n\tattribute def DeliveryDate;\n\tattribute def OwnerInfo;\n\tattribute def DriverInfo;\n\tattribute def ScrapInfo;\n\t\n\tport def VehicleDataPort {\n\t\tout vehicleID: VehicleID;\n\t\tout deliveryDate: DeliveryDate;\n\t}\n\t\n\tport def OwnershipPort {\n\t\tin vehicleID: VehicleID;\n\t\tout ownerInfo: OwnerInfo;\n\t}\n\t\n\tport def DrivingPort {\n\t\tin vehicleID: VehicleID;\n\t\tin ownerInfo: OwnerInfo;\n\t\tout driverInfo: DriverInfo;\n\t}\n\t\n\tport def ScrapPort {\n\t\tin vehicleID: VehicleID;\n\t\tout scrapInfo: ScrapInfo;\n\t}\n\t\n\tpart context {\n\t\tpart assemblySystem {\n\t\t\tport vehicleDataPort: VehicleDataPort;\n\t\t\tperform manageLifecycle.assembleVehicle {\n\t\t\t\tout vehicleID = vehicleDataPort.vehicleID;\n\t\t\t}\n\t\t}\n\t\t\n\t\tpart deliverySystem {\n\t\t\tport vehicleDataPort: ~VehicleDataPort;\n\t\t\tperform manageLifecycle.deliverVehicle {\n\t\t\t\tin vehicleID = vehicleDataPort.vehicleID;\n\t\t\t\tout deliveryDate = vehicleDataPort.deliveryDate;\n\t\t\t}\n\t\t}\n\t\t\n\t\tinterface assemblyToDelivery connect assemblySystem.vehicleDataPort to deliverySystem.vehicleDataPort {\n\t\t\tref flow references manageLifecycle.vehicleFlow\n\t\t\t\tfrom source.vehicleID to target.vehicleID;\n\t\t}\n\t\t\n\t\tpart ownershipSystem {\n\t\t\tport ownershipPort: OwnershipPort;\n\t\t\tperform manageLifecycle.recordOwnership {\n\t\t\t\tin vehicleID = ownershipPort.vehicleID;\n\t\t\t\tout ownerInfo = ownershipPort.ownerInfo;\n\t\t\t}\n\t\t}\n\t\t\n\t\tpart drivingSystem {\n\t\t\tport drivingPort: DrivingPort;\n\t\t\tperform manageLifecycle.recordDriving {\n\t\t\t\tin vehicleID = drivingPort.vehicleID;\n\t\t\t\tin ownerInfo = drivingPort.ownerInfo;\n\t\t\t\tout driverInfo = drivingPort.driverInfo;\n\t\t\t}\n\t\t}\n\t\t\n\t\tinterface ownershipToDriving connect ownershipSystem.ownershipPort to drivingSystem.drivingPort {\n\t\t\tref flow references manageLifecycle.ownerFlow\n\t\t\t\tfrom source.ownerInfo to target.ownerInfo;\n\t\t}\n\t\t\n\t\tpart scrapSystem {\n\t\t\tport scrapPort: ScrapPort;\n\t\t\tperform manageLifecycle.scrapVehicle {\n\t\t\t\tin vehicleID = scrapPort.vehicleID;\n\t\t\t\tout scrapInfo = scrapPort.scrapInfo;\n\t\t\t}\n\t\t}\n\t}\n\t\n\taction manageLifecycle {\n\t\taction assembleVehicle { out vehicleID: VehicleID; }\n\t\tsuccession flow vehicleFlow from assembleVehicle.vehicleID to deliverVehicle.vehicleID;\n\t\taction deliverVehicle { in vehicleID: VehicleID; out deliveryDate: DeliveryDate; }\n\t\tsuccession flow deliveryFlow from deliverVehicle.vehicleID to recordOwnership.vehicleID;\n\t\taction recordOwnership { in vehicleID: VehicleID; out ownerInfo: OwnerInfo; }\n\t\tsuccession flow ownerFlow from recordOwnership.ownerInfo to recordDriving.ownerInfo;\n\t\taction recordDriving { in vehicleID: VehicleID; in ownerInfo: OwnerInfo; out driverInfo: DriverInfo; }\n\t\tsuccession flow endFlow from recordDriving.vehicleID to scrapVehicle.vehicleID;\n\t\taction scrapVehicle { in vehicleID: VehicleID; out scrapInfo: ScrapInfo; }\n\t}\n}",
    "package 'Vehicle System' {\n    attribute def Mass;\n    attribute def GearSetting;\n    attribute def AcceleratorPosition;\n    \n    attribute def OperationalStatus {\n        attribute gearSetting: GearSetting;\n        attribute acceleratorPosition: AcceleratorPosition;\n    }\n    \n    part def Engine;\n    part def Wheel;\n    part def Driver;\n    \n    part def Vehicle {\n        attribute mass: Mass;\n        attribute operationalStatus: OperationalStatus;\n        \n        part engine: Engine;\n        ref part driver: Driver;\n        \n        part wheels: Wheel[*] {\n            part leftFrontWheel: Wheel;\n            part rightFrontWheel: Wheel;\n        }\n    }\n    \n    part vehicle_1: Vehicle {\n        snapshot leftFrontWheelSnapshot {\n            snapshot time: Time;\n            snapshot wheelState: wheels.leftFrontWheel;\n        }\n        \n        snapshot rightFrontWheelSnapshot {\n            snapshot time: Time;\n            snapshot wheelState: wheels.rightFrontWheel;\n        }\n    }\n}",
    "package 'VehicleSystem' {\n    attribute def Mass;\n    attribute def GearSetting;\n    attribute def AcceleratorPosition;\n    \n    attribute def VehicleState {\n        attribute gear: GearSetting;\n        attribute acceleratorPos: AcceleratorPosition;\n    }\n    \n    part def Vehicle {\n        attribute mass: Mass;\n        attribute state: VehicleState;\n    }\n    \n    part def Engine;\n    part def Driver;\n    \n    part vehicle_1: Vehicle {\n        timeslice initialState {\n            attribute :>> mass = 2000;\n            attribute :>> state {\n                attribute :>> gear = 0;\n                attribute :>> acceleratorPos = 0.0;\n            }\n        }\n        then timeslice nextState {\n            attribute :>> mass = 1500;\n            attribute :>> state {\n                attribute :>> gear = 2;\n                attribute :>> acceleratorPos = 0.5;\n            }\n        }\n    }\n    \n    part compositeSystem {\n        part vehicles: Vehicle[*];\n        part engines: Engine[*];\n        part drivers: Driver[*];\n    }\n}",
    "package 'VehicleSystem' {\n    attribute def Mass;\n    attribute def GearPosition;\n    attribute def ThrottlePedalPosition;\n    \n    part def Vehicle {\n        attribute mass : Mass;\n        attribute gearPosition : GearPosition;\n        attribute throttlePedalPosition : ThrottlePedalPosition;\n        \n        part engine;\n        ref driver : Person;\n    }\n    \n    part def Person {\n        attribute name : String;\n    }\n    \n    part alice : Person {\n        attribute name = \"Alice\";\n    }\n    \n    part bob : Person {\n        attribute name = \"Bob\";\n    }\n    \n    part vehicle : Vehicle {\n        timeslice initialState {\n            attribute mass = 2000;\n            attribute gearPosition = \"neutral\";\n            attribute throttlePedalPosition = 0.0;\n            ref driver = alice;\n        }\n        \n        then timeslice subsequentState {\n            attribute mass = 1500;\n            attribute gearPosition = \"second\";\n            attribute throttlePedalPosition = 0.5;\n            ref driver = bob;\n        }\n    }\n}",
    "package 'VehicleMassManagement' {\n    attribute def Mass;\n    attribute def ComponentID;\n    \n    part def MassComponent {\n        attribute id: ComponentID;\n        attribute ownMass: Mass;\n        attribute totalMass: Mass;\n    }\n    \n    part def SimpleComponent :> MassComponent {\n        calc totalMass = ownMass;\n    }\n    \n    part def CompositeComponent :> MassComponent {\n        part subComponents: MassComponent[0..*];\n        calc totalMass = ownMass + sum(subComponents.totalMass);\n    }\n    \n    part def Engine :> SimpleComponent;\n    part def Transmission :> SimpleComponent;\n    part def Body :> SimpleComponent;\n    \n    part def Vehicle :> CompositeComponent {\n        part engine: Engine;\n        part transmission: Transmission;\n        part body: Body;\n        part otherComponents: MassComponent[0..*];\n        \n        bind subComponents = (engine, transmission, body, otherComponents);\n    }\n    \n    part vehicleSystem {\n        part vehicle: Vehicle;\n        \n        action calculateTotalMass {\n            out totalVehicleMass: Mass = vehicle.totalMass;\n        }\n        \n        action queryComponentMass {\n            in componentId: ComponentID;\n            out componentMass: Mass;\n        }\n    }\n}",
    "package 'VehicleQualityManagement' {\n    attribute def Mass;\n    attribute def SerialNumber;\n    attribute def VIN;\n    attribute def Threshold;\n    \n    part def Component {\n        attribute serialNumber: SerialNumber;\n        attribute mass: Mass;\n        part components: Component[0..*];\n        \n        calc totalMass: Mass {\n            mass + components.totalMass->sum()\n        }\n        \n        calc filteredTotalMass: Mass (threshold: Threshold) {\n            mass + components->select(c | c.mass >= threshold).totalMass->sum()\n        }\n    }\n    \n    part def Engine :> Component;\n    part def Transmission :> Component;\n    \n    part def Vehicle :> Component {\n        attribute vin: VIN;\n        part engine: Engine[0..1];\n        part transmission: Transmission[0..1];\n    }\n    \n    part vehicleQualitySystem {\n        part vehicle: Vehicle;\n        \n        attribute massThreshold: Threshold;\n        \n        calc vehicleTotalMass: Mass = vehicle.totalMass;\n        calc vehicleFilteredMass: Mass = vehicle.filteredTotalMass(massThreshold);\n    }\n}",
    "package 'MassAggregationSystem' {\n    attribute def Mass;\n    \n    attribute def SimpleMass :> Mass;\n    attribute def TotalMass :> Mass;\n    \n    abstract part def MassObject {\n        attribute simpleMass : SimpleMass;\n        attribute totalMass : TotalMass;\n    }\n    \n    part def SimpleThing :> MassObject {\n        assert constraint { totalMass == simpleMass }\n    }\n    \n    part def CompositeThing :> MassObject {\n        part subcomponents : MassObject[0..*];\n        \n        assert constraint {\n            totalMass == simpleMass + sum(subcomponents.totalMass)\n        }\n    }\n    \n    calc def sum(masses : TotalMass[0..*]) : TotalMass {\n        masses->reduce '+' ?? 0.0\n    }\n}",
    "package 'MassManagementSystem' {\n    attribute def Mass;\n    attribute def MinMassThreshold;\n    \n    port def MassQueryPort {\n        in minThreshold : MinMassThreshold;\n        out totalMass : Mass;\n    }\n    \n    port def SubcomponentMassPort {\n        out mass : Mass;\n    }\n    \n    part def MassObject {\n        attribute basicMass : Mass;\n        part subcomponents : MassObject[0..*];\n        \n        port massQueryPort : ~MassQueryPort;\n        port subcomponentMassPort : SubcomponentMassPort[0..*];\n        \n        perform calculateMass {\n            in minThreshold = massQueryPort.minThreshold;\n            out totalMass = massQueryPort.totalMass;\n            \n            action computeOwnMass {\n                out ownMass : Mass = basicMass;\n            }\n            \n            action aggregateSubcomponentMass {\n                in threshold : MinMassThreshold = minThreshold;\n                in subMasses : Mass[0..*];\n                out aggregatedMass : Mass;\n            }\n            \n            action sumTotalMass {\n                in ownMass : Mass;\n                in subcomponentTotal : Mass;\n                out total : Mass = ownMass + subcomponentTotal;\n            }\n            \n            flow from computeOwnMass.ownMass to sumTotalMass.ownMass;\n            flow from aggregateSubcomponentMass.aggregatedMass to sumTotalMass.subcomponentTotal;\n            flow from sumTotalMass.total to totalMass;\n        }\n        \n        interface subcomponentConnection : MassObject::subcomponents {\n            connect massQueryPort to subcomponents.massQueryPort;\n            connect subcomponents.subcomponentMassPort to subcomponentMassPort;\n        }\n    }\n    \n    part massManagementContext {\n        part rootObject : MassObject;\n        \n        perform massAggregation {\n            action setThreshold {\n                out threshold : MinMassThreshold;\n            }\n            \n            action queryTotalMass {\n                in threshold : MinMassThreshold;\n                out totalMass : Mass;\n            }\n            \n            flow from setThreshold.threshold to queryTotalMass.threshold;\n            bind queryTotalMass.threshold = rootObject.massQueryPort.minThreshold;\n            bind queryTotalMass.totalMass = rootObject.massQueryPort.totalMass;\n        }\n    }\n}",
    "package 'VehicleDynamics' {\n    attribute def Power;\n    attribute def Acceleration;\n    attribute def Speed;\n    attribute def Position;\n    attribute def Mass;\n    attribute def Time;\n    attribute def WheelPower;\n    attribute def AeroDragCoeff;\n    attribute def FrictionCoeff;\n    attribute def Displacement;\n    \n    port def VehicleInputPort {\n        in wheelPower: WheelPower;\n        in aeroDragCoeff: AeroDragCoeff;\n        in frictionCoeff: FrictionCoeff;\n        in mass: Mass;\n        in speed: Speed;\n        in time: Time;\n    }\n    \n    port def DynamicsOutputPort {\n        out power: Power;\n        out acceleration: Acceleration;\n        out speed: Speed;\n        out position: Position;\n    }\n    \n    part context {\n        part vehicleSystem {\n            port inputPort: VehicleInputPort;\n            port outputPort: DynamicsOutputPort;\n            \n            perform calculateDynamics.computePower {\n                in wheelPower = inputPort.wheelPower;\n                in aeroDragCoeff = inputPort.aeroDragCoeff;\n                in frictionCoeff = inputPort.frictionCoeff;\n                in mass = inputPort.mass;\n                in speed = inputPort.speed;\n                out power = outputPort.power;\n            }\n            \n            perform calculateDynamics.computeAcceleration {\n                in power = outputPort.power;\n                in mass = inputPort.mass;\n                in speed = inputPort.speed;\n                out acceleration = outputPort.acceleration;\n            }\n            \n            perform calculateDynamics.computeSpeed {\n                in acceleration = outputPort.acceleration;\n                in initialSpeed = inputPort.speed;\n                in time = inputPort.time;\n                out speed = outputPort.speed;\n            }\n            \n            perform calculateDynamics.computePosition {\n                in speed = outputPort.speed;\n                in time = inputPort.time;\n                out position = outputPort.position;\n            }\n        }\n    }\n    \n    action calculateDynamics {\n        action computePower {\n            in wheelPower: WheelPower;\n            in aeroDragCoeff: AeroDragCoeff;\n            in frictionCoeff: FrictionCoeff;\n            in mass: Mass;\n            in speed: Speed;\n            out power: Power;\n        }\n        \n        succession flow powerFlow from computePower.power to computeAcceleration.power;\n        \n        action computeAcceleration {\n            in power: Power;\n            in mass: Mass;\n            in speed: Speed;\n            out acceleration: Acceleration;\n        }\n        \n        succession flow accelerationFlow from computeAcceleration.acceleration to computeSpeed.acceleration;\n        \n        action computeSpeed {\n            in acceleration: Acceleration;\n            in initialSpeed: Speed;\n            in time: Time;\n            out speed: Speed;\n        }\n        \n        succession flow speedFlow from computeSpeed.speed to computePosition.speed;\n        \n        action computePosition {\n            in speed: Speed;\n            in time: Time;\n            out position: Position;\n        }\n    }\n}",
    "package 'VehicleDynamicsSimulation' {\n    attribute def Power;\n    attribute def Mass;\n    attribute def Speed;\n    attribute def Position;\n    attribute def Acceleration;\n    attribute def TimeStep;\n    attribute def DragCoefficient;\n    attribute def RollingResistanceCoefficient;\n    \n    port def VehicleParametersPort {\n        in wheelPower: Power;\n        in vehicleMass: Mass;\n        in dragCoeff: DragCoefficient;\n        in rollingCoeff: RollingResistanceCoefficient;\n    }\n    \n    port def SimulationParametersPort {\n        in initialSpeed: Speed;\n        in initialPosition: Position;\n        in timeStep: TimeStep;\n    }\n    \n    port def DynamicsOutputPort {\n        out acceleration: Acceleration;\n        out speed: Speed;\n        out position: Position;\n    }\n    \n    part context {\n        part user {\n            port vehicleParamsPort: VehicleParametersPort;\n            port simParamsPort: SimulationParametersPort;\n            \n            perform computeDynamics.provideVehicleParameters {\n                out wheelPower = vehicleParamsPort.wheelPower;\n                out vehicleMass = vehicleParamsPort.vehicleMass;\n                out dragCoeff = vehicleParamsPort.dragCoeff;\n                out rollingCoeff = vehicleParamsPort.rollingCoeff;\n            }\n            \n            perform computeDynamics.provideSimulationParameters {\n                out initialSpeed = simParamsPort.initialSpeed;\n                out initialPosition = simParamsPort.initialPosition;\n                out timeStep = simParamsPort.timeStep;\n            }\n        }\n        \n        interface userToSimulator connect user.vehicleParamsPort to simulator.vehicleParamsPort {\n            ref flow references computeDynamics.vehicleParamsFlow\n                from source.wheelPower to target.wheelPower;\n            ref flow references computeDynamics.vehicleParamsFlow\n                from source.vehicleMass to target.vehicleMass;\n            ref flow references computeDynamics.vehicleParamsFlow\n                from source.dragCoeff to target.dragCoeff;\n            ref flow references computeDynamics.vehicleParamsFlow\n                from source.rollingCoeff to target.rollingCoeff;\n        }\n        \n        interface userToSimulator2 connect user.simParamsPort to simulator.simParamsPort {\n            ref flow references computeDynamics.simParamsFlow\n                from source.initialSpeed to target.initialSpeed;\n            ref flow references computeDynamics.simParamsFlow\n                from source.initialPosition to target.initialPosition;\n            ref flow references computeDynamics.simParamsFlow\n                from source.timeStep to target.timeStep;\n        }\n        \n        part simulator {\n            port vehicleParamsPort: ~VehicleParametersPort;\n            port simParamsPort: ~SimulationParametersPort;\n            port dynamicsOutputPort: DynamicsOutputPort;\n            \n            perform computeDynamics.calculateAvailablePower {\n                in wheelPower = vehicleParamsPort.wheelPower;\n                in dragCoeff = vehicleParamsPort.dragCoeff;\n                in rollingCoeff = vehicleParamsPort.rollingCoeff;\n                in currentSpeed = simParamsPort.initialSpeed;\n                out availablePower: Power;\n            }\n            \n            perform computeDynamics.calculateAcceleration {\n                in availablePower;\n                in vehicleMass = vehicleParamsPort.vehicleMass;\n                out acceleration = dynamicsOutputPort.acceleration;\n            }\n            \n            perform computeDynamics.updateSpeedAndPosition {\n                in acceleration;\n                in initialSpeed = simParamsPort.initialSpeed;\n                in initialPosition = simParamsPort.initialPosition;\n                in timeStep = simParamsPort.timeStep;\n                out speed = dynamicsOutputPort.speed;\n                out position = dynamicsOutputPort.position;\n            }\n        }\n    }\n    \n    action computeDynamics {\n        action provideVehicleParameters {\n            out wheelPower: Power;\n            out vehicleMass: Mass;\n            out dragCoeff: DragCoefficient;\n            out rollingCoeff: RollingResistanceCoefficient;\n        }\n        \n        action provideSimulationParameters {\n            out initialSpeed: Speed;\n            out initialPosition: Position;\n            out timeStep: TimeStep;\n        }\n        \n        succession flow vehicleParamsFlow from provideVehicleParameters to calculateAvailablePower;\n        succession flow simParamsFlow from provideSimulationParameters to calculateAvailablePower;\n        \n        action calculateAvailablePower {\n            in wheelPower: Power;\n            in dragCoeff: DragCoefficient;\n            in rollingCoeff: RollingResistanceCoefficient;\n            in currentSpeed: Speed;\n            out availablePower: Power;\n        }\n        \n        succession flow powerFlow from calculateAvailablePower.availablePower to calculateAcceleration.availablePower;\n        \n        action calculateAcceleration {\n            in availablePower: Power;\n            in vehicleMass: Mass;\n            out acceleration: Acceleration;\n        }\n        \n        succession flow accelerationFlow from calculateAcceleration.acceleration to updateSpeedAndPosition.acceleration;\n        \n        action updateSpeedAndPosition {\n            in acceleration: Acceleration;\n            in initialSpeed: Speed;\n            in initialPosition: Position;\n            in timeStep: TimeStep;\n            out speed: Speed;\n            out position: Position;\n        }\n    }\n}",
    "package 'VehicleDynamicsSystem' {\n    attribute def Mass;\n    attribute def Power;\n    attribute def DragCoefficient;\n    attribute def RollingResistanceCoefficient;\n    attribute def Speed;\n    attribute def Position;\n    attribute def Time;\n    attribute def Acceleration;\n    attribute def Displacement;\n    \n    port def VehicleParametersPort {\n        in mass: Mass;\n        in wheelPower: Power;\n        in dragCoeff: DragCoefficient;\n        in rollingResistCoeff: RollingResistanceCoefficient;\n        in initialSpeed: Speed;\n        in initialPosition: Position;\n    }\n    \n    port def DynamicsOutputPort {\n        out currentSpeed: Speed;\n        out currentPosition: Position;\n        out currentAcceleration: Acceleration;\n        out currentDisplacement: Displacement;\n    }\n    \n    port def TimeStepPort {\n        in timeStep: Time;\n    }\n    \n    part context {\n        part user {\n            port vehicleParametersPort: VehicleParametersPort;\n            port timeStepPort: TimeStepPort;\n            perform computeDynamics.provideParameters {\n                out mass = vehicleParametersPort.mass;\n                out wheelPower = vehicleParametersPort.wheelPower;\n                out dragCoeff = vehicleParametersPort.dragCoeff;\n                out rollingResistCoeff = vehicleParametersPort.rollingResistCoeff;\n                out initialSpeed = vehicleParametersPort.initialSpeed;\n                out initialPosition = vehicleParametersPort.initialPosition;\n                out timeStep = timeStepPort.timeStep;\n            }\n        }\n        \n        interface userToDynamicsComputer connect user.vehicleParametersPort to dynamicsComputer.vehicleParametersPort {\n            ref flow references computeDynamics.parametersFlow\n                from source.mass to target.mass;\n            ref flow references computeDynamics.parametersFlow\n                from source.wheelPower to target.wheelPower;\n            ref flow references computeDynamics.parametersFlow\n                from source.dragCoeff to target.dragCoeff;\n            ref flow references computeDynamics.parametersFlow\n                from source.rollingResistCoeff to target.rollingResistCoeff;\n            ref flow references computeDynamics.parametersFlow\n                from source.initialSpeed to target.initialSpeed;\n            ref flow references computeDynamics.parametersFlow\n                from source.initialPosition to target.initialPosition;\n        }\n        \n        interface userTimeToComputer connect user.timeStepPort to dynamicsComputer.timeStepPort {\n            ref flow references computeDynamics.timeFlow\n                from source.timeStep to target.timeStep;\n        }\n        \n        part dynamicsComputer {\n            port vehicleParametersPort: ~VehicleParametersPort;\n            port timeStepPort: ~TimeStepPort;\n            port dynamicsOutputPort: DynamicsOutputPort;\n            \n            perform computeDynamics.calculateDynamics {\n                in mass = vehicleParametersPort.mass;\n                in wheelPower = vehicleParametersPort.wheelPower;\n                in dragCoeff = vehicleParametersPort.dragCoeff;\n                in rollingResistCoeff = vehicleParametersPort.rollingResistCoeff;\n                in initialSpeed = vehicleParametersPort.initialSpeed;\n                in initialPosition = vehicleParametersPort.initialPosition;\n                in timeStep = timeStepPort.timeStep;\n                out currentSpeed = dynamicsOutputPort.currentSpeed;\n                out currentPosition = dynamicsOutputPort.currentPosition;\n                out currentAcceleration = dynamicsOutputPort.currentAcceleration;\n                out currentDisplacement = dynamicsOutputPort.currentDisplacement;\n            }\n        }\n    }\n    \n    action computeDynamics {\n        action provideParameters {\n            out mass: Mass;\n            out wheelPower: Power;\n            out dragCoeff: DragCoefficient;\n            out rollingResistCoeff: RollingResistanceCoefficient;\n            out initialSpeed: Speed;\n            out initialPosition: Position;\n            out timeStep: Time;\n        }\n        \n        succession flow parametersFlow from provideParameters to calculateDynamics;\n        succession flow timeFlow from provideParameters.timeStep to calculateDynamics.timeStep;\n        \n        action calculateDynamics {\n            in mass: Mass;\n            in wheelPower: Power;\n            in dragCoeff: DragCoefficient;\n            in rollingResistCoeff: RollingResistanceCoefficient;\n            in initialSpeed: Speed;\n            in initialPosition: Position;\n            in timeStep: Time;\n            out currentSpeed: Speed;\n            out currentPosition: Position;\n            out currentAcceleration: Acceleration;\n            out currentDisplacement: Displacement;\n        }\n    }\n}",
    "package 'VehicleLongitudinalDynamics' {\n    attribute def Position;\n    attribute def Velocity;\n    attribute def Mass;\n    attribute def Power;\n    attribute def TimeInterval;\n    attribute def DragCoefficient;\n    attribute def FrictionCoefficient;\n    attribute def Acceleration;\n    \n    port def VehicleInputPort {\n        in initialPosition: Position;\n        in initialVelocity: Velocity;\n        in vehicleMass: Mass;\n        in drivePower: Power;\n        in timeInterval: TimeInterval;\n    }\n    \n    port def EnvironmentParameterPort {\n        in dragCoefficient: DragCoefficient;\n        in frictionCoefficient: FrictionCoefficient;\n    }\n    \n    port def VehicleOutputPort {\n        out acceleration: Acceleration;\n        out finalVelocity: Velocity;\n        out finalPosition: Position;\n    }\n    \n    part context {\n        part user {\n            port vehicleInputPort: VehicleInputPort;\n            perform calculateDynamics.provideInputs {\n                out initialPosition = vehicleInputPort.initialPosition;\n                out initialVelocity = vehicleInputPort.initialVelocity;\n                out vehicleMass = vehicleInputPort.vehicleMass;\n                out drivePower = vehicleInputPort.drivePower;\n                out timeInterval = vehicleInputPort.timeInterval;\n            }\n        }\n        \n        interface userToSystem connect user.vehicleInputPort to dynamicsSystem.vehicleInputPort {\n            ref flow references calculateDynamics.inputFlow\n                from source.initialPosition to target.initialPosition;\n            ref flow references calculateDynamics.inputFlow\n                from source.initialVelocity to target.initialVelocity;\n            ref flow references calculateDynamics.inputFlow\n                from source.vehicleMass to target.vehicleMass;\n            ref flow references calculateDynamics.inputFlow\n                from source.drivePower to target.drivePower;\n            ref flow references calculateDynamics.inputFlow\n                from source.timeInterval to target.timeInterval;\n        }\n        \n        part dynamicsSystem {\n            port vehicleInputPort: ~VehicleInputPort;\n            port environmentPort: ~EnvironmentParameterPort;\n            port vehicleOutputPort: VehicleOutputPort;\n            \n            perform calculateDynamics.computeDynamics {\n                in initialPosition = vehicleInputPort.initialPosition;\n                in initialVelocity = vehicleInputPort.initialVelocity;\n                in vehicleMass = vehicleInputPort.vehicleMass;\n                in drivePower = vehicleInputPort.drivePower;\n                in timeInterval = vehicleInputPort.timeInterval;\n                in dragCoefficient = environmentPort.dragCoefficient;\n                in frictionCoefficient = environmentPort.frictionCoefficient;\n                out acceleration = vehicleOutputPort.acceleration;\n                out finalVelocity = vehicleOutputPort.finalVelocity;\n                out finalPosition = vehicleOutputPort.finalPosition;\n            }\n        }\n        \n        part environment {\n            port environmentPort: EnvironmentParameterPort;\n            perform calculateDynamics.provideEnvironmentParameters {\n                out dragCoefficient = environmentPort.dragCoefficient;\n                out frictionCoefficient = environmentPort.frictionCoefficient;\n            }\n        }\n        \n        interface environmentToSystem connect environment.environmentPort to dynamicsSystem.environmentPort {\n            ref flow references calculateDynamics.environmentFlow\n                from source.dragCoefficient to target.dragCoefficient;\n            ref flow references calculateDynamics.environmentFlow\n                from source.frictionCoefficient to target.frictionCoefficient;\n        }\n    }\n    \n    action calculateDynamics {\n        action provideInputs {\n            out initialPosition: Position;\n            out initialVelocity: Velocity;\n            out vehicleMass: Mass;\n            out drivePower: Power;\n            out timeInterval: TimeInterval;\n        }\n        \n        action provideEnvironmentParameters {\n            out dragCoefficient: DragCoefficient;\n            out frictionCoefficient: FrictionCoefficient;\n        }\n        \n        succession flow inputFlow from provideInputs to computeDynamics;\n        succession flow environmentFlow from provideEnvironmentParameters to computeDynamics;\n        \n        action computeDynamics {\n            in initialPosition: Position;\n            in initialVelocity: Velocity;\n            in vehicleMass: Mass;\n            in drivePower: Power;\n            in timeInterval: TimeInterval;\n            in dragCoefficient: DragCoefficient;\n            in frictionCoefficient: FrictionCoefficient;\n            out acceleration: Acceleration;\n            out finalVelocity: Velocity;\n            out finalPosition: Position;\n        }\n    }\n}",
    "package 'VehicleMassManagement' {\n\tattribute def Mass :> ISQ::mass;\n\tattribute def OverweightWarning;\n\t\n\tport def MassPort {\n\t\tin mass : Mass;\n\t}\n\t\n\tport def WarningPort {\n\t\tout warning : OverweightWarning;\n\t}\n\t\n\tpart def Vehicle {\n\t\tattribute totalMass : Mass;\n\t\tattribute maxPermittedMass : Mass = 2500 [kg];\n\t\t\n\t\tpart chassis {\n\t\t\tattribute mass : Mass;\n\t\t\tport massPort : MassPort {\n\t\t\t\tout mass = chassis::mass;\n\t\t\t}\n\t\t}\n\t\t\n\t\tpart engine {\n\t\t\tattribute mass : Mass;\n\t\t\tport massPort : MassPort {\n\t\t\t\tout mass = engine::mass;\n\t\t\t}\n\t\t}\n\t\t\n\t\tpart gearbox {\n\t\t\tattribute mass : Mass;\n\t\t\tport massPort : MassPort {\n\t\t\t\tout mass = gearbox::mass;\n\t\t\t}\n\t\t}\n\t\t\n\t\tpart massController {\n\t\t\tport chassisMassPort : ~MassPort;\n\t\t\tport engineMassPort : ~MassPort;\n\t\t\tport gearboxMassPort : ~MassPort;\n\t\t\tport warningPort : WarningPort;\n\t\t\t\n\t\t\tperform checkMass {\n\t\t\t\tin chassisMass = chassisMassPort.mass;\n\t\t\t\tin engineMass = engineMassPort.mass;\n\t\t\t\tin gearboxMass = gearboxMassPort.mass;\n\t\t\t\tattribute calculatedTotalMass : Mass = chassisMass + engineMass + gearboxMass;\n\t\t\t\tout warning = warningPort.warning {\n\t\t\t\t\tdoc /* Issue warning if total mass exceeds limit */\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t\n\t\tinterface chassisToController connect chassis.massPort to massController.chassisMassPort;\n\t\tinterface engineToController connect engine.massPort to massController.engineMassPort;\n\t\tinterface gearboxToController connect gearbox.massPort to massController.gearboxMassPort;\n\t\t\n\t\tconstraint massLimit {\n\t\t\tdoc /* Total mass must not exceed maximum permitted mass */\n\t\t\ttotalMass <= maxPermittedMass\n\t\t}\n\t}\n}",
    "package 'VehicleMassBudget' {\n\timport ISQ::*;\n\timport SI::*;\n\t\n\tattribute def MassValue :> ISQ::mass {\n\t\tattribute unit : MassUnit default kg;\n\t}\n\t\n\tconstraint def MassConstraint {\n\t\tin totalMass : MassValue;\n\t\tin massLimit : MassValue;\n\t\tconstraint { totalMass <= massLimit }\n\t}\n\t\n\tpart def Vehicle {\n\t\tattribute totalMass : MassValue;\n\t\tattribute massLimit : MassValue = 2500 [kg];\n\t\t\n\t\tpart chassis {\n\t\t\tattribute mass : MassValue;\n\t\t}\n\t\t\n\t\tpart engine {\n\t\t\tattribute mass : MassValue;\n\t\t}\n\t\t\n\t\tpart transmission {\n\t\t\tattribute mass : MassValue;\n\t\t}\n\t\t\n\t\tconstraint massCalculation : MassConstraint {\n\t\t\tin totalMass = chassis.mass + engine.mass + transmission.mass;\n\t\t\tin massLimit = massLimit;\n\t\t}\n\t\t\n\t\tassert constraint { totalMass == chassis.mass + engine.mass + transmission.mass }\n\t}\n\t\n\tpart vehicleInstance : Vehicle {\n\t\tdoc /* This instance represents a specific vehicle configuration\n\t\t     * where component masses are tracked and constrained */\n\t}\n}",
    "package 'VehicleMassManagement' {\n    attribute def MassValue :> ISQ::mass;\n    attribute def ComplianceStatus;\n    \n    port def MassDataPort {\n        in massValue : MassValue;\n    }\n    \n    port def CompliancePort {\n        out status : ComplianceStatus;\n    }\n    \n    part def Vehicle {\n        attribute totalMass : MassValue;\n        attribute massLimit : MassValue = 2500 [kg];\n        \n        part chassis {\n            attribute mass : MassValue;\n            port massPort : MassDataPort;\n        }\n        \n        part engine {\n            attribute mass : MassValue;\n            port massPort : MassDataPort;\n        }\n        \n        part transmission {\n            attribute mass : MassValue;\n            port massPort : MassDataPort;\n        }\n        \n        port compliancePort : CompliancePort;\n        \n        calc totalMass : MassValue = chassis.mass + engine.mass + transmission.mass;\n        \n        constraint massCompliance {\n            totalMass <= massLimit\n        }\n    }\n    \n    part vehicleMassSystem {\n        part vehicle : Vehicle;\n        \n        perform verifyMassCompliance {\n            in chassisMass = vehicle.chassis.massPort.massValue;\n            in engineMass = vehicle.engine.massPort.massValue;\n            in transmissionMass = vehicle.transmission.massPort.massValue;\n            \n            calc totalVehicleMass : MassValue = chassisMass + engineMass + transmissionMass;\n            calc isCompliant : ComplianceStatus = (totalVehicleMass <= 2500 [kg]);\n            \n            out complianceStatus = vehicle.compliancePort.status = isCompliant;\n        }\n    }\n}",
    "package 'VehicleWeightManagement' {\n\tattribute def Weight;\n\tattribute def WeightLimit;\n\tattribute def Warning;\n\t\n\tport def WeightDataPort {\n\t\tin weight : Weight;\n\t}\n\t\n\tport def WarningPort {\n\t\tout warning : Warning;\n\t}\n\t\n\tpart context {\n\t\tpart chassis {\n\t\t\tattribute weight : Weight;\n\t\t\tport weightPort : WeightDataPort {\n\t\t\t\tout weight = chassis.weight;\n\t\t\t}\n\t\t}\n\t\t\n\t\tpart engine {\n\t\t\tattribute weight : Weight;\n\t\t\tport weightPort : WeightDataPort {\n\t\t\t\tout weight = engine.weight;\n\t\t\t}\n\t\t}\n\t\t\n\t\tpart transmission {\n\t\t\tattribute weight : Weight;\n\t\t\tport weightPort : WeightDataPort {\n\t\t\t\tout weight = transmission.weight;\n\t\t\t}\n\t\t}\n\t\t\n\t\tpart weightManagementSystem {\n\t\t\tattribute weightLimit : WeightLimit = 2500;\n\t\t\t\n\t\t\tport chassisWeightPort : ~WeightDataPort;\n\t\t\tport engineWeightPort : ~WeightDataPort;\n\t\t\tport transmissionWeightPort : ~WeightDataPort;\n\t\t\tport warningPort : WarningPort;\n\t\t\t\n\t\t\tperform checkWeight.calculateTotalWeight {\n\t\t\t\tin chassisWeight = chassisWeightPort.weight;\n\t\t\t\tin engineWeight = engineWeightPort.weight;\n\t\t\t\tin transmissionWeight = transmissionWeightPort.weight;\n\t\t\t\tout totalWeight;\n\t\t\t}\n\t\t\t\n\t\t\tperform checkWeight.validateWeight {\n\t\t\t\tin totalWeight;\n\t\t\t\tin weightLimit;\n\t\t\t\tout warning = warningPort.warning;\n\t\t\t}\n\t\t}\n\t\t\n\t\tinterface chassisToSystem connect chassis.weightPort to weightManagementSystem.chassisWeightPort;\n\t\tinterface engineToSystem connect engine.weightPort to weightManagementSystem.engineWeightPort;\n\t\tinterface transmissionToSystem connect transmission.weightPort to weightManagementSystem.transmissionWeightPort;\n\t}\n\t\n\taction checkWeight {\n\t\taction calculateTotalWeight {\n\t\t\tin chassisWeight : Weight;\n\t\t\tin engineWeight : Weight;\n\t\t\tin transmissionWeight : Weight;\n\t\t\tout totalWeight : Weight;\n\t\t}\n\t\t\n\t\tsuccession flow totalWeightFlow from calculateTotalWeight.totalWeight to validateWeight.totalWeight;\n\t\t\n\t\taction validateWeight {\n\t\t\tin totalWeight : Weight;\n\t\t\tin weightLimit : WeightLimit;\n\t\t\tout warning : Warning;\n\t\t}\n\t}\n}",
    "package 'Vehicle System' {\n    import ISQ::*;\n    import SI::*;\n    \n    attribute def MassValue :> ISQ::mass;\n    attribute def ForceValue :> ISQ::force;\n    attribute def VelocityValue :> ISQ::speed;\n    attribute def TimeValue :> ISQ::time;\n    \n    part def Chassis {\n        attribute mass : MassValue;\n    }\n    \n    part def Engine {\n        attribute mass : MassValue;\n    }\n    \n    part def Transmission {\n        attribute mass : MassValue;\n    }\n    \n    part def Vehicle {\n        part chassis : Chassis;\n        part engine : Engine;\n        part transmission : Transmission;\n        \n        attribute totalMass : MassValue = chassis.mass + engine.mass + transmission.mass;\n        \n        constraint totalMassConstraint {\n            totalMass <= 2500[kg]\n        }\n        \n        attribute initialVelocity : VelocityValue;\n        attribute finalVelocity : VelocityValue;\n        attribute appliedForce : ForceValue;\n        attribute timeDuration : TimeValue;\n        \n        constraint massPositive {\n            totalMass > 0[kg]\n        }\n        \n        constraint dynamicConstraint {\n            (finalVelocity - initialVelocity) == (appliedForce * timeDuration) / totalMass\n        }\n    }\n}",
    "package 'VehicleMaintenanceSystem' {\n    import ScalarValues::*;\n    \n    attribute def VehicleID;\n    attribute def Temperature;\n    attribute def MaintenanceStatus;\n    attribute def HealthStatus;\n    \n    attribute nextMaintenanceTime : Real;\n    attribute maintenanceInterval : Real;\n    attribute maxAllowedTemperature : Temperature;\n    attribute currentTime : Real;\n    attribute actualMaintenanceStartTime : Real;\n    attribute maintenanceDuration : Real;\n    \n    part def Vehicle {\n        attribute vehicleID : VehicleID;\n        attribute nextMaintenance : Real;\n        attribute interval : Real;\n        attribute maxTemp : Temperature;\n        attribute status : MaintenanceStatus;\n        attribute health : HealthStatus;\n        \n        state healthyState;\n        state underMaintenanceState;\n        \n        transition healthyToMaintenance\n            first healthyState\n            then underMaintenanceState\n            when currentTime >= nextMaintenance;\n            \n        transition maintenanceToHealthy\n            first underMaintenanceState\n            then healthyState\n            when maintenanceDuration <= 48 * 3600;\n    }\n    \n    part def MaintenanceScheduler {\n        perform action scheduleNextMaintenance {\n            in vehicle : Vehicle;\n            in interval : Real;\n            out nextTime : Real = currentTime + interval;\n        }\n        \n        perform action checkMaintenanceTime {\n            in vehicle : Vehicle;\n            in currentTime : Real;\n            out needsMaintenance : Boolean = currentTime >= vehicle.nextMaintenance;\n        }\n    }\n    \n    part vehicleMaintenanceSystem {\n        part vehicle : Vehicle;\n        part scheduler : MaintenanceScheduler;\n        \n        constraint maintenanceStartConstraint {\n            actualMaintenanceStartTime > vehicle.nextMaintenance\n        }\n        \n        constraint maintenanceInitiationConstraint {\n            actualMaintenanceStartTime <= currentTime + 2\n        }\n        \n        constraint maintenanceDurationConstraint {\n            maintenanceDuration <= 48 * 3600\n        }\n        \n        action performMaintenance {\n            first start;\n            then done;\n            \n            bind actualMaintenanceStartTime = start::startTime;\n            bind maintenanceDuration = done::endTime - start::startTime;\n            \n            action updateNextMaintenance {\n                vehicle.nextMaintenance := vehicle.nextMaintenance + vehicle.interval;\n                vehicle.health := \"normal\";\n                vehicle.status := \"operational\";\n            }\n        }\n    }\n}",
    "package 'Vehicle' {\n\tattribute def Mass;\n\tattribute def Speed;\n\tattribute def Torque;\n\t\n\tport def TorquePort {\n\t\tout torque: Torque;\n\t}\n\t\n\tpart def Vehicle {\n\t\tattribute curbWeight: Mass;\n\t\tattribute fuelMass: Mass;\n\t\tattribute totalMass: Mass;\n\t\tattribute maxMassLimit: Mass;\n\t\t\n\t\tconstraint { totalMass == curbWeight + fuelMass }\n\t\tconstraint { totalMass <= maxMassLimit }\n\t\tconstraint { fuelMass > 0 }\n\t\t\n\t\tpart engine: Engine;\n\t\tpart clutch: Clutch;\n\t\tpart transmission: Transmission;\n\t\t\n\t\tinterface engineToClutch connect engine.torquePort to clutch.torqueInPort;\n\t\tinterface clutchToTransmission connect clutch.torqueOutPort to transmission.torquePort;\n\t}\n\t\n\tpart def Engine {\n\t\tattribute speed: Speed;\n\t\tport torquePort: TorquePort;\n\t\t\n\t\tperform generateTorque {\n\t\t\tin speed;\n\t\t\tout torque = torquePort.torque;\n\t\t}\n\t}\n\t\n\tpart def Clutch {\n\t\tport torqueInPort: ~TorquePort;\n\t\tport torqueOutPort: TorquePort;\n\t\t\n\t\tperform transmitTorque {\n\t\t\tin torque = torqueInPort.torque;\n\t\t\tout torque = torqueOutPort.torque;\n\t\t}\n\t}\n\t\n\tpart def Transmission {\n\t\tport torquePort: ~TorquePort;\n\t\t\n\t\tperform receiveTorque {\n\t\t\tin torque = torquePort.torque;\n\t\t}\n\t}\n}",
    "package 'Vehicle System' {\n\tattribute def Mass :> ISQ::mass;\n\tattribute def Torque :> ISQ::torque;\n\tattribute def Speed :> ISQ::angularVelocity;\n\t\n\tport def TorquePort {\n\t\tout torque: Torque;\n\t}\n\t\n\tpart def Vehicle {\n\t\tattribute dryMass: Mass;\n\t\tattribute fuelMass: Mass;\n\t\tattribute totalMass: Mass = dryMass + fuelMass;\n\t\t\n\t\tconstraint emptyTankMassLimit {\n\t\t\tdoc /* With empty fuel tank, total mass must not exceed 1500 kg */\n\t\t\ttotalMass <= 1500 [kg] when fuelMass == 0 [kg]\n\t\t}\n\t\t\n\t\tconstraint fullTankMassLimit {\n\t\t\tdoc /* With full fuel tank, total mass must not exceed 2000 kg */\n\t\t\ttotalMass <= 2000 [kg] when fuelMass == fuelTank.capacity\n\t\t}\n\t\t\n\t\tpart engine: Engine;\n\t\tpart transmission: Transmission;\n\t\tpart clutch: Clutch;\n\t\tpart fuelTank: FuelTank;\n\t\t\n\t\tinterface engineToClutch connect engine.torqueOut to clutch.torqueIn;\n\t\tinterface clutchToTransmission connect clutch.torqueOut to transmission.torqueIn;\n\t}\n\t\n\tpart def Engine {\n\t\tattribute speed: Speed;\n\t\tattribute outputTorque: Torque;\n\t\tport torqueOut: TorquePort;\n\t\t\n\t\tconstraint torqueSpeedCurve {\n\t\t\tdoc /* Engine must deliver torque according to speed-torque curve (Table 1) */\n\t\t\t// Constraint based on Table 1 data\n\t\t}\n\t\t\n\t\tperform generateTorque {\n\t\t\tout torque = torqueOut.torque;\n\t\t}\n\t}\n\t\n\tpart def Clutch {\n\t\tport torqueIn: ~TorquePort;\n\t\tport torqueOut: TorquePort;\n\t\t\n\t\tperform transmitTorque {\n\t\t\tin inputTorque = torqueIn.torque;\n\t\t\tout outputTorque = torqueOut.torque;\n\t\t}\n\t}\n\t\n\tpart def Transmission {\n\t\tport torqueIn: ~TorquePort;\n\t\t\n\t\tperform receiveTorque {\n\t\t\tin torque = torqueIn.torque;\n\t\t}\n\t}\n\t\n\tpart def FuelTank {\n\t\tattribute capacity: Mass;\n\t\tattribute currentFuel: Mass;\n\t\t\n\t\tconstraint fuelLimit {\n\t\t\t0 [kg] <= currentFuel <= capacity\n\t\t}\n\t}\n}",
    "package 'Vehicle System' {\n    attribute def Mass :> ISQ::mass;\n    attribute def Torque :> ISQ::torque;\n    attribute def Speed :> ISQ::speed;\n    \n    port def TorquePort {\n        out torque: Torque;\n    }\n    \n    port def SpeedPort {\n        in speed: Speed;\n    }\n    \n    requirement def MassRequirement {\n        doc /* The vehicle mass must not exceed specified limits */\n        attribute emptyMass: Mass;\n        attribute fueledMass: Mass;\n        require constraint { emptyMass <= 1500[kg] }\n        require constraint { fueledMass <= 2000[kg] }\n    }\n    \n    requirement def TorqueTransmissionRequirement {\n        doc /* Engine must effectively transmit torque through clutch interface */\n    }\n    \n    requirement def TorqueSpeedRequirement {\n        doc /* Engine torque must vary with speed per performance table */\n    }\n    \n    part vehicle {\n        attribute emptyMass: Mass;\n        attribute fueledMass: Mass;\n        \n        satisfy massReq: MassRequirement by vehicle {\n            attribute redefines emptyMass = vehicle.emptyMass;\n            attribute redefines fueledMass = vehicle.fueledMass;\n        }\n        \n        part engine {\n            port torquePort: TorquePort;\n            port speedPort: SpeedPort;\n            \n            perform generateTorque {\n                in speed = speedPort.speed;\n                out torque = torquePort.torque;\n            }\n            \n            satisfy torqueSpeedReq: TorqueSpeedRequirement by engine;\n        }\n        \n        part transmission {\n            port torquePort: ~TorquePort;\n        }\n        \n        interface clutchInterface connect engine.torquePort to transmission.torquePort {\n            satisfy torqueTransReq: TorqueTransmissionRequirement by clutchInterface;\n        }\n    }\n}",
    "package 'VehicleSystem' {\n    attribute def Mass;\n    attribute def Torque;\n    attribute def Speed;\n    \n    port def TorquePort {\n        out torque: Torque;\n    }\n    \n    port def SpeedPort {\n        in speed: Speed;\n    }\n    \n    part vehicle {\n        attribute curbMass: Mass;\n        attribute fuelMass: Mass;\n        attribute totalMass: Mass = curbMass + fuelMass;\n        \n        constraint massLimitFull {\n            doc /* When fuel tank is full, total mass must not exceed 2000 kg */\n            totalMass <= 2000 [kg]\n        }\n        \n        constraint massLimitEmpty {\n            doc /* When fuel tank is empty, total mass must not exceed 1500 kg */\n            curbMass <= 1500 [kg]\n        }\n        \n        part engine {\n            port speedPort: SpeedPort;\n            port torquePort: TorquePort;\n            \n            perform powerTransmission.generateTorque {\n                in speed = speedPort.speed;\n                out torque = torquePort.torque;\n            }\n        }\n        \n        part clutch {\n            port torqueInPort: ~TorquePort;\n            port torqueOutPort: TorquePort;\n            \n            perform powerTransmission.transmitTorque {\n                in torqueIn = torqueInPort.torque;\n                out torqueOut = torqueOutPort.torque;\n            }\n        }\n        \n        part gearbox {\n            port torquePort: ~TorquePort;\n            \n            perform powerTransmission.receiveTorque {\n                in torque = torquePort.torque;\n            }\n        }\n        \n        interface engineToClutch connect engine.torquePort to clutch.torqueInPort {\n            ref flow references powerTransmission.engineTorqueFlow\n                from source.torque to target.torque;\n        }\n        \n        interface clutchToGearbox connect clutch.torqueOutPort to gearbox.torquePort {\n            ref flow references powerTransmission.clutchTorqueFlow\n                from source.torque to target.torque;\n        }\n    }\n    \n    action powerTransmission {\n        action generateTorque { in speed: Speed; out torque: Torque; }\n        succession flow engineTorqueFlow from generateTorque.torque to transmitTorque.torqueIn;\n        action transmitTorque { in torqueIn: Torque; out torqueOut: Torque; }\n        succession flow clutchTorqueFlow from transmitTorque.torqueOut to receiveTorque.torque;\n        action receiveTorque { in torque: Torque; }\n    }\n}",
    "package 'VehicleDynamicPerformanceAnalysis' {\n    attribute def Mass;\n    attribute def Length;\n    attribute def Efficiency;\n    attribute def FuelEconomy;\n    attribute def Time;\n    attribute def Position;\n    attribute def Speed;\n    attribute def Acceleration;\n    attribute def Power;\n    attribute def FuelConsumption;\n    attribute def ComplianceStatus;\n    \n    attribute def VehicleConfiguration {\n        attribute curbWeight: Mass;\n        attribute payload: Mass;\n        attribute wheelDiameter: Length;\n        attribute transmissionEfficiency: Efficiency;\n        attribute urbanFuelEconomy: FuelEconomy;\n        attribute highwayFuelEconomy: FuelEconomy;\n    }\n    \n    attribute def DriveCycle {\n        attribute timePoints: Time[*];\n        attribute positions: Position[*];\n        attribute speeds: Speed[*];\n    }\n    \n    attribute def EnergyTarget {\n        attribute targetFuelEconomy: FuelEconomy;\n    }\n    \n    attribute def PerformanceResults {\n        attribute power: Power[*];\n        attribute acceleration: Acceleration[*];\n        attribute speed: Speed[*];\n        attribute position: Position[*];\n        attribute overallFuelEconomy: FuelEconomy;\n        attribute meetsTarget: ComplianceStatus;\n    }\n    \n    port def ConfigurationPort {\n        in vehicleConfig: VehicleConfiguration;\n        in driveCycle: DriveCycle;\n        in energyTarget: EnergyTarget;\n    }\n    \n    port def ResultsPort {\n        out performanceResults: PerformanceResults;\n    }\n    \n    part context {\n        part user {\n            port configPort: ConfigurationPort;\n            perform analyzePerformance.configureAnalysis {\n                out vehicleConfig = configPort.vehicleConfig;\n                out driveCycle = configPort.driveCycle;\n                out energyTarget = configPort.energyTarget;\n            }\n        }\n        \n        interface userToAnalysisSystem connect user.configPort to analysisSystem.configPort {\n            ref flow references analyzePerformance.configFlow\n                from source.vehicleConfig to target.vehicleConfig;\n            ref flow references analyzePerformance.cycleFlow\n                from source.driveCycle to target.driveCycle;\n            ref flow references analyzePerformance.targetFlow\n                from source.energyTarget to target.energyTarget;\n        }\n        \n        part analysisSystem {\n            port configPort: ~ConfigurationPort;\n            port resultsPort: ResultsPort;\n            \n            perform analyzePerformance.calculateDynamics {\n                in vehicleConfig = configPort.vehicleConfig;\n                in driveCycle = configPort.driveCycle;\n                out power: Power[*];\n                out acceleration: Acceleration[*];\n            }\n            \n            perform analyzePerformance.calculateFuelEconomy {\n                in vehicleConfig = configPort.vehicleConfig;\n                in driveCycle = configPort.driveCycle;\n                in power: Power[*];\n                out fuelEconomy: FuelEconomy;\n            }\n            \n            perform analyzePerformance.verifyCompliance {\n                in fuelEconomy: FuelEconomy;\n                in energyTarget = configPort.energyTarget;\n                out results = resultsPort.performanceResults;\n            }\n        }\n    }\n    \n    action analyzePerformance {\n        action configureAnalysis {\n            out vehicleConfig: VehicleConfiguration;\n            out driveCycle: DriveCycle;\n            out energyTarget: EnergyTarget;\n        }\n        \n        succession flow configFlow from configureAnalysis.vehicleConfig to calculateDynamics.vehicleConfig;\n        succession flow cycleFlow from configureAnalysis.driveCycle to calculateDynamics.driveCycle;\n        succession flow targetFlow from configureAnalysis.energyTarget to verifyCompliance.energyTarget;\n        \n        action calculateDynamics {\n            in vehicleConfig: VehicleConfiguration;\n            in driveCycle: DriveCycle;\n            out power: Power[*];\n            out acceleration: Acceleration[*];\n        }\n        \n        succession flow powerFlow from calculateDynamics.power to calculateFuelEconomy.power;\n        \n        action calculateFuelEconomy {\n            in vehicleConfig: VehicleConfiguration;\n            in driveCycle: DriveCycle;\n            in power: Power[*];\n            out fuelEconomy: FuelEconomy;\n        }\n        \n        succession flow economyFlow from calculateFuelEconomy.fuelEconomy to verifyCompliance.fuelEconomy;\n        \n        action verifyCompliance {\n            in fuelEconomy: FuelEconomy;\n            in energyTarget: EnergyTarget;\n            out results: PerformanceResults;\n        }\n    }\n}",
    "package 'VehicleFuelEconomySimulation' {\n    attribute def Speed;\n    attribute def Distance;\n    attribute def Time;\n    attribute def Power;\n    attribute def FuelConsumption;\n    attribute def FuelEconomy;\n    attribute def Mass;\n    attribute def WheelDiameter;\n    attribute def TransmissionEfficiency;\n    attribute def DrivingScenario;\n    attribute def Trajectory;\n    attribute def Acceleration;\n    \n    port def VehicleParametersPort {\n        in curbWeight: Mass;\n        in load: Mass;\n        in wheelDiameter: WheelDiameter;\n        in transmissionEfficiency: TransmissionEfficiency;\n    }\n    \n    port def DrivingConditionsPort {\n        in scenario: DrivingScenario;\n        in trajectory: Trajectory;\n        in speedProfile: Speed[*];\n    }\n    \n    port def SimulationResultsPort {\n        out fuelEconomy: FuelEconomy;\n        out fuelConsumption: FuelConsumption;\n        out meetsRequirement: Boolean;\n    }\n    \n    part context {\n        part user {\n            port vehicleParamsPort: VehicleParametersPort;\n            port drivingConditionsPort: DrivingConditionsPort;\n            port resultsPort: ~SimulationResultsPort;\n            \n            perform fuelEconomyAnalysis.setVehicleParameters {\n                out curbWeight = vehicleParamsPort.curbWeight;\n                out load = vehicleParamsPort.load;\n                out wheelDiameter = vehicleParamsPort.wheelDiameter;\n                out transmissionEfficiency = vehicleParamsPort.transmissionEfficiency;\n            }\n            \n            perform fuelEconomyAnalysis.setDrivingScenario {\n                out scenario = drivingConditionsPort.scenario;\n                out trajectory = drivingConditionsPort.trajectory;\n                out speedProfile = drivingConditionsPort.speedProfile;\n            }\n        }\n        \n        interface userToSimulator connect user.vehicleParamsPort to simulator.vehicleParamsPort;\n        interface userToDrivingInput connect user.drivingConditionsPort to simulator.drivingConditionsPort;\n        interface simulatorToUser connect simulator.resultsPort to user.resultsPort;\n        \n        part simulator {\n            port vehicleParamsPort: ~VehicleParametersPort;\n            port drivingConditionsPort: ~DrivingConditionsPort;\n            port resultsPort: SimulationResultsPort;\n            \n            perform fuelEconomyAnalysis.calculateWheelPower {\n                in curbWeight = vehicleParamsPort.curbWeight;\n                in load = vehicleParamsPort.load;\n                in wheelDiameter = vehicleParamsPort.wheelDiameter;\n                in speedProfile = drivingConditionsPort.speedProfile;\n                in trajectory = drivingConditionsPort.trajectory;\n                out wheelPower: Power;\n                out acceleration: Acceleration;\n            }\n            \n            perform fuelEconomyAnalysis.calculateEnginePower {\n                in wheelPower: Power;\n                in transmissionEfficiency = vehicleParamsPort.transmissionEfficiency;\n                out enginePower: Power;\n            }\n            \n            perform fuelEconomyAnalysis.calculateFuelConsumption {\n                in enginePower: Power;\n                in scenario = drivingConditionsPort.scenario;\n                out fuelConsumption = resultsPort.fuelConsumption;\n                out fuelEconomy = resultsPort.fuelEconomy;\n            }\n            \n            perform fuelEconomyAnalysis.verifyRequirement {\n                in fuelEconomy = resultsPort.fuelEconomy;\n                out meetsRequirement = resultsPort.meetsRequirement;\n            }\n        }\n    }\n    \n    action fuelEconomyAnalysis {\n        action setVehicleParameters {\n            out curbWeight: Mass;\n            out load: Mass;\n            out wheelDiameter: WheelDiameter;\n            out transmissionEfficiency: TransmissionEfficiency;\n        }\n        \n        action setDrivingScenario {\n            out scenario: DrivingScenario;\n            out trajectory: Trajectory;\n            out speedProfile: Speed[*];\n        }\n        \n        succession flow vehicleParamsFlow from setVehicleParameters to calculateWheelPower;\n        succession flow drivingConditionsFlow from setDrivingScenario to calculateWheelPower;\n        \n        action calculateWheelPower {\n            in curbWeight: Mass;\n            in load: Mass;\n            in wheelDiameter: WheelDiameter;\n            in speedProfile: Speed[*];\n            in trajectory: Trajectory;\n            out wheelPower: Power;\n            out acceleration: Acceleration;\n        }\n        \n        succession flow wheelPowerFlow from calculateWheelPower.wheelPower to calculateEnginePower.wheelPower;\n        \n        action calculateEnginePower {\n            in wheelPower: Power;\n            in transmissionEfficiency: TransmissionEfficiency;\n            out enginePower: Power;\n        }\n        \n        succession flow enginePowerFlow from calculateEnginePower.enginePower to calculateFuelConsumption.enginePower;\n        \n        action calculateFuelConsumption {\n            in enginePower: Power;\n            in scenario: DrivingScenario;\n            out fuelConsumption: FuelConsumption;\n            out fuelEconomy: FuelEconomy;\n        }\n        \n        succession flow fuelEconomyFlow from calculateFuelConsumption.fuelEconomy to verifyRequirement.fuelEconomy;\n        \n        action verifyRequirement {\n            in fuelEconomy: FuelEconomy;\n            out meetsRequirement: Boolean;\n        }\n    }\n}",
    "package 'EngineSelectionSystem' {\n\tattribute def Power;\n\tattribute def Mass;\n\tattribute def Efficiency;\n\tattribute def Cost;\n\tattribute def Score;\n\tattribute def EngineType;\n\t\n\tport def EngineDataPort {\n\t\tout power: Power;\n\t\tout mass: Mass;\n\t\tout efficiency: Efficiency;\n\t\tout cost: Cost;\n\t\tout engineType: EngineType;\n\t}\n\t\n\tport def ScorePort {\n\t\tout score: Score;\n\t}\n\t\n\tport def OptimalEnginePort {\n\t\tout optimalEngine: EngineType;\n\t\tout optimalScore: Score;\n\t}\n\t\n\tpart context {\n\t\tpart fourCylinderEngine {\n\t\t\tport engineDataPort: EngineDataPort;\n\t\t\tperform selectOptimalEngine.provideEngineData {\n\t\t\t\tout power = engineDataPort.power;\n\t\t\t\tout mass = engineDataPort.mass;\n\t\t\t\tout efficiency = engineDataPort.efficiency;\n\t\t\t\tout cost = engineDataPort.cost;\n\t\t\t\tout engineType = engineDataPort.engineType;\n\t\t\t}\n\t\t}\n\t\t\n\t\tpart sixCylinderEngine {\n\t\t\tport engineDataPort: EngineDataPort;\n\t\t\tperform selectOptimalEngine.provideEngineData {\n\t\t\t\tout power = engineDataPort.power;\n\t\t\t\tout mass = engineDataPort.mass;\n\t\t\t\tout efficiency = engineDataPort.efficiency;\n\t\t\t\tout cost = engineDataPort.cost;\n\t\t\t\tout engineType = engineDataPort.engineType;\n\t\t\t}\n\t\t}\n\t\t\n\t\tinterface engineToAnalyzer connect fourCylinderEngine.engineDataPort to analyzer.engineDataPort1 {\n\t\t\tref flow references selectOptimalEngine.engineDataFlow1\n\t\t\t\tfrom source.power to target.power;\n\t\t\tref flow references selectOptimalEngine.engineDataFlow1\n\t\t\t\tfrom source.mass to target.mass;\n\t\t\tref flow references selectOptimalEngine.engineDataFlow1\n\t\t\t\tfrom source.efficiency to target.efficiency;\n\t\t\tref flow references selectOptimalEngine.engineDataFlow1\n\t\t\t\tfrom source.cost to target.cost;\n\t\t\tref flow references selectOptimalEngine.engineDataFlow1\n\t\t\t\tfrom source.engineType to target.engineType;\n\t\t}\n\t\t\n\t\tinterface engineToAnalyzer2 connect sixCylinderEngine.engineDataPort to analyzer.engineDataPort2 {\n\t\t\tref flow references selectOptimalEngine.engineDataFlow2\n\t\t\t\tfrom source.power to target.power;\n\t\t\tref flow references selectOptimalEngine.engineDataFlow2\n\t\t\t\tfrom source.mass to target.mass;\n\t\t\tref flow references selectOptimalEngine.engineDataFlow2\n\t\t\t\tfrom source.efficiency to target.efficiency;\n\t\t\tref flow references selectOptimalEngine.engineDataFlow2\n\t\t\t\tfrom source.cost to target.cost;\n\t\t\tref flow references selectOptimalEngine.engineDataFlow2\n\t\t\t\tfrom source.engineType to target.engineType;\n\t\t}\n\t\t\n\t\tpart analyzer {\n\t\t\tport engineDataPort1: ~EngineDataPort;\n\t\t\tport engineDataPort2: ~EngineDataPort;\n\t\t\tport scorePort1: ScorePort;\n\t\t\tport scorePort2: ScorePort;\n\t\t\tport optimalEnginePort: OptimalEnginePort;\n\t\t\t\n\t\t\tperform selectOptimalEngine.calculatePerformance {\n\t\t\t\tin power1 = engineDataPort1.power;\n\t\t\t\tin mass1 = engineDataPort1.mass;\n\t\t\t\tin efficiency1 = engineDataPort1.efficiency;\n\t\t\t\tin cost1 = engineDataPort1.cost;\n\t\t\t\tin engineType1 = engineDataPort1.engineType;\n\t\t\t\tin power2 = engineDataPort2.power;\n\t\t\t\tin mass2 = engineDataPort2.mass;\n\t\t\t\tin efficiency2 = engineDataPort2.efficiency;\n\t\t\t\tin cost2 = engineDataPort2.cost;\n\t\t\t\tin engineType2 = engineDataPort2.engineType;\n\t\t\t\tout score1 = scorePort1.score;\n\t\t\t\tout score2 = scorePort2.score;\n\t\t\t}\n\t\t\t\n\t\t\tperform selectOptimalEngine.selectBestEngine {\n\t\t\t\tin score1 = scorePort1.score;\n\t\t\t\tin score2 = scorePort2.score;\n\t\t\t\tout optimalEngine = optimalEnginePort.optimalEngine;\n\t\t\t\tout optimalScore = optimalEnginePort.optimalScore;\n\t\t\t}\n\t\t}\n\t}\n\t\n\taction selectOptimalEngine {\n\t\taction provideEngineData { \n\t\t\tout power: Power; \n\t\t\tout mass: Mass; \n\t\t\tout efficiency: Efficiency; \n\t\t\tout cost: Cost;\n\t\t\tout engineType: EngineType;\n\t\t}\n\t\tsuccession flow engineDataFlow1 from provideEngineData to calculatePerformance;\n\t\tsuccession flow engineDataFlow2 from provideEngineData to calculatePerformance;\n\t\taction calculatePerformance { \n\t\t\tin power1; in mass1; in efficiency1; in cost1; in engineType1;\n\t\t\tin power2; in mass2; in efficiency2; in cost2; in engineType2;\n\t\t\tout score1: Score; \n\t\t\tout score2: Score;\n\t\t}\n\t\tsuccession flow scoreFlow from calculatePerformance to selectBestEngine;\n\t\taction selectBestEngine { \n\t\t\tin score1; in score2;\n\t\t\tout optimalEngine: EngineType;\n\t\t\tout optimalScore: Score;\n\t\t}\n\t}\n}",
    "package 'VehicleWeightInspection' {\n\tattribute def WeightData;\n\tattribute def ProcessedData;\n\tattribute def QualityResult;\n\t\n\tport def WeightDataPort {\n\t\tout weightData : WeightData;\n\t}\n\tport def ProcessedDataPort {\n\t\tout processedData : ProcessedData;\n\t}\n\tport def QualityResultPort {\n\t\tout qualityResult : QualityResult;\n\t}\n\t\n\tpart context {\n\t\tpart vehicle {\n\t\t\tport weightDataPort : WeightDataPort;\n\t\t\tperform inspectVehicleWeight.collectWeightData {\n\t\t\t\tout weightData = weightDataPort.weightData;\n\t\t\t}\n\t\t}\n\t\t\n\t\tinterface vehicleToSystem connect vehicle.weightDataPort to inspectionSystem.weightDataPort {\n\t\t\tref flow references inspectVehicleWeight.weightDataFlow\n\t\t\t\tfrom source.weightData to target.weightData;\n\t\t}\n\t\t\n\t\tpart inspectionSystem {\n\t\t\tport weightDataPort : ~WeightDataPort;\n\t\t\tport processedDataPort : ProcessedDataPort;\n\t\t\tport qualityResultPort : QualityResultPort;\n\t\t\t\n\t\t\tperform inspectVehicleWeight.processData {\n\t\t\t\tin weightData = weightDataPort.weightData;\n\t\t\t\tout processedData = processedDataPort.processedData;\n\t\t\t}\n\t\t\t\n\t\t\tperform inspectVehicleWeight.evaluateWeight {\n\t\t\t\tin processedData = processedDataPort.processedData;\n\t\t\t\tout qualityResult = qualityResultPort.qualityResult;\n\t\t\t}\n\t\t}\n\t}\n\t\n\taction inspectVehicleWeight {\n\t\taction collectWeightData { out weightData : WeightData; }\n\t\tsuccession flow weightDataFlow from collectWeightData.weightData to processData.weightData;\n\t\taction processData { in weightData : WeightData; out processedData : ProcessedData; }\n\t\tsuccession flow processedDataFlow from processData.processedData to evaluateWeight.processedData;\n\t\taction evaluateWeight { in processedData : ProcessedData; out qualityResult : QualityResult; }\n\t}\n}",
    "package 'VehicleMassVerification' {\n\tattribute def Mass;\n\tattribute def VerificationResult;\n\t\n\tport def MassDataPort {\n\t\tout massData : Mass;\n\t}\n\t\n\tport def VerificationResultPort {\n\t\tout result : VerificationResult;\n\t}\n\t\n\tpart context {\n\t\tpart vehicle {\n\t\t\tattribute actualMass : Mass;\n\t\t\tport massDataPort : MassDataPort;\n\t\t\t\n\t\t\tperform verifyMass.provideMass {\n\t\t\t\tout massData = massDataPort.massData;\n\t\t\t}\n\t\t}\n\t\t\n\t\tinterface vehicleToWeighingEquipment connect vehicle.massDataPort to weighingEquipment.massDataPort {\n\t\t\tref flow references verifyMass.massDataFlow\n\t\t\t\tfrom source.massData to target.massData;\n\t\t}\n\t\t\n\t\tpart weighingEquipment {\n\t\t\tport massDataPort : ~MassDataPort;\n\t\t\tport measuredMassPort : MassDataPort;\n\t\t\t\n\t\t\tperform verifyMass.measureMass {\n\t\t\t\tin massData = massDataPort.massData;\n\t\t\t\tout measuredMass = measuredMassPort.massData;\n\t\t\t}\n\t\t}\n\t\t\n\t\tinterface weighingToVerificationUnit connect weighingEquipment.measuredMassPort to massVerificationUnit.measuredMassPort {\n\t\t\tref flow references verifyMass.measuredMassFlow\n\t\t\t\tfrom source.massData to target.massData;\n\t\t}\n\t\t\n\t\tpart massVerificationUnit {\n\t\t\tattribute massLimit : Mass = 2500;\n\t\t\tport measuredMassPort : ~MassDataPort;\n\t\t\tport resultPort : VerificationResultPort;\n\t\t\t\n\t\t\tperform verifyMass.evaluateMass {\n\t\t\t\tin measuredMass = measuredMassPort.massData;\n\t\t\t\tout result = resultPort.result;\n\t\t\t}\n\t\t}\n\t}\n\t\n\taction verifyMass {\n\t\taction provideMass { out massData : Mass; }\n\t\tsuccession flow massDataFlow from provideMass.massData to measureMass.massData;\n\t\taction measureMass { in massData : Mass; out measuredMass : Mass; }\n\t\tsuccession flow measuredMassFlow from measureMass.measuredMass to evaluateMass.measuredMass;\n\t\taction evaluateMass { in measuredMass : Mass; out result : VerificationResult; }\n\t}\n}",
    "package 'TransportationSystem' {\n\tattribute def PassengerCount;\n\tattribute def Location;\n\tattribute def VehicleState;\n\tattribute def EnvironmentalData;\n\tattribute def FuelLevel;\n\t\n\tport def EntryExitPort {\n\t\tin entryRequest : VehicleState;\n\t\tout exitConfirmation : VehicleState;\n\t}\n\t\n\tport def NavigationPort {\n\t\tin destination : Location;\n\t\tout currentLocation : Location;\n\t}\n\t\n\tport def EnvironmentPort {\n\t\tin environmentData : EnvironmentalData;\n\t}\n\t\n\tport def FuelPort {\n\t\tinout fuelLevel : FuelLevel;\n\t}\n\t\n\tpart context {\n\t\tpart driver {\n\t\t\tport entryExitPort : EntryExitPort;\n\t\t\tport navigationPort : NavigationPort;\n\t\t\tperform transport.operateVehicle {\n\t\t\t\tout destination = navigationPort.destination;\n\t\t\t\tin currentLocation = navigationPort.currentLocation;\n\t\t\t}\n\t\t}\n\t\t\n\t\tpart passengers[0..4] {\n\t\t\tport entryExitPort : EntryExitPort;\n\t\t\tperform transport.travelInVehicle {\n\t\t\t\tout entryRequest = entryExitPort.entryRequest;\n\t\t\t\tin exitConfirmation = entryExitPort.exitConfirmation;\n\t\t\t}\n\t\t}\n\t\t\n\t\tinterface userToVehicle connect driver.entryExitPort to vehicle.driverEntryExitPort {\n\t\t\tref flow references transport.driverEntryFlow\n\t\t\t\tfrom source.entryRequest to target.entryRequest;\n\t\t}\n\t\t\n\t\tinterface passengerToVehicle connect passengers.entryExitPort to vehicle.passengerEntryExitPort {\n\t\t\tref flow references transport.passengerEntryFlow\n\t\t\t\tfrom source.entryRequest to target.entryRequest;\n\t\t}\n\t\t\n\t\tinterface driverNavigation connect driver.navigationPort to vehicle.navigationPort {\n\t\t\tref flow references transport.navigationFlow\n\t\t\t\tfrom source.destination to target.destination;\n\t\t\tref flow references transport.locationFlow\n\t\t\t\tfrom target.currentLocation to source.currentLocation;\n\t\t}\n\t\t\n\t\tpart vehicle {\n\t\t\tport driverEntryExitPort : ~EntryExitPort;\n\t\t\tport passengerEntryExitPort[0..4] : ~EntryExitPort;\n\t\t\tport navigationPort : ~NavigationPort;\n\t\t\tport environmentPort : EnvironmentPort;\n\t\t\tport fuelPort : FuelPort;\n\t\t\t\n\t\t\tperform transport.provideTransportation {\n\t\t\t\tin driverEntry = driverEntryExitPort.entryRequest;\n\t\t\t\tin passengerEntry = passengerEntryExitPort.entryRequest;\n\t\t\t\tin destination = navigationPort.destination;\n\t\t\t\tout currentLocation = navigationPort.currentLocation;\n\t\t\t\tin environmentData = environmentPort.environmentData;\n\t\t\t\tinout fuelLevel = fuelPort.fuelLevel;\n\t\t\t}\n\t\t}\n\t\t\n\t\tpart environment {\n\t\t\tport environmentPort : ~EnvironmentPort;\n\t\t\tperform transport.provideEnvironmentalData {\n\t\t\t\tout environmentData = environmentPort.environmentData;\n\t\t\t}\n\t\t}\n\t\t\n\t\tinterface vehicleToEnvironment connect vehicle.environmentPort to environment.environmentPort {\n\t\t\tref flow references transport.environmentFlow\n\t\t\t\tfrom target.environmentData to source.environmentData;\n\t\t}\n\t\t\n\t\tpart gasStation {\n\t\t\tport fuelPort : ~FuelPort;\n\t\t\tperform transport.provideFuel {\n\t\t\t\tinout fuelLevel = fuelPort.fuelLevel;\n\t\t\t}\n\t\t}\n\t\t\n\t\tinterface vehicleToGasStation connect vehicle.fuelPort to gasStation.fuelPort {\n\t\t\tref flow references transport.fuelFlow\n\t\t\t\tfrom source.fuelLevel to target.fuelLevel;\n\t\t}\n\t}\n\t\n\taction transport {\n\t\taction operateVehicle { out destination : Location; in currentLocation : Location; }\n\t\taction travelInVehicle { out entryRequest : VehicleState; in exitConfirmation : VehicleState; }\n\t\taction provideTransportation { \n\t\t\tin driverEntry : VehicleState; \n\t\t\tin passengerEntry : VehicleState;\n\t\t\tin destination : Location;\n\t\t\tout currentLocation : Location;\n\t\t\tin environmentData : EnvironmentalData;\n\t\t\tinout fuelLevel : FuelLevel;\n\t\t}\n\t\taction provideEnvironmentalData { out environmentData : EnvironmentalData; }\n\t\taction provideFuel { inout fuelLevel : FuelLevel; }\n\t\t\n\t\tsuccession flow driverEntryFlow from operateVehicle to provideTransportation;\n\t\tsuccession flow passengerEntryFlow from travelInVehicle.entryRequest to provideTransportation.passengerEntry;\n\t\tsuccession flow navigationFlow from operateVehicle.destination to provideTransportation.destination;\n\t\tsuccession flow locationFlow from provideTransportation.currentLocation to operateVehicle.currentLocation;\n\t\tsuccession flow environmentFlow from provideEnvironmentalData.environmentData to provideTransportation.environmentData;\n\t\tsuccession flow fuelFlow from provideTransportation.fuelLevel to provideFuel.fuelLevel;\n\t}\n}",
    "package 'TransportationSystem' {\n\tattribute def Location;\n\tattribute def Fuel;\n\tattribute def EnvironmentalConditions;\n\tattribute def VehicleControl;\n\t\n\tport def LocationPort {\n\t\tin location: Location;\n\t}\n\t\n\tport def FuelPort {\n\t\tin fuel: Fuel;\n\t\tout fuel: Fuel;\n\t}\n\t\n\tport def EnvironmentPort {\n\t\tin conditions: EnvironmentalConditions;\n\t}\n\t\n\tport def ControlPort {\n\t\tout control: VehicleControl;\n\t}\n\t\n\tpart context {\n\t\tpart driver {\n\t\t\tport controlPort: ControlPort;\n\t\t\tperform transportation.enterVehicle;\n\t\t\tperform transportation.operateVehicle {\n\t\t\t\tout control = controlPort.control;\n\t\t\t}\n\t\t\tperform transportation.exitVehicle;\n\t\t}\n\t\t\n\t\tpart passengers[0..4] {\n\t\t\tperform transportation.enterVehicle;\n\t\t\tperform transportation.exitVehicle;\n\t\t}\n\t\t\n\t\tinterface driverToVehicle connect driver.controlPort to vehicle.controlPort {\n\t\t\tref flow references transportation.controlFlow\n\t\t\t\tfrom source.control to target.control;\n\t\t}\n\t\t\n\t\tpart vehicle {\n\t\t\tport controlPort: ~ControlPort;\n\t\t\tport fuelPort: FuelPort;\n\t\t\tport environmentPort: EnvironmentPort;\n\t\t\tport startLocationPort: LocationPort;\n\t\t\tport destinationPort: LocationPort;\n\t\t\t\n\t\t\tperform transportation.transport {\n\t\t\t\tin control = controlPort.control;\n\t\t\t\tin fuel = fuelPort.fuel;\n\t\t\t\tin conditions = environmentPort.conditions;\n\t\t\t\tin startLocation = startLocationPort.location;\n\t\t\t\tin destination = destinationPort.location;\n\t\t\t}\n\t\t}\n\t\t\n\t\tpart gasStation {\n\t\t\tport fuelPort: ~FuelPort;\n\t\t\tperform transportation.refuel {\n\t\t\t\tout fuel = fuelPort.fuel;\n\t\t\t}\n\t\t}\n\t\t\n\t\tpart environment {\n\t\t\tport environmentPort: ~EnvironmentPort;\n\t\t\tperform transportation.provideConditions {\n\t\t\t\tout conditions = environmentPort.conditions;\n\t\t\t}\n\t\t}\n\t\t\n\t\tinterface vehicleToGasStation connect vehicle.fuelPort to gasStation.fuelPort {\n\t\t\tref flow references transportation.fuelFlow\n\t\t\t\tfrom target.fuel to source.fuel;\n\t\t}\n\t\t\n\t\tinterface environmentToVehicle connect environment.environmentPort to vehicle.environmentPort {\n\t\t\tref flow references transportation.environmentFlow\n\t\t\t\tfrom source.conditions to target.conditions;\n\t\t}\n\t}\n\t\n\taction transportation {\n\t\taction enterVehicle;\n\t\taction operateVehicle { out control: VehicleControl; }\n\t\taction transport { \n\t\t\tin control: VehicleControl; \n\t\t\tin fuel: Fuel;\n\t\t\tin conditions: EnvironmentalConditions;\n\t\t\tin startLocation: Location;\n\t\t\tin destination: Location;\n\t\t}\n\t\taction refuel { out fuel: Fuel; }\n\t\taction provideConditions { out conditions: EnvironmentalConditions; }\n\t\taction exitVehicle;\n\t\t\n\t\tsuccession flow controlFlow from operateVehicle.control to transport.control;\n\t\tsuccession flow fuelFlow from refuel.fuel to transport.fuel;\n\t\tsuccession flow environmentFlow from provideConditions.conditions to transport.conditions;\n\t\tsuccession enterVehicle then operateVehicle;\n\t\tsuccession operateVehicle then transport;\n\t\tsuccession transport then exitVehicle;\n\t}\n}",
    "package 'VehicleConfigurationManagement' {\n    attribute def CylinderDiameter :> Real;\n    \n    part def Cylinder {\n        attribute diameter : CylinderDiameter;\n        assert constraint { diameter == 70.0 or diameter == 100.0 }\n    }\n    \n    part def Engine {\n        abstract;\n        part cylinders : Cylinder[*] ordered;\n    }\n    \n    part def FourCylinderEngine :> Engine {\n        part :>> cylinders : Cylinder[4];\n    }\n    \n    part def SixCylinderEngine :> Engine {\n        part :>> cylinders : Cylinder[6];\n    }\n    \n    part def Transmission {\n        abstract;\n    }\n    \n    part def ManualTransmission :> Transmission;\n    \n    part def AutomaticTransmission :> Transmission;\n    \n    part def Vehicle {\n        part engine : Engine[1];\n        part transmission : Transmission[1];\n        \n        assert constraint validCombination {\n            (engine istype FourCylinderEngine and \n             (transmission istype ManualTransmission or transmission istype AutomaticTransmission))\n            or\n            (engine istype SixCylinderEngine and transmission istype AutomaticTransmission)\n        }\n    }\n}",
    "package 'ConfigurableEngine' {\n    attribute def CylinderCount;\n    attribute def CylinderDiameter;\n    \n    part def Cylinder {\n        attribute diameter : CylinderDiameter;\n    }\n    \n    part def Engine {\n        attribute cylinderCount : CylinderCount;\n        part cylinders : Cylinder[1..*];\n    }\n    \n    part def FourCylinderEngine :> Engine {\n        attribute redefines cylinderCount = 4;\n        part redefines cylinders : Cylinder[4];\n    }\n    \n    part def SixCylinderEngine :> Engine {\n        attribute redefines cylinderCount = 6;\n        part redefines cylinders : Cylinder[6];\n    }\n    \n    part engineSystem {\n        variant part selectedEngine : Engine[1] {\n            variant fourCylEngine : FourCylinderEngine {\n                part redefines cylinders {\n                    variant attribute redefines diameter {\n                        variant = 70;\n                        variant = 100;\n                    }\n                }\n            }\n            variant sixCylEngine : SixCylinderEngine {\n                part redefines cylinders {\n                    variant attribute redefines diameter {\n                        variant = 70;\n                        variant = 100;\n                    }\n                }\n            }\n        }\n    }\n}",
    "package 'AutomotiveConfiguration' {\n    attribute def DiameterValue :> Real;\n    \n    part def Cylinder {\n        attribute diameter : DiameterValue;\n    }\n    \n    part def Engine {\n        abstract;\n        part cylinders : Cylinder[1..*];\n    }\n    \n    part def FourCylinderEngine :> Engine {\n        part redefines cylinders : Cylinder[4];\n    }\n    \n    part def SixCylinderEngine :> Engine {\n        part redefines cylinders : Cylinder[6];\n    }\n    \n    part def Transmission {\n        abstract;\n    }\n    \n    part def ManualTransmission :> Transmission;\n    \n    part def AutomaticTransmission :> Transmission;\n    \n    part def Vehicle {\n        part engine : Engine[1] {\n            part redefines cylinders {\n                attribute redefines diameter {\n                    attribute diameterOptions : DiameterValue[2] = (70.0, 100.0);\n                    constraint { diameter == diameterOptions[1] or diameter == diameterOptions[2] }\n                }\n            }\n        }\n        part transmission : Transmission[1];\n        \n        constraint fourCylinderRequiresManual {\n            engine istype FourCylinderEngine implies transmission istype ManualTransmission\n        }\n        \n        constraint sixCylinderRequiresAutomatic {\n            engine istype SixCylinderEngine implies transmission istype AutomaticTransmission\n        }\n    }\n}",
    "package 'SystemAssembly' {\n\tattribute def MessageFormat;\n\tattribute def DataFormat;\n\tattribute def ProcessedData;\n\tattribute def StorageRequest;\n\tattribute def StorageResponse;\n\t\n\tport def MessageFormatPort {\n\t\tout messageFormat: MessageFormat;\n\t}\n\tport def DataFormatPort {\n\t\tout dataFormat: DataFormat;\n\t}\n\tport def ProcessedDataPort {\n\t\tout processedData: ProcessedData;\n\t}\n\tport def StorageRequestPort {\n\t\tout storageRequest: StorageRequest;\n\t}\n\tport def StorageResponsePort {\n\t\tout storageResponse: StorageResponse;\n\t}\n\t\n\tpart systemAssembly {\n\t\tpart softwareDesign {\n\t\t\tport messageFormatPort: MessageFormatPort;\n\t\t\tport dataFormatPort: DataFormatPort;\n\t\t\tperform systemOperation.defineFormats {\n\t\t\t\tout messageFormat = messageFormatPort.messageFormat;\n\t\t\t\tout dataFormat = dataFormatPort.dataFormat;\n\t\t\t}\n\t\t}\n\t\t\n\t\tpart computerSubsystem {\n\t\t\tport messageFormatPort: ~MessageFormatPort;\n\t\t\tport dataFormatPort: ~DataFormatPort;\n\t\t\tport processedDataPort: ProcessedDataPort;\n\t\t\tport storageRequestPort: StorageRequestPort;\n\t\t\tport storageResponsePort: ~StorageResponsePort;\n\t\t\tperform systemOperation.integrateAndProcess {\n\t\t\t\tin messageFormat = messageFormatPort.messageFormat;\n\t\t\t\tin dataFormat = dataFormatPort.dataFormat;\n\t\t\t\tin storageResponse = storageResponsePort.storageResponse;\n\t\t\t\tout processedData = processedDataPort.processedData;\n\t\t\t\tout storageRequest = storageRequestPort.storageRequest;\n\t\t\t}\n\t\t}\n\t\t\n\t\tpart storageSubsystem {\n\t\t\tport messageFormatPort: ~MessageFormatPort;\n\t\t\tport dataFormatPort: ~DataFormatPort;\n\t\t\tport processedDataPort: ~ProcessedDataPort;\n\t\t\tport storageRequestPort: ~StorageRequestPort;\n\t\t\tport storageResponsePort: StorageResponsePort;\n\t\t\tperform systemOperation.accessAndStore {\n\t\t\t\tin messageFormat = messageFormatPort.messageFormat;\n\t\t\t\tin dataFormat = dataFormatPort.dataFormat;\n\t\t\t\tin processedData = processedDataPort.processedData;\n\t\t\t\tin storageRequest = storageRequestPort.storageRequest;\n\t\t\t\tout storageResponse = storageResponsePort.storageResponse;\n\t\t\t}\n\t\t}\n\t\t\n\t\tinterface softwareToComputer connect softwareDesign.messageFormatPort to computerSubsystem.messageFormatPort {\n\t\t\tref flow references systemOperation.messageFormatFlow\n\t\t\t\tfrom source.messageFormat to target.messageFormat;\n\t\t}\n\t\tinterface softwareToComputer2 connect softwareDesign.dataFormatPort to computerSubsystem.dataFormatPort {\n\t\t\tref flow references systemOperation.dataFormatFlow\n\t\t\t\tfrom source.dataFormat to target.dataFormat;\n\t\t}\n\t\tinterface softwareToStorage connect softwareDesign.messageFormatPort to storageSubsystem.messageFormatPort {\n\t\t\tref flow references systemOperation.messageFormatToStorageFlow\n\t\t\t\tfrom source.messageFormat to target.messageFormat;\n\t\t}\n\t\tinterface softwareToStorage2 connect softwareDesign.dataFormatPort to storageSubsystem.dataFormatPort {\n\t\t\tref flow references systemOperation.dataFormatToStorageFlow\n\t\t\t\tfrom source.dataFormat to target.dataFormat;\n\t\t}\n\t\tinterface computerToStorage connect computerSubsystem.processedDataPort to storageSubsystem.processedDataPort {\n\t\t\tref flow references systemOperation.processedDataFlow\n\t\t\t\tfrom source.processedData to target.processedData;\n\t\t}\n\t\tinterface computerToStorage2 connect computerSubsystem.storageRequestPort to storageSubsystem.storageRequestPort {\n\t\t\tref flow references systemOperation.storageRequestFlow\n\t\t\t\tfrom source.storageRequest to target.storageRequest;\n\t\t}\n\t\tinterface storageToComputer connect storageSubsystem.storageResponsePort to computerSubsystem.storageResponsePort {\n\t\t\tref flow references systemOperation.storageResponseFlow\n\t\t\t\tfrom source.storageResponse to target.storageResponse;\n\t\t}\n\t}\n\t\n\taction systemOperation {\n\t\taction defineFormats { out messageFormat: MessageFormat; out dataFormat: DataFormat; }\n\t\tsuccession flow messageFormatFlow from defineFormats.messageFormat to integrateAndProcess.messageFormat;\n\t\tsuccession flow dataFormatFlow from defineFormats.dataFormat to integrateAndProcess.dataFormat;\n\t\tsuccession flow messageFormatToStorageFlow from defineFormats.messageFormat to accessAndStore.messageFormat;\n\t\tsuccession flow dataFormatToStorageFlow from defineFormats.dataFormat to accessAndStore.dataFormat;\n\t\taction integrateAndProcess { in messageFormat; in dataFormat; in storageResponse: StorageResponse; out processedData: ProcessedData; out storageRequest: StorageRequest; }\n\t\tsuccession flow processedDataFlow from integrateAndProcess.processedData to accessAndStore.processedData;\n\t\tsuccession flow storageRequestFlow from integrateAndProcess.storageRequest to accessAndStore.storageRequest;\n\t\taction accessAndStore { in messageFormat; in dataFormat; in processedData; in storageRequest; out storageResponse: StorageResponse; }\n\t\tsuccession flow storageResponseFlow from accessAndStore.storageResponse to integrateAndProcess.storageResponse;\n\t}\n}",
    "package 'PowertrainSystem' {\n    attribute def Power;\n    attribute def Torque;\n    \n    port def PowerPort {\n        out power: Power;\n    }\n    \n    port def TorquePort {\n        in power: Power;\n        out torque: Torque;\n    }\n    \n    part def LogicalPowerProvider {\n        port powerPort: PowerPort;\n    }\n    \n    part def LogicalTorqueGenerator {\n        port torquePort: TorquePort;\n    }\n    \n    part def PhysicalPowerUnit {\n        port powerPort: PowerPort;\n        port torquePort: TorquePort;\n    }\n    \n    part powertrainSystem {\n        part logicalLayer {\n            part powerProvider: LogicalPowerProvider;\n            part torqueGenerator: LogicalTorqueGenerator;\n            \n            interface powerFlow connect powerProvider.powerPort to torqueGenerator.torquePort {\n                flow of Power from source.power to target.power;\n            }\n        }\n        \n        part physicalLayer {\n            part powerUnit: PhysicalPowerUnit;\n        }\n        \n        allocation logicalToPhysical {\n            allocate logicalLayer.powerProvider to physicalLayer.powerUnit;\n            allocate logicalLayer.torqueGenerator to physicalLayer.powerUnit;\n        }\n    }\n}",
    "package 'PowerTransmissionSystem' {\n    attribute def Power;\n    attribute def Torque;\n    \n    port def PowerPort {\n        out power: Power;\n    }\n    \n    port def TorquePort {\n        out torque: Torque;\n    }\n    \n    part def LogicalSystem {\n        part torqueGenerator {\n            perform generateTorque {\n                in power: Power;\n                out torque: Torque;\n            }\n        }\n    }\n    \n    part def PhysicalSystem {\n        part powertrain {\n            part engine {\n                perform generateTorque {\n                    in power: Power;\n                    out torque: Torque;\n                }\n            }\n        }\n    }\n    \n    part system {\n        part logical: LogicalSystem;\n        part physical: PhysicalSystem;\n        \n        allocation logicalToPhysical {\n            allocate logical.torqueGenerator to physical.powertrain;\n            allocate logical.torqueGenerator.generateTorque to physical.powertrain.engine.generateTorque;\n        }\n    }\n    \n    action providePowerAndGenerateTorque {\n        action deliverPower { out power: Power; }\n        flow powerFlow from deliverPower.power to generateTorque.power;\n        action generateTorque { in power: Power; out torque: Torque; }\n    }\n}",
    "package 'VehicleFeatureAnnotationSystem' {\n    attribute def SafetyFeature;\n    attribute def SecurityFeature;\n    \n    part def SeatBelt {\n        attribute safetyType : SafetyFeature;\n    }\n    \n    part def DriverAirbag {\n        attribute safetyType : SafetyFeature;\n    }\n    \n    part def Bumper {\n        attribute safetyType : SafetyFeature;\n    }\n    \n    part def AntiTheftAlarm {\n        attribute securityType : SecurityFeature;\n    }\n    \n    part def KeylessEntrySystem {\n        attribute securityType : SecurityFeature;\n    }\n    \n    part def FrontSeat;\n    part def BodyShell;\n    \n    part def Interior {\n        part seatBelt : SeatBelt;\n        part frontSeat : FrontSeat;\n        part driverAirbag : DriverAirbag;\n        part alarmSystem : AntiTheftAlarm;\n    }\n    \n    part def BodyAssembly {\n        part bodyShell : BodyShell;\n        part bumper : Bumper;\n        part keylessEntry : KeylessEntrySystem;\n    }\n    \n    part vehicle {\n        part interior : Interior;\n        part bodyAssembly : BodyAssembly;\n    }\n}",
    "package 'VehicleDynamicsSimulation' {\n    attribute def Velocity;\n    attribute def Position;\n    attribute def Acceleration;\n    attribute def TimeStep;\n    \n    port def SimulationInputPort {\n        in initialVelocity : Velocity;\n        in initialPosition : Position;\n        in acceleration : Acceleration;\n        in timeStep : TimeStep;\n    }\n    \n    port def SimulationOutputPort {\n        out finalVelocity : Velocity;\n        out finalPosition : Position;\n    }\n    \n    part context {\n        part user {\n            port simulationInputPort : SimulationInputPort;\n            perform analyzeVehicleDynamics.provideInputs {\n                out initialVelocity = simulationInputPort.initialVelocity;\n                out initialPosition = simulationInputPort.initialPosition;\n                out acceleration = simulationInputPort.acceleration;\n                out timeStep = simulationInputPort.timeStep;\n            }\n        }\n        \n        interface userToSimulationSystem connect user.simulationInputPort to simulationSystem.simulationInputPort {\n            ref flow references analyzeVehicleDynamics.inputFlow\n                from source.initialVelocity to target.initialVelocity;\n            ref flow references analyzeVehicleDynamics.inputFlow\n                from source.initialPosition to target.initialPosition;\n            ref flow references analyzeVehicleDynamics.inputFlow\n                from source.acceleration to target.acceleration;\n            ref flow references analyzeVehicleDynamics.inputFlow\n                from source.timeStep to target.timeStep;\n        }\n        \n        part simulationSystem {\n            port simulationInputPort : ~SimulationInputPort;\n            port simulationOutputPort : SimulationOutputPort;\n            \n            perform analyzeVehicleDynamics.calculateDynamics {\n                in initialVelocity = simulationInputPort.initialVelocity;\n                in initialPosition = simulationInputPort.initialPosition;\n                in acceleration = simulationInputPort.acceleration;\n                in timeStep = simulationInputPort.timeStep;\n                out finalVelocity = simulationOutputPort.finalVelocity;\n                out finalPosition = simulationOutputPort.finalPosition;\n            }\n        }\n        \n        interface simulationSystemToModelCenter connect simulationSystem.simulationOutputPort to modelCenter.simulationOutputPort {\n            ref flow references analyzeVehicleDynamics.outputFlow\n                from source.finalVelocity to target.finalVelocity;\n            ref flow references analyzeVehicleDynamics.outputFlow\n                from source.finalPosition to target.finalPosition;\n        }\n        \n        part modelCenter {\n            port simulationOutputPort : ~SimulationOutputPort;\n            perform analyzeVehicleDynamics.processResults {\n                in finalVelocity = simulationOutputPort.finalVelocity;\n                in finalPosition = simulationOutputPort.finalPosition;\n            }\n        }\n    }\n    \n    action analyzeVehicleDynamics {\n        action provideInputs {\n            out initialVelocity : Velocity;\n            out initialPosition : Position;\n            out acceleration : Acceleration;\n            out timeStep : TimeStep;\n        }\n        \n        succession flow inputFlow from provideInputs to calculateDynamics;\n        \n        action calculateDynamics {\n            in initialVelocity : Velocity;\n            in initialPosition : Position;\n            in acceleration : Acceleration;\n            in timeStep : TimeStep;\n            out finalVelocity : Velocity;\n            out finalPosition : Position;\n        }\n        \n        succession flow outputFlow from calculateDynamics to processResults;\n        \n        action processResults {\n            in finalVelocity : Velocity;\n            in finalPosition : Position;\n        }\n    }\n}",
    "package 'Car Safety Compliance' {\n    attribute def isMandatory : Boolean;\n    \n    metadata def Safety;\n    \n    package 'Safety Features' {\n        filter @Safety;\n    }\n    \n    package 'Mandatory Safety Features' {\n        filter @Safety and isMandatory == true;\n    }\n    \n    part def Car {\n        part interior {\n            part seatBelt[2] {\n                @Safety;\n                attribute :>> isMandatory = true;\n            }\n            \n            part driverAirbag {\n                @Safety;\n                attribute :>> isMandatory = false;\n            }\n        }\n        \n        part body {\n            part bumper {\n                @Safety;\n                attribute :>> isMandatory = true;\n            }\n            \n            part keylessEntrySystem {\n                @Safety;\n                attribute :>> isMandatory = false;\n            }\n        }\n        \n        part wheelAssembly {\n            part wheel[2];\n            \n            part antiLockBrakingSystem {\n                @Safety;\n                attribute :>> isMandatory = false;\n            }\n        }\n    }\n}",
    "package 'VehicleSafetyComplianceSystem' {\n    attribute def SafetyFeatureType {\n        attribute isMandatory: Boolean;\n    }\n    \n    part def SafetyFeature {\n        attribute featureType: SafetyFeatureType;\n    }\n    \n    part def SeatBelt :> SafetyFeature {\n        attribute redefines featureType: SafetyFeatureType {\n            attribute redefines isMandatory = true;\n        }\n    }\n    \n    part def DriverAirbag :> SafetyFeature {\n        attribute redefines featureType: SafetyFeatureType {\n            attribute redefines isMandatory = false;\n        }\n    }\n    \n    part def Bumper :> SafetyFeature {\n        attribute redefines featureType: SafetyFeatureType {\n            attribute redefines isMandatory = true;\n        }\n    }\n    \n    part def KeylessEntrySystem :> SafetyFeature {\n        attribute redefines featureType: SafetyFeatureType {\n            attribute redefines isMandatory = false;\n        }\n    }\n    \n    part def Tire {\n        attribute quantity: Integer = 4;\n    }\n    \n    part def ABS :> SafetyFeature {\n        attribute redefines featureType: SafetyFeatureType {\n            attribute redefines isMandatory = false;\n        }\n    }\n    \n    part def VehicleInterior {\n        part seatBelt1: SeatBelt;\n        part seatBelt2: SeatBelt;\n        part driverAirbag: DriverAirbag[0..1];\n    }\n    \n    part def VehicleBody {\n        part bumper: Bumper;\n        part keylessEntry: KeylessEntrySystem[0..1];\n    }\n    \n    part def ChassisSystem {\n        part tires: Tire[4];\n        part abs: ABS[0..1];\n    }\n    \n    part vehicle {\n        part interior: VehicleInterior;\n        part body: VehicleBody;\n        part chassis: ChassisSystem;\n    }\n}",
    "package 'RiskManagementSystem' {\n    attribute def Probability :> Real;\n    attribute def SeverityLevel :> Real;\n    attribute def SituationDescription :> String;\n    attribute def CauseDescription :> String;\n    attribute def FailureDescription :> String;\n    attribute def RiskAssessment;\n    attribute def CausalRelationship;\n    \n    part def Situation {\n        attribute description : SituationDescription;\n        ref cause : Cause[0..*];\n        ref failure : Failure[0..*];\n    }\n    \n    part def Cause {\n        attribute description : CauseDescription;\n        attribute probability : Probability;\n        ref leadTo : Situation[0..*];\n    }\n    \n    part def Failure {\n        attribute description : FailureDescription;\n        attribute severity : SeverityLevel;\n        ref resultFrom : Situation[0..*];\n    }\n    \n    part def RiskScenario {\n        part situations : Situation[1..*];\n        part causes : Cause[1..*];\n        part failures : Failure[1..*];\n        part causalLinks : CausalLink[0..*];\n    }\n    \n    assoc def CausalLink {\n        end source : Cause[1];\n        end target : Situation[1];\n        attribute relationship : CausalRelationship;\n    }\n    \n    port def RiskDataPort {\n        out riskAssessment : RiskAssessment;\n    }\n    \n    port def ScenarioInputPort {\n        in situationData : SituationDescription;\n        in causeData : CauseDescription;\n        in failureData : FailureDescription;\n    }\n    \n    part riskManagementSystem {\n        port scenarioInput : ScenarioInputPort;\n        port riskOutput : RiskDataPort;\n        \n        part scenarioModeler {\n            perform analyzeRisk.modelScenario {\n                in situationData = scenarioInput.situationData;\n                in causeData = scenarioInput.causeData;\n                in failureData = scenarioInput.failureData;\n            }\n        }\n        \n        part riskAnalyzer {\n            perform analyzeRisk.evaluateRisk {\n                out riskAssessment = riskOutput.riskAssessment;\n            }\n        }\n    }\n    \n    action analyzeRisk {\n        action modelScenario {\n            in situationData : SituationDescription;\n            in causeData : CauseDescription;\n            in failureData : FailureDescription;\n        }\n        action evaluateRisk {\n            out riskAssessment : RiskAssessment;\n        }\n        succession flow modelToEvaluate from modelScenario to evaluateRisk;\n    }\n}",
    "package 'RiskMetadataManagementSystem' {\n    attribute def ScenarioID;\n    attribute def ScenarioDescription;\n    attribute def CauseID;\n    attribute def CauseDescription;\n    attribute def Probability;\n    attribute def FailureID;\n    attribute def FailureType;\n    attribute def SeverityLevel;\n    attribute def RelationshipID;\n    attribute def RiskScenarioID;\n    \n    port def ScenarioDataPort {\n        out scenarioID: ScenarioID;\n        out scenarioDesc: ScenarioDescription;\n    }\n    \n    port def CauseDataPort {\n        out causeID: CauseID;\n        out causeDesc: CauseDescription;\n        out probability: Probability;\n    }\n    \n    port def FailureDataPort {\n        out failureID: FailureID;\n        out failureType: FailureType;\n        out severity: SeverityLevel;\n    }\n    \n    port def RelationshipDataPort {\n        out relationshipID: RelationshipID;\n        out sourceScenario: ScenarioID;\n        out targetScenario: ScenarioID;\n    }\n    \n    port def RiskScenarioDataPort {\n        out riskScenarioID: RiskScenarioID;\n        out scenarios: ScenarioID[*];\n        out causes: CauseID[*];\n        out failures: FailureID[*];\n    }\n    \n    part context {\n        part user {\n            port scenarioPort: ScenarioDataPort;\n            port causePort: CauseDataPort;\n            port failurePort: FailureDataPort;\n            port relationshipPort: RelationshipDataPort;\n            port riskScenarioPort: RiskScenarioDataPort;\n            \n            perform manageRiskMetadata.identifyScenarios {\n                out scenarioID = scenarioPort.scenarioID;\n                out scenarioDesc = scenarioPort.scenarioDesc;\n            }\n            \n            perform manageRiskMetadata.detailCauses {\n                out causeID = causePort.causeID;\n                out causeDesc = causePort.causeDesc;\n                out probability = causePort.probability;\n            }\n            \n            perform manageRiskMetadata.associateFailures {\n                out failureID = failurePort.failureID;\n                out failureType = failurePort.failureType;\n                out severity = failurePort.severity;\n            }\n            \n            perform manageRiskMetadata.trackRelationships {\n                out relationshipID = relationshipPort.relationshipID;\n                out sourceScenario = relationshipPort.sourceScenario;\n                out targetScenario = relationshipPort.targetScenario;\n            }\n            \n            perform manageRiskMetadata.formRiskScenarios {\n                out riskScenarioID = riskScenarioPort.riskScenarioID;\n                out scenarios = riskScenarioPort.scenarios;\n                out causes = riskScenarioPort.causes;\n                out failures = riskScenarioPort.failures;\n            }\n        }\n        \n        interface userToSystem connect user.scenarioPort to riskSystem.scenarioPort {\n            ref flow references manageRiskMetadata.scenarioFlow\n                from source.scenarioID to target.scenarioID;\n            ref flow references manageRiskMetadata.scenarioFlow\n                from source.scenarioDesc to target.scenarioDesc;\n        }\n        \n        interface userToCauseSystem connect user.causePort to riskSystem.causePort {\n            ref flow references manageRiskMetadata.causeFlow\n                from source.causeID to target.causeID;\n            ref flow references manageRiskMetadata.causeFlow\n                from source.causeDesc to target.causeDesc;\n            ref flow references manageRiskMetadata.causeFlow\n                from source.probability to target.probability;\n        }\n        \n        interface userToFailureSystem connect user.failurePort to riskSystem.failurePort {\n            ref flow references manageRiskMetadata.failureFlow\n                from source.failureID to target.failureID;\n            ref flow references manageRiskMetadata.failureFlow\n                from source.failureType to target.failureType;\n            ref flow references manageRiskMetadata.failureFlow\n                from source.severity to target.severity;\n        }\n        \n        interface userToRelationshipSystem connect user.relationshipPort to riskSystem.relationshipPort {\n            ref flow references manageRiskMetadata.relationshipFlow\n                from source.relationshipID to target.relationshipID;\n            ref flow references manageRiskMetadata.relationshipFlow\n                from source.sourceScenario to target.sourceScenario;\n            ref flow references manageRiskMetadata.relationshipFlow\n                from source.targetScenario to target.targetScenario;\n        }\n        \n        interface userToRiskScenarioSystem connect user.riskScenarioPort to riskSystem.riskScenarioPort {\n            ref flow references manageRiskMetadata.riskScenarioFlow\n                from source.riskScenarioID to target.riskScenarioID;\n            ref flow references manageRiskMetadata.riskScenarioFlow\n                from source.scenarios to target.scenarios;\n            ref flow references manageRiskMetadata.riskScenarioFlow\n                from source.causes to target.causes;\n            ref flow references manageRiskMetadata.riskScenarioFlow\n                from source.failures to target.failures;\n        }\n        \n        part riskSystem {\n            port scenarioPort: ~ScenarioDataPort;\n            port causePort: ~CauseDataPort;\n            port failurePort: ~FailureDataPort;\n            port relationshipPort: ~RelationshipDataPort;\n            port riskScenarioPort: ~RiskScenarioDataPort;\n            \n            perform manageRiskMetadata.processScenarios {\n                in scenarioID = scenarioPort.scenarioID;\n                in scenarioDesc = scenarioPort.scenarioDesc;\n            }\n            \n            perform manageRiskMetadata.processCauses {\n                in causeID = causePort.causeID;\n                in causeDesc = causePort.causeDesc;\n                in probability = causePort.probability;\n            }\n            \n            perform manageRiskMetadata.processFailures {\n                in failureID = failurePort.failureID;\n                in failureType = failurePort.failureType;\n                in severity = failurePort.severity;\n            }\n            \n            perform manageRiskMetadata.processRelationships {\n                in relationshipID = relationshipPort.relationshipID;\n                in sourceScenario = relationshipPort.sourceScenario;\n                in targetScenario = relationshipPort.targetScenario;\n            }\n            \n            perform manageRiskMetadata.processRiskScenarios {\n                in riskScenarioID = riskScenarioPort.riskScenarioID;\n                in scenarios = riskScenarioPort.scenarios;\n                in causes = riskScenarioPort.causes;\n                in failures = riskScenarioPort.failures;\n            }\n        }\n    }\n    \n    action manageRiskMetadata {\n        action identifyScenarios { \n            out scenarioID: ScenarioID; \n            out scenarioDesc: ScenarioDescription;\n        }\n        succession flow scenarioFlow from identifyScenarios to processScenarios;\n        action processScenarios { \n            in scenarioID: ScenarioID; \n            in scenarioDesc: ScenarioDescription;\n        }\n        \n        action detailCauses { \n            out causeID: CauseID; \n            out causeDesc: CauseDescription;\n            out probability: Probability;\n        }\n        succession flow causeFlow from detailCauses to processCauses;\n        action processCauses { \n            in causeID: CauseID; \n            in causeDesc: CauseDescription;\n            in probability: Probability;\n        }\n        \n        action associateFailures { \n            out failureID: FailureID; \n            out failureType: FailureType;\n            out severity: SeverityLevel;\n        }\n        succession flow failureFlow from associateFailures to processFailures;\n        action processFailures { \n            in failureID: FailureID; \n            in failureType: FailureType;\n            in severity: SeverityLevel;\n        }\n        \n        action trackRelationships { \n            out relationshipID: RelationshipID; \n            out sourceScenario: ScenarioID;\n            out targetScenario: ScenarioID;\n        }\n        succession flow relationshipFlow from trackRelationships to processRelationships;\n        action processRelationships { \n            in relationshipID: RelationshipID; \n            in sourceScenario: ScenarioID;\n            in targetScenario: ScenarioID;\n        }\n        \n        action formRiskScenarios { \n            out riskScenarioID: RiskScenarioID; \n            out scenarios: ScenarioID[*];\n            out causes: CauseID[*];\n            out failures: FailureID[*];\n        }\n        succession flow riskScenarioFlow from formRiskScenarios to processRiskScenarios;\n        action processRiskScenarios { \n            in riskScenarioID: RiskScenarioID; \n            in scenarios: ScenarioID[*];\n            in causes: CauseID[*];\n            in failures: FailureID[*];\n        }\n    }\n}",
    "package 'RiskAnalysisSystem' {\n\tattribute def BatteryLevel;\n\tattribute def FailureProbability;\n\tattribute def RiskAlert;\n\tattribute def SeverityLevel;\n\t\n\tport def BatteryStatusPort {\n\t\tin batteryLevel: BatteryLevel;\n\t\tout failureProbability: FailureProbability;\n\t}\n\t\n\tport def RiskAlertPort {\n\t\tout riskAlert: RiskAlert;\n\t\tout severityLevel: SeverityLevel;\n\t}\n\t\n\tpart def Battery {\n\t\tattribute currentLevel: BatteryLevel;\n\t\tattribute agingFactor: Real;\n\t}\n\t\n\tpart context {\n\t\tpart equipment {\n\t\t\tpart battery: Battery;\n\t\t\tport batteryStatusPort: BatteryStatusPort;\n\t\t\t\n\t\t\tperform riskAnalysis.monitorBatteryLevel {\n\t\t\t\tout batteryLevel = batteryStatusPort.batteryLevel;\n\t\t\t}\n\t\t}\n\t\t\n\t\tinterface equipmentToAnalyzer connect equipment.batteryStatusPort to riskAnalyzer.batteryStatusPort {\n\t\t\tref flow references riskAnalysis.batteryLevelFlow\n\t\t\t\tfrom source.batteryLevel to target.batteryLevel;\n\t\t}\n\t\t\n\t\tpart riskAnalyzer {\n\t\t\tport batteryStatusPort: ~BatteryStatusPort;\n\t\t\tport riskAlertPort: RiskAlertPort;\n\t\t\t\n\t\t\tperform riskAnalysis.detectBatteryAging {\n\t\t\t\tin batteryLevel = batteryStatusPort.batteryLevel;\n\t\t\t\tout failureProbability = batteryStatusPort.failureProbability;\n\t\t\t}\n\t\t\t\n\t\t\tperform riskAnalysis.analyzeFailureRisk {\n\t\t\t\tin failureProbability = batteryStatusPort.failureProbability;\n\t\t\t\tout riskAlert = riskAlertPort.riskAlert;\n\t\t\t\tout severityLevel = riskAlertPort.severityLevel;\n\t\t\t}\n\t\t}\n\t\t\n\t\tinterface analyzerToUser connect riskAnalyzer.riskAlertPort to userInterface.riskAlertPort {\n\t\t\tref flow references riskAnalysis.alertFlow\n\t\t\t\tfrom source.riskAlert to target.riskAlert;\n\t\t\tref flow references riskAnalysis.severityFlow\n\t\t\t\tfrom source.severityLevel to target.severityLevel;\n\t\t}\n\t\t\n\t\tpart userInterface {\n\t\t\tport riskAlertPort: ~RiskAlertPort;\n\t\t\t\n\t\t\tperform riskAnalysis.notifyUser {\n\t\t\t\tin riskAlert = riskAlertPort.riskAlert;\n\t\t\t\tin severityLevel = riskAlertPort.severityLevel;\n\t\t\t}\n\t\t}\n\t}\n\t\n\taction riskAnalysis {\n\t\taction monitorBatteryLevel { out batteryLevel: BatteryLevel; }\n\t\tsuccession flow batteryLevelFlow from monitorBatteryLevel.batteryLevel to detectBatteryAging.batteryLevel;\n\t\t\n\t\taction detectBatteryAging { \n\t\t\tin batteryLevel: BatteryLevel; \n\t\t\tout failureProbability: FailureProbability; \n\t\t}\n\t\tsuccession flow probabilityFlow from detectBatteryAging.failureProbability to analyzeFailureRisk.failureProbability;\n\t\t\n\t\taction analyzeFailureRisk { \n\t\t\tin failureProbability: FailureProbability; \n\t\t\tout riskAlert: RiskAlert;\n\t\t\tout severityLevel: SeverityLevel;\n\t\t}\n\t\tsuccession flow alertFlow from analyzeFailureRisk.riskAlert to notifyUser.riskAlert;\n\t\tsuccession flow severityFlow from analyzeFailureRisk.severityLevel to notifyUser.severityLevel;\n\t\t\n\t\taction notifyUser { \n\t\t\tin riskAlert: RiskAlert;\n\t\t\tin severityLevel: SeverityLevel;\n\t\t}\n\t}\n}",
    "package 'HierarchicalSystem' {\n    attribute def Data;\n    attribute def Control;\n    attribute def Status;\n    \n    port def DataPort {\n        in dataIn: Data;\n        out dataOut: Data;\n    }\n    \n    port def ControlPort {\n        in controlIn: Control;\n        out controlOut: Control;\n    }\n    \n    port def StatusPort {\n        out status: Status;\n    }\n    \n    part system {\n        doc /* Top-level system with hierarchical decomposition */\n        \n        port systemDataPort: DataPort;\n        port systemControlPort: ControlPort;\n        port systemStatusPort: StatusPort;\n        \n        part subsystemA {\n            doc /* Subsystem A with well-defined interfaces */\n            \n            port dataPortA: DataPort;\n            port controlPortA: ControlPort;\n            port statusPortA: StatusPort;\n            \n            part componentA1 {\n                doc /* Component A1 - independently analyzable */\n                port dataPortA1: DataPort;\n                port controlPortA1: ControlPort;\n                port statusPortA1: StatusPort;\n            }\n            \n            part componentA2 {\n                doc /* Component A2 - independently analyzable */\n                port dataPortA2: DataPort;\n                port controlPortA2: ControlPort;\n                port statusPortA2: StatusPort;\n            }\n            \n            interface a1ToA2 connect componentA1.dataPortA1 to componentA2.dataPortA2;\n            interface a1ControlToA2 connect componentA1.controlPortA1 to componentA2.controlPortA2;\n        }\n        \n        part subsystemB {\n            doc /* Subsystem B with well-defined interfaces */\n            \n            port dataPortB: DataPort;\n            port controlPortB: ControlPort;\n            port statusPortB: StatusPort;\n            \n            part componentB1 {\n                doc /* Component B1 - independently analyzable */\n                port dataPortB1: DataPort;\n                port controlPortB1: ControlPort;\n                port statusPortB1: StatusPort;\n            }\n            \n            part componentB2 {\n                doc /* Component B2 - independently analyzable */\n                port dataPortB2: DataPort;\n                port controlPortB2: ControlPort;\n                port statusPortB2: StatusPort;\n            }\n            \n            interface b1ToB2 connect componentB1.dataPortB1 to componentB2.dataPortB2;\n            interface b1ControlToB2 connect componentB1.controlPortB1 to componentB2.controlPortB2;\n        }\n        \n        interface systemToSubsystemA connect systemDataPort to subsystemA.dataPortA;\n        interface systemControlToA connect systemControlPort to subsystemA.controlPortA;\n        interface subsystemAToB connect subsystemA.dataPortA to subsystemB.dataPortB;\n        interface subsystemAControlToB connect subsystemA.controlPortA to subsystemB.controlPortB;\n        interface subsystemBToSystem connect subsystemB.dataPortB to systemDataPort;\n        interface subsystemBStatusToSystem connect subsystemB.statusPortB to systemStatusPort;\n    }\n    \n    view def StructuralDecompositionView {\n        doc /* View for system engineers and IV&V to verify integrity and modular design */\n        render system;\n        expose system.**;\n    }\n}",
    "package 'AutomotiveSystem' {\n    attribute def SafetyLevel {\n        attribute isMandatory: Boolean;\n    }\n    \n    part def Component {\n        attribute name: String;\n        attribute isSafetyRelated: Boolean default false;\n        attribute safetyLevel: SafetyLevel[0..1];\n    }\n    \n    part def SafetyComponent :> Component {\n        attribute redefines isSafetyRelated = true;\n        attribute redefines safetyLevel: SafetyLevel[1];\n    }\n    \n    part def FunctionalComponent :> Component {\n        attribute redefines isSafetyRelated = false;\n    }\n    \n    part def System :> Component {\n        part subsystems: Component[*];\n        part components: Component[*];\n    }\n    \n    part automotiveSystem: System {\n        attribute redefines name = \"Automotive System Root\";\n        \n        part chassisSubsystem: System {\n            attribute redefines name = \"Chassis Subsystem\";\n            \n            part abs: SafetyComponent {\n                attribute redefines name = \"Anti-lock Braking System\";\n                attribute redefines safetyLevel {\n                    attribute redefines isMandatory = false;\n                }\n            }\n            \n            part suspensionSystem: FunctionalComponent {\n                attribute redefines name = \"Suspension System\";\n            }\n        }\n        \n        part safetySubsystem: System {\n            attribute redefines name = \"Safety Subsystem\";\n            \n            part seatBelt: SafetyComponent {\n                attribute redefines name = \"Seat Belt\";\n                attribute redefines safetyLevel {\n                    attribute redefines isMandatory = true;\n                }\n            }\n            \n            part bumper: SafetyComponent {\n                attribute redefines name = \"Bumper\";\n                attribute redefines safetyLevel {\n                    attribute redefines isMandatory = true;\n                }\n            }\n            \n            part driverAirbag: SafetyComponent {\n                attribute redefines name = \"Driver Airbag\";\n                attribute redefines safetyLevel {\n                    attribute redefines isMandatory = false;\n                }\n            }\n        }\n        \n        part powertrainSubsystem: System {\n            attribute redefines name = \"Powertrain Subsystem\";\n            \n            part engine: FunctionalComponent {\n                attribute redefines name = \"Engine\";\n            }\n            \n            part transmission: FunctionalComponent {\n                attribute redefines name = \"Transmission\";\n            }\n        }\n    }\n    \n    view def HierarchicalView {\n        expose automotiveSystem.**;\n    }\n    \n    view def SafetyComponentsView {\n        filter automotiveSystem.** @ Component such that isSafetyRelated;\n    }\n    \n    view def NonSafetyComponentsView {\n        filter automotiveSystem.** @ Component such that !isSafetyRelated;\n    }\n}",
    "package 'AutomotiveDomain' {\n    import ScalarValues::*;\n    \n    doc /* This system model provides standardized definitions and annotations \n         * for fundamental concepts and elements in the automotive domain */\n    \n    attribute def Torque :> ISQ::TorqueValue {\n        doc /* Physical quantity representing rotational force (扭矩) */\n    }\n    \n    part def Automobile {\n        doc /* Core component representing a vehicle in the automotive domain */\n        alias Car;\n        \n        attribute torque : Torque {\n            doc /* Torque characteristic of the automobile */\n        }\n    }\n    \n    abstract part def AutomotiveComponent {\n        doc /* Base definition for automotive-related components to ensure \n             * standardization and extensibility */\n    }\n    \n    abstract attribute def AutomotiveCharacteristic {\n        doc /* Base definition for standardized expression of automotive \n             * characteristics and properties */\n    }\n}",
    "package 'DocumentManagementSystem' {\n    import ISQ::*;\n    \n    attribute def DocumentID;\n    attribute def DocumentContent;\n    attribute def QueryString;\n    attribute def ArchiveStatus;\n    \n    item def Automobile {\n        doc /* Core object for automobile documentation */\n        attribute torque : ISQ::TorqueValue;\n        attribute documentContent : DocumentContent;\n        attribute documentID : DocumentID;\n    }\n    \n    alias Car for Automobile {\n        doc /* Alternative reference for automobile object */\n    }\n    \n    port def DocumentInputPort {\n        in documentContent : DocumentContent;\n        in torque : ISQ::TorqueValue;\n    }\n    \n    port def QueryPort {\n        in queryString : QueryString;\n        out documentContent : DocumentContent;\n        out documentID : DocumentID;\n    }\n    \n    port def ArchivePort {\n        in documentID : DocumentID;\n        out archiveStatus : ArchiveStatus;\n    }\n    \n    part def DocumentManagementPlatform {\n        port documentInputPort : DocumentInputPort;\n        port queryPort : QueryPort;\n        port archivePort : ArchivePort;\n        \n        perform manageDocuments {\n            in inputContent = documentInputPort.documentContent;\n            in inputTorque = documentInputPort.torque;\n            in query = queryPort.queryString;\n            in archiveID = archivePort.documentID;\n            out queryResult = queryPort.documentContent;\n            out queryID = queryPort.documentID;\n            out archiveResult = archivePort.archiveStatus;\n        }\n    }\n    \n    part def User {\n        port documentInputPort : ~DocumentInputPort;\n        port queryPort : ~QueryPort;\n        port archivePort : ~ArchivePort;\n        \n        perform userOperations {\n            out documentContent = documentInputPort.documentContent;\n            out torque = documentInputPort.torque;\n            out queryString = queryPort.queryString;\n            in queryResult = queryPort.documentContent;\n            in queryID = queryPort.documentID;\n            out archiveID = archivePort.documentID;\n            in archiveStatus = archivePort.archiveStatus;\n        }\n    }\n    \n    action manageDocuments {\n        action enterInformation {\n            in documentContent : DocumentContent;\n            in torque : ISQ::TorqueValue;\n            out automobile : Automobile;\n        }\n        \n        action queryInformation {\n            in queryString : QueryString;\n            out documentContent : DocumentContent;\n            out documentID : DocumentID;\n        }\n        \n        action archiveInformation {\n            in documentID : DocumentID;\n            out archiveStatus : ArchiveStatus;\n        }\n        \n        flow enterFlow from enterInformation.automobile to queryInformation;\n        flow queryFlow from queryInformation to archiveInformation;\n    }\n}",
    "package 'AutomobileManagementSystem' {\n    import ScalarValues::*;\n    \n    attribute def TorqueValue :> ScalarQuantityValue;\n    alias Torque for TorqueValue;\n    \n    part def Automobile {\n        attribute torque : TorqueValue;\n    }\n    alias Car for Automobile;\n}",
    "package 'VehicleSystem' {\n    attribute def VehicleSize;\n    attribute def CylinderCount;\n    \n    part def Engine {\n        attribute cylinders : CylinderCount;\n    }\n    \n    part def Vehicle {\n        part engine : Engine;\n    }\n    \n    part def StandardVehicle :> Vehicle {\n        constraint { engine.cylinders >= 4 and engine.cylinders <= 6 }\n    }\n    \n    part def SmallVehicle :> Vehicle {\n        attribute size : VehicleSize = \"small\";\n        constraint { engine.cylinders == 4 }\n    }\n    \n    part def LargeVehicle :> Vehicle {\n        attribute size : VehicleSize = \"large\";\n        constraint { engine.cylinders == 6 }\n    }\n}",
    "package 'FuelManagementSystem' {\n\tattribute def Fuel;\n\tattribute def Temperature;\n\t\n\tport def FuelSupplyPort {\n\t\tout fuel : Fuel;\n\t}\n\t\n\tport def FuelReturnPort {\n\t\tin fuel : Fuel;\n\t}\n\t\n\tport def TemperaturePort {\n\t\tout temperature : Temperature;\n\t}\n\t\n\tpart context {\n\t\tpart fuelTank {\n\t\t\tport fuelSupplyPort : FuelSupplyPort;\n\t\t\tport fuelReturnPort : FuelReturnPort;\n\t\t\tport temperaturePort : TemperaturePort;\n\t\t\t\n\t\t\tperform manageFuelFlow.supplyFuel {\n\t\t\t\tout fuel = fuelSupplyPort.fuel;\n\t\t\t\tout temperature = temperaturePort.temperature;\n\t\t\t}\n\t\t\t\n\t\t\tperform manageFuelFlow.receiveFuel {\n\t\t\t\tin fuel = fuelReturnPort.fuel;\n\t\t\t}\n\t\t}\n\t\t\n\t\tinterface fuelSupplyInterface connect fuelTank.fuelSupplyPort to engine.fuelSupplyPort {\n\t\t\tref flow references manageFuelFlow.fuelSupplyFlow\n\t\t\t\tfrom source.fuel to target.fuel;\n\t\t}\n\t\t\n\t\tinterface fuelReturnInterface connect engine.fuelReturnPort to fuelTank.fuelReturnPort {\n\t\t\tref flow references manageFuelFlow.fuelReturnFlow\n\t\t\t\tfrom source.fuel to target.fuel;\n\t\t}\n\t\t\n\t\tinterface temperatureMonitorInterface connect fuelTank.temperaturePort to engine.temperaturePort {\n\t\t\tref flow references manageFuelFlow.temperatureFlow\n\t\t\t\tfrom source.temperature to target.temperature;\n\t\t}\n\t\t\n\t\tpart engine {\n\t\t\tport fuelSupplyPort : ~FuelSupplyPort;\n\t\t\tport fuelReturnPort : ~FuelReturnPort;\n\t\t\tport temperaturePort : ~TemperaturePort;\n\t\t\t\n\t\t\tperform manageFuelFlow.consumeFuel {\n\t\t\t\tin fuel = fuelSupplyPort.fuel;\n\t\t\t\tin temperature = temperaturePort.temperature;\n\t\t\t\tout fuel = fuelReturnPort.fuel;\n\t\t\t}\n\t\t}\n\t}\n\t\n\taction manageFuelFlow {\n\t\taction supplyFuel { out fuel : Fuel; out temperature : Temperature; }\n\t\tsuccession flow fuelSupplyFlow from supplyFuel.fuel to consumeFuel.fuel;\n\t\tsuccession flow temperatureFlow from supplyFuel.temperature to consumeFuel.temperature;\n\t\taction consumeFuel { in fuel : Fuel; in temperature : Temperature; out fuel : Fuel; }\n\t\tsuccession flow fuelReturnFlow from consumeFuel.fuel to receiveFuel.fuel;\n\t\taction receiveFuel { in fuel : Fuel; }\n\t}\n}",
    "package 'Vehicle Structure' {\n    attribute def MassValue;\n    attribute def SteeringAngle;\n    \n    part def Vehicle {\n        attribute mass : MassValue;\n        part frontAxleAssembly : AxleAssembly;\n        part rearAxleAssembly : AxleAssembly;\n    }\n    \n    part def AxleAssembly {\n        part axle : Axle;\n        part wheel1 : Wheel;\n        part wheel2 : Wheel;\n    }\n    \n    part def Axle;\n    \n    part def FrontAxle :> Axle {\n        attribute steeringAngle : SteeringAngle;\n    }\n    \n    part def RearAxle :> Axle;\n    \n    part def Wheel;\n    \n    part vehicle1 : Vehicle {\n        attribute :>> mass = 1750;\n        part :>> frontAxleAssembly {\n            part :>> axle : FrontAxle;\n            part leftWheel :>> wheel1;\n            part rightWheel :>> wheel2;\n        }\n        part :>> rearAxleAssembly {\n            part :>> axle : RearAxle;\n            part leftWheel :>> wheel1;\n            part rightWheel :>> wheel2;\n        }\n    }\n    \n    part vehicle2 : Vehicle {\n        attribute :>> mass = 2000;\n        part :>> frontAxleAssembly {\n            part :>> axle : FrontAxle;\n            part leftWheel :>> wheel1;\n            part rightWheel :>> wheel2;\n        }\n        part :>> rearAxleAssembly {\n            part :>> axle : RearAxle;\n            part leftWheel :>> wheel1;\n            part rightWheel :>> wheel2;\n        }\n    }\n}"
]