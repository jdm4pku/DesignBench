[
    "package VehicleManagementSystem {\n    \n    part def Vehicle {\n        attribute mass : Real;\n        part vehicleStatus : VehicleStatus;\n        part engine : Engine;\n        ref driver : Person[0..1];\n    }\n    \n    part def VehicleStatus {\n        attribute gearSetting : String;\n        attribute acceleratorPedalPosition : Real;\n    }\n    \n    part def Engine {\n        attribute engineID : String;\n    }\n    \n    part def Person {\n        attribute personID : String;\n    }\n}",
    "package VehicleSystem {\n    part def Personnel;\n    part def Engine;\n    \n    part def Vehicle;\n    \n    part def ManualVehicle :> Vehicle {\n        part driver : Personnel[1];\n    }\n    \n    part def PoweredVehicle :> Vehicle {\n        part engine : Engine[1];\n    }\n    \n    part def ManualPoweredVehicle :> ManualVehicle, PoweredVehicle;\n}",
    "package VehicleStructure {\n    \n    abstract part def VehicleComponent;\n    \n    part def Engine :> VehicleComponent;\n    \n    part def Transmission :> VehicleComponent;\n    \n    part def Wheel :> VehicleComponent;\n    \n    part def Vehicle {\n        part engine : Engine[1];\n        part transmission : Transmission[1];\n        part wheels : Wheel[4];\n    }\n}",
    "package VehicleSystem {\n    \n    part def Vehicle {\n        abstract;\n        part engine : Engine[1];\n    }\n    \n    part def SmallVehicle :> Vehicle {\n        part engine : SmallEngine[1] redefines Vehicle::engine;\n    }\n    \n    part def LargeVehicle :> Vehicle {\n        part engine : LargeEngine[1] redefines Vehicle::engine;\n    }\n    \n    part def Engine {\n        abstract;\n        part cylinders : Cylinder[*];\n    }\n    \n    part def SmallEngine :> Engine {\n        part cylinders : Cylinder[4] redefines Engine::cylinders;\n    }\n    \n    part def LargeEngine :> Engine {\n        part cylinders : Cylinder[6] redefines Engine::cylinders;\n    }\n    \n    part def Cylinder;\n    \n}",
    "package TrafficSignalSystem {\n    \n    enum def TrafficLightColor {\n        enum green;\n        enum yellow;\n        enum red;\n    }\n    \n    part def TrafficSignal {\n        attribute currentColor : TrafficLightColor;\n    }\n    \n    part def GreenTrafficSignal :> TrafficSignal {\n        attribute redefines currentColor : TrafficLightColor = TrafficLightColor::green;\n    }\n}",
    "package InformationClassificationSystem {\n    \n    enum def InformationClassificationLevel {\n        enum Unclassified;\n        enum Confidential;\n        enum Secret;\n    }\n    \n    enum def GradeLevel {\n        enum A;\n        enum B;\n        enum C;\n        enum D;\n        enum F;\n    }\n    \n    attribute def InformationClassification {\n        attribute level : InformationClassificationLevel;\n        attribute code : String;\n        attribute color : String;\n    }\n    \n    attribute def Grade {\n        attribute level : GradeLevel;\n        attribute points : Real;\n    }\n    \n    part def InformationClassificationManagementSystem {\n        attribute unclassifiedInfo : InformationClassification = InformationClassification {\n            :>> level = InformationClassificationLevel::Unclassified;\n            :>> code = \"uncl\";\n            :>> color = \"green\";\n        }\n        \n        attribute confidentialInfo : InformationClassification = InformationClassification {\n            :>> level = InformationClassificationLevel::Confidential;\n            :>> code = \"conf\";\n            :>> color = \"yellow\";\n        }\n        \n        attribute secretInfo : InformationClassification = InformationClassification {\n            :>> level = InformationClassificationLevel::Secret;\n            :>> code = \"secr\";\n            :>> color = \"red\";\n        }\n        \n        attribute gradeA : Grade = Grade {\n            :>> level = GradeLevel::A;\n            :>> points = 4.0;\n        }\n        \n        attribute gradeB : Grade = Grade {\n            :>> level = GradeLevel::B;\n            :>> points = 3.0;\n        }\n        \n        attribute gradeC : Grade = Grade {\n            :>> level = GradeLevel::C;\n            :>> points = 2.0;\n        }\n        \n        attribute gradeD : Grade = Grade {\n            :>> level = GradeLevel::D;\n            :>> points = 1.0;\n        }\n        \n        attribute gradeF : Grade = Grade {\n            :>> level = GradeLevel::F;\n            :>> points = 0.0;\n        }\n    }\n}",
    "package VehicleSystem {\n    part def Vehicle;\n    part def SmallVehicle :> Vehicle;\n    part def LargeVehicle :> Vehicle;\n    \n    part def Engine {\n        part cylinders : Cylinder[4..6];\n    }\n    \n    part def Cylinder;\n    \n    part smallVehicle : SmallVehicle {\n        part engine : Engine {\n            part redefines cylinders : Cylinder[4];\n        }\n    }\n    \n    part largeVehicle : LargeVehicle {\n        part engine : Engine {\n            part redefines cylinders : Cylinder[6];\n        }\n    }\n}",
    "package VehicleModelingSystem {\n    \n    part def Fuel {\n        attribute fuelType : String;\n        attribute octaneRating : Real;\n    }\n    \n    part def Person {\n        attribute name : String;\n        attribute licenseNumber : String;\n    }\n    \n    part def FuelTank {\n        attribute capacity : Real;\n        attribute currentLevel : Real;\n        ref storedFuel : Fuel;\n    }\n    \n    part def Vehicle {\n        attribute manufacturer : String;\n        attribute model : String;\n        attribute year : Integer;\n        attribute weight : Real;\n        attribute maxSpeed : Real;\n        \n        ref driver : Person;\n        part fuelTank : FuelTank;\n    }\n}",
    "package WheelAssemblyStructure {\n    \n    part def WheelAssembly {\n        part wheelBearingUnit : WheelBearingUnit;\n        part tire : Tire;\n        part hub : Hub;\n        part boltConnections : BoltConnection[1..*];\n        \n        connection : BeadRimConnection connect tire.beads to hub.rims;\n        connection : BoltMounting connect hub.mountingHoles to hub.threadedHoles via boltConnections;\n    }\n    \n    part def WheelBearingUnit;\n    \n    part def Tire {\n        part beads : Bead[2];\n    }\n    \n    part def Bead;\n    \n    part def Hub {\n        part rims : Rim[2];\n        part mountingHoles : BoltMountingHole[1..*];\n        part threadedHoles : ThreadedHole[1..*];\n    }\n    \n    part def Rim;\n    \n    part def BoltMountingHole;\n    \n    part def ThreadedHole;\n    \n    part def BoltConnection;\n    \n    connection def BeadRimConnection {\n        end bead : Bead[2];\n        end rim : Rim[2];\n    }\n    \n    connection def BoltMounting {\n        end mountingHole : BoltMountingHole[1..*];\n        end threadedHole : ThreadedHole[1..*];\n        end bolt : BoltConnection[1..*];\n    }\n}",
    "package FuelFlowManagementSystem {\n    \n    part def FuelTankAssembly {\n        port fuelSupplyPort : FuelFlowPort;\n        port fuelReturnPort : FuelFlowPort;\n        \n        attribute fuelLevel : Real;\n        attribute temperature : Real;\n    }\n    \n    part def Engine {\n        port fuelInletPort : ~FuelFlowPort;\n        port fuelReturnPort : ~FuelFlowPort;\n        \n        attribute operatingStatus : String;\n        attribute fuelConsumptionRate : Real;\n    }\n    \n    port def FuelFlowPort {\n        attribute flowRate : Real;\n        attribute temperature : Real;\n        attribute pressure : Real;\n    }\n    \n    interface def FuelTransferInterface {\n        end supplierPort : FuelFlowPort;\n        end consumerPort : ~FuelFlowPort;\n        \n        flow of Fuel from supplierPort to consumerPort;\n        flow of TemperatureData from supplierPort to consumerPort;\n    }\n    \n    item def Fuel {\n        attribute volume : Real;\n        attribute temperature : Real;\n    }\n    \n    item def TemperatureData {\n        attribute value : Real;\n        attribute timestamp : String;\n    }\n    \n    part fuelFlowSystem : FuelFlowManagementSystem {\n        part fuelTank : FuelTankAssembly;\n        part engine : Engine;\n        \n        interface fuelSupplyInterface : FuelTransferInterface \n            connect fuelTank.fuelSupplyPort to engine.fuelInletPort;\n            \n        interface fuelReturnInterface : FuelTransferInterface \n            connect engine.fuelReturnPort to fuelTank.fuelReturnPort;\n    }\n    \n    part def FuelFlowManagementSystem {\n        part fuelTankAssembly : FuelTankAssembly;\n        part engineUnit : Engine;\n        \n        attribute systemStatus : String;\n        attribute totalFuelFlow : Real;\n    }\n}",
    "package VehicleConfigurationModel {\n    \n    part def Vehicle {\n        attribute mass : Real default 1750.0;\n        part frontAxle : Axle[1];\n        part rearAxle : Axle[1];\n    }\n    \n    part def Axle {\n        attribute mass : Real;\n        part tires : Tire[2] ordered;\n    }\n    \n    part def FrontAxle :> Axle {\n        attribute steeringAngle : Real;\n    }\n    \n    part def RearAxle :> Axle {\n    }\n    \n    part def Tire {\n        attribute mass : Real;\n    }\n    \n    part vehicle1_c1 : Vehicle {\n        attribute redefines mass = 2000.0;\n        part redefines frontAxle : FrontAxle;\n    }\n}",
    "package CouplingSystem {\n    \n    part def Vehicle {\n        ref hitch : Hitch;\n    }\n    \n    part def Trailer {\n        ref connector : Connector;\n    }\n    \n    part def Hitch {\n        part ball : CouplingBall;\n        part connector : Connector;\n    }\n    \n    part def CouplingBall;\n    \n    part def Connector;\n    \n    part def CouplingMechanism {\n        part vehicle : Vehicle;\n        part trailer : Trailer;\n        part hitch : Hitch;\n        \n        bind vehicle.hitch = hitch;\n        bind trailer.connector = hitch.connector;\n    }\n}",
    "package VehiclePowerTransmissionSystem {\n    \n    port def PowerPort {\n        in item power : Real;\n    }\n    \n    port def ControlPort {\n        in item command : Real;\n    }\n    \n    port def MechanicalPort {\n        in item torque : Real;\n        in item speed : Real;\n    }\n    \n    port def RoadInterface {\n        out item force : Real;\n        in item resistance : Real;\n    }\n    \n    part def Engine {\n        port fuelCommand : ControlPort;\n        port powerOut : PowerPort;\n        port clutchConnection : MechanicalPort;\n    }\n    \n    part def Clutch {\n        port engineSide : MechanicalPort;\n        port transmissionSide : MechanicalPort;\n    }\n    \n    part def Transmission {\n        port clutchIn : MechanicalPort;\n        port driveshaftOut : MechanicalPort;\n    }\n    \n    part def Driveshaft {\n        port transmissionIn : MechanicalPort;\n        port rearAxleOut : MechanicalPort;\n    }\n    \n    part def Differential {\n        port driveshaftIn : MechanicalPort;\n        port leftOut : MechanicalPort;\n        port rightOut : MechanicalPort;\n    }\n    \n    part def Halfshaft {\n        port differentialIn : MechanicalPort;\n        port wheelOut : MechanicalPort;\n    }\n    \n    part def Wheel {\n        port axleIn : MechanicalPort;\n        port road : RoadInterface;\n    }\n    \n    part def RearAxleAssembly {\n        part differential : Differential;\n        part leftHalfshaft : Halfshaft;\n        part rightHalfshaft : Halfshaft;\n        \n        port driveshaftIn : MechanicalPort;\n        port leftWheelOut : MechanicalPort;\n        port rightWheelOut : MechanicalPort;\n        \n        connection : Connect driveshaftIn to differential.driveshaftIn;\n        connection : Connect differential.leftOut to leftHalfshaft.differentialIn;\n        connection : Connect differential.rightOut to rightHalfshaft.differentialIn;\n        connection : Connect leftHalfshaft.wheelOut to leftWheelOut;\n        connection : Connect rightHalfshaft.wheelOut to rightWheelOut;\n    }\n    \n    part def VehiclePowerSystem {\n        part engine : Engine;\n        part clutch : Clutch;\n        part transmission : Transmission;\n        part driveshaft : Driveshaft;\n        part rearAxle : RearAxleAssembly;\n        part leftRearWheel : Wheel;\n        part rightRearWheel : Wheel;\n        \n        port fuelCommand : ControlPort;\n        port leftRoadInterface : RoadInterface;\n        port rightRoadInterface : RoadInterface;\n        \n        connection : Connect fuelCommand to engine.fuelCommand;\n        connection : Connect engine.clutchConnection to clutch.engineSide;\n        connection : Connect clutch.transmissionSide to transmission.clutchIn;\n        connection : Connect transmission.driveshaftOut to driveshaft.transmissionIn;\n        connection : Connect driveshaft.rearAxleOut to rearAxle.driveshaftIn;\n        connection : Connect rearAxle.leftWheelOut to leftRearWheel.axleIn;\n        connection : Connect rearAxle.rightWheelOut to rightRearWheel.axleIn;\n        connection : Connect leftRearWheel.road to leftRoadInterface;\n        connection : Connect rightRearWheel.road to rightRoadInterface;\n    }\n}",
    "package SystemModel {\n    \n    part def C1 {\n        port pb;\n    }\n    \n    part def C2 {\n        port pc;\n    }\n    \n    part def C3 {\n        port pd;\n    }\n    \n    part def C4 {\n        port pe;\n    }\n    \n    part def B11 {\n        part c1 : C1;\n        part c2 : C2;\n        port pe;\n        \n        connect c1.pb to c2.pc;\n        bind pe = c1.pb;\n    }\n    \n    part def B12 {\n        part c3 : C3;\n        part c4 : C4;\n        port pf;\n        \n        bind pf = c3.pd;\n    }\n    \n    part def System {\n        part b11 : B11;\n        part b12 : B12;\n        \n        connect b11.pe to b12.pf;\n    }\n    \n    part def B21 {\n        ref part c1 : C1;\n        ref part c2 : C2;\n        ref part c3 : C3;\n        ref part c4 : C4;\n    }\n    \n    part def B22 {\n        ref part c1 : C1;\n        ref part c2 : C2;\n        ref part c3 : C3;\n        ref part c4 : C4;\n    }\n    \n    part def SystemAlternative {\n        part b21 : B21;\n        part b22 : B22;\n    }\n}",
    "package PowertrainSystem {\n    \n    part def FuelCommand;\n    part def EngineStartCommand;\n    part def EngineStopCommand;\n    part def Torque;\n    part def DrivingForce;\n    \n    part def Engine {\n        port fuelCmdIn : FuelCommand;\n        port startCmdIn : EngineStartCommand;\n        port stopCmdIn : EngineStopCommand;\n        port torqueOut : Torque;\n    }\n    \n    part def Transmission {\n        port torqueIn : Torque;\n        port torqueOut : Torque;\n    }\n    \n    part def Driveshaft {\n        port torqueIn : Torque;\n        port torqueOut : Torque;\n    }\n    \n    part def Wheel {\n        port torqueIn : Torque;\n        port forceOut : DrivingForce;\n    }\n    \n    part def PowertrainControlSystem {\n        part engine : Engine;\n        part transmission : Transmission;\n        part driveshaft : Driveshaft;\n        part leftWheel : Wheel;\n        part rightWheel : Wheel;\n        \n        port fuelCommandInput : FuelCommand;\n        port engineStartInput : EngineStartCommand;\n        port engineStopInput : EngineStopCommand;\n        port leftWheelForce : DrivingForce;\n        port rightWheelForce : DrivingForce;\n        \n        connect fuelCommandInput to engine.fuelCmdIn;\n        connect engineStartInput to engine.startCmdIn;\n        connect engineStopInput to engine.stopCmdIn;\n        connect engine.torqueOut to transmission.torqueIn;\n        connect transmission.torqueOut to driveshaft.torqueIn;\n        connect driveshaft.torqueOut to leftWheel.torqueIn;\n        connect driveshaft.torqueOut to rightWheel.torqueIn;\n        connect leftWheel.forceOut to leftWheelForce;\n        connect rightWheel.forceOut to rightWheelForce;\n    }\n}",
    "package PowertrainSystem {\n    \n    part def FuelController {\n        in port fuelCommand;\n        out port startSignal;\n        out port fuelFlow;\n    }\n    \n    part def Engine {\n        in port startSignal;\n        in port fuelFlow;\n        in port stallSignal;\n        out port torqueOutput;\n    }\n    \n    part def TorqueAmplifier {\n        in port torqueInput;\n        out port amplifiedTorque;\n    }\n    \n    part def Transmission {\n        in port torqueInput;\n        out port transmittedTorque;\n    }\n    \n    part def TorqueDistributor {\n        in port torqueInput;\n        out port wheelTorque;\n    }\n    \n    part def DriveWheels {\n        in port wheelTorque;\n    }\n    \n    part def StallDetector {\n        out port stallSignal;\n    }\n    \n    part def PowertrainControlSystem {\n        part fuelController : FuelController;\n        part engine : Engine;\n        part torqueAmplifier : TorqueAmplifier;\n        part transmission : Transmission;\n        part torqueDistributor : TorqueDistributor;\n        part driveWheels : DriveWheels;\n        part stallDetector : StallDetector;\n        \n        connection : fuelController.startSignal to engine.startSignal;\n        connection : fuelController.fuelFlow to engine.fuelFlow;\n        connection : engine.torqueOutput to torqueAmplifier.torqueInput;\n        connection : torqueAmplifier.amplifiedTorque to transmission.torqueInput;\n        connection : transmission.transmittedTorque to torqueDistributor.torqueInput;\n        connection : torqueDistributor.wheelTorque to driveWheels.wheelTorque;\n        connection : stallDetector.stallSignal to engine.stallSignal;\n    }\n}",
    "package VehiclePowertrainSystem {\n    \n    part def Driver {\n        attribute fuelCommand : Real;\n        port fuelOutput : ~FuelCommandInterface;\n    }\n    \n    part def Engine {\n        attribute outputTorque : Real;\n        attribute isRunning : Boolean;\n        port fuelInput : FuelCommandInterface;\n        port startSignal : ControlSignalInterface;\n        port shutdownSignal : ControlSignalInterface;\n        port torqueOutput : ~TorqueInterface;\n    }\n    \n    part def Transmission {\n        attribute amplificationRatio : Real;\n        port torqueInput : TorqueInterface;\n        port torqueOutput : ~TorqueInterface;\n    }\n    \n    part def Wheel {\n        attribute receivedTorque : Real;\n        port torqueInput : TorqueInterface;\n    }\n    \n    part def PowertrainController {\n        port engineStart : ~ControlSignalInterface;\n        port engineShutdown : ~ControlSignalInterface;\n    }\n    \n    interface def FuelCommandInterface {\n        attribute fuelValue : Real;\n    }\n    \n    interface def TorqueInterface {\n        attribute torqueValue : Real;\n    }\n    \n    interface def ControlSignalInterface {\n        attribute signal : Boolean;\n    }\n    \n    part vehiclePowertrainSystem {\n        part driver : Driver;\n        part engine : Engine;\n        part transmission : Transmission;\n        part frontLeftWheel : Wheel;\n        part frontRightWheel : Wheel;\n        part rearLeftWheel : Wheel;\n        part rearRightWheel : Wheel;\n        part controller : PowertrainController;\n        \n        connect driver.fuelOutput to engine.fuelInput;\n        connect controller.engineStart to engine.startSignal;\n        connect controller.engineShutdown to engine.shutdownSignal;\n        connect engine.torqueOutput to transmission.torqueInput;\n        connect transmission.torqueOutput to frontLeftWheel.torqueInput;\n        connect transmission.torqueOutput to frontRightWheel.torqueInput;\n        connect transmission.torqueOutput to rearLeftWheel.torqueInput;\n        connect transmission.torqueOutput to rearRightWheel.torqueInput;\n    }\n}",
    "package PowerConnectionSystem {\n    \n    part def Vehicle {\n        part vehicleFrame : VehicleFrame;\n        part hitchBall : HitchBall;\n    }\n    \n    part def Trailer {\n        part trailerFrame : TrailerFrame;\n        part trailerCoupler : TrailerCoupler;\n    }\n    \n    part def VehicleFrame;\n    part def TrailerFrame;\n    part def HitchBall;\n    part def TrailerCoupler;\n    \n    part def PowerConnectionMechanism {\n        part vehicle : Vehicle;\n        part trailer : Trailer;\n        \n        attribute connectionStatus : String;\n    }\n    \n    action def Connect {\n        in vehicle : Vehicle;\n        in trailer : Trailer;\n        out result : String;\n    }\n    \n    action def Disconnect {\n        in vehicle : Vehicle;\n        in trailer : Trailer;\n        out result : String;\n    }\n    \n    part powerSystem : PowerConnectionMechanism {\n        action connectTrailer : Connect {\n            in vehicle = powerSystem.vehicle;\n            in trailer = powerSystem.trailer;\n        }\n        \n        action disconnectTrailer : Disconnect {\n            in vehicle = powerSystem.vehicle;\n            in trailer = powerSystem.trailer;\n        }\n    }\n}",
    "package TrailerConnectionSystem {\n    \n    part def Vehicle {\n        part chassis : Chassis;\n        part towBall : TowBall;\n    }\n    \n    part def Trailer {\n        part coupler : Coupler;\n        part trailerFrame : TrailerFrame;\n    }\n    \n    part def Chassis;\n    part def TowBall;\n    part def Coupler;\n    part def TrailerFrame;\n    \n    part def ConnectionSystem {\n        part vehicle : Vehicle;\n        part trailer : Trailer;\n        \n        port vehicleConnection : VehicleConnectionPort;\n        port trailerConnection : TrailerConnectionPort;\n    }\n    \n    port def VehicleConnectionPort;\n    port def TrailerConnectionPort;\n    \n    action def Connect {\n        in vehicle : Vehicle;\n        in trailer : Trailer;\n        out connectionStatus : Boolean;\n    }\n    \n    action def Disconnect {\n        in vehicle : Vehicle;\n        in trailer : Trailer;\n        out connectionStatus : Boolean;\n    }\n    \n    part connectionSystemInstance : ConnectionSystem {\n        perform connect : Connect {\n            in vehicle = connectionSystemInstance.vehicle;\n            in trailer = connectionSystemInstance.trailer;\n        }\n        \n        perform disconnect : Disconnect {\n            in vehicle = connectionSystemInstance.vehicle;\n            in trailer = connectionSystemInstance.trailer;\n        }\n    }\n}",
    "package VehicleTrailerSystem {\n    \n    part def Vehicle {\n        part chassis : Chassis;\n        part towBall : TowBall;\n    }\n    \n    part def Trailer {\n        part trailerChassis : TrailerChassis;\n        part couplerMechanism : CouplerMechanism;\n    }\n    \n    part def Chassis;\n    part def TrailerChassis;\n    part def TowBall;\n    \n    part def CouplerMechanism {\n        attribute isEngaged : Boolean = false;\n    }\n    \n    connection def TowConnection {\n        end vehicle : TowBall[1];\n        end trailer : CouplerMechanism[1];\n    }\n    \n    action def Hitch {\n        in vehicle : Vehicle;\n        in trailer : Trailer;\n        out connection : TowConnection;\n    }\n    \n    action def Unhitch {\n        in connection : TowConnection;\n        out vehicle : Vehicle;\n        out trailer : Trailer;\n    }\n    \n    part vehicleTrailerSystem : VehicleTrailerSystem {\n        part vehicle : Vehicle;\n        part trailer : Trailer;\n        \n        connection towConnection : TowConnection connect \n            vehicle.towBall to trailer.couplerMechanism;\n        \n        action hitchTrailer : Hitch {\n            in vehicle = vehicleTrailerSystem.vehicle;\n            in trailer = vehicleTrailerSystem.trailer;\n            out connection = vehicleTrailerSystem.towConnection;\n        }\n        \n        action unhitchTrailer : Unhitch {\n            in connection = vehicleTrailerSystem.towConnection;\n            out vehicle = vehicleTrailerSystem.vehicle;\n            out trailer = vehicleTrailerSystem.trailer;\n        }\n    }\n}",
    "package FuelSystem {\n    \n    part def FuelTankAssembly {\n        port fuelSupplyPort : FuelFlowPort;\n        port fuelReturnPort : FuelFlowPort;\n        \n        attribute fuelLevel : Real;\n        attribute fuelTemperature : Real;\n    }\n    \n    part def Engine {\n        port fuelInletPort : FuelFlowPort;\n        port fuelReturnPort : FuelFlowPort;\n        \n        attribute fuelConsumptionRate : Real;\n    }\n    \n    port def FuelFlowPort {\n        attribute flowRate : Real;\n        attribute temperature : Real;\n        attribute pressure : Real;\n    }\n    \n    interface def FuelFlowInterface {\n        end supplierPort : FuelFlowPort;\n        end consumerPort : FuelFlowPort;\n    }\n    \n    part def VehicleFuelSystem {\n        part fuelTank : FuelTankAssembly;\n        part engine : Engine;\n        \n        interface fuelSupplyInterface : FuelFlowInterface connect \n            fuelTank.fuelSupplyPort to engine.fuelInletPort;\n            \n        interface fuelReturnInterface : FuelFlowInterface connect \n            engine.fuelReturnPort to fuelTank.fuelReturnPort;\n    }\n}",
    "package FuelDeliverySystem {\n    \n    part def StorageTank {\n        attribute fuelLevel : Real;\n        attribute maxCapacity : Real;\n        \n        port fuelOutput : FuelPort;\n    }\n    \n    part def FuelPump {\n        port fuelInput : FuelPort;\n        port fuelOutput : FuelPort;\n    }\n    \n    part def VehicleFuelTank {\n        attribute currentFuelLevel : Real;\n        attribute maxCapacity : Real;\n        \n        port fuelInput : FuelPort;\n    }\n    \n    part def Vehicle {\n        part vehicleFuelTank : VehicleFuelTank;\n    }\n    \n    port def FuelPort {\n        attribute flowRate : Real;\n    }\n    \n    part def FuelDeliverySystem {\n        part storageTank : StorageTank;\n        part fuelPump : FuelPump;\n        part vehicle : Vehicle;\n        \n        interface storageTankToFuelPump connect \n            storageTank.fuelOutput to fuelPump.fuelInput;\n            \n        interface fuelPumpToVehicle connect \n            fuelPump.fuelOutput to vehicle.vehicleFuelTank.fuelInput;\n    }\n}",
    "package AutomobileAssemblyModel {\n    \n    part def VehicleAssembly {\n        attribute vin : String;\n        attribute assemblyStatus : String;\n    }\n    \n    part def Gearbox {\n        attribute serialNumber : String;\n        attribute type : String;\n    }\n    \n    part def Engine {\n        attribute serialNumber : String;\n        attribute displacement : Real;\n        attribute type : String;\n    }\n    \n    part def AssemblyWithoutEngine :> VehicleAssembly {\n        part gearbox : Gearbox;\n    }\n    \n    part def FullyAssembledVehicle :> VehicleAssembly {\n        part gearbox : Gearbox;\n        part engine : Engine;\n    }\n    \n    action def InstallGearbox {\n        in vehicleWithoutGearboxEngine : VehicleAssembly;\n        in gearboxToInstall : Gearbox;\n        out vehicleWithGearbox : AssemblyWithoutEngine;\n    }\n    \n    action def InstallEngine {\n        in vehicleWithGearbox : AssemblyWithoutEngine;\n        in engineToInstall : Engine;\n        out completeVehicle : FullyAssembledVehicle;\n    }\n    \n    action def AssembleVehicle {\n        in baseVehicle : VehicleAssembly;\n        in gearbox : Gearbox;\n        in engine : Engine;\n        out assembledVehicle : FullyAssembledVehicle;\n        \n        action installGearboxStep : InstallGearbox {\n            in vehicleWithoutGearboxEngine = baseVehicle;\n            in gearboxToInstall = gearbox;\n        }\n        \n        then action installEngineStep : InstallEngine {\n            in vehicleWithGearbox = installGearboxStep.vehicleWithGearbox;\n            in engineToInstall = engine;\n        }\n        \n        bind assembledVehicle = installEngineStep.completeVehicle;\n    }\n}",
    "package VehicleControlSystem {\n    \n    part def VehicleA {\n        attribute temperature : Real;\n        attribute brakePedalPressed : Boolean;\n        attribute startSignalReceived : Boolean;\n        attribute vehicleOnSignalReceived : Boolean;\n        attribute overTempSignalSent : Boolean;\n        attribute restoreSignalReceived : Boolean;\n        attribute safetyThreshold : Real = 85.0;\n        \n        port healthOutput : Real;\n        port controlInput : ControlSignal;\n        port controlOutput : ControlSignal;\n    }\n    \n    part def VehicleController {\n        port commandInput : ControlSignal;\n        port commandOutput : ControlSignal;\n    }\n    \n    part def ControlSignal {\n        attribute signalType : String;\n        attribute value : Boolean;\n    }\n    \n    state def VehicleStates {\n        entry state off;\n        state starting;\n        state running {\n            entry action {\n                doc /* Perform self-checks */\n                doc /* Supply power to vehicle */\n            }\n            exit action {\n                doc /* Apply parking brake */\n            }\n        }\n        state healthManagement {\n            state normal;\n            state degraded;\n            state maintenance;\n            \n            transition normal_to_degraded\n                first normal\n                then degraded\n                guard temperature > safetyThreshold\n                effect overTempSignalSent := true;\n                \n            transition degraded_to_normal\n                first degraded\n                then normal\n                guard restoreSignalReceived;\n                \n            transition maintenance_to_normal\n                first maintenance\n                then normal\n                guard restoreSignalReceived;\n        }\n        \n        transition off_to_starting\n            first off\n            then starting\n            guard brakePedalPressed & startSignalReceived;\n            \n        transition starting_to_running\n            first starting\n            then running\n            guard vehicleOnSignalReceived;\n            \n        transition running_to_off\n            first running\n            then off;\n    }\n    \n    state def ControllerStates {\n        entry state idle;\n        state active;\n        state shutdown;\n        \n        transition idle_to_active\n            first idle\n            then active\n            guard startSignalReceived;\n            \n        transition active_to_shutdown\n            first active\n            then shutdown;\n            \n        transition shutdown_to_idle\n            first shutdown\n            then idle;\n    }\n    \n    part vehicleSystem : VehicleControlSystem {\n        part vehicle : VehicleA {\n            exhibit state vehicleStates : VehicleStates;\n        }\n        \n        part controller : VehicleController {\n            exhibit state controllerStates : ControllerStates;\n        }\n        \n        connection : Connect\n            from vehicle.controlOutput\n            to controller.commandInput;\n            \n        connection : Connect\n            from controller.commandOutput\n            to vehicle.controlInput;\n            \n        action monitorHealth {\n            in item temp : Real = vehicle.temperature;\n            out item healthStatus : Real;\n            \n            healthStatus := temp;\n            vehicle.healthOutput := healthStatus;\n        }\n    }\n}",
    "package VehicleSystem {\n    \n    part def Vehicle {\n        attribute fuel : Real;\n        attribute maintenanceInterval : Real;\n        attribute temperatureThreshold : Real;\n        attribute currentTemperature : Real;\n        attribute isOverheating : Boolean;\n        \n        port vehicleStatusPort : VehicleStatusPort;\n        port controlPort : ControlPort;\n        port sensorPort : SensorPort;\n    }\n    \n    part def VehicleController {\n        port statusReceivePort : VehicleStatusPort;\n        port controlSendPort : ControlPort;\n    }\n    \n    port def VehicleStatusPort {\n        out statusSignal : StatusSignal;\n        out warningSignal : WarningSignal;\n    }\n    \n    port def ControlPort {\n        in startSignal : StartSignal;\n        in shutdownSignal : ShutdownSignal;\n        in brakePedalPressed : Boolean;\n    }\n    \n    port def SensorPort {\n        in temperatureReading : Real;\n    }\n    \n    enum def VehicleState {\n        enum shutdown;\n        enum normal;\n        enum degraded;\n    }\n    \n    item def StatusSignal {\n        attribute state : VehicleState;\n    }\n    \n    item def WarningSignal {\n        attribute warningType : String;\n    }\n    \n    item def StartSignal;\n    item def ShutdownSignal;\n    \n    state def VehicleStateMachine {\n        entry state shutdown;\n        state normal;\n        state degraded;\n        \n        transition startup\n            first shutdown\n            then normal\n            guard brakePedalPressed and startSignalReceived;\n            \n        transition overheatDetected\n            first normal\n            then degraded\n            guard isOverheating;\n            \n        transition recovered\n            first degraded\n            then normal\n            guard not isOverheating;\n            \n        transition shutdownTransition\n            first normal\n            then shutdown\n            guard shutdownSignalReceived;\n    }\n    \n    action def SelfInspection {\n        in vehicle : Vehicle;\n        out inspectionPassed : Boolean;\n    }\n    \n    action def PowerSupplyProcedure {\n        in vehicle : Vehicle;\n        out powerSupplied : Boolean;\n    }\n    \n    action def SendWarning {\n        in warningType : String;\n        out warning : WarningSignal;\n    }\n    \n    action def PerformMaintenance {\n        in vehicle : Vehicle;\n        out maintenanceCompleted : Boolean;\n    }\n    \n    action def FaultRecovery {\n        in vehicle : Vehicle;\n        out recoveryCompleted : Boolean;\n    }\n    \n    part vehicleSystemModel : Vehicle {\n        part controller : VehicleController;\n        \n        connection : Connect(\n            vehicleStatusPort, \n            controller.statusReceivePort\n        );\n        \n        connection : Connect(\n            controller.controlSendPort,\n            controlPort\n        );\n    }\n}",
    "package VehicleDynamicsSimulation {\n    import ScalarValues::*;\n    import Quantities::*;\n    import MeasurementReferences::*;\n    import ISQ::*;\n    import SI::*;\n    \n    attribute def VehicleState {\n        attribute isOn : Boolean;\n    }\n    \n    attribute def RoadProperties {\n        attribute slope : Real;\n        attribute frictionCoefficient : Real;\n    }\n    \n    part def Vehicle {\n        attribute mass : MassValue;\n        attribute position : LengthValue[3];\n        attribute velocity : SpeedValue[3];\n        attribute acceleration : AccelerationValue[3];\n        attribute state : VehicleState;\n    }\n    \n    part def Road {\n        attribute properties : RoadProperties;\n    }\n    \n    part def SimulationSnapshot {\n        attribute timePoint : TimeValue;\n        attribute vehicleData : Vehicle;\n        attribute roadData : Road;\n    }\n    \n    part def SimulationTimeSeries {\n        attribute startTime : TimeValue;\n        attribute endTime : TimeValue;\n        attribute snapshots : SimulationSnapshot[*] ordered;\n    }\n    \n    part def VehicleDynamicsSimulationSystem {\n        part vehicle : Vehicle;\n        part road : Road;\n        part timeSeries : SimulationTimeSeries;\n        \n        attribute def SimulationParameters {\n            attribute timeStep : TimeValue;\n            attribute totalDuration : TimeValue;\n        }\n        \n        attribute simulationParams : SimulationParameters;\n    }\n}",
    "package AutomotiveConfigurationSystem {\n    \n    part def Component1;\n    part def Component2;\n    part def Component3;\n    part def Component4;\n    part def Component5;\n    part def Component6;\n    \n    part def SubsystemA {\n        variant part config1 {\n            part c1 : Component1;\n            part c2 : Component2;\n        }\n        variant part config2 {\n            part c2 : Component2;\n            part c3 : Component3;\n        }\n    }\n    \n    part def SubsystemB {\n        variant part config1 {\n            part c4 : Component4;\n            part c5 : Component5;\n        }\n        variant part config2 {\n            part c5 : Component5;\n            part c6 : Component6;\n        }\n    }\n    \n    part def Automobile {\n        part subsystemA : SubsystemA;\n        part subsystemB : SubsystemB;\n        \n        constraint configurationConstraint {\n            (subsystemA.config2 == null) or (subsystemB.config1 != null);\n        }\n    }\n    \n    part configurationA : Automobile {\n        part :>> subsystemA {\n            part :>> config1;\n        }\n        part :>> subsystemB {\n            part :>> config1;\n        }\n    }\n    \n    part configurationB : Automobile {\n        part :>> subsystemA {\n            part :>> config2;\n        }\n        part :>> subsystemB {\n            part :>> config1;\n        }\n    }\n}",
    "package VehicleSystem {\n    \n    part def Part1;\n    part def Part2;\n    part def Part3 {\n        port p1;\n    }\n    part def Part4;\n    part def Part5 {\n        port p2;\n    }\n    part def Part6;\n    \n    abstract part def SubsystemA {\n        abstract part components[*];\n        abstract port subsystemPortA;\n    }\n    \n    abstract part def SubsystemB {\n        abstract part components[*];\n        abstract port subsystemPortB;\n    }\n    \n    part def SubsystemAVariant1 :> SubsystemA {\n        part components[2] {\n            part component1 : Part1;\n            part component2 : Part3;\n        }\n    }\n    \n    part def SubsystemAVariant2 :> SubsystemA {\n        part components[3] {\n            part component1 : Part2;\n            part component2 : Part4;\n            part component3 : Part5;\n        }\n    }\n    \n    part def SubsystemBVariant1 :> SubsystemB {\n        part components[2] {\n            part component1 : Part5;\n            part component2 : Part6;\n        }\n    }\n    \n    part def SubsystemBVariant2 :> SubsystemB {\n        part components[3] {\n            part component1 : Part3;\n            part component2 : Part4;\n            part component3 : Part6;\n        }\n    }\n    \n    abstract part def VehiclePlatform {\n        abstract part subsystemA : SubsystemA;\n        abstract part subsystemB : SubsystemB;\n        \n        abstract connection subsystemConnection connect subsystemA.subsystemPortA to subsystemB.subsystemPortB;\n    }\n    \n    part def VehicleConfigA :> VehiclePlatform {\n        part subsystemA : SubsystemAVariant1;\n        part subsystemB : SubsystemBVariant1;\n    }\n    \n    part def VehicleConfigB :> VehiclePlatform {\n        part subsystemA : SubsystemAVariant2;\n        part subsystemB : SubsystemBVariant2;\n    }\n}",
    "package VehicleProductLineSystem {\n    \n    part def Vehicle {\n        part engine : Engine[1];\n        part transmission : Transmission[1];\n        part wheels : Wheels[1];\n        \n        attribute performanceLevel : String;\n    }\n    \n    part def Engine {\n        attribute cylinders : Integer;\n        attribute engineType : String;\n    }\n    \n    part def Transmission {\n        attribute transmissionType : String;\n        attribute gears : Integer;\n    }\n    \n    part def Wheels {\n        attribute rimType : String;\n        attribute rimWidth : Real;\n    }\n    \n    part def VehicleConfiguration {\n        part vehicle : Vehicle[1];\n        \n        constraint highPerformanceConfig {\n            doc /* High performance configuration constraint */\n            \n            (vehicle.performanceLevel == \"high\") implies \n            (vehicle.engine.cylinders == 6 and \n             vehicle.transmission.transmissionType == \"automatic\" and\n             vehicle.wheels.rimType == \"wide\")\n        }\n        \n        constraint standardPerformanceConfig {\n            doc /* Standard performance configuration constraint */\n            \n            (vehicle.performanceLevel == \"standard\") implies\n            (vehicle.engine.cylinders == 4 and\n             vehicle.transmission.transmissionType == \"manual\" and\n             vehicle.wheels.rimType == \"narrow\")\n        }\n        \n        constraint engineTransmissionCompatibility {\n            doc /* Engine and transmission compatibility constraint */\n            \n            (vehicle.engine.cylinders == 6) implies \n            (vehicle.transmission.transmissionType == \"automatic\")\n        }\n        \n        constraint wheelEngineCompatibility {\n            doc /* Wheel and engine compatibility constraint */\n            \n            (vehicle.engine.cylinders == 6) implies\n            (vehicle.wheels.rimType == \"wide\")\n        }\n    }\n    \n    part def ProductLineManager {\n        part configurations : VehicleConfiguration[*];\n        \n        attribute marketDemand : String[*];\n        attribute modelVariants : String[*];\n    }\n}",
    "package VehicleManagementSystem {\n    import ScalarValues::*;\n    \n    // Value types and units\n    attribute def MassValue :> Real {\n        attribute unit : String = \"kg\";\n    }\n    \n    attribute def TorqueValue :> Real {\n        attribute unit : String = \"Nm\";\n    }\n    \n    // Enumerations\n    enum def FuelStatus {\n        enum fullFuel;\n        enum emptyFuel;\n    }\n    \n    enum def MassGrade {\n        enum grade2000kg;\n        enum grade2500kg;\n    }\n    \n    // Part definitions\n    part def Vehicle {\n        attribute actualMass : MassValue;\n        attribute maximumMass : MassValue;\n        attribute fuelStatus : FuelStatus;\n        attribute massGrade : MassGrade;\n        \n        part engine : Engine;\n        part transmission : Transmission;\n        \n        interface driveInterface : DriveInterface connect engine to transmission;\n    }\n    \n    part def Engine {\n        attribute outputTorque : TorqueValue;\n        \n        port torqueOutput : TorquePort;\n    }\n    \n    part def Transmission {\n        port torqueInput : TorquePort;\n    }\n    \n    // Port definitions\n    port def TorquePort {\n        attribute torque : TorqueValue;\n    }\n    \n    // Interface definitions\n    interface def DriveInterface {\n        end engineEnd : Engine;\n        end transmissionEnd : Transmission;\n    }\n    \n    // Requirements\n    requirement def VehicleMassRequirement {\n        doc /* Vehicle shall not exceed maximum mass limit */\n        \n        attribute massLimit : MassValue;\n        \n        require constraint {\n            doc /* Actual mass shall be less than or equal to maximum mass */\n        }\n    }\n    \n    requirement def FuelStatusRequirement {\n        doc /* Vehicle mass requirements shall consider fuel status */\n        \n        attribute requiredFuelStatus : FuelStatus;\n    }\n    \n    requirement def PowerDeliveryRequirement {\n        doc /* Engine shall deliver torque to transmission via drive interface */\n        \n        attribute minimumTorque : TorqueValue;\n    }\n    \n    requirement def ReliabilityRequirement {\n        doc /* Vehicle shall maintain specified performance throughout lifecycle */\n        \n        attribute reliabilityTarget : Real;\n    }\n    \n    // Requirement usages\n    requirement vehicleMass2000kg : VehicleMassRequirement {\n        :>> massLimit = 2000.0;\n    }\n    \n    requirement vehicleMass2500kg : VehicleMassRequirement {\n        :>> massLimit = 2500.0;\n    }\n    \n    requirement fullFuelMassReq : FuelStatusRequirement {\n        :>> requiredFuelStatus = FuelStatus::fullFuel;\n    }\n    \n    requirement emptyFuelMassReq : FuelStatusRequirement {\n        :>> requiredFuelStatus = FuelStatus::emptyFuel;\n    }\n    \n    requirement powerDelivery : PowerDeliveryRequirement {\n        :>> minimumTorque = 200.0;\n    }\n    \n    requirement vehicleReliability : ReliabilityRequirement {\n        :>> reliabilityTarget = 0.95;\n    }\n    \n    // Allocations\n    allocation vehicleMassAllocation : VehicleMassRequirement allocate to Vehicle;\n    allocation powerDeliveryAllocation : PowerDeliveryRequirement allocate to Engine;\n    allocation reliabilityAllocation : ReliabilityRequirement allocate to Vehicle;\n}",
    "package VehicleMassComplianceSystem {\n    \n    part def WeighingEquipment {\n        attribute serialNumber : String;\n        attribute accuracy : Real;\n    }\n    \n    part def Vehicle {\n        attribute vehicleID : String;\n        attribute actualMass : Real;\n    }\n    \n    part def TestOperator {\n        attribute operatorID : String;\n        attribute name : String;\n    }\n    \n    part def ComplianceResult {\n        attribute isCompliant : Boolean;\n        attribute testedVehicleID : String;\n        attribute measuredMass : Real;\n        attribute maxPermissibleMass : Real;\n    }\n    \n    part def VehicleMassComplianceVerificationSystem {\n        attribute maxPermissibleMass : Real = 2500.0;\n        \n        part weighingEquipment : WeighingEquipment;\n        part testOperator : TestOperator;\n        part vehicles : Vehicle[*];\n        part complianceResults : ComplianceResult[*];\n        \n        action measureVehicleMass {\n            in vehicle : Vehicle;\n            in operator : TestOperator;\n            in equipment : WeighingEquipment;\n            out measuredMass : Real;\n        }\n        \n        action compareWithLimit {\n            in measuredMass : Real;\n            in maxLimit : Real;\n            out isCompliant : Boolean {\n                isCompliant = measuredMass <= maxLimit;\n            }\n        }\n        \n        action verifyCompliance {\n            in vehicle : Vehicle;\n            out result : ComplianceResult;\n            \n            perform measureVehicleMass {\n                in vehicle = vehicle;\n                in operator = testOperator;\n                in equipment = weighingEquipment;\n                out measuredMass;\n            }\n            then perform compareWithLimit {\n                in measuredMass = measuredMass;\n                in maxLimit = maxPermissibleMass;\n                out isCompliant;\n            }\n            then assign result {\n                result.isCompliant = isCompliant;\n                result.testedVehicleID = vehicle.vehicleID;\n                result.measuredMass = measuredMass;\n                result.maxPermissibleMass = maxPermissibleMass;\n            }\n        }\n        \n        action performSequentialTesting {\n            for vehicle in vehicles {\n                perform verifyCompliance {\n                    in vehicle = vehicle;\n                    out result;\n                }\n                then assign complianceResults = complianceResults + result;\n            }\n        }\n    }\n}",
    "package WaterSupplySystem {\n    \n    item def Water {\n        attribute temperature : Real;\n        attribute flowRate : Real;\n    }\n    \n    item def HotWater :> Water {\n        attribute temperature : Real default = 60.0;\n    }\n    \n    item def ColdWater :> Water {\n        attribute temperature : Real default = 15.0;\n    }\n    \n    port def WaterOutlet {\n        out item waterFlow : Water;\n    }\n    \n    port def WaterInlet {\n        in item waterFlow : Water;\n    }\n    \n    interface def WaterConnection {\n        end supplier : WaterOutlet;\n        end consumer : WaterInlet;\n    }\n    \n    part def Spigot {\n        port waterOut : WaterOutlet;\n    }\n    \n    part def SpigotBank {\n        part hotSpigot : Spigot;\n        part coldSpigot : Spigot;\n    }\n    \n    part def FaucetInlet {\n        port waterIn : WaterInlet;\n    }\n    \n    part def Faucet {\n        part hotInlet : FaucetInlet;\n        part coldInlet : FaucetInlet;\n    }\n    \n    part def WaterSupplyNetwork {\n        part mainSupply : SpigotBank;\n        part faucets : Faucet[1..*];\n        \n        interface hotWaterConnections : WaterConnection connect \n            mainSupply.hotSpigot.waterOut to faucets.hotInlet.waterIn;\n            \n        interface coldWaterConnections : WaterConnection connect \n            mainSupply.coldSpigot.waterOut to faucets.coldInlet.waterIn;\n    }\n}",
    "package VehicleQualityAnalysisSystem {\n    \n    part def Vehicle {\n        attribute mass : Real;\n        \n        part engine : Engine;\n        part transmission : Transmission;\n        part frontAxleAssembly : AxleAssembly;\n        part rearAxleAssembly : AxleAssembly;\n        \n        attribute totalMass : Real = engine.mass + transmission.mass + \n                                     frontAxleAssembly.mass + rearAxleAssembly.mass;\n    }\n    \n    part def Engine {\n        attribute mass : Real;\n        attribute qualityData : QualityData;\n    }\n    \n    part def Transmission {\n        attribute mass : Real;\n        attribute qualityData : QualityData;\n    }\n    \n    part def AxleAssembly {\n        attribute mass : Real;\n        attribute qualityData : QualityData;\n    }\n    \n    attribute def QualityData {\n        attribute measurementDate : String;\n        attribute qualityScore : Real;\n        attribute defectCount : Integer;\n    }\n    \n    requirement def QualityAnalysisRequirement {\n        doc /* Quality analysis requirements for vehicle and components */\n        attribute analysisScope : String;\n        attribute targetMetrics : String[*];\n    }\n    \n    use case def QualityAnalysisUseCase {\n        subject vehicle : Vehicle;\n        \n        objective {\n            doc /* Perform comprehensive quality evaluation */\n        }\n        \n        include inputQualityData : InputQualityData;\n        include calculateTotalMass : CalculateTotalMass;\n        include generateAnalysisTasks : GenerateAnalysisTasks;\n        include evaluateQuality : EvaluateQuality;\n    }\n    \n    use case def InputQualityData {\n        subject component : Engine;\n    }\n    \n    use case def CalculateTotalMass {\n        subject vehicle : Vehicle;\n    }\n    \n    use case def GenerateAnalysisTasks {\n        subject analysisSystem : QualityAnalysisSystem;\n    }\n    \n    use case def EvaluateQuality {\n        subject vehicle : Vehicle;\n    }\n    \n    part def QualityAnalysisSystem {\n        part vehicle : Vehicle;\n        part analysisEngine : AnalysisEngine;\n        \n        attribute analysisObjectives : String[*];\n        attribute analysisTasks : AnalysisTask[*];\n        attribute analysisPlans : AnalysisPlan[*];\n    }\n    \n    part def AnalysisEngine {\n        attribute performAnalysis : Boolean;\n        attribute generateReport : Boolean;\n    }\n    \n    attribute def AnalysisTask {\n        attribute taskId : String;\n        attribute taskDescription : String;\n        attribute taskStatus : String;\n    }\n    \n    attribute def AnalysisPlan {\n        attribute planId : String;\n        attribute planObjective : String;\n        attribute scheduledDate : String;\n    }\n    \n    requirement vehicleQualityReq : QualityAnalysisRequirement {\n        doc /* The system shall enable quality attribute modeling and analysis for vehicles */\n        attribute analysisScope = \"Vehicle and key components\";\n        attribute targetMetrics = [\"mass\", \"quality score\", \"defect count\"];\n    }\n    \n    requirement massCalculationReq : QualityAnalysisRequirement {\n        doc /* The system shall automatically aggregate and calculate total vehicle mass */\n        attribute analysisScope = \"Total vehicle mass\";\n        attribute targetMetrics = [\"total mass\"];\n    }\n    \n    requirement analysisGenerationReq : QualityAnalysisRequirement {\n        doc /* The system shall automatically generate analysis tasks and plans */\n        attribute analysisScope = \"Analysis automation\";\n        attribute targetMetrics = [\"task generation\", \"plan creation\"];\n    }\n}",
    "package PowertrainOptimizationSystem {\n    \n    part def Engine {\n        attribute engineType : String;\n        attribute numberOfCylinders : Integer;\n        attribute power : Real;\n        attribute mass : Real;\n        attribute efficiency : Real;\n        attribute reliability : Real;\n        attribute cost : Real;\n        \n        part cylinders : Cylinder[1..*];\n        part pistons : Piston[1..*];\n        part connectingRods : ConnectingRod[1..*];\n        part crankshaft : Crankshaft;\n    }\n    \n    part def Cylinder {\n        attribute displacement : Real;\n        attribute bore : Real;\n        attribute stroke : Real;\n    }\n    \n    part def Piston {\n        attribute diameter : Real;\n        attribute mass : Real;\n    }\n    \n    part def ConnectingRod {\n        attribute length : Real;\n        attribute mass : Real;\n    }\n    \n    part def Crankshaft {\n        attribute mass : Real;\n        attribute material : String;\n    }\n    \n    part def PerformanceIndicator {\n        attribute name : String;\n        attribute value : Real;\n        attribute weight : Real;\n    }\n    \n    part def EvaluationModel {\n        attribute overallScore : Real;\n        part indicators : PerformanceIndicator[1..*];\n    }\n    \n    part def TradeOffAnalysis {\n        part candidateEngines : Engine[1..*];\n        part evaluationModel : EvaluationModel;\n        part optimalEngine : Engine;\n        attribute selectionRationale : String;\n    }\n    \n    part def PowertrainConfigurationSystem {\n        part engineLibrary : Engine[1..*];\n        part tradeOffAnalysis : TradeOffAnalysis;\n        \n        action performTradeOffAnalysis {\n            in engines : Engine[1..*];\n            out selectedEngine : Engine;\n            out rationale : String;\n        }\n        \n        action assembleEngineComponents {\n            in engineType : String;\n            in cylinderCount : Integer;\n            out assembledEngine : Engine;\n        }\n        \n        action evaluateEnginePerformance {\n            in engine : Engine;\n            out evaluationScore : Real;\n        }\n    }\n}",
    "package FuelEconomySystem {\n    import ScalarValues::*;\n    \n    attribute def MilesPerGallon :> Real {\n        doc /* Fuel economy measured in miles per gallon */\n    }\n    \n    attribute def Miles :> Real {\n        doc /* Distance in miles */\n    }\n    \n    attribute def Pounds :> Real {\n        doc /* Weight in pounds */\n    }\n    \n    attribute def CubicInches :> Real {\n        doc /* Volume in cubic inches */\n    }\n    \n    enum def DrivingCondition {\n        urban;\n        highway;\n    }\n    \n    attribute def USGallon :> CubicInches {\n        doc /* US customary gallon */\n        attribute redefines num = 231;\n    }\n    \n    requirement def FuelEconomyRequirement {\n        doc /* Vehicle fuel economy requirements */\n        \n        attribute urbanMinimum : MilesPerGallon = 25;\n        attribute highwayMinimum : MilesPerGallon = 30;\n        attribute testLoad : Pounds = 1000;\n        \n        requirement urbanRequirement {\n            doc /* Urban driving fuel economy requirement */\n            require constraint {\n                measuredUrbanFuelEconomy >= urbanMinimum\n            }\n        }\n        \n        requirement highwayRequirement {\n            doc /* Highway driving fuel economy requirement */\n            require constraint {\n                measuredHighwayFuelEconomy >= highwayMinimum\n            }\n        }\n    }\n    \n    part def Vehicle {\n        attribute powertrain : String;\n        attribute baseWeight : Pounds;\n        attribute fuelCapacity : USGallon;\n        \n        port fuelInput;\n        port powerOutput;\n    }\n    \n    part def FuelEconomyTestSystem {\n        part vehicle : Vehicle;\n        \n        attribute additionalLoad : Pounds = 1000;\n        attribute drivingCondition : DrivingCondition;\n        \n        attribute measuredFuelEconomy : MilesPerGallon;\n        \n        action performFuelEconomyTest {\n            in vehicle : Vehicle;\n            in testCondition : DrivingCondition;\n            in load : Pounds;\n            out fuelEconomy : MilesPerGallon;\n        }\n    }\n    \n    part fuelEconomySystem {\n        doc /* System to ensure vehicle fuel economy meets requirements */\n        \n        part testSystem : FuelEconomyTestSystem;\n        part vehicleUnderTest : Vehicle;\n        \n        satisfy requirement : FuelEconomyRequirement;\n        \n        attribute measuredUrbanFuelEconomy : MilesPerGallon;\n        attribute measuredHighwayFuelEconomy : MilesPerGallon;\n        \n        action testUrbanFuelEconomy {\n            testSystem.performFuelEconomyTest(\n                vehicleUnderTest,\n                DrivingCondition::urban,\n                1000\n            );\n            then measuredUrbanFuelEconomy := testSystem.measuredFuelEconomy;\n        }\n        \n        action testHighwayFuelEconomy {\n            testSystem.performFuelEconomyTest(\n                vehicleUnderTest,\n                DrivingCondition::highway,\n                1000\n            );\n            then measuredHighwayFuelEconomy := testSystem.measuredFuelEconomy;\n        }\n    }\n}",
    "package VehicleLongitudinalDynamicsSystem {\n    \n    part def VehicleDynamicsSimulator {\n        attribute mass : Real;\n        attribute initialPosition : Real;\n        attribute initialVelocity : Real;\n        attribute timeStep : Real;\n        \n        part powerInput : PowerSegmentSet;\n        part dynamicsCalculator : DynamicsCalculator;\n        part motionResults : MotionResults;\n        \n        port inputPort : DataInputPort;\n        port outputPort : DataOutputPort;\n    }\n    \n    part def PowerSegmentSet {\n        attribute powerSegments : Real[*] ordered;\n        attribute timeSegments : Real[*] ordered;\n    }\n    \n    part def DynamicsCalculator {\n        attribute currentTime : Real;\n        attribute currentPower : Real;\n        attribute currentAcceleration : Real;\n        attribute currentVelocity : Real;\n        attribute currentPosition : Real;\n        \n        action calculateDynamics {\n            in mass : Real;\n            in power : Real;\n            in velocity : Real;\n            in position : Real;\n            in timeStep : Real;\n            out acceleration : Real;\n            out newVelocity : Real;\n            out newPosition : Real;\n        }\n    }\n    \n    part def MotionResults {\n        attribute accelerationSequence : Real[*] ordered;\n        attribute velocitySequence : Real[*] ordered;\n        attribute positionSequence : Real[*] ordered;\n        attribute timeSequence : Real[*] ordered;\n    }\n    \n    port def DataInputPort {\n        in mass : Real;\n        in initialPosition : Real;\n        in initialVelocity : Real;\n        in powerData : Real[*];\n        in timeStep : Real;\n    }\n    \n    port def DataOutputPort {\n        out accelerationProfile : Real[*];\n        out velocityProfile : Real[*];\n        out displacementProfile : Real[*];\n        out timeProfile : Real[*];\n    }\n    \n    part vehicleSimulationSystem : VehicleDynamicsSimulator {\n        connect inputPort to powerInput.powerSegments;\n        connect dynamicsCalculator.acceleration to motionResults.accelerationSequence;\n        connect dynamicsCalculator.newVelocity to motionResults.velocitySequence;\n        connect dynamicsCalculator.newPosition to motionResults.positionSequence;\n        connect motionResults to outputPort;\n    }\n}",
    "package VehicleSystemModel {\n    \n    part def Vehicle {\n        attribute totalMass : Real = 2500.0;\n        \n        part frontAxleAssembly : FrontAxleAssembly;\n        part rearAxleAssembly : RearAxleAssembly;\n    }\n    \n    part def FrontAxleAssembly {\n        attribute mass : Real = 150.0;\n        \n        part frontWheel1 : Wheel;\n        part frontWheel2 : Wheel;\n        part frontAxle : FrontAxle;\n    }\n    \n    part def RearAxleAssembly {\n        attribute mass : Real = 250.0;\n        \n        part rearWheel1 : Wheel;\n        part rearWheel2 : Wheel;\n        part rearAxle : RearAxle;\n    }\n    \n    part def FrontAxle {\n        attribute mass : Real;\n        attribute steeringAngle : Real;\n    }\n    \n    part def RearAxle {\n        attribute mass : Real;\n    }\n    \n    part def Wheel {\n        attribute mass : Real;\n    }\n}",
    "package VehicleSafetySecuritySystem {\n    \n    part def Vehicle {\n        part seatBelts : SeatBelt[1..*];\n        part airbags : Airbag[0..*];\n        part bumpers : Bumper[1..*];\n        part antiLockBrakingSystem : AntiLockBrakingSystem[0..1];\n        part alarmDevice : AlarmDevice[0..1];\n        part keylessEntrySystem : KeylessEntrySystem[0..1];\n    }\n    \n    part def SafetyComponent {\n        attribute isMandatory : Boolean;\n    }\n    \n    part def SecurityComponent {\n    }\n    \n    part def SeatBelt :> SafetyComponent {\n        attribute isMandatory : Boolean = true;\n    }\n    \n    part def Airbag :> SafetyComponent {\n        attribute isMandatory : Boolean = false;\n    }\n    \n    part def Bumper :> SafetyComponent {\n        attribute isMandatory : Boolean = true;\n    }\n    \n    part def AntiLockBrakingSystem :> SafetyComponent {\n        attribute isMandatory : Boolean = false;\n    }\n    \n    part def AlarmDevice :> SecurityComponent {\n    }\n    \n    part def KeylessEntrySystem :> SecurityComponent {\n    }\n    \n    part def ManagementSystem {\n        part vehicle : Vehicle;\n        \n        action filterBySafety {\n            in vehicle : Vehicle;\n            out safetyComponents : SafetyComponent[0..*];\n        }\n        \n        action filterBySecurity {\n            in vehicle : Vehicle;\n            out securityComponents : SecurityComponent[0..*];\n        }\n        \n        action displayAsTree {\n            in components : SafetyComponent[0..*];\n        }\n        \n        action displayAsTable {\n            in components : SafetyComponent[0..*];\n        }\n    }\n}",
    "package SystemModel {\n    \n    part def System {\n        attribute x;\n        attribute y;\n        attribute z;\n        \n        part applicationLayer : ApplicationLayer;\n        part serviceLayer : ServiceLayer;\n        part dataLayer : DataLayer;\n        \n        connection : UsageConnection connect applicationLayer.serviceUsage to serviceLayer.serviceProvision;\n        connection : UsageConnection connect serviceLayer.dataUsage to dataLayer.dataProvision;\n    }\n    \n    part def ApplicationLayer {\n        port serviceUsage : ServiceInterface;\n    }\n    \n    part def ServiceLayer {\n        port serviceProvision : ~ServiceInterface;\n        port dataUsage : DataInterface;\n    }\n    \n    part def DataLayer {\n        port dataProvision : ~DataInterface;\n    }\n    \n    interface def ServiceInterface {\n    }\n    \n    interface def DataInterface {\n    }\n    \n    connection def UsageConnection {\n        end consumer : ServiceInterface;\n        end provider : ~ServiceInterface;\n    }\n    \n    connection def UsageConnection {\n        end consumer : DataInterface;\n        end provider : ~DataInterface;\n    }\n}",
    "package PowertrainSystem {\n    \n    part def Powertrain {\n        attribute torque : Real;\n        assert constraint { torque > 0.0 }\n    }\n    \n    part def Engine :> Powertrain;\n    \n    action def GenerateTorque {\n        out torqueOutput : Real;\n    }\n    \n    part powertrain : Powertrain {\n        perform generateTorque : GenerateTorque {\n            out torqueOutput = torque;\n        }\n    }\n    \n    part engine : Engine :> powertrain;\n    \n    allocation torqueGenerationAllocation {\n        from powertrain::generateTorque to engine;\n    }\n}",
    "package SystemModel {\n    \n    part def System {\n        perform action transmitPower;\n        perform action outputPower;\n        perform action providePower;\n        perform action generateTorque;\n        \n        part torqueGenerator : TorqueGenerator;\n        part powertrain : Powertrain;\n    }\n    \n    part def TorqueGenerator {\n        perform action generateTorque;\n    }\n    \n    part def Powertrain {\n        part engine : Engine;\n    }\n    \n    part def Engine {\n        perform action generateTorque;\n    }\n    \n    action def transmitPower;\n    action def outputPower;\n    action def providePower;\n    action def generateTorque;\n    \n    allocation def TorqueGeneratorToEngine {\n        end source : TorqueGenerator;\n        end target : Engine;\n    }\n    \n    allocation torqueGenAllocation : TorqueGeneratorToEngine {\n        allocate System.torqueGenerator to System.powertrain.engine;\n    }\n}",
    "package VehicleSafetyAndAntiTheftSystem {\n    \n    part def Vehicle {\n        part bodyAndInterior : BodyAndInterior;\n        part safetySystem : SafetySystem;\n        part securitySystem : SecuritySystem;\n    }\n    \n    part def BodyAndInterior {\n        part frontSeatBelts : FrontSeatBelt[2];\n        part bumpers : Bumper[2];\n    }\n    \n    part def SafetySystem {\n        part mandatorySafetyComponents : MandatorySafetyComponent[1..*];\n        part optionalSafetyComponents : OptionalSafetyComponent[0..*];\n    }\n    \n    part def SecuritySystem {\n        part alarmSystem : AlarmSystem;\n        part keylessEntrySystem : KeylessEntrySystem;\n    }\n    \n    part def SafetyComponent {\n        attribute affectsSafety : Boolean = true;\n        attribute affectsAntiTheft : Boolean = false;\n    }\n    \n    part def AntiTheftComponent {\n        attribute affectsSafety : Boolean = false;\n        attribute affectsAntiTheft : Boolean = true;\n    }\n    \n    part def DualPurposeComponent {\n        attribute affectsSafety : Boolean = true;\n        attribute affectsAntiTheft : Boolean = true;\n    }\n    \n    part def MandatorySafetyComponent :> SafetyComponent {\n        attribute isMandatory : Boolean = true;\n    }\n    \n    part def OptionalSafetyComponent :> SafetyComponent {\n        attribute isMandatory : Boolean = false;\n    }\n    \n    part def FrontSeatBelt :> MandatorySafetyComponent;\n    \n    part def Bumper :> MandatorySafetyComponent;\n    \n    part def DriverAirbag :> OptionalSafetyComponent;\n    \n    part def AntiLockBrakingSystem :> OptionalSafetyComponent;\n    \n    part def AlarmSystem :> AntiTheftComponent;\n    \n    part def KeylessEntrySystem :> AntiTheftComponent;\n}",
    "package FuelSystem {\n    import ScalarValues::*;\n    \n    part def Vehicle {\n        part fuelSystem : FuelSystem;\n    }\n    \n    part def FuelSystem {\n        part fuelTankAssembly : FuelTankAssembly;\n        part fuelConsumingUnits : FuelConsumingUnit[1..*];\n        \n        connection fuelSupply : FuelFlow connect fuelTankAssembly.fuelOutlet to fuelConsumingUnits.fuelInlet;\n        connection fuelReturn : FuelFlow connect fuelConsumingUnits.fuelReturn to fuelTankAssembly.returnInlet;\n        connection tempData : DataFlow connect fuelTankAssembly.tempOutput to fuelConsumingUnits.tempInput;\n    }\n    \n    part def FuelTankAssembly {\n        part fuelTank : FuelTank;\n        part fuelPump : FuelPump;\n        \n        port fuelOutlet : FuelPort;\n        port returnInlet : FuelPort;\n        port tempOutput : DataPort;\n        \n        connection pumpToTank : FuelFlow connect fuelPump.inlet to fuelTank.outlet;\n        connection pumpToOutlet : FuelFlow connect fuelPump.outlet to fuelOutlet;\n        connection returnToTank : FuelFlow connect returnInlet to fuelTank.inlet;\n        connection tempSensor : DataFlow connect fuelTank.tempSensor to tempOutput;\n    }\n    \n    part def FuelTank {\n        attribute capacity : Real;\n        attribute currentLevel : Real;\n        attribute temperature : Real;\n        \n        port inlet : FuelPort;\n        port outlet : FuelPort;\n        port tempSensor : DataPort;\n    }\n    \n    part def FuelPump {\n        attribute pressure : Real;\n        attribute flowRate : Real;\n        \n        port inlet : FuelPort;\n        port outlet : FuelPort;\n        \n        action pressurize {\n            doc /* Pressurizes fuel from tank and delivers to outlet */\n        }\n    }\n    \n    part def FuelConsumingUnit {\n        port fuelInlet : FuelPort;\n        port fuelReturn : FuelPort;\n        port tempInput : DataPort;\n    }\n    \n    port def FuelPort {\n        attribute flowRate : Real;\n        attribute pressure : Real;\n    }\n    \n    port def DataPort {\n        attribute value : Real;\n    }\n    \n    connection def FuelFlow {\n        end source : FuelPort;\n        end target : FuelPort;\n    }\n    \n    connection def DataFlow {\n        end source : DataPort;\n        end target : DataPort;\n    }\n}",
    "package VehicleSafetySecuritySystem {\n    \n    part def Vehicle {\n        part interior : Interior;\n        part body : Body;\n        part chassis : Chassis;\n    }\n    \n    part def Interior {\n        part seatBelts : SeatBelt[2];\n        part airbag : Airbag[0..1];\n        part antiTheftAlarm : AntiTheftAlarm;\n    }\n    \n    part def Body {\n        part bumper : Bumper;\n        part keylessEntrySystem : KeylessEntrySystem;\n    }\n    \n    part def Chassis {\n        part wheels : Wheel[2];\n        part antilockBrakingSystems : AntilockBrakingSystem[0..2];\n    }\n    \n    part def SeatBelt {\n        attribute isMandatory : Boolean = true;\n        attribute safetyCategory : String = \"Critical\";\n    }\n    \n    part def Airbag {\n        attribute isMandatory : Boolean = false;\n        attribute safetyCategory : String = \"Safety\";\n    }\n    \n    part def AntiTheftAlarm {\n        attribute isMandatory : Boolean = true;\n        attribute securityCategory : String = \"Security\";\n    }\n    \n    part def Bumper {\n        attribute isMandatory : Boolean = true;\n        attribute safetyCategory : String = \"Critical\";\n    }\n    \n    part def KeylessEntrySystem {\n        attribute isMandatory : Boolean = true;\n        attribute securityCategory : String = \"Security\";\n    }\n    \n    part def Wheel {\n        attribute isMandatory : Boolean = true;\n    }\n    \n    part def AntilockBrakingSystem {\n        attribute isMandatory : Boolean = false;\n        attribute safetyCategory : String = \"Safety\";\n    }\n}",
    "package VehicleSafetySecuritySystem {\n    \n    part def VehicleSafetySecurityComponent {\n        part interior : Interior;\n        part bodyAssembly : BodyAssembly;\n    }\n    \n    part def Interior {\n        part alarmSystem : AlarmSystem;\n        part seatBelts : SeatBelt[1..*];\n        part frontRowSeats : FrontRowSeat[1..*];\n        part driversAirbag : DriversAirbag;\n    }\n    \n    part def BodyAssembly {\n        part vehicleBody : VehicleBody;\n        part bumper : Bumper;\n        part keylessEntrySystem : KeylessEntrySystem;\n    }\n    \n    part def AlarmSystem;\n    part def SeatBelt;\n    part def FrontRowSeat;\n    part def DriversAirbag;\n    part def VehicleBody;\n    part def Bumper;\n    part def KeylessEntrySystem;\n    \n    part vehicleSafetySecurityComponent : VehicleSafetySecurityComponent;\n}",
    "package SecurityClassificationSystem {\n    \n    enum def SecurityLevel {\n        enum Unclassified;\n        enum Confidential;\n        enum Secret;\n    }\n    \n    attribute def SecurityClassification {\n        attribute level : SecurityLevel;\n    }\n    \n    part def Component {\n        attribute classification : SecurityClassification;\n    }\n    \n    part def ClassificationSystem {\n        part components : Component[*];\n        \n        attribute def displayClassification(comp : Component) : SecurityLevel {\n            return comp.classification.level;\n        }\n    }\n    \n    requirement def SecurityClassificationRequirement {\n        doc /* The system is required to classify and label each component to meet information security management requirements */\n        \n        requirement classifyComponents {\n            doc /* Every component must be clearly assigned a security classification level */\n            subject components : Component[*];\n        }\n        \n        requirement recognizeConfidential {\n            doc /* When a component is marked as \"Confidential,\" the system should be able to recognize and display its corresponding classification attribute */\n            assume comp : Component;\n            require constraint { comp.classification.level == SecurityLevel::Confidential }\n        }\n    }\n}",
    "package AutomotiveECUSystem {\n    \n    part def CANBus {\n        port canPort : ~CANInterface[1..*];\n    }\n    \n    part def BusInterface {\n        port ecuSide : CANInterface;\n        port busSide : ~CANInterface;\n    }\n    \n    part def VehicleControlUnit {\n        port busIF : CANInterface;\n        port sensorData : ~SensorInterface;\n        attribute vehicleState : String;\n    }\n    \n    part def EngineControlUnit {\n        port busIF : CANInterface;\n        port sensorData : ~SensorInterface;\n        attribute engineState : String;\n    }\n    \n    interface def CANInterface {\n        in item canMessage : CANMessage;\n        out item canResponse : CANMessage;\n    }\n    \n    interface def SensorInterface {\n        in item sensorSignal : SensorData;\n    }\n    \n    item def CANMessage {\n        attribute id : String;\n        attribute data : String;\n    }\n    \n    item def SensorData {\n        attribute value : Real;\n        attribute timestamp : String;\n    }\n    \n    part automotiveECU : AutomotiveECUSystem {\n        part vcu : VehicleControlUnit;\n        part ecu : EngineControlUnit;\n        part canBus : CANBus;\n        part vcuBusIF : BusInterface;\n        part ecuBusIF : BusInterface;\n        \n        interface vcuToBusIF connect vcu.busIF to vcuBusIF.ecuSide;\n        interface ecuToBusIF connect ecu.busIF to ecuBusIF.ecuSide;\n        interface vcuBusIFToCAN connect vcuBusIF.busSide to canBus.canPort;\n        interface ecuBusIFToCAN connect ecuBusIF.busSide to canBus.canPort;\n    }\n}",
    "package BloodGlucoseMeterSystem {\n    \n    part def BloodGlucoseMeter {\n        part batteryMonitor : BatteryMonitor;\n        part measurementUnit : MeasurementUnit;\n        part alarmSystem : AlarmSystem;\n        part userInterface : UserInterface;\n        \n        port powerStatus : PowerStatusPort;\n        port measurementStatus : MeasurementStatusPort;\n        port userAlert : UserAlertPort;\n    }\n    \n    part def BatteryMonitor {\n        attribute batteryLevel : Real;\n        attribute chargingStatus : Boolean;\n        \n        port batteryStatus : BatteryStatusPort;\n    }\n    \n    part def MeasurementUnit {\n        attribute measurementActive : Boolean;\n        attribute glucoseReading : Real;\n        \n        port measurementControl : MeasurementControlPort;\n    }\n    \n    part def AlarmSystem {\n        attribute alarmActive : Boolean;\n        attribute alarmType : String;\n        \n        port alarmTrigger : AlarmTriggerPort;\n    }\n    \n    part def UserInterface {\n        attribute displayMessage : String;\n        attribute alertVisible : Boolean;\n        \n        port displayControl : DisplayControlPort;\n    }\n    \n    port def PowerStatusPort {\n        attribute powerLevel : Real;\n        attribute isCharging : Boolean;\n    }\n    \n    port def MeasurementStatusPort {\n        attribute canMeasure : Boolean;\n        attribute lastReading : Real;\n    }\n    \n    port def UserAlertPort {\n        attribute alertMessage : String;\n        attribute alertPriority : String;\n    }\n    \n    port def BatteryStatusPort {\n        attribute currentLevel : Real;\n        attribute charging : Boolean;\n    }\n    \n    port def MeasurementControlPort {\n        attribute enableMeasurement : Boolean;\n    }\n    \n    port def AlarmTriggerPort {\n        attribute triggerAlarm : Boolean;\n        attribute alarmReason : String;\n    }\n    \n    port def DisplayControlPort {\n        attribute showAlert : Boolean;\n        attribute message : String;\n    }\n    \n    requirement def HighReliabilityRequirement {\n        doc /* System shall ensure high reliability and safety during use */\n        subject meter : BloodGlucoseMeter;\n    }\n    \n    requirement def BatteryDetectionRequirement {\n        doc /* System shall automatically detect battery status */\n        subject batteryMonitor : BatteryMonitor;\n        require constraint { batteryMonitor.batteryLevel >= 0.0 and batteryMonitor.batteryLevel <= 100.0 }\n    }\n    \n    requirement def UserAlertRequirement {\n        doc /* System shall promptly alert user when battery is depleted or cannot be charged */\n        subject alarmSystem : AlarmSystem;\n        subject userInterface : UserInterface;\n    }\n    \n    requirement def PreventMeasurementFailureRequirement {\n        doc /* System shall prevent failure to measure blood glucose due to battery issues */\n        subject meter : BloodGlucoseMeter;\n    }\n    \n    requirement def PreventiveMeasuresRequirement {\n        doc /* System shall implement preventive measures for battery status */\n        subject batteryMonitor : BatteryMonitor;\n    }\n    \n    requirement def EmergencyResponseRequirement {\n        doc /* System shall have alarm and emergency response mechanisms for measurement abnormalities */\n        subject alarmSystem : AlarmSystem;\n    }\n    \n    requirement def ContinuousTherapeuticSupportRequirement {\n        doc /* System shall ensure patients receive timely, continuous, and safe therapeutic support */\n        subject meter : BloodGlucoseMeter;\n    }\n    \n    connection def BatteryToAlarm {\n        end batteryPort : BatteryMonitor::batteryStatus;\n        end alarmPort : AlarmSystem::alarmTrigger;\n    }\n    \n    connection def AlarmToDisplay {\n        end alarmOut : AlarmSystem::alarmTrigger;\n        end displayIn : UserInterface::displayControl;\n    }\n    \n    connection def BatteryToMeasurement {\n        end batteryOut : BatteryMonitor::batteryStatus;\n        end measurementIn : MeasurementUnit::measurementControl;\n    }\n}",
    "package ScientificConstantsSystem {\n    \n    package MathematicalConstants {\n        attribute def EulersNumber {\n            attribute value : Real = 2.71828182845904523536;\n            attribute precision : Integer = 20;\n            attribute symbol : String = \"e\";\n        }\n        \n        attribute def Pi {\n            attribute value : Real = 3.14159265358979323846;\n            attribute precision : Integer = 20;\n            attribute symbol : String = \"π\";\n        }\n    }\n    \n    package PhysicalConstants {\n        attribute def SpeedOfLight {\n            attribute value : Real = 299792458.0;\n            attribute unit : String = \"m/s\";\n            attribute description : String = \"Speed of light in vacuum\";\n        }\n        \n        attribute def FineStructureConstant {\n            attribute value : Real = 0.0072973525693;\n            attribute unit : String = \"dimensionless\";\n            attribute description : String = \"Fine-structure constant\";\n        }\n        \n        attribute def ElectronProtonMassRatio {\n            attribute value : Real = 0.00054386734428;\n            attribute unit : String = \"dimensionless\";\n            attribute description : String = \"Electron to proton mass ratio\";\n        }\n    }\n    \n    package ContextSpecificConstants {\n        attribute def StandardGravity {\n            attribute value : Real = 9.80665;\n            attribute unit : String = \"m/s²\";\n            attribute description : String = \"Standard gravitational acceleration on Earth\";\n        }\n        \n        attribute def ModelXAmplifierGain {\n            attribute value : Real = 100.0;\n            attribute unit : String = \"dimensionless\";\n            attribute description : String = \"Amplifier gain coefficient for Model X\";\n            attribute product : String = \"Model X\";\n        }\n    }\n    \n    part def ConstantsProvider {\n        attribute mathConstants : MathematicalConstants::EulersNumber;\n        attribute mathConstants2 : MathematicalConstants::Pi;\n        attribute physConstants1 : PhysicalConstants::SpeedOfLight;\n        attribute physConstants2 : PhysicalConstants::FineStructureConstant;\n        attribute physConstants3 : PhysicalConstants::ElectronProtonMassRatio;\n        attribute contextConstants1 : ContextSpecificConstants::StandardGravity;\n        attribute contextConstants2 : ContextSpecificConstants::ModelXAmplifierGain;\n    }\n    \n    part def ScientificComputingSystem {\n        part constantsProvider : ConstantsProvider;\n        \n        attribute accessibleConstants : Boolean = true;\n        attribute verifiableConstants : Boolean = true;\n        attribute highPrecision : Boolean = true;\n    }\n}",
    "package TireSpecificationModel {\n    \n    attribute def ManufacturerName : String;\n    attribute def RimDiameter : Real;\n    attribute def TireWidth : Integer;\n    \n    item def Tire {\n        attribute manufacturer : ManufacturerName;\n        attribute rimDiameter : RimDiameter;\n        attribute width : TireWidth;\n    }\n    \n    item frenchTire : Tire {\n        attribute manufacturer = \"Michelin\";\n        attribute rimDiameter = 18.0;\n        attribute width = 245;\n    }\n}",
    "package AutomotiveComponentModel {\n    import ISQ::*;\n    import SI::*;\n    import USCustomaryUnits::*;\n    \n    part def Vehicle {\n        attribute mass : MassValue = 1200 [kg];\n        attribute length : LengthValue = 4.82 [m];\n        \n        part leftFrontWheel : Wheel;\n        part rightFrontWheel : Wheel;\n    }\n    \n    part def Wheel {\n        attribute hubDiameter : LengthValue = 18 [in];\n        attribute width : LengthValue = 245 [mm];\n        attribute outerDiameter : LengthValue;\n        \n        part tire : Tire;\n        \n        constraint {\n            outerDiameter == hubDiameter + 2 * tire.height\n        }\n    }\n    \n    part def Tire {\n        attribute height : LengthValue;\n    }\n}",
    "package VehiclePowertrainConfiguration {\n    \n    part def Vehicle {\n        attribute isHighPerformance : Boolean;\n        part engine : Engine[1];\n        part transmission : Transmission[1];\n    }\n    \n    abstract part def Engine;\n    part def FourCylinderEngine :> Engine;\n    part def SixCylinderEngine :> Engine;\n    \n    abstract part def Transmission;\n    part def ManualTransmission :> Transmission;\n    part def AutomaticTransmission :> Transmission;\n    \n    constraint def HighPerformanceRequiresV6 {\n        doc /* If the vehicle is a high-performance model, it must be equipped with a six-cylinder engine */\n        in vehicle : Vehicle;\n        vehicle.isHighPerformance implies vehicle.engine istype SixCylinderEngine\n    }\n    \n    constraint def StandardRequiresV4 {\n        doc /* If the vehicle is not a high-performance model, a four-cylinder engine must be used */\n        in vehicle : Vehicle;\n        not vehicle.isHighPerformance implies vehicle.engine istype FourCylinderEngine\n    }\n    \n    constraint def ValidPowertrainCombinations {\n        doc /* Only two valid powertrain combinations are permitted */\n        in vehicle : Vehicle;\n        (vehicle.engine istype FourCylinderEngine and vehicle.transmission istype ManualTransmission) or\n        (vehicle.engine istype SixCylinderEngine and vehicle.transmission istype AutomaticTransmission)\n    }\n}",
    "package AutomotiveSystem {\n    import ScalarValues::*;\n    \n    part def Vehicle {\n        attribute mass : Real = 1200.0;\n        attribute length : Real = 4.82;\n        \n        part wheelAssemblies : WheelAssembly[4];\n    }\n    \n    part def WheelAssembly {\n        part wheel : Wheel;\n        part brakeDisc : BrakeDisc;\n        \n        constraint fitmentConstraint {\n            brakeDisc.diameter < wheel.outerDiameter\n        }\n    }\n    \n    part def Wheel {\n        part rim : Rim;\n        part tire : Tire;\n        \n        attribute outerDiameter : Real = rim.diameter * 25.4 + 2 * tire.height;\n    }\n    \n    part def Rim {\n        attribute diameter : Real = 18.0;\n    }\n    \n    part def Tire {\n        attribute width : Real = 245.0;\n        attribute height : Real = 45.0;\n        attribute treadDepth : Real = 6.0;\n        \n        constraint safetyConstraint {\n            treadDepth >= 3.5\n        }\n    }\n    \n    part def BrakeDisc {\n        attribute radius : Real = 95.0;\n        attribute diameter : Real = 2 * radius;\n    }\n}",
    "package FuelSystem {\n    \n    part def FuelTankAssembly {\n        port fuelOutlet : FuelFlowPort;\n        port fuelReturn : FuelFlowPort;\n        \n        part fuelTank : FuelTank;\n        part fuelPump : FuelPump;\n        \n        interface : FuelInterface connect fuelPump.outlet to fuelOutlet;\n        interface : FuelInterface connect fuelReturn to fuelTank.inlet;\n        interface : FuelInterface connect fuelTank.outlet to fuelPump.inlet;\n    }\n    \n    part def FuelTank {\n        port inlet : FuelFlowPort;\n        port outlet : FuelFlowPort;\n        \n        attribute fuelTemperature : Real;\n    }\n    \n    part def FuelPump {\n        port inlet : FuelFlowPort;\n        port outlet : FuelFlowPort;\n        port returnInlet : FuelFlowPort;\n    }\n    \n    port def FuelFlowPort {\n        in item fuel : Fuel;\n        out item fuel : Fuel;\n    }\n    \n    item def Fuel {\n        attribute temperature : Real;\n    }\n    \n    interface def FuelInterface {\n        end supplierPort : FuelFlowPort;\n        end consumerPort : FuelFlowPort;\n    }\n    \n    part automotiveFuelSystem : FuelTankAssembly {\n        doc /* This system is used for the automotive fuel system and covers the requirements \n             * for components such as the fuel tank assembly, fuel pump, and fuel tank. */\n    }\n}",
    "package PhysicalQuantityManagementSystem {\n    \n    import ISQ::*;\n    import SI::*;\n    \n    part def PhysicalQuantitySystem {\n        attribute systemName : String;\n        attribute version : String;\n        \n        part quantities : PhysicalQuantity[1..*];\n        part units : MeasurementUnit[1..*];\n        part dataManager : DataManager;\n        part unitConverter : UnitConverter;\n    }\n    \n    abstract part def PhysicalQuantity {\n        attribute name : String;\n        attribute symbol : String;\n        attribute dimension : String;\n        attribute value : Real;\n        attribute unit : MeasurementUnit;\n    }\n    \n    part def BaseQuantity :> PhysicalQuantity {\n        attribute isBase : Boolean = true;\n    }\n    \n    part def DerivedQuantity :> PhysicalQuantity {\n        attribute isBase : Boolean = false;\n        attribute derivationFormula : String;\n    }\n    \n    abstract part def MeasurementUnit {\n        attribute name : String;\n        attribute symbol : String;\n        attribute quantity : PhysicalQuantity;\n    }\n    \n    part def BaseUnit :> MeasurementUnit {\n        attribute conversionFactor : Real = 1.0;\n    }\n    \n    part def DerivedUnit :> MeasurementUnit {\n        attribute baseUnits : BaseUnit[1..*];\n        attribute exponents : Real[1..*];\n    }\n    \n    part def Length :> BaseQuantity {\n        attribute name redefines name = \"length\";\n        attribute symbol redefines symbol = \"L\";\n        attribute dimension redefines dimension = \"L\";\n    }\n    \n    part def Mass :> BaseQuantity {\n        attribute name redefines name = \"mass\";\n        attribute symbol redefines symbol = \"M\";\n        attribute dimension redefines dimension = \"M\";\n    }\n    \n    part def Time :> BaseQuantity {\n        attribute name redefines name = \"time\";\n        attribute symbol redefines symbol = \"T\";\n        attribute dimension redefines dimension = \"T\";\n    }\n    \n    part def ElectricCurrent :> BaseQuantity {\n        attribute name redefines name = \"electric current\";\n        attribute symbol redefines symbol = \"I\";\n        attribute dimension redefines dimension = \"I\";\n    }\n    \n    part def Temperature :> BaseQuantity {\n        attribute name redefines name = \"temperature\";\n        attribute symbol redefines symbol = \"Θ\";\n        attribute dimension redefines dimension = \"Θ\";\n    }\n    \n    part def AmountOfSubstance :> BaseQuantity {\n        attribute name redefines name = \"amount of substance\";\n        attribute symbol redefines symbol = \"N\";\n        attribute dimension redefines dimension = \"N\";\n    }\n    \n    part def LuminousIntensity :> BaseQuantity {\n        attribute name redefines name = \"luminous intensity\";\n        attribute symbol redefines symbol = \"J\";\n        attribute dimension redefines dimension = \"J\";\n    }\n    \n    part def DataManager {\n        attribute dataStore : PhysicalQuantity[0..*];\n        \n        action storeQuantity {\n            in quantity : PhysicalQuantity;\n            out success : Boolean;\n        }\n        \n        action retrieveQuantity {\n            in quantityName : String;\n            out quantity : PhysicalQuantity;\n        }\n        \n        action validateData {\n            in quantity : PhysicalQuantity;\n            out isValid : Boolean;\n        }\n        \n        action ensureConsistency {\n            out consistencyStatus : Boolean;\n        }\n    }\n    \n    part def UnitConverter {\n        action convert {\n            in sourceValue : Real;\n            in sourceUnit : MeasurementUnit;\n            in targetUnit : MeasurementUnit;\n            out targetValue : Real;\n        }\n        \n        action validateConversion {\n            in sourceUnit : MeasurementUnit;\n            in targetUnit : MeasurementUnit;\n            out isConvertible : Boolean;\n        }\n    }\n    \n    part def ExtensionManager {\n        action importQuantity {\n            in externalQuantity : PhysicalQuantity;\n            out importedQuantity : PhysicalQuantity;\n        }\n        \n        action extendSystem {\n            in newQuantity : PhysicalQuantity;\n            in newUnit : MeasurementUnit;\n            out success : Boolean;\n        }\n    }\n    \n    part physicalQuantitySystemInstance : PhysicalQuantitySystem {\n        part lengthQuantity : Length;\n        part massQuantity : Mass;\n        part timeQuantity : Time;\n        part currentQuantity : ElectricCurrent;\n        part temperatureQuantity : Temperature;\n        part substanceQuantity : AmountOfSubstance;\n        part luminousQuantity : LuminousIntensity;\n        \n        part extensionManager : ExtensionManager;\n    }\n}",
    "package UnitSystemLibrary {\n    \n    package ISQUnits {\n        attribute def Length;\n        attribute def Mass;\n        attribute def Time;\n        attribute def Temperature;\n        attribute def ElectricCurrent;\n        attribute def AmountOfSubstance;\n        attribute def LuminousIntensity;\n    }\n    \n    package USCustomaryUnits {\n        attribute def Length;\n        attribute def Mass;\n        attribute def Time;\n        attribute def Temperature;\n        attribute def Volume;\n    }\n    \n    attribute def PhysicalQuantity {\n        attribute value : Real;\n        attribute unitType : String;\n    }\n    \n    part def UnitConverter {\n        attribute sourceUnit : PhysicalQuantity;\n        attribute targetUnit : PhysicalQuantity;\n        \n        action convert {\n            in source : PhysicalQuantity;\n            out target : PhysicalQuantity;\n        }\n    }\n    \n    part def UnitValidator {\n        action validate {\n            in quantity : PhysicalQuantity;\n            out isValid : Boolean;\n        }\n    }\n    \n    part def UnitRegistry {\n        attribute registeredUnits : PhysicalQuantity[*];\n        \n        action registerUnit {\n            in unit : PhysicalQuantity;\n        }\n        \n        action lookupUnit {\n            in unitType : String;\n            out unit : PhysicalQuantity;\n        }\n    }\n    \n    part def UnitSystemAdapter {\n        part converter : UnitConverter;\n        part validator : UnitValidator;\n        part registry : UnitRegistry;\n        \n        port inputPort {\n            in quantity : PhysicalQuantity;\n        }\n        \n        port outputPort {\n            out quantity : PhysicalQuantity;\n        }\n        \n        action adaptUnit {\n            in sourceQuantity : PhysicalQuantity;\n            in targetUnitType : String;\n            out targetQuantity : PhysicalQuantity;\n        }\n    }\n    \n    part def StandardizedUnitSystem {\n        part isqUnits : ISQUnits;\n        part usCustomaryUnits : USCustomaryUnits;\n        part adapter : UnitSystemAdapter;\n        \n        interface def UnitConversionInterface {\n            end userEnd;\n            end systemEnd;\n        }\n        \n        port userInterface : UnitConversionInterface;\n        \n        action processUnitRequest {\n            in request : PhysicalQuantity;\n            in targetSystem : String;\n            out result : PhysicalQuantity;\n        }\n    }\n}",
    "package HeadlampTiltAdjustmentSystem {\n    import ISQ::*;\n    import SI::*;\n    import ScalarValues::*;\n    \n    part def HeadlampTiltAdjustmentKnob {\n        attribute tiltAngle : ScalarValues::Real;\n        \n        constraint tiltAngleRange {\n            (tiltAngle >= 50.0) & (tiltAngle <= 80.0)\n        }\n    }\n    \n    part def HeadlampBeam {\n        attribute beamTiltAngle : ScalarValues::Real;\n        attribute unit : SI::deg = SI::deg;\n    }\n    \n    part def TiltAdjustmentVerificationSystem {\n        part knob : HeadlampTiltAdjustmentKnob;\n        part beam : HeadlampBeam;\n        \n        attribute isValid : ScalarValues::Boolean;\n        \n        constraint validateTiltAngle {\n            beam.beamTiltAngle == knob.tiltAngle\n        }\n        \n        constraint checkCompliance {\n            isValid == ((beam.beamTiltAngle >= 50.0) & (beam.beamTiltAngle <= 80.0))\n        }\n    }\n    \n    part tiltAdjustmentSystem : TiltAdjustmentVerificationSystem;\n}",
    "package DataTypes {\n    datatype UnsignedInteger :> ScalarValues::Integer {\n        constraint { self >= 0 }\n    }\n    \n    datatype UnsignedFloat :> ScalarValues::Real {\n        constraint { self >= 0.0 }\n    }\n    \n    datatype DateTime :> ScalarValues::String;\n    \n    datatype String :> ScalarValues::String;\n    \n    datatype Boolean :> ScalarValues::Boolean;\n    \n    enum def StatusLevel {\n        enum critical;\n        enum warning;\n        enum normal;\n    }\n    \n    enum def ColorLabel {\n        enum red;\n        enum yellow;\n        enum green;\n    }\n    \n    attribute def StatusColor {\n        attribute status : StatusLevel;\n        attribute color : ColorLabel;\n        \n        constraint statusToColorMapping {\n            (status == StatusLevel::critical implies color == ColorLabel::red) and\n            (status == StatusLevel::warning implies color == ColorLabel::yellow) and\n            (status == StatusLevel::normal implies color == ColorLabel::green)\n        }\n    }\n    \n    enum def DiameterSize {\n        enum small;\n        enum medium;\n        enum large;\n    }\n    \n    attribute def Diameter {\n        attribute size : DiameterSize default DiameterSize::small;\n        attribute value : UnsignedFloat;\n        \n        constraint sizeToValueMapping {\n            (size == DiameterSize::small implies value == 60.0) and\n            (size == DiameterSize::medium implies value == 70.0) and\n            (size == DiameterSize::large implies value == 80.0)\n        }\n    }\n}",
    "package SparePartsManagementSystem {\n    \n    part def SparePart;\n    \n    part def Person;\n    \n    part def SystemManager {\n        attribute sparePartsBag : Bag[0..*] of SparePart;\n        attribute integersList : List[0..*] of Integer;\n        attribute stringsSet : Set[0..*] of String;\n        attribute personnelOrderedSet : OrderedSet[0..*] of Person;\n        attribute nestedPersonSets : List[0..*] of Set[0..*] of Person;\n        attribute realNumbersArray : Real[4];\n    }\n}",
    "package TireInformationSystem {\n    import ScalarValues::*;\n    \n    attribute def ManufacturerName :> String;\n    attribute def RimDiameter :> Real {\n        doc /* Rim diameter in inches */\n    }\n    attribute def TireWidth :> Real;\n    \n    attribute def Position {\n        attribute x :> Real;\n        attribute y :> Real;\n        attribute z :> Real;\n    }\n    \n    item def Tire {\n        attribute manufacturer : ManufacturerName;\n        attribute rimDiameter : RimDiameter;\n        attribute width : TireWidth;\n        attribute installationPosition : Position[0..1];\n    }\n    \n    item michelinTire : Tire {\n        attribute :>> manufacturer = \"Michelin\";\n        attribute :>> rimDiameter = 18.0;\n        attribute :>> width = 245.0;\n    }\n}",
    "package SpacecraftTrajectorySystem {\n    import ScalarValues::*;\n    import Quantities::*;\n    import MeasurementReferences::*;\n    import ISQ::*;\n    import SI::*;\n    \n    attribute def TimePoint {\n        attribute secondsSinceLiftoff : Real;\n    }\n    \n    attribute def UTCTime {\n        attribute year : Integer;\n        attribute month : Integer;\n        attribute day : Integer;\n        attribute hour : Integer;\n        attribute minute : Integer;\n        attribute second : Real;\n    }\n    \n    attribute def Position3D {\n        attribute x : LengthValue;\n        attribute y : LengthValue;\n        attribute z : LengthValue;\n    }\n    \n    attribute def Velocity3D {\n        attribute vx : SpeedValue;\n        attribute vy : SpeedValue;\n        attribute vz : SpeedValue;\n    }\n    \n    item def TrajectoryDataPoint {\n        attribute timePoint : TimePoint;\n        attribute position : Position3D;\n        attribute velocity : Velocity3D;\n    }\n    \n    part def TrajectoryRecordingSystem {\n        attribute missionLiftoffTime : UTCTime;\n        attribute trajectoryData : TrajectoryDataPoint[1..*];\n        \n        port trajectoryInput {\n            in item position : Position3D;\n            in item velocity : Velocity3D;\n            in item currentTime : TimePoint;\n        }\n        \n        port trajectoryOutput {\n            out item recordedData : TrajectoryDataPoint[1..*];\n        }\n    }\n    \n    part def SpacecraftAscentSystem {\n        part trajectoryRecorder : TrajectoryRecordingSystem {\n            attribute redefines missionLiftoffTime {\n                :>> year = 2020;\n                :>> month = 8;\n                :>> day = 23;\n                :>> hour = 22;\n                :>> minute = 42;\n                :>> second = 32.924534;\n            }\n        }\n    }\n}",
    "package AlloyManagementSystem {\n    import ISQ::*;\n    import SI::*;\n    import ScalarValues::*;\n    \n    // Define tensile strength unit\n    attribute def TensileStrengthUnit :> DerivedUnit {\n        :>> symbol = \"N/mm²\";\n        :>> unitPowerFactor[0] {\n            :>> unit = N;\n            :>> exponent = 1;\n        }\n        :>> unitPowerFactor[1] {\n            :>> unit = mm;\n            :>> exponent = -2;\n        }\n    }\n    \n    // Base substance definition\n    abstract item def Substance {\n        attribute name : String;\n        attribute atomicMass : Real;\n    }\n    \n    // Material definition extending substance\n    abstract item def Material :> Substance {\n        attribute tensileStrength : Real;\n    }\n    \n    // Metal definition\n    item def Metal :> Material;\n    \n    // Alloy component definition\n    item def AlloyComponent {\n        ref material : Material;\n        attribute massFraction : Real;\n    }\n    \n    // Alloy definition\n    item def Alloy :> Material {\n        part components : AlloyComponent[2..*];\n        \n        constraint {\n            sum(components.massFraction) == 1.0\n        }\n    }\n    \n    // Define specific metals\n    item iron : Metal {\n        :>> name = \"Iron\";\n        :>> atomicMass = 55.845;\n        :>> tensileStrength = 250.0;\n    }\n    \n    item carbon : Metal {\n        :>> name = \"Carbon\";\n        :>> atomicMass = 12.011;\n        :>> tensileStrength = 130.0;\n    }\n    \n    item manganese : Metal {\n        :>> name = \"Manganese\";\n        :>> atomicMass = 54.938;\n        :>> tensileStrength = 650.0;\n    }\n    \n    // Define steel 980 alloy\n    item steel980 : Alloy {\n        :>> name = \"Steel 980\";\n        :>> tensileStrength = 980.0;\n        \n        :>> components {\n            item : AlloyComponent {\n                :>> material = iron;\n                :>> massFraction = 0.982;\n            }\n            item : AlloyComponent {\n                :>> material = carbon;\n                :>> massFraction = 0.008;\n            }\n            item : AlloyComponent {\n                :>> material = manganese;\n                :>> massFraction = 0.010;\n            }\n        }\n    }\n}",
    "package MaterialsDatabase {\n    import ScalarValues::*;\n    import Quantities::*;\n    import UnitsAndScales::*;\n    import ISQ::*;\n    \n    attribute def MaterialProperty {\n        attribute name : String;\n        attribute value : Real;\n        attribute unit : String;\n    }\n    \n    attribute def CompositionElement {\n        attribute element : String;\n        attribute massFraction : Real;\n    }\n    \n    abstract part def Material {\n        attribute materialName : String;\n        attribute atomicMass : Real;\n        attribute composition : CompositionElement[0..*];\n        attribute mechanicalProperties : MaterialProperty[0..*];\n    }\n    \n    part def Metal :> Material {\n        attribute metalType : String;\n    }\n    \n    part def Alloy :> Material {\n        attribute alloyType : String;\n        attribute baseElement : String;\n    }\n    \n    attribute def TensileStrength {\n        attribute value : Real;\n        attribute unit : String = \"N/mm^2\";\n    }\n    \n    part def Steel_980 :> Alloy {\n        attribute :>> materialName = \"High Strength Steel 980\";\n        attribute :>> alloyType = \"Steel\";\n        attribute :>> baseElement = \"Fe\";\n        \n        attribute :>> composition = (\n            CompositionElement {\n                :>> element = \"Fe\";\n                :>> massFraction = 0.9765;\n            },\n            CompositionElement {\n                :>> element = \"C\";\n                :>> massFraction = 0.0015;\n            },\n            CompositionElement {\n                :>> element = \"Mn\";\n                :>> massFraction = 0.022;\n            }\n        );\n        \n        attribute tensileStrength : TensileStrength {\n            :>> value = 980.0;\n        }\n        \n        attribute :>> mechanicalProperties = (\n            MaterialProperty {\n                :>> name = \"Tensile Strength\";\n                :>> value = 980.0;\n                :>> unit = \"N/mm^2\";\n            }\n        );\n    }\n    \n    part def MaterialsManagementSystem {\n        part materials : Material[0..*];\n        \n        action addMaterial {\n            in material : Material;\n        }\n        \n        action queryMaterial {\n            in materialName : String;\n            out material : Material;\n        }\n        \n        action compareMaterials {\n            in material1 : Material;\n            in material2 : Material;\n        }\n    }\n}",
    "package PubSubSystem {\n    \n    part def Message {\n        attribute content : String;\n        attribute timestamp : String;\n        attribute topicName : String;\n    }\n    \n    part def Topic {\n        attribute name : String;\n        attribute description : String;\n    }\n    \n    part def Producer {\n        port publishPort : PublishInterface;\n    }\n    \n    part def Consumer {\n        port subscribePort : SubscribeInterface;\n        attribute subscribedTopics : String[*];\n    }\n    \n    part def Server {\n        port producerPort : PublishInterface;\n        port consumerPort : SubscribeInterface;\n        attribute topics : Topic[*];\n        attribute subscriptions : Subscription[*];\n    }\n    \n    part def Subscription {\n        attribute topicName : String;\n        attribute consumerId : String;\n    }\n    \n    interface def PublishInterface {\n        in item publishMessage : Message;\n    }\n    \n    interface def SubscribeInterface {\n        in item subscribeTopic : String;\n        out item receiveMessage : Message;\n    }\n    \n    part def PubSubSystemModel {\n        part producers : Producer[*];\n        part consumers : Consumer[*];\n        part server : Server;\n        \n        interface : PublishInterface connect producers.publishPort to server.producerPort;\n        interface : SubscribeInterface connect consumers.subscribePort to server.consumerPort;\n    }\n}",
    "package VehicleFuelSystem {\n    \n    part def FuelTankAssembly {\n        attribute fuelLevel : Real;\n        attribute fuelTemperature : Real;\n        \n        port fuelSupplyPort : FuelFlow;\n        port fuelReturnPort : ~FuelFlow;\n    }\n    \n    part def Engine {\n        attribute fuelConsumptionRate : Real;\n        \n        port fuelInletPort : ~FuelFlow;\n        port fuelOutletPort : FuelFlow;\n    }\n    \n    part def FuelLine {\n        port inPort : ~FuelFlow;\n        port outPort : FuelFlow;\n    }\n    \n    interface def FuelFlow {\n        attribute flowRate : Real;\n        attribute temperature : Real;\n    }\n    \n    part def Vehicle {\n        part fuelTank : FuelTankAssembly;\n        part engine : Engine;\n        part supplyLine : FuelLine;\n        part returnLine : FuelLine;\n        \n        interface supplyConnection : FuelFlow connect fuelTank.fuelSupplyPort to supplyLine.inPort;\n        interface supplyToEngine : FuelFlow connect supplyLine.outPort to engine.fuelInletPort;\n        interface returnFromEngine : FuelFlow connect engine.fuelOutletPort to returnLine.inPort;\n        interface returnConnection : FuelFlow connect returnLine.outPort to fuelTank.fuelReturnPort;\n    }\n}",
    "package PublishSubscribeSystem {\n    \n    part def Producer {\n        port publishPort : PublishPort;\n    }\n    \n    part def Server {\n        port receivePublishPort : ~PublishPort;\n        port receiveSubscribePort : ~SubscribePort;\n        port deliverPort : DeliverPort;\n        \n        attribute topics : String[*];\n        attribute subscriptions : Subscription[*];\n    }\n    \n    part def Consumer {\n        port subscribePort : SubscribePort;\n        port receivePort : ~DeliverPort;\n    }\n    \n    part def Subscription {\n        attribute topic : String;\n        attribute consumer : Consumer;\n    }\n    \n    port def PublishPort {\n        out message : Message;\n    }\n    \n    port def SubscribePort {\n        out subscriptionRequest : SubscriptionRequest;\n    }\n    \n    port def DeliverPort {\n        out message : Message;\n    }\n    \n    item def Message {\n        attribute topic : String;\n        attribute content : String;\n    }\n    \n    item def SubscriptionRequest {\n        attribute topic : String;\n    }\n    \n    part pubSubSystem : PublishSubscribeSystem {\n        part producers : Producer[*];\n        part server : Server;\n        part consumers : Consumer[*];\n        \n        interface publishInterface : PublishPort connect producers.publishPort to server.receivePublishPort;\n        interface subscribeInterface : SubscribePort connect consumers.subscribePort to server.receiveSubscribePort;\n        interface deliverInterface : DeliverPort connect server.deliverPort to consumers.receivePort;\n    }\n}",
    "package TransportationSystem {\n    \n    part def Vehicle {\n        attribute fuelLevel : Real;\n        attribute maxTankCapacity : Real;\n        attribute currentPassengers : Integer;\n        \n        port driverPort : DriverInterface;\n        port passengerPort : PassengerInterface[0..4];\n        port fuelPort : FuelInterface;\n    }\n    \n    part def Driver {\n        port vehicleControl : DriverInterface;\n    }\n    \n    part def Passenger {\n        port vehicleAccess : PassengerInterface;\n    }\n    \n    part def GasStation {\n        port fuelSupply : FuelInterface;\n    }\n    \n    part def Environment {\n        attribute conditions : String;\n    }\n    \n    interface def DriverInterface {\n        in item command : String;\n        out item status : String;\n    }\n    \n    interface def PassengerInterface {\n        in item boardingRequest : Boolean;\n        out item boardingStatus : Boolean;\n    }\n    \n    interface def FuelInterface {\n        in item fuelRequest : Real;\n        out item fuelDelivered : Real;\n    }\n    \n    part transportationSystem : TransportationSystem {\n        part vehicle : Vehicle;\n        part driver : Driver;\n        part passengers : Passenger[0..4];\n        part gasStation : GasStation;\n        part environment : Environment;\n        \n        connection : Connect(driver.vehicleControl, vehicle.driverPort);\n        connection : Connect(passengers.vehicleAccess, vehicle.passengerPort);\n        connection : Connect(vehicle.fuelPort, gasStation.fuelSupply);\n    }\n    \n    action def EnterVehicle {\n        in actor : Driver;\n        in passengers : Passenger[0..*];\n        out vehicle : Vehicle;\n    }\n    \n    action def OperateVehicle {\n        in driver : Driver;\n        in vehicle : Vehicle;\n        out travelCompleted : Boolean;\n    }\n    \n    action def RefuelVehicle {\n        in vehicle : Vehicle;\n        in gasStation : GasStation;\n        out fuelLevel : Real;\n    }\n    \n    action def ExitVehicle {\n        in vehicle : Vehicle;\n        in driver : Driver;\n        in passengers : Passenger[0..*];\n    }\n    \n    action transportationProcess : Action {\n        first start;\n        \n        then action enterVehicle : EnterVehicle {\n            in actor = driver;\n            in passengers = passengers;\n            out vehicle = vehicle;\n        }\n        \n        then action operateVehicle : OperateVehicle {\n            in driver = driver;\n            in vehicle = vehicle;\n        }\n        \n        then decide fuelCheck {\n            if vehicle.fuelLevel < vehicle.maxTankCapacity * 0.1 \n                then refuel\n                else continueTravel;\n        }\n        \n        action refuel : RefuelVehicle {\n            in vehicle = vehicle;\n            in gasStation = gasStation;\n        }\n        then merge continueTravel;\n        \n        action continueTravel : Action;\n        \n        then action exitVehicle : ExitVehicle {\n            in vehicle = vehicle;\n            in driver = driver;\n            in passengers = passengers;\n        }\n        \n        then done;\n    }\n}",
    "package FuelManagementSystem {\n    \n    part def FuelTankAssembly {\n        attribute fuelCapacity : Real;\n        attribute currentFuelLevel : Real;\n        \n        port fuelOutlet : FuelPort {\n            out item fuel : Fuel;\n        }\n        \n        port fuelReturn : FuelPort {\n            in item fuel : Fuel;\n        }\n    }\n    \n    part def EngineUnit {\n        attribute fuelConsumptionRate : Real;\n        \n        port fuelInlet : FuelPort {\n            in item fuel : Fuel;\n        }\n        \n        port fuelReturnOutlet : FuelPort {\n            out item fuel : Fuel;\n        }\n    }\n    \n    port def FuelPort {\n        attribute fuelTemperature : Real;\n        attribute fuelPressure : Real;\n    }\n    \n    item def Fuel {\n        attribute temperature : Real;\n        attribute volume : Real;\n    }\n    \n    interface def FuelInterface {\n        end supplierPort : FuelPort;\n        end consumerPort : FuelPort;\n    }\n    \n    part def VehicleFuelSystem {\n        part fuelTank : FuelTankAssembly;\n        part engine : EngineUnit;\n        \n        interface fuelSupplyInterface : FuelInterface connect \n            supplierPort ::> fuelTank.fuelOutlet to \n            consumerPort ::> engine.fuelInlet;\n            \n        interface fuelReturnInterface : FuelInterface connect \n            supplierPort ::> engine.fuelReturnOutlet to \n            consumerPort ::> fuelTank.fuelReturn;\n    }\n}",
    "package FuelSystemModel {\n    import ScalarValues::*;\n    \n    attribute def Temperature {\n        attribute value : Real;\n        attribute unit : String = \"Celsius\";\n    }\n    \n    item def Fuel {\n        attribute temperature : Temperature;\n    }\n    \n    flow def FuelFlow {\n        ref item fuel : Fuel;\n    }\n    \n    interface def FuelInterface {\n        end supplierPort;\n        end consumerPort;\n        \n        flow fuelSupply : FuelFlow from supplierPort to consumerPort;\n        flow fuelReturn : FuelFlow from consumerPort to supplierPort;\n    }\n    \n    part def FuelTankAssembly {\n        port fuelSupplyPort : FuelInterface::supplierPort;\n        \n        attribute currentFuelTemperature : Temperature;\n    }\n    \n    part def Engine {\n        port fuelPort : FuelInterface::consumerPort;\n        \n        attribute fuelTemperature : Temperature;\n    }\n    \n    part def VehicleFuelSystem {\n        part fuelTank : FuelTankAssembly;\n        part engine : Engine;\n        \n        interface : FuelInterface connect fuelTank.fuelSupplyPort to engine.fuelPort;\n    }\n}",
    "package PhotoCaptureSystem {\n    \n    part def Camera {\n        attribute focusDistance : Real;\n        attribute aperture : Real;\n        attribute shutterSpeed : Real;\n    }\n    \n    part def Scene {\n        attribute location : String;\n        attribute lighting : Real;\n        attribute distance : Real;\n    }\n    \n    part def Image {\n        attribute resolution : String;\n        attribute format : String;\n        attribute quality : Real;\n    }\n    \n    part def User {\n        attribute userId : String;\n    }\n    \n    part def PhotoCaptureSystemDef {\n        part user : User;\n        part camera : Camera;\n        part selectedScene : Scene;\n        part focusedImage : Image;\n        part finalPhoto : Image;\n        \n        action selectScene {\n            in item userInput : Scene;\n            out item selected : Scene;\n        }\n        \n        action performAutoFocus {\n            in item scene : Scene;\n            out item focused : Image;\n            \n            bind scene = selectedScene;\n            bind focused = focusedImage;\n        }\n        \n        action capturePhoto {\n            in item focusedImg : Image;\n            out item photo : Image;\n            \n            bind focusedImg = focusedImage;\n            bind photo = finalPhoto;\n        }\n        \n        action obtainPhoto {\n            first selectScene\n                then performAutoFocus\n                then capturePhoto;\n        }\n    }\n}",
    "package CameraSystem {\n    \n    part def Camera;\n    part def Scene;\n    part def Image;\n    \n    action def Focus {\n        in scene : Scene;\n        out focusedImage : Image;\n    }\n    \n    action def Shoot {\n        in focusedImage : Image;\n        out finalImage : Image;\n    }\n    \n    action def PhotographyWorkflow {\n        in selectedScene : Scene;\n        out photograph : Image;\n        \n        action focusing : Focus {\n            in scene = selectedScene;\n        }\n        \n        action shooting : Shoot {\n            in focusedImage = focusing.focusedImage;\n        }\n        \n        flow focusing.focusedImage to shooting.focusedImage;\n        \n        bind photograph = shooting.finalImage;\n    }\n    \n    part cameraSystem : Camera {\n        perform PhotographyWorkflow;\n    }\n}",
    "package PhotographySystem {\n    \n    part def Camera;\n    part def User;\n    part def Scene;\n    part def Image;\n    part def Photograph;\n    \n    action def SelectScene {\n        in user : User;\n        in scene : Scene;\n        out selectedScene : Scene;\n    }\n    \n    action def Focus {\n        in scene : Scene;\n        out image : Image;\n    }\n    \n    action def Shoot {\n        in image : Image;\n        out photograph : Photograph;\n    }\n    \n    action def CaptureWorkflow {\n        in user : User;\n        in scene : Scene;\n        out photograph : Photograph;\n        \n        action selectScene : SelectScene {\n            in user = CaptureWorkflow::user;\n            in scene = CaptureWorkflow::scene;\n        }\n        \n        flow selectScene.selectedScene to focus.scene;\n        \n        action focus : Focus;\n        \n        flow focus.image to shoot.image;\n        \n        action shoot : Shoot;\n        \n        flow shoot.photograph to photograph;\n    }\n    \n    part photographySystem : Camera {\n        part user : User;\n        part scene : Scene;\n        \n        perform CaptureWorkflow {\n            in user = photographySystem::user;\n            in scene = photographySystem::scene;\n        }\n    }\n}",
    "package AutomatedPhotographySystem {\n    \n    part def Scene;\n    part def FocusedImage;\n    part def Photograph;\n    \n    action def ProvideShooting {\n        in scene : Scene;\n    }\n    \n    action def PerformFocus {\n        in scene : Scene;\n        out focusedImage : FocusedImage;\n    }\n    \n    action def ConvertToPhotograph {\n        in focusedImage : FocusedImage;\n        out photograph : Photograph;\n    }\n    \n    action def AutomatePhotography {\n        in inputScene : Scene;\n        out finalPhotograph : Photograph;\n        \n        action provideShooting : ProvideShooting {\n            in scene = inputScene;\n        }\n        \n        action performFocus : PerformFocus {\n            in scene = inputScene;\n        }\n        \n        action convertToPhotograph : ConvertToPhotograph {\n            in focusedImage = performFocus.focusedImage;\n        }\n        \n        flow from provideShooting to performFocus;\n        flow from performFocus.focusedImage to convertToPhotograph.focusedImage;\n        \n        bind finalPhotograph = convertToPhotograph.photograph;\n    }\n    \n    part photographySystem {\n        perform AutomatePhotography;\n    }\n}",
    "package PhotographyWorkflow {\n    part def Scene;\n    part def Image;\n    part def Picture;\n    \n    action def Focus {\n        in scene : Scene;\n        out image : Image;\n    }\n    \n    action def Shoot {\n        in image : Image;\n        out picture : Picture;\n    }\n    \n    action def PhotographyProcess {\n        in inputScene : Scene;\n        out outputPicture : Picture;\n        \n        action focus : Focus {\n            in scene = inputScene;\n        }\n        \n        action shoot : Shoot {\n            in image = focus.image;\n        }\n        \n        bind outputPicture = shoot.picture;\n    }\n}",
    "package PhotographySystem {\n    \n    part def Camera {\n        attribute isFocused : Boolean = false;\n        \n        action def focusScene {\n            in scene : Scene;\n            out focusResult : Boolean;\n        }\n        \n        action def capturePhoto {\n            in scene : Scene;\n            out photograph : Photograph;\n        }\n    }\n    \n    item def Scene;\n    item def Photograph;\n    \n    part def PhotographyWorkflow {\n        part camera : Camera;\n        \n        action shootingProcess {\n            in selectedScene : Scene;\n            out finalImage : Photograph;\n            \n            action focus : camera.focusScene {\n                in scene = selectedScene;\n            }\n            \n            action capture : camera.capturePhoto {\n                in scene = selectedScene;\n            }\n            \n            flow focus.focusResult to decide;\n            \n            action decide {\n                in focusStatus : Boolean;\n                \n                if focusStatus {\n                    then capture;\n                }\n            }\n            \n            flow capture.photograph to finalImage;\n            \n            first focus then decide;\n        }\n    }\n}",
    "package CameraSystem {\n    \n    part def Camera;\n    part def User;\n    part def Scene;\n    part def Image;\n    part def Photo;\n    \n    attribute def FocusQuality;\n    \n    action def SelectScene {\n        in user : User;\n        in scene : Scene;\n        out selectedScene : Scene;\n    }\n    \n    action def PerformFocusing {\n        in scene : Scene;\n        out focusedImage : Image;\n    }\n    \n    action def EvaluateFocusQuality {\n        in image : Image;\n        out quality : FocusQuality;\n        out isWellFocused : Boolean;\n    }\n    \n    action def ConvertToPhoto {\n        in focusedImage : Image;\n        out photo : Photo;\n    }\n    \n    action def CapturePhoto {\n        in scene : Scene;\n        out photo : Photo;\n        \n        action selectScene : SelectScene {\n            in user = CapturePhoto::user;\n            in scene = CapturePhoto::scene;\n        }\n        \n        then action focus : PerformFocusing {\n            in scene = selectScene.selectedScene;\n        }\n        \n        then action evaluate : EvaluateFocusQuality {\n            in image = focus.focusedImage;\n        }\n        \n        then action shoot : ConvertToPhoto {\n            in focusedImage = focus.focusedImage;\n        } if evaluate.isWellFocused;\n        \n        bind photo = shoot.photo;\n    }\n    \n    part cameraSystem : Camera {\n        part user : User;\n        \n        perform action photographyWorkflow : CapturePhoto {\n            in user = cameraSystem.user;\n        }\n    }\n}",
    "package CameraSystem {\n    \n    part def Camera {\n        attribute currentScene : String;\n        attribute focusedImage : String;\n        attribute finalPhoto : String;\n        \n        action takePhoto {\n            first start;\n            then acquireScene;\n            then focus;\n            then shoot;\n            then display;\n            then done;\n        }\n        \n        action acquireScene {\n            out scene : String;\n        }\n        \n        action focus {\n            in scene : String;\n            out image : String;\n        }\n        \n        action shoot {\n            in image : String;\n            out photo : String;\n        }\n        \n        action display {\n            in photo : String;\n        }\n        \n        flow from acquireScene.scene to focus.scene;\n        flow from focus.image to shoot.image;\n        flow from shoot.photo to display.photo;\n    }\n    \n    part cameraInstance : Camera;\n}",
    "package AutomaticBrakingControlSystem {\n    \n    part def Vehicle;\n    part def BrakingControlSystem;\n    part def BrakePedal;\n    part def BrakePressureSensor;\n    part def TractionSensor;\n    part def BrakeActuator;\n    part def IgnitionKey;\n    \n    attribute def BrakePressure : Real;\n    attribute def TractionLevel : Real;\n    attribute def ModulationFrequency : Real;\n    attribute def KeyPosition : String;\n    attribute def SystemStatus : String;\n    \n    part vehicle : Vehicle {\n        part brakingSystem : BrakingControlSystem {\n            attribute status : SystemStatus;\n            attribute currentBrakePressure : BrakePressure;\n            attribute currentModulationFreq : ModulationFrequency;\n            \n            part brakePedal : BrakePedal {\n                attribute pedalPressure : BrakePressure;\n            }\n            \n            part pressureSensor : BrakePressureSensor {\n                attribute detectedPressure : BrakePressure;\n            }\n            \n            part tractionSensor : TractionSensor {\n                attribute roadAdhesion : TractionLevel;\n            }\n            \n            part brakeActuator : BrakeActuator {\n                attribute appliedPressure : BrakePressure;\n                attribute modulationFreq : ModulationFrequency;\n            }\n        }\n        \n        part ignitionKey : IgnitionKey {\n            attribute position : KeyPosition;\n        }\n    }\n    \n    action def MonitorBrakePedal {\n        in sensorInput : BrakePressure;\n        out detectedPressure : BrakePressure;\n    }\n    \n    action def MonitorTraction {\n        in roadCondition : TractionLevel;\n        out tractionData : TractionLevel;\n    }\n    \n    action def AdjustBrakePressure {\n        in currentPressure : BrakePressure;\n        in traction : TractionLevel;\n        out adjustedPressure : BrakePressure;\n        out frequency : ModulationFrequency;\n    }\n    \n    action def ActivateSystem {\n        in keyPos : KeyPosition;\n        out systemActive : SystemStatus;\n    }\n    \n    action automaticBrakingControl {\n        first start;\n        then activate : ActivateSystem {\n            in keyPos = vehicle.ignitionKey.position;\n            out systemActive = vehicle.brakingSystem.status;\n        }\n        then loop {\n            action monitorPedal : MonitorBrakePedal {\n                in sensorInput = vehicle.brakingSystem.brakePedal.pedalPressure;\n                out detectedPressure = vehicle.brakingSystem.pressureSensor.detectedPressure;\n            }\n            then monitorTraction : MonitorTraction {\n                in roadCondition = vehicle.brakingSystem.tractionSensor.roadAdhesion;\n                out tractionData;\n            }\n            then adjustBrake : AdjustBrakePressure {\n                in currentPressure = vehicle.brakingSystem.pressureSensor.detectedPressure;\n                in traction = monitorTraction.tractionData;\n                out adjustedPressure = vehicle.brakingSystem.brakeActuator.appliedPressure;\n                out frequency = vehicle.brakingSystem.brakeActuator.modulationFreq;\n            }\n        }\n        then done;\n    }\n}",
    "package BatteryChargingControlSystem {\n    \n    part def BatteryChargingController {\n        attribute batteryLevel : Real;\n        attribute isCharging : Boolean;\n        \n        port batteryMonitor : BatteryMonitorPort;\n        port chargerControl : ChargerControlPort;\n    }\n    \n    part def Battery {\n        attribute currentLevel : Real;\n        attribute maxCapacity : Real = 100.0;\n        \n        port levelOutput : BatteryLevelPort;\n        port chargeInput : ChargingPort;\n    }\n    \n    part def Charger {\n        attribute chargingEnabled : Boolean;\n        attribute chargingCurrent : Real;\n        \n        port controlInput : ChargerControlPort;\n        port powerOutput : ChargingPort;\n    }\n    \n    port def BatteryMonitorPort {\n        out batteryLevel : Real;\n    }\n    \n    port def ChargerControlPort {\n        in enableCharging : Boolean;\n    }\n    \n    port def BatteryLevelPort {\n        out level : Real;\n    }\n    \n    port def ChargingPort {\n        in chargingPower : Real;\n    }\n    \n    part batteryChargingSystem : BatteryChargingController {\n        part battery : Battery;\n        part charger : Charger;\n        \n        connect battery.levelOutput to batteryMonitor;\n        connect chargerControl to charger.controlInput;\n        connect charger.powerOutput to battery.chargeInput;\n        \n        state idle {\n            entry action {\n                isCharging = false;\n            }\n            \n            transition to charging\n                when batteryLevel < 100.0;\n        }\n        \n        state charging {\n            entry action {\n                isCharging = true;\n            }\n            \n            transition to idle\n                when batteryLevel >= 100.0;\n        }\n    }\n}",
    "package BatteryChargingSystem {\n    \n    part def Battery {\n        attribute batteryLevel : Real;\n    }\n    \n    part def ChargingController {\n        attribute isCharging : Boolean;\n    }\n    \n    part def ChargingSystem {\n        part battery : Battery;\n        part controller : ChargingController;\n        \n        action def MonitorBatteryLevel {\n            in batteryRef : Battery;\n            out currentLevel : Real;\n        }\n        \n        action def ReplenishBattery {\n            inout batteryRef : Battery;\n        }\n        \n        action def StartCharging {\n            inout controllerRef : ChargingController;\n        }\n        \n        action def StopCharging {\n            inout controllerRef : ChargingController;\n        }\n        \n        action chargingProcess {\n            first start;\n            \n            action start : StartCharging {\n                inout controllerRef = controller;\n            }\n            \n            then loop;\n            \n            action loop : MonitorBatteryLevel {\n                in batteryRef = battery;\n                out currentLevel;\n            }\n            \n            then decide;\n            \n            action decide {\n                if currentLevel < 100.0 then charge\n                else stop\n            }\n            \n            action charge : ReplenishBattery {\n                inout batteryRef = battery;\n            }\n            then loop;\n            \n            action stop : StopCharging {\n                inout controllerRef = controller;\n            }\n            then done;\n        }\n    }\n}",
    "package CameraSystem {\n    \n    part def Camera {\n        part autofocusSubsystem : AutofocusSubsystem;\n        part imagingSubsystem : ImagingSubsystem;\n        part storageSubsystem : StorageSubsystem;\n        \n        port userInterface : UserInterface;\n        \n        action takePhoto {\n            in scene : Scene;\n            out photo : Photo;\n            \n            action selectScene {\n                in item scene : Scene;\n            }\n            \n            action focus : AutofocusSubsystem::performAutofocus {\n                in item scene : Scene;\n                out item focusedImage : FocusedImage;\n            }\n            \n            action capture : ImagingSubsystem::captureImage {\n                in item focusedImage : FocusedImage;\n                out item photo : Photo;\n            }\n            \n            action save : StorageSubsystem::storePhoto {\n                in item photo : Photo;\n            }\n            \n            flow selectScene.scene to focus.scene;\n            flow focus.focusedImage to capture.focusedImage;\n            flow capture.photo to save.photo;\n            flow capture.photo to photo;\n        }\n    }\n    \n    part def AutofocusSubsystem {\n        action performAutofocus {\n            in scene : Scene;\n            out focusedImage : FocusedImage;\n        }\n    }\n    \n    part def ImagingSubsystem {\n        action captureImage {\n            in focusedImage : FocusedImage;\n            out photo : Photo;\n        }\n    }\n    \n    part def StorageSubsystem {\n        action storePhoto {\n            in photo : Photo;\n        }\n    }\n    \n    port def UserInterface {\n        in sceneSelection : Scene;\n        out photoResult : Photo;\n    }\n    \n    item def Scene;\n    item def FocusedImage;\n    item def Photo;\n}",
    "package DigitalCameraSystem {\n    \n    part def Camera {\n        part sceneSelector : SceneSelector;\n        part focusModule : FocusModule;\n        part imagingModule : ImagingModule;\n        part controller : Controller;\n        \n        port userInterface : UserInterface;\n        port imageOutput : ImageOutput;\n        \n        action shootPhoto {\n            first start;\n            then selectScene;\n            then autoFocus;\n            then captureImage;\n            then outputPhoto;\n            then done;\n            \n            action selectScene {\n                in item scene : Scene;\n                out item selectedScene : Scene;\n            }\n            \n            action autoFocus {\n                in item targetScene : Scene;\n                out item focusSettings : FocusSettings;\n            }\n            \n            action captureImage {\n                in item focus : FocusSettings;\n                out item rawImage : Image;\n            }\n            \n            action outputPhoto {\n                in item image : Image;\n                out item finalPhoto : Photo;\n            }\n        }\n    }\n    \n    part def SceneSelector {\n        attribute availableScenes : Scene[*];\n        \n        action selectScene {\n            in item userSelection : Scene;\n            out item selectedScene : Scene;\n        }\n    }\n    \n    part def FocusModule {\n        attribute currentFocus : FocusSettings;\n        \n        action performAutoFocus {\n            in item scene : Scene;\n            out item focusSettings : FocusSettings;\n        }\n    }\n    \n    part def ImagingModule {\n        attribute sensor : ImageSensor;\n        \n        action capture {\n            in item focusSettings : FocusSettings;\n            out item image : Image;\n        }\n    }\n    \n    part def Controller {\n        action coordinate {\n            in item trigger : Boolean;\n        }\n    }\n    \n    item def Scene {\n        attribute sceneType : String;\n        attribute lightingConditions : String;\n    }\n    \n    item def FocusSettings {\n        attribute focalLength : Real;\n        attribute aperture : Real;\n    }\n    \n    item def Image {\n        attribute resolution : String;\n        attribute format : String;\n    }\n    \n    item def Photo {\n        attribute image : Image;\n        attribute metadata : String;\n    }\n    \n    item def ImageSensor {\n        attribute resolution : String;\n        attribute sensitivity : Real;\n    }\n    \n    port def UserInterface {\n        out item sceneSelection : Scene;\n        in item photoReady : Boolean;\n    }\n    \n    port def ImageOutput {\n        out item photo : Photo;\n    }\n}",
    "package VehicleMotionSimulation {\n    import ScalarValues::*;\n    \n    part def Vehicle {\n        attribute mass : Real;\n        attribute position : Real;\n        attribute velocity : Real;\n    }\n    \n    part def SimulationParameters {\n        attribute timeStep : Real;\n        attribute powerInputSequence : Real[*];\n    }\n    \n    part def SimulationResults {\n        attribute positionTrajectory : Real[*];\n    }\n    \n    part def VehicleMotionSimulator {\n        part vehicle : Vehicle;\n        part parameters : SimulationParameters;\n        part results : SimulationResults;\n        \n        attribute currentTime : Real;\n        attribute currentPowerInput : Real;\n        attribute currentForce : Real;\n        attribute currentAcceleration : Real;\n        \n        action simulateMotion {\n            in vehicleMass : Real;\n            in initialPosition : Real;\n            in initialVelocity : Real;\n            in timeInterval : Real;\n            in powerSequence : Real[*];\n            out trajectoryOutput : Real[*];\n            \n            bind vehicle.mass = vehicleMass;\n            bind vehicle.position = initialPosition;\n            bind vehicle.velocity = initialVelocity;\n            bind parameters.timeStep = timeInterval;\n            bind parameters.powerInputSequence = powerSequence;\n            \n            action calculateTrajectory {\n                for i in 1..size(powerSequence) {\n                    then action updateMotion {\n                        bind currentPowerInput = powerSequence[i];\n                        bind currentForce = currentPowerInput / vehicle.velocity;\n                        bind currentAcceleration = currentForce / vehicle.mass;\n                        bind vehicle.velocity = vehicle.velocity + currentAcceleration * parameters.timeStep;\n                        bind vehicle.position = vehicle.position + vehicle.velocity * parameters.timeStep;\n                        bind results.positionTrajectory[i] = vehicle.position;\n                    }\n                }\n            }\n            \n            bind trajectoryOutput = results.positionTrajectory;\n        }\n    }\n}",
    "package CameraSystem {\n    \n    part def Camera {\n        port sceneInput;\n        port photoOutput;\n    }\n    \n    part def Display {\n        port photoInput;\n    }\n    \n    part def User {\n        port sceneOutput;\n        port photoView;\n    }\n    \n    item def Scene;\n    item def Image;\n    item def Photo;\n    \n    action def Focus {\n        in scene : Scene;\n        out image : Image;\n    }\n    \n    action def Capture {\n        in image : Image;\n        out photo : Photo;\n    }\n    \n    action def ShowPhoto {\n        in photo : Photo;\n    }\n    \n    part cameraSystem {\n        part user : User;\n        part camera : Camera;\n        part display : Display;\n        \n        interface userToCamera connect user.sceneOutput to camera.sceneInput;\n        interface cameraToDisplay connect camera.photoOutput to display.photoInput;\n        interface displayToUser connect display.photoInput to user.photoView;\n        \n        action shootAndDisplay {\n            action focus : Focus {\n                in scene = camera.sceneInput;\n                out image;\n            }\n            then action capture : Capture {\n                in image = focus.image;\n                out photo;\n            }\n            then action show : ShowPhoto {\n                in photo = capture.photo;\n            }\n            \n            bind camera.photoOutput = capture.photo;\n            bind display.photoInput = capture.photo;\n        }\n    }\n}",
    "package CameraSystem {\n    part def Camera {\n        port viewPort;\n        port displayPort;\n    }\n    \n    part def Image;\n    part def Picture;\n    \n    action def Focus {\n        in scene;\n        out image : Image;\n    }\n    \n    action def Capture {\n        in image : Image;\n        out picture : Picture;\n    }\n    \n    action def Display {\n        in picture : Picture;\n        in displayPort;\n    }\n    \n    action def CameraWorkflow {\n        in scene;\n        out displayPort;\n        \n        action focus : Focus {\n            in scene = CameraWorkflow::scene;\n        }\n        \n        action capture : Capture {\n            in image = focus.image;\n        }\n        \n        action display : Display {\n            in picture = capture.picture;\n            in displayPort = CameraWorkflow::displayPort;\n        }\n        \n        flow focus.image to capture.image;\n        flow capture.picture to display.picture;\n    }\n}",
    "package SensorManagementSystem {\n    \n    part def Sensor {\n        attribute id : String;\n        attribute status : SensorStatus;\n        attribute lastUpdateTime : String;\n    }\n    \n    enum def SensorStatus {\n        enum ready;\n        enum busy;\n        enum offline;\n        enum updating;\n    }\n    \n    part def SensorManager {\n        part sensors : Sensor[0..*];\n        \n        action def monitorSensors {\n            in sensorList : Sensor[0..*];\n            out readySensors : Sensor[0..*];\n        }\n        \n        action def updateSensor {\n            in sensor : Sensor;\n            out updatedSensor : Sensor;\n        }\n        \n        action def traverseSensors {\n            in allSensors : Sensor[0..*];\n            out processedSensors : Sensor[0..*];\n        }\n    }\n    \n    part sensorManagementSystem : SensorManager {\n        \n        action performMonitoring : monitorSensors {\n            in sensorList = sensors;\n        }\n        \n        action performUpdate : updateSensor;\n        \n        action performTraversal : traverseSensors {\n            in allSensors = sensors;\n        }\n        \n        state sensorStates {\n            entry state idle;\n            state monitoring;\n            state updating;\n            \n            transition idle_to_monitoring\n                first idle\n                then monitoring;\n                \n            transition monitoring_to_updating\n                first monitoring\n                then updating\n                when sensors->exists(s | s.status == SensorStatus::ready);\n                \n            transition updating_to_monitoring\n                first updating\n                then monitoring;\n        }\n    }\n}",
    "package VehicleStartupShutdownSystem {\n    \n    part def Vehicle {\n        port startSignalPort : ~SignalPort;\n        port powerOnSignalPort : ~SignalPort;\n        port shutdownSignalPort : ~SignalPort;\n        \n        state vehicleStates {\n            entry state off;\n            state starting;\n            state on;\n            \n            transition off_to_starting\n                first off\n                then starting\n                accept startSignalPort;\n            \n            transition starting_to_on\n                first starting\n                then on\n                accept powerOnSignalPort;\n            \n            transition on_to_off\n                first on\n                then off\n                accept shutdownSignalPort;\n            \n            transition starting_to_off\n                first starting\n                then off\n                accept shutdownSignalPort;\n        }\n    }\n    \n    port def SignalPort;\n    \n    part vehicleSystem : Vehicle;\n}",
    "package VehicleOperationalSystem {\n    \n    part def Vehicle {\n        exhibit state vehicleStates {\n            entry state off;\n            state starting;\n            state on;\n            \n            transition off_to_starting\n                first off\n                accept VehicleStartSignal\n                then starting;\n                \n            transition starting_to_on\n                first starting\n                accept VehicleOnSignal\n                then on;\n                \n            transition on_to_off\n                first on\n                accept VehicleOffSignal\n                then off;\n        }\n    }\n    \n    part def VehicleStartSignal;\n    part def VehicleOnSignal;\n    part def VehicleOffSignal;\n    \n    part vehicleSystem : Vehicle;\n}",
    "package VehiclePowerManagementSystem {\n    \n    part def VehiclePowerController {\n        port userCommandPort;\n        port vehicleStatusPort;\n        port powerSupplyPort;\n        port safetySystemPort;\n    }\n    \n    part def UserInterface {\n        port commandPort;\n    }\n    \n    part def VehicleSubsystems {\n        port powerPort;\n        port statusPort;\n    }\n    \n    part def SafetySystem {\n        port controlPort;\n    }\n    \n    part def PowerSupply {\n        port outputPort;\n    }\n    \n    part vehiclePowerSystem {\n        part controller : VehiclePowerController;\n        part userInterface : UserInterface;\n        part vehicleSubsystems : VehicleSubsystems;\n        part safetySystem : SafetySystem;\n        part powerSupply : PowerSupply;\n        \n        interface userCommandInterface connect userInterface.commandPort to controller.userCommandPort;\n        interface vehicleStatusInterface connect vehicleSubsystems.statusPort to controller.vehicleStatusPort;\n        interface powerInterface connect controller.powerSupplyPort to powerSupply.outputPort;\n        interface safetyInterface connect controller.safetySystemPort to safetySystem.controlPort;\n        interface powerDistribution connect powerSupply.outputPort to vehicleSubsystems.powerPort;\n        \n        state vehicleOff;\n        state vehicleStarting;\n        state vehiclePoweredOn {\n            entry action performSelfDiagnosis;\n            do action supplyPowerContinuously;\n        }\n        \n        transition startCommandReceived\n            first vehicleOff\n            accept startCommand via controller.userCommandPort\n            then vehicleStarting;\n            \n        transition vehicleStarted\n            first vehicleStarting\n            accept vehicleStartedSignal via controller.vehicleStatusPort\n            then vehiclePoweredOn;\n            \n        transition shutdownCommandReceived\n            first vehiclePoweredOn\n            accept shutdownCommand via controller.userCommandPort\n            do send engageParkingBrake to controller.safetySystemPort;\n            do send cutPowerSupply to controller.powerSupplyPort;\n            then vehicleOff;\n    }\n}",
    "package VehicleControlSystem {\n    \n    part def Vehicle {\n        attribute vehicleStatus : String;\n        \n        state def VehicleStates {\n            entry state shutdown;\n            state startup;\n            state running;\n            \n            transition shutdown_to_startup\n                first shutdown\n                then startup\n                accept vehicleStartSignal;\n            \n            transition startup_to_running\n                first startup\n                then running\n                accept vehicleStartedSignal;\n            \n            transition running_to_shutdown\n                first running\n                then shutdown\n                accept vehicleShutdownSignal;\n        }\n        \n        exhibit state vehicleStateMachine : VehicleStates;\n    }\n    \n    part def User {\n        event occurrence vehicleStartSignal;\n        event occurrence vehicleStartedSignal;\n        event occurrence vehicleShutdownSignal;\n    }\n    \n    part vehicleSystem : Vehicle {\n        part user : User;\n    }\n}",
    "package VehiclePowerManagementSystem {\n    \n    part def Vehicle {\n        part powerController : PowerController;\n        \n        attribute operatingState : OperatingStateType;\n    }\n    \n    part def PowerController {\n        port userCommands : UserCommandPort;\n        \n        state powerStates {\n            entry state off;\n            state start;\n            state on;\n            \n            transition off_to_start : off --> start {\n                trigger userCommands.startSignal;\n            }\n            \n            transition start_to_on : start --> on {\n                trigger userCommands.onSignal;\n            }\n            \n            transition on_to_off : on --> off {\n                trigger userCommands.offSignal;\n            }\n        }\n    }\n    \n    port def UserCommandPort {\n        in startSignal : StartSignal;\n        in onSignal : OnSignal;\n        in offSignal : OffSignal;\n    }\n    \n    enum def OperatingStateType {\n        Off;\n        Start;\n        On;\n    }\n    \n    item def StartSignal;\n    item def OnSignal;\n    item def OffSignal;\n    \n    part def HealthStateManager {\n        // Reserved for future health monitoring capabilities\n    }\n    \n    part vehicleSystem : Vehicle {\n        part healthManager : HealthStateManager;\n    }\n}",
    "package VehicleHealthMonitoringSystem {\n    \n    part def VehicleHealthMonitor {\n        attribute currentTemperature : Real;\n        attribute maxAllowableTemperature : Real;\n        attribute maintenanceInterval : Real;\n        attribute lastMaintenanceTime : Real;\n        attribute nextMaintenanceTime : Real;\n        \n        port temperatureSensorPort : ~TemperatureSensorInterface;\n        port controllerPort : ~VehicleControllerInterface;\n    }\n    \n    part def TemperatureSensor {\n        attribute temperature : Real;\n        port sensorOutput : TemperatureSensorInterface;\n    }\n    \n    part def VehicleController {\n        attribute warningReceived : Boolean;\n        port controllerInput : VehicleControllerInterface;\n    }\n    \n    interface def TemperatureSensorInterface {\n        end supplierPort;\n        end consumerPort;\n    }\n    \n    interface def VehicleControllerInterface {\n        end supplierPort;\n        end consumerPort;\n    }\n    \n    state def VehicleHealthStates {\n        entry state;\n        state normal;\n        state degraded;\n        state maintenance;\n        \n        transition initialToNormal\n            first entry\n            then normal;\n            \n        transition normalToDegraded\n            first normal\n            accept overTemperatureEvent\n            then degraded;\n            \n        transition degradedToNormal\n            first degraded\n            accept temperatureNormalEvent\n            then normal;\n            \n        transition normalToMaintenance\n            first normal\n            accept maintenanceTimeReachedEvent\n            then maintenance;\n            \n        transition maintenanceToNormal\n            first maintenance\n            accept maintenanceCompleteEvent\n            then normal;\n    }\n    \n    event overTemperatureEvent;\n    event temperatureNormalEvent;\n    event maintenanceTimeReachedEvent;\n    event maintenanceCompleteEvent;\n    \n    action def monitorTemperature {\n        in currentTemp : Real;\n        in maxTemp : Real;\n        out isOverTemp : Boolean;\n        \n        action compareTemperature {\n            isOverTemp := currentTemp > maxTemp;\n        }\n    }\n    \n    action def sendOverTemperatureWarning {\n        out warning : Boolean;\n        warning := true;\n    }\n    \n    action def checkMaintenanceSchedule {\n        in currentTime : Real;\n        in nextMaintTime : Real;\n        out maintenanceNeeded : Boolean;\n        \n        maintenanceNeeded := currentTime >= nextMaintTime;\n    }\n    \n    action def updateMaintenanceSchedule {\n        in maintInterval : Real;\n        in currentTime : Real;\n        out nextMaintTime : Real;\n        \n        nextMaintTime := currentTime + maintInterval;\n    }\n    \n    constraint maintenanceDuration {\n        doc /* Maintenance status lasts for 48 hours */\n    }\n    \n    part vehicleHealthSystem : VehicleHealthMonitor {\n        exhibit state vehicleStates : VehicleHealthStates;\n        \n        part tempSensor : TemperatureSensor;\n        part controller : VehicleController;\n        \n        interface : TemperatureSensorInterface connect \n            tempSensor.sensorOutput to vehicleHealthSystem.temperatureSensorPort;\n            \n        interface : VehicleControllerInterface connect\n            vehicleHealthSystem.controllerPort to controller.controllerInput;\n    }\n}",
    "package ServerSystem {\n    import ScalarValues::*;\n    import ISQ::*;\n    import Time::*;\n    \n    part def Server {\n        attribute localClock : Time;\n        port requestPort;\n        \n        exhibit state serverBehavior {\n            entry; then off;\n            \n            state off {\n                transition startTransition\n                    first off\n                    accept start via requestPort\n                    then waiting;\n            }\n            \n            state waiting {\n                transition requestTransition\n                    first waiting\n                    accept request via requestPort\n                    then response;\n                    \n                transition dailyResetTransition\n                    first waiting\n                    when localClock == Time(11, 59, 0)\n                    then off;\n            }\n            \n            state response {\n                transition timeoutTransition\n                    first response\n                    after 5 [min]\n                    then waiting;\n                    \n                transition dailyResetFromResponse\n                    first response\n                    when localClock == Time(11, 59, 0)\n                    then off;\n            }\n        }\n    }\n    \n    part serverInstance : Server;\n}",
    "package VehicleStartStopSystem {\n    \n    part def Vehicle {\n        attribute isOff : Boolean = true;\n        attribute isStarting : Boolean = false;\n        attribute isOperating : Boolean = false;\n        attribute brakePedalDepressed : Boolean = false;\n        attribute parkingBrakeApplied : Boolean = true;\n    }\n    \n    part def Controller {\n        attribute startSignalReceived : Boolean = false;\n    }\n    \n    part def StartStopControlSystem {\n        part vehicle : Vehicle;\n        part controller : Controller;\n        \n        action def detectBrakePedal {\n            in brakePedalStatus : Boolean;\n            out brakePedalDepressed : Boolean;\n        }\n        \n        action def sendStartSignalToController {\n            out startSignal : Boolean;\n        }\n        \n        action def performSelfCheck {\n            out checkResult : Boolean;\n        }\n        \n        action def supplyPower {\n            out powerSupplied : Boolean;\n        }\n        \n        action def applyParkingBrake {\n            out parkingBrakeApplied : Boolean;\n        }\n        \n        state def VehicleStates {\n            entry state off;\n            state starting;\n            state operating;\n            \n            transition off_to_starting {\n                source off;\n                target starting;\n                guard startSignalReceived;\n            }\n            \n            transition starting_to_operating {\n                source starting;\n                target operating;\n                guard brakePedalDepressed and powerOnSignalReceived;\n                effect sendStartSignalToController;\n            }\n            \n            transition operating_to_off {\n                source operating;\n                target off;\n                guard stopSignalReceived;\n                effect applyParkingBrake;\n            }\n        }\n        \n        action controlVehicleStartStop {\n            in startSignal : Boolean;\n            in powerOnSignal : Boolean;\n            in stopSignal : Boolean;\n            \n            bind detectBrakePedal.brakePedalStatus = vehicle.brakePedalDepressed;\n            bind sendStartSignalToController.startSignal = controller.startSignalReceived;\n            \n            first start;\n            then merge continueOperation;\n            \n            action start {\n                vehicle.isOff := true;\n                vehicle.parkingBrakeApplied := true;\n            }\n            \n            action processStartSignal {\n                in startSignal : Boolean;\n                if (startSignal and vehicle.isOff) {\n                    vehicle.isOff := false;\n                    vehicle.isStarting := true;\n                }\n            }\n            \n            action processStartup {\n                in powerOnSignal : Boolean;\n                perform detectBrakePedal;\n                if (vehicle.isStarting and vehicle.brakePedalDepressed and powerOnSignal) {\n                    perform sendStartSignalToController;\n                    vehicle.isStarting := false;\n                    vehicle.isOperating := true;\n                    vehicle.parkingBrakeApplied := false;\n                }\n            }\n            \n            action operatingMode {\n                if (vehicle.isOperating) {\n                    perform performSelfCheck;\n                    perform supplyPower;\n                }\n            }\n            \n            action processStopSignal {\n                in stopSignal : Boolean;\n                if (stopSignal and vehicle.isOperating) {\n                    perform applyParkingBrake;\n                    vehicle.isOperating := false;\n                    vehicle.isOff := true;\n                }\n            }\n            \n            flow {\n                first processStartSignal;\n                then processStartup;\n                then operatingMode;\n                then processStopSignal;\n                then continueOperation;\n            }\n        }\n    }\n}",
    "package VehicleStartStopSystem {\n    \n    part def VehicleController;\n    part def BrakePedal;\n    part def ParkingBrake;\n    \n    part def VehicleStartStopControlSystem {\n        port startSignalPort;\n        port vehicleOnSignalPort;\n        port shutdownSignalPort;\n        port brakeStatusPort;\n        port startControlPort;\n        port parkingBrakeControlPort;\n        port powerSupplyPort;\n        \n        attribute vehicleState : String;\n        attribute isBrakeDepressed : Boolean;\n        attribute isSelfCheckComplete : Boolean;\n    }\n    \n    part vehicleStartStopSystem : VehicleStartStopControlSystem {\n        part vehicleController : VehicleController;\n        part brakePedal : BrakePedal;\n        part parkingBrake : ParkingBrake;\n        \n        state off {\n            entry action {\n                vehicleState := \"off\";\n            }\n            \n            transition startupTransition\n                first off\n                accept startSignalPort\n                then startup;\n        }\n        \n        state startup {\n            entry action {\n                vehicleState := \"startup\";\n            }\n            \n            transition toStarted\n                first startup\n                if isBrakeDepressed and vehicleOnSignalPort\n                do send startControlPort\n                then started;\n        }\n        \n        state started {\n            entry action {\n                vehicleState := \"started\";\n                send powerSupplyPort;\n            }\n            \n            do action selfCheck {\n                isSelfCheckComplete := true;\n            }\n            \n            transition toOff\n                first started\n                accept shutdownSignalPort\n                then shuttingDown;\n        }\n        \n        state shuttingDown {\n            entry action {\n                send parkingBrakeControlPort;\n                vehicleState := \"shuttingDown\";\n            }\n            \n            transition finalShutdown\n                first shuttingDown\n                then off;\n        }\n    }\n}",
    "package CruiseControlSystem {\n    part def Driver {\n        port driverCommands : DriverCommandPort;\n    }\n    \n    part def CruiseController {\n        port commandInput : DriverCommandPort;\n        port speedInput : SpeedDataPort;\n        port fuelCommand : FuelControlPort;\n    }\n    \n    part def Speedometer {\n        port speedOutput : SpeedDataPort;\n    }\n    \n    part def Engine {\n        port fuelControl : FuelControlPort;\n    }\n    \n    part def Vehicle {\n        part cruiseController : CruiseController;\n        part speedometer : Speedometer;\n        part engine : Engine;\n    }\n    \n    port def DriverCommandPort;\n    port def SpeedDataPort;\n    port def FuelControlPort;\n    \n    part cruiseControlSystem {\n        part driver : Driver;\n        part vehicle : Vehicle;\n        \n        connection : Connect(\n            driver.driverCommands,\n            vehicle.cruiseController.commandInput\n        );\n        \n        connection : Connect(\n            vehicle.speedometer.speedOutput,\n            vehicle.cruiseController.speedInput\n        );\n        \n        connection : Connect(\n            vehicle.cruiseController.fuelCommand,\n            vehicle.engine.fuelControl\n        );\n    }\n}",
    "package CruiseControlSystem {\n    \n    part def Driver {\n        attribute setSpeed : Real;\n        \n        port driverCommandPort : ~DriverCommandInterface;\n    }\n    \n    part def CruiseController {\n        attribute targetSpeed : Real;\n        attribute currentSpeed : Real;\n        attribute throttleCommand : Real;\n        \n        port commandInputPort : DriverCommandInterface;\n        port speedInputPort : SpeedInterface;\n        port throttleOutputPort : ~ThrottleInterface;\n    }\n    \n    part def Speedometer {\n        attribute vehicleSpeed : Real;\n        \n        port speedOutputPort : ~SpeedInterface;\n    }\n    \n    part def EngineSystem {\n        attribute throttlePosition : Real;\n        \n        port throttleInputPort : ThrottleInterface;\n    }\n    \n    interface def DriverCommandInterface {\n        flow setSpeedCommand : Real;\n    }\n    \n    interface def SpeedInterface {\n        flow speedData : Real;\n    }\n    \n    interface def ThrottleInterface {\n        flow throttleControlCommand : Real;\n    }\n    \n    part cruiseControlSystem : CruiseControlSystem {\n        part driver : Driver;\n        part cruiseController : CruiseController;\n        part speedometer : Speedometer;\n        part engineSystem : EngineSystem;\n        \n        interface driverToCruise : DriverCommandInterface connect \n            driver.driverCommandPort to cruiseController.commandInputPort;\n            \n        interface speedometerToCruise : SpeedInterface connect \n            speedometer.speedOutputPort to cruiseController.speedInputPort;\n            \n        interface cruiseToEngine : ThrottleInterface connect \n            cruiseController.throttleOutputPort to engineSystem.throttleInputPort;\n    }\n}",
    "package CruiseControlSystem {\n    \n    part def Driver {\n        port driverInterface : DriverInterface;\n    }\n    \n    part def CruiseController {\n        port controlInterface : ControlInterface;\n        port speedInput : SpeedInput;\n        port throttleOutput : ThrottleOutput;\n        \n        attribute setSpeed : Real;\n        attribute currentSpeed : Real;\n        attribute speedDifference : Real;\n        attribute throttleCommand : Real;\n    }\n    \n    part def SpeedSensor {\n        port speedOutput : SpeedOutput;\n        attribute vehicleSpeed : Real;\n    }\n    \n    part def Engine {\n        port throttleInput : ThrottleInput;\n        attribute engineOutput : Real;\n    }\n    \n    interface def DriverInterface {\n        end driverEnd;\n        end controllerEnd;\n    }\n    \n    interface def ControlInterface {\n        end driverEnd;\n        end controllerEnd;\n    }\n    \n    interface def SpeedInput {\n        end controllerEnd;\n        end sensorEnd;\n    }\n    \n    interface def SpeedOutput {\n        end sensorEnd;\n        end controllerEnd;\n    }\n    \n    interface def ThrottleOutput {\n        end controllerEnd;\n        end engineEnd;\n    }\n    \n    interface def ThrottleInput {\n        end engineEnd;\n        end controllerEnd;\n    }\n    \n    part cruiseControlSystem : CruiseControlSystem {\n        part driver : Driver;\n        part cruiseController : CruiseController;\n        part speedSensor : SpeedSensor;\n        part engine : Engine;\n        \n        interface driverToController : DriverInterface connect \n            driver.driverInterface.driverEnd to cruiseController.controlInterface.controllerEnd;\n            \n        interface sensorToController : SpeedInput connect\n            speedSensor.speedOutput.sensorEnd to cruiseController.speedInput.controllerEnd;\n            \n        interface controllerToEngine : ThrottleOutput connect\n            cruiseController.throttleOutput.controllerEnd to engine.throttleInput.engineEnd;\n    }\n}",
    "package CruiseControlSystem {\n    \n    part def Driver {\n        attribute desiredSpeed : Real;\n        port driverCommand : ~DriverCommandPort;\n    }\n    \n    part def CruiseController {\n        attribute targetSpeed : Real;\n        attribute currentSpeed : Real;\n        attribute throttleCommand : Real;\n        \n        port commandInput : DriverCommandPort;\n        port speedInput : SpeedDataPort;\n        port throttleOutput : ~ThrottleControlPort;\n    }\n    \n    part def Speedometer {\n        attribute measuredSpeed : Real;\n        port speedOutput : ~SpeedDataPort;\n    }\n    \n    part def Engine {\n        attribute throttlePosition : Real;\n        port throttleInput : ThrottleControlPort;\n    }\n    \n    port def DriverCommandPort {\n        attribute commandedSpeed : Real;\n    }\n    \n    port def SpeedDataPort {\n        attribute vehicleSpeed : Real;\n    }\n    \n    port def ThrottleControlPort {\n        attribute throttleValue : Real;\n    }\n    \n    part def Vehicle {\n        part driver : Driver;\n        part controller : CruiseController;\n        part speedometer : Speedometer;\n        part engine : Engine;\n        \n        interface driverToController connect \n            driver.driverCommand to controller.commandInput;\n            \n        interface speedometerToController connect\n            speedometer.speedOutput to controller.speedInput;\n            \n        interface controllerToEngine connect\n            controller.throttleOutput to engine.throttleInput;\n    }\n}",
    "package CruiseControlSystem {\n    \n    part def CruiseControlInterface {\n        attribute targetSpeed : Real;\n        port setSpeedOutput : DataPort;\n    }\n    \n    part def SpeedSensor {\n        attribute detectedSpeed : Real;\n        port speedOutput : DataPort;\n    }\n    \n    part def CruiseController {\n        attribute setSpeed : Real;\n        attribute actualSpeed : Real;\n        attribute fuelCommand : Real;\n        port setSpeedInput : DataPort;\n        port actualSpeedInput : DataPort;\n        port fuelCommandOutput : DataPort;\n    }\n    \n    part def Engine {\n        attribute fuelControl : Real;\n        port fuelControlInput : DataPort;\n    }\n    \n    part def Vehicle {\n        attribute currentSpeed : Real;\n        part cruiseInterface : CruiseControlInterface;\n        part sensor : SpeedSensor;\n        part controller : CruiseController;\n        part engine : Engine;\n        \n        interface setSpeedConnection connect \n            cruiseInterface.setSpeedOutput to controller.setSpeedInput;\n            \n        interface speedSensingConnection connect \n            sensor.speedOutput to controller.actualSpeedInput;\n            \n        interface fuelControlConnection connect \n            controller.fuelCommandOutput to engine.fuelControlInput;\n    }\n    \n    port def DataPort {\n        attribute data : Real;\n    }\n}",
    "package CruiseControlSystem {\n    \n    part def Driver {\n        port setSpeedCommand : SetSpeedCommandPort;\n    }\n    \n    part def CruiseController {\n        port receiveSetSpeed : SetSpeedCommandPort;\n        port readSpeed : SpeedDataPort;\n        port sendFuelCommand : FuelCommandPort;\n    }\n    \n    part def SpeedSensor {\n        port provideSpeed : SpeedDataPort;\n    }\n    \n    part def EngineController {\n        port receiveFuelCommand : FuelCommandPort;\n        port forwardFuelCommand : FuelCommandPort;\n    }\n    \n    part def Engine {\n        port receiveFuelControl : FuelCommandPort;\n    }\n    \n    port def SetSpeedCommandPort;\n    port def SpeedDataPort;\n    port def FuelCommandPort;\n    \n    part cruiseControlSystem : CruiseControlSystem {\n        part driver : Driver;\n        part cruiseController : CruiseController;\n        part speedSensor : SpeedSensor;\n        part engineController : EngineController;\n        part engine : Engine;\n        \n        interface setSpeedInterface connect driver.setSpeedCommand to cruiseController.receiveSetSpeed;\n        interface speedDataInterface connect speedSensor.provideSpeed to cruiseController.readSpeed;\n        interface fuelCommandInterface connect cruiseController.sendFuelCommand to engineController.receiveFuelCommand;\n        interface engineControlInterface connect engineController.forwardFuelCommand to engine.receiveFuelControl;\n    }\n}",
    "package VehicleLifecycleManagement {\n    \n    part def Vehicle {\n        attribute vin : String;\n        attribute model : String;\n        attribute manufacturer : String;\n        attribute assemblyDate : String;\n        attribute deliveryDate : String;\n        attribute scrapDate : String[0..1];\n        attribute status : VehicleStatus;\n    }\n    \n    enum def VehicleStatus {\n        enum assembled;\n        enum delivered;\n        enum inUse;\n        enum scrapped;\n    }\n    \n    part def Owner {\n        attribute ownerId : String;\n        attribute name : String;\n        attribute contactInfo : String;\n    }\n    \n    part def Driver {\n        attribute driverId : String;\n        attribute name : String;\n        attribute licenseNumber : String;\n    }\n    \n    part def OwnershipRecord {\n        attribute startDate : String;\n        attribute endDate : String[0..1];\n        ref owner : Owner;\n        ref vehicle : Vehicle;\n    }\n    \n    part def DrivingRecord {\n        attribute drivingDate : String;\n        attribute startTime : String;\n        attribute endTime : String;\n        ref driver : Driver;\n        ref vehicle : Vehicle;\n        ref ownership : OwnershipRecord;\n    }\n    \n    part def VehicleLifecycleSystem {\n        part vehicles : Vehicle[*];\n        part owners : Owner[*];\n        part drivers : Driver[*];\n        part ownershipRecords : OwnershipRecord[*];\n        part drivingRecords : DrivingRecord[*];\n        \n        action assembleVehicle {\n            in vehicle : Vehicle;\n            out assembledVehicle : Vehicle;\n        }\n        \n        action deliverVehicle {\n            in vehicle : Vehicle;\n            in deliveryDate : String;\n            out deliveredVehicle : Vehicle;\n        }\n        \n        action transferOwnership {\n            in vehicle : Vehicle;\n            in newOwner : Owner;\n            in transferDate : String;\n            out ownershipRecord : OwnershipRecord;\n        }\n        \n        action recordDriving {\n            in vehicle : Vehicle;\n            in driver : Driver;\n            in ownership : OwnershipRecord;\n            in drivingInfo : DrivingRecord;\n            out drivingRecord : DrivingRecord;\n        }\n        \n        action scrapVehicle {\n            in vehicle : Vehicle;\n            in scrapDate : String;\n            out scrappedVehicle : Vehicle;\n        }\n        \n        action queryVehicleHistory {\n            in vehicleId : String;\n            out vehicleInfo : Vehicle;\n            out ownershipHistory : OwnershipRecord[*];\n            out drivingHistory : DrivingRecord[*];\n        }\n    }\n}",
    "package VehicleModel {\n    \n    attribute def Mass;\n    attribute def GearSetting;\n    attribute def AcceleratorPosition;\n    \n    part def Vehicle {\n        attribute mass : Mass;\n        attribute gearSetting : GearSetting;\n        attribute acceleratorPosition : AcceleratorPosition;\n        \n        part engine : Engine;\n        ref part driver : Driver;\n        part wheels : Wheel[*];\n        part leftFrontWheel : Wheel;\n        part rightFrontWheel : Wheel;\n    }\n    \n    part def Engine {\n    }\n    \n    part def Driver {\n    }\n    \n    part def Wheel {\n    }\n    \n    part vehicle_1 : Vehicle {\n        snapshot leftFrontWheel_t1 : Wheel = leftFrontWheel;\n        snapshot leftFrontWheel_t2 : Wheel = leftFrontWheel;\n        snapshot rightFrontWheel_t1 : Wheel = rightFrontWheel;\n        snapshot rightFrontWheel_t2 : Wheel = rightFrontWheel;\n    }\n}",
    "package VehicleSystem {\n    \n    part def Vehicle {\n        attribute mass : Real;\n        attribute vehicleState : VehicleState;\n    }\n    \n    part def VehicleState {\n        attribute gearSetting : Integer;\n        attribute acceleratorPosition : Real;\n    }\n    \n    part def Engine {\n    }\n    \n    part def Driver {\n    }\n    \n    part def CompositeSystem {\n        part vehicles : Vehicle[*];\n        part engines : Engine[*];\n        part drivers : Driver[*];\n    }\n    \n    part Vehicle_1 : Vehicle {\n        attribute redefines mass = 2000.0;\n        attribute redefines vehicleState : VehicleState {\n            attribute redefines gearSetting = 0;\n            attribute redefines acceleratorPosition = 0.0;\n        }\n    }\n    \n    part Vehicle_1_NextMoment : Vehicle {\n        attribute redefines mass = 1500.0;\n        attribute redefines vehicleState : VehicleState {\n            attribute redefines gearSetting = 2;\n            attribute redefines acceleratorPosition = 0.5;\n        }\n    }\n}",
    "package VehicleSystem {\n    import ScalarValues::*;\n    \n    part def Vehicle {\n        attribute mass : Real;\n        attribute currentState {\n            attribute gearPosition : String;\n            attribute throttlePedalPosition : Real;\n        }\n        part engine : Engine;\n        ref driver : Driver;\n    }\n    \n    part def Engine {\n    }\n    \n    part def Driver {\n        attribute name : String;\n    }\n    \n    part alice : Driver {\n        attribute redefines name = \"Alice\";\n    }\n    \n    part bob : Driver {\n        attribute redefines name = \"Bob\";\n    }\n    \n    part vehicle : Vehicle {\n        timeslice initialState {\n            attribute redefines mass = 2000.0;\n            attribute redefines currentState {\n                attribute redefines gearPosition = \"neutral\";\n                attribute redefines throttlePedalPosition = 0.0;\n            }\n            ref redefines driver : Driver = alice;\n        }\n        \n        then timeslice secondState {\n            attribute redefines mass = 1500.0;\n            attribute redefines currentState {\n                attribute redefines gearPosition = \"second\";\n                attribute redefines throttlePedalPosition = 0.5;\n            }\n            ref redefines driver : Driver = bob;\n        }\n    }\n}",
    "package VehicleMassModel {\n    import ScalarValues::*;\n    import Quantities::*;\n    import MeasurementReferences::*;\n    import SI::*;\n    \n    attribute def MassValue :> ScalarQuantityValue {\n        attribute quantityDimension :>> num = 1;\n        attribute measurementReference :>> mRef = kg;\n    }\n    \n    abstract part def Component {\n        attribute id : String;\n        attribute mass : MassValue;\n    }\n    \n    abstract part def CompositeComponent :> Component {\n        part subComponents : Component[0..*];\n        \n        attribute totalMass : MassValue = mass + sum(subComponents.totalMass);\n    }\n    \n    part def SimpleComponent :> Component {\n        attribute totalMass : MassValue = mass;\n    }\n    \n    part def Engine :> SimpleComponent {\n        attribute engineType : String;\n    }\n    \n    part def Transmission :> SimpleComponent {\n        attribute transmissionType : String;\n    }\n    \n    part def Body :> SimpleComponent {\n        attribute bodyType : String;\n    }\n    \n    part def Vehicle :> CompositeComponent {\n        attribute vehicleModel : String;\n        \n        part engine : Engine;\n        part transmission : Transmission;\n        part body : Body;\n        \n        bind subComponents = (engine, transmission, body);\n    }\n}",
    "package VehicleMassManagementSystem {\n    \n    attribute def MassValue :> ISQ::mass;\n    attribute def SerialNumber :> String;\n    attribute def VIN :> String;\n    \n    part def Component {\n        attribute serialNumber : SerialNumber;\n        attribute mass : MassValue;\n        part subComponents : Component[0..*];\n        \n        attribute totalMass : MassValue = mass + subComponents.totalMass->sum();\n        \n        attribute def filterByMass(threshold : MassValue) : Component[0..*] = \n            subComponents->select(c | c.totalMass >= threshold);\n    }\n    \n    part def Engine :> Component {\n        attribute engineType : String;\n    }\n    \n    part def Transmission :> Component {\n        attribute transmissionType : String;\n    }\n    \n    part def Vehicle :> Component {\n        attribute vin : VIN redefines serialNumber;\n        \n        part engine : Engine[1];\n        part transmission : Transmission[1];\n        part otherComponents : Component[0..*];\n        \n        attribute redefines totalMass : MassValue = \n            mass + engine.totalMass + transmission.totalMass + otherComponents.totalMass->sum();\n    }\n    \n    part vehicleMassManagementSystem {\n        part vehicles : Vehicle[0..*];\n        \n        attribute calculateTotalMass(v : Vehicle) : MassValue = v.totalMass;\n        \n        attribute filterComponentsByMass(v : Vehicle, threshold : MassValue) : Component[0..*] =\n            v.filterByMass(threshold);\n    }\n}",
    "package MassAggregationSystem {\n    \n    part def MassedObject {\n        attribute simpleMass : Real;\n        attribute totalMass : Real;\n    }\n    \n    part def SimpleThing :> MassedObject {\n        attribute redefines totalMass = simpleMass;\n    }\n    \n    part def CompositeThing :> MassedObject {\n        part subcomponents : MassedObject[0..*];\n        attribute redefines totalMass = simpleMass + sum(subcomponents.totalMass);\n    }\n    \n}",
    "package MassManagementSystem {\n    \n    attribute def MassValue :> ISQ::mass;\n    \n    attribute def MinimumMassThreshold :> ISQ::mass;\n    \n    part def MassObject {\n        attribute basicMass : MassValue;\n        part subcomponents : MassObject[0..*];\n        \n        attribute totalMass : MassValue;\n        \n        calc def calculateTotalMass {\n            in object : MassObject;\n            return : MassValue;\n        }\n        \n        calc totalMassCalculation : calculateTotalMass {\n            in object = MassObject::self;\n            return = object.basicMass + sum(object.subcomponents.totalMass);\n        }\n        \n        bind totalMass = totalMassCalculation.return;\n    }\n    \n    part def FilteredMassObject :> MassObject {\n        attribute massThreshold : MinimumMassThreshold;\n        \n        calc def calculateFilteredTotalMass {\n            in object : FilteredMassObject;\n            in threshold : MinimumMassThreshold;\n            return : MassValue;\n        }\n        \n        calc filteredTotalMassCalculation : calculateFilteredTotalMass {\n            in object = FilteredMassObject::self;\n            in threshold = massThreshold;\n            return = object.basicMass + sum(\n                object.subcomponents\n                    .select(sc : MassObject | sc.totalMass >= threshold)\n                    .totalMass\n            );\n        }\n        \n        attribute filteredTotalMass : MassValue;\n        bind filteredTotalMass = filteredTotalMassCalculation.return;\n    }\n    \n    part def MassManagementSystem {\n        part managedObjects : MassObject[0..*];\n        part filteredObjects : FilteredMassObject[0..*];\n        \n        action aggregateMass {\n            in objects : MassObject[0..*];\n            out totalSystemMass : MassValue;\n            \n            bind totalSystemMass = sum(objects.totalMass);\n        }\n        \n        action filterAndAggregateMass {\n            in objects : FilteredMassObject[0..*];\n            in threshold : MinimumMassThreshold;\n            out filteredSystemMass : MassValue;\n            \n            bind filteredSystemMass = sum(objects.filteredTotalMass);\n        }\n    }\n}",
    "package VehicleDynamicsSystem {\n    import ScalarValues::*;\n    \n    part def VehicleDynamicsCalculator {\n        attribute wheelPower : Real;\n        attribute aerodynamicDragCoefficient : Real;\n        attribute frictionCoefficient : Real;\n        attribute vehicleMass : Real;\n        attribute currentSpeed : Real;\n        attribute initialSpeed : Real;\n        attribute time : Real;\n        \n        attribute actualAvailablePower : Real;\n        attribute acceleration : Real;\n        attribute speed : Real;\n        attribute position : Real;\n        \n        calc actualAvailablePower : Real = wheelPower - (aerodynamicDragCoefficient * currentSpeed * currentSpeed * currentSpeed) - (frictionCoefficient * vehicleMass * 9.81 * currentSpeed);\n        \n        calc acceleration : Real = actualAvailablePower / (vehicleMass * currentSpeed);\n        \n        calc speed : Real = initialSpeed + (acceleration * time);\n        \n        calc position : Real = initialSpeed * time + (0.5 * acceleration * time * time);\n    }\n    \n    part vehicleDynamicsSystem : VehicleDynamicsCalculator;\n}",
    "package VehicleDynamicsSimulation {\n    import ScalarValues::*;\n    \n    part def Vehicle {\n        attribute mass : Real;\n        attribute dragCoefficient : Real;\n        attribute rollingResistanceCoefficient : Real;\n        attribute frontalArea : Real;\n        attribute wheelRadius : Real;\n    }\n    \n    part def DrivingConditions {\n        attribute initialSpeed : Real;\n        attribute initialPosition : Real;\n        attribute timeStep : Real;\n        attribute wheelEndPower : Real;\n        attribute airDensity : Real;\n        attribute gravitationalAcceleration : Real;\n    }\n    \n    part def DynamicState {\n        attribute currentSpeed : Real;\n        attribute currentPosition : Real;\n        attribute currentAcceleration : Real;\n        attribute aerodynamicDrag : Real;\n        attribute rollingResistance : Real;\n        attribute availableDrivingForce : Real;\n    }\n    \n    part def VehicleDynamicsSystem {\n        part vehicle : Vehicle;\n        part conditions : DrivingConditions;\n        part state : DynamicState;\n        \n        action computeAerodynamicDrag {\n            in vehicleData : Vehicle;\n            in currentSpeed : Real;\n            in airDensity : Real;\n            out dragForce : Real;\n        }\n        \n        action computeRollingResistance {\n            in vehicleData : Vehicle;\n            in gravitationalAcceleration : Real;\n            out resistanceForce : Real;\n        }\n        \n        action computeAvailableDrivingForce {\n            in wheelEndPower : Real;\n            in currentSpeed : Real;\n            out drivingForce : Real;\n        }\n        \n        action computeAcceleration {\n            in availableForce : Real;\n            in dragForce : Real;\n            in resistanceForce : Real;\n            in mass : Real;\n            out acceleration : Real;\n        }\n        \n        action updateSpeed {\n            in currentSpeed : Real;\n            in acceleration : Real;\n            in timeStep : Real;\n            out newSpeed : Real;\n        }\n        \n        action updatePosition {\n            in currentPosition : Real;\n            in currentSpeed : Real;\n            in acceleration : Real;\n            in timeStep : Real;\n            out newPosition : Real;\n        }\n        \n        action simulateTimeStep {\n            in vehicle : Vehicle;\n            in conditions : DrivingConditions;\n            inout state : DynamicState;\n            \n            perform computeAerodynamicDrag {\n                in vehicleData = vehicle;\n                in currentSpeed = state.currentSpeed;\n                in airDensity = conditions.airDensity;\n                out dragForce = state.aerodynamicDrag;\n            }\n            \n            perform computeRollingResistance {\n                in vehicleData = vehicle;\n                in gravitationalAcceleration = conditions.gravitationalAcceleration;\n                out resistanceForce = state.rollingResistance;\n            }\n            \n            perform computeAvailableDrivingForce {\n                in wheelEndPower = conditions.wheelEndPower;\n                in currentSpeed = state.currentSpeed;\n                out drivingForce = state.availableDrivingForce;\n            }\n            \n            perform computeAcceleration {\n                in availableForce = state.availableDrivingForce;\n                in dragForce = state.aerodynamicDrag;\n                in resistanceForce = state.rollingResistance;\n                in mass = vehicle.mass;\n                out acceleration = state.currentAcceleration;\n            }\n            \n            perform updateSpeed {\n                in currentSpeed = state.currentSpeed;\n                in acceleration = state.currentAcceleration;\n                in timeStep = conditions.timeStep;\n                out newSpeed = state.currentSpeed;\n            }\n            \n            perform updatePosition {\n                in currentPosition = state.currentPosition;\n                in currentSpeed = state.currentSpeed;\n                in acceleration = state.currentAcceleration;\n                in timeStep = conditions.timeStep;\n                out newPosition = state.currentPosition;\n            }\n        }\n    }\n}",
    "package VehicleDynamicsSystem {\n    import SI::*;\n    import ScalarValues::*;\n    \n    part def Vehicle {\n        attribute mass : Real;\n        attribute wheelPower : Real;\n        attribute dragCoefficient : Real;\n        attribute rollingResistanceCoefficient : Real;\n        attribute frontalArea : Real;\n        attribute currentSpeed : Real;\n        attribute currentPosition : Real;\n        attribute currentAcceleration : Real;\n        attribute timeStep : Real;\n    }\n    \n    part def DynamicsCalculator {\n        in vehicleData : Vehicle;\n        out updatedVehicle : Vehicle;\n        \n        private attribute airDensity : Real = 1.225;\n        private attribute gravity : Real = 9.81;\n        \n        action calculateForces {\n            in vehicle : Vehicle;\n            out drivingForce : Real;\n            out dragForce : Real;\n            out rollingResistance : Real;\n            out netForce : Real;\n            \n            drivingForce := vehicle.wheelPower / vehicle.currentSpeed;\n            dragForce := 0.5 * airDensity * vehicle.dragCoefficient * vehicle.frontalArea * vehicle.currentSpeed * vehicle.currentSpeed;\n            rollingResistance := vehicle.rollingResistanceCoefficient * vehicle.mass * gravity;\n            netForce := drivingForce - dragForce - rollingResistance;\n        }\n        \n        action updateDynamics {\n            in vehicle : Vehicle;\n            in netForce : Real;\n            out newAcceleration : Real;\n            out newSpeed : Real;\n            out newPosition : Real;\n            \n            newAcceleration := netForce / vehicle.mass;\n            newSpeed := vehicle.currentSpeed + newAcceleration * vehicle.timeStep;\n            newPosition := vehicle.currentPosition + vehicle.currentSpeed * vehicle.timeStep + 0.5 * newAcceleration * vehicle.timeStep * vehicle.timeStep;\n        }\n    }\n    \n    part def SimulationController {\n        attribute simulationTime : Real;\n        attribute maxSimulationTime : Real;\n        \n        part vehicle : Vehicle;\n        part calculator : DynamicsCalculator;\n        \n        action runSimulation {\n            loop while (simulationTime < maxSimulationTime) {\n                perform calculator.calculateForces {\n                    in vehicle := self.vehicle;\n                    out drivingForce;\n                    out dragForce;\n                    out rollingResistance;\n                    out netForce;\n                }\n                \n                perform calculator.updateDynamics {\n                    in vehicle := self.vehicle;\n                    in netForce := netForce;\n                    out newAcceleration;\n                    out newSpeed;\n                    out newPosition;\n                }\n                \n                self.vehicle.currentAcceleration := newAcceleration;\n                self.vehicle.currentSpeed := newSpeed;\n                self.vehicle.currentPosition := newPosition;\n                self.simulationTime := self.simulationTime + self.vehicle.timeStep;\n            }\n        }\n    }\n    \n    part vehicleDynamicsSystem : SimulationController {\n        doc /* This system models and computes vehicle driving dynamics based on user input parameters */\n    }\n}",
    "package VehicleLongitudinalDynamics {\n    import ScalarValues::*;\n    \n    part def Vehicle {\n        attribute mass : Real;\n        attribute dragCoefficient : Real;\n        attribute frictionCoefficient : Real;\n        attribute frontalArea : Real;\n        attribute airDensity : Real;\n    }\n    \n    part def DynamicState {\n        attribute position : Real;\n        attribute velocity : Real;\n        attribute acceleration : Real;\n        attribute time : Real;\n    }\n    \n    part def DrivingConditions {\n        attribute wheelPower : Real;\n        attribute timeInterval : Real;\n    }\n    \n    part def LongitudinalDynamicsSystem {\n        part vehicle : Vehicle;\n        part initialState : DynamicState;\n        part finalState : DynamicState;\n        part conditions : DrivingConditions;\n        \n        attribute dragForce : Real = 0.5 * vehicle.airDensity * vehicle.dragCoefficient * vehicle.frontalArea * initialState.velocity ** 2;\n        attribute frictionForce : Real = vehicle.frictionCoefficient * vehicle.mass * 9.81;\n        attribute tractionForce : Real = conditions.wheelPower / initialState.velocity;\n        attribute netForce : Real = tractionForce - dragForce - frictionForce;\n        \n        constraint accelerationCalculation {\n            finalState.acceleration == netForce / vehicle.mass\n        }\n        \n        constraint velocityUpdate {\n            finalState.velocity == initialState.velocity + finalState.acceleration * conditions.timeInterval\n        }\n        \n        constraint positionUpdate {\n            finalState.position == initialState.position + initialState.velocity * conditions.timeInterval + 0.5 * finalState.acceleration * conditions.timeInterval ** 2\n        }\n        \n        constraint timeUpdate {\n            finalState.time == initialState.time + conditions.timeInterval\n        }\n    }\n}",
    "package VehicleMassManagementSystem {\n    \n    import ScalarValues::*;\n    \n    part def Vehicle {\n        attribute totalMass : Real;\n        attribute maxPermittedMass : Real = 2500.0;\n        \n        part chassis : Chassis;\n        part engine : Engine;\n        part gearbox : Gearbox;\n        \n        constraint totalMassCalculation {\n            totalMass == chassis.mass + engine.mass + gearbox.mass\n        }\n        \n        requirement massLimit {\n            doc /* The total mass shall not exceed 2500 kilograms */\n            require constraint {\n                totalMass <= maxPermittedMass\n            }\n        }\n        \n        attribute isOverweight : Boolean = totalMass > maxPermittedMass;\n    }\n    \n    part def Chassis {\n        attribute mass : Real;\n    }\n    \n    part def Engine {\n        attribute mass : Real;\n    }\n    \n    part def Gearbox {\n        attribute mass : Real;\n    }\n}",
    "package VehicleMassManagement {\n    import ScalarValues::*;\n    import Quantities::*;\n    import MeasurementReferences::*;\n    import SI::*;\n    \n    attribute def MassValue :> ScalarQuantityValue {\n        attribute quantityDimension :>> num = 1;\n        attribute measurementReference :>> mRef = kg;\n    }\n    \n    part def Vehicle {\n        attribute totalMassLimit : MassValue = 2500.0;\n        attribute actualTotalMass : MassValue;\n        \n        part chassis : Chassis;\n        part engine : Engine;\n        part transmission : Transmission;\n        \n        constraint massCalculation {\n            actualTotalMass == chassis.mass + engine.mass + transmission.mass\n        }\n        \n        constraint massLimit {\n            actualTotalMass <= totalMassLimit\n        }\n    }\n    \n    part def Chassis {\n        attribute mass : MassValue;\n    }\n    \n    part def Engine {\n        attribute mass : MassValue;\n    }\n    \n    part def Transmission {\n        attribute mass : MassValue;\n    }\n}",
    "package VehicleMassManagementSystem {\n    \n    part def Chassis {\n        attribute mass : Real;\n    }\n    \n    part def Engine {\n        attribute mass : Real;\n    }\n    \n    part def Transmission {\n        attribute mass : Real;\n    }\n    \n    part def Vehicle {\n        part chassis : Chassis;\n        part engine : Engine;\n        part transmission : Transmission;\n        \n        attribute totalMass : Real = chassis.mass + engine.mass + transmission.mass;\n        attribute massLimit : Real = 2500.0;\n        attribute isCompliant : Boolean = totalMass <= massLimit;\n    }\n    \n    part def VehicleMassManagementSystem {\n        part vehicle : Vehicle;\n        \n        attribute receivedChassisMass : Real;\n        attribute receivedEngineMass : Real;\n        attribute receivedTransmissionMass : Real;\n        \n        action verifyMassCompliance {\n            in chassisMass : Real;\n            in engineMass : Real;\n            in transmissionMass : Real;\n            out complianceStatus : Boolean;\n            \n            bind vehicle.chassis.mass = chassisMass;\n            bind vehicle.engine.mass = engineMass;\n            bind vehicle.transmission.mass = transmissionMass;\n            bind complianceStatus = vehicle.isCompliant;\n        }\n    }\n}",
    "package VehicleWeightManagementSystem {\n    \n    part def WeightData {\n        attribute weight : Real;\n    }\n    \n    part def VehicleComponent {\n        attribute componentWeight : Real;\n    }\n    \n    part def Chassis :> VehicleComponent;\n    part def Engine :> VehicleComponent;\n    part def Transmission :> VehicleComponent;\n    \n    part def WeightManagementSystem {\n        part chassis : Chassis;\n        part engine : Engine;\n        part transmission : Transmission;\n        \n        attribute totalWeight : Real;\n        attribute weightLimit : Real = 2500.0;\n        attribute warningActive : Boolean = false;\n        \n        calc def calculateTotalWeight {\n            in chassisWeight : Real;\n            in engineWeight : Real;\n            in transmissionWeight : Real;\n            return : Real = chassisWeight + engineWeight + transmissionWeight;\n        }\n        \n        constraint weightCompliance {\n            totalWeight <= weightLimit\n        }\n        \n        action def checkWeightLimit {\n            in currentTotalWeight : Real;\n            in limit : Real;\n            out warning : Boolean;\n            \n            action setWarning {\n                warning := currentTotalWeight > limit;\n            }\n        }\n        \n        action manageWeight {\n            action recordWeights {\n                chassis.componentWeight := chassis.componentWeight;\n                engine.componentWeight := engine.componentWeight;\n                transmission.componentWeight := transmission.componentWeight;\n            }\n            \n            action calculateTotal {\n                totalWeight := calculateTotalWeight(\n                    chassis.componentWeight,\n                    engine.componentWeight,\n                    transmission.componentWeight\n                );\n            }\n            \n            action checkCompliance {\n                checkWeightLimit(totalWeight, weightLimit, warningActive);\n            }\n        }\n    }\n}",
    "package VehicleSystem {\n    import ScalarValues::*;\n    \n    part def Vehicle {\n        attribute totalMass : Real;\n        \n        part chassis : Chassis;\n        part engine : Engine;\n        part transmission : Transmission;\n        \n        constraint massComposition {\n            totalMass == chassis.mass + engine.mass + transmission.mass\n        }\n        \n        constraint massLimit {\n            totalMass <= 2500.0\n        }\n    }\n    \n    part def Chassis {\n        attribute mass : Real;\n    }\n    \n    part def Engine {\n        attribute mass : Real;\n    }\n    \n    part def Transmission {\n        attribute mass : Real;\n    }\n    \n    part def VehicleDynamics {\n        attribute initialVelocity : Real;\n        attribute finalVelocity : Real;\n        attribute mass : Real;\n        attribute appliedForce : Real;\n        attribute timePeriod : Real;\n        \n        constraint massPositive {\n            mass > 0.0\n        }\n        \n        constraint dynamicRelationship {\n            appliedForce * timePeriod == mass * (finalVelocity - initialVelocity)\n        }\n    }\n}",
    "package VehicleMaintenanceSystem {\n    \n    part def Vehicle {\n        attribute nextMaintenanceTime : Real;\n        attribute maintenanceInterval : Real;\n        attribute maxAllowedTemperature : Real;\n        attribute actualMaintenanceStartTime : Real;\n        attribute healthStatus : String;\n        attribute vehicleStatus : String;\n        \n        constraint maintenanceStartConstraint {\n            actualMaintenanceStartTime > nextMaintenanceTime\n        }\n        \n        constraint maintenanceInitiationConstraint {\n            actualMaintenanceStartTime <= previousHealthyStateEndTime + 2\n        }\n        \n        constraint maintenanceDurationConstraint {\n            maintenanceDuration <= 48\n        }\n    }\n    \n    part def MaintenanceScheduler {\n        attribute currentTime : Real;\n        \n        action determineMaintenanceRequired {\n            in vehicle : Vehicle;\n            out maintenanceRequired : Boolean;\n            \n            maintenanceRequired = (currentTime >= vehicle.nextMaintenanceTime)\n        }\n        \n        action switchToMaintenance {\n            inout vehicle : Vehicle;\n            \n            vehicle.vehicleStatus := \"under maintenance\"\n        }\n        \n        action completeMaintenanceAction {\n            inout vehicle : Vehicle;\n            \n            vehicle.nextMaintenanceTime := vehicle.nextMaintenanceTime + vehicle.maintenanceInterval;\n            vehicle.healthStatus := \"normal\"\n        }\n    }\n    \n    part maintenanceSystem : MaintenanceScheduler {\n        part managedVehicle : Vehicle;\n    }\n}",
    "package VehicleSystem {\n    \n    part def Vehicle {\n        attribute curbWeight : Real;\n        attribute fuelMass : Real;\n        attribute totalMass : Real;\n        attribute maxMassLimit : Real;\n        \n        part engine : Engine;\n        part transmission : Transmission;\n        part clutch : Clutch;\n        \n        constraint totalMassCalculation {\n            totalMass == curbWeight + fuelMass\n        }\n        \n        constraint massLimit {\n            totalMass <= maxMassLimit\n        }\n        \n        constraint fuelMassPositive {\n            fuelMass > 0\n        }\n        \n        interface clutchInterface connect engine.torqueOutput to clutch.torqueInput;\n        interface transmissionInterface connect clutch.torqueOutput to transmission.torqueInput;\n    }\n    \n    part def Engine {\n        attribute speed : Real;\n        attribute torque : Real;\n        port torqueOutput : TorquePort;\n        \n        action generateTorque {\n            in engineSpeed : Real;\n            out engineTorque : Real;\n        }\n    }\n    \n    part def Clutch {\n        port torqueInput : TorquePort;\n        port torqueOutput : TorquePort;\n        \n        action transmitTorque {\n            in inputTorque : Real;\n            out outputTorque : Real;\n        }\n    }\n    \n    part def Transmission {\n        port torqueInput : TorquePort;\n        \n        action receiveTorque {\n            in torque : Real;\n        }\n    }\n    \n    port def TorquePort {\n        attribute torqueValue : Real;\n    }\n}",
    "package VehicleSystem {\n    \n    part def Vehicle {\n        attribute dryMass : Real;\n        attribute fuelMass : Real;\n        attribute totalMass : Real;\n        \n        part engine : Engine;\n        part transmission : Transmission;\n        part clutch : Clutch;\n        part fuelTank : FuelTank;\n    }\n    \n    part def Engine {\n        attribute generatedTorque : Real;\n        attribute speed : Real;\n    }\n    \n    part def Transmission {\n        attribute inputTorque : Real;\n    }\n    \n    part def Clutch {\n        attribute transmittedTorque : Real;\n    }\n    \n    part def FuelTank {\n        attribute capacity : Real;\n        attribute currentFuelMass : Real;\n    }\n    \n    interface def TorqueTransmissionInterface {\n        attribute torque : Real;\n    }\n    \n    connection def TorqueConnection {\n        end enginePort : TorqueTransmissionInterface;\n        end transmissionPort : TorqueTransmissionInterface;\n    }\n    \n    requirement def MassRequirements {\n        doc /* The vehicle mass must not exceed specified limits */\n        \n        requirement fullTankMassLimit {\n            doc /* With full fuel tank, total mass must not exceed 2000 kg */\n            require constraint { totalMass <= 2000 }\n        }\n        \n        requirement emptyTankMassLimit {\n            doc /* With empty fuel tank, total mass must not exceed 1500 kg */\n            require constraint { totalMass <= 1500 }\n        }\n    }\n    \n    requirement def TorqueTransmissionRequirement {\n        doc /* Engine must transmit torque to transmission via clutch */\n        subject engine : Engine;\n        subject transmission : Transmission;\n        subject clutch : Clutch;\n        \n        require constraint { engine.generatedTorque == clutch.transmittedTorque }\n        require constraint { clutch.transmittedTorque == transmission.inputTorque }\n    }\n    \n    requirement def EnginePerformanceRequirement {\n        doc /* Engine must deliver torque according to speed-torque curve */\n        subject engine : Engine;\n    }\n    \n    constraint def VehicleMassConstraint {\n        totalMass == dryMass + fuelMass\n    }\n}",
    "package VehicleSystemModel {\n    \n    requirement def VehicleMassRequirement {\n        doc /* The vehicle's total mass must not exceed 2000 kilograms when fully fueled, \n               and should not be higher than 1500 kilograms when empty. */\n        \n        attribute emptyMass : Real;\n        attribute fullyFueledMass : Real;\n        \n        require constraint { emptyMass <= 1500.0 }\n        require constraint { fullyFueledMass <= 2000.0 }\n    }\n    \n    requirement def EngineTorqueTransmissionRequirement {\n        doc /* The engine must be capable of effectively transmitting its generated torque \n               to the transmission system through a clutch interface. */\n    }\n    \n    requirement def EngineTorquePerformanceRequirement {\n        doc /* The torque generated by the engine should vary with speed, \n               conforming to the relevant performance table specifications. */\n    }\n    \n    part def Vehicle {\n        attribute emptyMass : Real;\n        attribute fullyFueledMass : Real;\n        \n        part engine : Engine;\n        \n        satisfy vehicleMassReq : VehicleMassRequirement {\n            :>> emptyMass = Vehicle::emptyMass;\n            :>> fullyFueledMass = Vehicle::fullyFueledMass;\n        }\n    }\n    \n    part def Engine {\n        port clutchInterface : ClutchPort;\n        \n        satisfy torqueTransmissionReq : EngineTorqueTransmissionRequirement;\n        satisfy torquePerformanceReq : EngineTorquePerformanceRequirement;\n    }\n    \n    port def ClutchPort {\n        attribute torque : Real;\n    }\n    \n    part def TransmissionSystem {\n        port clutchInterface : ClutchPort;\n    }\n    \n    connection def TorqueTransmission {\n        end enginePort : ClutchPort;\n        end transmissionPort : ClutchPort;\n    }\n}",
    "package VehicleSystem {\n    \n    part def Vehicle {\n        attribute curbMass : Real;\n        attribute fuelMass : Real;\n        attribute totalMass : Real;\n        \n        part engine : Engine;\n        part gearbox : Gearbox;\n        part clutch : Clutch;\n        \n        interface def PowerTransmission {\n            end engineSide;\n            end gearboxSide;\n        }\n        \n        connection powerLink : PowerTransmission connect engine.output to gearbox.input;\n    }\n    \n    part def Engine {\n        attribute speed : Real;\n        attribute torque : Real;\n        port output : PowerPort;\n    }\n    \n    part def Gearbox {\n        port input : PowerPort;\n    }\n    \n    part def Clutch {\n        port engineInterface : PowerPort;\n        port gearboxInterface : PowerPort;\n    }\n    \n    port def PowerPort {\n        attribute transmittedTorque : Real;\n    }\n    \n    requirement def MassRequirement {\n        doc /* The total vehicle mass must not exceed specified limits */\n        \n        requirement fullTankMassLimit {\n            doc /* When fuel tank is full, total mass must not exceed 2000 kg */\n            assume constraint { totalMass <= 2000 }\n        }\n        \n        requirement emptyTankMassLimit {\n            doc /* When fuel tank is empty, total mass must not exceed 1500 kg */\n            assume constraint { totalMass <= 1500 }\n        }\n        \n        requirement massCalculation {\n            doc /* Total mass is sum of curb mass and fuel mass */\n            assume constraint { totalMass == curbMass + fuelMass }\n        }\n    }\n    \n    requirement def PowerTransmissionRequirement {\n        doc /* Engine must generate and transmit torque to gearbox */\n        \n        requirement torqueGeneration {\n            doc /* Engine must generate specified torque at various speeds */\n        }\n        \n        requirement torqueTransmission {\n            doc /* Torque must be transmitted through clutch to gearbox */\n        }\n    }\n    \n    satisfy vehicleMassCompliance : MassRequirement by Vehicle;\n    satisfy powerDeliveryCompliance : PowerTransmissionRequirement by Vehicle;\n}",
    "package VehicleDynamicPerformanceAnalysis {\n    import ScalarValues::*;\n    \n    part def Vehicle {\n        attribute curbWeight : Real;\n        attribute payload : Real;\n        attribute wheelDiameter : Real;\n        attribute transmissionEfficiency : Real;\n        attribute urbanFuelEconomy : Real;\n        attribute highwayFuelEconomy : Real;\n        \n        attribute totalMass : Real = curbWeight + payload;\n        \n        port powerDemandPort : PowerPort;\n        port accelerationPort : AccelerationPort;\n        port speedPort : SpeedPort;\n        port positionPort : PositionPort;\n    }\n    \n    part def DrivingCycle {\n        attribute timeStamps : Real[*] ordered;\n        attribute positions : Real[*] ordered;\n        attribute speeds : Real[*] ordered;\n    }\n    \n    part def PerformanceAnalyzer {\n        in item vehicleConfig : Vehicle;\n        in item driveCycle : DrivingCycle;\n        \n        out attribute enginePower : Real[*] ordered;\n        out attribute acceleration : Real[*] ordered;\n        out attribute fuelConsumption : Real;\n        out attribute fuelEconomy : Real;\n        \n        action calculateDynamics {\n            in vehicle : Vehicle;\n            in cycle : DrivingCycle;\n            out power : Real[*] ordered;\n            out accel : Real[*] ordered;\n        }\n        \n        action calculateFuelEconomy {\n            in vehicle : Vehicle;\n            in cycle : DrivingCycle;\n            in power : Real[*] ordered;\n            out consumption : Real;\n            out economy : Real;\n        }\n    }\n    \n    part def ComplianceVerifier {\n        in item targetFuelEconomy : Real;\n        in item actualFuelEconomy : Real;\n        out attribute isCompliant : Boolean;\n        \n        action verifyCompliance {\n            isCompliant := actualFuelEconomy >= targetFuelEconomy;\n        }\n    }\n    \n    port def PowerPort {\n        attribute power : Real;\n    }\n    \n    port def AccelerationPort {\n        attribute acceleration : Real;\n    }\n    \n    port def SpeedPort {\n        attribute speed : Real;\n    }\n    \n    port def PositionPort {\n        attribute position : Real;\n    }\n    \n    part vehicleDynamicSystem : VehicleDynamicSystem {\n        part vehicle : Vehicle;\n        part drivingCycle : DrivingCycle;\n        part analyzer : PerformanceAnalyzer;\n        part verifier : ComplianceVerifier;\n        \n        attribute targetEconomyMPG : Real = 30.0;\n        \n        connection : Connect {\n            from vehicle to analyzer.vehicleConfig;\n        }\n        \n        connection : Connect {\n            from drivingCycle to analyzer.driveCycle;\n        }\n        \n        connection : Connect {\n            from analyzer.fuelEconomy to verifier.actualFuelEconomy;\n        }\n        \n        connection : Connect {\n            from targetEconomyMPG to verifier.targetFuelEconomy;\n        }\n    }\n    \n    part def VehicleDynamicSystem {\n        part vehicle : Vehicle;\n        part drivingCycle : DrivingCycle;\n        part analyzer : PerformanceAnalyzer;\n        part verifier : ComplianceVerifier;\n    }\n}",
    "package VehicleFuelEconomyAnalysis {\n    import ScalarValues::*;\n    \n    part def Vehicle {\n        attribute curbWeight : Real;\n        attribute load : Real;\n        attribute wheelDiameter : Real;\n        attribute transmissionEfficiency : Real;\n        attribute totalMass : Real = curbWeight + load;\n    }\n    \n    part def DrivingScenario {\n        attribute scenarioType : String;\n        attribute trajectory : Real[*];\n        attribute speedProfile : Real[*];\n    }\n    \n    part def SimulationAnalysis {\n        attribute requiredWheelPower : Real;\n        attribute acceleration : Real;\n        attribute energyConsumption : Real;\n        attribute enginePowerDemand : Real;\n        attribute fuelConsumption : Real;\n        attribute fuelEconomyL100km : Real;\n        attribute fuelEconomyMPG : Real;\n    }\n    \n    part def FuelEconomySystem {\n        part vehicle : Vehicle;\n        part urbanScenario : DrivingScenario {\n            attribute :>> scenarioType = \"Urban\";\n        }\n        part highwayScenario : DrivingScenario {\n            attribute :>> scenarioType = \"Highway\";\n        }\n        part urbanAnalysis : SimulationAnalysis;\n        part highwayAnalysis : SimulationAnalysis;\n        \n        attribute targetFuelEconomyMPG : Real = 30.0;\n        attribute meetsRequirement : Boolean;\n        \n        action calculateWheelPower {\n            in scenario : DrivingScenario;\n            in vehicleData : Vehicle;\n            out power : Real;\n        }\n        \n        action applyVehicleDynamics {\n            in wheelPower : Real;\n            in vehicleData : Vehicle;\n            out acceleration : Real;\n            out energyConsumption : Real;\n        }\n        \n        action calculateEnginePower {\n            in wheelPower : Real;\n            in efficiency : Real;\n            out enginePower : Real;\n        }\n        \n        action estimateFuelConsumption {\n            in enginePower : Real;\n            in drivingTime : Real;\n            out fuelConsumption : Real;\n            out fuelEconomyL100km : Real;\n            out fuelEconomyMPG : Real;\n        }\n        \n        action performSimulation {\n            in scenario : DrivingScenario;\n            in vehicleData : Vehicle;\n            out analysis : SimulationAnalysis;\n            \n            bind wheelPowerCalc = calculateWheelPower {\n                in scenario = scenario;\n                in vehicleData = vehicleData;\n                out power = analysis.requiredWheelPower;\n            }\n            \n            bind dynamicsCalc = applyVehicleDynamics {\n                in wheelPower = analysis.requiredWheelPower;\n                in vehicleData = vehicleData;\n                out acceleration = analysis.acceleration;\n                out energyConsumption = analysis.energyConsumption;\n            }\n            \n            bind engineCalc = calculateEnginePower {\n                in wheelPower = analysis.requiredWheelPower;\n                in efficiency = vehicleData.transmissionEfficiency;\n                out enginePower = analysis.enginePowerDemand;\n            }\n            \n            bind fuelCalc = estimateFuelConsumption {\n                in enginePower = analysis.enginePowerDemand;\n                in drivingTime = 1.0;\n                out fuelConsumption = analysis.fuelConsumption;\n                out fuelEconomyL100km = analysis.fuelEconomyL100km;\n                out fuelEconomyMPG = analysis.fuelEconomyMPG;\n            }\n        }\n        \n        action analyzeCompliance {\n            bind urbanSim = performSimulation {\n                in scenario = urbanScenario;\n                in vehicleData = vehicle;\n                out analysis = urbanAnalysis;\n            }\n            \n            bind highwaySim = performSimulation {\n                in scenario = highwayScenario;\n                in vehicleData = vehicle;\n                out analysis = highwayAnalysis;\n            }\n            \n            then meetsRequirement = (urbanAnalysis.fuelEconomyMPG > targetFuelEconomyMPG) and \n                                   (highwayAnalysis.fuelEconomyMPG > targetFuelEconomyMPG);\n        }\n    }\n}",
    "package EngineSelectionSystem {\n    \n    part def Engine {\n        attribute power : Real;\n        attribute mass : Real;\n        attribute efficiency : Real;\n        attribute cost : Real;\n    }\n    \n    part def FourCylinderEngine :> Engine;\n    \n    part def SixCylinderEngine :> Engine;\n    \n    part def EngineSelectionAnalysis {\n        part engines : Engine[*];\n        part fourCylinderEngines : FourCylinderEngine[*] :> engines;\n        part sixCylinderEngines : SixCylinderEngine[*] :> engines;\n        \n        attribute evaluationScores : Real[*];\n        attribute optimalEngine : Engine;\n        \n        action calculatePerformanceIndicators {\n            in engine : Engine;\n            out powerIndicator : Real;\n            out massIndicator : Real;\n            out efficiencyIndicator : Real;\n            out costIndicator : Real;\n        }\n        \n        action evaluateEngine {\n            in engine : Engine;\n            out score : Real;\n        }\n        \n        action selectOptimalEngine {\n            in engines : Engine[*];\n            in scores : Real[*];\n            out optimal : Engine;\n        }\n        \n        action performAnalysis {\n            first calculatePerformanceIndicators;\n            then evaluateEngine;\n            then selectOptimalEngine;\n        }\n    }\n}",
    "package VehicleQualitySystem {\n    \n    part def Vehicle {\n        attribute curbWeight : Real;\n    }\n    \n    part def QualityCheckSystem {\n        in item vehicle : Vehicle;\n        out item evaluationResult : EvaluationResult;\n        \n        attribute maxAllowedWeight : Real = 2500.0;\n        \n        action collectWeightData {\n            in item v : Vehicle;\n            out item actualWeight : Real;\n        }\n        \n        action processWeightData {\n            in item rawWeight : Real;\n            out item processedWeight : Real;\n        }\n        \n        action evaluateWeight {\n            in item weight : Real;\n            in item threshold : Real;\n            out item result : EvaluationResult;\n        }\n        \n        action performQualityCheck : ActionUsage {\n            in item inputVehicle : Vehicle = vehicle;\n            out item result : EvaluationResult;\n            \n            bind collectWeightData.v = inputVehicle;\n            bind processWeightData.rawWeight = collectWeightData.actualWeight;\n            bind evaluateWeight.weight = processWeightData.processedWeight;\n            bind evaluateWeight.threshold = maxAllowedWeight;\n            bind result = evaluateWeight.result;\n            \n            first collectWeightData\n            then processWeightData\n            then evaluateWeight;\n        }\n    }\n    \n    enum def EvaluationResult {\n        enum qualified;\n        enum unqualified;\n    }\n    \n    constraint def WeightRequirement {\n        in v : Vehicle;\n        v.curbWeight <= 2500.0;\n    }\n}",
    "package VehicleMassVerificationSystem {\n    \n    part def Vehicle {\n        attribute actualMass : Real;\n    }\n    \n    part def WeighingEquipment {\n        attribute measuredMass : Real;\n    }\n    \n    part def MassVerificationUnit {\n        attribute massLimit : Real = 2500.0;\n        attribute verificationResult : Boolean;\n    }\n    \n    part def VehicleMassVerificationSystem {\n        part vehicle : Vehicle;\n        part weighingEquipment : WeighingEquipment;\n        part massVerificationUnit : MassVerificationUnit;\n        \n        connection : Connect connect vehicle to weighingEquipment;\n        connection : Connect connect weighingEquipment to massVerificationUnit;\n    }\n    \n    action def MeasureVehicleMass {\n        in vehicle : Vehicle;\n        out measuredMass : Real;\n        \n        action measureMass {\n            assign measuredMass = vehicle.actualMass;\n        }\n    }\n    \n    action def VerifyMass {\n        in measuredMass : Real;\n        in massLimit : Real;\n        out isQualified : Boolean;\n        \n        action checkCompliance {\n            assign isQualified = (measuredMass <= massLimit);\n        }\n    }\n    \n    action def VehicleMassInspectionProcess {\n        in vehicle : Vehicle;\n        out verificationResult : Boolean;\n        \n        action measure : MeasureVehicleMass {\n            in vehicle = vehicle;\n        }\n        \n        action verify : VerifyMass {\n            in measuredMass = measure.measuredMass;\n            in massLimit = 2500.0;\n        }\n        \n        flow from measure.measuredMass to verify.measuredMass;\n        \n        assign verificationResult = verify.isQualified;\n    }\n}",
    "package VehicleTransportationSystem {\n    \n    part def Vehicle {\n        attribute capacity : Integer = 5;\n        attribute occupantCount : Integer;\n        \n        part driver : Person[0..1];\n        part passengers : Person[0..4];\n        \n        port entryExitPort : EntryExitInterface;\n        port fuelPort : FuelInterface;\n        \n        action transport {\n            in startLocation : Location;\n            in destination : Location;\n            out journeyCompleted : Boolean;\n        }\n        \n        action enterVehicle {\n            in person : Person;\n            out success : Boolean;\n        }\n        \n        action exitVehicle {\n            in person : Person;\n            out success : Boolean;\n        }\n    }\n    \n    part def Person {\n        attribute role : String;\n        attribute isDriver : Boolean;\n    }\n    \n    part def Location {\n        attribute name : String;\n        attribute coordinates : String;\n    }\n    \n    part def Environment {\n        attribute weatherConditions : String;\n        attribute trafficConditions : String;\n        attribute roadConditions : String;\n    }\n    \n    part def Infrastructure {\n        part gasStations : GasStation[*];\n    }\n    \n    part def GasStation {\n        attribute location : Location;\n        port fuelPort : FuelInterface;\n    }\n    \n    interface def EntryExitInterface {\n        in requestEntry : Boolean;\n        in requestExit : Boolean;\n        out accessGranted : Boolean;\n    }\n    \n    interface def FuelInterface {\n        in fuelRequest : Boolean;\n        out fuelProvided : Boolean;\n    }\n    \n    part transportationSystem : TransportationSystem {\n        part vehicle : Vehicle;\n        part environment : Environment;\n        part infrastructure : Infrastructure;\n        \n        connection : Connect {\n            from vehicle.fuelPort to infrastructure.gasStations.fuelPort;\n        }\n    }\n    \n    part def TransportationSystem {\n        attribute safetyLevel : String;\n        attribute comfortLevel : String;\n        attribute efficiency : String;\n    }\n}",
    "package TransportationSystem {\n    \n    part def Vehicle {\n        attribute capacity : Integer = 5;\n        attribute fuelLevel : Real;\n        attribute location : String;\n        attribute isMoving : Boolean = false;\n        \n        port driverInterface : DriverInterface;\n        port passengerInterface : PassengerInterface[0..4];\n        port fuelPort : FuelInterface;\n    }\n    \n    part def Driver {\n        attribute isInVehicle : Boolean = false;\n        attribute destination : String;\n        \n        port vehicleControl : DriverInterface;\n    }\n    \n    part def Passenger {\n        attribute isInVehicle : Boolean = false;\n        \n        port vehicleAccess : PassengerInterface;\n    }\n    \n    part def Environment {\n        attribute weatherConditions : String;\n        attribute roadConditions : String;\n        \n        port environmentalFactors : EnvironmentInterface;\n    }\n    \n    part def GasStation {\n        attribute fuelAvailable : Real;\n        \n        port fuelDispenser : FuelInterface;\n    }\n    \n    interface def DriverInterface {\n        in item enterCommand;\n        in item operateCommand;\n        in item exitCommand;\n        out item vehicleStatus;\n    }\n    \n    interface def PassengerInterface {\n        in item enterRequest;\n        in item exitRequest;\n        out item accessStatus;\n    }\n    \n    interface def FuelInterface {\n        in item refuelRequest;\n        out item fuelAmount;\n    }\n    \n    interface def EnvironmentInterface {\n        out item conditions;\n    }\n    \n    part transportationSystem : TransportationSystem {\n        part vehicle : Vehicle;\n        part driver : Driver;\n        part passengers : Passenger[0..4];\n        part environment : Environment;\n        part gasStation : GasStation[0..*];\n        \n        connection : Connect connect driver.vehicleControl to vehicle.driverInterface;\n        connection : Connect connect passengers.vehicleAccess to vehicle.passengerInterface;\n        connection : Connect connect gasStation.fuelDispenser to vehicle.fuelPort;\n        \n        action def TransportationProcess {\n            first start;\n            then action enterVehicle : EnterVehicle;\n            then action operateVehicle : OperateVehicle;\n            then action refuelIfNeeded : RefuelVehicle[0..1];\n            then action exitVehicle : ExitVehicle;\n            then done;\n        }\n        \n        action def EnterVehicle {\n            in driver : Driver;\n            in passengers : Passenger[0..4];\n            out vehicle : Vehicle;\n        }\n        \n        action def OperateVehicle {\n            in driver : Driver;\n            in vehicle : Vehicle;\n            in environment : Environment;\n            out vehicle : Vehicle;\n        }\n        \n        action def RefuelVehicle {\n            in vehicle : Vehicle;\n            in gasStation : GasStation;\n            out vehicle : Vehicle;\n        }\n        \n        action def ExitVehicle {\n            in driver : Driver;\n            in passengers : Passenger[0..4];\n            in vehicle : Vehicle;\n        }\n    }\n}",
    "package VehicleConfigurationManagement {\n    \n    part def Vehicle {\n        part engine : Engine[1];\n        part transmission : Transmission[1];\n        \n        constraint {\n            (engine instanceof FourCylinderEngine) implies (transmission instanceof ManualTransmission or transmission instanceof AutomaticTransmission)\n        }\n        \n        constraint {\n            (engine instanceof SixCylinderEngine) implies (transmission instanceof AutomaticTransmission)\n        }\n    }\n    \n    abstract part def Engine;\n    \n    part def FourCylinderEngine :> Engine {\n        part cylinders : Cylinder[4];\n    }\n    \n    part def SixCylinderEngine :> Engine {\n        part cylinders : Cylinder[6];\n    }\n    \n    part def Cylinder {\n        attribute diameter : Real;\n        \n        constraint {\n            diameter == 70.0 or diameter == 100.0\n        }\n    }\n    \n    abstract part def Transmission;\n    \n    part def ManualTransmission :> Transmission;\n    \n    part def AutomaticTransmission :> Transmission;\n}",
    "package EngineSystem {\n    \n    part def Engine {\n        attribute cylinderCount : Integer;\n        part cylinders : Cylinder[1..*];\n        \n        assert constraint {\n            cylinderCount == 4 or cylinderCount == 6\n        }\n        \n        assert constraint {\n            cylinders->size() == cylinderCount\n        }\n    }\n    \n    part def Cylinder {\n        attribute diameter : Real;\n        \n        assert constraint {\n            diameter == 70.0 or diameter == 100.0\n        }\n    }\n    \n    part def FourCylinderEngine :> Engine {\n        attribute redefines cylinderCount = 4;\n        part redefines cylinders : Cylinder[4];\n    }\n    \n    part def SixCylinderEngine :> Engine {\n        attribute redefines cylinderCount = 6;\n        part redefines cylinders : Cylinder[6];\n    }\n    \n    part configurableEngineSystem : Engine[1] {\n        doc /* This system supports configurable engines with either 4 or 6 cylinders,\n             * each cylinder having a diameter of either 70mm or 100mm */\n    }\n}",
    "package VehicleConfigurationSpace {\n    \n    part def Vehicle {\n        part engine : Engine[1];\n        part transmission : Transmission[1];\n    }\n    \n    part def Engine {\n        attribute cylinderCount : Integer;\n    }\n    \n    part def FourCylinderEngine :> Engine {\n        attribute redefines cylinderCount = 4;\n        part cylinders : Cylinder[4];\n    }\n    \n    part def SixCylinderEngine :> Engine {\n        attribute redefines cylinderCount = 6;\n        part cylinders : Cylinder[6];\n    }\n    \n    part def Cylinder {\n        attribute diameter : Real;\n        constraint { diameter == 70.0 or diameter == 100.0 }\n    }\n    \n    part def Transmission;\n    \n    part def ManualTransmission :> Transmission;\n    \n    part def AutomaticTransmission :> Transmission;\n    \n    constraint def EngineTransmissionConstraint {\n        doc /* If 4-cylinder engine, then manual transmission; if 6-cylinder engine, then automatic transmission */\n        \n        in vehicle : Vehicle;\n        \n        constraint {\n            (vehicle.engine istype FourCylinderEngine implies vehicle.transmission istype ManualTransmission) and\n            (vehicle.engine istype SixCylinderEngine implies vehicle.transmission istype AutomaticTransmission)\n        }\n    }\n    \n    part vehicleConfiguration : Vehicle {\n        assert constraint engineTransmissionRule : EngineTransmissionConstraint {\n            in vehicle = vehicleConfiguration;\n        }\n    }\n}",
    "package SystemModel {\n    \n    part def SystemAssembly {\n        part computerSubsystem : ComputerSubsystem;\n        part storageSubsystem : StorageSubsystem;\n        part softwareDesign : SoftwareDesign;\n        \n        connection : computerSubsystem.softwareInterface connect softwareDesign.computerInterface;\n        connection : storageSubsystem.dataInterface connect softwareDesign.storageInterface;\n        connection : computerSubsystem.storageLink connect storageSubsystem.computerLink;\n    }\n    \n    part def ComputerSubsystem {\n        port softwareInterface;\n        port storageLink;\n        \n        attribute utilizesFunctions : Boolean;\n        attribute integratesFunctions : Boolean;\n    }\n    \n    part def StorageSubsystem {\n        port dataInterface;\n        port computerLink;\n        \n        attribute accessesMessageFormat : Boolean;\n        attribute accessesDataFormat : Boolean;\n        attribute compatibleWithFormats : Boolean;\n    }\n    \n    part def SoftwareDesign {\n        port computerInterface;\n        port storageInterface;\n        \n        part messageFormat : MessageFormat;\n        part dataFormat : DataFormat;\n    }\n    \n    part def MessageFormat {\n        attribute formatSpecification : String;\n    }\n    \n    part def DataFormat {\n        attribute structureSpecification : String;\n    }\n    \n    part system : SystemAssembly {\n        attribute efficient : Boolean;\n        attribute reliable : Boolean;\n        attribute compliant : Boolean;\n    }\n}",
    "package PowertrainSystem {\n    \n    // Logical Layer\n    part def LogicalPowertrainSystem {\n        part powerProvider : PowerProvider;\n        part torqueGenerator : TorqueGenerator;\n    }\n    \n    part def PowerProvider {\n        attribute power : Real;\n    }\n    \n    part def TorqueGenerator {\n        attribute inputPower : Real;\n        attribute outputTorque : Real;\n    }\n    \n    // Physical Layer\n    part def PhysicalPowertrainSystem {\n        part powerUnit : PowerUnit;\n    }\n    \n    part def PowerUnit {\n        attribute powerOutput : Real;\n        attribute torqueOutput : Real;\n    }\n    \n    part def Engine :> PowerUnit;\n    \n    // System Integration\n    part def PowertrainSystem {\n        part logical : LogicalPowertrainSystem;\n        part physical : PhysicalPowertrainSystem;\n    }\n    \n    // Allocation relationships\n    allocation def LogicalToPhysicalAllocation {\n        end logical : LogicalPowertrainSystem;\n        end physical : PhysicalPowertrainSystem;\n    }\n    \n    allocation torqueGeneratorToPowerUnit : LogicalToPhysicalAllocation {\n        allocate logical.torqueGenerator to physical.powerUnit;\n    }\n    \n    allocation powerProviderToPowerUnit : LogicalToPhysicalAllocation {\n        allocate logical.powerProvider to physical.powerUnit;\n    }\n}",
    "package PowerTransmissionSystem {\n    \n    part def System {\n        part powerTransmission : PowerTransmissionSystem;\n    }\n    \n    part def PowerTransmissionSystem {\n        attribute providePower : Boolean;\n        attribute generateTorque : Boolean;\n    }\n    \n    part def LogicalModel {\n        part torqueGenerator : TorqueGenerator {\n            perform generatingTorque;\n        }\n    }\n    \n    part def TorqueGenerator {\n        action generatingTorque {\n            doc /* Transfer and convert power */\n        }\n    }\n    \n    part def PhysicalModel {\n        part powertrain : Powertrain {\n            part engine : Engine {\n                perform generateTorque;\n            }\n        }\n    }\n    \n    part def Powertrain {\n        part engine : Engine;\n    }\n    \n    part def Engine {\n        action generateTorque {\n            doc /* Generate torque function */\n        }\n    }\n    \n    allocation def TorqueGeneratorToPowertrain {\n        end source : TorqueGenerator;\n        end target : Powertrain;\n    }\n    \n    allocation def GeneratingTorqueToEngine {\n        end source : TorqueGenerator::generatingTorque;\n        end target : Engine::generateTorque;\n    }\n}",
    "package VehicleFeatureAnnotationSystem {\n    \n    part def Vehicle {\n        part interior : Interior;\n        part bodyAssembly : BodyAssembly;\n    }\n    \n    part def Interior {\n        part seatBelts : SeatBelt[1..*];\n        part frontSeats : FrontSeat[2];\n        part driverAirbag : DriverAirbag;\n        part alarmSystem : AlarmSystem;\n    }\n    \n    part def BodyAssembly {\n        part bodyShell : BodyShell;\n        part bumpers : Bumper[2];\n        part keylessEntryDevice : KeylessEntryDevice;\n    }\n    \n    part def SeatBelt {\n        attribute function : String = \"safety\";\n    }\n    \n    part def FrontSeat {\n        attribute function : String = \"safety\";\n    }\n    \n    part def DriverAirbag {\n        attribute function : String = \"safety\";\n    }\n    \n    part def AlarmSystem {\n        attribute function : String = \"security\";\n    }\n    \n    part def BodyShell {\n        attribute function : String = \"protection\";\n    }\n    \n    part def Bumper {\n        attribute function : String = \"safety\";\n    }\n    \n    part def KeylessEntryDevice {\n        attribute function : String = \"security\";\n    }\n}",
    "package VehicleDynamicsSimulationSystem {\n    \n    part def VehicleDynamicsSystem {\n        attribute initialVelocity : Real;\n        attribute initialPosition : Real;\n        attribute acceleration : Real;\n        attribute timeStep : Real;\n        attribute finalVelocity : Real;\n        attribute finalPosition : Real;\n        \n        port inputPort : DataInputPort;\n        port outputPort : DataOutputPort;\n        port modelCenterInterface : AnalysisToolInterface;\n    }\n    \n    part def DataInputPort {\n        in item initialVelocityData : Real;\n        in item initialPositionData : Real;\n        in item accelerationData : Real;\n        in item timeStepData : Real;\n    }\n    \n    part def DataOutputPort {\n        out item finalVelocityData : Real;\n        out item finalPositionData : Real;\n    }\n    \n    part def AnalysisToolInterface {\n        in item simulationParameters : SimulationData;\n        out item simulationResults : SimulationData;\n    }\n    \n    item def SimulationData {\n        attribute velocity : Real;\n        attribute position : Real;\n        attribute acceleration : Real;\n        attribute time : Real;\n    }\n    \n    part def ModelCenterTool {\n        port toolInterface : AnalysisToolInterface;\n        \n        action calculateDynamics {\n            in inputData : SimulationData;\n            out outputData : SimulationData;\n        }\n    }\n    \n    part vehicleSimulationSystem : VehicleDynamicsSystem {\n        part modelCenter : ModelCenterTool;\n        \n        interface : InterfaceDefinition connect inputPort to modelCenter.toolInterface;\n        interface : InterfaceDefinition connect modelCenter.toolInterface to outputPort;\n        \n        action performSimulation {\n            action receiveInput {\n                in initialVel : Real = initialVelocity;\n                in initialPos : Real = initialPosition;\n                in accel : Real = acceleration;\n                in deltaT : Real = timeStep;\n            }\n            \n            action executeCalculation {\n                in parameters : SimulationData;\n                out results : SimulationData;\n                \n                bind parameters.velocity = initialVelocity;\n                bind parameters.position = initialPosition;\n                bind parameters.acceleration = acceleration;\n                bind parameters.time = timeStep;\n                \n                send parameters to modelCenter.calculateDynamics;\n                results = modelCenter.calculateDynamics.outputData;\n            }\n            \n            action outputResults {\n                out finalVel : Real = finalVelocity;\n                out finalPos : Real = finalPosition;\n                \n                bind finalVel = results.velocity;\n                bind finalPos = results.position;\n            }\n            \n            flow receiveInput then executeCalculation then outputResults;\n        }\n    }\n    \n    requirement vehicleDynamicsSimulationCapability {\n        doc /* The system shall be capable of performing automated simulation \n             and analysis of vehicle dynamic behavior */\n        \n        require constraint {\n            vehicleSimulationSystem.performSimulation != null\n        }\n    }\n    \n    requirement userInputCapability {\n        doc /* Users should be able to input the vehicle's initial velocity, \n             initial position, acceleration at a specific moment, and the time step */\n        \n        require constraint {\n            vehicleSimulationSystem.inputPort != null and\n            vehicleSimulationSystem.initialVelocity != null and\n            vehicleSimulationSystem.initialPosition != null and\n            vehicleSimulationSystem.acceleration != null and\n            vehicleSimulationSystem.timeStep != null\n        }\n    }\n    \n    requirement modelCenterIntegration {\n        doc /* Through integration with the ModelCenter analysis tool, the system \n             shall automatically calculate and output the vehicle's velocity and \n             position after the specified time step */\n        \n        require constraint {\n            vehicleSimulationSystem.modelCenter != null and\n            vehicleSimulationSystem.modelCenterInterface != null\n        }\n    }\n    \n    requirement accurateDataTransfer {\n        doc /* The system must ensure accurate data transfer and reliable output \n             of simulation results */\n        \n        require constraint {\n            vehicleSimulationSystem.outputPort != null and\n            vehicleSimulationSystem.finalVelocity != null and\n            vehicleSimulationSystem.finalPosition != null\n        }\n    }\n}",
    "package 'Car Safety Compliance' {\n    \n    attribute def Safety;\n    attribute def isMandatory : Boolean;\n    \n    part def Car {\n        part interior : Interior;\n        part body : Body;\n        part wheelAssembly : WheelAssembly;\n    }\n    \n    part def Interior {\n        part seatBelt : SeatBelt[2] {\n            @Safety;\n            attribute :>> isMandatory = true;\n        }\n        part driverAirbag : DriverAirbag[0..1] {\n            @Safety;\n            attribute :>> isMandatory = false;\n        }\n    }\n    \n    part def Body {\n        part bumper : Bumper {\n            @Safety;\n            attribute :>> isMandatory = true;\n        }\n        part keylessEntry : KeylessEntry[0..1] {\n            @Safety;\n            attribute :>> isMandatory = false;\n        }\n    }\n    \n    part def WheelAssembly {\n        part wheel : Wheel[2];\n        part abs : ABS[0..1] {\n            @Safety;\n            attribute :>> isMandatory = false;\n        }\n    }\n    \n    part def SeatBelt;\n    part def DriverAirbag;\n    part def Bumper;\n    part def KeylessEntry;\n    part def Wheel;\n    part def ABS;\n    \n    package 'Safety Features' {\n        ref part seatBelt : SeatBelt;\n        ref part driverAirbag : DriverAirbag;\n        ref part bumper : Bumper;\n        ref part keylessEntry : KeylessEntry;\n        ref part abs : ABS;\n    }\n    \n    package 'Mandatory Safety Features' {\n        ref part seatBelt : SeatBelt;\n        ref part bumper : Bumper;\n    }\n}",
    "package VehicleSafetyComplianceSystem {\n    \n    part def SafetyFeature {\n        attribute isMandatory : Boolean;\n    }\n    \n    part def SeatBelt :> SafetyFeature {\n        attribute isMandatory : Boolean = true;\n    }\n    \n    part def DriverAirbag :> SafetyFeature {\n        attribute isMandatory : Boolean = false;\n    }\n    \n    part def Bumper :> SafetyFeature {\n        attribute isMandatory : Boolean = true;\n    }\n    \n    part def KeylessEntrySystem :> SafetyFeature {\n        attribute isMandatory : Boolean = false;\n    }\n    \n    part def Tire {\n        attribute quantity : Integer = 4;\n    }\n    \n    part def ABS :> SafetyFeature {\n        attribute isMandatory : Boolean = false;\n    }\n    \n    part def VehicleInterior {\n        part seatBelt1 : SeatBelt;\n        part seatBelt2 : SeatBelt;\n        part driverAirbag : DriverAirbag[0..1];\n    }\n    \n    part def VehicleBody {\n        part bumper : Bumper;\n        part keylessEntry : KeylessEntrySystem[0..1];\n    }\n    \n    part def Chassis {\n        part tires : Tire[4];\n        part abs : ABS[0..1];\n    }\n    \n    part def Vehicle {\n        part interior : VehicleInterior;\n        part body : VehicleBody;\n        part chassis : Chassis;\n    }\n}",
    "package RiskAndFailureManagementSystem {\n    \n    part def Situation {\n        attribute id : String;\n        attribute description : String;\n    }\n    \n    part def Cause {\n        attribute id : String;\n        attribute description : String;\n        attribute probability : Real;\n    }\n    \n    part def Failure {\n        attribute id : String;\n        attribute description : String;\n        attribute severityLevel : Integer;\n    }\n    \n    part def CausalRelationship {\n        ref source : Situation;\n        ref target : Situation;\n        attribute impactMechanism : String;\n    }\n    \n    part def RiskScenario {\n        attribute id : String;\n        attribute name : String;\n        part situations : Situation[*];\n        part causes : Cause[*];\n        part failures : Failure[*];\n        part relationships : CausalRelationship[*];\n    }\n    \n    part def RiskManagementSystem {\n        part scenarios : RiskScenario[*];\n        \n        action identifySituation {\n            in situationData : String;\n            out situation : Situation;\n        }\n        \n        action identifyCause {\n            in causeData : String;\n            in probability : Real;\n            out cause : Cause;\n        }\n        \n        action identifyFailure {\n            in failureData : String;\n            in severity : Integer;\n            out failure : Failure;\n        }\n        \n        action establishCausalRelationship {\n            in sourceSituation : Situation;\n            in targetSituation : Situation;\n            in mechanism : String;\n            out relationship : CausalRelationship;\n        }\n        \n        action evaluateRisk {\n            in scenario : RiskScenario;\n            out riskAssessment : Real;\n        }\n        \n        action modelRiskScenario {\n            in scenarioName : String;\n            out scenario : RiskScenario;\n        }\n    }\n}",
    "package RiskMetadataSystem {\n    \n    part def Scenario {\n        attribute id : String;\n        attribute name : String;\n        attribute description : String;\n        attribute probability : Real;\n        \n        part causes : Cause[0..*];\n        part failures : Failure[0..*];\n        part relatedScenarios : Scenario[0..*];\n    }\n    \n    part def Cause {\n        attribute id : String;\n        attribute name : String;\n        attribute description : String;\n        attribute probability : Real;\n    }\n    \n    part def Failure {\n        attribute id : String;\n        attribute type : String;\n        attribute description : String;\n        attribute severity : SeverityLevel;\n    }\n    \n    enum def SeverityLevel {\n        enum low;\n        enum medium;\n        enum high;\n        enum critical;\n    }\n    \n    part def CausalRelationship {\n        attribute id : String;\n        attribute description : String;\n        ref sourceScenario : Scenario;\n        ref targetScenario : Scenario;\n    }\n    \n    part def RiskScenario {\n        attribute id : String;\n        attribute name : String;\n        attribute description : String;\n        \n        part scenarios : Scenario[1..*];\n        part causalRelationships : CausalRelationship[0..*];\n    }\n    \n    part def RiskManagementSystem {\n        attribute systemId : String;\n        attribute version : String;\n        \n        part scenarios : Scenario[0..*];\n        part riskScenarios : RiskScenario[0..*];\n        part causalRelationships : CausalRelationship[0..*];\n    }\n}",
    "package EquipmentRiskAnalysisSystem {\n    \n    part def Equipment {\n        part battery : Battery;\n        attribute operationalStatus : String;\n        attribute criticalFunctionStatus : String;\n    }\n    \n    part def Battery {\n        attribute batteryLevel : Real;\n        attribute age : Real;\n        attribute failureProbability : Real;\n        attribute minimumThreshold : Real = 20.0;\n    }\n    \n    part def RiskAnalysisSystem {\n        attribute monitoringActive : Boolean = true;\n        attribute riskDetected : Boolean;\n        attribute severityLevel : String;\n    }\n    \n    occurrence def BatteryAging {\n        attribute agingFactor : Real;\n        attribute impactOnFailureProbability : Real;\n    }\n    \n    occurrence def LowBatteryLevel {\n        attribute currentLevel : Real;\n        attribute duration : Real;\n        attribute belowThreshold : Boolean;\n    }\n    \n    occurrence def DeviceShutdown {\n        attribute shutdownTime : Real;\n        attribute criticalFunctionInterrupted : Boolean;\n    }\n    \n    part riskAnalysisSystem : RiskAnalysisSystem {\n        perform monitorBatteryLevel {\n            in batteryToMonitor : Battery;\n            out batteryStatus : String;\n        }\n        \n        perform detectAgingRisk {\n            in battery : Battery;\n            out agingRiskDetected : Boolean;\n        }\n        \n        perform analyzeFailureScenario {\n            in lowBatteryState : LowBatteryLevel;\n            out failureConsequence : String;\n        }\n        \n        perform assignSeverityLevel {\n            in failureType : String;\n            out severity : String;\n        }\n    }\n    \n    connection def CausesLowBattery {\n        end cause : BatteryAging;\n        end effect : LowBatteryLevel;\n    }\n    \n    connection def LeadsToShutdown {\n        end cause : LowBatteryLevel;\n        end effect : DeviceShutdown;\n    }\n    \n    constraint def BatteryFailureProbability {\n        batteryAge : Real;\n        failureProbability : Real;\n        failureProbability > 0.7 implies batteryAge > 3.0;\n    }\n    \n    constraint def LowBatteryCondition {\n        batteryLevel : Real;\n        minimumThreshold : Real;\n        lowBattery : Boolean;\n        lowBattery == (batteryLevel < minimumThreshold);\n    }\n    \n    constraint def CriticalSeverity {\n        criticalFunctionInterrupted : Boolean;\n        severityLevel : String;\n        criticalFunctionInterrupted implies severityLevel == \"High\";\n    }\n}",
    "package SystemStructuralDecomposition {\n    \n    part def System {\n        doc /* The system must possess a clear capability for structural decomposition */\n        \n        part subsystems : Subsystem[1..*];\n        part components : Component[1..*];\n        \n        port interfaces : Interface[1..*];\n    }\n    \n    part def Subsystem {\n        doc /* Subsystem as part of hierarchical structure */\n        \n        part subComponents : Component[1..*];\n        port subInterfaces : Interface[1..*];\n        \n        attribute level : Integer;\n        attribute functions : String[1..*];\n        attribute capabilities : String[1..*];\n    }\n    \n    part def Component {\n        doc /* Component that can be independently understood and analyzed */\n        \n        attribute name : String;\n        attribute functions : String[1..*];\n        attribute capabilities : String[1..*];\n        \n        port componentInterfaces : Interface[1..*];\n    }\n    \n    port def Interface {\n        doc /* Well defined interfaces between system components */\n        \n        attribute interfaceType : String;\n        attribute protocol : String;\n    }\n    \n    connection def ComponentConnection {\n        doc /* Connection enabling components to collaborate effectively */\n        \n        end sourceComponent : Component[1];\n        end targetComponent : Component[1];\n        \n        attribute connectionType : String;\n    }\n    \n    part systemInstance : System {\n        doc /* Top-down hierarchical structure instance */\n        \n        part subsystem1 : Subsystem {\n            :>> level = 1;\n        }\n        \n        part subsystem2 : Subsystem {\n            :>> level = 1;\n        }\n        \n        connection : ComponentConnection \n            connect subsystem1.subComponents[1] to subsystem2.subComponents[1];\n    }\n    \n    requirement def StructuralDecompositionRequirement {\n        doc /* Requirement for structural decomposition capability */\n        \n        subject system : System;\n        \n        require constraint {\n            system.subsystems->size() >= 1 and\n            system.components->size() >= 1\n        }\n    }\n    \n    requirement def InterfaceDefinitionRequirement {\n        doc /* Interfaces between components should be well defined */\n        \n        subject component : Component;\n        \n        require constraint {\n            component.componentInterfaces->size() >= 1\n        }\n    }\n    \n    requirement def IndependentAnalysisRequirement {\n        doc /* Each component can be independently understood and analyzed */\n        \n        subject component : Component;\n        \n        require constraint {\n            component.functions->size() >= 1 and\n            component.capabilities->size() >= 1\n        }\n    }\n    \n    requirement def VerificationRequirement {\n        doc /* System engineers and IV&V must be able to verify system integrity */\n        \n        subject system : System;\n        \n        require constraint {\n            system.subsystems->forAll(s | s.functions->notEmpty()) and\n            system.subsystems->forAll(s | s.capabilities->notEmpty())\n        }\n    }\n}",
    "package AutomotiveSystemArchitecture {\n    \n    part def Component {\n        attribute name : String;\n        attribute id : String;\n    }\n    \n    part def SafetyComponent :> Component {\n        attribute safetyLevel : String;\n        attribute isMandatory : Boolean;\n    }\n    \n    part def FunctionalComponent :> Component {\n        attribute function : String;\n    }\n    \n    part def System :> Component {\n        part subsystems : Subsystem[*];\n        part components : Component[*];\n    }\n    \n    part def Subsystem :> Component {\n        part components : Component[*];\n    }\n    \n    part def SeatBelt :> SafetyComponent {\n        attribute :>> isMandatory = true;\n        attribute :>> safetyLevel = \"Critical\";\n    }\n    \n    part def Bumper :> SafetyComponent {\n        attribute :>> isMandatory = true;\n        attribute :>> safetyLevel = \"Critical\";\n    }\n    \n    part def DriverAirbag :> SafetyComponent {\n        attribute :>> isMandatory = false;\n        attribute :>> safetyLevel = \"High\";\n    }\n    \n    part def ABS :> SafetyComponent {\n        attribute :>> isMandatory = false;\n        attribute :>> safetyLevel = \"High\";\n        attribute :>> name = \"Anti-lock Braking System\";\n    }\n    \n    part def AutomotiveSystem :> System {\n        attribute :>> name = \"Root Automotive System\";\n        \n        part safetySubsystem : Subsystem {\n            attribute :>> name = \"Safety Subsystem\";\n            \n            part seatBelt : SeatBelt {\n                attribute :>> name = \"Seat Belt System\";\n            }\n            \n            part bumper : Bumper {\n                attribute :>> name = \"Bumper System\";\n            }\n            \n            part driverAirbag : DriverAirbag {\n                attribute :>> name = \"Driver Airbag System\";\n            }\n            \n            part abs : ABS;\n        }\n        \n        part functionalSubsystem : Subsystem {\n            attribute :>> name = \"Functional Subsystem\";\n            \n            part engineControl : FunctionalComponent {\n                attribute :>> name = \"Engine Control Unit\";\n                attribute :>> function = \"Engine Management\";\n            }\n            \n            part transmission : FunctionalComponent {\n                attribute :>> name = \"Transmission Control\";\n                attribute :>> function = \"Gear Management\";\n            }\n        }\n    }\n    \n    view def ComponentHierarchyView {\n        expose AutomotiveSystem::**;\n    }\n    \n    view def SafetyComponentView {\n        filter AutomotiveSystem::**:>SafetyComponent;\n    }\n    \n    view def NonSafetyComponentView {\n        filter AutomotiveSystem::**:>FunctionalComponent;\n    }\n}",
    "package AutomotiveDomain {\n    doc /* This system model aims to provide standardized definitions and annotations for fundamental concepts and elements in the automotive domain. */\n    \n    part def Automobile {\n        doc /* Core component representing an automobile with standardized characteristics */\n        alias Car;\n        \n        attribute torque : ISQ::TorqueValue {\n            doc /* Physical quantity representing torque (扭矩) for standardized expression of automotive characteristics */\n        }\n    }\n    \n    comment /* The model emphasizes clarity and extensibility, enabling convenient development, integration, and maintenance of subsequent automotive-related systems. */\n}",
    "package DocumentManagementSystem {\n    \n    part def Automobile {\n        doc /* Core object for managing automobile information and documentation */\n        \n        attribute vin : String;\n        attribute make : String;\n        attribute model : String;\n        attribute year : Integer;\n        attribute documentationSet : String[0..*];\n        \n        attribute torqueSpec : ISQ::TorqueValue;\n    }\n    \n    alias Car for Automobile {\n        doc /* Alternative name for Automobile to support different user preferences */\n    }\n    \n    part def DocumentationPlatform {\n        doc /* Main system for document management related to automobiles */\n        \n        part automobiles : Automobile[0..*];\n        \n        action enterInformation {\n            in automobile : Automobile;\n            doc /* Action to enter automobile information into the system */\n        }\n        \n        action queryInformation {\n            in searchCriteria : String;\n            out results : Automobile[0..*];\n            doc /* Action to query automobile information */\n        }\n        \n        action archiveDocumentation {\n            in automobile : Automobile;\n            in document : String;\n            doc /* Action to archive automobile documentation */\n        }\n    }\n    \n    part def User {\n        doc /* System user who can perform operations on automobile documentation */\n        \n        attribute userId : String;\n        attribute preferredTerminology : String;\n    }\n    \n    usage platformInstance : DocumentationPlatform {\n        doc /* Instance of the document management platform */\n    }\n}",
    "package AutomobileSystem {\n    import ScalarValues::*;\n    \n    part def Automobile {\n        alias Car;\n        attribute torqueValue : TorqueValue;\n    }\n    \n    attribute def TorqueValue :> ScalarQuantityValue {\n        alias Torque;\n    }\n}",
    "package VehicleSystem {\n    \n    part def Vehicle;\n    \n    part def Engine {\n        attribute cylinders : Integer;\n    }\n    \n    part def Cylinder;\n    \n    part def StandardVehicle :> Vehicle {\n        part engine : Engine {\n            part cylinder : Cylinder[4..6];\n        }\n    }\n    \n    part def SmallVehicle :> Vehicle {\n        part engine : Engine {\n            part cylinder : Cylinder[4];\n        }\n    }\n    \n    part def LargeVehicle :> Vehicle {\n        part engine : Engine {\n            part cylinder : Cylinder[6];\n        }\n    }\n}",
    "package FuelManagementSystem {\n    \n    part def FuelSystem {\n        part fuelTank : FuelTank;\n        part engine : Engine;\n        \n        interface def FuelInterface {\n            end supplierPort;\n            end consumerPort;\n        }\n        \n        interface fuelSupplyInterface : FuelInterface connect supplierPort ::> fuelTank.fuelOutlet to consumerPort ::> engine.fuelInlet;\n        interface fuelReturnInterface : FuelInterface connect supplierPort ::> engine.fuelReturn to consumerPort ::> fuelTank.fuelReturn;\n    }\n    \n    part def FuelTank {\n        port fuelOutlet;\n        port fuelReturn;\n    }\n    \n    part def Engine {\n        port fuelInlet;\n        port fuelReturn;\n    }\n    \n    action def ManageFuelFlow {\n        action deliverFuel;\n        action returnFuel;\n        action monitorTemperature;\n    }\n}",
    "package VehicleStructure {\n    \n    attribute def MassValue :> ISQ::mass;\n    attribute def AngleValue :> ISQ::plane_angle;\n    \n    part def Vehicle {\n        attribute mass : MassValue;\n        \n        part frontAxleAssembly : AxleAssembly;\n        part rearAxleAssembly : AxleAssembly;\n    }\n    \n    part def AxleAssembly {\n        part axle : Axle;\n        part wheel1 : Wheel;\n        part wheel2 : Wheel;\n    }\n    \n    part def Axle {\n    }\n    \n    part def SteerableAxle :> Axle {\n        attribute steeringAngle : AngleValue;\n    }\n    \n    part def Wheel {\n    }\n    \n    part vehicle1 : Vehicle {\n        attribute :>> mass = 1750 [kg];\n    }\n    \n    part vehicle2 : Vehicle {\n        attribute :>> mass = 2000 [kg];\n        \n        part :>> frontAxleAssembly {\n            part :>> axle : SteerableAxle;\n            part leftWheel :>> wheel1;\n            part rightWheel :>> wheel2;\n        }\n        \n        part :>> rearAxleAssembly {\n            part leftWheel :>> wheel1;\n            part rightWheel :>> wheel2;\n        }\n    }\n}"
]