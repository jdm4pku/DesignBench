[
    "package VehicleManagementSystem {\n    \n    enum def GearSetting {\n        enum park;\n        enum reverse;\n        enum neutral;\n        enum drive;\n        enum sport;\n    }\n    \n    attribute def Mass :> ISQ::mass;\n    attribute def AcceleratorPosition :> Real {\n        doc /* Accelerator pedal position as percentage (0-100) */\n        constraint { 0.0 <= self <= 100.0 }\n    }\n    \n    part def Engine {\n        attribute engineID : String;\n        attribute engineType : String;\n        attribute displacement : Real;\n        attribute maxPower : Real;\n        attribute maxTorque : Real;\n    }\n    \n    part def Person {\n        attribute personID : String;\n        attribute name : String;\n        attribute licenseNumber : String;\n    }\n    \n    part def VehicleStatus {\n        attribute currentGear : GearSetting;\n        attribute acceleratorPedalPosition : AcceleratorPosition;\n        attribute timestamp : String;\n    }\n    \n    part def Vehicle {\n        attribute vehicleID : String;\n        attribute vehicleMass : Mass;\n        \n        part vehicleStatus : VehicleStatus[1];\n        part engine : Engine[1];\n        \n        ref driver : Person[0..1];\n    }\n    \n    part def VehicleManagementSystem {\n        part vehicles : Vehicle[*];\n        part engines : Engine[*];\n        part personnel : Person[*];\n    }\n}",
    "package VehicleSystem {\n    import ScalarValues::*;\n    \n    part def Personnel {\n        attribute name : String;\n    }\n    \n    part def Engine {\n        attribute power : Real;\n        attribute type : String;\n    }\n    \n    abstract part def Vehicle {\n        attribute id : String;\n    }\n    \n    part def ManuallyOperatedVehicle :> Vehicle {\n        part driver : Personnel[1];\n    }\n    \n    part def PoweredVehicle :> Vehicle {\n        part engine : Engine[1..*];\n    }\n    \n    part def ManuallyOperatedPoweredVehicle :> ManuallyOperatedVehicle, PoweredVehicle {\n    }\n}",
    "<scratchpad>\nKey functional/non-functional information extracted:\n1. Vehicle structure definition needed\n2. Vehicle composed of multiple components\n3. Major components: 1 engine, 1 transmission, 4 wheels\n4. Components are subclasses of vehicle components\n5. Compositional relationships with quantity requirements\n6. Exactly 4 wheels, 1 engine, 1 transmission\n7. System should support extensibility for vehicle and component types\n8. Need to accommodate different configurations and varieties\n\nMapping to SysML v2:\n- Use part definitions for Vehicle, VehicleComponent, Engine, Transmission, Wheel\n- Use specialization (subclassing) for component types\n- Use part usages with multiplicity for composition\n- Use abstract definitions for extensibility\n</scratchpad>\n\npackage VehicleStructure {\n    \n    abstract part def VehicleComponent;\n    \n    part def Engine :> VehicleComponent;\n    \n    part def Transmission :> VehicleComponent;\n    \n    part def Wheel :> VehicleComponent;\n    \n    abstract part def Vehicle {\n        part engine : Engine[1];\n        part transmission : Transmission[1];\n        part wheels : Wheel[4];\n    }\n}",
    "package VehicleSystem {\n    \n    abstract part def Vehicle {\n        abstract part engine : Engine[1];\n    }\n    \n    abstract part def Engine {\n        abstract part cylinders : Cylinder[*];\n    }\n    \n    part def Cylinder;\n    \n    part def SmallEngine :> Engine {\n        part redefines cylinders : Cylinder[4];\n    }\n    \n    part def LargeEngine :> Engine {\n        part redefines cylinders : Cylinder[6];\n    }\n    \n    part def SmallVehicle :> Vehicle {\n        part redefines engine : SmallEngine[1];\n    }\n    \n    part def LargeVehicle :> Vehicle {\n        part redefines engine : LargeEngine[1];\n    }\n}",
    "I'll analyze the requirement and create a SysML v2 model for the traffic signal system.\n\n<scratchpad>\nKey functional/non-functional information:\n1. Traffic signal system with a traffic signal component\n2. Traffic signal has color states: green, yellow, red\n3. A specific traffic signal instance that is always in green state\n4. Purpose: facilitate orderly traffic flow and management\n\nMapping to SysML v2:\n- Use package for overall system\n- Define enumeration for traffic light colors\n- Create part definition for traffic signal with state attribute\n- Create usage for specific green signal instance\n- Add documentation\n</scratchpad>\n\npackage TrafficSignalSystem {\n    \n    enum def TrafficLightColor {\n        enum green;\n        enum yellow;\n        enum red;\n    }\n    \n    part def TrafficSignal {\n        doc /* Represents a traffic signal component that manages \n             * the current color state of the traffic light */\n        \n        attribute currentColor : TrafficLightColor;\n    }\n    \n    part def TrafficSignalSystem {\n        doc /* System that includes traffic signal components to\n             * facilitate orderly traffic flow and management */\n        \n        part trafficSignal : TrafficSignal;\n        \n        part greenSignal : TrafficSignal {\n            doc /* Specific traffic signal component that is \n                 * always in the green \"go\" state */\n            \n            attribute redefines currentColor = TrafficLightColor::green;\n        }\n    }\n}",
    "package InformationClassificationSystem {\n    \n    enum def InformationClassificationLevel {\n        enum unclassified;\n        enum confidential;\n        enum secret;\n    }\n    \n    enum def GradeLevel {\n        enum A;\n        enum B;\n        enum C;\n        enum D;\n        enum F;\n    }\n    \n    attribute def InformationClassificationCode {\n        attribute code : String;\n    }\n    \n    attribute def InformationClassificationColor {\n        attribute color : String;\n    }\n    \n    attribute def GradePoints {\n        attribute points : Real;\n    }\n    \n    part def InformationClassification {\n        attribute level : InformationClassificationLevel;\n        attribute code : String;\n        attribute color : String;\n        \n        constraint {\n            (level == InformationClassificationLevel::unclassified) implies \n                (code == \"uncl\" and color == \"green\")\n        }\n        \n        constraint {\n            (level == InformationClassificationLevel::confidential) implies \n                (code == \"conf\" and color == \"yellow\")\n        }\n        \n        constraint {\n            (level == InformationClassificationLevel::secret) implies \n                (code == \"secr\" and color == \"red\")\n        }\n    }\n    \n    part def GradeClassification {\n        attribute grade : GradeLevel;\n        attribute points : Real;\n        \n        constraint {\n            (grade == GradeLevel::A) implies (points == 4.0)\n        }\n        \n        constraint {\n            (grade == GradeLevel::B) implies (points == 3.0)\n        }\n        \n        constraint {\n            (grade == GradeLevel::C) implies (points == 2.0)\n        }\n        \n        constraint {\n            (grade == GradeLevel::D) implies (points == 1.0)\n        }\n        \n        constraint {\n            (grade == GradeLevel::F) implies (points == 0.0)\n        }\n    }\n    \n    part def InformationManagementSystem {\n        part informationClassifier : InformationClassification[*];\n        part gradeClassifier : GradeClassification[*];\n        \n        action classifyInformation {\n            in item info : InformationItem;\n            out item classifiedInfo : ClassifiedInformation;\n        }\n        \n        action assignGrade {\n            in item gradedItem : GradableItem;\n            out item gradedResult : GradedItem;\n        }\n    }\n    \n    item def InformationItem {\n        attribute content : String;\n    }\n    \n    item def ClassifiedInformation :> InformationItem {\n        attribute classification : InformationClassification;\n    }\n    \n    item def GradableItem {\n        attribute name : String;\n    }\n    \n    item def GradedItem :> GradableItem {\n        attribute gradeClassification : GradeClassification;\n    }\n}",
    "package VehicleSystem {\n    \n    part def Vehicle {\n        part engine : Engine[1];\n    }\n    \n    part def SmallVehicle :> Vehicle {\n        part engine : Engine[1] :>> Vehicle::engine {\n            part cylinders : Cylinder[4];\n        }\n    }\n    \n    part def LargeVehicle :> Vehicle {\n        part engine : Engine[1] :>> Vehicle::engine {\n            part cylinders : Cylinder[6];\n        }\n    }\n    \n    part def Engine {\n        part cylinders : Cylinder[4..6];\n    }\n    \n    part def Cylinder {\n        doc /* Fundamental component of the engine, plays a key role in \n             * the engine's normal operation and the vehicle's power output */\n    }\n}",
    "package VehicleModelingSystem {\n    \n    // Basic definitions\n    attribute def FuelType {\n        attribute name : String;\n    }\n    \n    attribute def QualityAttribute {\n        attribute name : String;\n        attribute value : Real;\n        attribute unit : String;\n    }\n    \n    // Personnel definition\n    part def Person {\n        attribute name : String;\n        attribute licenseNumber : String;\n        attribute age : Integer;\n    }\n    \n    // Fuel definition\n    part def Fuel {\n        attribute type : FuelType;\n        attribute octaneRating : Real;\n    }\n    \n    // Fuel tank definition\n    part def FuelTank {\n        attribute capacity : Real;\n        attribute currentLevel : Real;\n        ref storedFuel : Fuel;\n    }\n    \n    // Vehicle definition\n    part def Vehicle {\n        attribute vin : String;\n        attribute model : String;\n        attribute year : Integer;\n        \n        attribute qualityAttributes : QualityAttribute[*];\n        \n        ref driver : Person;\n        part fuelTank : FuelTank;\n    }\n    \n    // Usage example\n    part vehicleInstance : Vehicle {\n        attribute vin = \"1HGCM82633A123456\";\n        attribute model = \"Sedan\";\n        attribute year = 2024;\n        \n        attribute qualityAttributes = (\n            QualityAttribute {\n                name = \"weight\";\n                value = 1500.0;\n                unit = \"kg\";\n            },\n            QualityAttribute {\n                name = \"maxSpeed\";\n                value = 200.0;\n                unit = \"km/h\";\n            }\n        );\n        \n        ref driver : Person {\n            attribute name = \"John Doe\";\n            attribute licenseNumber = \"DL123456\";\n            attribute age = 35;\n        }\n        \n        part fuelTank : FuelTank {\n            attribute capacity = 60.0;\n            attribute currentLevel = 45.0;\n            ref storedFuel : Fuel {\n                attribute type = FuelType { name = \"Gasoline\"; };\n                attribute octaneRating = 95.0;\n            }\n        }\n    }\n}",
    "package WheelAssemblyStructure {\n    \n    part def WheelBearingUnit;\n    \n    part def Tire {\n        part bead[2];\n    }\n    \n    part def Hub {\n        part rim[2];\n        part mountingHole[*];\n        part threadedHole[*];\n    }\n    \n    part def Bolt;\n    \n    connection def BoltConnection {\n        end bolt : Bolt[1];\n        end mountingHole : Hub::mountingHole[1];\n        end threadedHole : Hub::threadedHole[1];\n    }\n    \n    connection def BeadRimSeal {\n        end bead : Tire::bead[1];\n        end rim : Hub::rim[1];\n    }\n    \n    part wheelAssembly : WheelAssemblyStructure {\n        part wheelBearingUnit : WheelBearingUnit;\n        part tire : Tire;\n        part hub : Hub;\n        part bolt : Bolt[*];\n        \n        connection beadRimConnection : BeadRimSeal[2] \n            connect tire.bead[1] to hub.rim[1],\n                    tire.bead[2] to hub.rim[2];\n        \n        connection boltConnections : BoltConnection[*]\n            connect bolt to (hub.mountingHole, hub.threadedHole);\n    }\n}",
    "I'll analyze the requirement and create a SysML v2 model for the fuel flow management system.\n\n<scratchpad>\nKey functional/non-functional information extracted:\n1. System purpose: Effective management of fuel flow\n2. Main components: Fuel tank assembly, Engine\n3. Functions:\n   - Fuel tank supplies fuel to engine through dedicated port\n   - Fuel tank receives excess fuel returned from engine\n   - Temperature detection and transmission at interface\n   - Real-time data provision (fuel supply, return flow, temperature)\n   - Visualized monitoring\n   - Precise control of fuel flow status\n\nMapping to SysML v2:\n- Package for organization\n- Part definitions for components (FuelTankAssembly, Engine)\n- Interface definition for fuel flow with temperature\n- Attributes for fuel flow and temperature\n- Ports for connections\n- Item definition for Fuel\n- Connection definitions for fuel supply and return\n- Part usage in system definition\n- Requirements for traceability\n</scratchpad>\n\npackage FuelFlowManagementSystem {\n    import ScalarValues::*;\n    \n    item def Fuel;\n    \n    attribute def Temperature :> ScalarValues::Real;\n    attribute def FlowRate :> ScalarValues::Real;\n    \n    port def FuelFlowPort {\n        out fuel : Fuel;\n        out temperature : Temperature;\n        out flowRate : FlowRate;\n    }\n    \n    port def FuelReturnPort {\n        in fuel : Fuel;\n        in temperature : Temperature;\n        in flowRate : FlowRate;\n    }\n    \n    part def FuelTankAssembly {\n        attribute capacity : ScalarValues::Real;\n        attribute currentLevel : ScalarValues::Real;\n        \n        port fuelSupplyPort : FuelFlowPort;\n        port fuelReturnPort : FuelReturnPort;\n    }\n    \n    part def Engine {\n        attribute fuelConsumptionRate : ScalarValues::Real;\n        \n        port fuelInletPort : ~FuelFlowPort;\n        port fuelReturnPort : ~FuelReturnPort;\n    }\n    \n    connection def FuelSupplyConnection {\n        end supplier : FuelFlowPort;\n        end consumer : ~FuelFlowPort;\n    }\n    \n    connection def FuelReturnConnection {\n        end returner : ~FuelReturnPort;\n        end receiver : FuelReturnPort;\n    }\n    \n    part def FuelFlowManagementSystem {\n        part fuelTank : FuelTankAssembly;\n        part engine : Engine;\n        \n        connection fuelSupply : FuelSupplyConnection \n            connect fuelTank.fuelSupplyPort to engine.fuelInletPort;\n            \n        connection fuelReturn : FuelReturnConnection\n            connect engine.fuelReturnPort to fuelTank.fuelReturnPort;\n    }\n    \n    requirement def EffectiveFuelManagement {\n        doc /* This system is designed to achieve effective management of fuel flow */\n    }\n    \n    requirement def TemperatureMonitoring {\n        doc /* Temperature information can be detected and transmitted at the interface */\n    }\n    \n    requirement def RealTimeDataProvision {\n        doc /* Users can obtain real-time data on fuel supply, return flow, and related temperature parameters */\n    }\n    \n    requirement def VisualizedMonitoring {\n        doc /* Enabling visualized monitoring and precise control of fuel flow status */\n    }\n}",
    "package VehicleConfigurationModel {\n    import ScalarValues::*;\n    \n    part def Vehicle {\n        attribute mass : Real default 1750.0 [kg];\n        part frontAxle : Axle[1];\n        part rearAxle : Axle[1];\n    }\n    \n    part def Axle {\n        attribute mass : Real [kg];\n        part tires : Tire[2] ordered;\n    }\n    \n    part def FrontAxle :> Axle {\n        attribute steeringAngle : Real [deg];\n    }\n    \n    part def RearAxle :> Axle;\n    \n    part def Tire {\n        attribute mass : Real [kg];\n    }\n    \n    part vehicle1_c1 : Vehicle {\n        attribute :>> mass = 2000.0 [kg];\n        part :>> frontAxle : FrontAxle {\n            part :>> tires {\n                part tire1 : Tire;\n                part tire2 : Tire;\n            }\n        }\n        part :>> rearAxle : RearAxle {\n            part :>> tires {\n                part tire3 : Tire;\n                part tire4 : Tire;\n            }\n        }\n    }\n}",
    "I'll analyze the requirements and create a SysML v2 model for the vehicle-trailer coupling system.\n\n<scratchpad>\nKey functional/non-functional information extracted:\n1. System consists of: vehicle, trailer, coupling mechanism (hitch with ball connector)\n2. Vehicle references the ball in the hitch (not built-in)\n3. Trailer references the connector in the hitch\n4. Design goals: reusability, flexibility, modularity, maintainability\n5. Components can be independently detached\n\nSysML v2 mapping:\n- Use part definitions for Vehicle, Trailer, Hitch, Ball, Connector\n- Use interface definitions for coupling interfaces\n- Use connection definitions for the coupling relationships\n- Use part usages and reference properties\n- Model the binding/allocation relationships\n</scratchpad>\n\npackage VehicleTrailerCouplingSystem {\n    \n    part def Vehicle {\n        ref ballReference : Ball;\n    }\n    \n    part def Trailer {\n        ref connectorReference : Connector;\n    }\n    \n    part def Hitch {\n        part ball : Ball;\n        part connector : Connector;\n    }\n    \n    part def Ball;\n    \n    part def Connector;\n    \n    interface def CouplingInterface {\n        end ballEnd : Ball;\n        end connectorEnd : Connector;\n    }\n    \n    connection def PhysicalCoupling {\n        end vehicle : Vehicle;\n        end trailer : Trailer;\n        interface : CouplingInterface connect \n            vehicle.ballReference to trailer.connectorReference;\n    }\n    \n    part couplingSystem : CouplingSystem {\n        part vehicle : Vehicle;\n        part trailer : Trailer;\n        part hitch : Hitch;\n        \n        bind vehicle.ballReference = hitch.ball;\n        bind trailer.connectorReference = hitch.connector;\n        \n        connection : PhysicalCoupling connect vehicle to trailer;\n    }\n    \n    part def CouplingSystem {\n        attribute reusability : Boolean = true;\n        attribute flexibility : Boolean = true;\n        attribute modularity : Boolean = true;\n        attribute maintainability : Boolean = true;\n    }\n}",
    "package VehiclePowerTransmissionSystem {\n    import ScalarValues::*;\n    \n    // Port definitions\n    port def PowerPort {\n        out power : Real;\n        in torque : Real;\n        in rotationalSpeed : Real;\n    }\n    \n    port def ControlPort {\n        in command : Real;\n    }\n    \n    port def MechanicalPort {\n        out force : Real;\n        out velocity : Real;\n        in resistance : Real;\n    }\n    \n    port def RoadInterface {\n        out tractionForce : Real;\n        in roadResistance : Real;\n        in frictionCoefficient : Real;\n    }\n    \n    // Part definitions\n    part def Engine {\n        port fuelCommand : ControlPort;\n        port powerOut : PowerPort;\n        port clutchConnection : PowerPort;\n        \n        attribute maxPower : Real;\n        attribute efficiency : Real;\n    }\n    \n    part def Clutch {\n        port engineSide : ~PowerPort;\n        port transmissionSide : PowerPort;\n        \n        attribute engaged : Boolean;\n        attribute slipRatio : Real;\n    }\n    \n    part def Transmission {\n        port powerIn : ~PowerPort;\n        port powerOut : PowerPort;\n        \n        attribute gearRatio : Real[1..*];\n        attribute currentGear : Integer;\n    }\n    \n    part def Driveshaft {\n        port frontConnection : ~PowerPort;\n        port rearConnection : PowerPort;\n        \n        attribute length : Real;\n        attribute stiffness : Real;\n    }\n    \n    part def Differential {\n        port input : ~PowerPort;\n        port leftOutput : PowerPort;\n        port rightOutput : PowerPort;\n        \n        attribute ratio : Real;\n    }\n    \n    part def HalfShaft {\n        port differentialSide : ~PowerPort;\n        port wheelSide : PowerPort;\n        \n        attribute length : Real;\n        attribute diameter : Real;\n    }\n    \n    part def Wheel {\n        port shaftConnection : ~PowerPort;\n        port roadContact : RoadInterface;\n        \n        attribute radius : Real;\n        attribute inertia : Real;\n    }\n    \n    part def RearAxleAssembly {\n        part differential : Differential;\n        part leftHalfShaft : HalfShaft;\n        part rightHalfShaft : HalfShaft;\n        \n        port powerInput : ~PowerPort;\n        port leftWheelConnection : PowerPort;\n        port rightWheelConnection : PowerPort;\n        \n        bind powerInput = differential.input;\n        bind differential.leftOutput = leftHalfShaft.differentialSide;\n        bind differential.rightOutput = rightHalfShaft.differentialSide;\n        bind leftHalfShaft.wheelSide = leftWheelConnection;\n        bind rightHalfShaft.wheelSide = rightWheelConnection;\n    }\n    \n    part def VehiclePowerSystem {\n        part engine : Engine;\n        part clutch : Clutch;\n        part transmission : Transmission;\n        part driveshaft : Driveshaft;\n        part rearAxle : RearAxleAssembly;\n        part leftRearWheel : Wheel;\n        part rightRearWheel : Wheel;\n        \n        port fuelControl : ControlPort;\n        port leftRoadInterface : RoadInterface;\n        port rightRoadInterface : RoadInterface;\n        \n        bind fuelControl = engine.fuelCommand;\n        bind engine.clutchConnection = clutch.engineSide;\n        bind clutch.transmissionSide = transmission.powerIn;\n        bind transmission.powerOut = driveshaft.frontConnection;\n        bind driveshaft.rearConnection = rearAxle.powerInput;\n        bind rearAxle.leftWheelConnection = leftRearWheel.shaftConnection;\n        bind rearAxle.rightWheelConnection = rightRearWheel.shaftConnection;\n        bind leftRearWheel.roadContact = leftRoadInterface;\n        bind rightRearWheel.roadContact = rightRoadInterface;\n    }\n}",
    "package SystemArchitecture {\n    import ScalarValues::*;\n    \n    // Component definitions\n    part def C1 {\n        port pb;\n    }\n    \n    part def C2 {\n        port pa;\n    }\n    \n    part def C3 {\n        port pd;\n    }\n    \n    part def C4 {\n        port pc;\n    }\n    \n    // Interface definitions\n    interface def SignalInterface;\n    \n    // First decomposition subsystems\n    part def B11 {\n        part c1 : C1;\n        part c2 : C2;\n        \n        interface pe : SignalInterface;\n        \n        bind pe = c1.pb;\n        connect c1.pb to c2.pa;\n    }\n    \n    part def B12 {\n        part c3 : C3;\n        part c4 : C4;\n        \n        interface pf : SignalInterface;\n        \n        bind pf = c3.pd;\n        connect c3.pd to c4.pc;\n    }\n    \n    // Second decomposition modules\n    part def B21 {\n        ref part c1 : C1;\n        ref part c2 : C2;\n        ref part c3 : C3;\n        ref part c4 : C4;\n        \n        connect c1.pb to c2.pa;\n        connect c3.pd to c4.pc;\n    }\n    \n    part def B22 {\n        ref part c1 : C1;\n        ref part c2 : C2;\n        ref part c3 : C3;\n        ref part c4 : C4;\n        \n        connect c1.pb to c3.pd;\n        connect c2.pa to c4.pc;\n    }\n    \n    // Main system definition\n    part def IntegratedSystem {\n        // First architecture\n        part a11 {\n            part b11 : B11;\n            part b12 : B12;\n            \n            connect b11.pe to b12.pf;\n        }\n        \n        // Second architecture\n        part a21 {\n            part b21 : B21;\n            part b22 : B22;\n        }\n    }\n}",
    "package PowertrainSystem {\n    import ScalarValues::*;\n    \n    part def Engine {\n        attribute isRunning : Boolean = false;\n        attribute engineTorque : Real = 0.0;\n        \n        port fuelCommandPort : ~FuelCommand;\n        port startStopPort : ~StartStopCommand;\n        port torqueOutputPort : TorqueFlow;\n    }\n    \n    part def Transmission {\n        attribute gearRatio : Real = 1.0;\n        attribute outputTorque : Real = 0.0;\n        \n        port torqueInputPort : ~TorqueFlow;\n        port torqueOutputPort : TorqueFlow;\n    }\n    \n    part def Driveshaft {\n        attribute shaftTorque : Real = 0.0;\n        \n        port torqueInputPort : ~TorqueFlow;\n        port torqueOutputPort : TorqueFlow;\n    }\n    \n    part def Differential {\n        attribute leftWheelTorque : Real = 0.0;\n        attribute rightWheelTorque : Real = 0.0;\n        \n        port torqueInputPort : ~TorqueFlow;\n        port leftTorquePort : TorqueFlow;\n        port rightTorquePort : TorqueFlow;\n    }\n    \n    part def Wheel {\n        attribute wheelTorque : Real = 0.0;\n        attribute drivingForce : Real = 0.0;\n        \n        port torqueInputPort : ~TorqueFlow;\n    }\n    \n    port def FuelCommand {\n        attribute fuelRate : Real;\n    }\n    \n    port def StartStopCommand {\n        attribute command : String;\n    }\n    \n    port def TorqueFlow {\n        attribute torqueValue : Real;\n    }\n    \n    part automotivePowertrain : PowertrainSystem {\n        part engine : Engine;\n        part transmission : Transmission;\n        part driveshaft : Driveshaft;\n        part differential : Differential;\n        part leftWheel : Wheel;\n        part rightWheel : Wheel;\n        \n        interface engineToTransmission connect engine.torqueOutputPort to transmission.torqueInputPort;\n        interface transmissionToDriveshaft connect transmission.torqueOutputPort to driveshaft.torqueInputPort;\n        interface driveshaftToDifferential connect driveshaft.torqueOutputPort to differential.torqueInputPort;\n        interface differentialToLeftWheel connect differential.leftTorquePort to leftWheel.torqueInputPort;\n        interface differentialToRightWheel connect differential.rightTorquePort to rightWheel.torqueInputPort;\n        \n        action generateEngineTorque {\n            in fuelCommand : FuelCommand;\n            in engineState : Boolean;\n            out torque : Real;\n            \n            if engineState {\n                torque := fuelCommand.fuelRate * 100.0;\n            } else {\n                torque := 0.0;\n            }\n        }\n        \n        action amplifyTorque {\n            in inputTorque : Real;\n            in ratio : Real;\n            out outputTorque : Real;\n            \n            outputTorque := inputTorque * ratio;\n        }\n        \n        action distributeTorque {\n            in inputTorque : Real;\n            out leftTorque : Real;\n            out rightTorque : Real;\n            \n            leftTorque := inputTorque * 0.5;\n            rightTorque := inputTorque * 0.5;\n        }\n        \n        action startEngine {\n            in command : StartStopCommand;\n            inout engineState : Boolean;\n            \n            if command.command == \"start\" {\n                engineState := true;\n            }\n        }\n        \n        action stopEngine {\n            in command : StartStopCommand;\n            inout engineState : Boolean;\n            \n            if command.command == \"stop\" {\n                engineState := false;\n            }\n        }\n    }\n    \n    requirement powerTransmissionReq {\n        doc /* The system shall transmit power from engine through transmission, \n               driveshaft, and differential to wheels */\n    }\n    \n    requirement engineControlReq {\n        doc /* The system shall support engine start and stop commands */\n    }\n    \n    requirement torqueDistributionReq {\n        doc /* The system shall distribute torque equally to left and right wheels */\n    }\n    \n    requirement safeShutdownReq {\n        doc /* The system shall cease all torque generation and transmission \n               when engine is shut down */\n    }\n}",
    "package AutomotivePowertrainSystem {\n    import ScalarValues::*;\n    \n    part def PowertrainController {\n        in port fuelControlCommand;\n        in port stallSignal;\n        out port engineStatus;\n        out port torqueCommand;\n    }\n    \n    part def Engine {\n        in port startCommand;\n        in port shutdownCommand;\n        in port fuelCommand;\n        out port engineTorque;\n        out port status;\n    }\n    \n    part def TorqueAmplifier {\n        in port inputTorque;\n        out port amplifiedTorque;\n        attribute amplificationRatio : Real;\n    }\n    \n    part def Transmission {\n        in port inputTorque;\n        out port transmittedTorque;\n        attribute gearRatio : Real;\n    }\n    \n    part def TorqueDistributor {\n        in port inputTorque;\n        out port leftWheelTorque;\n        out port rightWheelTorque;\n        out port frontWheelTorque;\n        out port rearWheelTorque;\n    }\n    \n    part def DriveWheel {\n        in port appliedTorque;\n        out port wheelSpeed;\n        attribute wheelRadius : Real;\n    }\n    \n    part powertrainSystem : PowertrainController {\n        part engine : Engine;\n        part torqueAmplifier : TorqueAmplifier;\n        part transmission : Transmission;\n        part torqueDistributor : TorqueDistributor;\n        part frontLeftWheel : DriveWheel;\n        part frontRightWheel : DriveWheel;\n        part rearLeftWheel : DriveWheel;\n        part rearRightWheel : DriveWheel;\n        \n        interface engineControl connect powertrainSystem.engineStatus to engine.status;\n        interface torqueFlow1 connect engine.engineTorque to torqueAmplifier.inputTorque;\n        interface torqueFlow2 connect torqueAmplifier.amplifiedTorque to transmission.inputTorque;\n        interface torqueFlow3 connect transmission.transmittedTorque to torqueDistributor.inputTorque;\n        interface wheelTorque1 connect torqueDistributor.frontWheelTorque to frontLeftWheel.appliedTorque;\n        interface wheelTorque2 connect torqueDistributor.frontWheelTorque to frontRightWheel.appliedTorque;\n        interface wheelTorque3 connect torqueDistributor.rearWheelTorque to rearLeftWheel.appliedTorque;\n        interface wheelTorque4 connect torqueDistributor.rearWheelTorque to rearRightWheel.appliedTorque;\n    }\n    \n    action def StartEngine {\n        in fuelCmd;\n        out engineRunning : Boolean;\n        out torqueOutput : Real;\n    }\n    \n    action def StopEngine {\n        in stallDetected : Boolean;\n        out engineStopped : Boolean;\n    }\n    \n    action def AmplifyTorque {\n        in inputTorque : Real;\n        in ratio : Real;\n        out outputTorque : Real = inputTorque * ratio;\n    }\n    \n    action def TransmitPower {\n        in inputTorque : Real;\n        in gearRatio : Real;\n        out outputTorque : Real = inputTorque * gearRatio;\n    }\n    \n    action def DistributeTorque {\n        in totalTorque : Real;\n        out frontTorque : Real = totalTorque * 0.4;\n        out rearTorque : Real = totalTorque * 0.6;\n    }\n    \n    requirement def PowerDeliveryRequirement {\n        doc /* The system shall deliver power from fuel commands to wheel output torque through sequential stages */\n        subject powertrainSystem;\n    }\n    \n    requirement def EngineControlRequirement {\n        doc /* The system shall support engine start and shutdown control */\n        subject engine;\n    }\n    \n    requirement def StallResponseRequirement {\n        doc /* The system shall halt operational processes when stall signal is detected */\n        subject powertrainSystem;\n    }\n    \n    requirement def ReliabilityRequirement {\n        doc /* The system shall provide reliable power response and handling experience */\n        subject powertrainSystem;\n        attribute mtbf : Real >= 10000 [h];\n    }\n    \n    requirement def EfficiencyRequirement {\n        doc /* The system shall ensure efficient and coordinated power delivery */\n        subject powertrainSystem;\n        attribute efficiency : Real >= 0.85;\n    }\n}",
    "package VehiclePowertrainSystem {\n    \n    part def PowertrainController {\n        attribute fuelCommand : Real;\n        attribute engineStartSignal : Boolean;\n        attribute engineShutdownSignal : Boolean;\n        \n        port fuelInput : ~FuelCommandInterface;\n        port engineControl : EngineControlInterface;\n        port transmissionControl : TransmissionControlInterface;\n    }\n    \n    part def Engine {\n        attribute outputTorque : Real;\n        attribute isRunning : Boolean = false;\n        \n        port control : ~EngineControlInterface;\n        port torqueOutput : TorqueInterface;\n        \n        action generateTorque {\n            in fuelCmd : Real;\n            out torque : Real;\n        }\n    }\n    \n    part def Transmission {\n        attribute gearRatio : Real;\n        attribute amplifiedTorque : Real;\n        \n        port torqueInput : ~TorqueInterface;\n        port torqueOutput : TorqueInterface;\n        port control : ~TransmissionControlInterface;\n        \n        action amplifyTorque {\n            in inputTorque : Real;\n            in ratio : Real;\n            out outputTorque : Real;\n        }\n    }\n    \n    part def TorqueDistributor {\n        attribute distributedTorque : Real[4];\n        \n        port torqueInput : ~TorqueInterface;\n        port wheelTorqueOutput : TorqueInterface[4];\n        \n        action distributeTorque {\n            in totalTorque : Real;\n            out wheelTorques : Real[4];\n        }\n    }\n    \n    part def Wheel {\n        attribute appliedTorque : Real;\n        \n        port torqueInput : ~TorqueInterface;\n    }\n    \n    interface def FuelCommandInterface {\n        flow fuelCommand : Real;\n    }\n    \n    interface def EngineControlInterface {\n        flow startSignal : Boolean;\n        flow shutdownSignal : Boolean;\n        flow fuelCommand : Real;\n    }\n    \n    interface def TransmissionControlInterface {\n        flow gearCommand : Real;\n    }\n    \n    interface def TorqueInterface {\n        flow torque : Real;\n    }\n    \n    part vehiclePowertrain : PowertrainController {\n        part engine : Engine;\n        part transmission : Transmission;\n        part torqueDistributor : TorqueDistributor;\n        part wheels : Wheel[4];\n        \n        connect vehiclePowertrain.engineControl to engine.control;\n        connect vehiclePowertrain.transmissionControl to transmission.control;\n        connect engine.torqueOutput to transmission.torqueInput;\n        connect transmission.torqueOutput to torqueDistributor.torqueInput;\n        \n        for i in 1..4 {\n            connect torqueDistributor.wheelTorqueOutput[i] to wheels[i].torqueInput;\n        }\n        \n        state machine PowertrainStates {\n            entry state off;\n            state running {\n                entry action {\n                    engine.isRunning := true;\n                }\n                do action {\n                    engine.generateTorque(vehiclePowertrain.fuelCommand) >> engine.outputTorque;\n                    transmission.amplifyTorque(engine.outputTorque, transmission.gearRatio) >> transmission.amplifiedTorque;\n                    torqueDistributor.distributeTorque(transmission.amplifiedTorque) >> torqueDistributor.distributedTorque;\n                }\n                exit action {\n                    engine.isRunning := false;\n                    engine.outputTorque := 0;\n                }\n            }\n            \n            transition off_to_running : off --> running {\n                guard vehiclePowertrain.engineStartSignal;\n            }\n            \n            transition running_to_off : running --> off {\n                guard vehiclePowertrain.engineShutdownSignal;\n            }\n        }\n    }\n    \n    requirement integratedManagement {\n        doc /* The system shall achieve integrated management of the vehicle powertrain system according to the driver's fuel input command */\n        satisfy vehiclePowertrain;\n    }\n    \n    requirement torqueGeneration {\n        doc /* The system shall generate corresponding engine output torque based on the fuel command when engine start signal is activated */\n        satisfy engine.generateTorque;\n    }\n    \n    requirement torqueTransmission {\n        doc /* The system shall amplify and transmit torque sequentially through the transmission */\n        satisfy transmission.amplifyTorque;\n    }\n    \n    requirement torqueDistribution {\n        doc /* The system shall distribute torque to each wheel */\n        satisfy torqueDistributor.distributeTorque;\n    }\n    \n    requirement powerTermination {\n        doc /* The system shall terminate power output process when engine shutdown signal is triggered */\n        satisfy vehiclePowertrain.PowertrainStates.running_to_off;\n    }\n    \n    requirement performanceEfficiency {\n        doc /* The system shall ensure automatic control accurately and efficiently in power demand response, torque transmission, and power distribution */\n        refine integratedManagement;\n    }\n}",
    "package PowerConnectionSystem {\n    \n    part def VehicleFrame {\n        part hitchBall : HitchBall;\n    }\n    \n    part def TrailerFrame {\n        part trailerCoupler : TrailerCoupler;\n    }\n    \n    part def HitchBall;\n    \n    part def TrailerCoupler;\n    \n    part def Vehicle {\n        part vehicleFrame : VehicleFrame;\n    }\n    \n    part def Trailer {\n        part trailerFrame : TrailerFrame;\n    }\n    \n    interface def HitchInterface {\n        end vehicle : HitchBall;\n        end trailer : TrailerCoupler;\n    }\n    \n    connection def PowerConnection {\n        end vehicle : Vehicle;\n        end trailer : Trailer;\n        \n        interface : HitchInterface connect \n            vehicle.vehicleFrame.hitchBall to \n            trailer.trailerFrame.trailerCoupler;\n    }\n    \n    part powerConnectionSystem : PowerConnectionSystem {\n        part vehicle : Vehicle;\n        part trailer : Trailer;\n        \n        state connectionStates {\n            entry state disconnected;\n            state connected;\n            \n            transition disconnected_to_connected\n                first disconnected\n                then connected;\n                \n            transition connected_to_disconnected\n                first connected\n                then disconnected;\n        }\n    }\n    \n    action def Connect {\n        in vehicle : Vehicle;\n        in trailer : Trailer;\n        out connection : PowerConnection;\n    }\n    \n    action def Disconnect {\n        in connection : PowerConnection;\n    }\n    \n    requirement def SafeConnectionRequirement {\n        doc /* The system shall enable safe and reliable connection \n               between vehicle and trailer */\n    }\n    \n    requirement def FlexibleCombinationRequirement {\n        doc /* The system shall achieve flexible combination and \n               separation of vehicle and trailer */\n    }\n    \n    requirement def MultiScenarioRequirement {\n        doc /* The system shall meet user requirements for vehicle \n               and trailer power coupling in various scenarios */\n    }\n}",
    "<scratchpad>\nLet me analyze the requirement step by step:\n\n1. Key Components:\n   - System: Vehicle-Trailer Connection Management System\n   - Parts: Vehicle (with chassis and tow ball), Trailer (with coupler and trailer frame)\n   - Interfaces: Connection between tow ball and coupler\n\n2. Key Functions:\n   - Connect trailer to vehicle\n   - Disconnect trailer from vehicle\n   - Manage connection status\n\n3. Key Attributes/States:\n   - Connection status (connected/disconnected)\n   - Safety and reliability aspects\n\n4. SysML v2 Mapping:\n   - Use package for overall system\n   - Define parts for Vehicle and Trailer\n   - Define subparts for chassis, tow ball, coupler, trailer frame\n   - Define interface/connection between tow ball and coupler\n   - Define actions for connect and disconnect operations\n   - Define states for connection status\n</scratchpad>\n\npackage VehicleTrailerConnectionSystem {\n    \n    part def Vehicle {\n        part chassis : Chassis;\n        part towBall : TowBall;\n    }\n    \n    part def Trailer {\n        part coupler : Coupler;\n        part trailerFrame : TrailerFrame;\n    }\n    \n    part def Chassis;\n    part def TowBall;\n    part def Coupler;\n    part def TrailerFrame;\n    \n    interface def TowBallCouplerInterface {\n        end towBallEnd : TowBall;\n        end couplerEnd : Coupler;\n    }\n    \n    part vehicleTrailerSystem : VehicleTrailerSystem {\n        part vehicle : Vehicle;\n        part trailer : Trailer;\n        \n        interface : TowBallCouplerInterface connect \n            vehicle.towBall to trailer.coupler;\n        \n        attribute connectionStatus : ConnectionStatusType;\n        \n        action connectTrailer {\n            in item vehicle : Vehicle;\n            in item trailer : Trailer;\n            out item connectedSystem : VehicleTrailerSystem;\n            \n            bind connectionStatus = ConnectionStatusType::connected;\n        }\n        \n        action disconnectTrailer {\n            in item connectedSystem : VehicleTrailerSystem;\n            out item vehicle : Vehicle;\n            out item trailer : Trailer;\n            \n            bind connectionStatus = ConnectionStatusType::disconnected;\n        }\n    }\n    \n    part def VehicleTrailerSystem {\n        part vehicle : Vehicle;\n        part trailer : Trailer;\n    }\n    \n    enum def ConnectionStatusType {\n        connected;\n        disconnected;\n    }\n}",
    "package VehicleTrailerSystem {\n    import ScalarValues::*;\n    \n    part def Vehicle {\n        part chassis : Chassis;\n        part towBall : TowBall;\n    }\n    \n    part def Trailer {\n        part trailerChassis : TrailerChassis;\n        part coupler : CouplerMechanism;\n    }\n    \n    part def Chassis {\n        attribute mass : Real;\n    }\n    \n    part def TrailerChassis {\n        attribute mass : Real;\n    }\n    \n    part def TowBall {\n        attribute diameter : Real;\n        attribute height : Real;\n    }\n    \n    part def CouplerMechanism {\n        attribute latchState : LatchStateType;\n        \n        action engage {\n            in towBall : TowBall;\n            out result : Boolean;\n        }\n        \n        action disengage {\n            out result : Boolean;\n        }\n    }\n    \n    enum def LatchStateType {\n        enum latched;\n        enum unlatched;\n    }\n    \n    connection def TowConnection {\n        end vehicle : Vehicle[1];\n        end trailer : Trailer[0..1];\n    }\n    \n    action def HitchOperation {\n        in vehicle : Vehicle;\n        in trailer : Trailer;\n        out connection : TowConnection;\n        \n        action connectCoupler {\n            in item coupler = trailer.coupler;\n            in item towBall = vehicle.towBall;\n            \n            perform coupler.engage(towBall);\n        }\n    }\n    \n    action def UnhitchOperation {\n        in connection : TowConnection;\n        \n        action disconnectCoupler {\n            in item coupler = connection.trailer.coupler;\n            \n            perform coupler.disengage();\n        }\n    }\n    \n    requirement def SecureConnection {\n        doc /* When connected, the trailer's coupler shall securely latch onto the vehicle's tow ball */\n        \n        subject connection : TowConnection;\n        \n        require constraint {\n            connection.trailer != null implies \n            connection.trailer.coupler.latchState == LatchStateType::latched\n        }\n    }\n    \n    requirement def SmoothDisconnection {\n        doc /* Disconnection shall allow the vehicle and trailer to separate smoothly */\n        \n        subject unhitchOp : UnhitchOperation;\n        \n        require constraint {\n            unhitchOp.connection.trailer.coupler.latchState == LatchStateType::unlatched\n        }\n    }\n}",
    "package FuelSystem {\n    import ScalarValues::*;\n    \n    part def FuelTankAssembly {\n        attribute capacity : Real;\n        port fuelSupplyPort : FuelFlowPort;\n        port fuelReturnPort : FuelFlowPort;\n    }\n    \n    part def Engine {\n        port fuelInletPort : FuelFlowPort;\n        port fuelReturnPort : FuelFlowPort;\n    }\n    \n    port def FuelFlowPort {\n        attribute flowRate : Real;\n        attribute temperature : Real;\n        attribute pressure : Real;\n    }\n    \n    interface def FuelFlowInterface {\n        end supplierPort : FuelFlowPort;\n        end consumerPort : FuelFlowPort;\n    }\n    \n    part def VehicleFuelSystem {\n        part fuelTank : FuelTankAssembly;\n        part engine : Engine;\n        \n        interface fuelSupplyInterface : FuelFlowInterface connect \n            supplierPort => fuelTank.fuelSupplyPort to\n            consumerPort => engine.fuelInletPort;\n            \n        interface fuelReturnInterface : FuelFlowInterface connect\n            supplierPort => engine.fuelReturnPort to\n            consumerPort => fuelTank.fuelReturnPort;\n            \n        requirement fuelCirculation {\n            doc /* Fuel shall circulate between fuel tank and engine */\n            require constraint { fuelSupplyInterface.supplierPort.flowRate > 0 }\n        }\n        \n        requirement temperatureMonitoring {\n            doc /* System shall monitor fuel temperature during flow */\n            require constraint { \n                fuelSupplyInterface.supplierPort.temperature >= 0 and\n                fuelSupplyInterface.supplierPort.temperature <= 100\n            }\n        }\n        \n        requirement systemReliability {\n            doc /* Fuel system shall maintain stable and reliable operation */\n            attribute reliabilityTarget : Real = 0.999;\n        }\n    }\n}",
    "package FuelDeliverySystem {\n    import ScalarValues::*;\n    \n    part def StorageTank {\n        attribute fuelLevel : Real;\n        attribute capacity : Real;\n        \n        port fuelOutlet : FuelPort;\n    }\n    \n    part def FuelPump {\n        attribute flowRate : Real;\n        attribute isActive : Boolean;\n        \n        port fuelInlet : FuelPort;\n        port fuelOutlet : FuelPort;\n    }\n    \n    part def VehicleFuelTank {\n        attribute currentFuelLevel : Real;\n        attribute maxCapacity : Real;\n        \n        port fuelInlet : FuelPort;\n        \n        action monitorFuelLevel {\n            doc /* Monitors fuel level in real-time */\n        }\n    }\n    \n    part def Vehicle {\n        part vehicleTank : VehicleFuelTank;\n    }\n    \n    port def FuelPort {\n        attribute fuelFlow : Real;\n    }\n    \n    part def FuelDeliverySystem {\n        part storageTank : StorageTank;\n        part fuelPump : FuelPump;\n        part vehicle : Vehicle;\n        \n        interface def FuelTransfer {\n            end source : FuelPort;\n            end target : FuelPort;\n            \n            flow of fuel from source to target;\n        }\n        \n        interface storageToPump : FuelTransfer connect \n            storageTank.fuelOutlet to fuelPump.fuelInlet;\n            \n        interface pumpToVehicle : FuelTransfer connect \n            fuelPump.fuelOutlet to vehicle.vehicleTank.fuelInlet;\n            \n        action deliverFuel {\n            first start;\n            then extractFuel;\n            then pumpFuel;\n            then fillVehicleTank;\n            then done;\n            \n            action extractFuel {\n                doc /* Extract fuel from storage tank */\n            }\n            \n            action pumpFuel {\n                doc /* Pump fuel through fuel pump */\n            }\n            \n            action fillVehicleTank {\n                doc /* Fill vehicle fuel tank */\n            }\n        }\n        \n        requirement efficientDelivery {\n            doc /* System shall provide efficient fuel delivery to vehicles */\n        }\n        \n        requirement fuelFlowControl {\n            doc /* Fuel flow path shall be clear and controllable */\n        }\n        \n        requirement timelyAccurateSafe {\n            doc /* System shall ensure timely, safe, and accurate fuel delivery */\n        }\n    }\n}",
    "package AutomobileAssemblyModel {\n    \n    part def VehicleAssembly {\n        attribute vin : String;\n        attribute assemblyStatus : String;\n    }\n    \n    part def Gearbox {\n        attribute serialNumber : String;\n        attribute type : String;\n        attribute functional : Boolean = true;\n    }\n    \n    part def Engine {\n        attribute serialNumber : String;\n        attribute displacement : Real;\n        attribute functional : Boolean = true;\n    }\n    \n    part def AssemblyWithoutEngine :> VehicleAssembly {\n        part gearbox : Gearbox;\n    }\n    \n    part def FullyAssembledVehicle :> VehicleAssembly {\n        part gearbox : Gearbox;\n        part engine : Engine;\n        \n        attribute powerDeliveryCapable : Boolean = gearbox.functional and engine.functional;\n    }\n    \n    action def InstallGearbox {\n        in vehicleAssembly : VehicleAssembly;\n        in gearbox : Gearbox;\n        out assemblyWithGearbox : AssemblyWithoutEngine;\n        \n        bind assemblyWithGearbox.gearbox = gearbox;\n        bind assemblyWithGearbox.vin = vehicleAssembly.vin;\n        bind assemblyWithGearbox.assemblyStatus = \"Gearbox Installed\";\n    }\n    \n    action def InstallEngine {\n        in assemblyWithGearbox : AssemblyWithoutEngine;\n        in engine : Engine;\n        out fullyAssembledVehicle : FullyAssembledVehicle;\n        \n        bind fullyAssembledVehicle.gearbox = assemblyWithGearbox.gearbox;\n        bind fullyAssembledVehicle.engine = engine;\n        bind fullyAssembledVehicle.vin = assemblyWithGearbox.vin;\n        bind fullyAssembledVehicle.assemblyStatus = \"Fully Assembled\";\n    }\n    \n    action def FinalAssemblyProcess {\n        in initialVehicleAssembly : VehicleAssembly;\n        in gearboxUnit : Gearbox;\n        in engineUnit : Engine;\n        out completeVehicle : FullyAssembledVehicle;\n        \n        action installGearboxStep : InstallGearbox {\n            in vehicleAssembly = initialVehicleAssembly;\n            in gearbox = gearboxUnit;\n        }\n        \n        flow installGearboxStep.assemblyWithGearbox to installEngineStep.assemblyWithGearbox;\n        \n        action installEngineStep : InstallEngine {\n            in engine = engineUnit;\n        }\n        \n        flow installEngineStep.fullyAssembledVehicle to completeVehicle;\n        \n        assert constraint {\n            doc /* Assembly sequence must be maintained: gearbox before engine */\n            installGearboxStep happens before installEngineStep\n        }\n    }\n    \n    requirement def AssemblySequenceRequirement {\n        doc /* The gearbox must be installed before the engine */\n        subject finalAssembly : FinalAssemblyProcess;\n        require constraint {\n            finalAssembly.installGearboxStep happens before finalAssembly.installEngineStep\n        }\n    }\n    \n    requirement def ComponentFunctionalityRequirement {\n        doc /* The fully assembled vehicle must have functional gearbox and engine units */\n        subject vehicle : FullyAssembledVehicle;\n        require constraint {\n            vehicle.gearbox.functional == true and vehicle.engine.functional == true\n        }\n    }\n    \n    requirement def AssemblyIntegrityRequirement {\n        doc /* Each assembly step must have clear inputs and outputs */\n        subject process : FinalAssemblyProcess;\n        require constraint {\n            process.initialVehicleAssembly != null and\n            process.gearboxUnit != null and\n            process.engineUnit != null and\n            process.completeVehicle != null\n        }\n    }\n}",
    "package VehicleControlSystem {\n    import ScalarValues::*;\n    \n    part def VehicleA {\n        attribute temperature : Real;\n        attribute safetyThreshold : Real = 85.0;\n        \n        port brakePedalInput : ~BrakePedalSignal;\n        port startSignalInput : ~StartSignal;\n        port vehicleOnSignalInput : ~VehicleOnSignal;\n        port restoreSignalInput : ~RestoreSignal;\n        port temperatureSensor : ~TemperatureReading;\n        port overTempSignalOutput : OverTempSignal;\n        port powerSupplyOutput : PowerSupply;\n        port parkingBrakeOutput : ParkingBrake;\n        \n        exhibit state vehicleStates {\n            entry state off;\n            state starting;\n            state running {\n                entry action {\n                    perform selfCheck;\n                    send powerSupplyOutput;\n                }\n                exit action {\n                    send parkingBrakeOutput;\n                }\n            }\n            \n            transition off_to_starting : off --> starting\n                when brakePedalInput & startSignalInput;\n            \n            transition starting_to_running : starting --> running\n                when vehicleOnSignalInput;\n            \n            transition running_to_off : running --> off;\n        }\n        \n        exhibit state healthStates parallel {\n            state normal;\n            state degraded {\n                entry action {\n                    send overTempSignalOutput;\n                }\n            }\n            state maintenance;\n            \n            transition normal_to_degraded : normal --> degraded\n                when temperature > safetyThreshold;\n            \n            transition degraded_to_normal : degraded --> normal\n                when restoreSignalInput;\n            \n            transition maintenance_to_normal : maintenance --> normal\n                when restoreSignalInput;\n        }\n        \n        action selfCheck;\n        \n        constraint temperatureMonitoring {\n            temperature == temperatureSensor.value\n        }\n    }\n    \n    part def VehicleController {\n        port startupSignalInput : ~StartupSignal;\n        port shutdownSignalInput : ~ShutdownSignal;\n        port vehicleControlOutput : VehicleControlSignal;\n        \n        exhibit state controllerStates {\n            state idle;\n            state active;\n            \n            transition idle_to_active : idle --> active\n                when startupSignalInput;\n            \n            transition active_to_idle : active --> idle\n                when shutdownSignalInput;\n        }\n    }\n    \n    interface def BrakePedalSignal;\n    interface def StartSignal;\n    interface def VehicleOnSignal;\n    interface def RestoreSignal;\n    interface def TemperatureReading {\n        attribute value : Real;\n    }\n    interface def OverTempSignal;\n    interface def PowerSupply;\n    interface def ParkingBrake;\n    interface def StartupSignal;\n    interface def ShutdownSignal;\n    interface def VehicleControlSignal;\n    \n    part vehicleSystem : VehicleControlSystem {\n        part vehicle : VehicleA;\n        part controller : VehicleController;\n        \n        interface : VehicleControlInterface connect controller.vehicleControlOutput to vehicle.startSignalInput;\n    }\n    \n    interface def VehicleControlInterface;\n}",
    "package VehicleSystem {\n    import ScalarValues::*;\n    \n    attribute def Temperature;\n    attribute def FuelLevel;\n    attribute def MaintenanceInterval;\n    \n    enum def VehicleState {\n        enum shutdown;\n        enum starting;\n        enum running;\n        enum degraded;\n        enum maintenance;\n    }\n    \n    enum def SignalType {\n        enum startSignal;\n        enum warningSignal;\n        enum shutdownSignal;\n    }\n    \n    part def Vehicle {\n        attribute currentState : VehicleState = VehicleState::shutdown;\n        attribute temperature : Temperature;\n        attribute fuel : FuelLevel;\n        attribute maintenanceInterval : MaintenanceInterval;\n        attribute brakePedalPressed : Boolean = false;\n        attribute startSignalReceived : Boolean = false;\n        attribute isOverheating : Boolean = false;\n        \n        port controlPort {\n            in item startCommand;\n            in item shutdownCommand;\n            out item warningSignal;\n            out item statusSignal;\n        }\n        \n        action selfInspection {\n            doc /* Performs vehicle self-inspection */\n        }\n        \n        action powerSupply {\n            doc /* Manages power supply procedures */\n        }\n        \n        action performMaintenance {\n            doc /* Executes maintenance procedures */\n        }\n        \n        action recoverFromFault {\n            doc /* Recovers from fault conditions */\n        }\n        \n        state vehicleStates {\n            entry state shutdown;\n            state starting;\n            state running;\n            state degraded;\n            state maintenance;\n            \n            transition shutdown_to_starting\n                first shutdown\n                accept controlPort.startCommand\n                if brakePedalPressed and startSignalReceived\n                do selfInspection then powerSupply\n                then starting;\n                \n            transition starting_to_running\n                first starting\n                then running;\n                \n            transition running_to_degraded\n                first running\n                if isOverheating\n                do send warningSignal via controlPort\n                then degraded;\n                \n            transition degraded_to_maintenance\n                first degraded\n                then maintenance;\n                \n            transition maintenance_to_running\n                first maintenance\n                do performMaintenance then recoverFromFault\n                then running;\n                \n            transition any_to_shutdown\n                first running, degraded, maintenance\n                accept controlPort.shutdownCommand\n                then shutdown;\n        }\n    }\n    \n    part def VehicleController {\n        port vehiclePort {\n            out item startCommand;\n            out item shutdownCommand;\n            in item warningSignal;\n            in item statusSignal;\n        }\n        \n        action processControlSignal {\n            in signal : SignalType;\n            doc /* Processes control signals */\n        }\n        \n        action processStatusSignal {\n            in status : VehicleState;\n            doc /* Processes vehicle status signals */\n        }\n        \n        action sendStartCommand {\n            doc /* Sends start command to vehicle */\n            send startCommand via vehiclePort;\n        }\n        \n        action sendShutdownCommand {\n            doc /* Sends shutdown command to vehicle */\n            send shutdownCommand via vehiclePort;\n        }\n    }\n    \n    part vehicleSystem {\n        part vehicle : Vehicle;\n        part controller : VehicleController;\n        \n        interface vehicleControlInterface connect \n            vehicle.controlPort to controller.vehiclePort;\n            \n        action monitorTemperature {\n            doc /* Continuously monitors vehicle temperature */\n            loop {\n                if vehicle.temperature > temperatureThreshold {\n                    vehicle.isOverheating := true;\n                }\n            }\n        }\n        \n        attribute temperatureThreshold : Temperature;\n        \n        requirement startupRequirement {\n            doc /* Vehicle shall only start when brake pedal is pressed and start signal is received */\n            verify vehicle.currentState == VehicleState::starting \n                implies (vehicle.brakePedalPressed and vehicle.startSignalReceived);\n        }\n        \n        requirement safetyRequirement {\n            doc /* Vehicle shall enter degraded mode when overheating is detected */\n            verify vehicle.isOverheating \n                implies vehicle.currentState == VehicleState::degraded;\n        }\n        \n        requirement maintenanceRequirement {\n            doc /* Vehicle shall support regular maintenance and fault recovery */\n            verify vehicle.currentState == VehicleState::maintenance \n                implies eventually vehicle.currentState == VehicleState::running;\n        }\n    }\n}",
    "package VehicleDynamicsSimulation {\n    import ScalarValues::*;\n    import Quantities::*;\n    import MeasurementReferences::*;\n    import Time::*;\n    import SpaceTime::*;\n    \n    enum def VehicleStateKind {\n        enum on;\n        enum off;\n        enum driving;\n    }\n    \n    attribute def Mass :> MassValue;\n    attribute def Position :> LengthValue;\n    attribute def Velocity :> SpeedValue;\n    attribute def Acceleration :> AccelerationValue;\n    attribute def Angle :> PlaneAngleValue;\n    attribute def FrictionCoefficient :> Real;\n    \n    item def Vehicle {\n        attribute mass : Mass;\n        attribute position : Position[3];\n        attribute velocity : Velocity[3];\n        attribute acceleration : Acceleration[3];\n        attribute currentState : VehicleStateKind;\n        \n        port vehicleStatePort : VehicleStatePort;\n    }\n    \n    item def Road {\n        attribute slope : Angle;\n        attribute frictionCoefficient : FrictionCoefficient;\n        attribute length : Position;\n        \n        port roadConditionPort : RoadConditionPort;\n    }\n    \n    port def VehicleStatePort {\n        out attribute vehiclePosition : Position[3];\n        out attribute vehicleVelocity : Velocity[3];\n        out attribute vehicleAcceleration : Acceleration[3];\n        out attribute vehicleState : VehicleStateKind;\n    }\n    \n    port def RoadConditionPort {\n        out attribute roadSlope : Angle;\n        out attribute roadFriction : FrictionCoefficient;\n    }\n    \n    attribute def SimulationSnapshot {\n        attribute timeStamp : TimeInstantValue;\n        attribute vehicleState : VehicleStateKind;\n        attribute vehiclePosition : Position[3];\n        attribute vehicleVelocity : Velocity[3];\n        attribute vehicleAcceleration : Acceleration[3];\n        attribute roadSlope : Angle;\n        attribute roadFriction : FrictionCoefficient;\n    }\n    \n    part def SpatiotemporalSimulationSystem {\n        part vehicle : Vehicle;\n        part road : Road;\n        \n        attribute simulationStartTime : TimeInstantValue;\n        attribute simulationEndTime : TimeInstantValue;\n        attribute simulationTimeStep : DurationValue;\n        attribute snapshots : SimulationSnapshot[*] ordered;\n        \n        interface vehicleRoadInterface connect vehicle.vehicleStatePort to road.roadConditionPort;\n        \n        action simulateVehicleDynamics {\n            in startTime : TimeInstantValue;\n            in endTime : TimeInstantValue;\n            in timeStep : DurationValue;\n            out snapshotSeries : SimulationSnapshot[*];\n            \n            action startVehicle {\n                assign vehicle.currentState := VehicleStateKind::on;\n            }\n            \n            action updateVehicleState {\n                in currentTime : TimeInstantValue;\n                in roadSlope : Angle;\n                in roadFriction : FrictionCoefficient;\n                \n                assign vehicle.currentState := VehicleStateKind::driving;\n            }\n            \n            action shutdownVehicle {\n                assign vehicle.currentState := VehicleStateKind::off;\n            }\n            \n            action recordSnapshot {\n                in time : TimeInstantValue;\n                out snapshot : SimulationSnapshot;\n            }\n        }\n        \n        requirement trackStateTransitions {\n            doc /* The system shall track vehicle state transitions from on through driving to off */\n        }\n        \n        requirement multipleSnapshots {\n            doc /* The system shall support recording snapshots at multiple time points */\n        }\n        \n        requirement vehicleDynamicsAnalysis {\n            doc /* The system shall provide detailed data for vehicle dynamics analysis */\n        }\n        \n        requirement roadAdaptabilityAssessment {\n            doc /* The system shall support road adaptability assessment */\n        }\n        \n        requirement virtualEnvironmentPrediction {\n            doc /* The system shall enable performance prediction in virtual environment */\n        }\n    }\n}",
    "package AutomotiveConfigurationSystem {\n    \n    part def Component1;\n    part def Component2;\n    part def Component3;\n    part def Component4;\n    part def Component5;\n    part def Component6;\n    \n    part def SubsystemA {\n        variant part config1 {\n            part c1 : Component1;\n            part c2 : Component2;\n        }\n        variant part config2 {\n            part c2 : Component2;\n            part c3 : Component3;\n        }\n    }\n    \n    part def SubsystemB {\n        variant part config1 {\n            part c4 : Component4;\n            part c5 : Component5;\n        }\n        variant part config2 {\n            part c5 : Component5;\n            part c6 : Component6;\n        }\n    }\n    \n    part def Automobile {\n        part subsystemA : SubsystemA[0..1];\n        part subsystemB : SubsystemB[0..1];\n        \n        constraint configurationConstraint {\n            (subsystemA.config2 == null) or (subsystemB.config1 != null)\n        }\n    }\n    \n    part configurationA : Automobile {\n        part :>> subsystemA {\n            part :>> config1;\n        }\n        part :>> subsystemB {\n            part :>> config1;\n        }\n    }\n    \n    part configurationB : Automobile {\n        part :>> subsystemA {\n            part :>> config2;\n        }\n        part :>> subsystemB {\n            part :>> config1;\n        }\n    }\n}",
    "package VehicleConfigurationSystem {\n    \n    // Base component definitions\n    part def Part1;\n    part def Part2;\n    part def Part3 {\n        port p1;\n    }\n    part def Part4;\n    part def Part5 {\n        port p2;\n        variant behavior behaviorVariant1;\n        variant behavior behaviorVariant2;\n    }\n    part def Part6;\n    \n    // Abstract subsystem definitions\n    abstract part def SubsystemA {\n        port portA;\n    }\n    \n    abstract part def SubsystemB {\n        port portB;\n    }\n    \n    // Subsystem A variants\n    part def SubsystemA_Variant1 :> SubsystemA {\n        part component1 : Part1;\n        part component2 : Part2;\n        part component3 : Part3;\n    }\n    \n    part def SubsystemA_Variant2 :> SubsystemA {\n        part component1 : Part1;\n        part component3 : Part3;\n        part component4 : Part4;\n    }\n    \n    // Subsystem B variants\n    part def SubsystemB_Variant1 :> SubsystemB {\n        part component5 : Part5;\n        part component6 : Part6;\n    }\n    \n    part def SubsystemB_Variant2 :> SubsystemB {\n        part component4 : Part4;\n        part component5 : Part5;\n    }\n    \n    // Vehicle platform definition\n    part def VehiclePlatform {\n        part subsystemA : SubsystemA;\n        part subsystemB : SubsystemB;\n        \n        interface : subsystemA.portA to subsystemB.portB;\n    }\n    \n    // Configuration definitions\n    part def VehicleConfigA :> VehiclePlatform {\n        part :>> subsystemA : SubsystemA_Variant1;\n        part :>> subsystemB : SubsystemB_Variant1;\n    }\n    \n    part def VehicleConfigB :> VehiclePlatform {\n        part :>> subsystemA : SubsystemA_Variant2;\n        part :>> subsystemB : SubsystemB_Variant2;\n    }\n    \n    // Constraints\n    constraint def ConfigurationConsistency {\n        doc /* Ensures configuration consistency and rationality */\n    }\n    \n    // Variation points\n    variation part def ConfigurableVehicle :> VehiclePlatform {\n        variant part :>> subsystemA {\n            variant : SubsystemA_Variant1;\n            variant : SubsystemA_Variant2;\n        }\n        variant part :>> subsystemB {\n            variant : SubsystemB_Variant1;\n            variant : SubsystemB_Variant2;\n        }\n    }\n}",
    "package VehicleProductLineConfiguration {\n    \n    import ScalarValues::*;\n    \n    // Part definitions for vehicle components\n    part def Engine {\n        attribute cylinders : Integer;\n        attribute powerOutput : Real;\n    }\n    \n    part def Transmission {\n        attribute type : String;\n        attribute gearCount : Integer;\n    }\n    \n    part def Wheel {\n        attribute rimType : String;\n        attribute width : Real;\n    }\n    \n    part def Vehicle {\n        part engine : Engine;\n        part transmission : Transmission;\n        part wheels : Wheel[4];\n        \n        attribute performanceLevel : String;\n        attribute modelVariant : String;\n    }\n    \n    // Specific component variants\n    part def SixCylinderEngine :> Engine {\n        attribute :>> cylinders = 6;\n        attribute :>> powerOutput = 300.0;\n    }\n    \n    part def FourCylinderEngine :> Engine {\n        attribute :>> cylinders = 4;\n        attribute :>> powerOutput = 150.0;\n    }\n    \n    part def AutomaticTransmission :> Transmission {\n        attribute :>> type = \"Automatic\";\n        attribute :>> gearCount = 8;\n    }\n    \n    part def ManualTransmission :> Transmission {\n        attribute :>> type = \"Manual\";\n        attribute :>> gearCount = 6;\n    }\n    \n    part def WideRimWheel :> Wheel {\n        attribute :>> rimType = \"Wide\";\n        attribute :>> width = 255.0;\n    }\n    \n    part def NarrowRimWheel :> Wheel {\n        attribute :>> rimType = \"Narrow\";\n        attribute :>> width = 195.0;\n    }\n    \n    // Configuration constraints\n    constraint def HighPerformanceConfiguration {\n        doc /* High performance requires 6-cylinder engine, automatic transmission, and wide wheels */\n        \n        in vehicle : Vehicle;\n        \n        vehicle.performanceLevel == \"High\" implies (\n            vehicle.engine istype SixCylinderEngine and\n            vehicle.transmission istype AutomaticTransmission and\n            vehicle.wheels->forAll(w | w istype WideRimWheel)\n        )\n    }\n    \n    constraint def StandardPerformanceConfiguration {\n        doc /* Standard performance requires 4-cylinder engine, manual transmission, and narrow wheels */\n        \n        in vehicle : Vehicle;\n        \n        vehicle.performanceLevel == \"Standard\" implies (\n            vehicle.engine istype FourCylinderEngine and\n            vehicle.transmission istype ManualTransmission and\n            vehicle.wheels->forAll(w | w istype NarrowRimWheel)\n        )\n    }\n    \n    constraint def ComponentCompatibility {\n        doc /* Ensures compatibility between engine and transmission */\n        \n        in vehicle : Vehicle;\n        \n        (vehicle.engine istype SixCylinderEngine implies \n            vehicle.transmission istype AutomaticTransmission) and\n        (vehicle.engine istype FourCylinderEngine implies \n            vehicle.transmission istype ManualTransmission)\n    }\n    \n    // Use case for configuration selection\n    use case def ConfigureVehicle {\n        subject vehicle : Vehicle;\n        \n        objective {\n            doc /* Configure vehicle based on performance requirements and user preferences */\n        }\n        \n        include selectPerformanceLevel;\n        include selectModelVariant;\n        include validateConfiguration;\n    }\n    \n    use case selectPerformanceLevel {\n        doc /* User selects desired performance level */\n    }\n    \n    use case selectModelVariant {\n        doc /* User selects vehicle model variant */\n    }\n    \n    use case validateConfiguration {\n        doc /* System validates component compatibility */\n    }\n    \n    // Requirement definitions\n    requirement def FlexibleConfiguration {\n        doc /* System shall provide flexible solutions for vehicle product line configuration */\n        \n        subject vehicle : Vehicle;\n    }\n    \n    requirement def AutomaticMatching {\n        doc /* System shall automatically match suitable combinations based on requirements */\n        \n        subject vehicle : Vehicle;\n        \n        require constraint HighPerformanceConfiguration;\n        require constraint StandardPerformanceConfiguration;\n    }\n    \n    requirement def MarketResponsiveness {\n        doc /* System shall enable quick response to market demands */\n        \n        subject vehicle : Vehicle;\n        \n        assume {\n            doc /* Multiple model variants are available */\n            vehicle.modelVariant in [\"Sedan\", \"SUV\", \"Coupe\", \"Hatchback\"]\n        }\n    }\n    \n    // Analysis context\n    analysis def ProductLineAnalysis {\n        subject vehicleProductLine : Vehicle[*];\n        \n        return configurationsCount = vehicleProductLine->size();\n        return highPerformanceCount = vehicleProductLine->select(v | v.performanceLevel == \"High\")->size();\n        return standardPerformanceCount = vehicleProductLine->select(v | v.performanceLevel == \"Standard\")->size();\n    }\n}",
    "package VehicleManagementSystem {\n    import ScalarValues::*;\n    import Quantities::*;\n    import MeasurementReferences::*;\n    import ISQ::*;\n    \n    // Attribute definitions\n    attribute def MassValue :> MassValue;\n    attribute def TorqueValue :> TorqueValue;\n    attribute def ReliabilityValue :> Real;\n    \n    // Enumeration for fuel status\n    enum def FuelStatus {\n        enum fullFuel;\n        enum emptyFuel;\n    }\n    \n    // Enumeration for mass grades\n    enum def MassGrade {\n        enum grade2000kg;\n        enum grade2500kg;\n    }\n    \n    // Part definitions\n    part def Vehicle {\n        attribute actualMass : MassValue;\n        attribute massGrade : MassGrade;\n        attribute fuelStatus : FuelStatus;\n        attribute maxMassLimit : MassValue;\n        \n        part engine : Engine;\n        part transmission : Transmission;\n        \n        interface driveInterface : DriveInterface\n            connect engine.torqueOutput to transmission.torqueInput;\n    }\n    \n    part def Engine {\n        attribute outputTorque : TorqueValue;\n        port torqueOutput : TorquePort;\n    }\n    \n    part def Transmission {\n        port torqueInput : TorquePort;\n    }\n    \n    // Port definition\n    port def TorquePort {\n        attribute torque : TorqueValue;\n    }\n    \n    // Interface definition\n    interface def DriveInterface {\n        end engineSide : TorquePort;\n        end transmissionSide : TorquePort;\n    }\n    \n    // Requirements\n    requirement def VehicleSpecifications {\n        doc /* This requirement defines the primary specifications for vehicles */\n        \n        requirement massManagement {\n            doc /* Vehicle mass must be managed according to grade and fuel status */\n            subject vehicle : Vehicle;\n            \n            requirement massGradeCompliance {\n                doc /* Vehicle must comply with assigned mass grade */\n                require constraint {\n                    (vehicle.massGrade == MassGrade::grade2000kg) implies \n                    (vehicle.maxMassLimit == 2000[kg])\n                    and\n                    (vehicle.massGrade == MassGrade::grade2500kg) implies \n                    (vehicle.maxMassLimit == 2500[kg])\n                }\n            }\n            \n            requirement overloadPrevention {\n                doc /* Vehicle actual mass must not exceed maximum limit */\n                require constraint {\n                    vehicle.actualMass <= vehicle.maxMassLimit\n                }\n            }\n        }\n        \n        requirement fuelStatusManagement {\n            doc /* Fuel status requirements for different vehicle configurations */\n            subject vehicle : Vehicle;\n            \n            requirement fuelMassCompliance {\n                doc /* Mass requirements based on fuel status */\n                require constraint {\n                    (vehicle.fuelStatus == FuelStatus::fullFuel) implies\n                    (vehicle.actualMass <= vehicle.maxMassLimit)\n                }\n            }\n        }\n    }\n    \n    requirement def PowertrainRequirements {\n        doc /* Requirements for vehicle powertrain functionality */\n        subject vehicle : Vehicle;\n        \n        requirement powerDelivery {\n            doc /* Engine must deliver torque through transmission */\n            require constraint {\n                vehicle.engine.outputTorque > 0[N*m]\n            }\n        }\n        \n        requirement driveInterfaceConnection {\n            doc /* Engine and transmission must be effectively connected */\n            require constraint {\n                vehicle.driveInterface != null\n            }\n        }\n    }\n    \n    requirement def ReliabilityRequirements {\n        doc /* Vehicle reliability and durability requirements */\n        subject vehicle : Vehicle;\n        attribute targetReliability : ReliabilityValue;\n        \n        requirement lifecyclePerformance {\n            doc /* Vehicle must maintain specified performance throughout lifecycle */\n            attribute measuredReliability : ReliabilityValue;\n            require constraint {\n                measuredReliability >= targetReliability\n            }\n        }\n    }\n    \n    // Verification cases\n    verification def MassVerification {\n        subject vehicleUnderTest : Vehicle;\n        objective {\n            doc /* Verify vehicle mass compliance */\n        }\n        \n        verify requirement VehicleSpecifications::massManagement::overloadPrevention;\n    }\n    \n    verification def PowertrainVerification {\n        subject vehicleUnderTest : Vehicle;\n        objective {\n            doc /* Verify powertrain functionality */\n        }\n        \n        verify requirement PowertrainRequirements::powerDelivery;\n        verify requirement PowertrainRequirements::driveInterfaceConnection;\n    }\n}",
    "package VehicleMassComplianceSystem {\n    import ScalarValues::*;\n    import Quantities::*;\n    import MeasurementReferences::*;\n    import ISQ::*;\n    \n    attribute def MassValue :> ScalarQuantityValue {\n        attribute num : Real;\n        attribute mRef : MassUnit;\n    }\n    \n    attribute def ComplianceStatus {\n        attribute isCompliant : Boolean;\n    }\n    \n    item def Vehicle {\n        attribute actualMass : MassValue;\n        attribute vehicleID : String;\n    }\n    \n    item def WeighingEquipment {\n        attribute equipmentID : String;\n        attribute accuracy : MassValue;\n    }\n    \n    actor def TestOperator {\n        attribute operatorID : String;\n        attribute name : String;\n    }\n    \n    requirement def MaxPermissibleMassRequirement {\n        doc /* The vehicle mass shall not exceed the maximum permissible mass */\n        attribute maxPermissibleMass : MassValue = MassValue(num = 2500.0, mRef = kg);\n        \n        require constraint {\n            doc /* Vehicle actual mass must be less than or equal to maximum permissible mass */\n        }\n    }\n    \n    action def MeasureVehicleMass {\n        in vehicle : Vehicle;\n        in equipment : WeighingEquipment;\n        in operator : TestOperator;\n        out measuredMass : MassValue;\n        \n        action useEquipment {\n            doc /* Operator uses weighing equipment to measure vehicle mass */\n        }\n        \n        action recordMeasurement {\n            doc /* Record the measured mass value */\n        }\n        \n        flow from useEquipment.done to recordMeasurement.start;\n    }\n    \n    action def VerifyMassCompliance {\n        in measuredMass : MassValue;\n        in requirement : MaxPermissibleMassRequirement;\n        out status : ComplianceStatus;\n        \n        action compareMass {\n            doc /* Compare measured mass with maximum permissible mass */\n            bind status.isCompliant = (measuredMass.num <= requirement.maxPermissibleMass.num);\n        }\n    }\n    \n    action def TestVehicleCompliance {\n        in vehicle : Vehicle;\n        in equipment : WeighingEquipment;\n        in operator : TestOperator;\n        in requirement : MaxPermissibleMassRequirement;\n        out result : ComplianceStatus;\n        \n        action measure : MeasureVehicleMass {\n            in vehicle = TestVehicleCompliance::vehicle;\n            in equipment = TestVehicleCompliance::equipment;\n            in operator = TestVehicleCompliance::operator;\n        }\n        \n        action verify : VerifyMassCompliance {\n            in measuredMass = measure.measuredMass;\n            in requirement = TestVehicleCompliance::requirement;\n        }\n        \n        flow from measure.done to verify.start;\n        bind result = verify.status;\n    }\n    \n    part def VehicleMassComplianceSystemContext {\n        part vehicles : Vehicle[1..*];\n        part weighingEquipment : WeighingEquipment;\n        part testOperator : TestOperator;\n        part massRequirement : MaxPermissibleMassRequirement;\n        \n        perform testSequence : TestVehicleCompliance[1..*] {\n            doc /* Sequential testing of multiple vehicles */\n        }\n    }\n}",
    "package WaterSupplySystem {\n    import ScalarValues::*;\n    \n    // Define water flow interface\n    interface def WaterFlow {\n        attribute temperature : Real;\n        attribute flowRate : Real;\n        attribute pressure : Real;\n    }\n    \n    // Define port definitions\n    port def WaterOutlet {\n        out waterFlow : WaterFlow;\n    }\n    \n    port def WaterInlet {\n        in waterFlow : WaterFlow;\n    }\n    \n    // Define parts\n    part def SpigotBank {\n        port hotWaterOut : WaterOutlet;\n        port coldWaterOut : WaterOutlet;\n        \n        attribute mainSupplyPressure : Real;\n    }\n    \n    part def Spigot {\n        port waterIn : WaterInlet;\n        port waterOut : WaterOutlet;\n        \n        attribute isHot : Boolean;\n    }\n    \n    part def FaucetInlet {\n        port waterIn : WaterInlet;\n        \n        attribute inletType : String;\n    }\n    \n    part def Faucet {\n        part hotInlet : FaucetInlet {\n            attribute :>> inletType = \"hot\";\n        }\n        part coldInlet : FaucetInlet {\n            attribute :>> inletType = \"cold\";\n        }\n        \n        attribute location : String;\n    }\n    \n    // Define the main system\n    part def WaterSupplyNetwork {\n        part spigotBank : SpigotBank;\n        part hotSpigot : Spigot {\n            attribute :>> isHot = true;\n        }\n        part coldSpigot : Spigot {\n            attribute :>> isHot = false;\n        }\n        part faucets : Faucet[1..*];\n        \n        // Interface connections\n        interface hotWaterSupply : WaterFlow connect \n            spigotBank.hotWaterOut to hotSpigot.waterIn;\n            \n        interface coldWaterSupply : WaterFlow connect \n            spigotBank.coldWaterOut to coldSpigot.waterIn;\n            \n        interface hotDistribution : WaterFlow connect \n            hotSpigot.waterOut to faucets.hotInlet.waterIn;\n            \n        interface coldDistribution : WaterFlow connect \n            coldSpigot.waterOut to faucets.coldInlet.waterIn;\n    }\n    \n    // Requirements\n    requirement def ReliableDelivery {\n        doc /* System shall reliably deliver hot and cold water from main supply \n             to all downstream faucets */\n        subject waterSystem : WaterSupplyNetwork;\n        \n        require constraint {\n            waterSystem.spigotBank.mainSupplyPressure > 0\n        }\n    }\n    \n    requirement def SimultaneousSupply {\n        doc /* System shall ensure simultaneous supply to multiple water usage points */\n        subject waterSystem : WaterSupplyNetwork;\n        \n        require constraint {\n            waterSystem.faucets->size() >= 1\n        }\n    }\n    \n    requirement def CorrectConnection {\n        doc /* System must guarantee correct connection of hot and cold water pipelines */\n        subject waterSystem : WaterSupplyNetwork;\n        \n        require constraint {\n            waterSystem.hotSpigot.isHot == true and\n            waterSystem.coldSpigot.isHot == false\n        }\n    }\n}",
    "<scratchpad>\nKey functional/non-functional information extracted:\n1. System purpose: Model and analyze quality attributes of vehicles\n2. Components: Vehicle (whole), Engine, Transmission, Front Axle Assembly, Rear Axle Assembly\n3. Key attribute: Mass/quality data for each component\n4. Functions:\n   - Input quality data for components\n   - Aggregate and calculate total vehicle mass\n   - Define quality analysis requirements\n   - Formulate analysis use cases\n   - Generate analysis tasks and plans based on objectives\n   - Evaluate and track requirements\n   - Support vehicle design and performance optimization\n\nMapping to SysML v2:\n- Package for organization\n- Part definitions for vehicle and components\n- Attributes for mass/quality\n- Requirements for quality analysis\n- Use cases for analysis scenarios\n- Analysis cases for quality evaluation\n- Calculations for mass aggregation\n- Connections between parts\n</scratchpad>\n\npackage VehicleQualityAnalysisSystem {\n    import ScalarValues::*;\n    import ISQ::*;\n    import SI::*;\n    \n    attribute def QualityData {\n        attribute mass : MassValue;\n        attribute qualityScore : Real;\n        attribute timestamp : String;\n    }\n    \n    part def Engine {\n        attribute qualityData : QualityData;\n    }\n    \n    part def Transmission {\n        attribute qualityData : QualityData;\n    }\n    \n    part def FrontAxleAssembly {\n        attribute qualityData : QualityData;\n    }\n    \n    part def RearAxleAssembly {\n        attribute qualityData : QualityData;\n    }\n    \n    part def Vehicle {\n        part engine : Engine;\n        part transmission : Transmission;\n        part frontAxle : FrontAxleAssembly;\n        part rearAxle : RearAxleAssembly;\n        \n        attribute totalMass : MassValue = \n            engine.qualityData.mass + \n            transmission.qualityData.mass + \n            frontAxle.qualityData.mass + \n            rearAxle.qualityData.mass;\n            \n        attribute overallQualityScore : Real;\n    }\n    \n    requirement def QualityAnalysisRequirement {\n        doc /* Quality analysis requirements for vehicle and components */\n        attribute targetMass : MassValue;\n        attribute minQualityScore : Real;\n    }\n    \n    requirement vehicleQualityReq : QualityAnalysisRequirement {\n        doc /* Overall vehicle quality requirements */\n        targetMass = 1500[kg];\n        minQualityScore = 0.85;\n    }\n    \n    use case def QualityAnalysisUseCase {\n        subject vehicle : Vehicle;\n        objective {\n            doc /* Analyze quality attributes and generate evaluation */\n        }\n    }\n    \n    use case inputComponentData : QualityAnalysisUseCase {\n        doc /* Input quality data for each component */\n    }\n    \n    use case calculateTotalMass : QualityAnalysisUseCase {\n        doc /* Aggregate and calculate total vehicle mass */\n    }\n    \n    use case generateAnalysisPlan : QualityAnalysisUseCase {\n        doc /* Generate analysis tasks and plans based on objectives */\n    }\n    \n    analysis def QualityEvaluation {\n        subject vehicle : Vehicle;\n        objective {\n            doc /* Comprehensive evaluation of vehicle quality */\n        }\n        \n        return massCompliance : Boolean = vehicle.totalMass <= vehicleQualityReq.targetMass;\n        return qualityCompliance : Boolean = vehicle.overallQualityScore >= vehicleQualityReq.minQualityScore;\n    }\n    \n    analysis vehicleQualityAnalysis : QualityEvaluation {\n        subject vehicle : Vehicle;\n    }\n    \n    part vehicleInstance : Vehicle {\n        part engine {\n            :>> qualityData {\n                mass = 200[kg];\n                qualityScore = 0.9;\n            }\n        }\n        part transmission {\n            :>> qualityData {\n                mass = 150[kg];\n                qualityScore = 0.88;\n            }\n        }\n        part frontAxle {\n            :>> qualityData {\n                mass = 300[kg];\n                qualityScore = 0.87;\n            }\n        }\n        part rearAxle {\n            :>> qualityData {\n                mass = 350[kg];\n                qualityScore = 0.86;\n            }\n        }\n    }\n}",
    "package PowertrainOptimizationSystem {\n    import ScalarValues::*;\n    import Quantities::*;\n    import MeasurementReferences::*;\n    import ISQ::*;\n    \n    // Define attributes for performance indicators\n    attribute def PowerAttribute :> ScalarQuantityValue {\n        attribute quantityDimension = ISQ::power;\n    }\n    \n    attribute def MassAttribute :> ScalarQuantityValue {\n        attribute quantityDimension = ISQ::mass;\n    }\n    \n    attribute def EfficiencyAttribute :> Real;\n    \n    attribute def ReliabilityAttribute :> Real {\n        assert constraint { 0.0 <= self <= 1.0 }\n    }\n    \n    attribute def CostAttribute :> ScalarQuantityValue {\n        attribute quantityDimension = ISQ::currency;\n    }\n    \n    // Component definitions\n    part def Cylinder {\n        attribute bore :> LengthValue;\n        attribute stroke :> LengthValue;\n        attribute compressionRatio :> Real;\n    }\n    \n    part def Piston {\n        attribute mass :> MassAttribute;\n        attribute diameter :> LengthValue;\n    }\n    \n    part def ConnectingRod {\n        attribute length :> LengthValue;\n        attribute mass :> MassAttribute;\n    }\n    \n    part def Crankshaft {\n        attribute mass :> MassAttribute;\n        attribute mainJournalDiameter :> LengthValue;\n    }\n    \n    // Engine configuration definition\n    part def Engine {\n        attribute engineType : String;\n        attribute numberOfCylinders : Integer;\n        attribute power :> PowerAttribute;\n        attribute mass :> MassAttribute;\n        attribute efficiency :> EfficiencyAttribute;\n        attribute reliability :> ReliabilityAttribute;\n        attribute cost :> CostAttribute;\n        \n        part cylinders : Cylinder[1..*];\n        part pistons : Piston[1..*];\n        part connectingRods : ConnectingRod[1..*];\n        part crankshaft : Crankshaft;\n        \n        assert constraint cylinderCount { \n            cylinders.size() == numberOfCylinders \n        }\n        assert constraint pistonCount { \n            pistons.size() == numberOfCylinders \n        }\n        assert constraint rodCount { \n            connectingRods.size() == numberOfCylinders \n        }\n    }\n    \n    // Specific engine configurations\n    part def FourCylinderEngine :> Engine {\n        attribute redefines numberOfCylinders = 4;\n        attribute redefines engineType = \"I4\";\n    }\n    \n    part def SixCylinderEngine :> Engine {\n        attribute redefines numberOfCylinders = 6;\n        attribute redefines engineType = \"I6\";\n    }\n    \n    // Trade-off analysis\n    analysis def MultiAttributeTradeOffAnalysis {\n        in candidate : Engine[1..*];\n        out optimalEngine : Engine;\n        out tradeOffScore : Real[0..*];\n        \n        attribute powerWeight : Real = 0.25;\n        attribute massWeight : Real = 0.20;\n        attribute efficiencyWeight : Real = 0.25;\n        attribute reliabilityWeight : Real = 0.15;\n        attribute costWeight : Real = 0.15;\n        \n        assert constraint weightsSum {\n            powerWeight + massWeight + efficiencyWeight + \n            reliabilityWeight + costWeight == 1.0\n        }\n        \n        calc def calculateScore {\n            in engine : Engine;\n            return score : Real;\n        }\n    }\n    \n    // Evaluation model\n    calc def PerformanceEvaluation {\n        in engine : Engine;\n        out performanceScore : Real;\n        out performanceBreakdown : Real[5];\n    }\n    \n    // Decision support\n    requirement def OptimalEngineSelection {\n        doc /* The system shall automatically recommend the optimal engine \n             solution based on multi-attribute trade-off analysis */\n        \n        subject system : PowertrainConfigurationSystem;\n        \n        require constraint {\n            system.selectedEngine == system.tradeOffAnalysis.optimalEngine\n        }\n    }\n    \n    requirement def DecisionTransparency {\n        doc /* The system shall provide explanations on the rationality \n             of engine selection */\n        \n        subject system : PowertrainConfigurationSystem;\n        \n        require constraint {\n            system.selectionExplanation != null\n        }\n    }\n    \n    // System definition\n    part def PowertrainConfigurationSystem {\n        part engineLibrary : Engine[1..*];\n        part tradeOffAnalysis : MultiAttributeTradeOffAnalysis;\n        attribute selectedEngine : Engine;\n        attribute selectionExplanation : String;\n        \n        perform action assembleEngine {\n            in engineType : String;\n            in cylinderCount : Integer;\n            out assembledEngine : Engine;\n        }\n        \n        perform action evaluateEngines {\n            in engines : Engine[1..*];\n            out evaluationResults : Real[0..*];\n        }\n        \n        perform action selectOptimalEngine {\n            in evaluationResults : Real[0..*];\n            in engines : Engine[1..*];\n            out optimal : Engine;\n            out explanation : String;\n        }\n    }\n    \n    // Use case\n    use case def ConfigurePowertrain {\n        subject vehicle : Vehicle;\n        actor engineer : SystemEngineer;\n        \n        objective {\n            doc /* Select optimal engine configuration based on \n                 performance, mass, efficiency, reliability, and cost */\n        }\n        \n        include use case defineRequirements;\n        include use case modelEngineOptions;\n        include use case performTradeOffAnalysis;\n        include use case reviewRecommendation;\n    }\n    \n    // Stakeholders\n    part def Vehicle;\n    part def SystemEngineer;\n}",
    "package FuelEconomySystem {\n    import ScalarValues::*;\n    import Quantities::*;\n    import MeasurementReferences::*;\n    import ISQ::*;\n    import USCustomaryUnits::*;\n    \n    attribute def FuelEconomy :> ScalarQuantityValue {\n        attribute quantityDimension = length / volume;\n        attribute unit = mile / gallon;\n    }\n    \n    attribute def Load :> ScalarQuantityValue {\n        attribute quantityDimension = mass;\n        attribute unit = pound;\n    }\n    \n    enum def DrivingCondition {\n        urban;\n        highway;\n    }\n    \n    requirement def FuelEconomyRequirement {\n        doc /* The vehicle fuel economy must meet regulatory and performance requirements */\n        \n        attribute testLoad : Load = 1000 [pound];\n        attribute urbanMinimum : FuelEconomy = 25 [mile/gallon];\n        attribute highwayMinimum : FuelEconomy = 30 [mile/gallon];\n        \n        requirement urbanFuelEconomy {\n            doc /* Under urban driving conditions, range per gallon must not be less than 25 miles */\n            assume constraint { testLoad == 1000 [pound] }\n            require constraint { measuredUrbanFuelEconomy >= urbanMinimum }\n        }\n        \n        requirement highwayFuelEconomy {\n            doc /* Under highway conditions, range per gallon must not be less than 30 miles */\n            assume constraint { testLoad == 1000 [pound] }\n            require constraint { measuredHighwayFuelEconomy >= highwayMinimum }\n        }\n        \n        attribute measuredUrbanFuelEconomy : FuelEconomy;\n        attribute measuredHighwayFuelEconomy : FuelEconomy;\n    }\n    \n    part def Vehicle {\n        attribute fuelEconomy : FuelEconomy;\n        attribute operatingCondition : DrivingCondition;\n        attribute currentLoad : Load;\n        \n        part powertrain : Powertrain;\n    }\n    \n    part def Powertrain {\n        attribute efficiency : Real;\n    }\n    \n    analysis def FuelEconomyAnalysis {\n        subject vehicle : Vehicle;\n        \n        return urbanResult : FuelEconomy;\n        return highwayResult : FuelEconomy;\n        \n        objective {\n            doc /* Analyze fuel consumption under various conditions */\n        }\n    }\n    \n    verification def FuelEconomyVerification {\n        subject vehicleUnderTest : Vehicle;\n        \n        objective {\n            doc /* Verify fuel economy meets requirements under standard test conditions */\n        }\n        \n        return verdict : VerdictKind;\n    }\n    \n    part fuelEconomySystem : Vehicle {\n        satisfy requirement fuelEconomyReq : FuelEconomyRequirement;\n    }\n}",
    "package VehicleLongitudinalDynamicsSimulation {\n    import SI::*;\n    import ISQ::*;\n    import ScalarValues::*;\n    \n    part def VehicleDynamicsSystem {\n        attribute mass : MassValue;\n        attribute initialPosition : LengthValue;\n        attribute initialVelocity : SpeedValue;\n        attribute timeStep : TimeValue;\n        \n        port powerInput : PowerSegmentPort;\n        port dynamicsOutput : DynamicsResultPort;\n        \n        perform action simulateDynamics {\n            in vehicleMass : MassValue = mass;\n            in initPos : LengthValue = initialPosition;\n            in initVel : SpeedValue = initialVelocity;\n            in powerData : PowerSegment[*];\n            in dt : TimeValue = timeStep;\n            \n            out accelerationSequence : AccelerationValue[*];\n            out velocitySequence : SpeedValue[*];\n            out positionSequence : LengthValue[*];\n        }\n    }\n    \n    port def PowerSegmentPort {\n        in item powerSegments : PowerSegment[*];\n    }\n    \n    port def DynamicsResultPort {\n        out item acceleration : AccelerationValue[*];\n        out item velocity : SpeedValue[*];\n        out item position : LengthValue[*];\n    }\n    \n    attribute def PowerSegment {\n        attribute power : PowerValue;\n        attribute duration : TimeValue;\n    }\n    \n    requirement def FunctionalRequirements {\n        doc /* The system shall calculate vehicle acceleration, velocity, and position \n               based on input power and dynamic equations */\n        \n        requirement calculateAcceleration {\n            doc /* System shall compute acceleration at each time step using \n                   F = P/v and a = F/m */\n        }\n        \n        requirement calculateVelocity {\n            doc /* System shall integrate acceleration to obtain velocity sequence */\n        }\n        \n        requirement calculatePosition {\n            doc /* System shall integrate velocity to obtain position sequence */\n        }\n        \n        requirement processSegmentedPower {\n            doc /* System shall handle segmented power input data */\n        }\n    }\n    \n    requirement def NonFunctionalRequirements {\n        requirement numericalAccuracy {\n            doc /* Calculations shall maintain numerical stability and accuracy \n                   with specified time step */\n        }\n        \n        requirement performanceAnalysisSupport {\n            doc /* System shall provide data for vehicle performance analysis */\n        }\n        \n        requirement controlStrategySupport {\n            doc /* System shall support control strategy development */\n        }\n        \n        requirement behaviorEvaluationSupport {\n            doc /* System shall enable driving behavior evaluation */\n        }\n    }\n    \n    analysis def LongitudinalDynamicsAnalysis {\n        subject system : VehicleDynamicsSystem;\n        \n        objective {\n            doc /* Analyze straight-line dynamic characteristics of vehicle motion */\n        }\n        \n        return accelerationProfile : AccelerationValue[*];\n        return velocityProfile : SpeedValue[*]; \n        return displacementProfile : LengthValue[*];\n    }\n    \n    verification def DynamicsCalculationVerification {\n        subject system : VehicleDynamicsSystem;\n        \n        objective {\n            doc /* Verify correct implementation of dynamic equations */\n        }\n        \n        verify requirement FunctionalRequirements::calculateAcceleration;\n        verify requirement FunctionalRequirements::calculateVelocity;\n        verify requirement FunctionalRequirements::calculatePosition;\n    }\n}",
    "package VehicleStructureModel {\n    import SI::*;\n    \n    part def Vehicle {\n        attribute totalMass : MassValue = 2500 [kg];\n        \n        part frontAxleAssembly : FrontAxleAssembly;\n        part rearAxleAssembly : RearAxleAssembly;\n    }\n    \n    part def FrontAxleAssembly {\n        attribute mass : MassValue = 150 [kg];\n        \n        part frontWheel[2] : Wheel;\n        part frontAxle : FrontAxle;\n    }\n    \n    part def RearAxleAssembly {\n        attribute mass : MassValue = 250 [kg];\n        \n        part rearWheel[2] : Wheel;\n        part rearAxle : RearAxle;\n    }\n    \n    part def FrontAxle {\n        attribute mass : MassValue;\n        attribute steeringAngle : AngleValue;\n    }\n    \n    part def RearAxle {\n        attribute mass : MassValue;\n    }\n    \n    part def Wheel {\n        attribute mass : MassValue;\n    }\n}",
    "package VehicleSafetySecuritySystem {\n    import ScalarValues::*;\n    \n    enum def SafetyFeatureType {\n        mandatory;\n        optional;\n    }\n    \n    enum def ComponentCategory {\n        safety;\n        security;\n    }\n    \n    attribute def DisplayFormat {\n        attribute formatType : String;\n    }\n    \n    part def Vehicle {\n        part seatBelts : SeatBelt[1..*];\n        part airbags : Airbag[0..*];\n        part bumpers : Bumper[1..*];\n        part alarmDevices : AlarmDevice[0..*];\n        part keylessEntrySystem : KeylessEntry[0..1];\n        part antiLockBrakingSystem : ABS[0..1];\n        \n        attribute hasCompleteSafetyConfig : Boolean;\n    }\n    \n    abstract part def VehicleComponent {\n        attribute componentName : String;\n        attribute category : ComponentCategory;\n    }\n    \n    abstract part def SafetyComponent :> VehicleComponent {\n        attribute safetyType : SafetyFeatureType;\n        attribute category : ComponentCategory default ComponentCategory::safety;\n    }\n    \n    abstract part def SecurityComponent :> VehicleComponent {\n        attribute category : ComponentCategory default ComponentCategory::security;\n    }\n    \n    part def SeatBelt :> SafetyComponent {\n        attribute safetyType : SafetyFeatureType default SafetyFeatureType::mandatory;\n    }\n    \n    part def Airbag :> SafetyComponent {\n        attribute safetyType : SafetyFeatureType default SafetyFeatureType::optional;\n    }\n    \n    part def Bumper :> SafetyComponent {\n        attribute safetyType : SafetyFeatureType default SafetyFeatureType::mandatory;\n    }\n    \n    part def ABS :> SafetyComponent {\n        attribute safetyType : SafetyFeatureType default SafetyFeatureType::optional;\n    }\n    \n    part def AlarmDevice :> SecurityComponent;\n    \n    part def KeylessEntry :> SecurityComponent;\n    \n    part def SafetySecurityManagementSystem {\n        part managedVehicle : Vehicle;\n        part displaySubsystem : DisplaySubsystem;\n        part filteringEngine : FilteringEngine;\n        \n        interface vehicleDataInterface connect managedVehicle to filteringEngine;\n        interface filteredDataInterface connect filteringEngine to displaySubsystem;\n    }\n    \n    part def FilteringEngine {\n        action filterByCategory {\n            in vehicle : Vehicle;\n            in filterCategory : ComponentCategory;\n            out filteredComponents : VehicleComponent[0..*];\n        }\n        \n        action filterBySafetyType {\n            in vehicle : Vehicle;\n            in filterType : SafetyFeatureType;\n            out filteredComponents : SafetyComponent[0..*];\n        }\n    }\n    \n    part def DisplaySubsystem {\n        attribute supportedFormats : DisplayFormat[1..*];\n        \n        action displayAsTree {\n            in components : VehicleComponent[0..*];\n        }\n        \n        action displayAsTable {\n            in components : VehicleComponent[0..*];\n        }\n        \n        action showSafetyConfiguration {\n            in vehicle : Vehicle;\n        }\n    }\n    \n    requirement def SafetyVisualizationRequirement {\n        doc /* System shall display safety and security configurations */\n        subject system : SafetySecurityManagementSystem;\n        \n        require constraint {\n            system.displaySubsystem.supportedFormats->size() >= 2\n        }\n    }\n    \n    requirement def MandatorySafetyRequirement {\n        doc /* Vehicle must have mandatory safety features */\n        subject vehicle : Vehicle;\n        \n        require constraint {\n            vehicle.seatBelts->size() >= 1 and\n            vehicle.bumpers->size() >= 1\n        }\n    }\n    \n    requirement def ComponentCategorizationRequirement {\n        doc /* All components must be categorizable by safety or security */\n        subject component : VehicleComponent;\n        \n        require constraint {\n            component.category == ComponentCategory::safety or\n            component.category == ComponentCategory::security\n        }\n    }\n}",
    "I'll analyze this requirement and create a SysML v2 model representing the layered architecture system.\n\n<scratchpad>\nKey functional/non-functional information:\n1. Layered architecture with 3 layers: Application Layer, Service Layer, Data Layer\n2. Dependencies: Application Layer uses Service Layer, Service Layer uses Data Layer\n3. System has 3 core attributes: x, y, z\n4. Attribute z depends on attributes x and y\n5. Clear division of responsibilities between layers\n6. Smooth data flow and functional calls\n\nSysML v2 mapping:\n- Use package for overall system\n- Use part definitions for each layer\n- Use interface definitions for layer interactions\n- Use attributes for x, y, z\n- Use constraints for z dependency on x and y\n- Use usage relationships to show layer dependencies\n- Use ports and connections for data flow\n</scratchpad>\n\npackage LayeredSystemArchitecture {\n    \n    part def System {\n        attribute x : Real;\n        attribute y : Real;\n        attribute z : Real;\n        \n        constraint zDependency {\n            z == f(x, y)\n        }\n        \n        part applicationLayer : ApplicationLayer;\n        part serviceLayer : ServiceLayer;\n        part dataLayer : DataLayer;\n        \n        interface applicationServiceInterface : ApplicationServiceInterface \n            connect applicationLayer.servicePort to serviceLayer.applicationPort;\n            \n        interface serviceDataInterface : ServiceDataInterface\n            connect serviceLayer.dataPort to dataLayer.servicePort;\n    }\n    \n    part def ApplicationLayer {\n        port servicePort : ApplicationServiceInterface;\n        \n        action executeApplicationLogic {\n            out item request;\n            in item response;\n            \n            send request via servicePort;\n            accept response via servicePort;\n        }\n    }\n    \n    part def ServiceLayer {\n        port applicationPort : ~ApplicationServiceInterface;\n        port dataPort : ServiceDataInterface;\n        \n        action processServiceRequest {\n            in item request;\n            out item response;\n            \n            accept request via applicationPort;\n            send dataRequest via dataPort;\n            accept dataResponse via dataPort;\n            send response via applicationPort;\n        }\n    }\n    \n    part def DataLayer {\n        port servicePort : ~ServiceDataInterface;\n        \n        action handleDataOperation {\n            in item dataRequest;\n            out item dataResponse;\n            \n            accept dataRequest via servicePort;\n            send dataResponse via servicePort;\n        }\n    }\n    \n    interface def ApplicationServiceInterface {\n        end applicationEnd;\n        end serviceEnd;\n    }\n    \n    interface def ServiceDataInterface {\n        end serviceEnd;\n        end dataEnd;\n    }\n}",
    "package PowertrainSystem {\n    import ScalarValues::*;\n    \n    requirement def TorqueGenerationRequirement {\n        doc /* This system is designed to realize the torque generation function within the powertrain system */\n        \n        requirement torqueCapability {\n            doc /* The system should include relevant components capable of generating torque */\n        }\n        \n        requirement minimumTorque {\n            doc /* The torque produced during operation must be greater than zero newton-meters */\n            attribute requiredTorque :> ISQ::torque;\n            require constraint { requiredTorque > 0 [N*m] }\n        }\n        \n        requirement allocationMapping {\n            doc /* The logic layer's torque generator function should be effectively allocated and mapped to the physical layer */\n        }\n    }\n    \n    part def Powertrain {\n        attribute generatedTorque :> ISQ::torque;\n        \n        perform action generateTorque {\n            out torqueOutput :> ISQ::torque = generatedTorque;\n        }\n        \n        part engine : Engine;\n        \n        satisfy torqueGenerationReq : TorqueGenerationRequirement {\n            requirement minimumTorque {\n                attribute :>> requiredTorque = generatedTorque;\n            }\n        }\n    }\n    \n    part def Engine {\n        attribute outputTorque :> ISQ::torque;\n        \n        action engineTorqueGeneration {\n            out engineTorque :> ISQ::torque = outputTorque;\n        }\n    }\n    \n    action def TorqueGeneratorFunction {\n        doc /* Logic layer torque generator function */\n        out torque :> ISQ::torque;\n    }\n    \n    allocation def TorqueGenerationAllocation {\n        doc /* Allocation from logical function to physical component */\n        end logical : TorqueGeneratorFunction;\n        end physical : Engine::engineTorqueGeneration;\n    }\n    \n    usage powertrainInstance : Powertrain {\n        :>> generatedTorque;\n        \n        allocation : TorqueGenerationAllocation {\n            allocate TorqueGeneratorFunction to engine.engineTorqueGeneration;\n        }\n        \n        assert constraint torqueValidation {\n            generatedTorque > 0 [N*m]\n        }\n    }\n}",
    "package SystemModel {\n    import ScalarValues::*;\n    \n    part def System {\n        attribute powerOutput : Real;\n        \n        perform action transmitPower;\n        perform action outputPower;\n        perform action providePower;\n        perform action generateTorque;\n    }\n    \n    part def TorqueGenerator {\n        attribute torqueOutput : Real;\n        \n        perform action generateTorque;\n    }\n    \n    part def Powertrain {\n        part engine : Engine;\n    }\n    \n    part def Engine {\n        attribute torqueOutput : Real;\n        \n        perform action generateTorque;\n    }\n    \n    part system : System {\n        part torqueGen : TorqueGenerator;\n        part powertrain : Powertrain;\n        \n        allocation torqueGenToEngine : torqueGen.generateTorque to powertrain.engine.generateTorque;\n    }\n}",
    "<scratchpad>\nLet me analyze the requirements step by step:\n\n1. Key functional/non-functional information:\n   - System: Vehicle Safety and Anti-theft Function Catalogue\n   - Purpose: Standardize basic configuration requirements for vehicle components\n   - Two main aspects: Safety and Anti-theft performance\n   \n2. Component categories:\n   - Basic safety components (mandatory): front seat belts, bumpers\n   - Optional safety components: driver's airbag, anti-lock braking system (ABS)\n   - Security components: alarm system, keyless entry system\n   - Components can affect: safety only, anti-theft only, or both\n   \n3. Requirements:\n   - Must ensure fundamental personal safety of occupants\n   - Must enhance overall security and protective capability\n   - Must meet regulatory requirements\n   - Must meet users' needs for basic safety and protection\n   \n4. SysML v2 mapping:\n   - Use package for the catalogue\n   - Use part definitions for component types\n   - Use requirements for safety/security requirements\n   - Use attributes for component properties\n   - Use constraints for mandatory vs optional\n   - Use allocations to show which components satisfy which requirements\n</scratchpad>\n\npackage VehicleSafetyAntiTheftCatalogue {\n    \n    import ScalarValues::*;\n    \n    enum def ComponentCategory {\n        enum safety;\n        enum antiTheft;\n        enum safetyAndAntiTheft;\n    }\n    \n    enum def ConfigurationStatus {\n        enum mandatory;\n        enum optional;\n    }\n    \n    attribute def SafetyLevel :> Real {\n        doc /* Level of safety protection provided */\n    }\n    \n    part def VehicleComponent {\n        attribute category : ComponentCategory;\n        attribute status : ConfigurationStatus;\n        attribute safetyLevel : SafetyLevel;\n    }\n    \n    part def SafetyComponent :> VehicleComponent {\n        attribute category redefines VehicleComponent::category = ComponentCategory::safety;\n    }\n    \n    part def AntiTheftComponent :> VehicleComponent {\n        attribute category redefines VehicleComponent::category = ComponentCategory::antiTheft;\n    }\n    \n    part def DualPurposeComponent :> VehicleComponent {\n        attribute category redefines VehicleComponent::category = ComponentCategory::safetyAndAntiTheft;\n    }\n    \n    part def FrontSeatBelt :> SafetyComponent {\n        attribute status redefines VehicleComponent::status = ConfigurationStatus::mandatory;\n        doc /* Basic safety component for occupant protection */\n    }\n    \n    part def Bumper :> SafetyComponent {\n        attribute status redefines VehicleComponent::status = ConfigurationStatus::mandatory;\n        doc /* Basic safety component for collision protection */\n    }\n    \n    part def DriverAirbag :> SafetyComponent {\n        attribute status redefines VehicleComponent::status = ConfigurationStatus::optional;\n        doc /* Enhanced safety feature for driver protection */\n    }\n    \n    part def AntiLockBrakingSystem :> SafetyComponent {\n        attribute status redefines VehicleComponent::status = ConfigurationStatus::optional;\n        doc /* ABS - Enhanced safety feature for braking control */\n    }\n    \n    part def AlarmSystem :> AntiTheftComponent {\n        attribute status redefines VehicleComponent::status = ConfigurationStatus::optional;\n        doc /* Security component for theft deterrence */\n    }\n    \n    part def KeylessEntrySystem :> AntiTheftComponent {\n        attribute status redefines VehicleComponent::status = ConfigurationStatus::optional;\n        doc /* Security component for access control */\n    }\n    \n    part def Vehicle {\n        part bodyAndInterior {\n            part frontSeatBelts : FrontSeatBelt[2];\n            part bumpers : Bumper[2];\n            part driverAirbag : DriverAirbag[0..1];\n        }\n        \n        part brakingSystem {\n            part abs : AntiLockBrakingSystem[0..1];\n        }\n        \n        part securitySystem {\n            part alarm : AlarmSystem[0..1];\n            part keylessEntry : KeylessEntrySystem[0..1];\n        }\n    }\n    \n    requirement def SafetyRequirement {\n        doc /* Requirements for vehicle safety performance */\n    }\n    \n    requirement def AntiTheftRequirement {\n        doc /* Requirements for vehicle security performance */\n    }\n    \n    requirement fundamentalPersonalSafety : SafetyRequirement {\n        doc /* Ensure the fundamental personal safety of occupants */\n        require constraint {\n            Vehicle::bodyAndInterior::frontSeatBelts->size() >= 2 and\n            Vehicle::bodyAndInterior::bumpers->size() >= 2\n        }\n    }\n    \n    requirement enhancedSecurityCapability : AntiTheftRequirement {\n        doc /* Enhance the overall security and protective capability of the vehicle */\n    }\n    \n    requirement regulatoryCompliance : SafetyRequirement {\n        doc /* Meet regulatory requirements for vehicle safety */\n        subject vehicle : Vehicle;\n        require constraint {\n            vehicle.bodyAndInterior.frontSeatBelts->forAll(fb | fb.status == ConfigurationStatus::mandatory) and\n            vehicle.bodyAndInterior.bumpers->forAll(b | b.status == ConfigurationStatus::mandatory)\n        }\n    }\n    \n    requirement userSafetyNeeds : SafetyRequirement {\n        doc /* Meet users' needs for the most basic safety functions */\n    }\n    \n    requirement userProtectionNeeds : AntiTheftRequirement {\n        doc /* Meet users' needs for the most basic protection functions */\n    }\n    \n    allocation mandatorySafetyAllocation {\n        allocate fundamentalPersonalSafety to FrontSeatBelt;\n        allocate fundamentalPersonalSafety to Bumper;\n    }\n    \n    allocation securityAllocation {\n        allocate enhancedSecurityCapability to AlarmSystem;\n        allocate enhancedSecurityCapability to KeylessEntrySystem;\n    }\n}",
    "package FuelSystem {\n    import ScalarValues::*;\n    \n    part def Vehicle {\n        part fuelSystem : FuelSystem;\n    }\n    \n    part def FuelSystem {\n        doc /* This system provides complete fuel supply and return management functions for vehicles */\n        \n        part fuelTankAssembly : FuelTankAssembly;\n        \n        interface def FuelFlowInterface {\n            end supplierPort;\n            end consumerPort;\n            flow of Fuel from supplierPort to consumerPort;\n        }\n        \n        interface def FuelReturnInterface {\n            end returnPort;\n            end receiverPort;\n            flow of Fuel from returnPort to receiverPort;\n        }\n        \n        interface def FuelDataInterface {\n            end dataSource;\n            end dataReceiver;\n            flow of FuelTemperature from dataSource to dataReceiver;\n        }\n    }\n    \n    part def FuelTankAssembly {\n        doc /* Integrates both the fuel pump and the fuel tank */\n        \n        part fuelTank : FuelTank;\n        part fuelPump : FuelPump;\n        \n        port fuelSupplyPort : FuelFlowInterface::supplierPort;\n        port fuelReturnPort : FuelReturnInterface::receiverPort;\n        port temperatureDataPort : FuelDataInterface::dataSource;\n        \n        bind fuelPump.inletPort = fuelTank.outletPort;\n        bind fuelPump.outletPort = fuelSupplyPort;\n        bind fuelTank.returnPort = fuelReturnPort;\n        bind fuelTank.tempSensorPort = temperatureDataPort;\n    }\n    \n    part def FuelTank {\n        attribute capacity : Real;\n        attribute currentLevel : Real;\n        \n        port outletPort : FuelFlowInterface::supplierPort;\n        port returnPort : FuelReturnInterface::receiverPort;\n        port tempSensorPort : FuelDataInterface::dataSource;\n        \n        perform action monitorTemperature {\n            doc /* Monitor real-time fuel temperature */\n        }\n    }\n    \n    part def FuelPump {\n        doc /* Responsible for pressurizing fuel from the tank and delivering it to fuel-consuming units */\n        \n        attribute pressure : Real;\n        attribute flowRate : Real;\n        \n        port inletPort : FuelFlowInterface::consumerPort;\n        port outletPort : FuelFlowInterface::supplierPort;\n        \n        perform action pressurizeFuel {\n            doc /* Pressurize fuel for delivery */\n        }\n    }\n    \n    part def FuelConsumingUnit {\n        port fuelInletPort : FuelFlowInterface::consumerPort;\n        port fuelReturnPort : FuelReturnInterface::returnPort;\n        port temperatureReceivePort : FuelDataInterface::dataReceiver;\n    }\n    \n    item def Fuel {\n        attribute temperature : Real;\n        attribute pressure : Real;\n    }\n    \n    item def FuelTemperature {\n        attribute value : Real;\n        attribute timestamp : String;\n    }\n    \n    connection def FuelSupplyPath {\n        end supplier : FuelFlowInterface::supplierPort;\n        end consumer : FuelFlowInterface::consumerPort;\n    }\n    \n    connection def FuelReturnPath {\n        end returner : FuelReturnInterface::returnPort;\n        end receiver : FuelReturnInterface::receiverPort;\n    }\n    \n    connection def TemperatureDataPath {\n        end source : FuelDataInterface::dataSource;\n        end receiver : FuelDataInterface::dataReceiver;\n    }\n    \n    requirement def SafetyRequirement {\n        doc /* System must monitor and transmit real-time fuel temperature information to ensure safety */\n        subject fuelSystem : FuelSystem;\n    }\n    \n    requirement def EfficiencyRequirement {\n        doc /* System must ensure efficiency of fuel transport */\n        subject fuelSystem : FuelSystem;\n    }\n    \n    requirement def ReliabilityRequirement {\n        doc /* System must achieve reliable fuel supply and effective return management */\n        subject fuelSystem : FuelSystem;\n    }\n}",
    "<scratchpad>\nLet me analyze the requirements step by step:\n\n1. Key functional/non-functional information:\n   - Vehicle system with safety and security compliance configurations\n   - Interior components:\n     - 2 seat belts (mandatory safety features)\n     - 1 airbag in cockpit (optional)\n     - 1 anti-theft alarm device (security)\n   - Body components:\n     - 1 bumper (required safety component)\n     - 1 keyless entry system (security)\n   - Chassis components:\n     - 2 wheels\n     - 2 anti-lock braking systems (optional)\n   - All components subject to identification and classification management\n   - Goal: ensure compliance with safety and security regulations\n\n2. SysML v2 mapping:\n   - Use package for overall model\n   - Use part definitions for component types\n   - Use parts with multiplicity for instances\n   - Use attributes for properties like mandatory/optional\n   - Use requirements for compliance needs\n   - Use allocation for mapping requirements to parts\n</scratchpad>\n\npackage VehicleSafetySecuritySystem {\n    \n    part def Vehicle {\n        part interior : Interior;\n        part body : Body;\n        part chassis : Chassis;\n    }\n    \n    part def Interior {\n        part seatBelts : SeatBelt[2];\n        part airbag : Airbag[0..1];\n        part antiTheftAlarm : AntiTheftAlarm[1];\n    }\n    \n    part def Body {\n        part bumper : Bumper[1];\n        part keylessEntrySystem : KeylessEntrySystem[1];\n    }\n    \n    part def Chassis {\n        part wheels : Wheel[2];\n        part absSystem : AntiLockBrakingSystem[0..2];\n    }\n    \n    part def SeatBelt {\n        attribute isMandatory : Boolean = true;\n        attribute category : String = \"Safety\";\n    }\n    \n    part def Airbag {\n        attribute isMandatory : Boolean = false;\n        attribute category : String = \"Safety\";\n    }\n    \n    part def AntiTheftAlarm {\n        attribute isMandatory : Boolean = true;\n        attribute category : String = \"Security\";\n    }\n    \n    part def Bumper {\n        attribute isMandatory : Boolean = true;\n        attribute category : String = \"Safety\";\n    }\n    \n    part def KeylessEntrySystem {\n        attribute isMandatory : Boolean = true;\n        attribute category : String = \"Security\";\n    }\n    \n    part def Wheel {\n        attribute isMandatory : Boolean = true;\n        attribute category : String = \"Chassis\";\n    }\n    \n    part def AntiLockBrakingSystem {\n        attribute isMandatory : Boolean = false;\n        attribute category : String = \"Safety\";\n    }\n    \n    requirement def SafetyCompliance {\n        doc /* All mandatory safety components must be installed and functional */\n    }\n    \n    requirement def SecurityCompliance {\n        doc /* All security components must meet regulatory standards */\n    }\n    \n    requirement def ComponentManagement {\n        doc /* All safety and security components must be identified and classified */\n    }\n    \n    part vehicle : Vehicle {\n        satisfy requirement safetyReq : SafetyCompliance;\n        satisfy requirement securityReq : SecurityCompliance;\n        satisfy requirement managementReq : ComponentManagement;\n    }\n}",
    "package VehicleSafetySecuritySystem {\n    import ScalarValues::*;\n    \n    part def VehicleSafetySecurityComponent {\n        part interior : Interior;\n        part bodyAssembly : BodyAssembly;\n        \n        attribute def SafetyLevel :> String;\n        attribute def SecurityLevel :> String;\n        \n        attribute safetyLevel : SafetyLevel;\n        attribute securityLevel : SecurityLevel;\n    }\n    \n    part def Interior {\n        part alarmSystem : AlarmSystem;\n        part seatBelts : SeatBelt[1..*];\n        part frontRowSeats : FrontRowSeat[2];\n        part driverAirbag : DriverAirbag;\n    }\n    \n    part def BodyAssembly {\n        part vehicleBody : VehicleBody;\n        part bumper : Bumper;\n        part keylessEntrySystem : KeylessEntrySystem;\n    }\n    \n    part def AlarmSystem {\n        attribute isActive : Boolean;\n        attribute sensitivity : Real;\n    }\n    \n    part def SeatBelt {\n        attribute isFastened : Boolean;\n        attribute tensionLevel : Real;\n    }\n    \n    part def FrontRowSeat {\n        attribute position : String;\n        attribute isOccupied : Boolean;\n    }\n    \n    part def DriverAirbag {\n        attribute isDeployed : Boolean;\n        attribute deploymentThreshold : Real;\n    }\n    \n    part def VehicleBody {\n        attribute material : String;\n        attribute structuralIntegrity : Real;\n    }\n    \n    part def Bumper {\n        attribute impactResistance : Real;\n        attribute material : String;\n    }\n    \n    part def KeylessEntrySystem {\n        attribute isEnabled : Boolean;\n        attribute range : Real;\n        attribute encryptionType : String;\n    }\n    \n    requirement def SafetyRequirement {\n        doc /* System shall provide comprehensive safety protection through seat belts, airbags, and bumpers */\n        subject system : VehicleSafetySecurityComponent;\n        \n        require constraint {\n            system.interior.seatBelts->size() >= 1 and\n            system.interior.driverAirbag != null and\n            system.bodyAssembly.bumper != null\n        }\n    }\n    \n    requirement def SecurityRequirement {\n        doc /* System shall provide anti-theft and convenient access through alarm and keyless entry */\n        subject system : VehicleSafetySecurityComponent;\n        \n        require constraint {\n            system.interior.alarmSystem != null and\n            system.bodyAssembly.keylessEntrySystem != null\n        }\n    }\n    \n    requirement def IntegratedSystemRequirement {\n        doc /* System shall integrate safety and security functions for comprehensive protection and convenient user experience */\n        subject system : VehicleSafetySecurityComponent;\n        \n        satisfy safetyReq : SafetyRequirement;\n        satisfy securityReq : SecurityRequirement;\n    }\n    \n    part vehicleSafetySecurityInstance : VehicleSafetySecurityComponent {\n        part interior {\n            part alarmSystem {\n                :>> isActive = true;\n                :>> sensitivity = 0.8;\n            }\n            part seatBelts;\n            part frontRowSeats;\n            part driverAirbag {\n                :>> isDeployed = false;\n                :>> deploymentThreshold = 25.0;\n            }\n        }\n        part bodyAssembly {\n            part vehicleBody;\n            part bumper;\n            part keylessEntrySystem {\n                :>> isEnabled = true;\n                :>> range = 5.0;\n            }\n        }\n    }\n}",
    "package 'Information Security Classification System' {\n    \n    enum def SecurityClassificationLevel {\n        enum Unclassified;\n        enum Confidential;\n        enum Secret;\n    }\n    \n    attribute def ClassificationAttribute {\n        attribute level : SecurityClassificationLevel;\n        attribute displayLabel : String;\n    }\n    \n    part def Component {\n        attribute classification : ClassificationAttribute;\n        attribute componentId : String;\n        attribute componentName : String;\n    }\n    \n    part def ClassificationSystem {\n        part components : Component[*];\n        \n        action classifyComponent {\n            in component : Component;\n            in securityLevel : SecurityClassificationLevel;\n            out classifiedComponent : Component;\n        }\n        \n        action recognizeClassification {\n            in component : Component;\n            out recognizedLevel : SecurityClassificationLevel;\n            out displayAttribute : String;\n        }\n        \n        action displayClassification {\n            in component : Component;\n            out classificationDisplay : String;\n        }\n    }\n    \n    requirement def InformationSecurityRequirement {\n        doc /* All components must be classified and labeled */\n        \n        requirement classificationRequirement {\n            doc /* Every component must be assigned a security classification level */\n            subject comp : Component;\n            require constraint {\n                comp.classification.level in SecurityClassificationLevel\n            }\n        }\n        \n        requirement confidentialRecognitionRequirement {\n            doc /* System must recognize and display confidential classification */\n            subject sys : ClassificationSystem;\n            assume constraint {\n                sys.components->exists(c | c.classification.level == SecurityClassificationLevel::Confidential)\n            }\n            require constraint {\n                sys.recognizeClassification.recognizedLevel == SecurityClassificationLevel::Confidential \n                implies sys.displayClassification.classificationDisplay == \"Confidential\"\n            }\n        }\n    }\n    \n    verification def ClassificationVerification {\n        subject sys : ClassificationSystem;\n        \n        verify requirement InformationSecurityRequirement::classificationRequirement {\n            return sys.components->forAll(c | c.classification.level != null);\n        }\n        \n        verify requirement InformationSecurityRequirement::confidentialRecognitionRequirement {\n            return sys.components\n                ->select(c | c.classification.level == SecurityClassificationLevel::Confidential)\n                ->forAll(c | sys.recognizeClassification(c).recognizedLevel == SecurityClassificationLevel::Confidential);\n        }\n    }\n}",
    "package AutomotiveECUSystem {\n    import ScalarValues::*;\n    \n    // Define interfaces\n    interface def CANInterface {\n        in item canReceive;\n        out item canTransmit;\n    }\n    \n    interface def SensorInterface {\n        in item sensorData;\n    }\n    \n    // Define connection types\n    connection def CANBusConnection {\n        end canPort1 : CANInterface;\n        end canPort2 : CANInterface;\n    }\n    \n    // Define parts\n    part def VehicleControlUnit {\n        attribute id : String;\n        attribute state : String;\n        \n        port busIF : CANInterface;\n        port sensorIF : SensorInterface;\n        \n        perform action monitorVehicleState;\n        perform action controlVehicleState;\n    }\n    \n    part def EngineControlUnit {\n        attribute id : String;\n        attribute engineState : String;\n        attribute rpm : Real;\n        \n        port busIF : CANInterface;\n        port sensorIF : SensorInterface;\n        \n        perform action monitorEngineState;\n        perform action controlEngineState;\n    }\n    \n    part def CANBus {\n        attribute busSpeed : Real;\n        attribute protocol : String;\n        \n        port vcuConnection : CANInterface;\n        port ecuConnection : CANInterface;\n    }\n    \n    part def AutomotiveECUSystemModel {\n        part vcu : VehicleControlUnit {\n            attribute :>> id = \"VCU_001\";\n        }\n        \n        part ecu : EngineControlUnit {\n            attribute :>> id = \"ECU_001\";\n        }\n        \n        part canBus : CANBus {\n            attribute :>> busSpeed = 500.0;\n            attribute :>> protocol = \"CAN 2.0B\";\n        }\n        \n        connection vcuToCAN : CANBusConnection \n            connect vcu.busIF to canBus.vcuConnection;\n            \n        connection ecuToCAN : CANBusConnection \n            connect ecu.busIF to canBus.ecuConnection;\n    }\n    \n    // Define requirements\n    requirement def SafetyRequirement {\n        doc /* System shall ensure reliable communication between VCU and ECU */\n        attribute criticality : String = \"High\";\n    }\n    \n    requirement def PerformanceRequirement {\n        doc /* System shall support efficient collaboration among vehicle subsystems */\n        attribute responseTime : Real;\n        require constraint { responseTime <= 10.0 }\n    }\n    \n    requirement def ExpansionRequirement {\n        doc /* System shall reserve interfaces for sensor data exchange */\n    }\n    \n    requirement vehicleSafety : SafetyRequirement;\n    requirement vehiclePerformance : PerformanceRequirement {\n        attribute :>> responseTime = 5.0;\n    }\n    requirement futureExpansion : ExpansionRequirement;\n}",
    "package BloodGlucoseMeterSystem {\n    import ScalarValues::*;\n    \n    requirement def ReliabilityAndSafetyRequirement {\n        doc /* This system is designed to ensure high reliability and safety of the blood glucose meter during use */\n        \n        requirement batteryMonitoring : BatteryMonitoringRequirement;\n        requirement alarmMechanism : AlarmMechanismRequirement;\n        requirement emergencyResponse : EmergencyResponseRequirement;\n        requirement riskManagement : RiskManagementRequirement;\n    }\n    \n    requirement def BatteryMonitoringRequirement {\n        doc /* System shall automatically detect battery status and alert user when battery is depleted or cannot be charged */\n        \n        requirement detectBatteryStatus {\n            doc /* System shall automatically detect battery status */\n        }\n        \n        requirement alertLowBattery {\n            doc /* System shall promptly alert user when battery is depleted */\n        }\n        \n        requirement alertChargingFailure {\n            doc /* System shall alert user when battery cannot be charged */\n        }\n    }\n    \n    requirement def AlarmMechanismRequirement {\n        doc /* System must have appropriate alarm mechanisms for abnormalities in blood glucose measurement function */\n        \n        requirement measurementFailureAlarm {\n            doc /* System shall trigger alarm when blood glucose measurement fails */\n        }\n    }\n    \n    requirement def EmergencyResponseRequirement {\n        doc /* System must have emergency response mechanisms in case of abnormalities */\n        \n        requirement preventMeasurementFailure {\n            doc /* System shall prevent failure to measure blood glucose levels due to battery issues */\n        }\n        \n        requirement preventTreatmentDelay {\n            doc /* System shall prevent potential treatment delays resulting from measurement failures */\n        }\n    }\n    \n    requirement def RiskManagementRequirement {\n        doc /* Management measures for key risk scenarios to ensure continuous and safe therapeutic support */\n        \n        requirement approvedRequirements {\n            doc /* Related system requirements have undergone rigorous approval */\n        }\n        \n        requirement continuousTherapeuticSupport {\n            doc /* Ensure patients can receive timely, continuous, and safe therapeutic support under all circumstances */\n        }\n    }\n}",
    "package ScientificConstantsSystem {\n    import ScalarValues::*;\n    import ISQ::*;\n    import SI::*;\n    \n    package MathematicalConstants {\n        attribute def EulerNumber :> Real {\n            doc /* Euler's number with 20 decimal precision */\n            attribute value : Real = 2.71828182845904523536;\n        }\n        \n        attribute def Pi :> Real {\n            doc /* Pi with 20 decimal precision */\n            attribute value : Real = 3.14159265358979323846;\n        }\n    }\n    \n    package PhysicalConstants {\n        attribute def SpeedOfLightInVacuum :> ISQ::SpeedValue {\n            doc /* Speed of light in vacuum */\n            attribute num : Real = 299792458;\n            attribute mRef :> ISQ::speed;\n        }\n        \n        attribute def FineStructureConstant :> Real {\n            doc /* Fine-structure constant (dimensionless) */\n            attribute value : Real = 0.0072973525693;\n        }\n        \n        attribute def ElectronToProtonMassRatio :> Real {\n            doc /* Electron to proton mass ratio (dimensionless) */\n            attribute value : Real = 0.00054386734428;\n        }\n    }\n    \n    package ContextSpecificConstants {\n        attribute def StandardGravitationalAcceleration :> ISQ::AccelerationValue {\n            doc /* Standard gravitational acceleration on Earth */\n            attribute num : Real = 9.80665;\n            attribute mRef :> ISQ::acceleration;\n        }\n        \n        attribute def ModelXAmplifierGain :> Real {\n            doc /* Amplifier gain coefficient for Model X */\n            attribute value : Real = 100.0;\n        }\n    }\n    \n    part def ConstantsProvider {\n        attribute eulerNumber : MathematicalConstants::EulerNumber;\n        attribute pi : MathematicalConstants::Pi;\n        attribute speedOfLight : PhysicalConstants::SpeedOfLightInVacuum;\n        attribute fineStructure : PhysicalConstants::FineStructureConstant;\n        attribute electronProtonRatio : PhysicalConstants::ElectronToProtonMassRatio;\n        attribute earthGravity : ContextSpecificConstants::StandardGravitationalAcceleration;\n        attribute modelXGain : ContextSpecificConstants::ModelXAmplifierGain;\n    }\n    \n    part scientificConstantsSystem : ConstantsProvider {\n        doc /* Main system instance providing all scientific constants */\n    }\n}",
    "package TireSpecificationModel {\n    import ScalarValues::*;\n    \n    attribute def ManufacturerName :> String;\n    attribute def RimDiameter :> Real;\n    attribute def TireWidth :> Integer;\n    \n    item def Tire {\n        attribute manufacturer : ManufacturerName;\n        attribute rimDiameter : RimDiameter;\n        attribute width : TireWidth;\n    }\n    \n    item frenchTire : Tire {\n        attribute manufacturer = \"Michelin\";\n        attribute rimDiameter = 18.0;\n        attribute width = 245;\n    }\n}",
    "package AutomotiveComponentModel {\n    import ISQ::*;\n    import SI::*;\n    import USCustomaryUnits::*;\n    \n    part def Vehicle {\n        attribute mass : MassValue = 1200 [kg];\n        attribute length : LengthValue = 4.82 [m];\n        \n        part frontWheels : FrontWheelAssembly;\n    }\n    \n    part def FrontWheelAssembly {\n        part leftWheel : Wheel;\n        part rightWheel : Wheel;\n    }\n    \n    part def Wheel {\n        attribute hubDiameter : LengthValue = 18 [in];\n        attribute width : LengthValue = 245 [mm];\n        attribute outerDiameter : LengthValue;\n        \n        part tire : Tire;\n        \n        constraint { outerDiameter == hubDiameter + 2 * tire.height }\n    }\n    \n    part def Tire {\n        attribute height : LengthValue;\n    }\n}",
    "package PowertrainConfiguration {\n    \n    part def Vehicle {\n        attribute isHighPerformance : Boolean;\n        part engine : Engine[1];\n        part transmission : Transmission[1];\n    }\n    \n    part def Engine {\n        attribute cylinders : Integer;\n    }\n    \n    part def FourCylinderEngine :> Engine {\n        attribute redefines cylinders = 4;\n    }\n    \n    part def SixCylinderEngine :> Engine {\n        attribute redefines cylinders = 6;\n    }\n    \n    part def Transmission;\n    \n    part def ManualTransmission :> Transmission;\n    \n    part def AutomaticTransmission :> Transmission;\n    \n    constraint def HighPerformanceEngineConstraint {\n        in vehicle : Vehicle;\n        \n        vehicle.isHighPerformance implies vehicle.engine.cylinders == 6;\n        !vehicle.isHighPerformance implies vehicle.engine.cylinders == 4;\n    }\n    \n    constraint def ValidPowertrainCombination {\n        in vehicle : Vehicle;\n        \n        (vehicle.engine.cylinders == 4 and vehicle.transmission istype ManualTransmission) xor\n        (vehicle.engine.cylinders == 6 and vehicle.transmission istype AutomaticTransmission);\n    }\n    \n    part vehicleConfiguration : Vehicle {\n        assert constraint highPerformanceRule : HighPerformanceEngineConstraint {\n            in vehicle = vehicleConfiguration;\n        }\n        \n        assert constraint validCombination : ValidPowertrainCombination {\n            in vehicle = vehicleConfiguration;\n        }\n    }\n}",
    "<scratchpad>\nLet me analyze the requirements step by step:\n\n1. Key entities/components:\n   - Car/Vehicle (mass: 1200 kg, length: 4.82 m)\n   - Wheel assemblies (multiple)\n   - Wheel (composed of rim and tire)\n   - Rim (diameter: 18 inches)\n   - Tire (width: 245 mm, height: 45 mm, default tread depth: 6.0 mm)\n   - Brake disc (radius: 95 mm)\n\n2. Key relationships:\n   - Car has multiple wheel assemblies\n   - Each wheel assembly has a wheel and a brake disc\n   - Each wheel consists of a rim and a tire\n\n3. Key constraints:\n   - Tire tread depth must be >= 3.5 mm (safety regulation)\n   - Brake disc diameter must be < wheel outer diameter\n   - Outer diameter calculation based on rim diameter and tire dimensions\n\n4. Mapping to SysML v2:\n   - Use part definitions for components\n   - Use attributes for properties with units\n   - Use part usages for composition\n   - Use constraints for the safety and fitment requirements\n   - Use calculations for derived values\n</scratchpad>\n\npackage AutomotiveComponentModel {\n    import ISQ::*;\n    import SI::*;\n    \n    part def Vehicle {\n        attribute mass : MassValue = 1200 [kg];\n        attribute length : LengthValue = 4.82 [m];\n        \n        part wheelAssemblies : WheelAssembly[4];\n    }\n    \n    part def WheelAssembly {\n        part wheel : Wheel;\n        part brakeDisc : BrakeDisc;\n        \n        constraint fitmentConstraint {\n            brakeDisc.diameter < wheel.outerDiameter\n        }\n    }\n    \n    part def Wheel {\n        part rim : Rim;\n        part tire : Tire;\n        \n        attribute outerDiameter : LengthValue = rim.diameter + 2 * tire.height;\n    }\n    \n    part def Rim {\n        attribute diameter : LengthValue = 18 [in];\n    }\n    \n    part def Tire {\n        attribute width : LengthValue = 245 [mm];\n        attribute height : LengthValue = 45 [mm];\n        attribute treadDepth : LengthValue = 6.0 [mm];\n        \n        constraint safetyRegulation {\n            treadDepth >= 3.5 [mm]\n        }\n    }\n    \n    part def BrakeDisc {\n        attribute radius : LengthValue = 95 [mm];\n        attribute diameter : LengthValue = 2 * radius;\n    }\n}",
    "package FuelSystemModel {\n    import ScalarValues::*;\n    \n    // Define item types\n    item def Fuel;\n    item def FuelTemperatureData;\n    \n    // Define interfaces\n    interface def FuelFlowInterface {\n        end supplierPort;\n        end consumerPort;\n        \n        flow of Fuel from supplierPort to consumerPort;\n    }\n    \n    interface def FuelReturnInterface {\n        end returnPort;\n        end receiverPort;\n        \n        flow of Fuel from returnPort to receiverPort;\n    }\n    \n    interface def TemperatureDataInterface {\n        end sensorPort;\n        end monitorPort;\n        \n        flow of FuelTemperatureData from sensorPort to monitorPort;\n    }\n    \n    // Define parts\n    part def FuelTank {\n        port fuelOutlet : FuelFlowInterface::supplierPort;\n        port fuelInlet : FuelReturnInterface::receiverPort;\n        port tempDataOut : TemperatureDataInterface::sensorPort;\n        \n        attribute capacity : Real;\n        attribute currentFuelLevel : Real;\n        attribute temperature : Real;\n    }\n    \n    part def FuelPump {\n        port fuelIn : FuelFlowInterface::consumerPort;\n        port fuelOut : FuelFlowInterface::supplierPort;\n        port returnIn : FuelReturnInterface::returnPort;\n        port tempSensor : TemperatureDataInterface::sensorPort;\n        \n        attribute pumpRate : Real;\n        attribute operatingPressure : Real;\n        \n        action pumpFuel {\n            in fuelInput : Fuel;\n            out fuelOutput : Fuel;\n        }\n        \n        action receiveReturn {\n            in returnedFuel : Fuel;\n        }\n    }\n    \n    part def FuelTankAssembly {\n        part tank : FuelTank;\n        part pump : FuelPump;\n        \n        port assemblyFuelOut : FuelFlowInterface::supplierPort;\n        port assemblyReturnIn : FuelReturnInterface::receiverPort;\n        port assemblyTempOut : TemperatureDataInterface::sensorPort;\n        \n        interface : FuelFlowInterface connect tank.fuelOutlet to pump.fuelIn;\n        interface : FuelFlowInterface connect pump.fuelOut to assemblyFuelOut;\n        interface : FuelReturnInterface connect assemblyReturnIn to pump.returnIn;\n        \n        bind assemblyTempOut = pump.tempSensor;\n    }\n    \n    part def Engine {\n        port fuelIn : FuelFlowInterface::consumerPort;\n        port fuelReturn : FuelReturnInterface::returnPort;\n        \n        action consumeFuel {\n            in fuel : Fuel;\n            out unusedFuel : Fuel;\n        }\n    }\n    \n    part def AutomotiveFuelSystem {\n        part fuelTankAssembly : FuelTankAssembly;\n        part engine : Engine;\n        \n        interface fuelSupply : FuelFlowInterface connect fuelTankAssembly.assemblyFuelOut to engine.fuelIn;\n        interface fuelReturn : FuelReturnInterface connect engine.fuelReturn to fuelTankAssembly.assemblyReturnIn;\n        \n        requirement efficientFuelCirculation {\n            doc /* Fuel shall circulate efficiently among all components */\n            verify fuelSupply.isOperational and fuelReturn.isOperational;\n        }\n        \n        requirement safeFuelHandling {\n            doc /* System shall ensure safe fuel handling */\n            assume fuelTankAssembly.tank.currentFuelLevel > 0;\n            require fuelTankAssembly.pump.operatingPressure <= 500; // kPa\n        }\n        \n        requirement temperatureMonitoring {\n            doc /* System shall monitor and transmit fuel temperature */\n            verify fuelTankAssembly.assemblyTempOut.isConnected;\n        }\n        \n        requirement normalEngineSupply {\n            doc /* System shall ensure normal fuel supply to engine */\n            require engine.fuelIn.isSupplied;\n        }\n    }\n}",
    "I'll analyze the requirements and create a SysML v2 model for a physical quantities and units management system.\n\n<scratchpad>\nKey functional requirements:\n- Support and manage data and units for physical quantities\n- Cover ISQ base quantities (length, mass, time, electric current, temperature, amount of substance, luminous intensity)\n- Allow import and extension capabilities\n- Ensure accurate representation of physical quantities\n- Maintain consistency of information\n- Facilitate data processing and unit conversion\n- Meet diverse user requirements\n\nKey non-functional requirements:\n- Accuracy\n- Consistency\n- Extensibility\n- Usability\n\nSysML v2 mapping:\n- Use package for organization\n- Define attribute definitions for base quantities\n- Create part definitions for system components\n- Use requirements for traceability\n- Define constraints for accuracy and consistency\n- Create actions for conversions\n- Use metadata for ISQ standards reference\n</scratchpad>\n\npackage PhysicalQuantityManagementSystem {\n    import ISQ::*;\n    import SI::*;\n    \n    attribute def PhysicalQuantity {\n        attribute value : Real;\n        attribute unit : Unit;\n        attribute dimension : PhysicalDimension;\n    }\n    \n    attribute def Unit {\n        attribute symbol : String;\n        attribute name : String;\n        attribute conversionFactor : Real;\n        attribute baseUnit : Unit[0..1];\n    }\n    \n    attribute def PhysicalDimension {\n        attribute length : Integer = 0;\n        attribute mass : Integer = 0;\n        attribute time : Integer = 0;\n        attribute electricCurrent : Integer = 0;\n        attribute temperature : Integer = 0;\n        attribute amountOfSubstance : Integer = 0;\n        attribute luminousIntensity : Integer = 0;\n    }\n    \n    part def QuantityManager {\n        attribute quantities : PhysicalQuantity[*];\n        \n        action convertUnit(in source : PhysicalQuantity, in targetUnit : Unit) : PhysicalQuantity {\n            assert constraint { source.dimension == targetUnit.dimension }\n        }\n        \n        action validateConsistency() : Boolean;\n        \n        action importQuantity(in external : PhysicalQuantity) : Boolean;\n        \n        action extendSystem(in newUnit : Unit, in newDimension : PhysicalDimension) : Boolean;\n    }\n    \n    part def UnitRegistry {\n        attribute registeredUnits : Unit[*];\n        attribute baseUnits : Unit[7];\n        \n        action registerUnit(in unit : Unit) : Boolean;\n        action findCompatibleUnits(in dimension : PhysicalDimension) : Unit[*];\n    }\n    \n    part def DataProcessor {\n        action processQuantityData(in data : PhysicalQuantity[*]) : PhysicalQuantity[*];\n        action aggregateQuantities(in quantities : PhysicalQuantity[*]) : PhysicalQuantity;\n    }\n    \n    part def PhysicalQuantitySystem {\n        part quantityManager : QuantityManager;\n        part unitRegistry : UnitRegistry;\n        part dataProcessor : DataProcessor;\n        \n        interface def QuantityInterface {\n            in item importData : PhysicalQuantity;\n            out item exportData : PhysicalQuantity;\n        }\n        \n        port quantityPort : QuantityInterface;\n        \n        connection : Connect(\n            quantityManager.quantities,\n            dataProcessor.processQuantityData.data\n        );\n    }\n    \n    requirement def SystemRequirements {\n        doc /* The system must support ISQ base quantities */\n        requirement supportISQQuantities {\n            subject system : PhysicalQuantitySystem;\n            assert constraint {\n                system.unitRegistry.baseUnits->size() == 7\n            }\n        }\n        \n        requirement accurateRepresentation {\n            doc /* Ensure accurate representation of physical quantities */\n            subject quantity : PhysicalQuantity;\n            assert constraint {\n                quantity.value != null and\n                quantity.unit != null and\n                quantity.dimension != null\n            }\n        }\n        \n        requirement consistencyMaintenance {\n            doc /* Maintain consistency of information */\n            subject manager : QuantityManager;\n            assert constraint {\n                manager.validateConsistency() == true\n            }\n        }\n        \n        requirement extensibility {\n            doc /* Allow import and extension */\n            subject system : PhysicalQuantitySystem;\n            verify test {\n                system.quantityManager.importQuantity != null and\n                system.quantityManager.extendSystem != null\n            }\n        }\n    }\n    \n    allocation allocate SystemRequirements::* to PhysicalQuantitySystem;\n}",
    "package UnitSystemLibrary {\n    import ISQ::*;\n    import SI::*;\n    import USCustomaryUnits::*;\n    \n    package 'Unit Management' {\n        part def UnitConverter {\n            attribute sourceUnit : ScalarValues::String;\n            attribute targetUnit : ScalarValues::String;\n            attribute conversionFactor : ScalarValues::Real;\n            \n            perform action convert {\n                in value : ScalarValues::Real;\n                out convertedValue : ScalarValues::Real;\n            }\n        }\n        \n        part def UnitRegistry {\n            attribute registeredUnits : ScalarValues::String[0..*];\n            attribute unitDefinitions : ScalarValues::String[0..*];\n            \n            perform action registerUnit {\n                in unitName : ScalarValues::String;\n                in unitDefinition : ScalarValues::String;\n            }\n            \n            perform action validateUnit {\n                in unitName : ScalarValues::String;\n                out isValid : ScalarValues::Boolean;\n            }\n        }\n        \n        part def MeasurementQuantity {\n            attribute value : ScalarValues::Real;\n            attribute unit : ScalarValues::String;\n            attribute dimension : ScalarValues::String;\n        }\n    }\n    \n    part def UnitSystemAdapter {\n        part isqInterface : ISQInterface;\n        part usCustomaryInterface : USCustomaryInterface;\n        part converter : UnitConverter;\n        \n        interface def ISQInterface {\n            end supplierPort : ~MeasurementPort;\n        }\n        \n        interface def USCustomaryInterface {\n            end consumerPort : MeasurementPort;\n        }\n        \n        port def MeasurementPort {\n            out measurement : MeasurementQuantity;\n        }\n        \n        connection : Connect connect isqInterface.supplierPort to converter.inputPort;\n        connection : Connect connect converter.outputPort to usCustomaryInterface.consumerPort;\n    }\n    \n    requirement def AccuracyRequirement {\n        doc /* Conversion accuracy shall maintain precision within 0.0001% */\n        attribute id = \"REQ-001\";\n        attribute text = \"System shall maintain conversion accuracy within 0.0001%\";\n    }\n    \n    requirement def StandardizationRequirement {\n        doc /* All units must conform to authoritative standards */\n        attribute id = \"REQ-002\";\n        attribute text = \"All unit definitions shall conform to ISO 80000 and NIST standards\";\n    }\n    \n    requirement def InteroperabilityRequirement {\n        doc /* System must support bidirectional conversion */\n        attribute id = \"REQ-003\";\n        attribute text = \"System shall support bidirectional conversion between ISQ and US Customary Units\";\n    }\n    \n    constraint def ConversionAccuracy {\n        attribute actualError : ScalarValues::Real;\n        attribute maxAllowedError : ScalarValues::Real = 0.00001;\n        assert constraint { actualError <= maxAllowedError }\n    }\n    \n    verification def VerifyConversionAccuracy {\n        subject converter : UnitConverter;\n        objective : AccuracyRequirement;\n        \n        return verdict : VerdictKind;\n    }\n    \n    enum def VerdictKind {\n        pass;\n        fail;\n        inconclusive;\n    }\n    \n    package ApplicationDomains {\n        part def EngineeringApplication {\n            part unitSystem : UnitSystemAdapter;\n            attribute domain = \"Engineering\";\n        }\n        \n        part def ScientificResearchApplication {\n            part unitSystem : UnitSystemAdapter;\n            attribute domain = \"Scientific Research\";\n        }\n        \n        part def DailyLifeApplication {\n            part unitSystem : UnitSystemAdapter;\n            attribute domain = \"Daily Life\";\n        }\n    }\n}",
    "package HeadlampTiltAdjustmentSystem {\n    import ISQ::*;\n    import SI::*;\n    import ScalarValues::*;\n    \n    attribute def TiltAngle :> ScalarQuantityValue {\n        attribute quantityDimension = ISQ::PlaneAngleDimension;\n        attribute measurementUnit = SI::degree;\n    }\n    \n    requirement def HeadlampTiltRequirement {\n        doc /* The tilt angle of the headlamp beam must be between 50 degrees and 80 degrees */\n        \n        attribute tiltAngle : TiltAngle;\n        \n        require constraint tiltAngleRange {\n            (tiltAngle.magnitude >= 50.0) and (tiltAngle.magnitude <= 80.0)\n        }\n    }\n    \n    part def HeadlampTiltAdjustmentKnob {\n        attribute currentTiltAngle : TiltAngle;\n        \n        port tiltOutput : ~TiltAngle;\n        \n        action adjustTilt {\n            in newAngle : TiltAngle;\n            out resultAngle : TiltAngle;\n            \n            bind currentTiltAngle = newAngle;\n            bind resultAngle = currentTiltAngle;\n            bind tiltOutput = currentTiltAngle;\n        }\n    }\n    \n    part def HeadlampBeam {\n        attribute beamTiltAngle : TiltAngle;\n        \n        port tiltInput : TiltAngle;\n        \n        bind beamTiltAngle = tiltInput;\n    }\n    \n    part def HeadlampTiltVerificationSystem {\n        part adjustmentKnob : HeadlampTiltAdjustmentKnob;\n        part headlampBeam : HeadlampBeam;\n        \n        interface : adjustmentKnob.tiltOutput to headlampBeam.tiltInput;\n        \n        satisfy requirement headlampTiltReq : HeadlampTiltRequirement {\n            bind tiltAngle = headlampBeam.beamTiltAngle;\n        }\n        \n        action verifyTiltAngle {\n            in measuredAngle : TiltAngle;\n            out isValid : Boolean;\n            \n            assert constraint validationCheck {\n                (measuredAngle.magnitude >= 50.0) and (measuredAngle.magnitude <= 80.0)\n            }\n            \n            bind isValid = validationCheck;\n        }\n    }\n}",
    "<scratchpad>\nLet me analyze the requirements step by step:\n\n1. Core data types needed:\n   - Unsigned integers (non-negative)\n   - Unsigned floating-point numbers (non-negative)\n   - Date-time\n   - String\n   - Boolean\n\n2. Color labeling system:\n   - Three status levels: critical, warning, normal\n   - Associated colors: red, yellow, green\n   - Need enumeration for both status and color\n   - Need association/mapping between them\n\n3. Physical dimensions:\n   - Diameter parameter in millimeters\n   - Three options: Small (60mm), Medium (70mm), Large (80mm)\n   - Default value: Small\n   - Need enumeration with associated values\n\n4. Design considerations:\n   - Future extensibility\n   - Value constraints enforcement\n   - Status-color association logic\n\nSysML v2 mapping:\n- Use `attribute def` for basic data types with constraints\n- Use `enum def` for enumerations\n- Use `attribute` for specific properties\n- Use constraints for value restrictions\n- Use metadata for units\n- Consider using functions or constraints for status-color mapping\n</scratchpad>\n\npackage DataManagementSystem {\n    import ScalarValues::*;\n    import ISQ::*;\n    import SI::*;\n    \n    attribute def UnsignedInteger :> Integer {\n        constraint { self >= 0 }\n    }\n    \n    attribute def UnsignedFloat :> Real {\n        constraint { self >= 0.0 }\n    }\n    \n    attribute def DateTime :> String;\n    \n    enum def StatusLevel {\n        enum critical;\n        enum warning;\n        enum normal;\n    }\n    \n    enum def StatusColor {\n        enum red;\n        enum yellow;\n        enum green;\n    }\n    \n    enum def DiameterSize {\n        enum small = 60;\n        enum medium = 70;\n        enum large = 80;\n    }\n    \n    attribute def Diameter :> LengthValue {\n        attribute size : DiameterSize default DiameterSize::small;\n        attribute :>> num = size;\n        attribute :>> mRef = mm;\n    }\n    \n    attribute def StatusMapping {\n        attribute level : StatusLevel;\n        attribute color : StatusColor;\n        \n        constraint statusColorAssociation {\n            (level == StatusLevel::critical) == (color == StatusColor::red) &\n            (level == StatusLevel::warning) == (color == StatusColor::yellow) &\n            (level == StatusLevel::normal) == (color == StatusColor::green)\n        }\n    }\n    \n    part def SystemDataTypes {\n        attribute unsignedInt : UnsignedInteger;\n        attribute unsignedFloat : UnsignedFloat;\n        attribute dateTime : DateTime;\n        attribute textData : String;\n        attribute flag : Boolean;\n        attribute diameter : Diameter;\n        attribute status : StatusMapping;\n    }\n}",
    "<scratchpad>\nLet me analyze the requirements step by step:\n\n1. Key functional/non-functional information:\n   - Manage spare parts as Bags (unordered, allows duplicates)\n   - Store integers as Lists (ordered, allows duplicates)\n   - Manage strings as Sets (unordered, no duplicates)\n   - Manage personnel using OrderedSets (ordered, no duplicates)\n   - Support nested collections: List<Set<Person>>\n   - Process real numbers as fixed-length arrays (length 4)\n   - Support integration and interaction with other business functions\n\n2. Mapping to SysML v2:\n   - Need to define item definitions for SparePart and Person\n   - Use attribute definitions with multiplicity and collection types\n   - Bag: unordered, nonunique\n   - List: ordered, nonunique\n   - Set: unordered, unique\n   - OrderedSet: ordered, unique\n   - Array[4]: fixed size array\n   - Define a part for the management system\n   - Include attributes for each collection type\n</scratchpad>\n\npackage CollectionManagementSystem {\n    \n    item def SparePart {\n        attribute id : String;\n        attribute name : String;\n        attribute quantity : Integer;\n    }\n    \n    item def Person {\n        attribute id : String;\n        attribute name : String;\n        attribute role : String;\n    }\n    \n    part def ManagementSystem {\n        attribute sparePartsBag : SparePart[*] unordered nonunique;\n        attribute integerList : Integer[*] ordered nonunique;\n        attribute stringSet : String[*] unordered unique;\n        attribute personnelOrderedSet : Person[*] ordered unique;\n        attribute nestedPersonSets : Set<Person>[*] ordered nonunique;\n        attribute realNumberArray : Real[4];\n        \n        action retrieveSparePartsByName(in searchName : String) : SparePart[*];\n        action addPersonToSet(in person : Person, inout targetSet : Person[*]);\n        action processRealNumbers(in numbers : Real[4]) : Real;\n    }\n    \n    part managementSystemInstance : ManagementSystem;\n}",
    "package TireInformationSystem {\n    import ScalarValues::*;\n    import Quantities::*;\n    import MeasurementReferences::*;\n    import ISQ::*;\n    import SI::*;\n    import USCustomaryUnits::*;\n    \n    attribute def ManufacturerName :> String;\n    \n    attribute def RimDiameter :> LengthValue {\n        attribute :>> num;\n        attribute :>> mRef = inch;\n    }\n    \n    attribute def TireWidth :> LengthValue {\n        attribute :>> num;\n        attribute :>> mRef = mm;\n    }\n    \n    attribute def Position3D {\n        attribute x :> LengthValue;\n        attribute y :> LengthValue;\n        attribute z :> LengthValue;\n    }\n    \n    item def Tire {\n        attribute manufacturer : ManufacturerName;\n        attribute rimDiameter : RimDiameter;\n        attribute width : TireWidth;\n        attribute installationPosition : Position3D[0..1];\n    }\n    \n    item michelinTire18x245 : Tire {\n        attribute :>> manufacturer = \"Michelin\";\n        attribute :>> rimDiameter {\n            :>> num = 18;\n        }\n        attribute :>> width {\n            :>> num = 245;\n        }\n    }\n}",
    "package SpacecraftAscentTrajectorySystem {\n    import ScalarValues::*;\n    import Quantities::*;\n    import MeasurementReferences::*;\n    import Time::*;\n    import SpaceTime::*;\n    import ISQ::*;\n    \n    attribute def UTCTimeStamp {\n        attribute year : Integer;\n        attribute month : Integer;\n        attribute day : Integer;\n        attribute hour : Integer;\n        attribute minute : Integer;\n        attribute second : Real;\n    }\n    \n    attribute def Position3D {\n        attribute x : LengthValue;\n        attribute y : LengthValue;\n        attribute z : LengthValue;\n    }\n    \n    attribute def Velocity3D {\n        attribute vx : SpeedValue;\n        attribute vy : SpeedValue;\n        attribute vz : SpeedValue;\n    }\n    \n    attribute def TrajectoryDataPoint {\n        attribute timeFromLiftoff : TimeValue;\n        attribute position : Position3D;\n        attribute velocity : Velocity3D;\n    }\n    \n    part def SpacecraftTrajectoryRecorder {\n        attribute missionLiftoffTime : UTCTimeStamp;\n        attribute trajectoryData : TrajectoryDataPoint[1..*] ordered;\n        \n        requirement collectTrajectoryData {\n            doc /* The system shall sample and record spacecraft trajectory during ascent phase */\n        }\n        \n        requirement useReferenceTime {\n            doc /* The system shall use mission liftoff time as reference time zero */\n            assume constraint { missionLiftoffTime.year == 2020 }\n            assume constraint { missionLiftoffTime.month == 8 }\n            assume constraint { missionLiftoffTime.day == 23 }\n            assume constraint { missionLiftoffTime.hour == 22 }\n            assume constraint { missionLiftoffTime.minute == 42 }\n            assume constraint { missionLiftoffTime.second == 32.924534 }\n        }\n        \n        requirement recordKeyParameters {\n            doc /* The system shall collect position and velocity at different time points */\n            require constraint { trajectoryData->forAll(dp | dp.position.x.unit == m) }\n            require constraint { trajectoryData->forAll(dp | dp.position.y.unit == m) }\n            require constraint { trajectoryData->forAll(dp | dp.position.z.unit == m) }\n            require constraint { trajectoryData->forAll(dp | dp.velocity.vx.unit == m/s) }\n            require constraint { trajectoryData->forAll(dp | dp.velocity.vy.unit == m/s) }\n            require constraint { trajectoryData->forAll(dp | dp.velocity.vz.unit == m/s) }\n        }\n        \n        requirement associateTimeWithData {\n            doc /* Each sampled data set must associate time point with position and velocity */\n            require constraint { trajectoryData->size() >= 1 }\n            require constraint { trajectoryData->forAll(dp | dp.timeFromLiftoff.unit == s) }\n        }\n        \n        action sampleTrajectory {\n            in currentTime : TimeValue;\n            in currentPosition : Position3D;\n            in currentVelocity : Velocity3D;\n            out dataPoint : TrajectoryDataPoint;\n            \n            bind dataPoint.timeFromLiftoff = currentTime;\n            bind dataPoint.position = currentPosition;\n            bind dataPoint.velocity = currentVelocity;\n        }\n    }\n}",
    "package AlloyManagementSystem {\n    import ISQ::*;\n    import SI::*;\n    import ScalarValues::*;\n    \n    // Define custom unit for tensile strength\n    attribute def TensileStrengthUnit :> DerivedUnit {\n        attribute lengthPowerFactor :> UnitPowerFactor {\n            attribute powerFactor :> Real = -2;\n            attribute unit :> SIDerivedUnit = m;\n        }\n        attribute forcePowerFactor :> UnitPowerFactor {\n            attribute powerFactor :> Real = 1;\n            attribute unit :> SIDerivedUnit = N;\n        }\n    }\n    \n    // Define tensile strength quantity\n    attribute def TensileStrengthValue :> ScalarQuantityValue {\n        attribute num :> Real;\n        attribute mRef :> MeasurementReference {\n            attribute unit = N/(mm**2);\n        }\n    }\n    \n    // Base substance definition\n    abstract item def Substance {\n        attribute name : String;\n        attribute atomicMass : MassValue;\n    }\n    \n    // Material definition extending substance\n    abstract item def Material :> Substance {\n        attribute tensileStrength : TensileStrengthValue;\n    }\n    \n    // Metal definition\n    item def Metal :> Material;\n    \n    // Alloy component with mass fraction\n    part def AlloyComponent {\n        ref material : Material;\n        attribute massFraction : Real {\n            assert constraint { 0.0 <= massFraction and massFraction <= 1.0 }\n        }\n    }\n    \n    // Alloy definition\n    item def Alloy :> Material {\n        part components : AlloyComponent[2..*];\n        \n        assert constraint sumToOne {\n            components.massFraction->sum() == 1.0\n        }\n    }\n    \n    // Define specific metals\n    item iron : Metal {\n        :>> name = \"Iron\";\n        :>> atomicMass = 55.845 [g/mol];\n        :>> tensileStrength = 200 [N/(mm**2)];\n    }\n    \n    item carbon : Metal {\n        :>> name = \"Carbon\";\n        :>> atomicMass = 12.011 [g/mol];\n        :>> tensileStrength = 130 [N/(mm**2)];\n    }\n    \n    item manganese : Metal {\n        :>> name = \"Manganese\";\n        :>> atomicMass = 54.938 [g/mol];\n        :>> tensileStrength = 650 [N/(mm**2)];\n    }\n    \n    // Define steel alloy instance\n    item steel980 : Alloy {\n        :>> name = \"Steel 980\";\n        :>> tensileStrength = 980 [N/(mm**2)];\n        \n        part :>> components {\n            part ironComponent : AlloyComponent {\n                :>> material = iron;\n                :>> massFraction = 0.982;\n            }\n            part carbonComponent : AlloyComponent {\n                :>> material = carbon;\n                :>> massFraction = 0.008;\n            }\n            part manganeseComponent : AlloyComponent {\n                :>> material = manganese;\n                :>> massFraction = 0.010;\n            }\n        }\n    }\n}",
    "package EngineeringMaterialsDatabase {\n    import ScalarValues::*;\n    import Quantities::*;\n    import MeasurementReferences::*;\n    import ISQ::*;\n    import SI::*;\n    \n    attribute def AtomicMassValue :> ScalarQuantityValue {\n        attribute quantityDimension :>> num = 1;\n        attribute measurementReference :>> mRef = kg;\n    }\n    \n    attribute def MassFractionValue :> ScalarQuantityValue {\n        attribute quantityDimension :>> num = 1;\n        attribute measurementReference :>> mRef = one;\n    }\n    \n    attribute def TensileStrengthValue :> ScalarQuantityValue {\n        attribute quantityDimension :>> num = 1;\n        attribute measurementReference :>> mRef = N / mm^2;\n    }\n    \n    abstract part def Material {\n        attribute name : String;\n        attribute atomicMass : AtomicMassValue;\n    }\n    \n    part def Element :> Material;\n    \n    part def Alloy :> Material {\n        part constituents : Constituent[1..*];\n        \n        constraint {\n            sum(constituents.massFraction.num) == 1.0\n        }\n    }\n    \n    part def Constituent {\n        ref material : Material;\n        attribute massFraction : MassFractionValue;\n    }\n    \n    abstract part def MechanicalProperties {\n        attribute tensileStrength : TensileStrengthValue;\n    }\n    \n    part def Metal :> Material {\n        part mechanicalProperties : MechanicalProperties;\n    }\n    \n    part def MetalAlloy :> Alloy, Metal;\n    \n    part iron : Element {\n        :>> name = \"Iron\";\n        :>> atomicMass = 55.845 [kg];\n    }\n    \n    part carbon : Element {\n        :>> name = \"Carbon\";\n        :>> atomicMass = 12.011 [kg];\n    }\n    \n    part manganese : Element {\n        :>> name = \"Manganese\";\n        :>> atomicMass = 54.938 [kg];\n    }\n    \n    part steel_980 : MetalAlloy {\n        :>> name = \"Steel_980\";\n        \n        part :>> constituents {\n            part ironConstituent : Constituent {\n                :>> material = iron;\n                :>> massFraction = 0.982;\n            }\n            part carbonConstituent : Constituent {\n                :>> material = carbon;\n                :>> massFraction = 0.008;\n            }\n            part manganeseConstituent : Constituent {\n                :>> material = manganese;\n                :>> massFraction = 0.010;\n            }\n        }\n        \n        part :>> mechanicalProperties {\n            :>> tensileStrength = 980 [N / mm^2];\n        }\n    }\n}",
    "package PubSubSystem {\n    import ScalarValues::*;\n    \n    part def Message {\n        attribute content : String;\n        attribute timestamp : String;\n        attribute messageId : String;\n    }\n    \n    part def Topic {\n        attribute name : String;\n        attribute description : String;\n    }\n    \n    part def Publisher {\n        attribute publisherId : String;\n        attribute name : String;\n    }\n    \n    part def Subscriber {\n        attribute subscriberId : String;\n        attribute name : String;\n    }\n    \n    part def MessageBroker {\n        attribute brokerId : String;\n        port publishPort : PublishInterface;\n        port subscribePort : SubscribeInterface;\n        port deliveryPort : DeliveryInterface;\n        \n        private attribute topicRegistry : Topic[0..*];\n        private attribute subscriptionRegistry : Subscription[0..*];\n    }\n    \n    part def Subscription {\n        ref subscriber : Subscriber;\n        ref topic : Topic;\n        attribute subscriptionTime : String;\n    }\n    \n    interface def PublishInterface {\n        in item publishedMessage : Message;\n        in item targetTopic : Topic;\n        out item acknowledgment : Boolean;\n    }\n    \n    interface def SubscribeInterface {\n        in item subscriptionRequest : SubscriptionRequest;\n        out item subscriptionConfirmation : Boolean;\n    }\n    \n    interface def DeliveryInterface {\n        out item deliveredMessage : Message;\n        out item deliveryTopic : Topic;\n        in item deliveryAcknowledgment : Boolean;\n    }\n    \n    item def SubscriptionRequest {\n        attribute subscriberId : String;\n        attribute topicName : String;\n    }\n    \n    action def PublishMessage {\n        in publisher : Publisher;\n        in message : Message;\n        in topic : Topic;\n        out success : Boolean;\n        \n        bind publishAction.publishPort.publishedMessage = message;\n        bind publishAction.publishPort.targetTopic = topic;\n        \n        action publishAction : SendMessage {\n            in publishPort : PublishInterface;\n        }\n        \n        then action receiveAck {\n            out success : Boolean;\n        }\n    }\n    \n    action def SubscribeToTopic {\n        in subscriber : Subscriber;\n        in topic : Topic;\n        out success : Boolean;\n        \n        action createRequest {\n            out request : SubscriptionRequest;\n        }\n        \n        then action sendSubscription {\n            in subscribePort : SubscribeInterface;\n        }\n        \n        then action receiveConfirmation {\n            out success : Boolean;\n        }\n    }\n    \n    action def DistributeMessage {\n        in message : Message;\n        in topic : Topic;\n        in subscriptions : Subscription[0..*];\n        \n        action identifySubscribers {\n            in topic : Topic;\n            in subscriptions : Subscription[0..*];\n            out targetSubscribers : Subscriber[0..*];\n        }\n        \n        then action deliverToSubscribers {\n            in message : Message;\n            in subscribers : Subscriber[0..*];\n            \n            for subscriber in subscribers {\n                perform deliverMessage {\n                    in deliveryPort : DeliveryInterface;\n                    in message : Message;\n                    in topic : Topic;\n                }\n            }\n        }\n    }\n    \n    part pubSubSystem : PubSubSystem {\n        part broker : MessageBroker;\n        part publishers : Publisher[0..*];\n        part subscribers : Subscriber[0..*];\n        \n        connection publishConnection : PublisherToBroker \n            connect publishers.publishPort to broker.publishPort;\n            \n        connection subscribeConnection : SubscriberToBroker\n            connect subscribers.subscribePort to broker.subscribePort;\n            \n        connection deliveryConnection : BrokerToSubscriber\n            connect broker.deliveryPort to subscribers.deliveryPort;\n    }\n    \n    requirement def MessageDeliveryRequirement {\n        doc /* When a producer publishes a new message, the server must promptly \n        receive and distribute it to corresponding subscribers */\n        \n        subject broker : MessageBroker;\n        \n        require constraint {\n            when (broker.publishPort.publishedMessage != null) {\n                broker.deliveryPort.deliveredMessage == broker.publishPort.publishedMessage\n            }\n        }\n    }\n    \n    requirement def DecouplingRequirement {\n        doc /* Users only need to declare topics to subscribe without knowing \n        specific publishers or other subscribers */\n        \n        subject system : PubSubSystem;\n        \n        require constraint {\n            subscribers.subscribePort.subscriptionRequest.topicName != null and\n            subscribers.subscribePort.subscriptionRequest.publisherId == null\n        }\n    }\n    \n    requirement def EfficiencyRequirement {\n        doc /* Efficient processing of message subscription, publishing, \n        and distribution flows */\n        \n        subject broker : MessageBroker;\n        attribute maxProcessingTime : Real;\n        \n        require constraint {\n            broker.processingTime <= maxProcessingTime\n        }\n    }\n}",
    "package FuelSystem {\n    import ScalarValues::*;\n    \n    part def FuelTankAssembly {\n        attribute fuelLevel : Real;\n        attribute fuelTemperature : Real;\n        \n        port fuelSupplyPort : FuelFlow;\n        port fuelReturnPort : ~FuelFlow;\n    }\n    \n    part def Engine {\n        attribute fuelConsumptionRate : Real;\n        \n        port fuelInletPort : ~FuelFlow;\n        port fuelReturnPort : FuelFlow;\n    }\n    \n    part def FuelLine {\n        attribute flowRate : Real;\n        attribute pressure : Real;\n    }\n    \n    interface def FuelFlow {\n        attribute flowRate : Real;\n        attribute temperature : Real;\n        attribute pressure : Real;\n    }\n    \n    part vehicleFuelSystem {\n        part fuelTank : FuelTankAssembly;\n        part engine : Engine;\n        part supplyLine : FuelLine;\n        part returnLine : FuelLine;\n        \n        interface fuelSupplyInterface : FuelFlow connect fuelTank.fuelSupplyPort to engine.fuelInletPort;\n        interface fuelReturnInterface : FuelFlow connect engine.fuelReturnPort to fuelTank.fuelReturnPort;\n        \n        action fuelCirculation {\n            action supplyFuel {\n                in source : FuelTankAssembly = fuelTank;\n                out target : Engine = engine;\n                \n                bind source.fuelSupplyPort = fuelSupplyInterface;\n            }\n            \n            action returnUnusedFuel {\n                in source : Engine = engine;\n                out target : FuelTankAssembly = fuelTank;\n                \n                bind source.fuelReturnPort = fuelReturnInterface;\n            }\n            \n            flow from supplyFuel.target to returnUnusedFuel.source;\n            flow from returnUnusedFuel.target to supplyFuel.source;\n        }\n        \n        requirement continuousFuelSupply {\n            doc /* The system shall provide continuous and stable fuel supply during vehicle operation */\n            \n            require constraint { fuelTank.fuelLevel > 0 }\n        }\n        \n        requirement temperatureMonitoring {\n            doc /* The system shall monitor and transmit fuel temperature information */\n            \n            subject fuelTank : FuelTankAssembly;\n            \n            require constraint { fuelTank.fuelTemperature >= -40 and fuelTank.fuelTemperature <= 85 }\n        }\n        \n        requirement fuelRecycling {\n            doc /* The system shall effectively recycle excess fuel */\n            \n            verify requirement { returnLine.flowRate >= 0 }\n        }\n    }\n}",
    "package PubSubSystem {\n    import ScalarValues::*;\n    \n    part def Producer {\n        port messageOut : MessagePort;\n        \n        action publishMessage {\n            in topic : String;\n            in content : String;\n            out message : Message;\n        }\n    }\n    \n    part def Consumer {\n        port messageIn : MessagePort;\n        port subscriptionOut : SubscriptionPort;\n        \n        action subscribe {\n            in topic : String;\n            out subscription : Subscription;\n        }\n        \n        action receiveMessage {\n            in message : Message;\n        }\n    }\n    \n    part def Server {\n        port messageIn : MessagePort;\n        port messageOut : MessagePort[0..*];\n        port subscriptionIn : SubscriptionPort[0..*];\n        \n        attribute subscriptions : Subscription[0..*];\n        \n        action processSubscription {\n            in subscription : Subscription;\n        }\n        \n        action processMessage {\n            in message : Message;\n        }\n        \n        action distributeMessage {\n            in message : Message;\n            in subscribers : Consumer[0..*];\n        }\n    }\n    \n    item def Message {\n        attribute topic : String;\n        attribute content : String;\n        attribute timestamp : String;\n    }\n    \n    item def Subscription {\n        attribute topic : String;\n        attribute consumerId : String;\n    }\n    \n    port def MessagePort {\n        out item message : Message;\n    }\n    \n    port def SubscriptionPort {\n        out item subscription : Subscription;\n    }\n    \n    part pubSubSystem : PubSubSystem {\n        part producers : Producer[1..*];\n        part server : Server;\n        part consumers : Consumer[1..*];\n        \n        interface producerToServer connect producers.messageOut to server.messageIn;\n        interface consumerToServer connect consumers.subscriptionOut to server.subscriptionIn;\n        interface serverToConsumer connect server.messageOut to consumers.messageIn;\n        \n        action systemOperation {\n            action consumerSubscription {\n                perform consumers.subscribe;\n                then server.processSubscription;\n            }\n            \n            action messagePublishing {\n                perform producers.publishMessage;\n                then server.processMessage;\n                then server.distributeMessage;\n            }\n        }\n    }\n}",
    "package TransportationSystem {\n    import ScalarValues::*;\n    \n    part def Vehicle {\n        attribute maxPassengers : Integer = 4;\n        attribute maxFuelCapacity : Real;\n        attribute currentFuelLevel : Real;\n        attribute fuelWarningThreshold : Real = 0.1;\n        \n        port driverEntry : ~PersonEntry;\n        port passengerEntry : ~PersonEntry[0..4];\n        port fuelIntake : FuelFlow;\n    }\n    \n    part def Person {\n        attribute role : String;\n    }\n    \n    part def Driver :> Person {\n        attribute role : String = \"driver\";\n    }\n    \n    part def Passenger :> Person {\n        attribute role : String = \"passenger\";\n    }\n    \n    part def GasStation {\n        port fuelOutput : ~FuelFlow;\n    }\n    \n    part def Environment {\n        attribute conditions : String;\n    }\n    \n    interface def PersonEntry {\n        end supplierPort : Person;\n        end consumerPort : Vehicle;\n    }\n    \n    interface def FuelFlow {\n        end source : GasStation;\n        end target : Vehicle;\n        flow of fuel : Real;\n    }\n    \n    use case def ProvideTransportation {\n        subject vehicle : Vehicle;\n        actor driver : Driver;\n        actor passengers : Passenger[0..4];\n        actor gasStation : GasStation;\n        actor environment : Environment;\n        \n        include enterVehicle : EnterVehicle;\n        include operateVehicle : OperateVehicle;\n        include refuelVehicle : RefuelVehicle;\n        include exitVehicle : ExitVehicle;\n    }\n    \n    use case def EnterVehicle {\n        subject vehicle : Vehicle;\n        actor driver : Driver;\n        actor passengers : Passenger[0..*];\n    }\n    \n    use case def OperateVehicle {\n        subject vehicle : Vehicle;\n        actor driver : Driver;\n        \n        constraint {\n            doc /* Driver operates vehicle to complete travel tasks */\n        }\n    }\n    \n    use case def RefuelVehicle {\n        subject vehicle : Vehicle;\n        actor driver : Driver;\n        actor gasStation : GasStation;\n        \n        precondition fuelLow {\n            vehicle.currentFuelLevel < (vehicle.maxFuelCapacity * vehicle.fuelWarningThreshold)\n        }\n        \n        postcondition fuelReplenished {\n            vehicle.currentFuelLevel > (vehicle.maxFuelCapacity * vehicle.fuelWarningThreshold)\n        }\n    }\n    \n    use case def ExitVehicle {\n        subject vehicle : Vehicle;\n        actor driver : Driver;\n        actor passengers : Passenger[0..*];\n        \n        postcondition allExited {\n            doc /* All individuals exit vehicle safely */\n        }\n    }\n    \n    requirement def TransportationRequirements {\n        doc /* System shall provide transportation services for users */\n        \n        requirement userCapacity {\n            doc /* System shall accommodate driver and up to 4 passengers */\n            require constraint {\n                vehicle.maxPassengers == 4\n            }\n        }\n        \n        requirement fuelMonitoring {\n            doc /* System shall monitor fuel level and enable refueling when below 10% */\n            require constraint {\n                vehicle.fuelWarningThreshold == 0.1\n            }\n        }\n        \n        requirement environmentalConsideration {\n            doc /* System shall take environmental factors into account */\n        }\n        \n        requirement safeBoarding {\n            doc /* System shall ensure smooth boarding and alighting of all occupants */\n        }\n        \n        requirement efficientTravel {\n            doc /* System shall guarantee efficient and safe travel experience */\n        }\n    }\n}",
    "package FuelManagementSystem {\n    import ScalarValues::*;\n    \n    attribute def Temperature;\n    attribute def FlowRate;\n    \n    port def FuelPort {\n        attribute fuelTemp : Temperature;\n        attribute flowRate : FlowRate;\n    }\n    \n    part def FuelTankAssembly {\n        port fuelOutlet : FuelPort;\n        port fuelReturn : FuelPort;\n        \n        attribute capacity : Real;\n        attribute currentLevel : Real;\n    }\n    \n    part def EngineUnit {\n        port fuelInlet : FuelPort;\n        port fuelReturnOut : FuelPort;\n        \n        attribute fuelConsumptionRate : FlowRate;\n    }\n    \n    interface def FuelInterface {\n        end supplierPort : FuelPort;\n        end consumerPort : FuelPort;\n    }\n    \n    part vehicleFuelSystem {\n        part fuelTank : FuelTankAssembly;\n        part engine : EngineUnit;\n        \n        interface fuelSupplyInterface : FuelInterface connect \n            supplierPort ::> fuelTank.fuelOutlet to\n            consumerPort ::> engine.fuelInlet;\n            \n        interface fuelReturnInterface : FuelInterface connect\n            supplierPort ::> engine.fuelReturnOut to\n            consumerPort ::> fuelTank.fuelReturn;\n            \n        requirement continuousFuelSupply {\n            doc /* The system shall provide continuous fuel supply to the engine */\n            require constraint { fuelTank.currentLevel > 0 }\n        }\n        \n        requirement bidirectionalFlow {\n            doc /* The system shall support both fuel supply and return flow */\n        }\n        \n        requirement realTimeMonitoring {\n            doc /* The system shall monitor fuel temperature and flow parameters in real time */\n        }\n    }\n}",
    "package FuelSystemManagement {\n    import ScalarValues::*;\n    \n    attribute def Temperature {\n        attribute value : Real;\n        attribute unit : String = \"°C\";\n    }\n    \n    item def Fuel {\n        attribute temperature : Temperature;\n    }\n    \n    flow def FuelFlow {\n        ref item fuel : Fuel;\n    }\n    \n    port def FuelPort {\n        out flow fuelSupply : FuelFlow;\n        in flow fuelReturn : FuelFlow;\n    }\n    \n    port def EnginePort {\n        in flow fuelIn : FuelFlow;\n        out flow fuelOut : FuelFlow;\n    }\n    \n    part def FuelTankAssembly {\n        port fuelInterface : FuelPort;\n        \n        attribute currentFuelTemperature : Temperature;\n        \n        action supplyFuel {\n            out item suppliedFuel : Fuel;\n            bind suppliedFuel.temperature = currentFuelTemperature;\n            flow suppliedFuel to fuelInterface.fuelSupply.fuel;\n        }\n        \n        action receiveFuel {\n            in item returnedFuel : Fuel;\n            flow returnedFuel from fuelInterface.fuelReturn.fuel;\n        }\n    }\n    \n    part def Engine {\n        port fuelInterface : EnginePort;\n        \n        action consumeFuel {\n            in item incomingFuel : Fuel;\n            out item unusedFuel : Fuel;\n            flow incomingFuel from fuelInterface.fuelIn.fuel;\n            flow unusedFuel to fuelInterface.fuelOut.fuel;\n        }\n    }\n    \n    part def VehicleFuelSystem {\n        part fuelTank : FuelTankAssembly;\n        part engine : Engine;\n        \n        interface fuelConnection connect fuelTank.fuelInterface to engine.fuelInterface {\n            flow fuelTank.fuelInterface.fuelSupply to engine.fuelInterface.fuelIn;\n            flow engine.fuelInterface.fuelOut to fuelTank.fuelInterface.fuelReturn;\n        }\n        \n        requirement efficientFuelSupply {\n            doc /* The system shall provide efficient fuel supply from tank to engine */\n        }\n        \n        requirement efficientFuelReturn {\n            doc /* The system shall provide efficient fuel return from engine to tank */\n        }\n        \n        requirement temperatureMonitoring {\n            doc /* Each fuel interface shall provide current fuel temperature information */\n        }\n        \n        requirement reliability {\n            doc /* The system shall ensure reliable fuel delivery during normal vehicle operation */\n        }\n        \n        requirement safety {\n            doc /* The system shall meet safety requirements for fuel handling */\n        }\n        \n        requirement fuelFlowTracking {\n            doc /* The system shall track fuel flow information during supply and return processes */\n        }\n    }\n}",
    "I'll analyze this requirement and create a SysML v2 model for a camera/photo capture system.\n\n<scratchpad>\nKey functional requirements extracted:\n1. User selects a scene to capture\n2. System automatically performs focusing on selected scene\n3. System generates an intermediate image (after focusing)\n4. System captures final photo based on focused image\n5. System outputs final photo to user\n6. Process is automatic without manual intervention\n\nKey non-functional requirements:\n- Automation (no manual intervention required)\n- Photos should meet user requirements\n\nSysML v2 mapping:\n- Package for overall system\n- Part definitions for main components (Camera System, User, Scene)\n- Action definitions for key behaviors (select scene, auto focus, generate image, capture photo)\n- Item definitions for data flow (Scene Selection, Focused Image, Final Photo)\n- Usage scenarios to show the workflow\n- Requirements to capture the stated needs\n</scratchpad>\n\npackage PhotoCaptureSystem {\n    import ScalarValues::*;\n    \n    item def SceneSelection {\n        attribute targetArea : String;\n        attribute timestamp : String;\n    }\n    \n    item def FocusedImage {\n        attribute focusQuality : Real;\n        attribute imageData : String;\n    }\n    \n    item def Photo {\n        attribute resolution : String;\n        attribute format : String;\n        attribute imageData : String;\n    }\n    \n    part def Camera {\n        attribute focalLength : Real;\n        attribute aperture : Real;\n        \n        action autoFocus {\n            in scene : SceneSelection;\n            out focusedImg : FocusedImage;\n        }\n        \n        action capturePhoto {\n            in focusedImg : FocusedImage;\n            out finalPhoto : Photo;\n        }\n    }\n    \n    part def User {\n        action selectScene {\n            out selection : SceneSelection;\n        }\n        \n        action receivePhoto {\n            in photo : Photo;\n        }\n    }\n    \n    part def PhotoCaptureSystemDef {\n        part user : User;\n        part camera : Camera;\n        \n        action performPhotoCapture {\n            action userSelectsScene : User::selectScene {\n                out selection;\n            }\n            \n            flow from userSelectsScene.selection to autoFocusing.scene;\n            \n            action autoFocusing : Camera::autoFocus {\n                in scene;\n                out focusedImg;\n            }\n            \n            flow from autoFocusing.focusedImg to photoCapturing.focusedImg;\n            \n            action photoCapturing : Camera::capturePhoto {\n                in focusedImg;\n                out finalPhoto;\n            }\n            \n            flow from photoCapturing.finalPhoto to userReceivesPhoto.photo;\n            \n            action userReceivesPhoto : User::receivePhoto {\n                in photo;\n            }\n            \n            first userSelectsScene then autoFocusing;\n            first autoFocusing then photoCapturing;\n            first photoCapturing then userReceivesPhoto;\n        }\n    }\n    \n    requirement def AutomaticOperation {\n        doc /* The system shall complete focusing and shooting processes \n               automatically without manual intervention */\n        subject sys : PhotoCaptureSystemDef;\n    }\n    \n    requirement def UserPhotoObtainment {\n        doc /* The system shall enable users to obtain photos from \n               real-world scenes */\n        subject sys : PhotoCaptureSystemDef;\n    }\n    \n    requirement def AutoFocusRequirement {\n        doc /* The system shall automatically perform focusing for \n               the selected scene */\n        subject camera : Camera;\n    }\n    \n    requirement def IntermediateImageGeneration {\n        doc /* The system shall generate an intermediate image \n               after focusing */\n        subject camera : Camera;\n    }\n    \n    requirement def FinalPhotoCapture {\n        doc /* The system shall capture and output the final photo \n               based on the focused image */\n        subject camera : Camera;\n    }\n}",
    "package PhotographySystem {\n    \n    part def Camera;\n    part def Scene;\n    part def Image;\n    part def FocusedImage :> Image;\n    part def FinalPhotograph :> Image;\n    \n    action def SelectScene {\n        in scene : Scene;\n        out selectedScene : Scene;\n    }\n    \n    action def PerformFocusing {\n        in scene : Scene;\n        out focusedImage : FocusedImage;\n    }\n    \n    action def PerformShooting {\n        in focusedImage : FocusedImage;\n        out finalPhoto : FinalPhotograph;\n    }\n    \n    action def PhotographyWorkflow {\n        in inputScene : Scene;\n        out outputPhoto : FinalPhotograph;\n        \n        action selectScene : SelectScene {\n            in scene = inputScene;\n        }\n        \n        action focusing : PerformFocusing {\n            in scene = selectScene.selectedScene;\n        }\n        \n        action shooting : PerformShooting {\n            in focusedImage = focusing.focusedImage;\n        }\n        \n        flow selectScene.selectedScene to focusing.scene;\n        flow focusing.focusedImage to shooting.focusedImage;\n        bind outputPhoto = shooting.finalPhoto;\n        \n        first selectScene then focusing then shooting;\n    }\n    \n    part photographySystem : Camera {\n        perform PhotographyWorkflow;\n    }\n    \n    requirement def ClearFocusRequirement {\n        doc /* Image must achieve clear focus before shooting */\n        subject focusedImage : FocusedImage;\n    }\n    \n    requirement def HighQualityOutputRequirement {\n        doc /* System must produce high-quality photo output */\n        subject finalPhoto : FinalPhotograph;\n    }\n    \n    requirement def SequentialProcessRequirement {\n        doc /* Workflow must complete sequentially through focusing and shooting steps */\n        subject workflow : PhotographyWorkflow;\n    }\n    \n    requirement def EfficientOperationRequirement {\n        doc /* System operation must be concise and coherent for efficient photo acquisition */\n        subject system : Camera;\n    }\n}",
    "I'll analyze the photography workflow system requirements and create a SysML v2 model.\n\n<scratchpad>\nKey functional requirements identified:\n1. User selects a scene\n2. System performs focusing on selected scene\n3. System generates an image from focusing\n4. System performs shooting based on the image\n5. System produces final photograph\n6. Workflow is automatic (no manual intermediate steps)\n\nKey non-functional requirements:\n1. High-quality photographs\n2. Convenient for users\n3. Automatic workflow\n\nSysML v2 mapping:\n- Package for overall system\n- Part definitions for main components (Camera System, User)\n- Action definitions for key processes (select scene, focus, generate image, shoot, produce photo)\n- Item definitions for data flow (Scene, Image, Photograph)\n- Usage for the complete workflow\n- Constraints for quality requirements\n</scratchpad>\n\npackage PhotographyWorkflowSystem {\n    \n    item def Scene;\n    item def Image;\n    item def Photograph {\n        attribute quality : String;\n    }\n    \n    part def User {\n        action selectScene : Scene;\n    }\n    \n    part def CameraSystem {\n        action focus {\n            in scene : Scene;\n            out image : Image;\n        }\n        \n        action shoot {\n            in image : Image;\n            out photograph : Photograph;\n        }\n    }\n    \n    action def CaptureWorkflow {\n        in selectedScene : Scene;\n        out finalPhotograph : Photograph;\n        \n        action userSelection : User::selectScene {\n            out scene = selectedScene;\n        }\n        \n        action focusing : CameraSystem::focus {\n            in scene = userSelection.scene;\n            out focusedImage;\n        }\n        \n        action shooting : CameraSystem::shoot {\n            in image = focusing.focusedImage;\n            out photo;\n        }\n        \n        bind finalPhotograph = shooting.photo;\n        \n        flow from userSelection to focusing;\n        flow from focusing to shooting;\n    }\n    \n    part photographySystem : CameraSystem;\n    part systemUser : User;\n    \n    usage workflow : CaptureWorkflow {\n        constraint {\n            doc /* Workflow must be automatic without manual intermediate steps */\n        }\n        \n        constraint {\n            shooting.photo.quality == \"high\"\n        }\n    }\n}",
    "<scratchpad>\nLet me analyze the requirement step by step:\n\nKey functional information:\n1. System automates photography process\n2. User provides shooting scene as input\n3. System performs focus processing on the scene\n4. System generates an image suitable for shooting\n5. System converts the image into a photograph through shooting operation\n6. Process is seamlessly integrated\n7. No user intervention needed for focusing/shooting details\n\nKey non-functional information:\n1. Simplifies photography workflow\n2. Easy and efficient for users\n3. Automated process\n\nMapping to SysML v2:\n- Package for organizing the model\n- Part definitions for main components (AutomatedPhotographySystem, FocusProcessor, ImageCapture)\n- Item definitions for data flow (Scene, FocusedImage, Photograph)\n- Action definitions for behaviors (providesScene, focusProcessing, imageCapture)\n- Usage/allocation to show the integrated system\n- Requirements to capture the non-functional aspects\n</scratchpad>\n\npackage AutomatedPhotographySystem {\n    \n    item def Scene;\n    item def FocusedImage;\n    item def Photograph;\n    \n    part def User {\n        out port sceneOutput : Scene;\n    }\n    \n    part def FocusProcessor {\n        in port sceneInput : Scene;\n        out port focusedImageOutput : FocusedImage;\n        \n        action focusProcessing {\n            in scene : Scene;\n            out focusedImage : FocusedImage;\n        }\n    }\n    \n    part def ImageCapture {\n        in port focusedImageInput : FocusedImage;\n        out port photographOutput : Photograph;\n        \n        action shootImage {\n            in image : FocusedImage;\n            out photo : Photograph;\n        }\n    }\n    \n    part def AutomatedPhotographySystem {\n        part user : User;\n        part focusProcessor : FocusProcessor;\n        part imageCapture : ImageCapture;\n        \n        interface : user.sceneOutput to focusProcessor.sceneInput;\n        interface : focusProcessor.focusedImageOutput to imageCapture.focusedImageInput;\n        \n        action automatedPhotography {\n            action provideScene : user::sceneOutput;\n            then action processFocus : focusProcessor::focusProcessing;\n            then action capturePhoto : imageCapture::shootImage;\n            \n            flow provideScene.out to processFocus.scene;\n            flow processFocus.focusedImage to capturePhoto.image;\n        }\n    }\n    \n    requirement def SeamlessIntegration {\n        doc /* The system shall provide seamless integration between focus processing \n             and image capture without user intervention */\n    }\n    \n    requirement def SimplifiedWorkflow {\n        doc /* The system shall simplify the photography workflow by automating \n             focus and shooting details */\n    }\n    \n    requirement def UserEfficiency {\n        doc /* The system shall enable users to obtain photographs easily \n             and efficiently */\n    }\n    \n    satisfy SeamlessIntegration by AutomatedPhotographySystem;\n    satisfy SimplifiedWorkflow by AutomatedPhotographySystem;\n    satisfy UserEfficiency by AutomatedPhotographySystem;\n}",
    "package PhotographyWorkflow {\n    import ScalarValues::*;\n    \n    part def Scene;\n    part def Image;\n    part def Picture;\n    \n    action def Focus {\n        in scene : Scene;\n        out image : Image;\n    }\n    \n    action def Shoot {\n        in focusedImage : Image;\n        out photograph : Picture;\n    }\n    \n    action def PhotographyProcess {\n        in inputScene : Scene;\n        out outputPicture : Picture;\n        \n        action focus : Focus {\n            in scene = inputScene;\n        }\n        \n        action shoot : Shoot {\n            in focusedImage = focus.image;\n        }\n        \n        bind outputPicture = shoot.photograph;\n    }\n    \n    part photographySystem {\n        perform PhotographyProcess;\n    }\n}",
    "I'll analyze this photography workflow requirement and create a SysML v2 model.\n\n<scratchpad>\nKey functional requirements extracted:\n1. Select a scene\n2. Focus on the scene\n3. Check if focus is clear\n4. Take photo if focus is clear\n5. Generate final image\n6. Sequential operation (focus then shoot)\n7. One-click operation\n\nKey non-functional requirements:\n1. Ensure optimal image sharpness\n2. Ensure clarity and quality\n3. Convenient user experience\n4. Automatic operation\n\nSysML v2 mapping:\n- Use case: Photography workflow\n- Actions: select scene, focus, check focus, take photo, generate image\n- States: scene selected, focusing, focused, shooting, image generated\n- Constraints: focus must be clear before shooting\n- Sequence: focus → check → shoot\n</scratchpad>\n\npackage 'Photography System' {\n    import ScalarValues::*;\n    \n    part def Camera {\n        attribute focusClarity : Boolean;\n        attribute imageQuality : String;\n    }\n    \n    part def Scene {\n        attribute isSelected : Boolean;\n    }\n    \n    part def Image {\n        attribute sharpness : Real;\n        attribute quality : String;\n    }\n    \n    use case def 'Capture Photograph' {\n        subject camera : Camera;\n        objective {\n            doc /* Provide convenient one-click shooting experience \n                   while ensuring photo clarity and quality */\n        }\n        \n        include use case selectScene : 'Select Scene';\n        include use case focusScene : 'Focus Scene';\n        include use case checkFocus : 'Check Focus Clarity';\n        include use case takePhoto : 'Take Photo';\n        include use case generateImage : 'Generate Final Image';\n        \n        assert constraint {\n            doc /* Focus must be clear before taking photo */\n        }\n    }\n    \n    action def PhotographyWorkflow {\n        in scene : Scene;\n        out finalImage : Image;\n        \n        action selectScene {\n            in inputScene : Scene;\n            out selectedScene : Scene {\n                :>> isSelected = true;\n            }\n        }\n        \n        action focusOnScene {\n            in selectedScene : Scene;\n            out focusResult : Camera {\n                :>> focusClarity;\n            }\n        }\n        \n        action checkFocusClarity {\n            in focus : Camera;\n            out isClear : Boolean = focus.focusClarity;\n        }\n        \n        action capturePhoto {\n            in focusedScene : Scene;\n            out capturedImage : Image;\n        }\n        \n        action generateFinalImage {\n            in capturedImage : Image;\n            out finalImage : Image {\n                :>> quality = \"high\";\n            }\n        }\n        \n        flow from selectScene.selectedScene to focusOnScene.selectedScene;\n        flow from focusOnScene.focusResult to checkFocusClarity.focus;\n        \n        succession selectScene then focusOnScene;\n        succession focusOnScene then checkFocusClarity;\n        \n        if checkFocusClarity.isClear {\n            succession checkFocusClarity then capturePhoto;\n            succession capturePhoto then generateFinalImage;\n            flow from selectScene.selectedScene to capturePhoto.focusedScene;\n            flow from capturePhoto.capturedImage to generateFinalImage.capturedImage;\n            flow from generateFinalImage.finalImage to finalImage;\n        }\n    }\n    \n    requirement def ImageQualityRequirement {\n        doc /* System shall ensure optimal image sharpness and quality */\n        subject camera : Camera;\n        \n        require constraint {\n            camera.focusClarity == true before camera.imageQuality == \"captured\";\n        }\n    }\n    \n    requirement def UserExperienceRequirement {\n        doc /* System shall provide convenient one-click shooting experience */\n        subject workflow : PhotographyWorkflow;\n        \n        attribute executionMode : String = \"automatic\";\n        attribute userInteraction : String = \"one-click\";\n    }\n}",
    "package 'Photography System' {\n    import ScalarValues::*;\n    \n    part def Scene;\n    part def FocusedImage;\n    part def Photograph;\n    \n    attribute def FocusQuality :> Boolean;\n    \n    action def SelectScene {\n        in scene : Scene;\n        out selectedScene : Scene;\n    }\n    \n    action def PerformFocusing {\n        in scene : Scene;\n        out focusedImage : FocusedImage;\n    }\n    \n    action def EvaluateFocusQuality {\n        in image : FocusedImage;\n        out isWellFocused : FocusQuality;\n    }\n    \n    action def ConvertToPhotograph {\n        in focusedImage : FocusedImage;\n        out photograph : Photograph;\n    }\n    \n    action def CapturePhotograph {\n        in userScene : Scene;\n        out finalPhoto : Photograph;\n        \n        action selectScene : SelectScene {\n            in scene = userScene;\n        }\n        \n        action focus : PerformFocusing {\n            in scene = selectScene.selectedScene;\n        }\n        \n        action evaluateQuality : EvaluateFocusQuality {\n            in image = focus.focusedImage;\n        }\n        \n        action shoot : ConvertToPhotograph {\n            in focusedImage = focus.focusedImage;\n        } if evaluateQuality.isWellFocused;\n        \n        bind finalPhoto = shoot.photograph;\n        \n        flow from selectScene.selectedScene to focus.scene;\n        flow from focus.focusedImage to evaluateQuality.image;\n        flow from focus.focusedImage to shoot.focusedImage;\n    }\n    \n    part photographySystem {\n        perform action photographyWorkflow : CapturePhotograph;\n        \n        requirement focusBeforeShooting {\n            doc /* Shooting shall only occur when focus quality is determined to be appropriate */\n        }\n        \n        requirement automaticWorkflow {\n            doc /* The system shall automatically link the workflow from scene input to photo output */\n        }\n        \n        requirement imageQuality {\n            doc /* The system shall improve clarity and quality of resulting photographs through focus validation */\n        }\n    }\n}",
    "package PhotographyWorkflowSystem {\n    \n    part def Camera {\n        attribute currentScene : SceneData;\n        attribute focusedImage : ImageData;\n        attribute finalPhoto : PhotoData;\n    }\n    \n    part def SceneData;\n    part def ImageData;\n    part def PhotoData;\n    \n    action def AcquireScene {\n        out scene : SceneData;\n    }\n    \n    action def PerformFocus {\n        in scene : SceneData;\n        out focusedImage : ImageData;\n    }\n    \n    action def ExecuteShoot {\n        in image : ImageData;\n        out photo : PhotoData;\n    }\n    \n    action def DisplayPhoto {\n        in photo : PhotoData;\n    }\n    \n    action def TakePhotoWorkflow {\n        action acquireScene : AcquireScene;\n        then action performFocus : PerformFocus {\n            in scene = acquireScene.scene;\n        }\n        then action executeShoot : ExecuteShoot {\n            in image = performFocus.focusedImage;\n        }\n        then action displayPhoto : DisplayPhoto {\n            in photo = executeShoot.photo;\n        }\n    }\n    \n    part cameraSystem : Camera {\n        perform takePhoto : TakePhotoWorkflow;\n    }\n    \n    requirement def AutomatedWorkflow {\n        doc /* The system shall automatically complete all steps after user triggers take photo operation */\n        satisfy cameraSystem.takePhoto;\n    }\n    \n    requirement def SeamlessIntegration {\n        doc /* The entire process shall be seamlessly integrated without manual intervention */\n        satisfy cameraSystem.takePhoto;\n    }\n}",
    "<scratchpad>\nLet me analyze the requirement step by step:\n\n1. Key functional information:\n- System provides automatic braking control\n- Activates when key turned to start position\n- Monitors brake pedal status\n- Monitors traction information (road adhesion)\n- Detects brake pressure from driver input\n- Evaluates traction variations\n- Adjusts brake pressure\n- Adjusts modulation frequency\n- Operates automatically without intervention\n\n2. Key non-functional information:\n- Safe and reliable braking performance\n- Enhanced driving safety\n- Enhanced comfort\n- Optimal state operation\n- Continuous monitoring\n- Dynamic regulation\n\n3. SysML v2 mapping:\n- Package for overall system\n- Part definitions for major components\n- Actions for behaviors\n- Requirements for constraints\n- Interfaces for interactions\n- States for system modes\n- Attributes for properties\n- Item flows for information exchange\n</scratchpad>\n\npackage AutomaticBrakingControlSystem {\n    \n    part def Vehicle;\n    part def BrakingControlSystem;\n    part def BrakePedal;\n    part def TractionSensor;\n    part def BrakeActuator;\n    part def IgnitionSwitch;\n    \n    item def BrakePressure;\n    item def TractionData;\n    item def ModulationFrequency;\n    item def KeyPosition;\n    \n    requirement def SafeBrakingPerformance {\n        doc /* The system shall provide safe and reliable braking performance under various operating conditions */\n    }\n    \n    requirement def AutomaticOperation {\n        doc /* The system shall operate automatically without user intervention */\n    }\n    \n    requirement def ContinuousMonitoring {\n        doc /* The system shall continuously monitor brake pedal status and traction information */\n    }\n    \n    action def MonitorBrakePedal {\n        in brakePedalStatus;\n        out detectedPressure : BrakePressure;\n    }\n    \n    action def MonitorTraction {\n        in roadConditions;\n        out tractionInfo : TractionData;\n    }\n    \n    action def AdjustBraking {\n        in currentPressure : BrakePressure;\n        in tractionVariation : TractionData;\n        out adjustedPressure : BrakePressure;\n        out modulationFreq : ModulationFrequency;\n    }\n    \n    part vehicleSystem : Vehicle {\n        part brakingControl : BrakingControlSystem {\n            attribute isActive : Boolean;\n            \n            part ignition : IgnitionSwitch {\n                attribute keyPosition : String;\n            }\n            \n            part brakePedal : BrakePedal {\n                attribute pedalPressure : Real;\n            }\n            \n            part tractionSensor : TractionSensor {\n                attribute roadAdhesion : Real;\n            }\n            \n            part brakeActuator : BrakeActuator {\n                attribute appliedPressure : Real;\n                attribute modulationFrequency : Real;\n            }\n            \n            perform monitorPedal : MonitorBrakePedal;\n            perform monitorTraction : MonitorTraction;\n            perform adjustBraking : AdjustBraking;\n            \n            state systemStates {\n                entry state off;\n                state active {\n                    entry action {\n                        assign isActive := true;\n                    }\n                    do action {\n                        perform monitorPedal;\n                        perform monitorTraction;\n                        perform adjustBraking;\n                    }\n                }\n                \n                transition activation\n                    first off\n                    then active\n                    when ignition.keyPosition == \"START\";\n            }\n            \n            flow of BrakePressure from brakePedal to monitorPedal.brakePedalStatus;\n            flow of TractionData from tractionSensor to monitorTraction.roadConditions;\n            flow of BrakePressure from monitorPedal.detectedPressure to adjustBraking.currentPressure;\n            flow of TractionData from monitorTraction.tractionInfo to adjustBraking.tractionVariation;\n            flow of BrakePressure from adjustBraking.adjustedPressure to brakeActuator;\n            flow of ModulationFrequency from adjustBraking.modulationFreq to brakeActuator;\n            \n            satisfy requirement SafeBrakingPerformance by adjustBraking;\n            satisfy requirement AutomaticOperation by systemStates;\n            satisfy requirement ContinuousMonitoring by monitorPedal, monitorTraction;\n        }\n    }\n}",
    "package BatteryChargingControlSystem {\n    import ScalarValues::*;\n    \n    part def Battery {\n        attribute currentLevel : Real;\n        attribute maxCapacity : Real = 100.0;\n        \n        port powerInput : PowerPort;\n        port statusOutput : StatusPort;\n    }\n    \n    part def ChargingController {\n        attribute isCharging : Boolean = false;\n        attribute targetLevel : Real = 100.0;\n        \n        port powerControl : PowerPort;\n        port batteryStatus : StatusPort;\n        port chargerControl : ChargerPort;\n    }\n    \n    part def Charger {\n        attribute isActive : Boolean = false;\n        attribute chargingRate : Real;\n        \n        port powerSupply : PowerPort;\n        port controlInput : ChargerPort;\n    }\n    \n    port def PowerPort {\n        attribute voltage : Real;\n        attribute current : Real;\n    }\n    \n    port def StatusPort {\n        attribute batteryLevel : Real;\n        attribute chargingStatus : Boolean;\n    }\n    \n    port def ChargerPort {\n        attribute enableCharging : Boolean;\n    }\n    \n    part batteryChargingSystem : BatteryChargingControlSystem {\n        part battery : Battery;\n        part controller : ChargingController;\n        part charger : Charger;\n        \n        interface : PowerInterface connect charger.powerSupply to battery.powerInput;\n        interface : StatusInterface connect battery.statusOutput to controller.batteryStatus;\n        interface : ChargerInterface connect controller.chargerControl to charger.controlInput;\n        \n        requirement automaticCharging {\n            doc /* System shall automatically supply charge when battery level is below 100% */\n            verify batteryLevelMonitoring;\n        }\n        \n        requirement chargingTermination {\n            doc /* System shall automatically terminate charging when battery level reaches or exceeds 100% */\n            verify chargingControl;\n        }\n        \n        requirement noManualIntervention {\n            doc /* System shall operate without manual intervention */\n        }\n        \n        action batteryLevelMonitoring {\n            in batteryStatus : StatusPort;\n            out chargingDecision : Boolean;\n            \n            if (batteryStatus.batteryLevel < 100.0) {\n                chargingDecision = true;\n            } else {\n                chargingDecision = false;\n            }\n        }\n        \n        action chargingControl {\n            in shouldCharge : Boolean;\n            out chargerCommand : ChargerPort;\n            \n            chargerCommand.enableCharging = shouldCharge;\n        }\n        \n        state batteryState {\n            entry state idle;\n            state charging;\n            state full;\n            \n            transition idle_to_charging\n                first idle\n                accept batteryLevel : Real when batteryLevel < 100.0\n                then charging;\n                \n            transition charging_to_full\n                first charging\n                accept batteryLevel : Real when batteryLevel >= 100.0\n                then full;\n                \n            transition full_to_charging\n                first full\n                accept batteryLevel : Real when batteryLevel < 100.0\n                then charging;\n        }\n    }\n    \n    interface def PowerInterface {\n        end supplier : PowerPort;\n        end consumer : PowerPort;\n    }\n    \n    interface def StatusInterface {\n        end source : StatusPort;\n        end receiver : StatusPort;\n    }\n    \n    interface def ChargerInterface {\n        end controller : ChargerPort;\n        end charger : ChargerPort;\n    }\n}",
    "package BatteryChargingSystem {\n    \n    part def BatteryChargingController {\n        attribute batteryLevel : Real;\n        attribute isCharging : Boolean = false;\n        \n        action monitorBatteryLevel {\n            out currentLevel : Real;\n        }\n        \n        action startCharging {\n            doc /* Initiates the charging process */\n        }\n        \n        action stopCharging {\n            doc /* Terminates the charging process */\n        }\n        \n        action replenishBattery {\n            doc /* Performs battery replenishment */\n        }\n    }\n    \n    part def Battery {\n        attribute currentLevel : Real;\n        attribute maxLevel : Real = 100.0;\n    }\n    \n    part batteryChargingSystem : BatteryChargingController {\n        part battery : Battery;\n        \n        requirement continuousMonitoring {\n            doc /* The system shall continuously monitor the battery level during charging */\n            verify by analysis;\n        }\n        \n        requirement automaticReplenishment {\n            doc /* The system shall automatically replenish the battery when level is below 100% */\n            verify by test;\n        }\n        \n        requirement automaticTermination {\n            doc /* The system shall automatically terminate charging when battery level reaches or exceeds 100% */\n            verify by test;\n        }\n        \n        requirement noManualIntervention {\n            doc /* The system shall operate fully automated without manual intervention */\n            verify by inspection;\n        }\n        \n        requirement preventOvercharging {\n            doc /* The system shall prevent battery overcharging */\n            verify by test;\n        }\n        \n        state chargingStateMachine {\n            entry state idle;\n            state monitoring;\n            state charging;\n            state terminated;\n            \n            transition idle_to_monitoring\n                first idle\n                then monitoring\n                guard isCharging;\n            \n            transition monitoring_to_charging\n                first monitoring\n                then charging\n                guard batteryLevel < 100.0;\n            \n            transition charging_to_monitoring\n                first charging\n                then monitoring;\n            \n            transition monitoring_to_terminated\n                first monitoring\n                then terminated\n                guard batteryLevel >= 100.0;\n        }\n        \n        action chargingProcess {\n            first start;\n            then loop {\n                action : monitorBatteryLevel {\n                    out batteryLevel;\n                }\n                \n                if batteryLevel < 100.0 {\n                    then action : replenishBattery;\n                } else {\n                    then done;\n                }\n            }\n            then action : stopCharging;\n        }\n    }\n}",
    "I'll analyze the requirements and create a SysML v2 model for the camera system.\n\n<scratchpad>\nKey functional requirements extracted:\n1. Camera function to take photos of various scenes\n2. Automatic focusing on objects within scenes\n3. Imaging process to capture photos\n4. User selects/confirms scene\n5. System obtains clear and realistic image through autofocus\n6. Imaging subsystem captures image as photograph\n7. All photos are recorded and saved\n8. User doesn't need to know internal details\n9. Camera automatically completes focusing and imaging\n10. Generates high-quality photos\n\nKey non-functional requirements:\n1. Image quality: clear and realistic\n2. Automation: automatic focusing and imaging\n3. Usability: hide internal technical details from user\n4. Output quality: high-quality photos\n\nSysML v2 mapping:\n- Package for overall system\n- Part definitions for Camera, AutofocusSubsystem, ImagingSubsystem\n- Item definitions for Scene, Photo, Image\n- Action definitions for focusing, imaging, saving\n- Requirements for functional and non-functional aspects\n- Interfaces between user and system\n- State machines for camera operation flow\n</scratchpad>\n\npackage CameraSystem {\n    import ScalarValues::*;\n    \n    item def Scene {\n        attribute id : String;\n        attribute description : String;\n    }\n    \n    item def Image {\n        attribute clarity : Real;\n        attribute quality : String;\n    }\n    \n    item def Photo {\n        attribute id : String;\n        attribute timestamp : String;\n        attribute image : Image;\n    }\n    \n    part def AutofocusSubsystem {\n        in item selectedScene : Scene;\n        out item focusedImage : Image;\n        \n        action focus {\n            in scene : Scene;\n            out image : Image;\n        }\n    }\n    \n    part def ImagingSubsystem {\n        in item focusedImage : Image;\n        out item capturedPhoto : Photo;\n        \n        action capture {\n            in image : Image;\n            out photo : Photo;\n        }\n    }\n    \n    part def StorageSubsystem {\n        in item photo : Photo;\n        \n        action save {\n            in photoToSave : Photo;\n        }\n    }\n    \n    part def Camera {\n        part autofocus : AutofocusSubsystem;\n        part imaging : ImagingSubsystem;\n        part storage : StorageSubsystem;\n        \n        port userInterface {\n            in item sceneSelection : Scene;\n            out item generatedPhoto : Photo;\n        }\n        \n        action takePhoto {\n            in scene : Scene;\n            out photo : Photo;\n            \n            bind scene = autofocus.selectedScene;\n            \n            action step focusOnScene : autofocus.focus {\n                in scene = scene;\n                out image;\n            }\n            then action step captureImage : imaging.capture {\n                in image = focusOnScene.image;\n                out photo;\n            }\n            then action step savePhoto : storage.save {\n                in photoToSave = captureImage.photo;\n            }\n            \n            bind photo = captureImage.photo;\n        }\n    }\n    \n    requirement def ImageQualityRequirement {\n        doc /* The system shall produce clear and realistic images */\n        attribute clarity : Real;\n        require constraint { clarity >= 0.95 }\n    }\n    \n    requirement def AutomationRequirement {\n        doc /* The system shall automatically complete focusing and imaging operations */\n        subject camera : Camera;\n        require constraint { camera.autofocus.focus.isAutomatic == true }\n    }\n    \n    requirement def UsabilityRequirement {\n        doc /* Users shall not need to concern themselves with internal technical details */\n        subject camera : Camera;\n    }\n    \n    requirement def PhotoStorageRequirement {\n        doc /* All photos taken shall be recorded and saved by the system */\n        subject storage : StorageSubsystem;\n    }\n    \n    usage cameraSystemUsage : Camera {\n        satisfy requirement imageQuality : ImageQualityRequirement;\n        satisfy requirement automation : AutomationRequirement;\n        satisfy requirement usability : UsabilityRequirement;\n        satisfy requirement photoStorage : PhotoStorageRequirement;\n    }\n}",
    "I'll analyze the requirements and create a SysML v2 model for the digital camera shooting system.\n\n<scratchpad>\nKey functional requirements extracted:\n1. User selects shooting scene\n2. Camera automatically focuses on selected scene\n3. System generates image that meets requirements\n4. Imaging module captures and produces final photo\n5. Process is fully automated (no manual focus/imaging)\n6. All modules collaborate for complete shooting process\n\nKey non-functional requirements:\n1. Simple operation (single operation)\n2. Efficient shooting experience\n3. Convenient shooting experience\n4. High-quality photo output\n\nSysML v2 mapping:\n- Package for overall system\n- Part definitions for main components (Camera, User, Scene, FocusModule, ImagingModule)\n- Actions for key behaviors (selectScene, autoFocus, generateImage, capturePhoto)\n- Requirements for functional and non-functional aspects\n- Interfaces for module interactions\n- States for system operation modes\n</scratchpad>\n\npackage DigitalCameraSystem {\n    import ScalarValues::*;\n    import ISQ::*;\n    import SI::*;\n    \n    requirement def CameraSystemRequirements {\n        doc /* The digital camera system shall enable automated shooting process */\n        \n        requirement singleOperationReq {\n            doc /* Users shall complete entire shooting procedure with single operation */\n        }\n        \n        requirement autoFocusReq {\n            doc /* Camera shall automatically focus on selected scene */\n        }\n        \n        requirement imageQualityReq {\n            doc /* System shall output high-quality photos */\n        }\n        \n        requirement efficiencyReq {\n            doc /* System shall ensure efficient and convenient shooting experience */\n        }\n    }\n    \n    part def Scene {\n        attribute sceneType : String;\n        attribute lightingConditions : Real;\n        attribute distance : Real;\n    }\n    \n    part def FocusModule {\n        attribute focalLength : Real;\n        attribute aperture : Real;\n        \n        action autoFocus(in targetScene : Scene) : Boolean;\n    }\n    \n    part def ImagingModule {\n        attribute sensorResolution : Real;\n        attribute imageFormat : String;\n        \n        action captureImage() : Image;\n        action processImage(in rawImage : Image) : Image;\n    }\n    \n    item def Image {\n        attribute resolution : Real;\n        attribute quality : String;\n        attribute format : String;\n    }\n    \n    part def Camera {\n        part focusModule : FocusModule;\n        part imagingModule : ImagingModule;\n        \n        port userInterface : UserInterface;\n        port sceneInput : SceneInterface;\n        \n        action performShooting(in selectedScene : Scene) : Image {\n            first start;\n            then action focus : Boolean = focusModule.autoFocus(selectedScene);\n            then action capture : Image = imagingModule.captureImage();\n            then action process : Image = imagingModule.processImage(capture);\n            then done;\n        }\n    }\n    \n    interface def UserInterface {\n        end userEnd;\n        end cameraEnd;\n        \n        flow userEnd.selectedScene : Scene to cameraEnd.selectedScene : Scene;\n        flow cameraEnd.finalPhoto : Image to userEnd.finalPhoto : Image;\n    }\n    \n    interface def SceneInterface {\n        end sceneEnd;\n        end cameraEnd;\n        \n        flow sceneEnd.sceneData : Scene to cameraEnd.sceneData : Scene;\n    }\n    \n    part def User {\n        action selectScene() : Scene;\n        action receivePhoto(in photo : Image);\n    }\n    \n    part digitalCameraSystem : Camera {\n        satisfy requirement CameraSystemRequirements;\n        \n        state shootingStates {\n            entry state idle;\n            state focusing;\n            state imaging;\n            state processing;\n            state complete;\n            \n            transition idle_to_focusing\n                first idle\n                accept selectedScene : Scene\n                then focusing;\n                \n            transition focusing_to_imaging\n                first focusing\n                guard focusModule.autoFocus\n                then imaging;\n                \n            transition imaging_to_processing\n                first imaging\n                then processing;\n                \n            transition processing_to_complete\n                first processing\n                then complete;\n                \n            transition complete_to_idle\n                first complete\n                then idle;\n        }\n    }\n    \n    usage cameraOperation : Camera {\n        part user : User;\n        part scene : Scene;\n        \n        connect user.userInterface to cameraOperation.userInterface;\n        connect scene.sceneInterface to cameraOperation.sceneInput;\n        \n        action shootingSequence {\n            first action userSelectsScene : Scene = user.selectScene();\n            then action cameraShoot : Image = cameraOperation.performShooting(userSelectsScene);\n            then action userReceives = user.receivePhoto(cameraShoot);\n        }\n    }\n}",
    "<scratchpad>\nLet me analyze the requirement step by step:\n\n1. Key functional information:\n   - System simulates a vehicle moving in 1D\n   - Predicts position over time based on power input\n   - Takes inputs: mass, initial position, initial velocity, time interval, power sequence\n   - Calculates speed and position sequentially\n   - Outputs position trajectory\n\n2. Key non-functional information:\n   - One-dimensional straight path constraint\n   - Time-varying power input\n   - Sequential calculation requirement\n\n3. Mapping to SysML v2:\n   - Need a package to contain the model\n   - Define parts for the vehicle and simulation system\n   - Define attributes for mass, position, velocity, time interval\n   - Define ports for power input and position output\n   - Define actions for calculating speed and position\n   - Define constraints for 1D motion\n   - Define item definitions for data types\n</scratchpad>\n\npackage VehicleMotionSimulation {\n    import ScalarValues::*;\n    import ISQ::*;\n    import SI::*;\n    \n    item def PowerProfile {\n        attribute timeSteps : Real[*] ordered;\n        attribute powerValues : PowerValue[*] ordered;\n    }\n    \n    item def TrajectoryData {\n        attribute timePoints : Real[*] ordered;\n        attribute positions : LengthValue[*] ordered;\n    }\n    \n    part def Vehicle {\n        attribute mass : MassValue;\n        attribute position : LengthValue;\n        attribute velocity : SpeedValue;\n        attribute acceleration : AccelerationValue;\n        \n        port powerInput : PowerValue;\n    }\n    \n    part def SimulationController {\n        attribute timeStep : TimeValue;\n        attribute currentTime : TimeValue = 0 [s];\n        \n        port powerSequenceInput : PowerProfile;\n        port trajectoryOutput : TrajectoryData;\n    }\n    \n    part def VehicleMotionSimulator {\n        part vehicle : Vehicle;\n        part controller : SimulationController;\n        \n        attribute initialPosition : LengthValue;\n        attribute initialVelocity : SpeedValue;\n        \n        action simulate {\n            in vehicleMass : MassValue;\n            in initPos : LengthValue;\n            in initVel : SpeedValue;\n            in deltaT : TimeValue;\n            in powerProfile : PowerProfile;\n            out trajectory : TrajectoryData;\n            \n            bind vehicle.mass = vehicleMass;\n            bind vehicle.position = initPos;\n            bind vehicle.velocity = initVel;\n            bind controller.timeStep = deltaT;\n            \n            action step stepCalculation[1..*] {\n                in power : PowerValue;\n                in dt : TimeValue;\n                \n                calc force : ForceValue = power / vehicle.velocity;\n                calc vehicle.acceleration : AccelerationValue = force / vehicle.mass;\n                calc vehicle.velocity : SpeedValue = vehicle.velocity + vehicle.acceleration * dt;\n                calc vehicle.position : LengthValue = vehicle.position + vehicle.velocity * dt;\n            }\n        }\n        \n        constraint oneDimensionalMotion {\n            doc /* Vehicle moves only along a straight path */\n        }\n    }\n}",
    "package CameraSystem {\n    import ScalarValues::*;\n    \n    part def Camera {\n        attribute id : String;\n        attribute status : String;\n    }\n    \n    part def Display {\n        attribute resolution : String;\n        attribute brightness : Real;\n    }\n    \n    part def Scene {\n        attribute lighting : String;\n        attribute distance : Real;\n    }\n    \n    part def Image {\n        attribute format : String;\n        attribute quality : String;\n        attribute focusLevel : Real;\n    }\n    \n    part def Photo {\n        attribute timestamp : String;\n        attribute size : String;\n        attribute image : Image;\n    }\n    \n    part def User {\n        attribute name : String;\n    }\n    \n    part def CameraSystemContext {\n        part user : User;\n        part camera : Camera;\n        part display : Display;\n        \n        interface def UserCameraInterface {\n            end userPort;\n            end cameraPort;\n        }\n        \n        interface : UserCameraInterface connect user to camera;\n    }\n    \n    action def InputScene {\n        in scene : Scene;\n        out sceneData : Scene;\n    }\n    \n    action def PerformFocusing {\n        in scene : Scene;\n        out focusedImage : Image;\n    }\n    \n    action def CaptureImage {\n        in image : Image;\n        out photo : Photo;\n    }\n    \n    action def DisplayPhoto {\n        in photo : Photo;\n        in display : Display;\n    }\n    \n    action def ShootAndDisplay {\n        in inputScene : Scene;\n        in displayDevice : Display;\n        \n        action inputSceneAction : InputScene {\n            in scene = inputScene;\n        }\n        \n        action focusAction : PerformFocusing {\n            in scene = inputSceneAction.sceneData;\n        }\n        \n        action captureAction : CaptureImage {\n            in image = focusAction.focusedImage;\n        }\n        \n        action displayAction : DisplayPhoto {\n            in photo = captureAction.photo;\n            in display = displayDevice;\n        }\n        \n        flow inputSceneAction.sceneData to focusAction.scene;\n        flow focusAction.focusedImage to captureAction.image;\n        flow captureAction.photo to displayAction.photo;\n    }\n    \n    requirement def AutomaticProcessing {\n        doc /* The system shall automatically process scene, generate image, \n               and display photo seamlessly without manual intervention between steps */\n    }\n    \n    requirement def ImmediateDisplay {\n        doc /* The system shall display the captured photo immediately after capture */\n    }\n    \n    requirement def SimpleShooting {\n        doc /* The user shall be able to complete the entire shooting process \n               with a simple operation */\n    }\n}",
    "I'll analyze this camera system requirement and create a SysML v2 model.\n\n<scratchpad>\nKey functional information extracted:\n1. User selects a scene through viewfinder (viewPort)\n2. System focuses on the scene to obtain an image\n3. Image is captured to generate a photograph (Picture)\n4. Photograph is displayed on screen via display port\n5. Process is automatic after user selection\n\nKey components/parts:\n- Camera system\n- Viewfinder (viewPort)\n- Display port (displayPort)\n- User (external actor)\n\nKey items/data:\n- Scene\n- Image\n- Picture (photograph)\n\nKey actions/behaviors:\n- Select scene\n- Focus\n- Capture\n- Display\n\nFlow sequence:\n1. User selects scene → 2. System focuses → 3. Obtains image → 4. Captures to create picture → 5. Displays picture\n\nSysML v2 mapping:\n- Use part definitions for components\n- Use item definitions for data elements\n- Use action definitions for behaviors\n- Use usage for instances\n- Use flow connections for data flow\n- Use succession for temporal ordering\n</scratchpad>\n\npackage CameraSystem {\n    \n    item def Scene;\n    item def Image;\n    item def Picture;\n    \n    part def Camera {\n        port viewPort;\n        port displayPort;\n        \n        action def focus {\n            in scene : Scene;\n            out image : Image;\n        }\n        \n        action def capture {\n            in image : Image;\n            out picture : Picture;\n        }\n        \n        action def display {\n            in picture : Picture;\n        }\n    }\n    \n    part def User {\n        action def selectScene {\n            out scene : Scene;\n        }\n    }\n    \n    part cameraSystem : Camera {\n        perform action photographyWorkflow {\n            in item userScene : Scene;\n            \n            action focusing : focus {\n                in scene = userScene;\n            }\n            then action capturing : capture {\n                in image = focusing.image;\n            }\n            then action displaying : display {\n                in picture = capturing.picture;\n            }\n            \n            flow focusing.image to capturing.image;\n            flow capturing.picture to displaying.picture;\n        }\n    }\n    \n    part user : User;\n    \n    interface def CameraUserInterface {\n        end userEnd : User;\n        end cameraEnd : Camera;\n    }\n    \n    interface : CameraUserInterface connect user to cameraSystem {\n        flow user.selectScene.scene to cameraSystem.photographyWorkflow.userScene;\n    }\n}",
    "package SensorManagementSystem {\n    import ScalarValues::*;\n    \n    part def Sensor {\n        attribute id : String;\n        attribute status : SensorStatus;\n        attribute lastUpdateTime : String;\n    }\n    \n    enum def SensorStatus {\n        enum ready;\n        enum busy;\n        enum offline;\n        enum updating;\n    }\n    \n    part def SensorManager {\n        part sensors : Sensor[0..*];\n        \n        action monitorSensors {\n            in sensors : Sensor[0..*];\n            out sensorsToUpdate : Sensor[0..*];\n            \n            action traverseSensors {\n                for sensor in sensors {\n                    if (sensor.status == SensorStatus::ready) {\n                        then sensorsToUpdate = sensorsToUpdate + sensor;\n                    }\n                }\n            }\n        }\n        \n        action updateSensor {\n            in sensor : Sensor;\n            out updatedSensor : Sensor;\n            \n            first sensor.status := SensorStatus::updating;\n            then performUpdate;\n            then sensor.status := SensorStatus::ready;\n            then sensor.lastUpdateTime := currentTime;\n            then updatedSensor := sensor;\n        }\n        \n        action performUpdate;\n        \n        action manageSensors {\n            loop {\n                perform monitorSensors(sensors, sensorsToUpdate);\n                for sensor in sensorsToUpdate {\n                    perform updateSensor(sensor, updatedSensor);\n                }\n            }\n        }\n    }\n    \n    requirement def MultiSensorSupport {\n        doc /* The system shall support managing multiple sensors */\n        subject sensorManager : SensorManager;\n        require constraint { sensorManager.sensors.size() >= 0 }\n    }\n    \n    requirement def AutomaticMonitoring {\n        doc /* The system shall automatically monitor sensor status */\n        subject sensorManager : SensorManager;\n    }\n    \n    requirement def ReadyStateDetection {\n        doc /* The system shall detect sensors in ready state */\n        subject sensorManager : SensorManager;\n    }\n    \n    requirement def AutomaticUpdate {\n        doc /* The system shall automatically update ready sensors */\n        subject sensorManager : SensorManager;\n    }\n    \n    requirement def TraversalCapability {\n        doc /* The system shall traverse all registered sensors */\n        subject sensorManager : SensorManager;\n    }\n    \n    requirement def TimelyProcessing {\n        doc /* The system shall promptly process sensors meeting ready condition */\n        subject sensorManager : SensorManager;\n    }\n    \n    requirement def SystemResponsiveness {\n        doc /* The system shall enhance overall responsiveness */\n        subject sensorManager : SensorManager;\n    }\n    \n    requirement def SystemReliability {\n        doc /* The system shall enhance overall reliability */\n        subject sensorManager : SensorManager;\n    }\n}",
    "I'll analyze this vehicle start-up and shutdown system requirement step by step.\n\n<scratchpad>\nKey functional information extracted:\n1. System manages vehicle start-up and shutdown states\n2. States identified:\n   - off (initial state)\n   - starting\n   - on\n3. Transitions/Events:\n   - \"vehicle start signal\" triggers: off → starting\n   - \"vehicle power-on signal\" triggers: starting → on\n   - \"vehicle shutdown signal\" triggers: any state → off\n4. Non-functional requirements:\n   - Reliability: must reliably ensure appropriate response\n   - Safety: safe transitions between states\n   - Sequential: orderly state transitions\n\nSysML v2 mapping:\n- Use state definition with nested states\n- Define transitions with trigger events\n- Model the vehicle system as a part\n- Define the state machine behavior\n</scratchpad>\n\npackage VehicleStartupShutdownSystem {\n    \n    part def Vehicle {\n        event occurrence vehicleStartSignal;\n        event occurrence vehiclePowerOnSignal;\n        event occurrence vehicleShutdownSignal;\n    }\n    \n    part vehicle : Vehicle {\n        \n        state def VehicleStates {\n            entry; then off;\n            \n            state off {\n                transition first\n                    when vehicleStartSignal\n                    then starting;\n            }\n            \n            state starting {\n                transition\n                    when vehiclePowerOnSignal\n                    then on;\n                transition\n                    when vehicleShutdownSignal\n                    then off;\n            }\n            \n            state on {\n                transition\n                    when vehicleShutdownSignal\n                    then off;\n            }\n        }\n        \n        exhibit state vehicleStateMachine : VehicleStates;\n    }\n}",
    "I'll analyze the requirement and create a SysML v2 model for the vehicle operational status management system.\n\n<scratchpad>\nKey functional information extracted:\n1. System manages vehicle operational status\n2. Three states: \"off\", \"starting\", \"on\" (running)\n3. Initial state: \"off\"\n4. State transitions:\n   - off → starting: triggered by VehicleStartSignal\n   - starting → on: triggered by VehicleOnSignal\n   - on → off: triggered by VehicleOffSignal\n5. Automatic state management capability\n\nMapping to SysML v2:\n- Use a state machine to model the behavior\n- Define states: off, starting, on\n- Define transitions with triggers\n- Set initial state\n- Package everything in a proper structure\n</scratchpad>\n\npackage VehicleOperationalSystem {\n    \n    part def Vehicle {\n        exhibit state vehicleStates {\n            entry state off;\n            state starting;\n            state on;\n            \n            transition off_to_starting\n                first off\n                accept VehicleStartSignal\n                then starting;\n                \n            transition starting_to_on\n                first starting\n                accept VehicleOnSignal\n                then on;\n                \n            transition on_to_off\n                first on\n                accept VehicleOffSignal\n                then off;\n        }\n    }\n    \n    part vehicle : Vehicle;\n}",
    "package VehiclePowerManagementSystem {\n    import ScalarValues::*;\n    \n    part def VehiclePowerController {\n        port userCommands : UserCommandPort;\n        port vehicleSignals : VehicleSignalPort;\n        port powerOutput : PowerOutputPort;\n        port safetyControls : SafetyControlPort;\n        \n        attribute powerState : PowerStateType;\n        \n        state powerStateMachine {\n            entry state off;\n            state startPhase;\n            state poweredOn {\n                entry action {\n                    perform selfDiagnosis();\n                    send powerOutput.supplyPower();\n                }\n                do action {\n                    send powerOutput.continuousPowerSupply();\n                }\n            }\n            \n            transition off_to_startPhase\n                first off\n                accept userCommands.startCommand\n                then startPhase;\n                \n            transition startPhase_to_poweredOn\n                first startPhase\n                accept vehicleSignals.vehicleStartedSignal\n                then poweredOn;\n                \n            transition poweredOn_to_off\n                first poweredOn\n                accept userCommands.shutdownCommand\n                do action {\n                    perform safetyOperations();\n                    send safetyControls.engageParkingBrake();\n                    send powerOutput.cutOffPower();\n                }\n                then off;\n        }\n        \n        action selfDiagnosis();\n        action safetyOperations();\n    }\n    \n    port def UserCommandPort {\n        in startCommand : StartCommand;\n        in shutdownCommand : ShutdownCommand;\n    }\n    \n    port def VehicleSignalPort {\n        in vehicleStartedSignal : VehicleStartedSignal;\n    }\n    \n    port def PowerOutputPort {\n        out supplyPower : PowerSupplySignal;\n        out continuousPowerSupply : PowerSupplySignal;\n        out cutOffPower : PowerCutOffSignal;\n    }\n    \n    port def SafetyControlPort {\n        out engageParkingBrake : ParkingBrakeSignal;\n    }\n    \n    enum def PowerStateType {\n        enum off;\n        enum startPhase;\n        enum poweredOn;\n    }\n    \n    item def StartCommand;\n    item def ShutdownCommand;\n    item def VehicleStartedSignal;\n    item def PowerSupplySignal;\n    item def PowerCutOffSignal;\n    item def ParkingBrakeSignal;\n    \n    part vehiclePowerSystem : VehiclePowerController;\n}",
    "package VehicleControlSystem {\n    \n    part def VehicleController {\n        attribute vehicleStatus : VehicleState;\n        \n        port userCommands : UserCommandPort;\n        port statusFeedback : StatusFeedbackPort;\n    }\n    \n    port def UserCommandPort {\n        in startSignal : StartCommand;\n        in shutdownSignal : ShutdownCommand;\n        in startedSignal : StartedCommand;\n    }\n    \n    port def StatusFeedbackPort {\n        out currentStatus : VehicleState;\n    }\n    \n    enum def VehicleState {\n        enum shutdown;\n        enum startup;\n        enum running;\n    }\n    \n    item def StartCommand;\n    item def ShutdownCommand;\n    item def StartedCommand;\n    \n    state def VehicleStateMachine {\n        entry state shutdown;\n        state startup;\n        state running;\n        \n        transition shutdown_to_startup\n            first shutdown\n            accept startSignal : StartCommand\n            then startup;\n            \n        transition startup_to_running\n            first startup\n            accept startedSignal : StartedCommand\n            then running;\n            \n        transition running_to_shutdown\n            first running\n            accept shutdownSignal : ShutdownCommand\n            then shutdown;\n    }\n    \n    part vehicleSystem : VehicleController {\n        exhibit state vehicleOperation : VehicleStateMachine;\n        \n        requirement accurateSignalResponse {\n            doc /* The system must accurately respond to the corresponding signals */\n            verify vehicleOperation;\n        }\n        \n        requirement automaticStateSwitching {\n            doc /* Enable automatic switching among the three main states */\n            satisfy vehicleOperation;\n        }\n    }\n}",
    "package VehiclePowerManagement {\n    \n    part def Vehicle {\n        attribute operatingState : OperatingStateType;\n        \n        port userCommands : UserCommandPort;\n        port stateOutput : StateOutputPort;\n    }\n    \n    enum def OperatingStateType {\n        enum Off;\n        enum Start;\n        enum On;\n    }\n    \n    port def UserCommandPort {\n        in startSignal : StartCommand;\n        in onSignal : OnCommand;\n        in offSignal : OffCommand;\n    }\n    \n    port def StateOutputPort {\n        out currentState : OperatingStateType;\n    }\n    \n    item def StartCommand;\n    item def OnCommand;\n    item def OffCommand;\n    \n    part vehicle : Vehicle {\n        exhibit state vehicleStates {\n            entry state off : OperatingStateType::Off;\n            state start : OperatingStateType::Start;\n            state on : OperatingStateType::On;\n            \n            transition off_to_start : off --> start\n                accept userCommands.startSignal\n                do send stateOutput.currentState = OperatingStateType::Start;\n            \n            transition start_to_on : start --> on\n                accept userCommands.onSignal\n                do send stateOutput.currentState = OperatingStateType::On;\n            \n            transition on_to_off : on --> off\n                accept userCommands.offSignal\n                do send stateOutput.currentState = OperatingStateType::Off;\n        }\n    }\n    \n    requirement def PowerManagementRequirements {\n        doc /* The system shall support three operating states: Off, Start, and On */\n        requirement operatingStates {\n            subject vehicle : Vehicle;\n            assert constraint { vehicle.operatingState in OperatingStateType }\n        }\n        \n        doc /* The system shall transition between states based on user commands */\n        requirement stateTransitions {\n            subject vehicle : Vehicle;\n            assume constraint { vehicle.operatingState == OperatingStateType::Off }\n            require constraint { \n                vehicle.userCommands.startSignal implies next(vehicle.operatingState == OperatingStateType::Start)\n            }\n        }\n        \n        doc /* The system shall respond promptly to control signals */\n        requirement responseTime {\n            subject vehicle : Vehicle;\n            attribute maxResponseTime : Real = 100[ms];\n        }\n    }\n    \n    package FutureExpansion {\n        part def HealthMonitor {\n            attribute healthState : HealthStateType;\n        }\n        \n        enum def HealthStateType {\n            enum Normal;\n            enum Warning;\n            enum Critical;\n        }\n    }\n}",
    "package VehicleHealthMonitoringSystem {\n    import ScalarValues::*;\n    import ISQ::*;\n    import SI::*;\n    import Time::*;\n    \n    part def VehicleHealthMonitor {\n        attribute currentTemperature : TemperatureValue;\n        attribute maxAllowableTemperature : TemperatureValue;\n        attribute maintenanceInterval : DurationValue;\n        attribute lastMaintenanceTime : TimeInstantValue;\n        attribute nextMaintenanceTime : TimeInstantValue;\n        \n        port temperatureSensor : ~TemperatureSensorInterface;\n        port controllerInterface : VehicleControllerInterface;\n        \n        state healthStatus {\n            entry state normal;\n            state degraded;\n            state maintenance;\n            \n            transition normal_to_degraded\n                first normal\n                then degraded\n                guard currentTemperature > maxAllowableTemperature\n                do send controllerInterface.overTemperatureWarning;\n            \n            transition degraded_to_normal\n                first degraded\n                then normal\n                guard currentTemperature <= maxAllowableTemperature;\n            \n            transition normal_to_maintenance\n                first normal\n                then maintenance\n                guard currentTime >= nextMaintenanceTime;\n            \n            transition maintenance_to_normal\n                first maintenance\n                then normal\n                after 48 [h]\n                do action {\n                    lastMaintenanceTime := currentTime;\n                    nextMaintenanceTime := currentTime + maintenanceInterval;\n                }\n        }\n    }\n    \n    interface def TemperatureSensorInterface {\n        out temperatureReading : TemperatureValue;\n    }\n    \n    interface def VehicleControllerInterface {\n        in overTemperatureWarning : WarningSignal;\n    }\n    \n    abstract def WarningSignal;\n    \n    attribute def TemperatureValue :> ScalarQuantityValue {\n        attribute redefines num : Real;\n        attribute redefines mRef : TemperatureUnit;\n    }\n    \n    attribute def DurationValue :> ScalarQuantityValue {\n        attribute redefines num : Real;\n        attribute redefines mRef : DurationUnit;\n    }\n    \n    usage vehicleHealthSystem : VehicleHealthMonitor {\n        attribute redefines maxAllowableTemperature = 90 [°C];\n        attribute redefines maintenanceInterval = 30 [day];\n    }\n}",
    "package ServerSystem {\n    import ScalarValues::*;\n    import ISQ::*;\n    import Time::*;\n    import Actions::*;\n    \n    part def Server {\n        attribute localClock : Time;\n        port requestPort {\n            in item startCommand;\n            in item requestMessage;\n        }\n        \n        state serverBehavior {\n            entry state off;\n            state waiting;\n            state response;\n            \n            transition startup \n                first start then off;\n                \n            transition startTransition\n                first off\n                accept startCommand via requestPort\n                then waiting;\n                \n            transition requestTransition\n                first waiting\n                accept requestMessage via requestPort\n                then response;\n                \n            transition responseTimeout\n                first response\n                after 5 [minute]\n                then waiting;\n                \n            transition dailyReset\n                first waiting, response\n                when localClock == TimeOfDay(11, 59, 0)\n                then off;\n        }\n    }\n    \n    usage serverInstance : Server {\n        exhibit state serverBehavior;\n    }\n}",
    "<scratchpad>\nLet me analyze this step-by-step:\n\n1. Key functional information:\n- System controls vehicle start-stop process\n- Initial state: off\n- States: off, starting, operating\n- Transitions triggered by: start signal, stop signal, power-on signal\n- Conditions: brake pedal must be depressed before power-on\n- Actions during transitions:\n  - Send start signal to controller when power-on received\n  - Perform self-check when entering operating state\n  - Continuously supply power in operating state\n  - Apply parking brake when leaving operating state\n\n2. Non-functional requirements:\n- Safety and reliability of start-stop process\n- Coordinated control with controller\n\n3. SysML v2 mapping:\n- Use a state machine to model the behavior\n- States: off, starting, operating\n- Transitions with triggers and guards\n- Entry/exit actions for states\n- Send actions for signals\n- Part definition for the system\n- Requirements for safety and reliability\n</scratchpad>\n\npackage VehicleStartStopSystem {\n    \n    part def VehicleStartStopController {\n        attribute brakePedalDepressed : Boolean;\n        \n        port controllerPort {\n            out item startSignalToController;\n        }\n    }\n    \n    part vehicleController : VehicleStartStopController {\n        \n        state startStopStateMachine {\n            entry; then off;\n            \n            state off;\n            \n            state starting {\n                entry action sendStartSignal {\n                    send startSignalToController via controllerPort;\n                }\n            }\n            \n            state operating {\n                entry action performSelfCheck;\n                do action continuouslySupplyPower;\n                exit action applyParkingBrake;\n            }\n            \n            transition off_to_starting : off --> starting {\n                trigger startSignal;\n            }\n            \n            transition starting_to_operating : starting --> operating {\n                trigger powerOnSignal;\n                guard brakePedalDepressed;\n            }\n            \n            transition operating_to_off : operating --> off {\n                trigger stopSignal;\n            }\n        }\n    }\n    \n    requirement def SafetyReliability {\n        doc /* The system shall ensure the safety and reliability of the vehicle's start-stop process */\n    }\n    \n    requirement def CoordinatedControl {\n        doc /* The system shall provide coordinated control with the controller */\n    }\n    \n    satisfy SafetyReliability by vehicleController;\n    satisfy CoordinatedControl by vehicleController;\n}",
    "package VehicleStartStopSystem {\n    \n    part def VehicleController;\n    part def BrakePedal;\n    part def ParkingBrake;\n    \n    part def VehicleStartStopControlSystem {\n        port startSignalPort : ~SignalPort;\n        port vehicleOnSignalPort : ~SignalPort;\n        port shutdownSignalPort : ~SignalPort;\n        port brakeStatusPort : ~StatusPort;\n        port startControlPort : SignalPort;\n        port powerSupplyPort : PowerPort;\n        port parkingBrakeControlPort : ControlPort;\n        \n        attribute systemState : SystemStateType;\n        \n        perform action selfCheck;\n        \n        state machine VehicleStateMachine {\n            entry state off;\n            state startUp;\n            state started {\n                entry action {\n                    perform selfCheck;\n                    send powerSupplyPort.supplyPower();\n                }\n                do action {\n                    send powerSupplyPort.continuousPower();\n                }\n            }\n            \n            transition off_to_startUp\n                first off\n                accept startSignalPort.signal\n                then startUp;\n                \n            transition startUp_to_started\n                first startUp\n                accept vehicleOnSignalPort.signal\n                if brakeStatusPort.isDepressed\n                do send startControlPort.startSignal()\n                then started;\n                \n            transition started_to_off\n                first started\n                accept shutdownSignalPort.signal\n                do {\n                    send parkingBrakeControlPort.applyBrake();\n                    systemState := SystemStateType::off;\n                }\n                then off;\n        }\n    }\n    \n    enum def SystemStateType {\n        enum off;\n        enum startUp;\n        enum started;\n    }\n    \n    port def SignalPort {\n        out signal : Boolean;\n    }\n    \n    port def StatusPort {\n        in isDepressed : Boolean;\n    }\n    \n    port def ControlPort {\n        out startSignal : Boolean;\n        out applyBrake : Boolean;\n    }\n    \n    port def PowerPort {\n        out supplyPower : Boolean;\n        out continuousPower : Boolean;\n    }\n    \n    part vehicleSystem : VehicleStartStopControlSystem {\n        part controller : VehicleController;\n        part brake : BrakePedal;\n        part parkingBrake : ParkingBrake;\n        \n        connect vehicleSystem.startControlPort to controller.controlInput;\n        connect brake.status to vehicleSystem.brakeStatusPort;\n        connect vehicleSystem.parkingBrakeControlPort to parkingBrake.control;\n    }\n    \n    requirement def SafetyRequirement {\n        doc /* Vehicle can only be started when brake pedal is depressed */\n        require constraint { \n            vehicleSystem.systemState == SystemStateType::started \n            implies brake.status.isDepressed == true \n        }\n    }\n    \n    requirement def ShutdownSafetyRequirement {\n        doc /* Parking brake must be applied before shutdown */\n        require constraint {\n            vehicleSystem.systemState == SystemStateType::off\n            implies parkingBrake.isApplied == true\n        }\n    }\n}",
    "<scratchpad>\nLet me analyze the requirements step by step:\n\n1. Key Components/Parts:\n   - Driver\n   - Cruise Controller\n   - Speedometer\n   - Engine\n   - Vehicle (contains the other components)\n\n2. Key Interfaces/Ports:\n   - Driver sends set speed command\n   - Cruise Controller receives set speed command\n   - Speedometer sends actual speed to Cruise Controller\n   - Cruise Controller sends fuel control commands to Engine\n   - Engine receives fuel control commands\n\n3. Key Behaviors:\n   - Driver activates cruise function\n   - Cruise Controller processes speed information\n   - Speedometer collects real-time speed\n   - Engine adjusts output based on fuel commands\n\n4. Information Flow (Events):\n   - Set speed command (Driver → Cruise Controller)\n   - Actual speed (Speedometer → Cruise Controller)\n   - Fuel control command (Cruise Controller → Engine)\n\n5. System Structure:\n   - Vehicle is the main system containing all components\n   - Components interact through event-based communication\n\nMapping to SysML v2:\n- Use part definitions for components\n- Use part usages for instances\n- Use ports for interfaces\n- Use connections for information flow\n- Use actions/behaviors for functional aspects\n</scratchpad>\n\npackage CruiseControlSystem {\n    \n    part def Driver {\n        port setSpeedOut : ~SetSpeedCommand;\n    }\n    \n    part def CruiseController {\n        port setSpeedIn : SetSpeedCommand;\n        port actualSpeedIn : ActualSpeed;\n        port fuelCommandOut : ~FuelControlCommand;\n    }\n    \n    part def Speedometer {\n        port actualSpeedOut : ~ActualSpeed;\n    }\n    \n    part def Engine {\n        port fuelCommandIn : FuelControlCommand;\n    }\n    \n    part def Vehicle {\n        part driver : Driver;\n        part cruiseController : CruiseController;\n        part speedometer : Speedometer;\n        part engine : Engine;\n        \n        connection : driver.setSpeedOut to cruiseController.setSpeedIn;\n        connection : speedometer.actualSpeedOut to cruiseController.actualSpeedIn;\n        connection : cruiseController.fuelCommandOut to engine.fuelCommandIn;\n    }\n    \n    port def SetSpeedCommand {\n        attribute desiredSpeed : Real;\n    }\n    \n    port def ActualSpeed {\n        attribute currentSpeed : Real;\n    }\n    \n    port def FuelControlCommand {\n        attribute fuelRate : Real;\n    }\n}",
    "package CruiseControlSystem {\n    \n    part def Driver {\n        attribute setSpeed : Real;\n        \n        port driverCommands : ~DriverCommandsInterface;\n    }\n    \n    part def CruiseController {\n        attribute targetSpeed : Real;\n        attribute currentSpeed : Real;\n        attribute throttleCommand : Real;\n        \n        port commandInput : DriverCommandsInterface;\n        port speedInput : SpeedDataInterface;\n        port throttleOutput : ~ThrottleCommandInterface;\n        \n        action controlSpeed {\n            in targetSpeed : Real;\n            in currentSpeed : Real;\n            out throttleCommand : Real;\n            \n            throttleCommand := calculateThrottle(targetSpeed - currentSpeed);\n        }\n    }\n    \n    part def Speedometer {\n        attribute vehicleSpeed : Real;\n        \n        port speedData : ~SpeedDataInterface;\n    }\n    \n    part def EngineSystem {\n        attribute powerOutput : Real;\n        \n        port throttleInput : ThrottleCommandInterface;\n        \n        action adjustPower {\n            in throttleCommand : Real;\n            powerOutput := throttleCommand * maxPower;\n        }\n    }\n    \n    interface def DriverCommandsInterface {\n        in setSpeed : Real;\n    }\n    \n    interface def SpeedDataInterface {\n        out vehicleSpeed : Real;\n    }\n    \n    interface def ThrottleCommandInterface {\n        in throttleCommand : Real;\n    }\n    \n    part cruiseControlSystemContext {\n        part driver : Driver;\n        part controller : CruiseController;\n        part speedometer : Speedometer;\n        part engine : EngineSystem;\n        \n        connect driver.driverCommands to controller.commandInput;\n        connect speedometer.speedData to controller.speedInput;\n        connect controller.throttleOutput to engine.throttleInput;\n        \n        requirement automaticSpeedControl {\n            doc /* The system shall automatically control vehicle speed based on driver's set speed */\n            satisfy cruiseControlSystemContext;\n        }\n        \n        requirement drivingComfort {\n            doc /* The system shall improve driving comfort through automatic speed control */\n            satisfy cruiseControlSystemContext;\n        }\n        \n        requirement drivingSafety {\n            doc /* The system shall enhance driving safety through consistent speed control */\n            satisfy cruiseControlSystemContext;\n        }\n    }\n}",
    "package CruiseControlSystem {\n    import ScalarValues::*;\n    \n    part def Driver {\n        port setSpeedPort : ~SetSpeedInterface;\n    }\n    \n    part def CruiseController {\n        port driverInterface : SetSpeedInterface;\n        port speedSensorInterface : SpeedSensorInterface;\n        port engineInterface : ~EngineControlInterface;\n        \n        attribute targetSpeed : Real;\n        attribute currentSpeed : Real;\n        attribute speedDifference : Real;\n        \n        action calculateSpeedDifference {\n            in targetSpeed : Real;\n            in currentSpeed : Real;\n            out speedDifference : Real;\n            \n            speedDifference := targetSpeed - currentSpeed;\n        }\n        \n        action generateThrottleCommand {\n            in speedDifference : Real;\n            out throttleCommand : Real;\n        }\n    }\n    \n    part def SpeedSensor {\n        port speedOutput : ~SpeedSensorInterface;\n        attribute measuredSpeed : Real;\n    }\n    \n    part def Engine {\n        port throttleInput : EngineControlInterface;\n        attribute throttlePosition : Real;\n    }\n    \n    interface def SetSpeedInterface {\n        in item setSpeed : Real;\n    }\n    \n    interface def SpeedSensorInterface {\n        out item currentSpeed : Real;\n    }\n    \n    interface def EngineControlInterface {\n        in item throttleCommand : Real;\n    }\n    \n    part cruiseControlSystem : CruiseControlSystem {\n        part driver : Driver;\n        part controller : CruiseController;\n        part speedometer : SpeedSensor;\n        part engine : Engine;\n        \n        interface : SetSpeedInterface connect driver.setSpeedPort to controller.driverInterface;\n        interface : SpeedSensorInterface connect speedometer.speedOutput to controller.speedSensorInterface;\n        interface : EngineControlInterface connect controller.engineInterface to engine.throttleInput;\n    }\n    \n    action maintainCruiseSpeed {\n        in item targetSpeed : Real;\n        \n        first start;\n        then receiveSetSpeed;\n        then readCurrentSpeed;\n        then calculateControl;\n        then sendThrottleCommand;\n        then done;\n        \n        action receiveSetSpeed {\n            in item speed : Real;\n        }\n        \n        action readCurrentSpeed {\n            out item speed : Real;\n        }\n        \n        action calculateControl {\n            in item targetSpeed : Real;\n            in item currentSpeed : Real;\n            out item throttleCommand : Real;\n        }\n        \n        action sendThrottleCommand {\n            in item command : Real;\n        }\n    }\n}",
    "package CruiseControlSystem {\n    import ScalarValues::*;\n    \n    part def Driver {\n        attribute desiredSpeed : Real;\n        port speedCommand : SpeedCommandPort;\n    }\n    \n    part def CruiseController {\n        attribute targetSpeed : Real;\n        attribute currentSpeed : Real;\n        attribute throttleCommand : Real;\n        \n        port speedCommandIn : SpeedCommandPort;\n        port speedSensorIn : SpeedSensorPort;\n        port throttleOut : ThrottleControlPort;\n        \n        action calculateThrottle {\n            in targetSpeed : Real;\n            in currentSpeed : Real;\n            out throttleCommand : Real;\n        }\n    }\n    \n    part def Speedometer {\n        attribute measuredSpeed : Real;\n        port speedOut : SpeedSensorPort;\n    }\n    \n    part def Engine {\n        attribute throttlePosition : Real;\n        port throttleIn : ThrottleControlPort;\n    }\n    \n    port def SpeedCommandPort {\n        out speedValue : Real;\n    }\n    \n    port def SpeedSensorPort {\n        out speed : Real;\n    }\n    \n    port def ThrottleControlPort {\n        out throttle : Real;\n    }\n    \n    part cruiseControlSystem : CruiseControlSystem {\n        part driver : Driver;\n        part controller : CruiseController;\n        part speedometer : Speedometer;\n        part engine : Engine;\n        \n        interface driverToController connect \n            driver.speedCommand to controller.speedCommandIn;\n            \n        interface speedometerToController connect\n            speedometer.speedOut to controller.speedSensorIn;\n            \n        interface controllerToEngine connect\n            controller.throttleOut to engine.throttleIn;\n            \n        requirement accuracyRequirement {\n            doc /* The system shall maintain vehicle speed within ±2% of the set speed */\n            verify speedAccuracy {\n                in measuredSpeed : Real;\n                in targetSpeed : Real;\n                return abs(measuredSpeed - targetSpeed) <= targetSpeed * 0.02;\n            }\n        }\n        \n        requirement responsivenessRequirement {\n            doc /* The system shall respond to speed commands within 1 second */\n            attribute responseTime : Real;\n            assume constraint { responseTime <= 1.0 }\n        }\n        \n        requirement smoothnessRequirement {\n            doc /* The system shall provide smooth throttle adjustments */\n            attribute throttleChangeRate : Real;\n            assume constraint { throttleChangeRate <= 10.0 }\n        }\n    }\n}",
    "package CruiseControlSystem {\n    import ScalarValues::*;\n    \n    part def CruiseControlInterface {\n        attribute targetSpeed : Real;\n        port setSpeedCommand : DataPort;\n    }\n    \n    part def SpeedSensor {\n        attribute detectedSpeed : Real;\n        port speedOutput : DataPort;\n    }\n    \n    part def CruiseController {\n        attribute setSpeed : Real;\n        attribute actualSpeed : Real;\n        attribute fuelCommand : Real;\n        \n        port speedCommandInput : DataPort;\n        port actualSpeedInput : DataPort;\n        port fuelControlOutput : DataPort;\n        \n        action compareAndControl {\n            in setSpeedValue : Real;\n            in actualSpeedValue : Real;\n            out fuelControlValue : Real;\n        }\n    }\n    \n    part def Engine {\n        attribute fuelInput : Real;\n        attribute powerOutput : Real;\n        \n        port fuelControlInput : DataPort;\n    }\n    \n    part def Vehicle {\n        attribute currentSpeed : Real;\n        \n        part cruiseInterface : CruiseControlInterface;\n        part speedSensor : SpeedSensor;\n        part cruiseController : CruiseController;\n        part engine : Engine;\n        \n        interface def DataPort {\n            end source;\n            end target;\n        }\n        \n        interface setSpeedInterface : DataPort connect \n            cruiseInterface.setSpeedCommand to cruiseController.speedCommandInput;\n            \n        interface speedSensingInterface : DataPort connect\n            speedSensor.speedOutput to cruiseController.actualSpeedInput;\n            \n        interface fuelControlInterface : DataPort connect\n            cruiseController.fuelControlOutput to engine.fuelControlInput;\n            \n        requirement maintainTargetSpeed {\n            doc /* The system shall maintain vehicle speed within ±2 km/h of the target speed */\n            satisfy cruiseController.compareAndControl;\n        }\n        \n        requirement reliableOperation {\n            doc /* The system shall operate reliably with accurate data exchange between components */\n            verify speedSensingInterface, setSpeedInterface, fuelControlInterface;\n        }\n    }\n}",
    "package CruiseControlSystem {\n    import ScalarValues::*;\n    \n    // Value types\n    attribute def Speed :> Real {\n        doc /* Vehicle speed in km/h */\n    }\n    \n    attribute def FuelCommand :> Real {\n        doc /* Fuel control command value */\n    }\n    \n    // Message definitions\n    item def SetSpeedCommand {\n        attribute targetSpeed : Speed;\n    }\n    \n    item def SpeedReading {\n        attribute currentSpeed : Speed;\n    }\n    \n    item def FuelControlCommand {\n        attribute fuelAdjustment : FuelCommand;\n    }\n    \n    // Part definitions\n    part def Driver {\n        port setSpeedOut : ~SetSpeedCommand;\n    }\n    \n    part def CruiseController {\n        port setSpeedIn : SetSpeedCommand;\n        port speedIn : SpeedReading;\n        port fuelCommandOut : ~FuelControlCommand;\n        \n        private attribute setSpeed : Speed;\n        private attribute actualSpeed : Speed;\n        \n        action processSetSpeed {\n            in cmd : SetSpeedCommand;\n            bind cmd = setSpeedIn;\n            assign setSpeed := cmd.targetSpeed;\n        }\n        \n        action readSpeed {\n            in reading : SpeedReading;\n            bind reading = speedIn;\n            assign actualSpeed := reading.currentSpeed;\n        }\n        \n        action calculateFuelCommand {\n            out cmd : FuelControlCommand;\n            bind cmd = fuelCommandOut;\n            assign cmd.fuelAdjustment := (setSpeed - actualSpeed) * 0.1;\n        }\n    }\n    \n    part def SpeedSensor {\n        port speedOut : ~SpeedReading;\n        \n        action measureSpeed {\n            out reading : SpeedReading;\n            bind reading = speedOut;\n        }\n    }\n    \n    part def EngineController {\n        port fuelCommandIn : FuelControlCommand;\n        port engineCommandOut : ~FuelControlCommand;\n        \n        action processFuelCommand {\n            in cmd : FuelControlCommand;\n            out engineCmd : FuelControlCommand;\n            bind cmd = fuelCommandIn;\n            bind engineCmd = engineCommandOut;\n            assign engineCmd := cmd;\n        }\n    }\n    \n    part def Engine {\n        port fuelCommandIn : FuelControlCommand;\n        \n        action adjustFuel {\n            in cmd : FuelControlCommand;\n            bind cmd = fuelCommandIn;\n        }\n    }\n    \n    // System composition\n    part cruiseControlSystem {\n        part driver : Driver;\n        part controller : CruiseController;\n        part sensor : SpeedSensor;\n        part engineController : EngineController;\n        part engine : Engine;\n        \n        // Connections\n        interface setSpeedInterface connect driver.setSpeedOut to controller.setSpeedIn;\n        interface speedInterface connect sensor.speedOut to controller.speedIn;\n        interface fuelCommandInterface connect controller.fuelCommandOut to engineController.fuelCommandIn;\n        interface engineInterface connect engineController.engineCommandOut to engine.fuelCommandIn;\n        \n        // Requirements\n        requirement reliability {\n            doc /* The system shall ensure reliable message transmission between components */\n        }\n        \n        requirement efficiency {\n            doc /* The system shall process commands efficiently with minimal latency */\n        }\n        \n        requirement safety {\n            doc /* The system shall operate safely under all conditions */\n        }\n    }\n}",
    "package VehicleLifecycleManagement {\n    import ScalarValues::*;\n    \n    part def Vehicle {\n        attribute vin : String;\n        attribute model : String;\n        attribute manufactureDate : String;\n    }\n    \n    part def Person {\n        attribute id : String;\n        attribute name : String;\n    }\n    \n    part def Owner :> Person;\n    part def Driver :> Person;\n    \n    occurrence def VehicleLifecycle {\n        attribute deliveryDate : String;\n        attribute scrapDate : String[0..1];\n        \n        ref vehicle : Vehicle;\n        \n        occurrence assembly : AssemblyStage {\n            in item vehicle : Vehicle;\n            out item assembledVehicle : Vehicle;\n        }\n        \n        occurrence delivery : DeliveryStage {\n            in item assembledVehicle : Vehicle;\n            out item deliveredVehicle : Vehicle;\n            attribute actualDeliveryDate : String;\n        }\n        \n        occurrence ownership : OwnershipPeriod[1..*] ordered {\n            ref item ownedVehicle : Vehicle;\n            ref item owner : Owner[1];\n            attribute startDate : String;\n            attribute endDate : String[0..1];\n            \n            occurrence driving : DrivingOperation[0..*] {\n                ref item drivenVehicle : Vehicle;\n                ref item driver : Driver[1];\n                attribute drivingDate : String;\n                attribute startTime : String;\n                attribute endTime : String;\n            }\n        }\n        \n        occurrence endOfLife : ScrapStage[0..1] {\n            in item vehicleToScrap : Vehicle;\n            attribute scrapDate : String;\n            attribute reason : String;\n        }\n        \n        succession assembly then delivery;\n        succession delivery.deliveredVehicle to ownership.ownedVehicle;\n        succession ownership then endOfLife;\n    }\n    \n    action def AssemblyStage {\n        in item vehicle : Vehicle;\n        out item assembledVehicle : Vehicle;\n    }\n    \n    action def DeliveryStage {\n        in item assembledVehicle : Vehicle;\n        out item deliveredVehicle : Vehicle;\n    }\n    \n    action def DrivingOperation {\n        in item vehicle : Vehicle;\n        in item driver : Driver;\n    }\n    \n    action def ScrapStage {\n        in item vehicleToScrap : Vehicle;\n    }\n    \n    requirement def TraceabilityRequirement {\n        doc /* Each ownership stage must be traceable to a unique owner */\n        subject lifecycle : VehicleLifecycle;\n        require constraint {\n            lifecycle.ownership->forAll(o1, o2 | \n                (o1 != o2) implies (o1.owner != o2.owner or o1.startDate != o2.startDate))\n        }\n    }\n    \n    requirement def LifecycleDataManagement {\n        doc /* System shall record and manage all lifecycle data */\n        subject lifecycle : VehicleLifecycle;\n        require constraint {\n            lifecycle.assembly != null and\n            lifecycle.delivery != null and\n            lifecycle.delivery.actualDeliveryDate != null and\n            lifecycle.ownership->size() >= 1\n        }\n    }\n}",
    "package VehicleModel {\n    import ScalarValues::*;\n    \n    attribute def Mass :> Real;\n    attribute def GearSetting :> Integer;\n    attribute def AcceleratorPosition :> Real;\n    \n    attribute def OperationalStatus {\n        attribute gearSetting : GearSetting;\n        attribute acceleratorPedalPosition : AcceleratorPosition;\n    }\n    \n    part def Wheel {\n        attribute id : String;\n        attribute position : String;\n    }\n    \n    part def Engine {\n        attribute id : String;\n    }\n    \n    actor def Driver {\n        attribute id : String;\n    }\n    \n    part def Vehicle {\n        attribute mass : Mass;\n        attribute status : OperationalStatus;\n        \n        part engine : Engine[1];\n        ref driver : Driver[1];\n        part wheels : Wheel[2..*];\n        \n        part leftFrontWheel : Wheel[1] :> wheels {\n            attribute :>> position = \"left front\";\n        }\n        \n        part rightFrontWheel : Wheel[1] :> wheels {\n            attribute :>> position = \"right front\";\n        }\n    }\n    \n    part vehicle_1 : Vehicle {\n        attribute :>> mass = 1500.0;\n        \n        snapshot leftFrontWheel_t1 : leftFrontWheel @ t1;\n        snapshot leftFrontWheel_t2 : leftFrontWheel @ t2;\n        \n        snapshot rightFrontWheel_t1 : rightFrontWheel @ t1;\n        snapshot rightFrontWheel_t2 : rightFrontWheel @ t2;\n    }\n}",
    "package VehicleSystem {\n    import ScalarValues::*;\n    \n    part def Vehicle {\n        attribute mass : Real;\n        attribute state : VehicleState;\n    }\n    \n    part def VehicleState {\n        attribute gearSetting : Integer;\n        attribute acceleratorPedalPosition : Real;\n    }\n    \n    part def Engine;\n    \n    part def Driver;\n    \n    part def CompositeSystem {\n        part vehicles : Vehicle[*];\n        part engines : Engine[*];\n        part drivers : Driver[*];\n    }\n    \n    part vehicle_1 : Vehicle {\n        attribute redefines mass = 2000.0;\n        attribute redefines state : VehicleState {\n            attribute redefines gearSetting = 0;\n            attribute redefines acceleratorPedalPosition = 0.0;\n        }\n    }\n    \n    occurrence def VehicleTimeline {\n        occurrence vehicle_1_t0 : Vehicle {\n            attribute redefines mass = 2000.0;\n            attribute redefines state : VehicleState {\n                attribute redefines gearSetting = 0;\n                attribute redefines acceleratorPedalPosition = 0.0;\n            }\n        }\n        \n        occurrence vehicle_1_t1 : Vehicle {\n            attribute redefines mass = 1500.0;\n            attribute redefines state : VehicleState {\n                attribute redefines gearSetting = 2;\n                attribute redefines acceleratorPedalPosition = 0.5;\n            }\n        }\n        \n        succession vehicle_1_t0 then vehicle_1_t1;\n    }\n}",
    "I'll analyze the requirements and create a SysML v2 model step by step.\n\n<scratchpad>\nKey functional/non-functional information:\n1. Vehicle system with properties:\n   - mass (changes from 2000 kg to 1500 kg)\n   - current state with gear position (neutral to second)\n   - throttle pedal position (0 to 0.5)\n2. Vehicle contains an engine component\n3. Vehicle can be assigned a driver\n4. Two drivers defined: Alice and Bob\n5. Time-based changes (time slices)\n6. Driver assignment changes over time (Alice then Bob)\n\nSysML v2 mapping:\n- Use part definitions for Vehicle, Engine, Driver\n- Use attributes for mass, gear position, throttle\n- Use parts for composition (engine in vehicle)\n- Use references for driver assignment\n- Use individual definitions for Alice and Bob\n- Use time slices or snapshots to model temporal changes\n- Use allocations or assignments for driver-vehicle relationships\n</scratchpad>\n\npackage VehicleModel {\n    import ScalarValues::*;\n    \n    part def Driver {\n        attribute name : String;\n    }\n    \n    part def Engine;\n    \n    part def Vehicle {\n        attribute mass : Real;\n        attribute gearPosition : String;\n        attribute throttlePedalPosition : Real;\n        \n        part engine : Engine;\n        ref driver : Driver;\n    }\n    \n    individual def Alice : Driver {\n        attribute redefines name = \"Alice\";\n    }\n    \n    individual def Bob : Driver {\n        attribute redefines name = \"Bob\";\n    }\n    \n    individual vehicle : Vehicle {\n        timeslice initialState {\n            attribute redefines mass = 2000.0;\n            attribute redefines gearPosition = \"neutral\";\n            attribute redefines throttlePedalPosition = 0.0;\n            ref redefines driver : Alice;\n        }\n        \n        then timeslice secondState {\n            attribute redefines mass = 1500.0;\n            attribute redefines gearPosition = \"second\";\n            attribute redefines throttlePedalPosition = 0.5;\n            ref redefines driver : Bob;\n        }\n    }\n}",
    "package VehicleMassManagementSystem {\n    import ScalarValues::*;\n    import Quantities::*;\n    import MeasurementReferences::*;\n    import SI::*;\n    \n    attribute def MassValue :> ScalarQuantityValue {\n        attribute quantityDimension :>> num = 1;\n        attribute measurementReference :>> mRef = kg;\n    }\n    \n    abstract part def Component {\n        attribute id : String;\n        attribute componentMass : MassValue;\n        attribute totalMass : MassValue;\n    }\n    \n    abstract part def CompositeComponent :> Component {\n        part subComponents : Component[0..*];\n        \n        calc constraint {\n            totalMass == componentMass + sum(subComponents.totalMass)\n        }\n    }\n    \n    part def SimpleComponent :> Component {\n        calc constraint {\n            totalMass == componentMass\n        }\n    }\n    \n    part def Engine :> SimpleComponent {\n        attribute engineType : String;\n        attribute displacement : Real;\n    }\n    \n    part def Transmission :> SimpleComponent {\n        attribute transmissionType : String;\n        attribute gearCount : Integer;\n    }\n    \n    part def Body :> SimpleComponent {\n        attribute bodyType : String;\n        attribute material : String;\n    }\n    \n    part def Vehicle :> CompositeComponent {\n        attribute vehicleModel : String;\n        attribute vin : String;\n        \n        part engine : Engine[1];\n        part transmission : Transmission[1];\n        part body : Body[1];\n        part otherComponents : Component[0..*];\n        \n        :>> subComponents = (engine, transmission, body, otherComponents);\n    }\n    \n    calc def sum(masses : MassValue[0..*]) : MassValue {\n        if isEmpty(masses) ? 0[kg]\n        else if size(masses) == 1 ? masses#(1)\n        else masses#(1) + sum(masses[2..size(masses)])\n    }\n}",
    "package VehicleMassManagementSystem {\n    import ScalarValues::*;\n    import ISQ::*;\n    import SI::*;\n    \n    attribute def MassValue :> MassValue {\n        attribute massValue : Real;\n    }\n    \n    attribute def SerialNumber {\n        attribute value : String;\n    }\n    \n    attribute def VIN {\n        attribute value : String;\n    }\n    \n    abstract part def Component {\n        attribute serialNumber : SerialNumber;\n        attribute mass : MassValue;\n        part subComponents : Component[0..*];\n        \n        calc totalMass : MassValue {\n            mass.massValue + subComponents.totalMass.massValue->sum()\n        }\n    }\n    \n    part def Engine :> Component;\n    part def Transmission :> Component;\n    \n    part def Vehicle :> Component {\n        attribute vin : VIN;\n        ref engine : Engine;\n        ref transmission : Transmission;\n        \n        calc filteredMass : MassValue {\n            in threshold : Real;\n            mass.massValue + \n            subComponents->select(c | c.mass.massValue >= threshold).totalMass.massValue->sum()\n        }\n    }\n    \n    calc def calculateTotalMass {\n        in vehicle : Vehicle;\n        return totalMass : MassValue = vehicle.totalMass;\n    }\n    \n    calc def calculateFilteredMass {\n        in vehicle : Vehicle;\n        in threshold : Real;\n        return filteredMass : MassValue {\n            vehicle.filteredMass(threshold)\n        }\n    }\n}",
    "<scratchpad>\nLet me analyze the requirements step by step:\n\n1. Key functional requirements:\n   - Objects have mass attributes (simpleMass and totalMass)\n   - Basic objects (simpleThing): totalMass = simpleMass\n   - Composite objects (compositeThing): can contain subcomponents\n   - Composite totalMass = simpleMass + sum of all subcomponents' totalMass\n   - Hierarchical mass aggregation\n\n2. Key non-functional requirements:\n   - Automatic calculation\n   - Hierarchical management\n   - Mass statistics at all levels\n\n3. SysML v2 mapping:\n   - Need abstract part definition for common mass attributes\n   - SimpleThing as a specialized part\n   - CompositeThing as a specialized part with composition\n   - Attribute definitions for simpleMass and totalMass\n   - Constraint for totalMass calculation\n   - Recursive composition pattern for hierarchical structure\n</scratchpad>\n\npackage MassAggregationSystem {\n    \n    abstract part def MassObject {\n        attribute simpleMass : Real;\n        attribute totalMass : Real;\n    }\n    \n    part def SimpleThing :> MassObject {\n        assert constraint {\n            totalMass == simpleMass\n        }\n    }\n    \n    part def CompositeThing :> MassObject {\n        part subcomponents : MassObject[0..*];\n        \n        assert constraint {\n            totalMass == simpleMass + subcomponents.totalMass->sum()\n        }\n    }\n}",
    "package MassManagementSystem {\n    import ScalarValues::*;\n    \n    attribute def MassValue :> Real {\n        attribute unit = \"kg\";\n    }\n    \n    part def MassObject {\n        attribute basicMass : MassValue;\n        part subcomponents : MassObject[0..*];\n        \n        attribute totalMass : MassValue;\n        attribute filteredTotalMass : MassValue;\n        \n        calc totalMassCalculation : MassValue {\n            basicMass + sum(subcomponents.totalMass)\n        }\n        \n        calc filteredMassCalculation {\n            in minThreshold : MassValue;\n            return : MassValue = basicMass + sum(\n                subcomponents.select(s | s.totalMass >= minThreshold).totalMass\n            );\n        }\n    }\n    \n    part def MassAggregationSystem {\n        part managedObjects : MassObject[0..*];\n        attribute minimumMassThreshold : MassValue default = 0.0;\n        \n        action calculateTotalMass {\n            in obj : MassObject;\n            out totalMass : MassValue;\n            \n            bind totalMass = obj.totalMassCalculation;\n        }\n        \n        action calculateFilteredMass {\n            in obj : MassObject;\n            in threshold : MassValue;\n            out filteredMass : MassValue;\n            \n            bind filteredMass = obj.filteredMassCalculation(threshold);\n        }\n        \n        action filterObjectsByMass {\n            in objects : MassObject[0..*];\n            in minMass : MassValue;\n            out filteredObjects : MassObject[0..*];\n            \n            bind filteredObjects = objects.select(o | o.totalMass >= minMass);\n        }\n        \n        action aggregateMass {\n            in objects : MassObject[0..*];\n            out aggregatedMass : MassValue;\n            \n            bind aggregatedMass = sum(objects.totalMass);\n        }\n    }\n    \n    requirement def MassCalculationRequirement {\n        doc /* The system shall calculate total mass as sum of basic mass \n             * and all subcomponent masses */\n        \n        subject system : MassAggregationSystem;\n        \n        require constraint {\n            forAll obj in system.managedObjects {\n                obj.totalMass == obj.totalMassCalculation\n            }\n        }\n    }\n    \n    requirement def FilteredAggregationRequirement {\n        doc /* The system shall support mass-based filtering with \n             * configurable minimum threshold */\n        \n        subject system : MassAggregationSystem;\n        \n        require constraint {\n            forAll obj in system.managedObjects {\n                obj.filteredTotalMass == \n                obj.filteredMassCalculation(system.minimumMassThreshold)\n            }\n        }\n    }\n    \n    requirement def HierarchicalDecompositionRequirement {\n        doc /* The system shall support hierarchical decomposition \n             * of complex structures */\n        \n        subject obj : MassObject;\n        \n        require constraint {\n            obj.subcomponents->size() >= 0\n        }\n    }\n}",
    "<scratchpad>\nLet me analyze the requirements step by step:\n\n1. Key functional requirements:\n   - Calculate vehicle dynamics core parameters (power output, acceleration, speed, position)\n   - Calculate actual available power output based on:\n     - Wheel power\n     - Aerodynamic drag coefficient\n     - Friction coefficient\n     - Vehicle mass\n     - Speed\n   - Deduce acceleration from effective power, mass, and current speed\n   - Calculate speed at any moment using acceleration, initial speed, and time\n   - Estimate displacement based on speed and time\n\n2. Non-functional requirements:\n   - High accuracy\n   - Clear logical relationships between parameters\n   - Results convenient for practical engineering applications\n\n3. Mapping to SysML v2:\n   - Create a package for the vehicle dynamics system\n   - Define parts for the vehicle and its subsystems\n   - Define attributes for all the parameters mentioned\n   - Create calculations/constraints for the relationships\n   - Define actions for the various calculations\n   - Use requirements to capture the functional and non-functional needs\n</scratchpad>\n\npackage VehicleDynamicsSystem {\n    import ScalarValues::*;\n    import Quantities::*;\n    import MeasurementReferences::*;\n    import SI::*;\n    \n    part def Vehicle {\n        attribute mass : MassValue;\n        attribute speed : SpeedValue;\n        attribute acceleration : AccelerationValue;\n        attribute position : LengthValue;\n        attribute wheelPower : PowerValue;\n        attribute effectivePower : PowerValue;\n        attribute aerodynamicDragCoefficient : Real;\n        attribute frictionCoefficient : Real;\n        attribute initialSpeed : SpeedValue;\n        attribute time : TimeValue;\n        \n        calc def calculateEffectivePower {\n            in wheelPower : PowerValue;\n            in aerodynamicDragCoefficient : Real;\n            in frictionCoefficient : Real;\n            in mass : MassValue;\n            in speed : SpeedValue;\n            return effectivePower : PowerValue;\n        }\n        \n        calc def calculateAcceleration {\n            in effectivePower : PowerValue;\n            in mass : MassValue;\n            in speed : SpeedValue;\n            return acceleration : AccelerationValue;\n        }\n        \n        calc def calculateSpeed {\n            in acceleration : AccelerationValue;\n            in initialSpeed : SpeedValue;\n            in time : TimeValue;\n            return speed : SpeedValue;\n        }\n        \n        calc def calculateDisplacement {\n            in speed : SpeedValue;\n            in time : TimeValue;\n            return displacement : LengthValue;\n        }\n    }\n    \n    part vehicleDynamicsCalculator : Vehicle {\n        perform action calculateDynamics {\n            action calculatePower : calculateEffectivePower {\n                in wheelPower = vehicleDynamicsCalculator.wheelPower;\n                in aerodynamicDragCoefficient = vehicleDynamicsCalculator.aerodynamicDragCoefficient;\n                in frictionCoefficient = vehicleDynamicsCalculator.frictionCoefficient;\n                in mass = vehicleDynamicsCalculator.mass;\n                in speed = vehicleDynamicsCalculator.speed;\n                out effectivePower = vehicleDynamicsCalculator.effectivePower;\n            }\n            \n            then action calculateAcc : calculateAcceleration {\n                in effectivePower = vehicleDynamicsCalculator.effectivePower;\n                in mass = vehicleDynamicsCalculator.mass;\n                in speed = vehicleDynamicsCalculator.speed;\n                out acceleration = vehicleDynamicsCalculator.acceleration;\n            }\n            \n            then action calculateVelocity : calculateSpeed {\n                in acceleration = vehicleDynamicsCalculator.acceleration;\n                in initialSpeed = vehicleDynamicsCalculator.initialSpeed;\n                in time = vehicleDynamicsCalculator.time;\n                out speed = vehicleDynamicsCalculator.speed;\n            }\n            \n            then action calculatePosition : calculateDisplacement {\n                in speed = vehicleDynamicsCalculator.speed;\n                in time = vehicleDynamicsCalculator.time;\n                out displacement = vehicleDynamicsCalculator.position;\n            }\n        }\n    }\n    \n    requirement def VehicleDynamicsRequirements {\n        doc /* The system must calculate core vehicle dynamics parameters */\n        \n        requirement calculatePowerOutput {\n            doc /* System shall calculate actual available power output based on wheel power,\n                   aerodynamic drag coefficient, friction coefficient, vehicle mass, and speed */\n            subject vehicle : Vehicle;\n        }\n        \n        requirement deduceAcceleration {\n            doc /* System shall deduce vehicle acceleration based on effective power, mass, and current speed */\n            subject vehicle : Vehicle;\n        }\n        \n        requirement calculateSpeedAtTime {\n            doc /* System shall calculate vehicle speed at any given moment using acceleration, initial speed, and time */\n            subject vehicle : Vehicle;\n        }\n        \n        requirement estimateDisplacement {\n            doc /* System shall estimate vehicle displacement based on speed and time */\n            subject vehicle : Vehicle;\n        }\n        \n        requirement highAccuracy {\n            doc /* System shall provide high accuracy in all calculations */\n            subject vehicle : Vehicle;\n        }\n        \n        requirement clearParameterRelationships {\n            doc /* System shall maintain clear logical relationships between all parameters */\n            subject vehicle : Vehicle;\n        }\n        \n        requirement practicalEngineering {\n            doc /* System results shall be convenient for practical engineering applications */\n            subject vehicle : Vehicle;\n        }\n    }\n    \n    satisfy requirement calculatePowerOutput by vehicleDynamicsCalculator.calculatePower;\n    satisfy requirement deduceAcceleration by vehicleDynamicsCalculator.calculateAcc;\n    satisfy requirement calculateSpeedAtTime by vehicleDynamicsCalculator.calculateVelocity;\n    satisfy requirement estimateDisplacement by vehicleDynamicsCalculator.calculatePosition;\n}",
    "<scratchpad>\nLet me analyze the requirement step by step:\n\n1. Key functional information:\n- Simulate and compute dynamic behavior of vehicles during straight-line driving\n- Calculate vehicle's acceleration, speed, and position\n- Consider aerodynamic drag and rolling resistance\n- Use wheel-end output power and total vehicle mass\n- Allow users to set key parameters\n- Support performance analysis, energy consumption simulation, and driving strategy optimization\n\n2. Key non-functional information:\n- Provide accurate physical modeling\n- Flexible parameter setting\n- Dynamic calculation based on time steps\n\n3. Mapping to SysML v2:\n- Need a package to contain the model\n- Define parts for vehicle, aerodynamics, resistance\n- Define attributes for physical properties (mass, drag coefficient, rolling resistance coefficient, power, speed, position, acceleration)\n- Define calculations/constraints for the physics equations\n- Define actions for the simulation behavior\n- Use calc definitions for reusable calculations\n- Define requirements to capture the system needs\n</scratchpad>\n\npackage VehicleDynamicsSimulation {\n    import SI::*;\n    import ISQ::*;\n    import ScalarValues::*;\n    \n    part def Vehicle {\n        attribute mass : MassValue;\n        attribute position : LengthValue;\n        attribute speed : SpeedValue;\n        attribute acceleration : AccelerationValue;\n        attribute wheelEndPower : PowerValue;\n        attribute dragCoefficient : Real;\n        attribute rollingResistanceCoefficient : Real;\n        attribute frontalArea : AreaValue;\n        \n        calc aerodynamicDrag : ForceValue = 0.5 * 1.225[kg/m^3] * dragCoefficient * frontalArea * speed^2;\n        calc rollingResistance : ForceValue = rollingResistanceCoefficient * mass * 9.81[m/s^2];\n        calc totalResistance : ForceValue = aerodynamicDrag + rollingResistance;\n        calc drivingForce : ForceValue = wheelEndPower / speed;\n        calc netForce : ForceValue = drivingForce - totalResistance;\n    }\n    \n    calc def computeAcceleration(vehicle : Vehicle) : AccelerationValue {\n        vehicle.netForce / vehicle.mass\n    }\n    \n    calc def updateSpeed(currentSpeed : SpeedValue, acceleration : AccelerationValue, timeStep : TimeValue) : SpeedValue {\n        currentSpeed + acceleration * timeStep\n    }\n    \n    calc def updatePosition(currentPosition : LengthValue, speed : SpeedValue, timeStep : TimeValue) : LengthValue {\n        currentPosition + speed * timeStep\n    }\n    \n    action def SimulateVehicleDynamics {\n        in vehicle : Vehicle;\n        in initialSpeed : SpeedValue;\n        in initialPosition : LengthValue;\n        in timeStep : TimeValue;\n        in simulationDuration : TimeValue;\n        \n        out finalSpeed : SpeedValue;\n        out finalPosition : LengthValue;\n        out trajectory : LengthValue[*];\n        \n        action simulationLoop {\n            first start;\n            then merge continueOrStop;\n            \n            action continueOrStop : DecisionNode {\n                if currentTime < simulationDuration then computeStep\n                else done;\n            }\n            \n            action computeStep {\n                vehicle.acceleration := computeAcceleration(vehicle);\n                vehicle.speed := updateSpeed(vehicle.speed, vehicle.acceleration, timeStep);\n                vehicle.position := updatePosition(vehicle.position, vehicle.speed, timeStep);\n                trajectory := trajectory->including(vehicle.position);\n                currentTime := currentTime + timeStep;\n                then continueOrStop;\n            }\n            \n            action initialize {\n                vehicle.speed := initialSpeed;\n                vehicle.position := initialPosition;\n                currentTime := 0[s];\n                trajectory := Sequence{initialPosition};\n                then continueOrStop;\n            }\n            \n            state start;\n            transition first start then initialize;\n            \n            state done;\n            action setOutputs {\n                finalSpeed := vehicle.speed;\n                finalPosition := vehicle.position;\n            }\n            transition continueOrStop.done then setOutputs then done;\n        }\n    }\n    \n    requirement def VehicleDynamicsRequirements {\n        doc /* The system shall simulate and compute dynamic behavior of vehicles during straight-line driving */\n        \n        requirement aerodynamicConsideration {\n            doc /* The system shall consider aerodynamic drag in calculations */\n        }\n        \n        requirement rollingResistanceConsideration {\n            doc /* The system shall consider rolling resistance in calculations */\n        }\n        \n        requirement dynamicCalculation {\n            doc /* The system shall dynamically calculate acceleration, speed, and position based on time steps */\n        }\n        \n        requirement parameterFlexibility {\n            doc /* The system shall allow users to flexibly set key parameters */\n        }\n        \n        requirement accurateModeling {\n            doc /* The system shall provide accurate physical modeling */\n        }\n    }\n    \n    part vehicleDynamicsSystem : Vehicle {\n        perform SimulateVehicleDynamics(\n            vehicle = vehicleDynamicsSystem,\n            initialSpeed = initialSpeed,\n            initialPosition = initialPosition,\n            timeStep = timeStep,\n            simulationDuration = simulationDuration\n        );\n    }\n}",
    "I'll analyze the requirements and create a SysML v2 model for the vehicle dynamics system.\n\n<scratchpad>\nKey functional requirements:\n- Model and compute vehicle driving dynamics\n- Accept user input parameters (mass, wheel power, drag coefficient, rolling resistance, initial speed/position)\n- Calculate and update speed and position at each time step\n- Account for air resistance and rolling resistance\n- Predict velocity, acceleration, displacement over time\n- Support vehicle performance analysis\n\nKey non-functional requirements:\n- Automation of dynamics simulation\n- Efficient management of simulation\n\nSysML v2 mapping:\n- Use package for overall organization\n- Define part definitions for Vehicle, DynamicsCalculator\n- Use attributes for parameters (mass, power, coefficients)\n- Use ports for inputs/outputs\n- Define actions for calculations\n- Use state machines for time-stepped simulation\n- Define requirements for traceability\n</scratchpad>\n\npackage VehicleDynamicsSystem {\n    import SI::*;\n    import Time::*;\n    \n    attribute def VehicleParameters {\n        attribute mass : MassValue;\n        attribute wheelPower : PowerValue;\n        attribute dragCoefficient : Real;\n        attribute rollingResistanceCoefficient : Real;\n        attribute frontalArea : AreaValue;\n    }\n    \n    attribute def DynamicState {\n        attribute position : LengthValue;\n        attribute velocity : SpeedValue;\n        attribute acceleration : AccelerationValue;\n        attribute time : TimeValue;\n    }\n    \n    part def Vehicle {\n        attribute parameters : VehicleParameters;\n        attribute currentState : DynamicState;\n        \n        port inputPort : ~VehicleParameters;\n        port outputPort : DynamicState;\n    }\n    \n    part def DynamicsCalculator {\n        in attribute vehicleParams : VehicleParameters;\n        in attribute currentState : DynamicState;\n        in attribute timeStep : TimeValue;\n        out attribute nextState : DynamicState;\n        \n        private attribute airDensity : Real = 1.225; // kg/m³\n        \n        calc def calculateForces {\n            in params : VehicleParameters;\n            in state : DynamicState;\n            return netForce : ForceValue;\n            \n            attribute dragForce : ForceValue = \n                0.5 * airDensity * params.dragCoefficient * \n                params.frontalArea * state.velocity ** 2;\n                \n            attribute rollingResistance : ForceValue = \n                params.rollingResistanceCoefficient * \n                params.mass * 9.81;\n                \n            attribute tractionForce : ForceValue = \n                params.wheelPower / state.velocity;\n                \n            netForce = tractionForce - dragForce - rollingResistance;\n        }\n        \n        action computeNextState {\n            in params : VehicleParameters;\n            in current : DynamicState;\n            in dt : TimeValue;\n            out next : DynamicState;\n            \n            calc netForce : ForceValue = calculateForces(params, current);\n            \n            next.acceleration = netForce / params.mass;\n            next.velocity = current.velocity + next.acceleration * dt;\n            next.position = current.position + current.velocity * dt + \n                           0.5 * next.acceleration * dt ** 2;\n            next.time = current.time + dt;\n        }\n    }\n    \n    part def VehicleDynamicsSimulator {\n        part vehicle : Vehicle;\n        part calculator : DynamicsCalculator;\n        \n        attribute simulationTimeStep : TimeValue = 0.1; // seconds\n        attribute simulationDuration : TimeValue = 100; // seconds\n        \n        port userInputs {\n            in attribute vehicleParams : VehicleParameters;\n            in attribute initialSpeed : SpeedValue;\n            in attribute initialPosition : LengthValue;\n        }\n        \n        port simulationOutputs {\n            out attribute stateHistory : DynamicState[*] ordered;\n        }\n        \n        state def SimulationStates {\n            entry state Initialize;\n            state Running;\n            state Completed;\n            \n            transition Initialize_to_Running\n                first Initialize\n                then Running\n                guard vehicle.currentState.time < simulationDuration;\n                \n            transition Running_to_Running\n                first Running\n                then Running\n                guard vehicle.currentState.time < simulationDuration\n                do action updateVehicleState;\n                \n            transition Running_to_Completed\n                first Running\n                then Completed\n                guard vehicle.currentState.time >= simulationDuration;\n        }\n        \n        action updateVehicleState {\n            bind calculator.vehicleParams = vehicle.parameters;\n            bind calculator.currentState = vehicle.currentState;\n            bind calculator.timeStep = simulationTimeStep;\n            \n            perform calculator.computeNextState;\n            \n            set vehicle.currentState = calculator.nextState;\n            append stateHistory = vehicle.currentState;\n        }\n    }\n    \n    requirement def FunctionalRequirements {\n        doc /* System shall model and compute vehicle driving dynamics */\n        \n        requirement modelDynamics {\n            doc /* System shall calculate vehicle dynamics including speed, \n                   position, and acceleration */\n        }\n        \n        requirement userInputHandling {\n            doc /* System shall accept user input parameters including mass, \n                   power, drag coefficient, rolling resistance, initial conditions */\n        }\n        \n        requirement resistanceModeling {\n            doc /* System shall account for air resistance and rolling resistance */\n        }\n        \n        requirement timeSteppedSimulation {\n            doc /* System shall update vehicle state at each time step */\n        }\n    }\n    \n    requirement def NonFunctionalRequirements {\n        requirement automation {\n            doc /* System shall provide automated dynamics simulation */\n        }\n        \n        requirement efficiency {\n            doc /* System shall efficiently manage simulation computations */\n        }\n    }\n    \n    satisfy FunctionalRequirements::modelDynamics by VehicleDynamicsSimulator;\n    satisfy FunctionalRequirements::userInputHandling by VehicleDynamicsSimulator::userInputs;\n    satisfy FunctionalRequirements::resistanceModeling by DynamicsCalculator::calculateForces;\n    satisfy FunctionalRequirements::timeSteppedSimulation by VehicleDynamicsSimulator::updateVehicleState;\n}",
    "package VehicleLongitudinalDynamics {\n    import SI::*;\n    import ISQ::*;\n    import Quantities::*;\n    import MeasurementReferences::*;\n    import CalculationDefinitions::*;\n    \n    attribute def Position :> LengthValue;\n    attribute def Velocity :> SpeedValue;\n    attribute def Acceleration :> AccelerationValue;\n    attribute def Mass :> MassValue;\n    attribute def Power :> PowerValue;\n    attribute def Force :> ForceValue;\n    attribute def DragCoefficient :> Real;\n    attribute def FrictionCoefficient :> Real;\n    attribute def TimeInterval :> DurationValue;\n    \n    part def Vehicle {\n        attribute mass : Mass;\n        attribute dragCoefficient : DragCoefficient;\n        attribute frictionCoefficient : FrictionCoefficient;\n        attribute currentPosition : Position;\n        attribute currentVelocity : Velocity;\n        attribute currentAcceleration : Acceleration;\n    }\n    \n    part def DynamicsCalculator {\n        in vehicle : Vehicle;\n        in wheelPower : Power;\n        in timeInterval : TimeInterval;\n        in initialPosition : Position;\n        in initialVelocity : Velocity;\n        \n        out finalPosition : Position;\n        out finalVelocity : Velocity;\n        out acceleration : Acceleration;\n        \n        private attribute driveForce : Force;\n        private attribute dragForce : Force;\n        private attribute frictionForce : Force;\n        private attribute netForce : Force;\n        \n        calc def calculateDriveForce {\n            in power : Power;\n            in velocity : Velocity;\n            return force : Force;\n        }\n        \n        calc def calculateDragForce {\n            in dragCoeff : DragCoefficient;\n            in velocity : Velocity;\n            return force : Force;\n        }\n        \n        calc def calculateFrictionForce {\n            in frictionCoeff : FrictionCoefficient;\n            in mass : Mass;\n            return force : Force;\n        }\n        \n        calc def calculateAcceleration {\n            in netForce : Force;\n            in mass : Mass;\n            return acceleration : Acceleration;\n        }\n        \n        calc def calculateFinalVelocity {\n            in initialVelocity : Velocity;\n            in acceleration : Acceleration;\n            in timeInterval : TimeInterval;\n            return finalVelocity : Velocity;\n        }\n        \n        calc def calculateFinalPosition {\n            in initialPosition : Position;\n            in initialVelocity : Velocity;\n            in acceleration : Acceleration;\n            in timeInterval : TimeInterval;\n            return finalPosition : Position;\n        }\n    }\n    \n    constraint def PhysicalConstraints {\n        doc /* Ensures physical consistency of motion simulation */\n        \n        constraint velocityNonNegative {\n            doc /* Vehicle velocity must be non-negative for forward motion */\n        }\n        \n        constraint powerLimit {\n            doc /* Drive power must be within realistic bounds */\n        }\n        \n        constraint accelerationLimit {\n            doc /* Acceleration must be within physical limits */\n        }\n    }\n    \n    action def SimulateVehicleDynamics {\n        in vehicle : Vehicle;\n        in initialState : VehicleState;\n        in wheelPower : Power;\n        in timeInterval : TimeInterval;\n        out finalState : VehicleState;\n        \n        bind calculator : DynamicsCalculator;\n        \n        first start;\n        then action calculateForces {\n            assign calculator.driveForce := calculator.calculateDriveForce(wheelPower, initialState.velocity);\n            assign calculator.dragForce := calculator.calculateDragForce(vehicle.dragCoefficient, initialState.velocity);\n            assign calculator.frictionForce := calculator.calculateFrictionForce(vehicle.frictionCoefficient, vehicle.mass);\n            assign calculator.netForce := calculator.driveForce - calculator.dragForce - calculator.frictionForce;\n        }\n        then action calculateMotion {\n            assign calculator.acceleration := calculator.calculateAcceleration(calculator.netForce, vehicle.mass);\n            assign finalState.velocity := calculator.calculateFinalVelocity(initialState.velocity, calculator.acceleration, timeInterval);\n            assign finalState.position := calculator.calculateFinalPosition(initialState.position, initialState.velocity, calculator.acceleration, timeInterval);\n            assign finalState.acceleration := calculator.acceleration;\n        }\n        then done;\n    }\n    \n    attribute def VehicleState {\n        attribute position : Position;\n        attribute velocity : Velocity;\n        attribute acceleration : Acceleration;\n    }\n    \n    requirement def FunctionalRequirements {\n        doc /* System shall calculate vehicle dynamics based on input parameters */\n        \n        requirement calculateAcceleration {\n            doc /* System shall calculate acceleration considering all forces */\n        }\n        \n        requirement calculateFinalVelocity {\n            doc /* System shall calculate final velocity after time interval */\n        }\n        \n        requirement calculateFinalPosition {\n            doc /* System shall calculate final position after time interval */\n        }\n        \n        requirement considerResistances {\n            doc /* System shall consider air drag and friction resistance */\n        }\n    }\n    \n    requirement def NonFunctionalRequirements {\n        doc /* System performance and quality requirements */\n        \n        requirement accuracy {\n            doc /* Calculations shall maintain physical consistency and accuracy */\n        }\n        \n        requirement applicability {\n            doc /* System shall support linear uniformly accelerated motion scenarios */\n        }\n        \n        requirement usability {\n            doc /* System shall accept user inputs for initial conditions and parameters */\n        }\n    }\n    \n    verification def VerifyDynamicsCalculation {\n        subject calculator : DynamicsCalculator;\n        \n        verify requirement FunctionalRequirements::calculateAcceleration;\n        verify requirement FunctionalRequirements::calculateFinalVelocity;\n        verify requirement FunctionalRequirements::calculateFinalPosition;\n        verify requirement NonFunctionalRequirements::accuracy;\n    }\n}",
    "<scratchpad>\nLet me analyze the requirement step by step:\n\n1. Key functional information:\n   - System manages vehicle's total mass\n   - Vehicle consists of: chassis, engine, gearbox\n   - Each component has its own mass parameter\n   - System calculates total mass\n   - System checks compliance with 2,500 kg limit\n   - System issues overweight warning if limit exceeded\n\n2. Key non-functional information:\n   - Maximum permitted limit: 2,500 kg\n   - Weight regulation compliance\n\n3. SysML v2 mapping:\n   - Need a package to contain the model\n   - Define parts for vehicle components (chassis, engine, gearbox)\n   - Define attributes for mass values\n   - Define a constraint for the 2,500 kg limit\n   - Define a requirement for the mass limit\n   - Define an action/behavior for calculating total mass\n   - Define a verification case to check compliance\n   - Use assert to check the constraint\n</scratchpad>\n\npackage VehicleMassManagementSystem {\n    import ScalarValues::*;\n    import ISQ::*;\n    import SI::*;\n    \n    part def Vehicle {\n        attribute totalMass : MassValue;\n        \n        part chassis : Chassis;\n        part engine : Engine;\n        part gearbox : Gearbox;\n        \n        constraint massLimit {\n            totalMass.num <= 2500\n        }\n        \n        calc totalMassCalculation : MassValue {\n            chassis.mass + engine.mass + gearbox.mass\n        }\n        \n        attribute :>> totalMass = totalMassCalculation;\n    }\n    \n    part def Chassis {\n        attribute mass : MassValue;\n    }\n    \n    part def Engine {\n        attribute mass : MassValue;\n    }\n    \n    part def Gearbox {\n        attribute mass : MassValue;\n    }\n    \n    requirement def VehicleMassRequirement {\n        doc /* The vehicle's total mass shall not exceed 2,500 kilograms */\n        \n        attribute maxPermittedMass : MassValue = 2500[kg];\n        \n        require constraint {\n            doc /* Total mass of chassis, engine, and gearbox must not exceed maximum permitted limit */\n        }\n    }\n    \n    requirement vehicleMassReq : VehicleMassRequirement;\n    \n    part vehicle : Vehicle {\n        satisfy vehicleMassReq by massLimit;\n    }\n    \n    verification def MassComplianceVerification {\n        subject vehicle : Vehicle;\n        \n        verify requirement vehicleMassReq;\n        \n        return verdict : VerdictKind;\n    }\n    \n    verification massComplianceCheck : MassComplianceVerification {\n        subject :>> vehicle;\n        \n        action checkTotalMass {\n            calc isOverweight : Boolean = vehicle.totalMass.num > 2500;\n            \n            if isOverweight {\n                send OverweightWarning() to vehicle;\n            }\n            \n            assert constraint { !isOverweight }\n        }\n        \n        return :>> verdict = checkTotalMass.isOverweight ? fail : pass;\n    }\n    \n    message OverweightWarning {\n        attribute totalMass : MassValue;\n        attribute exceededBy : MassValue;\n    }\n}",
    "package VehicleMassManagement {\n    import ScalarValues::*;\n    import Quantities::*;\n    import MeasurementReferences::*;\n    import SI::*;\n    \n    attribute def MassValue :> ScalarQuantityValue {\n        attribute quantityDimension redefines quantityDimension = mass;\n        attribute measurementReference redefines measurementReference = kg;\n    }\n    \n    part def Vehicle {\n        attribute totalMass : MassValue;\n        attribute massLimit : MassValue = 2500 [kg];\n        \n        part chassis : Chassis;\n        part engine : Engine;\n        part transmission : Transmission;\n        \n        constraint massConstraint {\n            totalMass == chassis.mass + engine.mass + transmission.mass\n        }\n        \n        constraint massLimitConstraint {\n            totalMass <= massLimit\n        }\n        \n        requirement massRequirement {\n            doc /* The total mass of the vehicle shall not exceed 2500 kg */\n            require constraint massLimitConstraint;\n        }\n    }\n    \n    part def Chassis {\n        attribute mass : MassValue;\n    }\n    \n    part def Engine {\n        attribute mass : MassValue;\n    }\n    \n    part def Transmission {\n        attribute mass : MassValue;\n    }\n    \n    calc def CalculateTotalMass {\n        in chassisMass : MassValue;\n        in engineMass : MassValue;\n        in transmissionMass : MassValue;\n        return totalMass : MassValue = chassisMass + engineMass + transmissionMass;\n    }\n}",
    "package VehicleMassManagementSystem {\n    import ScalarValues::*;\n    import Quantities::*;\n    import MeasurementReferences::*;\n    import SI::*;\n    \n    attribute def MassValue :> ScalarQuantityValue {\n        attribute quantityDimension redefines quantityDimension = mass;\n        attribute measurementReference redefines measurementReference = kg;\n    }\n    \n    part def Chassis {\n        attribute mass : MassValue;\n    }\n    \n    part def Engine {\n        attribute mass : MassValue;\n    }\n    \n    part def Transmission {\n        attribute mass : MassValue;\n    }\n    \n    part def Vehicle {\n        part chassis : Chassis;\n        part engine : Engine;\n        part transmission : Transmission;\n        \n        attribute totalMass : MassValue = chassis.mass + engine.mass + transmission.mass;\n    }\n    \n    requirement def VehicleMassCompliance {\n        doc /* The total mass of the complete vehicle must not exceed 2,500 kilograms */\n        attribute maxMass : MassValue = 2500;\n        \n        subject vehicle : Vehicle;\n        \n        require constraint {\n            vehicle.totalMass <= maxMass\n        }\n    }\n    \n    part vehicleMassManagementSystem {\n        part vehicle : Vehicle;\n        \n        requirement vehicleMassRequirement : VehicleMassCompliance {\n            subject = vehicle;\n        }\n        \n        action verifyMassCompliance {\n            in vehicleToVerify : Vehicle;\n            out isCompliant : Boolean;\n            \n            bind isCompliant = vehicleToVerify.totalMass <= 2500;\n        }\n    }\n}",
    "package VehicleWeightManagementSystem {\n    \n    import ScalarValues::*;\n    import Quantities::*;\n    import MeasurementReferences::*;\n    import SI::*;\n    \n    requirement def VehicleWeightRequirement {\n        doc /* The combined weight of main vehicle components shall not exceed 2,500 kilograms */\n        \n        attribute maxTotalWeight : MassValue = 2500[kg];\n    }\n    \n    part def VehicleComponent {\n        attribute weight : MassValue;\n    }\n    \n    part def Chassis :> VehicleComponent;\n    part def Engine :> VehicleComponent;\n    part def Transmission :> VehicleComponent;\n    \n    part def WeightManagementSystem {\n        part chassis : Chassis;\n        part engine : Engine;\n        part transmission : Transmission;\n        \n        attribute totalWeight : MassValue = chassis.weight + engine.weight + transmission.weight;\n        attribute weightLimit : MassValue = 2500[kg];\n        attribute isOverweight : Boolean = totalWeight > weightLimit;\n        \n        action recordComponentWeight {\n            in componentType : String;\n            in componentWeight : MassValue;\n        }\n        \n        action calculateTotalWeight {\n            out calculatedWeight : MassValue = totalWeight;\n        }\n        \n        action checkWeightCompliance {\n            out complianceStatus : Boolean = !isOverweight;\n            out warningMessage : String = isOverweight ? \"WARNING: Total weight exceeds 2,500 kg limit\" : \"Weight within acceptable limits\";\n        }\n        \n        constraint weightConstraint {\n            doc /* Total weight must not exceed regulatory limit */\n            totalWeight <= weightLimit\n        }\n    }\n    \n    part vehicleWeightSystem : WeightManagementSystem {\n        satisfy vehicleWeightReq : VehicleWeightRequirement by weightConstraint;\n    }\n}",
    "package VehicleSystem {\n    import ScalarValues::*;\n    import ISQ::*;\n    import SI::*;\n    \n    part def Vehicle {\n        attribute totalMass : MassValue;\n        \n        part chassis : Chassis;\n        part engine : Engine;\n        part transmission : Transmission;\n        \n        constraint massComposition {\n            totalMass == chassis.mass + engine.mass + transmission.mass\n        }\n        \n        constraint massLimit {\n            totalMass <= 2500[kg]\n        }\n    }\n    \n    part def Chassis {\n        attribute mass : MassValue;\n    }\n    \n    part def Engine {\n        attribute mass : MassValue;\n    }\n    \n    part def Transmission {\n        attribute mass : MassValue;\n    }\n    \n    constraint def VehicleDynamics {\n        in initialVelocity : SpeedValue;\n        in finalVelocity : SpeedValue;\n        in mass : MassValue;\n        in appliedForce : ForceValue;\n        in timePeriod : DurationValue;\n        \n        constraint massPositive {\n            mass > 0[kg]\n        }\n        \n        constraint dynamicRelationship {\n            appliedForce == mass * (finalVelocity - initialVelocity) / timePeriod\n        }\n    }\n    \n    part vehicleInstance : Vehicle {\n        perform action dynamicAnalysis {\n            in initialVel : SpeedValue;\n            in finalVel : SpeedValue;\n            in force : ForceValue;\n            in duration : DurationValue;\n            \n            assert constraint vehicleDynamicConstraint : VehicleDynamics {\n                in initialVelocity = initialVel;\n                in finalVelocity = finalVel;\n                in mass = totalMass;\n                in appliedForce = force;\n                in timePeriod = duration;\n            }\n        }\n    }\n}",
    "I'll analyze this vehicle maintenance management system requirement and create a SysML v2 model.\n\n<scratchpad>\nKey functional requirements:\n- Manage and monitor maintenance schedule for vehicles\n- Set specific next maintenance time for each vehicle\n- Set fixed maintenance interval for each vehicle\n- Record maximum allowed temperature\n- Automatically determine if vehicle reached maintenance time\n- Switch vehicle status to \"under maintenance\" when scheduled time reached\n- Actual maintenance start time must be after scheduled time\n- Maintenance must start within 2 seconds after healthy state ends\n- Maintenance duration must not exceed 48 hours\n- After maintenance, next maintenance time is postponed by interval\n- Health status restored to normal after maintenance\n\nKey non-functional requirements:\n- Timing constraint: 2 seconds max between healthy state end and maintenance start\n- Duration constraint: 48 hours max maintenance duration\n\nSysML v2 elements to use:\n- Package for organization\n- Part definitions for Vehicle, MaintenanceScheduler\n- Attributes for properties (nextMaintenanceTime, maintenanceInterval, maxTemperature, status, healthStatus)\n- States and state machines for vehicle status transitions\n- Constraints for timing and duration requirements\n- Actions for maintenance operations\n- Requirements for capturing the constraints\n</scratchpad>\n\npackage VehicleMaintenanceSystem {\n    import ScalarValues::*;\n    import ISQ::*;\n    import SI::*;\n    \n    enum def VehicleStatus {\n        enum operational;\n        enum underMaintenance;\n    }\n    \n    enum def HealthStatus {\n        enum healthy;\n        enum needsMaintenance;\n    }\n    \n    attribute def Temperature :> ScalarQuantityValue {\n        attribute quantityDimension = ISQ::temperature;\n        attribute unit = SI::K;\n    }\n    \n    part def Vehicle {\n        attribute vehicleID : String;\n        attribute nextMaintenanceTime : Time;\n        attribute maintenanceInterval : Duration;\n        attribute maxAllowedTemperature : Temperature;\n        attribute currentTemperature : Temperature;\n        attribute status : VehicleStatus = VehicleStatus::operational;\n        attribute healthStatus : HealthStatus = HealthStatus::healthy;\n        attribute lastHealthyStateEndTime : Time;\n        attribute actualMaintenanceStartTime : Time;\n        \n        state vehicleStates {\n            entry state;\n            state operational {\n                entry action {\n                    status := VehicleStatus::operational;\n                    healthStatus := HealthStatus::healthy;\n                }\n            }\n            state underMaintenance {\n                entry action {\n                    status := VehicleStatus::underMaintenance;\n                }\n                constraint maintenanceDuration {\n                    doc /* Maintenance duration must not exceed 48 hours */\n                    (currentTime - actualMaintenanceStartTime) <= 48 [h]\n                }\n            }\n            \n            transition operational_to_maintenance\n                first operational\n                then underMaintenance\n                guard (currentTime >= nextMaintenanceTime);\n                \n            transition maintenance_to_operational\n                first underMaintenance\n                then operational\n                effect action {\n                    nextMaintenanceTime := actualMaintenanceStartTime + maintenanceInterval;\n                    healthStatus := HealthStatus::healthy;\n                }\n        }\n    }\n    \n    part def MaintenanceScheduler {\n        part vehicles : Vehicle[*];\n        \n        action checkMaintenanceSchedule {\n            for vehicle in vehicles {\n                if (currentTime >= vehicle.nextMaintenanceTime) {\n                    send MaintenanceRequired() to vehicle;\n                }\n            }\n        }\n        \n        action initiateMaintenanceFor(in vehicle : Vehicle) {\n            vehicle.lastHealthyStateEndTime := currentTime;\n            vehicle.actualMaintenanceStartTime := currentTime;\n            assert constraint {\n                doc /* Actual maintenance start time must be later than scheduled */\n                vehicle.actualMaintenanceStartTime > vehicle.nextMaintenanceTime\n            }\n            assert constraint {\n                doc /* Maintenance must start within 2 seconds after healthy state ends */\n                (vehicle.actualMaintenanceStartTime - vehicle.lastHealthyStateEndTime) <= 2 [s]\n            }\n        }\n    }\n    \n    requirement def MaintenanceTimingRequirement {\n        doc /* The actual maintenance start time must be later than the scheduled maintenance time */\n        subject vehicle : Vehicle;\n        require constraint {\n            vehicle.actualMaintenanceStartTime > vehicle.nextMaintenanceTime\n        }\n    }\n    \n    requirement def MaintenanceStartDelayRequirement {\n        doc /* Maintenance must be initiated within 2 seconds after the previous healthy state ends */\n        subject vehicle : Vehicle;\n        require constraint {\n            (vehicle.actualMaintenanceStartTime - vehicle.lastHealthyStateEndTime) <= 2 [s]\n        }\n    }\n    \n    requirement def MaintenanceDurationRequirement {\n        doc /* The duration of the maintenance must not exceed 48 hours */\n        subject vehicle : Vehicle;\n        require constraint {\n            (currentTime - vehicle.actualMaintenanceStartTime) <= 48 [h]\n        }\n    }\n    \n    part vehicleMaintenanceSystem {\n        part scheduler : MaintenanceScheduler;\n        part fleet : Vehicle[*];\n        \n        bind scheduler.vehicles = fleet;\n    }\n}",
    "package VehicleSystemRequirements {\n    import ScalarValues::*;\n    import ISQ::*;\n    import SI::*;\n    \n    requirement def VehicleMassRequirement {\n        doc /* The total mass of the vehicle (including curb weight and fuel mass) \n             * must not exceed the specified maximum mass limit */\n        \n        attribute maxMassLimit : MassValue;\n        attribute curbWeight : MassValue;\n        attribute fuelMass : MassValue;\n        \n        require constraint {\n            (curbWeight + fuelMass) <= maxMassLimit\n        }\n    }\n    \n    requirement def FuelMassRequirement {\n        doc /* The fuel mass must be a positive value */\n        \n        attribute fuelMass : MassValue;\n        \n        require constraint {\n            fuelMass > 0 [kg]\n        }\n    }\n    \n    requirement def EngineTorqueRequirement {\n        doc /* The engine must be able to generate corresponding torque \n             * according to the speed curve */\n        \n        attribute engineSpeed : AngularVelocityValue;\n        attribute engineTorque : TorqueValue;\n        \n        requirement torqueGenerationCapability {\n            doc /* Engine shall generate torque as a function of speed */\n        }\n    }\n    \n    requirement def PowerTransmissionRequirement {\n        doc /* The torque produced by the engine must be effectively transmitted \n             * to the transmission through the clutch interface */\n        \n        attribute engineOutputTorque : TorqueValue;\n        attribute transmissionInputTorque : TorqueValue;\n        attribute clutchEfficiency : Real;\n        \n        require constraint {\n            transmissionInputTorque == engineOutputTorque * clutchEfficiency\n        }\n        \n        requirement smoothPowerDelivery {\n            doc /* Ensure that power is smoothly delivered to the vehicle's drive system */\n        }\n    }\n    \n    part def Engine {\n        port engineOutput : PowerPort;\n        attribute speed : AngularVelocityValue;\n        attribute torque : TorqueValue;\n    }\n    \n    part def Clutch {\n        port clutchInput : PowerPort;\n        port clutchOutput : PowerPort;\n        attribute efficiency : Real;\n    }\n    \n    part def Transmission {\n        port transmissionInput : PowerPort;\n        port transmissionOutput : PowerPort;\n    }\n    \n    part def Vehicle {\n        attribute totalMass : MassValue;\n        attribute curbWeight : MassValue;\n        attribute fuelMass : MassValue;\n        \n        part engine : Engine;\n        part clutch : Clutch;\n        part transmission : Transmission;\n        \n        interface : PowerInterface connect engine.engineOutput to clutch.clutchInput;\n        interface : PowerInterface connect clutch.clutchOutput to transmission.transmissionInput;\n        \n        satisfy vehicleMassReq : VehicleMassRequirement by Vehicle {\n            redefines maxMassLimit;\n            redefines curbWeight = Vehicle::curbWeight;\n            redefines fuelMass = Vehicle::fuelMass;\n        }\n        \n        satisfy fuelMassReq : FuelMassRequirement by Vehicle {\n            redefines fuelMass = Vehicle::fuelMass;\n        }\n        \n        satisfy engineTorqueReq : EngineTorqueRequirement by engine {\n            redefines engineSpeed = engine::speed;\n            redefines engineTorque = engine::torque;\n        }\n        \n        satisfy powerTransReq : PowerTransmissionRequirement by Vehicle {\n            redefines engineOutputTorque = engine::torque;\n            redefines clutchEfficiency = clutch::efficiency;\n        }\n    }\n    \n    port def PowerPort {\n        attribute torque : TorqueValue;\n        attribute speed : AngularVelocityValue;\n    }\n    \n    interface def PowerInterface {\n        end source : PowerPort;\n        end target : PowerPort;\n        \n        flow source.torque to target.torque;\n        flow source.speed to target.speed;\n    }\n}",
    "<scratchpad>\nLet me analyze the requirements step by step:\n\n1. Key functional/non-functional information:\n   - Vehicle mass constraints:\n     - With full fuel tank: total mass ≤ 2000 kg\n     - With empty fuel tank: total mass ≤ 1500 kg\n     - Total mass = dry mass + fuel mass\n   - Engine requirements:\n     - Must transmit torque to transmission via clutch interface\n     - Must deliver torque according to speed-torque curve (Table 1)\n   - System goals: vehicle mass control, powertrain interface and performance\n\n2. Mapping to SysML v2:\n   - Package for organizing\n   - Part definitions for Vehicle, Engine, Transmission, Clutch\n   - Attributes for mass properties\n   - Constraints for mass requirements\n   - Interface definitions for torque transmission\n   - Requirements for capturing the stated requirements\n   - Connection/interface between engine and transmission via clutch\n</scratchpad>\n\npackage VehicleSystem {\n    \n    part def Vehicle {\n        attribute dryMass : Real;\n        attribute fuelMass : Real;\n        attribute totalMass : Real = dryMass + fuelMass;\n        \n        part engine : Engine;\n        part transmission : Transmission;\n        part clutch : Clutch;\n    }\n    \n    part def Engine {\n        attribute torqueOutput : Real;\n        attribute speed : Real;\n        port torquePort : TorqueInterface;\n    }\n    \n    part def Transmission {\n        port torqueInputPort : TorqueInterface;\n    }\n    \n    part def Clutch {\n        port engineSide : TorqueInterface;\n        port transmissionSide : TorqueInterface;\n    }\n    \n    interface def TorqueInterface {\n        attribute torque : Real;\n    }\n    \n    requirement def VehicleMassRequirements {\n        doc /* The vehicle mass must meet constraints under different fuel conditions */\n        \n        requirement fullTankMassLimit {\n            doc /* With full fuel tank, total mass must not exceed 2000 kg */\n            assume constraint { vehicle.fuelMass == vehicle.fuelTankCapacity }\n            require constraint { vehicle.totalMass <= 2000 }\n        }\n        \n        requirement emptyTankMassLimit {\n            doc /* With empty fuel tank, total mass must not exceed 1500 kg */\n            assume constraint { vehicle.fuelMass == 0 }\n            require constraint { vehicle.totalMass <= 1500 }\n        }\n    }\n    \n    requirement def EngineTorqueTransmission {\n        doc /* Engine must transmit torque to transmission via clutch */\n        subject engine : Engine;\n        \n        requirement torqueDelivery {\n            doc /* Engine must deliver torque according to speed-torque curve */\n            require constraint { engine.torqueOutput == torqueCurve(engine.speed) }\n        }\n    }\n    \n    part vehicleInstance : Vehicle {\n        connect engine.torquePort to clutch.engineSide;\n        connect clutch.transmissionSide to transmission.torqueInputPort;\n    }\n    \n    satisfy VehicleMassRequirements by vehicleInstance;\n    satisfy EngineTorqueTransmission by vehicleInstance.engine;\n}",
    "package VehicleSystemModel {\n    import ScalarValues::*;\n    \n    requirement def VehicleRequirements {\n        doc /* The system model of this project primarily outlines the basic requirements for a vehicle and its engine */\n        \n        requirement vehicleMassConstraints {\n            doc /* Vehicle mass constraints for safety and performance */\n            \n            requirement fullyFueledMass {\n                doc /* The vehicle's total mass must not exceed 2000 kilograms when fully fueled */\n                assume constraint { fullyFueledMass <= 2000[kg] }\n            }\n            \n            requirement emptyMass {\n                doc /* Vehicle mass should not be higher than 1500 kilograms when empty */\n                assume constraint { emptyMass <= 1500[kg] }\n            }\n        }\n        \n        requirement engineRequirements {\n            doc /* Engine performance and interface requirements */\n            \n            requirement torqueTransmission {\n                doc /* The engine must be capable of effectively transmitting its generated torque to the transmission system through a clutch interface */\n            }\n            \n            requirement torqueSpeedCharacteristic {\n                doc /* The torque generated by the engine should vary with speed, conforming to the relevant performance table specifications */\n            }\n        }\n        \n        requirement systemIntegration {\n            doc /* The design of both the vehicle and its engine must meet these critical requirements for mass and power interface to ensure overall vehicle performance and safety */\n        }\n    }\n    \n    part def Vehicle {\n        attribute fullyFueledMass : MassValue;\n        attribute emptyMass : MassValue;\n        \n        part engine : Engine;\n        part transmission : Transmission;\n        \n        interface clutchInterface : ClutchInterface \n            connect engine.torqueOutput to transmission.torqueInput;\n    }\n    \n    part def Engine {\n        attribute generatedTorque : TorqueValue;\n        attribute engineSpeed : AngularVelocityValue;\n        \n        port torqueOutput : TorquePort;\n    }\n    \n    part def Transmission {\n        port torqueInput : TorquePort;\n    }\n    \n    interface def ClutchInterface {\n        end supplierPort : TorquePort;\n        end consumerPort : TorquePort;\n    }\n    \n    port def TorquePort {\n        attribute torque : TorqueValue;\n    }\n    \n    attribute def MassValue :> ScalarValues::Real {\n        attribute unit : MassUnit;\n    }\n    \n    attribute def TorqueValue :> ScalarValues::Real {\n        attribute unit : TorqueUnit;\n    }\n    \n    attribute def AngularVelocityValue :> ScalarValues::Real {\n        attribute unit : AngularVelocityUnit;\n    }\n}",
    "package VehicleSystemRequirements {\n    import ScalarValues::*;\n    \n    requirement def VehicleMassRequirement {\n        doc /* The actual mass of the vehicle must not exceed the specified limit under different fuel conditions */\n        \n        attribute curbMass : MassValue;\n        attribute fuelMass : MassValue;\n        attribute totalVehicleMass : MassValue = curbMass + fuelMass;\n        \n        requirement fullTankMassLimit {\n            doc /* When fuel tank is full, total vehicle mass must not exceed 2000 kg */\n            assume constraint { fuelMass == fuelMass@max }\n            require constraint { totalVehicleMass <= 2000[kg] }\n        }\n        \n        requirement emptyTankMassLimit {\n            doc /* When fuel tank is empty, total vehicle mass must not exceed 1500 kg */\n            assume constraint { fuelMass == 0[kg] }\n            require constraint { totalVehicleMass <= 1500[kg] }\n        }\n    }\n    \n    requirement def EngineTorqueRequirement {\n        doc /* Engine must generate specified torque characteristics at various speeds */\n        \n        attribute engineSpeed : AngularVelocityValue;\n        attribute generatedTorque : TorqueValue;\n        \n        requirement torqueGeneration {\n            doc /* Engine must be capable of generating specified torque at various speeds */\n            require constraint { generatedTorque == torqueCharacteristic(engineSpeed) }\n        }\n    }\n    \n    requirement def PowerTransmissionRequirement {\n        doc /* Generated torque must be effectively transmitted to gearbox through clutch interface */\n        \n        attribute inputTorque : TorqueValue;\n        attribute outputTorque : TorqueValue;\n        attribute clutchEngaged : Boolean;\n        \n        requirement smoothPowerDelivery {\n            doc /* Ensure smooth power delivery through clutch to gearbox */\n            require constraint { \n                clutchEngaged implies (outputTorque >= 0.95 * inputTorque and outputTorque <= inputTorque)\n            }\n        }\n    }\n    \n    requirement vehicleSystemRequirements {\n        doc /* Top-level vehicle system requirements for mass control and power transmission */\n        \n        subject vehicle;\n        \n        require massControl : VehicleMassRequirement;\n        require torqueGeneration : EngineTorqueRequirement;\n        require powerTransmission : PowerTransmissionRequirement;\n    }\n}",
    "package VehicleDynamicPerformanceAnalysis {\n    import ScalarValues::*;\n    import Quantities::*;\n    import MeasurementReferences::*;\n    import ISQ::*;\n    \n    attribute def VehicleConfiguration {\n        attribute curbWeight : MassValue;\n        attribute payload : MassValue;\n        attribute wheelDiameter : LengthValue;\n        attribute transmissionEfficiency : Real;\n        attribute urbanFuelEconomy : Real;\n        attribute highwayFuelEconomy : Real;\n    }\n    \n    attribute def DriveCyclePoint {\n        attribute time : TimeValue;\n        attribute position : LengthValue;\n        attribute speed : SpeedValue;\n    }\n    \n    attribute def DynamicParameters {\n        attribute enginePower : PowerValue;\n        attribute acceleration : AccelerationValue;\n        attribute speed : SpeedValue;\n        attribute position : LengthValue;\n    }\n    \n    attribute def FuelEconomyMetrics {\n        attribute fuelConsumptionPer100km : Real;\n        attribute milesPerGallon : Real;\n        attribute totalFuelConsumed : VolumeValue;\n    }\n    \n    attribute def ComplianceTarget {\n        attribute targetType : String;\n        attribute targetValue : Real;\n        attribute unit : String;\n    }\n    \n    part def Vehicle {\n        attribute config : VehicleConfiguration;\n        attribute currentDynamics : DynamicParameters;\n    }\n    \n    part def DriveCycle {\n        attribute cyclePoints : DriveCyclePoint[*] ordered;\n        attribute totalDuration : TimeValue;\n        attribute totalDistance : LengthValue;\n    }\n    \n    part def PerformanceAnalyzer {\n        in vehicle : Vehicle;\n        in driveCycle : DriveCycle;\n        out dynamicResults : DynamicParameters[*] ordered;\n        out fuelEconomyResults : FuelEconomyMetrics;\n        \n        action calculateDynamics {\n            in cycle : DriveCycle;\n            in vehicleConfig : VehicleConfiguration;\n            out dynamics : DynamicParameters[*] ordered;\n        }\n        \n        action calculateFuelEconomy {\n            in dynamics : DynamicParameters[*] ordered;\n            in vehicleConfig : VehicleConfiguration;\n            out fuelMetrics : FuelEconomyMetrics;\n        }\n    }\n    \n    part def ComplianceVerifier {\n        in fuelMetrics : FuelEconomyMetrics;\n        in target : ComplianceTarget;\n        out isCompliant : Boolean;\n        \n        action verifyCompliance {\n            in metrics : FuelEconomyMetrics;\n            in complianceTarget : ComplianceTarget;\n            out result : Boolean;\n        }\n    }\n    \n    part def VehicleDynamicPerformanceSystem {\n        part vehicle : Vehicle;\n        part driveCycle : DriveCycle;\n        part analyzer : PerformanceAnalyzer;\n        part verifier : ComplianceVerifier;\n        \n        interface : PerformanceAnalyzer::calculateDynamics connect \n            driveCycle to PerformanceAnalyzer::calculateDynamics::cycle,\n            vehicle.config to PerformanceAnalyzer::calculateDynamics::vehicleConfig;\n            \n        interface : PerformanceAnalyzer::calculateFuelEconomy connect\n            analyzer.dynamicResults to PerformanceAnalyzer::calculateFuelEconomy::dynamics,\n            vehicle.config to PerformanceAnalyzer::calculateFuelEconomy::vehicleConfig;\n            \n        interface : ComplianceVerifier::verifyCompliance connect\n            analyzer.fuelEconomyResults to ComplianceVerifier::verifyCompliance::metrics;\n            \n        requirement straightLineDriving {\n            doc /* System shall model vehicle dynamics for straight-line driving only */\n        }\n        \n        requirement powerDemandCalculation {\n            doc /* System shall calculate required engine power based on vehicle configuration and drive cycle */\n        }\n        \n        requirement fuelEconomyCalculation {\n            doc /* System shall calculate fuel economy throughout entire driving cycle */\n        }\n        \n        requirement complianceVerification {\n            doc /* System shall verify compliance with specified energy consumption targets */\n        }\n        \n        requirement configurability {\n            doc /* System shall allow users to input various vehicle parameters and drive cycle scenarios */\n        }\n    }\n}",
    "package VehicleFuelEconomySimulation {\n    import ScalarValues::*;\n    import Quantities::*;\n    import MeasurementReferences::*;\n    import ISQ::*;\n    \n    requirement def FuelEconomyRequirement {\n        doc /* Vehicle must achieve fuel economy exceeding 30 miles per gallon */\n        attribute targetFuelEconomy : Real = 30.0;\n        attribute unit : String = \"mpg\";\n    }\n    \n    part def Vehicle {\n        attribute curbWeight : MassValue;\n        attribute load : MassValue;\n        attribute wheelDiameter : LengthValue;\n        attribute transmissionEfficiency : Real;\n        \n        port fuelInput : FuelFlow;\n        port powerOutput : MechanicalPower;\n    }\n    \n    part def DrivingScenario {\n        attribute scenarioType : String;\n        attribute trajectory : DrivingTrajectory;\n        attribute speedProfile : SpeedVariation;\n    }\n    \n    part def DrivingTrajectory {\n        attribute distance : LengthValue;\n        attribute time : TimeValue;\n        attribute waypoints : Point3D[*];\n    }\n    \n    part def SpeedVariation {\n        attribute speeds : SpeedValue[*];\n        attribute timestamps : TimeValue[*];\n    }\n    \n    part def SimulationEngine {\n        in vehicle : Vehicle;\n        in scenario : DrivingScenario;\n        out fuelEconomy : FuelEconomyResult;\n        \n        private attribute wheelPower : PowerValue;\n        private attribute acceleration : AccelerationValue;\n        private attribute energyConsumption : EnergyValue;\n        private attribute enginePowerDemand : PowerValue;\n        private attribute fuelConsumption : VolumeValue;\n    }\n    \n    part def FuelEconomyResult {\n        attribute mpg : Real;\n        attribute litersPerHundredKm : Real;\n        attribute meetsRequirement : Boolean;\n    }\n    \n    analysis def FuelEconomyAnalysis {\n        subject vehicle : Vehicle;\n        objective fuelEconomyReq : FuelEconomyRequirement;\n        \n        return fuelEconomyResult : FuelEconomyResult;\n        \n        action simulateUrbanDriving {\n            in urbanScenario : DrivingScenario;\n            out urbanResult : FuelEconomyResult;\n        }\n        \n        action simulateHighwayDriving {\n            in highwayScenario : DrivingScenario;\n            out highwayResult : FuelEconomyResult;\n        }\n        \n        action calculateCombinedFuelEconomy {\n            in urbanResult : FuelEconomyResult;\n            in highwayResult : FuelEconomyResult;\n            out combinedResult : FuelEconomyResult;\n        }\n    }\n    \n    calc def VehicleDynamicsCalculation {\n        in vehicle : Vehicle;\n        in speed : SpeedValue;\n        in acceleration : AccelerationValue;\n        return powerRequired : PowerValue;\n    }\n    \n    calc def FuelConsumptionCalculation {\n        in enginePower : PowerValue;\n        in duration : TimeValue;\n        in efficiency : Real;\n        return fuelVolume : VolumeValue;\n    }\n    \n    constraint def FuelEconomyConstraint {\n        in actualFuelEconomy : Real;\n        in requiredFuelEconomy : Real;\n        \n        actualFuelEconomy > requiredFuelEconomy\n    }\n    \n    verification def VerifyFuelEconomy {\n        subject vehicle : Vehicle;\n        objective : FuelEconomyRequirement;\n        \n        return verdict : VerdictKind;\n    }\n    \n    attribute def MassValue :> ScalarQuantityValue {\n        attribute num : Real;\n        attribute mRef : MassUnit;\n    }\n    \n    attribute def PowerValue :> ScalarQuantityValue {\n        attribute num : Real;\n        attribute mRef : PowerUnit;\n    }\n    \n    attribute def SpeedValue :> ScalarQuantityValue {\n        attribute num : Real;\n        attribute mRef : SpeedUnit;\n    }\n    \n    attribute def AccelerationValue :> ScalarQuantityValue {\n        attribute num : Real;\n        attribute mRef : AccelerationUnit;\n    }\n    \n    attribute def EnergyValue :> ScalarQuantityValue {\n        attribute num : Real;\n        attribute mRef : EnergyUnit;\n    }\n    \n    attribute def VolumeValue :> ScalarQuantityValue {\n        attribute num : Real;\n        attribute mRef : VolumeUnit;\n    }\n    \n    attribute def Point3D {\n        attribute x : LengthValue;\n        attribute y : LengthValue;\n        attribute z : LengthValue;\n    }\n    \n    interface def FuelFlow {\n        end supplier : FuelTank;\n        end consumer : Engine;\n    }\n    \n    interface def MechanicalPower {\n        end source : Engine;\n        end sink : Transmission;\n    }\n}",
    "<scratchpad>\nLet me analyze the requirement step by step:\n\n1. Key functional information:\n   - Conduct selection analysis for engines\n   - Support multiple engine types (four-cylinder, six-cylinder)\n   - Aggregate and calculate performance indicators\n   - Use unified evaluation function\n   - Automatically screen and recommend optimal engine\n\n2. Key non-functional information:\n   - Performance indicators: power, mass, efficiency, cost\n   - Goal: maximize performance and economic efficiency\n\n3. SysML v2 mapping:\n   - Package for organization\n   - Part definitions for engine types\n   - Attributes for performance indicators\n   - Analysis case for selection analysis\n   - Calculation definitions for aggregation and evaluation\n   - Requirements for objectives\n</scratchpad>\n\npackage EngineSelectionSystem {\n    \n    import ScalarValues::*;\n    \n    attribute def Power :> ScalarQuantityValue {\n        attribute unit :> MeasurementUnit;\n    }\n    \n    attribute def Mass :> ScalarQuantityValue {\n        attribute unit :> MeasurementUnit;\n    }\n    \n    attribute def Efficiency :> Real;\n    \n    attribute def Cost :> ScalarQuantityValue {\n        attribute unit :> MeasurementUnit;\n    }\n    \n    attribute def EvaluationScore :> Real;\n    \n    part def Engine {\n        attribute power : Power;\n        attribute mass : Mass;\n        attribute efficiency : Efficiency;\n        attribute cost : Cost;\n        attribute evaluationScore : EvaluationScore;\n    }\n    \n    part def FourCylinderEngine :> Engine;\n    \n    part def SixCylinderEngine :> Engine;\n    \n    calc def PerformanceAggregation {\n        in engine : Engine;\n        return aggregatedMetrics : Engine;\n    }\n    \n    calc def UnifiedEvaluationFunction {\n        in engine : Engine;\n        return score : EvaluationScore;\n    }\n    \n    calc def OptimalEngineSelection {\n        in candidates : Engine[*];\n        return optimal : Engine;\n    }\n    \n    analysis def EngineSelectionAnalysis {\n        subject engines : Engine[*];\n        \n        calc performanceCalc : PerformanceAggregation {\n            in engine = engines;\n        }\n        \n        calc evaluation : UnifiedEvaluationFunction {\n            in engine = performanceCalc.aggregatedMetrics;\n        }\n        \n        calc selection : OptimalEngineSelection {\n            in candidates = engines;\n        }\n        \n        return selectedEngine : Engine = selection.optimal;\n    }\n    \n    requirement def MaximizePerformance {\n        doc /* The system shall maximize engine performance */\n        subject engine : Engine;\n    }\n    \n    requirement def MaximizeEconomicEfficiency {\n        doc /* The system shall maximize economic efficiency */\n        subject engine : Engine;\n    }\n    \n    requirement def ComprehensiveEvaluation {\n        doc /* The system shall use a unified evaluation function to assess engines based on power, mass, efficiency, and cost */\n        subject evaluationFunction : UnifiedEvaluationFunction;\n    }\n    \n    part engineSelectionSystem {\n        part fourCylinderEngines : FourCylinderEngine[*];\n        part sixCylinderEngines : SixCylinderEngine[*];\n        \n        perform analysis : EngineSelectionAnalysis {\n            subject engines = fourCylinderEngines union sixCylinderEngines;\n        }\n    }\n}",
    "package VehicleQualityAssurance {\n    \n    attribute def CurbWeight :> ISQ::mass;\n    \n    requirement def VehicleWeightRequirement {\n        doc /* The curb weight of each vehicle must be less than or equal to 2,500 kilograms */\n        \n        attribute maxAllowableWeight : CurbWeight = 2500 [kg];\n        \n        require constraint {\n            actualWeight <= maxAllowableWeight\n        }\n    }\n    \n    item def Vehicle {\n        attribute actualWeight : CurbWeight;\n        attribute qualityStatus : String;\n    }\n    \n    item def WeightData {\n        attribute rawWeight : CurbWeight;\n        attribute processedWeight : CurbWeight;\n    }\n    \n    action def CollectWeightData {\n        in vehicle : Vehicle;\n        out weightData : WeightData;\n    }\n    \n    action def ProcessWeightData {\n        in rawData : WeightData;\n        out processedData : WeightData;\n    }\n    \n    action def EvaluateVehicleWeight {\n        in vehicle : Vehicle;\n        in processedData : WeightData;\n        out result : String;\n        \n        bind vehicle.actualWeight = processedData.processedWeight;\n    }\n    \n    action def VehicleWeightInspection {\n        in targetVehicle : Vehicle;\n        out inspectionResult : String;\n        \n        action collectData : CollectWeightData {\n            in vehicle = targetVehicle;\n        }\n        \n        then action processData : ProcessWeightData {\n            in rawData = collectData.weightData;\n        }\n        \n        then action evaluate : EvaluateVehicleWeight {\n            in vehicle = targetVehicle;\n            in processedData = processData.processedData;\n        }\n        \n        bind inspectionResult = evaluate.result;\n    }\n    \n    part def VehicleQualitySystem {\n        part vehicles : Vehicle[*];\n        \n        requirement vehicleWeightReq : VehicleWeightRequirement[*] {\n            subject = vehicles;\n        }\n        \n        perform vehicleInspection : VehicleWeightInspection[*] {\n            in targetVehicle = vehicles;\n        }\n    }\n}",
    "package VehicleMassVerificationSystem {\n    import ScalarValues::*;\n    import Quantities::*;\n    import MeasurementReferences::*;\n    import SI::*;\n    \n    attribute def MassValue :> MassValue {\n        attribute actualValue : Real;\n        attribute unit : MassUnit default kg;\n    }\n    \n    attribute def VerificationStatus {\n        attribute isQualified : Boolean;\n    }\n    \n    part def Vehicle {\n        attribute actualMass : MassValue;\n        attribute verificationStatus : VerificationStatus;\n    }\n    \n    part def WeighingEquipment {\n        attribute measuredMass : MassValue;\n        \n        action measureMass {\n            in vehicle : Vehicle;\n            out measurement : MassValue;\n        }\n    }\n    \n    part def MassVerificationUnit {\n        attribute massLimit : MassValue = MassValue(actualValue = 2500.0, unit = kg);\n        \n        action evaluateMass {\n            in measuredMass : MassValue;\n            in limit : MassValue;\n            out status : VerificationStatus;\n            \n            bind status.isQualified = (measuredMass.actualValue <= limit.actualValue);\n        }\n    }\n    \n    part def VehicleMassVerificationSystem {\n        part vehicles : Vehicle[*];\n        part weighingEquipment : WeighingEquipment;\n        part verificationUnit : MassVerificationUnit;\n        \n        action verifyVehicleMass {\n            in vehicle : Vehicle;\n            \n            perform weighingEquipment.measureMass {\n                in vehicle = vehicle;\n                out measurement;\n            }\n            then perform verificationUnit.evaluateMass {\n                in measuredMass = measurement;\n                in limit = verificationUnit.massLimit;\n                out status;\n            }\n            then assign vehicle.actualMass := measurement;\n            then assign vehicle.verificationStatus := status;\n        }\n        \n        requirement massLimitRequirement {\n            doc /* All vehicles must not exceed 2500 kg */\n            require constraint {\n                vehicles->forAll(v | v.actualMass.actualValue <= 2500.0)\n            }\n        }\n        \n        requirement independentVerificationRequirement {\n            doc /* Each vehicle must be verified independently */\n            require constraint {\n                vehicles->forAll(v | v.verificationStatus != null)\n            }\n        }\n    }\n}",
    "package VehicleTransportationSystem {\n    import ScalarValues::*;\n    \n    part def Vehicle {\n        attribute capacity : Integer = 5;\n        attribute occupantCount : Integer;\n        \n        part driver : Person[0..1];\n        part passengers : Person[0..4];\n        \n        port vehicleAccessPort : VehicleAccessInterface;\n        port environmentInterface : EnvironmentInterface;\n        port infrastructureInterface : InfrastructureInterface;\n    }\n    \n    part def Person {\n        attribute isDriver : Boolean;\n    }\n    \n    interface def VehicleAccessInterface {\n        in item enterRequest;\n        in item exitRequest;\n        out item accessStatus;\n    }\n    \n    interface def EnvironmentInterface {\n        in item environmentalData;\n        out item safetyStatus;\n    }\n    \n    interface def InfrastructureInterface {\n        in item infrastructureInfo;\n        out item compatibilityStatus;\n    }\n    \n    use case def TransportPeople {\n        subject vehicle : Vehicle;\n        \n        objective {\n            doc /* Transport driver and passengers safely from origin to destination */\n        }\n        \n        include use case enterVehicle : EnterVehicle;\n        include use case travel : Travel;\n        include use case exitVehicle : ExitVehicle;\n    }\n    \n    use case def EnterVehicle {\n        subject vehicle : Vehicle;\n        \n        assert constraint { vehicle.occupantCount <= vehicle.capacity }\n    }\n    \n    use case def Travel {\n        subject vehicle : Vehicle;\n        \n        include use case monitorEnvironment : MonitorEnvironment;\n        include use case accessInfrastructure : AccessInfrastructure;\n    }\n    \n    use case def ExitVehicle {\n        subject vehicle : Vehicle;\n    }\n    \n    use case def MonitorEnvironment {\n        subject vehicle : Vehicle;\n    }\n    \n    use case def AccessInfrastructure {\n        subject vehicle : Vehicle;\n    }\n    \n    requirement def TransportationCapability {\n        doc /* System shall support one driver and up to four passengers */\n        \n        subject vehicle : Vehicle;\n        \n        require constraint { vehicle.capacity == 5 }\n    }\n    \n    requirement def AccessibilityRequirement {\n        doc /* System shall provide simple and smooth entry/exit process */\n        \n        subject vehicle : Vehicle;\n    }\n    \n    requirement def SafetyRequirement {\n        doc /* System shall ensure safe transportation considering environmental factors */\n        \n        subject vehicle : Vehicle;\n    }\n    \n    requirement def InfrastructureCompatibility {\n        doc /* System shall be compatible with infrastructure like gas stations */\n        \n        subject vehicle : Vehicle;\n    }\n    \n    requirement def UserCentricDesign {\n        doc /* System operation shall be human-centered focusing on ride experience */\n        \n        subject vehicle : Vehicle;\n    }\n}",
    "I'll analyze the requirement and create a SysML v2 model for this transportation system.\n\n<scratchpad>\nKey functional information extracted:\n- System supports transportation scenarios\n- Accommodates 1 driver + up to 4 passengers (5 people total)\n- Transport from starting point to destination\n- Users enter vehicle first\n- Driver operates vehicle\n- Environmental conditions affect operation\n- Refueling at gas station when needed\n- Safe exit at destination\n- Complete transportation process\n\nKey non-functional information:\n- Safety (safely transported, safely exit)\n- Simplicity and convenience of interactions\n- Meeting daily transportation needs\n\nSysML v2 mapping:\n- Package for overall system\n- Part definitions for: Vehicle, Driver, Passenger, GasStation, Environment\n- Use case for transportation scenario\n- Actions for: enter vehicle, operate vehicle, refuel, exit vehicle\n- Attributes for capacity constraints\n- Requirements for safety and usability\n- Interfaces between parts\n</scratchpad>\n\npackage TransportationSystem {\n    import ScalarValues::*;\n    \n    part def Vehicle {\n        attribute capacity : Integer = 5;\n        attribute fuelLevel : Real;\n        attribute location : String;\n        \n        port driverInterface : DriverVehicleInterface;\n        port passengerInterface : PassengerVehicleInterface[0..4];\n        port fuelPort : FuelInterface;\n    }\n    \n    part def Driver {\n        attribute licensed : Boolean;\n        port vehicleControl : DriverVehicleInterface;\n    }\n    \n    part def Passenger {\n        port vehicleAccess : PassengerVehicleInterface;\n    }\n    \n    part def GasStation {\n        attribute fuelAvailable : Boolean;\n        port fuelDispenser : FuelInterface;\n    }\n    \n    part def Environment {\n        attribute weatherCondition : String;\n        attribute roadCondition : String;\n    }\n    \n    interface def DriverVehicleInterface {\n        end driverEnd;\n        end vehicleEnd;\n    }\n    \n    interface def PassengerVehicleInterface {\n        end passengerEnd;\n        end vehicleEnd;\n    }\n    \n    interface def FuelInterface {\n        end stationEnd;\n        end vehicleEnd;\n    }\n    \n    use case def TransportationScenario {\n        subject vehicle : Vehicle;\n        actor driver : Driver;\n        actor passengers : Passenger[0..4];\n        actor gasStation : GasStation;\n        actor environment : Environment;\n        \n        objective {\n            doc /* Transport driver and passengers safely from starting point to destination */\n        }\n        \n        part enterVehicleAction : EnterVehicle {\n            in actors : Person[1..5];\n            out occupiedVehicle : Vehicle;\n        }\n        \n        part operateVehicleAction : OperateVehicle {\n            in operator : Driver;\n            in vehicle : Vehicle;\n            in envConditions : Environment;\n            out vehicleInMotion : Vehicle;\n        }\n        \n        part refuelAction : Refuel {\n            in vehicle : Vehicle;\n            in station : GasStation;\n            out refueledVehicle : Vehicle;\n        }\n        \n        part exitVehicleAction : ExitVehicle {\n            in occupiedVehicle : Vehicle;\n            out actors : Person[1..5];\n        }\n        \n        flow from enterVehicleAction.occupiedVehicle to operateVehicleAction.vehicle;\n        flow from operateVehicleAction.vehicleInMotion to refuelAction.vehicle;\n        flow from refuelAction.refueledVehicle to exitVehicleAction.occupiedVehicle;\n    }\n    \n    action def EnterVehicle {\n        in actors : Person[1..5];\n        out occupiedVehicle : Vehicle;\n    }\n    \n    action def OperateVehicle {\n        in operator : Driver;\n        in vehicle : Vehicle;\n        in envConditions : Environment;\n        out vehicleInMotion : Vehicle;\n    }\n    \n    action def Refuel {\n        in vehicle : Vehicle;\n        in station : GasStation;\n        out refueledVehicle : Vehicle;\n    }\n    \n    action def ExitVehicle {\n        in occupiedVehicle : Vehicle;\n        out actors : Person[1..5];\n    }\n    \n    abstract part def Person;\n    \n    requirement def SafetyRequirement {\n        doc /* System shall ensure safe transportation of all occupants */\n        subject vehicle : Vehicle;\n    }\n    \n    requirement def UsabilityRequirement {\n        doc /* System interactions shall be simple and convenient */\n        subject vehicle : Vehicle;\n    }\n    \n    requirement def CapacityRequirement {\n        doc /* Vehicle shall accommodate 1 driver and up to 4 passengers */\n        subject vehicle : Vehicle;\n        assume constraint { vehicle.capacity == 5 }\n    }\n}",
    "package VehicleProductLine {\n    import ScalarValues::*;\n    \n    part def Vehicle {\n        part engine : Engine[1];\n        part transmission : Transmission[1];\n        \n        constraint engineTransmissionCompatibility {\n            (engine istype FourCylinderEngine) implies (transmission istype ManualTransmission or transmission istype AutomaticTransmission)\n            and\n            (engine istype SixCylinderEngine) implies (transmission istype AutomaticTransmission)\n        }\n    }\n    \n    abstract part def Engine {\n        abstract part cylinders : Cylinder[*];\n    }\n    \n    part def FourCylinderEngine :> Engine {\n        part redefines cylinders : Cylinder[4];\n    }\n    \n    part def SixCylinderEngine :> Engine {\n        part redefines cylinders : Cylinder[6];\n    }\n    \n    part def Cylinder {\n        attribute diameter : Real;\n        \n        constraint diameterOptions {\n            diameter == 70.0 or diameter == 100.0\n        }\n    }\n    \n    abstract part def Transmission;\n    \n    part def ManualTransmission :> Transmission;\n    \n    part def AutomaticTransmission :> Transmission;\n}",
    "I'll analyze the requirements and create a SysML v2 model for the configurable engine system.\n\n<scratchpad>\nKey functional/non-functional information extracted:\n1. System: Configurable engine\n2. Components: Multiple cylinders\n3. Variability:\n   - Number of cylinders: 4 or 6\n   - Cylinder diameters: 70mm or 100mm\n4. Engine variants: \n   - Four-cylinder engine\n   - Six-cylinder engine\n5. Flexibility: Users can choose cylinder quantity and diameter\n\nSysML v2 mapping:\n- Use package for organization\n- Define parts for engine and cylinders\n- Use variation definitions for configurability\n- Define attributes for cylinder properties\n- Use constraints for valid configurations\n- Define usage scenarios for the two engine variants\n</scratchpad>\n\npackage ConfigurableEngineSystem {\n    import ScalarValues::*;\n    \n    attribute def CylinderDiameter :> Real {\n        constraint { self == 70.0 or self == 100.0 }\n    }\n    \n    part def Cylinder {\n        attribute diameter : CylinderDiameter;\n    }\n    \n    part def Engine {\n        part cylinders : Cylinder[4..6];\n        \n        attribute cylinderCount : Integer {\n            constraint { cylinderCount == 4 or cylinderCount == 6 }\n        }\n        \n        constraint { cylinders.size() == cylinderCount }\n    }\n    \n    variation part def ConfigurableEngine :> Engine {\n        variant part fourCylinderEngine : Engine {\n            attribute redefines cylinderCount = 4;\n        }\n        \n        variant part sixCylinderEngine : Engine {\n            attribute redefines cylinderCount = 6;\n        }\n    }\n    \n    part engineSystem : ConfigurableEngine {\n        variation cylinderDiameterConfig {\n            variant smallDiameter {\n                part redefines cylinders {\n                    attribute redefines diameter = 70.0;\n                }\n            }\n            variant largeDiameter {\n                part redefines cylinders {\n                    attribute redefines diameter = 100.0;\n                }\n            }\n        }\n    }\n}",
    "I'll analyze the requirements and create a SysML v2 model for the automotive configuration space.\n\n<scratchpad>\nKey functional/non-functional information extracted:\n1. System describes automotive configuration space\n2. Components:\n   - Engines: 4-cylinder or 6-cylinder\n   - Each engine contains corresponding number of cylinders\n   - Cylinder diameter: 70mm or 100mm\n   - Transmission: manual or automatic\n3. Constraints:\n   - One engine per vehicle\n   - One transmission per vehicle\n   - 4-cylinder engine → manual transmission\n   - 6-cylinder engine → automatic transmission\n\nSysML v2 mapping:\n- Use package for organization\n- Part definitions for components (Engine, Cylinder, Transmission, Vehicle)\n- Variation definitions for different types\n- Attributes for parameters (diameter)\n- Usage relationships\n- Constraints for configuration rules\n</scratchpad>\n\npackage AutomotiveConfiguration {\n    import ScalarValues::*;\n    \n    attribute def DiameterValue :> Real {\n        attribute unit = \"mm\";\n    }\n    \n    part def Cylinder {\n        attribute diameter : DiameterValue;\n    }\n    \n    part def Engine {\n        abstract;\n        part cylinders : Cylinder[1..*];\n    }\n    \n    part def FourCylinderEngine :> Engine {\n        part cylinders : Cylinder[4];\n    }\n    \n    part def SixCylinderEngine :> Engine {\n        part cylinders : Cylinder[6];\n    }\n    \n    part def Transmission {\n        abstract;\n    }\n    \n    part def ManualTransmission :> Transmission;\n    \n    part def AutomaticTransmission :> Transmission;\n    \n    part def Vehicle {\n        part engine : Engine[1];\n        part transmission : Transmission[1];\n        \n        constraint engineTransmissionCompatibility {\n            (engine istype FourCylinderEngine) implies (transmission istype ManualTransmission) and\n            (engine istype SixCylinderEngine) implies (transmission istype AutomaticTransmission)\n        }\n    }\n    \n    variation part def CylinderVariation :> Cylinder {\n        variant attribute diameter {\n            variant smallDiameter = 70.0;\n            variant largeDiameter = 100.0;\n        }\n    }\n}",
    "I'll analyze the requirements and create a SysML v2 model.\n\n<scratchpad>\nKey elements to extract:\n1. System composition: system assembly containing computer subsystem and storage subsystem\n2. Software design section: defines message format and data format\n3. Computer subsystem: must utilize and integrate all software design functions\n4. Storage subsystem: must access and be compatible with message/data formats\n5. Integration requirement: software and hardware must work together seamlessly\n6. Quality attributes: efficient, reliable, compliant with data structure specifications\n\nSysML v2 mapping:\n- Use package for overall system\n- Define parts for subsystems\n- Use interfaces for message/data formats\n- Use requirements for constraints\n- Use connections for integration\n</scratchpad>\n\npackage SystemModel {\n    import ScalarValues::*;\n    \n    part def MessageFormat {\n        doc /* Defines the structure of messages in the system */\n    }\n    \n    part def DataFormat {\n        doc /* Defines the structure of data storage */\n    }\n    \n    part def SoftwareDesign {\n        part messageFormat : MessageFormat;\n        part dataFormat : DataFormat;\n    }\n    \n    part def ComputerSubsystem {\n        port softwareInterface : ~SoftwareInterface;\n        \n        attribute functions[*];\n        \n        requirement utilizeSoftwareFunctions {\n            doc /* Must utilize and integrate all functions from software design */\n            verify requirement {\n                in design : SoftwareDesign;\n                in computer : ComputerSubsystem;\n                return computer.functions == design.functions;\n            }\n        }\n    }\n    \n    part def StorageSubsystem {\n        port dataInterface : ~DataInterface;\n        \n        requirement accessCompatibility {\n            doc /* Must access and be compatible with message and data formats */\n            verify requirement {\n                in storage : StorageSubsystem;\n                in msgFormat : MessageFormat;\n                in dataFormat : DataFormat;\n                return storage.isCompatibleWith(msgFormat) and \n                       storage.isCompatibleWith(dataFormat);\n            }\n        }\n    }\n    \n    interface def SoftwareInterface {\n        end supplier : SoftwareDesign;\n        end consumer : ComputerSubsystem;\n    }\n    \n    interface def DataInterface {\n        end provider : StorageSubsystem;\n        end consumer : ComputerSubsystem;\n    }\n    \n    part def SystemAssembly {\n        part computer : ComputerSubsystem;\n        part storage : StorageSubsystem;\n        part software : SoftwareDesign;\n        \n        interface softwareToComputer : SoftwareInterface \n            connect software to computer.softwareInterface;\n            \n        interface storageToComputer : DataInterface\n            connect storage.dataInterface to computer;\n            \n        requirement seamlessIntegration {\n            doc /* Software and hardware must work together seamlessly */\n            subject system : SystemAssembly;\n            \n            requirement efficient {\n                doc /* System processes must be efficient */\n            }\n            \n            requirement reliable {\n                doc /* System processes must be reliable */\n            }\n            \n            requirement compliant {\n                doc /* Must comply with data structure specifications */\n            }\n        }\n    }\n    \n    part system : SystemAssembly {\n        doc /* Main system instance composed of subsystems */\n        \n        perform action systemOperation {\n            doc /* Information storage, transmission, and processing */\n            \n            action store {\n                in data : DataFormat;\n                perform storage.store(data);\n            }\n            \n            action transmit {\n                in message : MessageFormat;\n                perform computer.process(message);\n            }\n            \n            action process {\n                perform computer.execute();\n            }\n            \n            flow store then transmit then process;\n        }\n    }\n}",
    "package PowertrainSystem {\n    import ScalarValues::*;\n    \n    // Logical Layer\n    part def LogicalPowerProvider {\n        attribute power : Real;\n    }\n    \n    part def LogicalTorqueGenerator {\n        attribute torque : Real;\n        attribute power : Real;\n    }\n    \n    part def LogicalLayer {\n        part powerProvider : LogicalPowerProvider;\n        part torqueGenerator : LogicalTorqueGenerator;\n        \n        flow powerProvider.power to torqueGenerator.power;\n    }\n    \n    // Physical Layer\n    part def PowerUnit {\n        attribute powerOutput : Real;\n        attribute torqueOutput : Real;\n    }\n    \n    part def Engine :> PowerUnit;\n    \n    part def PhysicalLayer {\n        part powerUnit : PowerUnit;\n    }\n    \n    // System Definition\n    part def PowertrainSystemDef {\n        part logical : LogicalLayer;\n        part physical : PhysicalLayer;\n        \n        // Allocation\n        allocation logicalToPhysical {\n            allocate logical.torqueGenerator to physical.powerUnit;\n        }\n    }\n    \n    // Requirements\n    requirement def PowerProvisionReq {\n        doc /* Logical components shall provide power */\n    }\n    \n    requirement def TorqueGenerationReq {\n        doc /* Torque generator shall convert power into torque */\n    }\n    \n    requirement def PhysicalIntegrationReq {\n        doc /* Physical components shall integrate logical functions */\n    }\n    \n    requirement def MappingReq {\n        doc /* Logical torque generator shall map to physical power unit */\n    }\n    \n    requirement def PowerTransmissionReq {\n        doc /* System shall provide power transmission and torque output capabilities */\n    }\n    \n    // Satisfy relationships\n    satisfy PowerProvisionReq by LogicalPowerProvider;\n    satisfy TorqueGenerationReq by LogicalTorqueGenerator;\n    satisfy PhysicalIntegrationReq by PowerUnit;\n    satisfy MappingReq by logicalToPhysical;\n    satisfy PowerTransmissionReq by PowertrainSystemDef;\n}",
    "package PowerTransmissionSystem {\n    import ScalarValues::*;\n    \n    // Logical Architecture\n    part def TorqueGenerator {\n        action generateTorque {\n            out torqueOutput : Torque;\n        }\n    }\n    \n    part def LogicalPowerSystem {\n        part torqueGen : TorqueGenerator;\n        \n        action deliverPower {\n            out powerOutput : Power;\n        }\n        \n        action generateTorque {\n            out torqueOutput : Torque;\n            bind generateTorque = torqueGen.generateTorque;\n        }\n    }\n    \n    // Physical Architecture\n    part def Engine {\n        action generateTorque {\n            out torqueOutput : Torque;\n        }\n    }\n    \n    part def Powertrain {\n        part engine : Engine;\n        \n        action generateTorque {\n            out torqueOutput : Torque;\n            bind generateTorque = engine.generateTorque;\n        }\n    }\n    \n    part def PhysicalPowerSystem {\n        part powertrain : Powertrain;\n    }\n    \n    // System Definition\n    part powerTransmissionSystem : PowerTransmissionSystem {\n        part logical : LogicalPowerSystem;\n        part physical : PhysicalPowerSystem;\n        \n        // Allocations\n        allocation logicalToPhysical {\n            allocate logical.torqueGen to physical.powertrain;\n            allocate logical.torqueGen.generateTorque to physical.powertrain.engine.generateTorque;\n        }\n        \n        // System Requirements\n        requirement providePower {\n            doc /* The system shall provide power */\n            satisfy by logical.deliverPower;\n        }\n        \n        requirement generateTorque {\n            doc /* The system shall generate torque */\n            satisfy by logical.generateTorque;\n        }\n    }\n    \n    // Value Types\n    attribute def Power :> ScalarQuantityValue;\n    attribute def Torque :> ScalarQuantityValue;\n}",
    "package VehicleFeatureAnnotationSystem {\n    import ScalarValues::*;\n    \n    // Define feature categories\n    enum def FeatureCategory {\n        enum safety;\n        enum security;\n        enum protection;\n    }\n    \n    // Define component attributes\n    attribute def SafetyLevel :> Integer {\n        doc /* Safety criticality level from 1-5 */\n    }\n    \n    attribute def SecurityType :> String {\n        doc /* Type of security feature provided */\n    }\n    \n    // Part definitions for vehicle components\n    part def Vehicle {\n        attribute vin : String;\n        attribute model : String;\n        \n        part interior : InteriorAssembly;\n        part bodyAssembly : BodyAssembly;\n        \n        // Safety requirements\n        requirement safetyFeatures {\n            doc /* Vehicle must have basic safety features */\n            require constraint { \n                interior.seatBelts != null and\n                interior.driverAirbag != null and\n                bodyAssembly.bumpers != null\n            }\n        }\n        \n        // Security requirements\n        requirement securityFeatures {\n            doc /* Vehicle must have security features */\n            require constraint {\n                interior.alarmSystem != null and\n                bodyAssembly.keylessEntry != null\n            }\n        }\n    }\n    \n    part def InteriorAssembly {\n        part seatBelts : SeatBelt[1..*] {\n            attribute featureType : FeatureCategory = FeatureCategory::safety;\n        }\n        \n        part frontSeats : FrontSeat[2] {\n            attribute position : String;\n        }\n        \n        part driverAirbag : Airbag {\n            attribute featureType : FeatureCategory = FeatureCategory::safety;\n            attribute safetyLevel : SafetyLevel = 5;\n        }\n        \n        part alarmSystem : AlarmSystem {\n            attribute featureType : FeatureCategory = FeatureCategory::security;\n            attribute securityType : SecurityType = \"anti-theft\";\n        }\n    }\n    \n    part def BodyAssembly {\n        part bodyShell : BodyShell;\n        \n        part bumpers : Bumper[2] {\n            attribute featureType : FeatureCategory = FeatureCategory::safety;\n            attribute location : String;\n        }\n        \n        part keylessEntry : KeylessEntryDevice {\n            attribute featureType : FeatureCategory = FeatureCategory::security;\n            attribute securityType : SecurityType = \"access control\";\n        }\n    }\n    \n    // Component definitions\n    part def SeatBelt {\n        attribute type : String;\n        attribute certificationStandard : String;\n    }\n    \n    part def FrontSeat {\n        attribute material : String;\n        attribute adjustable : Boolean;\n    }\n    \n    part def Airbag {\n        attribute deploymentForce : Real;\n        attribute sensorType : String;\n    }\n    \n    part def AlarmSystem {\n        attribute sensitivity : Integer;\n        attribute alertTypes : String[1..*];\n    }\n    \n    part def BodyShell {\n        attribute material : String;\n        attribute structuralIntegrity : Real;\n    }\n    \n    part def Bumper {\n        attribute impactRating : Real;\n        attribute material : String;\n    }\n    \n    part def KeylessEntryDevice {\n        attribute frequency : Real;\n        attribute encryptionType : String;\n        attribute range : Real;\n    }\n    \n    // Usage example\n    part vehicleInstance : Vehicle {\n        part :>> interior {\n            part :>> seatBelts[4];\n            part :>> frontSeats {\n                [1] { attribute :>> position = \"driver\"; }\n                [2] { attribute :>> position = \"passenger\"; }\n            }\n        }\n        \n        part :>> bodyAssembly {\n            part :>> bumpers {\n                [1] { attribute :>> location = \"front\"; }\n                [2] { attribute :>> location = \"rear\"; }\n            }\n        }\n    }\n}",
    "I'll analyze this requirement and create a SysML v2 model for the vehicle dynamics simulation system.\n\n<scratchpad>\nKey functional requirements:\n- Perform automated simulation and analysis of vehicle dynamic behavior\n- Accept user inputs: initial velocity, initial position, acceleration, time step\n- Integrate with ModelCenter analysis tool\n- Calculate velocity and position after time step\n- Output simulation results\n\nKey non-functional requirements:\n- Ensure accurate data transfer\n- Provide reliable output\n- Support convenient access to dynamic parameters\n- Enable vehicle performance analysis and design optimization\n\nSysML v2 mapping:\n- Package for organization\n- Part definitions for system components\n- Attribute definitions for parameters\n- Action definitions for calculations\n- Interface definitions for ModelCenter integration\n- Requirement definitions for traceability\n- Constraint definitions for physics equations\n</scratchpad>\n\npackage VehicleDynamicsSimulationSystem {\n    import ScalarValues::*;\n    import ISQ::*;\n    import SI::*;\n    \n    attribute def VelocityValue :> ScalarQuantityValue {\n        attribute quantityDimension :>> num = ISQ::velocityUnit;\n        attribute measurementUnit :>> mRef = SI::['m/s'];\n    }\n    \n    attribute def PositionValue :> ScalarQuantityValue {\n        attribute quantityDimension :>> num = ISQ::lengthUnit;\n        attribute measurementUnit :>> mRef = SI::m;\n    }\n    \n    attribute def AccelerationValue :> ScalarQuantityValue {\n        attribute quantityDimension :>> num = ISQ::accelerationUnit;\n        attribute measurementUnit :>> mRef = SI::['m/s^2'];\n    }\n    \n    attribute def TimeValue :> ScalarQuantityValue {\n        attribute quantityDimension :>> num = ISQ::durationUnit;\n        attribute measurementUnit :>> mRef = SI::s;\n    }\n    \n    part def VehicleDynamicsSimulator {\n        attribute initialVelocity : VelocityValue;\n        attribute initialPosition : PositionValue;\n        attribute acceleration : AccelerationValue;\n        attribute timeStep : TimeValue;\n        attribute finalVelocity : VelocityValue;\n        attribute finalPosition : PositionValue;\n        \n        port modelCenterInterface : ModelCenterPort;\n        \n        action simulateDynamics {\n            in item inputVelocity : VelocityValue = initialVelocity;\n            in item inputPosition : PositionValue = initialPosition;\n            in item inputAcceleration : AccelerationValue = acceleration;\n            in item inputTimeStep : TimeValue = timeStep;\n            out item outputVelocity : VelocityValue;\n            out item outputPosition : PositionValue;\n            \n            bind modelCenterInterface.velocityIn = inputVelocity;\n            bind modelCenterInterface.positionIn = inputPosition;\n            bind modelCenterInterface.accelerationIn = inputAcceleration;\n            bind modelCenterInterface.timeStepIn = inputTimeStep;\n            \n            action calculateKinematics {\n                outputVelocity := inputVelocity + inputAcceleration * inputTimeStep;\n                outputPosition := inputPosition + inputVelocity * inputTimeStep + 0.5 * inputAcceleration * inputTimeStep * inputTimeStep;\n            }\n            \n            bind outputVelocity = modelCenterInterface.velocityOut;\n            bind outputPosition = modelCenterInterface.positionOut;\n            bind finalVelocity = outputVelocity;\n            bind finalPosition = outputPosition;\n        }\n    }\n    \n    interface def ModelCenterPort {\n        in item velocityIn : VelocityValue;\n        in item positionIn : PositionValue;\n        in item accelerationIn : AccelerationValue;\n        in item timeStepIn : TimeValue;\n        out item velocityOut : VelocityValue;\n        out item positionOut : PositionValue;\n    }\n    \n    part def ModelCenterAnalysisTool {\n        port simulatorInterface : ~ModelCenterPort;\n    }\n    \n    part def VehicleDynamicsSystem {\n        part simulator : VehicleDynamicsSimulator;\n        part analysisTool : ModelCenterAnalysisTool;\n        \n        interface : InterfaceDefinition connect simulator.modelCenterInterface to analysisTool.simulatorInterface;\n    }\n    \n    requirement def AutomatedSimulationCapability {\n        doc /* The system shall be capable of performing automated simulation \n             and analysis of vehicle dynamic behavior */\n        subject system : VehicleDynamicsSystem;\n    }\n    \n    requirement def UserInputCapability {\n        doc /* Users should be able to input the vehicle's initial velocity, \n             initial position, acceleration at a specific moment, and the time step */\n        subject simulator : VehicleDynamicsSimulator;\n        require constraint {\n            simulator.initialVelocity != null and\n            simulator.initialPosition != null and\n            simulator.acceleration != null and\n            simulator.timeStep != null\n        }\n    }\n    \n    requirement def ModelCenterIntegration {\n        doc /* Through integration with the ModelCenter analysis tool, the system \n             shall automatically calculate and output the vehicle's velocity and \n             position after the specified time step */\n        subject system : VehicleDynamicsSystem;\n        satisfy simulateDynamics by simulator.simulateDynamics;\n    }\n    \n    requirement def DataAccuracy {\n        doc /* The system must ensure accurate data transfer and reliable \n             output of simulation results */\n        subject system : VehicleDynamicsSystem;\n    }\n    \n    requirement def ConvenientAccess {\n        doc /* Enable users to conveniently obtain key dynamic parameters to \n             support vehicle performance analysis and design optimization */\n        subject system : VehicleDynamicsSystem;\n    }\n}",
    "package 'Car Safety Compliance' {\n    import ScalarValues::*;\n    \n    attribute def Safety;\n    \n    part def Car {\n        attribute isMandatory : Boolean;\n        \n        part interior : Interior {\n            part seatBelt : SeatBelt[2] {\n                @Safety;\n                attribute redefines isMandatory = true;\n            }\n            \n            part driverAirbag : DriverAirbag[0..1] {\n                @Safety;\n                attribute redefines isMandatory = false;\n            }\n        }\n        \n        part body : Body {\n            part bumper : Bumper {\n                @Safety;\n                attribute redefines isMandatory = true;\n            }\n            \n            part keylessEntry : KeylessEntrySystem[0..1] {\n                @Safety;\n                attribute redefines isMandatory = false;\n            }\n        }\n        \n        part wheelAssembly : WheelAssembly {\n            part wheel : Wheel[2];\n            \n            part abs : AntiLockBrakingSystem[0..1] {\n                @Safety;\n                attribute redefines isMandatory = false;\n            }\n        }\n    }\n    \n    part def Interior;\n    part def SeatBelt;\n    part def DriverAirbag;\n    part def Body;\n    part def Bumper;\n    part def KeylessEntrySystem;\n    part def WheelAssembly;\n    part def Wheel;\n    part def AntiLockBrakingSystem;\n    \n    package 'Safety Features' {\n        ref part seatBelt : SeatBelt;\n        ref part driverAirbag : DriverAirbag;\n        ref part bumper : Bumper;\n        ref part keylessEntry : KeylessEntrySystem;\n        ref part abs : AntiLockBrakingSystem;\n    }\n    \n    package 'Mandatory Safety Features' {\n        ref part seatBelt : SeatBelt;\n        ref part bumper : Bumper;\n    }\n}",
    "package VehicleSafetyComplianceSystem {\n    \n    part def Vehicle {\n        part interior : VehicleInterior;\n        part body : VehicleBody;\n        part chassis : Chassis;\n    }\n    \n    part def VehicleInterior {\n        part seatBelts : SeatBelt[2];\n        part driversAirbag : DriversAirbag[0..1];\n    }\n    \n    part def VehicleBody {\n        part bumper : Bumper[1];\n        part keylessEntrySystem : KeylessEntrySystem[0..1];\n    }\n    \n    part def Chassis {\n        part tires : Tire[4];\n        part abs : AntiLockBrakingSystem[0..1];\n    }\n    \n    abstract part def SafetyComponent {\n        attribute isMandatory : Boolean;\n    }\n    \n    part def SeatBelt :> SafetyComponent {\n        attribute redefines isMandatory = true;\n    }\n    \n    part def DriversAirbag :> SafetyComponent {\n        attribute redefines isMandatory = false;\n    }\n    \n    part def Bumper :> SafetyComponent {\n        attribute redefines isMandatory = true;\n    }\n    \n    part def KeylessEntrySystem :> SafetyComponent {\n        attribute redefines isMandatory = false;\n    }\n    \n    part def AntiLockBrakingSystem :> SafetyComponent {\n        attribute redefines isMandatory = false;\n    }\n    \n    part def Tire;\n    \n    requirement def SafetyCompliance {\n        doc /* All mandatory safety components must be present in the vehicle */\n        subject vehicle : Vehicle;\n        \n        require constraint {\n            vehicle.interior.seatBelts->size() == 2 and\n            vehicle.body.bumper->size() == 1 and\n            vehicle.chassis.tires->size() == 4\n        }\n    }\n}",
    "I'll analyze the requirements and create a SysML v2 model for the risk and failure management system.\n\n<scratchpad>\nKey functional requirements:\n- Identify and describe various possible situations\n- Identify causes leading to situations\n- Identify potential failures that may result\n- Record probability of each cause\n- Record severity level of each failure\n- Establish causal relationships\n- Analyze sequence and impact mechanisms\n- Model different risk scenarios\n- Evaluate and manage risks/failures\n- Support risk control and decision-making\n\nKey non-functional aspects:\n- Comprehensive/all-round manner\n- Provide basis for decision-making\n\nSysML v2 mapping:\n- Use packages for organization\n- Define item definitions for key concepts (Situation, Cause, Failure, Risk)\n- Use attributes for probability and severity\n- Use connections for causal relationships\n- Use analysis cases for risk analysis\n- Use requirements for traceability\n- Use state machines for sequence modeling\n- Use constraints for validation rules\n</scratchpad>\n\npackage RiskFailureManagementSystem {\n    import ScalarValues::*;\n    import ISQ::*;\n    import SI::*;\n    \n    attribute def Probability :> Real {\n        constraint { 0.0 <= self <= 1.0 }\n    }\n    \n    attribute def SeverityLevel :> Integer {\n        constraint { 1 <= self <= 10 }\n    }\n    \n    enum def RiskCategory {\n        enum low;\n        enum medium;\n        enum high;\n        enum critical;\n    }\n    \n    item def Cause {\n        attribute id : String;\n        attribute description : Text;\n        attribute probability : Probability;\n        attribute category : String;\n    }\n    \n    item def Situation {\n        attribute id : String;\n        attribute description : Text;\n        attribute context : Text;\n        attribute timeframe : String;\n    }\n    \n    item def Failure {\n        attribute id : String;\n        attribute description : Text;\n        attribute severity : SeverityLevel;\n        attribute impact : Text;\n        attribute domain : String;\n    }\n    \n    item def Risk {\n        attribute id : String;\n        attribute name : String;\n        attribute riskScore : Real;\n        attribute category : RiskCategory;\n        \n        calc riskScore {\n            causedBy.probability * resultsIn.severity\n        }\n    }\n    \n    connection def CausalRelationship {\n        end cause : Cause[1..*];\n        end situation : Situation[1..*];\n        attribute strength : Real;\n        attribute mechanism : Text;\n    }\n    \n    connection def FailureRelationship {\n        end situation : Situation[1..*];\n        end failure : Failure[1..*];\n        attribute likelihood : Probability;\n        attribute propagationPath : Text;\n    }\n    \n    part def RiskScenario {\n        part causes : Cause[*];\n        part situations : Situation[*];\n        part failures : Failure[*];\n        part risks : Risk[*];\n        \n        connection causalLinks : CausalRelationship[*]\n            connect cause references causes to situation references situations;\n            \n        connection failureLinks : FailureRelationship[*]\n            connect situation references situations to failure references failures;\n    }\n    \n    analysis def RiskAnalysis {\n        subject scenario : RiskScenario;\n        \n        calc totalRiskScore : Real {\n            scenario.risks.riskScore->sum()\n        }\n        \n        calc highRiskCount : Integer {\n            scenario.risks->select(r | r.category == RiskCategory::high or r.category == RiskCategory::critical)->size()\n        }\n        \n        return totalScore = totalRiskScore;\n        return criticalRisks = highRiskCount;\n    }\n    \n    part def RiskManagementSystem {\n        part scenarios : RiskScenario[*];\n        \n        action identifyRisks {\n            in inputData : Text;\n            out identifiedRisks : Risk[*];\n        }\n        \n        action analyzeCausality {\n            in causes : Cause[*];\n            in situations : Situation[*];\n            out relationships : CausalRelationship[*];\n        }\n        \n        action evaluateFailures {\n            in situations : Situation[*];\n            out failures : Failure[*];\n            out failureLinks : FailureRelationship[*];\n        }\n        \n        action generateRiskReport {\n            in scenario : RiskScenario;\n            out report : Text;\n            out recommendations : Text[*];\n        }\n        \n        state riskStates {\n            entry state initial;\n            state identifying;\n            state analyzing;\n            state evaluating;\n            state reporting;\n            state monitoring;\n            \n            transition initial then identifying;\n            transition identifying then analyzing;\n            transition analyzing then evaluating;\n            transition evaluating then reporting;\n            transition reporting then monitoring;\n            transition monitoring then identifying;\n        }\n    }\n    \n    requirement def SystemRequirements {\n        doc /* The system shall support comprehensive risk and failure management */\n        \n        requirement identificationReq {\n            doc /* System shall identify and describe various possible situations */\n            subject system : RiskManagementSystem;\n        }\n        \n        requirement causalityReq {\n            doc /* System shall establish and analyze causal relationships */\n            subject system : RiskManagementSystem;\n        }\n        \n        requirement probabilityReq {\n            doc /* System shall record probability of each cause */\n            subject cause : Cause;\n            constraint { cause.probability >= 0.0 and cause.probability <= 1.0 }\n        }\n        \n        requirement severityReq {\n            doc /* System shall record severity level of each failure */\n            subject failure : Failure;\n            constraint { failure.severity >= 1 and failure.severity <= 10 }\n        }\n        \n        requirement analysisReq {\n            doc /* System shall analyze sequence and impact mechanisms */\n            subject analysis : RiskAnalysis;\n        }\n        \n        requirement scenarioReq {\n            doc /* System shall support modeling of different risk scenarios */\n            subject scenarios : RiskScenario[*];\n        }\n    }\n    \n    verification def RiskSystemVerification {\n        subject system : RiskManagementSystem;\n        \n        verify requirement SystemRequirements::identificationReq {\n            return system.scenarios.situations->notEmpty();\n        }\n        \n        verify requirement SystemRequirements::causalityReq {\n            return system.scenarios.causalLinks->notEmpty();\n        }\n    }\n}",
    "package RiskMetadataManagementSystem {\n    import ScalarValues::*;\n    \n    // Core domain concepts\n    abstract item def RiskElement {\n        attribute id : String;\n        attribute name : String;\n        attribute description : String;\n        attribute createdDate : String;\n        attribute modifiedDate : String;\n    }\n    \n    item def Scenario :> RiskElement {\n        attribute likelihood : Real;\n        attribute context : String;\n        ref causes : Cause[0..*];\n        ref failures : Failure[0..*];\n        ref relatedScenarios : Scenario[0..*];\n    }\n    \n    item def Cause :> RiskElement {\n        attribute probability : Real {\n            assert constraint { probability >= 0.0 and probability <= 1.0 }\n        }\n        attribute category : String;\n        ref triggeringScenarios : Scenario[0..*];\n    }\n    \n    item def Failure :> RiskElement {\n        attribute severity : SeverityLevel;\n        attribute impact : String;\n        attribute detectability : Real {\n            assert constraint { detectability >= 0.0 and detectability <= 1.0 }\n        }\n    }\n    \n    enum def SeverityLevel {\n        enum negligible;\n        enum minor;\n        enum moderate;\n        enum major;\n        enum catastrophic;\n    }\n    \n    // Relationships\n    assoc def CausalRelationship {\n        end sourceScenario : Scenario[1];\n        end targetScenario : Scenario[1];\n        attribute relationshipType : String;\n        attribute strength : Real {\n            assert constraint { strength >= 0.0 and strength <= 1.0 }\n        }\n    }\n    \n    assoc def ScenarioCauseAssociation {\n        end scenario : Scenario[1];\n        end cause : Cause[1..*];\n        attribute contributionFactor : Real;\n    }\n    \n    assoc def ScenarioFailureAssociation {\n        end scenario : Scenario[1];\n        end failure : Failure[1..*];\n        attribute likelihood : Real;\n    }\n    \n    // Risk scenario composition\n    item def RiskScenario :> RiskElement {\n        ref scenarios : Scenario[1..*] ordered;\n        ref propagationPaths : CausalRelationship[0..*];\n        attribute aggregatedRisk : Real;\n        attribute status : RiskStatus;\n        \n        calc def calculateAggregatedRisk : Real {\n            // Calculation logic would be implemented here\n            return 0.0;\n        }\n    }\n    \n    enum def RiskStatus {\n        enum identified;\n        enum analyzed;\n        enum mitigated;\n        enum accepted;\n        enum closed;\n    }\n    \n    // System capabilities\n    abstract action def RiskManagementAction {\n        in item target : RiskElement;\n        out item result : RiskElement;\n    }\n    \n    action def IdentifyScenario :> RiskManagementAction {\n        in item scenarioData : Scenario;\n        out item identifiedScenario : Scenario;\n    }\n    \n    action def AssociateCause {\n        in item scenario : Scenario;\n        in item cause : Cause;\n        in item probability : Real;\n        out item association : ScenarioCauseAssociation;\n    }\n    \n    action def AssociateFailure {\n        in item scenario : Scenario;\n        in item failure : Failure;\n        out item association : ScenarioFailureAssociation;\n    }\n    \n    action def EstablishCausalRelationship {\n        in item source : Scenario;\n        in item target : Scenario;\n        in item strength : Real;\n        out item relationship : CausalRelationship;\n    }\n    \n    action def ComposeRiskScenario {\n        in item scenarios : Scenario[1..*];\n        in item relationships : CausalRelationship[0..*];\n        out item riskScenario : RiskScenario;\n    }\n    \n    // Analysis capabilities\n    action def AnalyzeRiskPropagation {\n        in item startScenario : Scenario;\n        out item propagationChain : Scenario[1..*] ordered;\n        out item cumulativeRisk : Real;\n    }\n    \n    action def EvaluateRiskSeverity {\n        in item riskScenario : RiskScenario;\n        out item severityScore : Real;\n        out item recommendations : String[0..*];\n    }\n    \n    // System interface\n    interface def RiskMetadataInterface {\n        port scenarioInput : ~Scenario;\n        port causeInput : ~Cause;\n        port failureInput : ~Failure;\n        port riskOutput : RiskScenario;\n    }\n    \n    // Integration support\n    metadata def ModelingLanguageCompatibility {\n        attribute supportedLanguages : String[1..*] = [\"SysML\", \"UML\", \"BPMN\"];\n        attribute exportFormats : String[1..*] = [\"XMI\", \"JSON\", \"XML\"];\n    }\n    \n    // System constraints\n    constraint def RiskConsistency {\n        doc /* All causes must have at least one associated scenario */\n        constraint { \n            Cause.all().forAll(c | c.triggeringScenarios.size() > 0)\n        }\n    }\n    \n    constraint def ProbabilityNormalization {\n        doc /* Sum of cause probabilities for a scenario should not exceed 1.0 */\n        constraint {\n            Scenario.all().forAll(s | \n                s.causes.sum(c | c.probability) <= 1.0\n            )\n        }\n    }\n}",
    "package EquipmentRiskAnalysisSystem {\n    \n    import ScalarValues::*;\n    import ISQ::*;\n    import SI::*;\n    \n    attribute def BatteryLevel :> Real {\n        attribute unit = percent;\n    }\n    \n    attribute def FailureProbability :> Real {\n        attribute unit = one;\n        constraint { self >= 0.0 and self <= 1.0 }\n    }\n    \n    attribute def SeverityLevel :> Integer {\n        constraint { self >= 1 and self <= 5 }\n    }\n    \n    enum def EquipmentState {\n        enum normal;\n        enum lowBattery;\n        enum shutdown;\n    }\n    \n    item def Battery {\n        attribute currentLevel : BatteryLevel;\n        attribute ageInMonths : Real;\n        attribute failureProbability : FailureProbability;\n    }\n    \n    item def Equipment {\n        part battery : Battery;\n        attribute operationalState : EquipmentState = EquipmentState::normal;\n        attribute minimumBatteryThreshold : BatteryLevel = 20.0;\n    }\n    \n    concern def Risk {\n        doc /* Represents a potential risk in the system */\n        attribute probability : FailureProbability;\n        attribute impact : String;\n    }\n    \n    concern batteryAgingRisk : Risk {\n        doc /* Risk of battery aging leading to low battery level */\n        attribute redefines impact = \"Low battery level due to aging\";\n    }\n    \n    concern def FailureMode {\n        attribute cause : String;\n        attribute effect : String;\n        attribute severity : SeverityLevel;\n    }\n    \n    concern deviceShutdownFailure : FailureMode {\n        attribute redefines cause = \"Prolonged low battery state\";\n        attribute redefines effect = \"Device shutdown\";\n        attribute redefines severity = 4;\n    }\n    \n    analysis def RiskAnalysis {\n        subject equipment : Equipment;\n        \n        calc batteryFailureProbability : FailureProbability {\n            equipment.battery.failureProbability\n        }\n        \n        constraint lowBatteryDetection {\n            equipment.battery.currentLevel < equipment.minimumBatteryThreshold \n            implies \n            equipment.operationalState == EquipmentState::lowBattery\n        }\n    }\n    \n    action def MonitorBatteryLevel {\n        in equipment : Equipment;\n        out detectedState : EquipmentState;\n        \n        action checkBatteryLevel {\n            if (equipment.battery.currentLevel < equipment.minimumBatteryThreshold) {\n                detectedState := EquipmentState::lowBattery;\n            } else {\n                detectedState := EquipmentState::normal;\n            }\n        }\n    }\n    \n    action def AnalyzeFailureRisk {\n        in equipment : Equipment;\n        in duration : Real;\n        out riskAssessment : FailureMode;\n        \n        action evaluateShutdownRisk {\n            if (equipment.operationalState == EquipmentState::lowBattery and duration > 300.0) {\n                riskAssessment := deviceShutdownFailure;\n            }\n        }\n    }\n    \n    requirement def ContinuousMonitoring {\n        doc /* System shall continuously monitor battery level during operation */\n        subject system : Equipment;\n        \n        require constraint {\n            system.battery.currentLevel > 0.0\n        }\n    }\n    \n    requirement def BatteryAgingDetection {\n        doc /* System shall detect battery aging and associated failure probability */\n        subject system : Equipment;\n        \n        require constraint {\n            system.battery.ageInMonths > 24.0 implies system.battery.failureProbability > 0.3\n        }\n    }\n    \n    requirement def LowBatteryStateIdentification {\n        doc /* System shall identify low battery state when below threshold */\n        subject system : Equipment;\n        \n        require constraint {\n            system.battery.currentLevel < system.minimumBatteryThreshold \n            implies \n            system.operationalState == EquipmentState::lowBattery\n        }\n    }\n    \n    requirement def HighSeverityAlertRequirement {\n        doc /* System shall assign appropriate severity level for critical failures */\n        subject failure : FailureMode;\n        \n        require constraint {\n            failure.effect == \"Device shutdown\" implies failure.severity >= 3\n        }\n    }\n    \n    verification def VerifyRiskDetection {\n        subject riskAnalysis : RiskAnalysis;\n        \n        objective {\n            doc /* Verify that battery aging risk is properly detected */\n        }\n    }\n}",
    "package SystemStructuralDecomposition {\n    \n    requirement def StructuralDecompositionCapability {\n        doc /* The system must possess a clear capability for structural decomposition */\n        \n        requirement hierarchicalStructure {\n            doc /* Ability to explicitly present a top-down hierarchical structure */\n            require constraint { \n                doc /* System divided into multiple subsystems and components */\n            }\n        }\n        \n        requirement functionalCoverage {\n            doc /* Functions and capabilities of each level are fully covered */\n        }\n        \n        requirement interfaceDefinition {\n            doc /* Interfaces between system components should be well defined */\n        }\n        \n        requirement componentIndependence {\n            doc /* Each component can be independently understood and analyzed */\n        }\n        \n        requirement componentCollaboration {\n            doc /* Components collaborate effectively within the overall system */\n        }\n        \n        requirement stakeholderComprehension {\n            doc /* System engineers and IV&V parties must be able to use structural view */\n            subject systemEngineers;\n            subject ivvParties;\n        }\n        \n        requirement systemVerification {\n            doc /* Comprehend and verify system's integrity and modular design */\n            \n            requirement integrityVerification {\n                doc /* Verify system integrity */\n            }\n            \n            requirement modularDesignVerification {\n                doc /* Verify modular design */\n            }\n        }\n        \n        requirement requirementsSatisfaction {\n            doc /* Ensure system's various functional and performance requirements are met */\n        }\n    }\n    \n    abstract part def System {\n        part subsystems : Subsystem[1..*];\n        \n        interface def SystemInterface;\n        \n        port systemPorts : SystemInterface[*];\n    }\n    \n    abstract part def Subsystem {\n        part components : Component[1..*];\n        \n        port subsystemPorts : SystemInterface[*];\n    }\n    \n    abstract part def Component {\n        attribute isIndependent : Boolean = true;\n        \n        port componentPorts : SystemInterface[*];\n    }\n    \n    view def StructuralDecompositionView {\n        satisfy StructuralDecompositionCapability;\n        \n        expose System::*;\n        expose Subsystem::*;\n        expose Component::*;\n        \n        viewpoint {\n            stakeholder systemEngineers;\n            stakeholder ivvParties;\n            concern \"System integrity and modular design verification\";\n        }\n    }\n}",
    "package AutomotiveSystemArchitecture {\n    import ScalarValues::*;\n    \n    enum def SafetyClassification {\n        enum mandatory;\n        enum optional;\n    }\n    \n    attribute def SafetyAttribute {\n        attribute isSafetyCritical : Boolean;\n        attribute classification : SafetyClassification[0..1];\n    }\n    \n    abstract part def SystemComponent {\n        attribute name : String;\n        attribute id : String;\n        attribute safety : SafetyAttribute;\n    }\n    \n    abstract part def SafetyComponent :> SystemComponent {\n        attribute safety : SafetyAttribute {\n            :>> isSafetyCritical = true;\n        }\n    }\n    \n    part def MandatorySafetyComponent :> SafetyComponent {\n        attribute safety : SafetyAttribute {\n            :>> classification = SafetyClassification::mandatory;\n        }\n    }\n    \n    part def OptionalSafetyComponent :> SafetyComponent {\n        attribute safety : SafetyAttribute {\n            :>> classification = SafetyClassification::optional;\n        }\n    }\n    \n    part def NonSafetyComponent :> SystemComponent {\n        attribute safety : SafetyAttribute {\n            :>> isSafetyCritical = false;\n        }\n    }\n    \n    interface def ComponentInterface {\n        in item inputSignals[0..*];\n        out item outputSignals[0..*];\n    }\n    \n    part def SeatBelt :> MandatorySafetyComponent {\n        port seatBeltInterface : ComponentInterface;\n    }\n    \n    part def Bumper :> MandatorySafetyComponent {\n        port bumperInterface : ComponentInterface;\n    }\n    \n    part def DriverAirbag :> OptionalSafetyComponent {\n        port airbagInterface : ComponentInterface;\n    }\n    \n    part def ABS :> OptionalSafetyComponent {\n        port absInterface : ComponentInterface;\n    }\n    \n    part def AutomotiveSystem :> SystemComponent {\n        part bodySubsystem : BodySubsystem[1];\n        part chassisSubsystem : ChassisSubsystem[1];\n        part powertrainSubsystem : PowertrainSubsystem[1];\n        part electricalSubsystem : ElectricalSubsystem[1];\n    }\n    \n    part def BodySubsystem :> SystemComponent {\n        part seatBelts : SeatBelt[4..*];\n        part bumpers : Bumper[2];\n        part airbags : DriverAirbag[0..*];\n        part doors : Door[2..*];\n    }\n    \n    part def ChassisSubsystem :> SystemComponent {\n        part brakingSystem : BrakingSystem[1];\n        part suspension : Suspension[1];\n        part steering : SteeringSystem[1];\n    }\n    \n    part def BrakingSystem :> SystemComponent {\n        part abs : ABS[0..1];\n        part brakePedal : BrakePedal[1];\n        part brakeDiscs : BrakeDisc[4];\n    }\n    \n    part def PowertrainSubsystem :> SystemComponent {\n        part engine : Engine[1];\n        part transmission : Transmission[1];\n    }\n    \n    part def ElectricalSubsystem :> SystemComponent {\n        part battery : Battery[1];\n        part ecu : ECU[1..*];\n    }\n    \n    part def Door :> NonSafetyComponent {\n        port doorInterface : ComponentInterface;\n    }\n    \n    part def Suspension :> NonSafetyComponent {\n        port suspensionInterface : ComponentInterface;\n    }\n    \n    part def SteeringSystem :> NonSafetyComponent {\n        port steeringInterface : ComponentInterface;\n    }\n    \n    part def BrakePedal :> NonSafetyComponent {\n        port pedalInterface : ComponentInterface;\n    }\n    \n    part def BrakeDisc :> NonSafetyComponent {\n        port discInterface : ComponentInterface;\n    }\n    \n    part def Engine :> NonSafetyComponent {\n        port engineInterface : ComponentInterface;\n    }\n    \n    part def Transmission :> NonSafetyComponent {\n        port transmissionInterface : ComponentInterface;\n    }\n    \n    part def Battery :> NonSafetyComponent {\n        port batteryInterface : ComponentInterface;\n    }\n    \n    part def ECU :> NonSafetyComponent {\n        port ecuInterface : ComponentInterface;\n    }\n    \n    view def HierarchicalStructureView {\n        expose AutomotiveSystem::**;\n        render asTree;\n    }\n    \n    view def SafetyComponentsView {\n        filter SafetyComponent::**;\n        viewpoint {\n            frame safety.classification;\n            frame safety.isSafetyCritical;\n        }\n        render asTable;\n    }\n    \n    view def NonSafetyComponentsView {\n        filter NonSafetyComponent::**;\n        render asTable;\n    }\n    \n    view def MandatorySafetyView {\n        filter MandatorySafetyComponent::**;\n        render asTree;\n    }\n    \n    view def OptionalSafetyView {\n        filter OptionalSafetyComponent::**;\n        render asTree;\n    }\n}",
    "package AutomotiveDomain {\n    doc /* This system model provides standardized definitions and annotations \n         * for fundamental concepts and elements in the automotive domain */\n    \n    import ISQ::*;\n    import SI::*;\n    import ScalarValues::*;\n    \n    // Define torque as a physical quantity\n    attribute def TorqueValue :> ScalarQuantityValue {\n        doc /* Torque (扭矩) - rotational force measurement */\n        attribute quantityDimension :>> num = ISQ::torque;\n        attribute measurementUnit :>> mRef = SI::['N·m'];\n    }\n    \n    // Core automobile definition\n    part def Automobile {\n        doc /* Core component representing an automobile vehicle */\n        alias Car;\n        \n        attribute torque : TorqueValue {\n            doc /* Vehicle torque characteristic */\n        }\n    }\n    \n    // Extensible base for automotive characteristics\n    attribute def AutomotiveCharacteristic {\n        doc /* Base definition for standardized automotive characteristics */\n    }\n    \n    // Framework for system integration\n    part def AutomotiveSystem {\n        doc /* Extensible framework for automotive system development and integration */\n        \n        part vehicle : Automobile[1..*] {\n            doc /* Vehicle instances within the system */\n        }\n    }\n}",
    "package DocumentManagementSystem {\n    import ISQ::*;\n    import SI::*;\n    \n    item def Automobile {\n        doc /* Core object for managing automobile-related information and documentation */\n        \n        attribute vin : String;\n        attribute make : String;\n        attribute model : String;\n        attribute year : Integer;\n        attribute specifications : AutomobileSpecification[0..*];\n        attribute documents : Document[0..*];\n    }\n    \n    alias Car for Automobile {\n        doc /* Alternative reference name for Automobile to support different user preferences */\n    }\n    \n    item def AutomobileSpecification {\n        attribute torque : ISQ::TorqueValue;\n        attribute power : ISQ::PowerValue;\n        attribute weight : ISQ::MassValue;\n        attribute length : ISQ::LengthValue;\n        attribute width : ISQ::LengthValue;\n        attribute height : ISQ::LengthValue;\n    }\n    \n    item def Document {\n        attribute id : String;\n        attribute title : String;\n        attribute content : String;\n        attribute createdDate : String;\n        attribute lastModified : String;\n        attribute author : String;\n        attribute documentType : DocumentType;\n        attribute annotations : Annotation[0..*];\n    }\n    \n    enum def DocumentType {\n        technical;\n        maintenance;\n        regulatory;\n        user_manual;\n        service_record;\n        general;\n    }\n    \n    item def Annotation {\n        doc /* Explanatory notes for objects and their aliases */\n        \n        attribute annotationText : String;\n        attribute annotatedObject : String;\n        attribute timestamp : String;\n        attribute annotator : String;\n    }\n    \n    part def DocumentManagementPlatform {\n        doc /* Main system for managing automobile documentation */\n        \n        part automobiles : Automobile[0..*];\n        part documentRepository : DocumentRepository;\n        part searchEngine : SearchEngine;\n        part archiveSystem : ArchiveSystem;\n        \n        port userInterface : UserInterfacePort;\n    }\n    \n    part def DocumentRepository {\n        attribute documents : Document[0..*];\n        \n        action storeDocument(in doc : Document);\n        action retrieveDocument(in docId : String) : Document;\n        action updateDocument(in doc : Document);\n        action deleteDocument(in docId : String);\n    }\n    \n    part def SearchEngine {\n        action searchByAutomobile(in searchTerm : String) : Automobile[0..*];\n        action searchByCar(in searchTerm : String) : Car[0..*];\n        action searchDocuments(in query : String) : Document[0..*];\n    }\n    \n    part def ArchiveSystem {\n        action archiveDocument(in doc : Document);\n        action retrieveArchivedDocument(in docId : String) : Document;\n        action listArchivedDocuments() : Document[0..*];\n    }\n    \n    port def UserInterfacePort {\n        in item enterAutomobileInfo : Automobile;\n        in item enterDocument : Document;\n        in item queryRequest : String;\n        out item queryResult : Document[0..*];\n        out item automobileResult : Automobile[0..*];\n    }\n    \n    action def ManageAutomobileInformation {\n        in automobile : Automobile;\n        out result : Boolean;\n        \n        action enterData;\n        action validateData;\n        action storeData;\n    }\n    \n    action def QueryInformation {\n        in searchCriteria : String;\n        in searchType : SearchType;\n        out results : Document[0..*];\n        \n        action performSearch;\n        action filterResults;\n        action returnResults;\n    }\n    \n    enum def SearchType {\n        byAutomobile;\n        byCar;\n        byDocument;\n        byAnnotation;\n    }\n    \n    requirement def ProfessionalAccuracy {\n        doc /* System shall support standard physical quantity systems for professional and accurate documentation */\n        \n        subject platform : DocumentManagementPlatform;\n        require constraint {\n            platform.automobiles.specifications.torque istype ISQ::TorqueValue\n        }\n    }\n    \n    requirement def FlexibleNaming {\n        doc /* System shall support both \"Automobile\" and \"Car\" terminology for user flexibility */\n        \n        subject searchEngine : SearchEngine;\n    }\n    \n    requirement def Traceability {\n        doc /* All information shall be clearly annotated and traceable */\n        \n        subject documents : Document[0..*];\n        require constraint {\n            documents.annotations->size() >= 0\n        }\n    }\n}",
    "I'll analyze the requirements and create a SysML v2 model.\n\n<scratchpad>\nKey functional/non-functional information extracted:\n1. System manages automobile information\n2. Emphasis on vehicle torque parameters\n3. Need to represent Automobile objects\n4. \"Car\" is an alias for Automobile\n5. Handle basic physical quantities, specifically torque values\n6. \"Torque\" is an alias for TorqueValue\n7. Import and manage scalar physical quantity data\n8. Support automobile-related data processing and modeling\n\nMapping to SysML v2:\n- Use package for organization\n- Import ISQ (International System of Quantities) for physical quantities\n- Define item for Automobile\n- Create alias for Car -> Automobile\n- Import TorqueValue from ISQ\n- Create alias for Torque -> TorqueValue\n- Import ScalarValues for general scalar quantity support\n</scratchpad>\n\npackage AutomobileManagementSystem {\n    import ScalarValues::*;\n    import ISQ::*;\n    import ISQ::TorqueValue;\n    \n    alias Car for Automobile;\n    alias Torque for TorqueValue;\n    \n    item def Automobile {\n        attribute torque : Torque;\n    }\n}",
    "package VehicleSystem {\n    \n    part def Vehicle {\n        part engine : Engine;\n    }\n    \n    part def Engine {\n        part cylinders : Cylinder[4..6];\n    }\n    \n    part def Cylinder;\n    \n    part def SmallVehicle :> Vehicle {\n        part engine : Engine {\n            part redefines cylinders : Cylinder[4];\n        }\n    }\n    \n    part def LargeVehicle :> Vehicle {\n        part engine : Engine {\n            part redefines cylinders : Cylinder[6];\n        }\n    }\n}",
    "I'll analyze this requirement and create a SysML v2 model.\n\n<scratchpad>\nKey functional requirements:\n- Manage fuel flow\n- Deliver fuel from tank to engine\n- Support fuel return\n- Monitor fuel temperature\n- Manage fuel temperature\n\nKey non-functional requirements:\n- Reliability of fuel flow\n- Safety of fuel flow\n\nKey components/parts:\n- Fuel tank\n- Engine\n- Fuel interfaces (standardized)\n\nKey interfaces/connections:\n- Fuel flow from tank to engine\n- Fuel return flow\n- Fuel interfaces connecting tank and engine\n\nMapping to SysML v2:\n- Use package to organize\n- Define parts: fuel tank, engine\n- Define interfaces for fuel flow\n- Define actions for monitoring and managing\n- Define flows for fuel delivery and return\n- Define requirements for reliability and safety\n- Use connections to show fuel flow paths\n</scratchpad>\n\npackage FuelManagementSystem {\n    import ScalarValues::*;\n    import ISQ::*;\n    import SI::*;\n    \n    part def FuelTank {\n        attribute fuelLevel : Real;\n        port fuelOutlet : FuelInterface;\n        port fuelInlet : FuelInterface;\n    }\n    \n    part def Engine {\n        port fuelInlet : FuelInterface;\n        port fuelReturn : FuelInterface;\n    }\n    \n    interface def FuelInterface {\n        end supplierEnd : FuelFlowEnd;\n        end consumerEnd : FuelFlowEnd;\n    }\n    \n    port def FuelFlowEnd {\n        out item fuelFlow : Fuel;\n        in item returnFlow : Fuel;\n    }\n    \n    item def Fuel {\n        attribute temperature : TemperatureValue;\n        attribute flowRate : Real;\n    }\n    \n    part fuelManagementSystem : FuelManagementSystem {\n        part fuelTank : FuelTank;\n        part engine : Engine;\n        \n        interface fuelSupplyInterface : FuelInterface connect \n            supplierEnd ::> fuelTank.fuelOutlet to\n            consumerEnd ::> engine.fuelInlet;\n            \n        interface fuelReturnInterface : FuelInterface connect\n            supplierEnd ::> engine.fuelReturn to\n            consumerEnd ::> fuelTank.fuelInlet;\n            \n        action manageFuelFlow {\n            action deliverFuel {\n                flow fuelTank.fuelOutlet.fuelFlow to engine.fuelInlet.fuelFlow;\n            }\n            \n            action returnFuel {\n                flow engine.fuelReturn.returnFlow to fuelTank.fuelInlet.returnFlow;\n            }\n            \n            action monitorFuelTemperature {\n                in fuel : Fuel;\n                out temperature : TemperatureValue = fuel.temperature;\n            }\n            \n            action manageFuelTemperature {\n                in currentTemp : TemperatureValue;\n                out controlSignal : Real;\n            }\n        }\n    }\n    \n    requirement fuelFlowReliability {\n        doc /* The system shall ensure reliability of fuel flow */\n        subject fuelManagementSystem;\n    }\n    \n    requirement fuelFlowSafety {\n        doc /* The system shall ensure safety of fuel flow */\n        subject fuelManagementSystem;\n    }\n    \n    requirement standardizedInterfaces {\n        doc /* Fuel tank and engine shall be connected via standardized fuel interfaces */\n        subject fuelSupplyInterface, fuelReturnInterface;\n    }\n}",
    "package VehicleStructure {\n    import ScalarValues::*;\n    \n    part def Vehicle {\n        attribute mass : Real;\n        \n        part frontAxleAssembly : AxleAssembly;\n        part rearAxleAssembly : AxleAssembly;\n    }\n    \n    part def AxleAssembly {\n        part axle : Axle;\n        part wheels : Wheel[2] ordered;\n    }\n    \n    part def Axle {\n    }\n    \n    part def FrontAxle :> Axle {\n        attribute steeringAngle : Real;\n    }\n    \n    part def Wheel {\n    }\n    \n    part vehicle1 : Vehicle {\n        attribute :>> mass = 1750.0;\n        \n        part :>> frontAxleAssembly {\n            part :>> axle : FrontAxle;\n            part :>> wheels {\n                ref leftFrontWheel : Wheel = wheels#(1);\n                ref rightFrontWheel : Wheel = wheels#(2);\n            }\n        }\n        \n        part :>> rearAxleAssembly {\n            part :>> wheels {\n                ref leftRearWheel : Wheel = wheels#(1);\n                ref rightRearWheel : Wheel = wheels#(2);\n            }\n        }\n    }\n    \n    part vehicle2 : Vehicle {\n        attribute :>> mass = 2000.0;\n    }\n}"
]