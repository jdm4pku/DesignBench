[
    " ```\npackage VehicleManagementSystem {\n\n  part def Vehicle {\n    mass: Real\n    status: VehicleStatus\n    engine: Engine [1]\n    driver: Driver [0..1]\n  }\n\n  part def Engine {\n    // Engine properties\n  }\n  \n  part def Driver {\n    // Driver properties  \n  }\n\n  enum VehicleStatus {\n    PARKED,\n    DRIVING    \n  }\n  \n  part def VehicleStatus {\n    gearSetting: Integer\n    acceleratorPedalPosition: Real\n  }\n\n}\n```",
    " ```sysml\npackage VehicleModel {\n\n    abstract class Vehicle;\n\n    class ManuallyOperatedVehicle specializes Vehicle {\n        driver: Personnel[1];\n    }\n    \n    class PoweredVehicle specializes Vehicle {\n        engine: Engine[1..*];\n    }\n    \n    class ManuallyOperatedPoweredVehicle specializes ManuallyOperatedVehicle, PoweredVehicle;\n    \n    class Personnel;\n    \n    class Engine;\n\n}\n```",
    " ```sysml\npackage VehicleStructure {\n\n    abstract class Vehicle {\n        part def engine: Engine [1]\n        part def transmission: Transmission [1]\n        part def wheels: Wheel [4]\n    }\n\n    abstract class VehicleComponent { }\n\n    class Engine specializes VehicleComponent { }\n\n    class Transmission specializes VehicleComponent { }\n    \n    class Wheel specializes VehicleComponent { }\n\n}\n```",
    " ```sysml\npackage VehicleSystem {\n\n    abstract requirement VehicleDefinition {\n        doc \"The system must be able to define and distinguish between different types of vehicles.\"\n    }\n\n    requirement SmallVehicleRequirement specializes VehicleDefinition {\n        doc \"Small vehicles must be equipped with a small engine, which contains 4 cylinders.\"\n    }\n\n    requirement LargeVehicleRequirement specializes VehicleDefinition {\n        doc \"Large vehicles must be equipped with a large engine, which contains 6 cylinders.\"\n    }\n\n    abstract part def Vehicle {\n        part engine : Engine;\n    }\n\n    part def SmallVehicle specializes Vehicle {\n        part engine : SmallEngine;\n    }\n\n    part def LargeVehicle specializes Vehicle {\n        part engine : LargeEngine;\n    }\n\n    abstract part def Engine {\n        part cylinders : Cylinder[1..*];\n    }\n\n    part def SmallEngine specializes Engine {\n        part cylinders : Cylinder[4];\n    }\n\n    part def LargeEngine specializes Engine {\n        part cylinders : Cylinder[6];\n    }\n\n    part def Cylinder;\n\n    requirement EngineRequirement {\n        doc \"Each engine contains a functional subsystem composed of a specific number of cylinders to meet the actual requirements of the vehicle's power system.\"\n    }\n\n    satisfy SmallVehicleRequirement {\n        by SmallVehicle, SmallEngine;\n    }\n\n    satisfy LargeVehicleRequirement {\n        by LargeVehicle, LargeEngine;\n    }\n    \n    satisfy EngineRequirement {\n        by Engine;\n    }\n\n}\n```",
    " ```sysml\npackage TrafficSignalSystem {\n\n    part def TrafficSignal {\n        part def Light {\n            attribute currentColor: LightColor\n        }\n    }\n\n    enum LightColor {\n        case RED\n        case YELLOW\n        case GREEN\n    }\n\n    part def GreenTrafficSignal specializes TrafficSignal {\n        part def Light {\n            attribute currentColor = LightColor::GREEN\n        }\n    }\n\n}\n```",
    " package InformationClassificationManagement {\n  enum InformationClassification {\n    case Unclassified {\n      code = 'uncl'\n      color = 'green'\n    }\n    case Confidential {\n      code = 'conf' \n      color = 'yellow'\n    }\n    case Secret {\n      code = 'secr'\n      color = 'red'  \n    }\n  }\n  \n  enum GradeLevel {\n    case A {\n      points = 4.0\n    }\n    case B {\n      points = 3.0  \n    }\n    case C {\n      points = 2.0\n    }\n    case D {\n      points = 1.0\n    }\n    case F {\n      points = 0.0\n    }\n  }\n\n  requirement InformationClassificationManagement {\n    description = \"The system shall implement an information classification management mechanism based on the traffic light principle, with information divided into Unclassified, Confidential, and Secret levels, each corresponding to a code and color. The system shall also support grade classification with levels A, B, C, D and F corresponding to point values.\"\n    \n    satisfy {\n      item def InformationClassification\n      item def GradeLevel\n    }\n  }\n}",
    " ```sysml\npackage VehicleSystem {\n\n  abstract part def Vehicle {\n    part engine : Engine [1]\n  }\n\n  part def SmallVehicle :> Vehicle {\n    engine : SmallEngine [1]\n  }\n\n  part def LargeVehicle :> Vehicle {\n    engine : LargeEngine [1]\n  }\n\n  abstract part def Engine {\n    part cylinder : Cylinder [4..6]\n  }\n\n  part def SmallEngine :> Engine {\n    cylinder : Cylinder [4]\n  }\n  \n  part def LargeEngine :> Engine {\n    cylinder : Cylinder [6]\n  }\n\n  part def Cylinder {\n  }\n\n}\n```",
    " ```\npackage VehicleModeling {\n\n  abstract class Fuel;\n\n  class Personnel {\n    name: String;\n    role: String;\n  }\n\n  class Vehicle {\n    name: String;\n    qualityAttributes: String[0..*];\n    driver: Personnel;\n    fuelTank: FuelTank;\n  }\n\n  class FuelTank {\n    capacity: Real;\n    fuelType: Fuel;\n  }\n\n  part def theFuel: Fuel;\n  part def thePersonnel: Personnel[1..*];\n  part def theVehicle: Vehicle[1..*];\n\n  theVehicle.driver := thePersonnel;\n  theVehicle.fuelTank.fuelType := theFuel;\n}\n```",
    " ```sysml\npackage AutomobileWheelAssembly {\n\n  part def WheelAssembly {\n    part def WheelBearingUnit {\n    }\n    part def Tire {\n      part def Bead {\n        quantity = 2;\n      }\n    }\n    part def Hub {\n      part def Rim {\n        quantity = 2;\n      }\n      part def BoltMountingHole {\n        quantity = *;\n      }\n      part def ThreadedHole {\n        quantity = *;\n      }\n    }\n    part def Bolt {\n      quantity = *;\n    }\n\n    connection def TireBeadToHubRim {\n      connect Tire::Bead to Hub::Rim;\n      kind = sealed;\n    }\n    \n    connection def BoltConnection {\n      connect Hub::BoltMountingHole to Hub::ThreadedHole;\n      connector = Bolt;\n    }\n  }\n\n}\n```",
    " ```\npackage FuelManagementSystem {\n    part def FuelTankAssembly {\n        port def FuelSupplyPort: ~Engine.FuelReceivePort;\n        port def FuelReturnPort: ~Engine.FuelReturnPort;\n    }\n\n    part def Engine {\n        port def FuelReceivePort: ~FuelTankAssembly.FuelSupplyPort;\n        port def FuelReturnPort: ~FuelTankAssembly.FuelReturnPort;\n    }\n\n    part def FuelManagementSystem {\n        part fuelTank: FuelTankAssembly;\n        part engine: Engine;\n\n        fuelTank.FuelSupplyPort connect engine.FuelReceivePort;\n        fuelTank.FuelReturnPort connect engine.FuelReturnPort;\n    }\n\n    requirement def FuelFlowManagement {\n        doc \"This system is designed to achieve effective management of fuel flow.\";\n    }\n\n    requirement def FuelSupply {\n        doc \"The fuel tank supplies fuel to the engine through a dedicated port.\";\n    }\n\n    requirement def FuelReturn {\n        doc \"The fuel tank can receive excess fuel returned from the engine.\";\n    }\n\n    requirement def TemperatureMonitoring {\n        doc \"Temperature information can be detected and transmitted at the interface to ensure the safety and efficiency of fuel supply.\";\n    }\n\n    requirement def DataVisualization {\n        doc \"Users can obtain real-time data on fuel supply, return flow, and related temperature parameters, enabling visualized monitoring and precise control of fuel flow status.\";\n    }\n\n    requirement def EngineRequirements {\n        doc \"This effectively meets the engine's requirements for fuel management during operation.\";\n    }\n\n    satisfy FuelFlowManagement {\n        FuelSupply;\n        FuelReturn;\n        TemperatureMonitoring;\n        DataVisualization;\n        EngineRequirements;\n    }\n}\n```",
    " ```sysml\npackage VehicleVariants {\n\n  abstract vehicle vehicle {\n    mass: kg = 1750\n    parts:\n      frontAxle: axle [1]\n      rearAxle: axle [1]\n  }\n  \n  abstract axle axle {\n    parts:\n      tire: tire [2] ordered\n  }\n  \n  abstract frontAxle frontAxle:axle {\n    steeringAngle: rad\n  }\n  \n  part tire tire {\n  }\n    \n  part vehicle1 instanceof vehicle {\n  }\n\n  part vehicle1_c1 instanceof vehicle {\n    mass = 2000\n    frontAxle instanceof frontAxle {\n    }\n  }\n  \n}\n```\n\nThis SysML v2 model defines:\n\n- An abstract `vehicle` with a default mass of 1750 kg, containing 1 `frontAxle` and 1 `rearAxle`\n- An abstract `axle` containing 2 ordered `tire` parts\n- An abstract `frontAxle` specializing `axle` with an added `steeringAngle` attribute\n- A concrete `tire` part \n- A concrete `vehicle1` part instantiating the default `vehicle`\n- A variant configuration `vehicle1_c1` that:\n  - Instantiates `vehicle` but overrides the mass to 2000 kg\n  - Replaces the `frontAxle` with an instance of the specialized `frontAxle` with steering\n\nThis allows flexibly defining base structures, attributes, and relationships, while enabling variant configurations that inherit and override aspects as needed to capture different vehicle configurations.",
    " ```sysml\npackage CouplingSystem {\n  import OMGSysML::KernelLibrary::*;\n\n  part def Vehicle {\n    part def Hitch {\n      part def CouplingBall;\n    }\n  }\n\n  part def Trailer {\n    part def Connector;\n  }\n\n  part def CouplingSystem {\n    part vehicle: Vehicle;\n    part trailer: Trailer;\n\n    connection vbt: VehicleTrailerBinding {\n      end vehicle.Hitch.CouplingBall;\n      end trailer.Connector;\n    }\n  }\n\n  connection def VehicleTrailerBinding {\n    connection end CouplingBallEnd: Item;\n    connection end ConnectorEnd: Item;\n  }\n}\n```",
    " ```sysml\npackage VehiclePowerTransmissionSystem {\n\n  requirement VehicleTransmissionRequirements {\n    id = \"R1\"\n    text = \"The system shall include an engine, transmission (gearbox), clutch, driveshaft, rear axle assembly (including differential and left/right half-shafts), wheels, and an interface for interaction with the road surface.\"\n  }\n\n  requirement EngineRequirements {\n    id = \"R2\" \n    text = \"The engine shall receive control signals via a fuel command port and be coupled to the transmission through power and clutch ports.\"\n  }\n\n  requirement PowerTransmissionRequirements {\n    id = \"R3\"\n    text = \"Power shall be transmitted via the driveshaft to the rear axle assembly. The rear axle assembly shall include a differential that connects separately to the left and right half-shafts, delivering power to the rear wheels.\"\n  }\n\n  requirement WheelInterfaceRequirements {\n    id = \"R4\" \n    text = \"Each rear wheel shall be equipped with interfaces to both the rear axle and the road, enabling power output to the ground.\"\n  }\n\n  requirement InterfaceRequirements {\n    id = \"R5\"\n    text = \"The interfaces between the internal components of the system shall be clearly defined, allowing for flexible combination and hierarchical decomposition at various levels and within major assemblies.\"\n  }\n  \n  requirement ModularityRequirements {\n    id = \"R6\"\n    text = \"The system shall be designed to be modular and reconfigurable, meeting the needs of vehicle dynamics modeling, simulation, and subsequent optimization design.\"\n  }\n\n  requirement UsabilityRequirements {\n    id = \"R7\" \n    text = \"The system shall enable end users to understand, adjust, and expand the relationships and functions of various vehicle power components with ease.\"\n  }\n\n  system VehiclePowerTransmissionSystem {\n    part engine: Engine\n    part transmission: Transmission \n    part clutch: Clutch\n    part driveshaft: Driveshaft\n    part rearAxleAssembly: RearAxleAssembly\n    part wheels: Wheel[2]\n    part roadInterface: RoadInterface\n    \n    engine.fuelCommandPort -> transmission.fuelCommandPort\n    engine.powerPort -> clutch.enginePort\n    clutch.transmissionPort -> transmission.inputPort\n    transmission.outputPort -> driveshaft.inputPort  \n    driveshaft.outputPort -> rearAxleAssembly.inputPort\n    rearAxleAssembly.leftOutputPort -> wheels[0].axlePort\n    rearAxleAssembly.rightOutputPort -> wheels[1].axlePort\n    wheels[0].roadPort -> roadInterface.leftPort\n    wheels[1].roadPort -> roadInterface.rightPort\n  }\n\n  part Engine {\n    port fuelCommandPort: in ~FuelCommand\n    port powerPort: out ~Power \n    port clutchPort: out ~Clutch\n  }\n\n  part Transmission {\n    port fuelCommandPort: in ~FuelCommand  \n    port inputPort: in ~Power\n    port outputPort: out ~Power\n  }\n\n  part Clutch {\n    port enginePort: in ~Power\n    port transmissionPort: out ~Power  \n  }\n  \n  part Driveshaft {\n    port inputPort: in ~Power\n    port outputPort: out ~Power\n  }\n\n  part RearAxleAssembly {\n    port inputPort: in ~Power\n    port leftOutputPort: out ~Power\n    port rightOutputPort: out ~Power\n    \n    part differential: Differential\n    part leftHalfShaft: HalfShaft\n    part rightHalfShaft: HalfShaft\n      \n    inputPort -> differential.inputPort  \n    differential.leftPort -> leftHalfShaft.inputPort\n    differential.rightPort -> rightHalfShaft.inputPort\n    leftHalfShaft.outputPort -> leftOutputPort\n    rightHalfShaft.outputPort -> rightOutputPort\n  }\n\n  part Wheel {\n    port axlePort: in ~Power  \n    port roadPort: out ~Power\n  }\n\n  part RoadInterface {\n    port leftPort: in ~Power\n    port rightPort: in ~Power  \n  }\n  \n}\n```",
    " ```sysml\npackage MultiArchitectureSystem {\n\n  requirement req1 {\n    doc /* This system aims to achieve integrated management of multi-architecture systems, \n           involving communication and collaboration among multiple subsystems and components. */\n  }\n\n  system sys {\n    doc /* The system is decomposed into two main architectural breakdowns */\n  }\n\n  part def b11 {\n    part c1 {\n      port pb: ~pe;\n    }\n    part c2 {\n      connector c1.signal -> c2.signal;\n    }\n  }\n\n  part def b12 {\n    part c3 {\n      port pd: ~pf;\n    }\n    part c4 {\n    }\n  }\n\n  part def b21 {\n    use b11::c1;\n    use b11::c2;\n    use b12::c3;\n    use b12::c4;\n  }\n\n  part def b22 {\n    use b11::c1;\n    use b11::c2; \n    use b12::c3;\n    use b12::c4;\n  }\n  \n  interface pe {\n  }\n\n  interface pf {\n  }\n\n  connector b11.pe -> b12.pf;\n\n}\n```",
    " ```sysml\npackage PowertrainSystem {\n\n    requirement Req01 {\n        doc /* Input Requirement:\n        This system is designed to implement the functional architecture of an automotive powertrain, including the input of fuel commands, engine start-stop control, and support for power transmission and distribution. Users can control the system's power output through fuel commands. Once the engine is ignited and started, the system generates engine torque according to the fuel command. The torque is then sequentially amplified from the engine to the transmission, transmitted to the driveshaft, and finally distributed to the left and right wheels, thus enabling control of the vehicle's driving force. Additionally, users can shut down the engine via a command, triggering the cessation of the system's powertrain. During engine shutdown, generation and transmission of driving force will likewise be suspended, ensuring safe and intelligent operation of the system.\n        */\n    }\n\n    part def Powertrain {\n        part engine: Engine;\n        part transmission: Transmission;\n        part driveshaft: Driveshaft;\n        part leftWheel: Wheel;\n        part rightWheel: Wheel;\n    }\n\n    part def Engine {\n        in fuelCommand: FuelCommand;\n        in startStopCommand: StartStopCommand;\n        out torque: Torque;\n    }\n\n    part def Transmission {\n        in engineTorque: Torque;\n        out transmissionTorque: Torque;\n    }\n    \n    part def Driveshaft {\n        in transmissionTorque: Torque;\n        out driveshaftTorque: Torque; \n    }\n\n    part def Wheel {\n        in driveshaftTorque: Torque;\n        out drivingForce: DrivingForce;\n    }\n\n    abstract fuelCommand: FuelCommand;\n    abstract torque: Torque;\n    abstract startStopCommand: StartStopCommand;\n    abstract drivingForce: DrivingForce;\n\n    action StartEngine {\n        in fuelCmd: FuelCommand;\n        in startCmd: StartStopCommand;\n    }\n\n    action GenerateTorque {\n        in fuelCmd: FuelCommand;\n        out engineTorque: Torque;\n    }\n\n    action TransmitTorque {\n        in engineTorque: Torque;\n        out transmissionTorque: Torque;\n        out driveshaftTorque: Torque;\n    }\n\n    action DistributeTorque {\n        in driveshaftTorque: Torque;\n        out leftWheelForce: DrivingForce;\n        out rightWheelForce: DrivingForce;\n    }\n\n    action StopEngine {\n        in stopCmd: StartStopCommand;\n    }\n\n    action StopDrivingForce;\n\n    requirement Transmission {\n        doc /* The torque is sequentially amplified from the engine to the transmission */        \n    }\n\n    requirement Distribution {\n        doc /* The torque is transmitted to the driveshaft, and finally distributed to the left and right wheels */\n    }\n    \n    requirement UserControl {\n        doc /* Users can control the system's power output through fuel commands */\n    }\n\n    requirement StartStop {  \n        doc /* Users can shut down the engine via a command, triggering the cessation of the system's powertrain */\n    }\n\n    requirement SafeShutdown {\n        doc /* During engine shutdown, generation and transmission of driving force will likewise be suspended */\n    }\n\n}\n```",
    " ```sysml\npackage PowertrainControlSystem {\n\n    requirement req PowertrainControlReq {\n        doc /* This system is designed to implement the control logic of an automotive powertrain. Its main functions are as follows: \n        Upon receiving a fuel control command, the system sequentially starts the engine and generates torque according to the predetermined order. \n        The generated torque is then successively amplified, transmitted, and distributed, delivering power stage by stage to the vehicle's drive wheels to ensure normal driving. \n        When a stall signal is detected, the relevant operational processes will be halted as required. \n        The system supports engine start and shutdown control, as well as the entire power transmission process from fuel commands to actual wheel output torque, ensuring efficient and coordinated power delivery. \n        It provides users with a reliable power response and handling experience. */\n    }\n\n    block PowertrainControlSystem satisfies PowertrainControlReq {\n        part eng : Engine;\n        part tcu : TorqueControlUnit;\n        part ptu : PowerTransmissionUnit;\n        part sw : StallWatcher;\n\n        port in fuelCmd : FuelControlCommand;\n        port in stallSignal : StallSignal;\n        port out wheelTorque : WheelTorque;\n    }\n\n    block Engine {\n        port in startCmd : StartCommand;\n        port in shutdownCmd : ShutdownCommand;\n        port out torque : EngineTorque;\n    }\n\n    block TorqueControlUnit {\n        port in engineTorque : EngineTorque;\n        port out controlledTorque : ControlledTorque;\n    }\n\n    block PowerTransmissionUnit {\n        port in inTorque : ControlledTorque;\n        port out outTorque : WheelTorque;\n    }\n\n    block StallWatcher {\n        port in stallSignal : StallSignal;\n        port out stallAlert : StallAlert;\n    }\n\n    item FuelControlCommand;\n    item StallSignal;\n    item WheelTorque;\n    item StartCommand;\n    item ShutdownCommand;    \n    item EngineTorque;\n    item ControlledTorque;\n    item StallAlert;\n\n    item Definition {\n        doc /* Define flows and item types */\n    }\n}\n```",
    " ```sysml\npackage VehiclePowertrainManagementSystem {\n\n  requirement vehiclePowertrainManagementSystemRequirement {\n    doc \"This system can achieve integrated management of the vehicle powertrain system according to the driver's fuel input command.\"\n    \n    requirement engineStartRequirement {\n      doc \"When the engine start signal is activated, the system first generates the corresponding engine output torque based on the fuel command.\"\n    }\n\n    requirement torqueTransmissionRequirement {\n      doc \"The system amplifies and transmits the torque sequentially through the transmission.\"\n    }\n\n    requirement torqueDistributionRequirement {\n      doc \"The system subsequently distributes the torque to each wheel, thereby achieving effective management and distribution of the vehicle's output power.\"\n    }\n\n    requirement engineShutdownRequirement {\n      doc \"When the engine shutdown signal is triggered, the relevant power output process is terminated.\"\n    }\n\n    requirement performanceRequirement {\n      doc \"This entire process ensures that the vehicle performs automatic control accurately and efficiently in terms of power demand response, torque transmission, and power distribution, thereby enhancing the driving experience and improving energy efficiency.\"\n    }\n  }\n\n  part vehiclePowertrainManagementSystem {\n    perform vehiclePowertrainManagementSystemRequirement\n  }\n\n  part engine {\n    perform engineStartRequirement\n  }\n  \n  part transmission {\n    perform torqueTransmissionRequirement\n  }\n\n  part wheel {\n    perform torqueDistributionRequirement\n  }\n\n  action engineStartAction {\n    doc \"Engine start action\"\n  }\n\n  action engineShutdownAction {\n    doc \"Engine shutdown action\"  \n  }\n\n  stm engineStateMachine {\n    initial engineOff to engineOn on engineStartAction\n    state engineOn {\n      perform engineStartRequirement\n      transition to engineOff on engineShutdownAction\n    }\n    final engineOff {\n      perform engineShutdownRequirement\n    }\n  }\n\n  part fuelInputCommand\n  \n  vehiclePowertrainManagementSystem {\n    connect engine to transmission\n    connect transmission to wheel\n  }\n  \n  satisfy vehiclePowertrainManagementSystemRequirement {\n    by vehiclePowertrainManagementSystem\n  }\n}\n```",
    " ```sysml\npackage VehicleTrailerHitchSystem {\n\n  requirement req Power_Connection_and_Disconnection_Mechanism {\n    doc /* This system is designed to implement a power connection and disconnection mechanism \n           between a vehicle and a trailer. */\n  }\n\n  requirement req Independent_Structural_Frames {\n    doc /* The vehicle and the trailer each possess independent structural frames. */\n  }\n\n  requirement req Hitch_Ball_on_Vehicle_Frame {\n    doc /* A hitch ball is installed on the vehicle frame. */\n  }\n\n  requirement req Trailer_Coupler_on_Trailer_Frame {\n    doc /* A trailer coupler is installed on the trailer frame. */\n  }\n\n  requirement req Connection_States {  \n    doc /* The system enables the vehicle and the trailer to be \"connected\" or \"disconnected\" \n           via the hitching mechanism. */\n  }\n\n  requirement req Safe_and_Reliable_Connection {\n    doc /* The system allows users to safely and reliably connect the trailer to the vehicle \n           when needed. */\n  }\n\n  requirement req Disconnection_Capability {\n    doc /* The system allows users to disengage the trailer from the vehicle when needed. */\n  }\n  \n  requirement req Flexible_Combination_and_Separation {\n    doc /* The system achieves a flexible combination and separation, meeting user requirements\n           for vehicle and trailer power coupling functions in various scenarios. */\n  }\n\n  satisfies Power_Connection_and_Disconnection_Mechanism {\n    Independent_Structural_Frames and \n    Hitch_Ball_on_Vehicle_Frame and\n    Trailer_Coupler_on_Trailer_Frame and\n    Connection_States and \n    Safe_and_Reliable_Connection and\n    Disconnection_Capability and\n    Flexible_Combination_and_Separation\n  }\n\n}\n```",
    " ```sysml\npackage VehicleTrailerConnection {\n\n    requirement req1 {\n        id = \"R1\"\n        text = \"The system shall manage the connection status between a vehicle and a trailer.\"\n    }\n\n    requirement req2 {\n        id = \"R2\"\n        text = \"The system shall include one vehicle and one trailer.\"\n    }\n\n    requirement req3 {\n        id = \"R3\"\n        text = \"The vehicle shall be equipped with a chassis and a tow ball.\"\n    }\n\n    requirement req4 {\n        id = \"R4\"\n        text = \"The trailer shall feature a coupler and a trailer frame.\"\n    }\n\n    requirement req5 {\n        id = \"R5\"\n        text = \"The system shall enable the vehicle to connect to or disconnect from the trailer by means of the tow ball on the vehicle's chassis and the coupler on the trailer's frame.\"\n    }\n\n    requirement req6 {\n        id = \"R6\"\n        text = \"The system shall facilitate the hitching and unhitching operations between the trailer and the vehicle.\"\n    }\n\n    requirement req7 {\n        id = \"R7\"\n        text = \"Users shall be able to conveniently connect or disconnect the trailer via the system.\"\n    }\n\n    requirement req8 {\n        id = \"R8\"\n        text = \"The system shall ensure that the trailer can be safely and reliably coupled to the vehicle when needed.\"\n    }\n\n    requirement req9 {\n        id = \"R9\"\n        text = \"The system shall ensure that the trailer can be smoothly detached from the vehicle when not required.\"\n    }\n\n    requirement req10 {\n        id = \"R10\"\n        text = \"The system shall enhance the convenience and safety of vehicle-trailer combinations.\"\n    }\n\n    part def Vehicle {\n        part def Chassis {}\n        part def TowBall {}\n    }\n\n    part def Trailer {\n        part def Coupler {}\n        part def TrailerFrame {}\n    }\n\n    part def VehicleTrailerConnectionSystem {\n        part vehicle : Vehicle;\n        part trailer : Trailer;\n\n        connection ConnectTrailer {\n            end vehicle.TowBall;\n            end trailer.Coupler;\n        }\n    }\n\n    requirement req1 {\n        satisfiedBy VehicleTrailerConnectionSystem::vehicle, VehicleTrailerConnectionSystem::trailer;\n    }\n\n    requirement req2 {\n        satisfiedBy VehicleTrailerConnectionSystem::vehicle, VehicleTrailerConnectionSystem::trailer;\n    }\n\n    requirement req3 {\n        satisfiedBy Vehicle::Chassis, Vehicle::TowBall;\n    }\n\n    requirement req4 {\n        satisfiedBy Trailer::Coupler, Trailer::TrailerFrame;\n    }\n\n    requirement req5 {\n        satisfiedBy VehicleTrailerConnectionSystem::ConnectTrailer;\n    }\n\n    requirement req6 {\n        satisfiedBy VehicleTrailerConnectionSystem::ConnectTrailer;\n    }\n\n    requirement req7 {\n        satisfiedBy VehicleTrailerConnectionSystem;\n    }\n\n    requirement req8 {\n        satisfiedBy VehicleTrailerConnectionSystem::ConnectTrailer;\n    }\n\n    requirement req9 {\n        satisfiedBy VehicleTrailerConnectionSystem::ConnectTrailer;\n    }\n\n    requirement req10 {\n        satisfiedBy VehicleTrailerConnectionSystem;\n    }\n\n}\n```",
    " ```sysml\npackage TrailerConnectionSystem {\n\n  requirement req VehicleRequirements {\n    requirement VehicleChassisReq {\n      doc \"The vehicle shall have a chassis.\"\n    }\n    requirement TowBallDeviceReq {\n      doc \"The vehicle shall be equipped with a tow ball device.\"\n    }\n  }\n\n  requirement req TrailerRequirements {\n    requirement TrailerChassisReq {\n      doc \"The trailer shall have a chassis.\"\n    }\n    requirement CouplerMechanismReq {\n      doc \"The trailer shall include a coupler mechanism.\"\n    }\n    requirement EngageDisengageReq {\n      doc \"The coupler mechanism shall be able to engage or disengage with the tow ball through its internal structure.\"\n    }\n  }\n\n  requirement req ConnectionRequirements {\n    requirement HitchingReq {\n      doc \"Users shall be able to connect the trailer to the vehicle (hitching operation).\"\n    }\n    requirement UnhitchingReq {\n      doc \"Users shall be able to disconnect the trailer from the vehicle (unhitching operation).\"\n    }\n    requirement SecureConnectionReq {\n      doc \"When connected, the trailer's coupler shall securely latch onto the vehicle's tow ball.\"\n    }\n    requirement SmoothDisconnectionReq {\n      doc \"Disconnection shall allow the vehicle and trailer to separate smoothly.\"\n    }\n  }\n\n  requirement req SystemRequirements {\n    doc \"This system is designed to implement a dynamic connection reference model between a vehicle and a towed trailer.\"\n    \n    include VehicleRequirements\n    include TrailerRequirements \n    include ConnectionRequirements\n\n    requirement SafetyReq {\n      doc \"The system shall achieve safe trailer attachment and detachment functionality.\"\n    }\n    requirement ConvenienceReq {\n      doc \"The system shall achieve convenient trailer attachment and detachment functionality.\"\n    } \n  }\n\n  part def Vehicle {\n    part Chassis\n    part TowBallDevice\n  }\n\n  part def Trailer {\n    part Chassis\n    part CouplerMechanism\n  }\n\n  part def TrailerConnectionSystem {\n    part vehicle: Vehicle\n    part trailer: Trailer\n\n    connector def TrailerConnection {\n      end vehicle.TowBallDevice\n      end trailer.CouplerMechanism\n    }\n  }\n\n}\n```",
    " ```sysml\npackage FuelSystem {\n\n    requirement req1 {\n        description = \"The fuel system shall describe the fuel supply and return process between the fuel tank assembly and the engine.\"\n    }\n\n    requirement req2 {\n        description = \"The fuel tank shall provide fuel to the engine.\"\n    }\n\n    requirement req3 {\n        description = \"The engine shall return a portion of the fuel to the fuel tank.\"\n    }\n\n    requirement req4 {\n        description = \"The fuel system shall monitor key parameters such as temperature to ensure the safety and efficiency of fuel supply.\"\n    }\n\n    requirement req5 {\n        description = \"The fuel system shall support interface connections between different components.\"\n    }\n\n    requirement req6 {\n        description = \"The fuel system shall ensure smooth and well-integrated fuel supply routes.\"\n    }\n\n    requirement req7 {\n        description = \"The fuel system shall meet the requirements for stability and reliability of fuel supply during vehicle operation.\"\n    }\n\n    part def FuelTank {\n        feature def FuelSupplyPort: ~Interface\n    }\n\n    part def Engine {\n        feature def FuelReturnPort: ~Interface\n    }\n\n    part def FuelSystem {\n        part fuelTank: FuelTank\n        part engine: Engine\n\n        connector def fuelSupply: FuelSupplyConnector {\n            end sourcePort: fuelTank.FuelSupplyPort\n            end targetPort: engine.FuelReturnPort\n        }\n\n        connector def fuelReturn: FuelReturnConnector {\n            end sourcePort: engine.FuelReturnPort\n            end targetPort: fuelTank.FuelSupplyPort\n        }\n\n        satisfy req1, req2, req3, req4, req5, req6, req7\n    }\n\n    connection def FuelSupplyConnector\n    connection def FuelReturnConnector\n    \n    interface def Interface\n}\n```",
    " package FuelDeliverySystem {\n\n  requirement FuelDeliveryEfficiency {\n    doc \"This system is designed to provide vehicles with efficient fuel delivery services.\"\n  }\n\n  part FuelStorageTank {\n    doc \"The system includes a storage tank as the initial fuel reservoir, from which fuel is extracted.\"\n  }\n\n  part FuelPump {\n    doc \"Fuel is delivered to vehicles via a fuel pump.\"\n  }\n\n  part VehicleFuelTank {\n    doc \"Inside the vehicle, there is a fuel tank used to receive and store the delivered fuel.\"\n\n    attribute fuelCapacity: Real {\n      doc \"Monitors the maximum capacity of the fuel tank.\"\n    }\n    attribute currentFuelLevel: Real {\n      doc \"Monitors the current fuel level in real-time.\"\n    }\n  }\n\n  part def FuelFlowPath {\n    doc \"The flow path of the fuel is clear and controllable.\"\n\n    attribute fuelSource: ref FuelStorageTank\n    attribute fuelDelivery: ref FuelPump\n    attribute fuelDestination: ref VehicleFuelTank\n  }\n  \n  requirement FuelTransferManagement {\n    doc \"The system focuses on the transfer and quantity changes of fuel at each stage.\"\n  }\n\n  requirement TimelyFuelDelivery {\n    doc \"Ensures that vehicles can obtain the required fuel in a timely manner to meet normal operation needs.\"\n  }\n\n  requirement SafeFuelDelivery {\n    doc \"Ensures that vehicles can obtain the required fuel in a safe manner.\"\n  }\n\n  requirement AccurateFuelDelivery {\n    doc \"Ensures that vehicles can obtain the required fuel in an accurate manner.\"\n  }\n\n}",
    " ```sysml\npackage AutomobileAssembly {\n\n    part def VehicleAssemblyWithoutGearboxAndEngine {\n    }\n\n    part def VehicleAssemblyWithoutEngine {\n        part gearbox: Gearbox;\n    }\n\n    part def VehicleAssembly {\n        part engine: Engine;\n        part gearbox: Gearbox;\n    }\n\n    part def Engine {\n    }\n\n    part def Gearbox {\n    }\n\n    action def InstallGearbox(in vehicleAssemblyWithoutGearboxAndEngine: VehicleAssemblyWithoutGearboxAndEngine, \n                              in gearbox: Gearbox, \n                              out vehicleAssemblyWithoutEngine: VehicleAssemblyWithoutEngine) {\n        vehicleAssemblyWithoutEngine.gearbox = gearbox;\n    }\n\n    action def InstallEngine(in vehicleAssemblyWithoutEngine: VehicleAssemblyWithoutEngine, \n                             in engine: Engine,\n                             out vehicleAssembly: VehicleAssembly) {\n        vehicleAssembly.gearbox = vehicleAssemblyWithoutEngine.gearbox;\n        vehicleAssembly.engine = engine;\n    }\n\n    activity AutomobileAssemblyProcess(\n                in startingAssembly: VehicleAssemblyWithoutGearboxAndEngine,\n                in gearboxToInstall: Gearbox,\n                in engineToInstall: Engine,\n                out finalAssembledVehicle: VehicleAssembly) {\n                                           \n        action installGearbox: InstallGearbox(vehicleAssemblyWithoutGearboxAndEngine: startingAssembly, \n                                              gearbox: gearboxToInstall);\n\n        action installEngine: InstallEngine(vehicleAssemblyWithoutEngine: installGearbox.vehicleAssemblyWithoutEngine,\n                                            engine: engineToInstall,\n                                            vehicleAssembly => finalAssembledVehicle);                                      \n    }\n}\n```",
    " ```sysml\npackage VehicleControlSystem {\n\n  requirement VehicleControlRequirements {\n    id = \"VCS-REQS\"\n    text = \"System requirements for the vehicle control system.\"\n\n    requirement StartupRequirements {\n      id = \"VCS-REQS-1\"\n      text = \"The vehicle shall only transition from Off to Starting state when the brake pedal is pressed and a start signal is received.\"\n    }\n\n    requirement RunningStateRequirements {\n      id = \"VCS-REQS-2\" \n      text = \"Upon entering Running state, the system shall perform self-checks, supply power, and apply parking brake when exiting the state.\"\n    }\n\n    requirement HealthMonitoringRequirements {\n      id = \"VCS-REQS-3\"\n      text = \"The system shall detect and output vehicle temperature in real-time. When temperature exceeds safety threshold, switch to Degraded mode and send over-temperature signal.\"\n    }\n\n    requirement MaintenanceAndDegradedStates {\n      id = \"VCS-REQS-4\" \n      text = \"The system shall support Maintenance and Degraded states, and return to Normal state upon receiving a restore-to-normal signal.\"\n    }\n\n    requirement ControllerStateManagement {\n      id = \"VCS-REQS-5\"\n      text = \"The vehicle controller shall manage its own operation states and switch the vehicle's main control states based on start-up and shut-down signals.\"\n    }\n  }\n\n  statemachine VehicleStates {\n    initialState Off\n    state Off\n    state Starting\n    state Running\n    state Maintenance \n    state Degraded\n\n    transition OffToStarting {\n      from Off\n      to Starting\n      trigger BrakePedalPressed && StartSignalReceived\n    }\n\n    transition StartingToRunning {\n      from Starting\n      to Running\n      trigger VehicleOnSignal\n    }\n\n    transition RunningToMaintenance {\n      from Running\n      to Maintenance\n    }\n\n    transition MaintenanceToNormal {\n      from Maintenance\n      to Running\n      trigger RestoreToNormalSignal  \n    }\n\n    transition RunningToDegraded {\n      from Running\n      to Degraded\n      trigger TemperatureExceededThreshold\n    }\n\n    transition DegradedToNormal {\n      from Degraded \n      to Running\n      trigger RestoreToNormalSignal\n    }\n  }\n\n  part VehicleController {\n    attribute states : ControllerStates\n  }\n\n  statemachine ControllerStates {\n    // Controller states to be defined\n  }\n\n  part Vehicle {\n    attribute states : VehicleStates\n    attribute temperature : Real\n    attribute brakePedalPressed : Boolean\n    attribute powerSupplied : Boolean\n    attribute parkingBrakeApplied : Boolean\n\n    operation selfCheck()\n    operation supplyPower()\n    operation applyParkingBrake()\n  }\n\n}\n```",
    " ```sysml\npackage VehicleSystem {\n\n  requirement AutonomousOperationReq {\n    doc /* The vehicle shall autonomously manage its operation under different conditions */\n    id R1\n  }\n\n  requirement AutonomousHealthReq {\n    doc /* The vehicle shall autonomously manage its health status */\n    id R2\n  }\n\n  requirement StartupReq {\n    doc /* The vehicle shall only initiate startup from shutdown when brake pedal pressed and start signal received */\n    id R3\n  }\n\n  requirement SelfInspectionReq {\n    doc /* The vehicle shall complete self-inspection after meeting startup requirements */\n    id R4\n  }\n\n  requirement PowerSupplyReq {\n    doc /* The vehicle shall complete power supply procedures after meeting startup requirements */\n    id R5\n  }\n\n  requirement TemperatureSensingReq {\n    doc /* The system shall sense temperature in real-time */\n    id R6\n  }\n\n  requirement OverheatWarningReq {\n    doc /* When overheating detected, the system shall send a warning signal to the vehicle controller */\n    id R7\n  }\n\n  requirement DegradedModeReq {\n    doc /* When overheating detected, the system shall switch vehicle status to degraded mode */  \n    id R8\n  }\n\n  requirement OverheatSafetyReq {\n    doc /* When overheating detected, the system shall ensure safety */ \n    id R9\n  }\n\n  requirement MaintenanceReq {\n    doc /* The system shall include regular maintenance mechanisms */ \n    id R10\n  }\n\n  requirement FaultRecoveryReq {\n    doc /* The system shall include fault recovery mechanisms to restore from abnormal to normal states */\n    id R11 \n  }\n\n  requirement SignalProcessingReq {\n    doc /* The vehicle controller shall receive and process control and status signals from the vehicle */\n    id R12\n  }\n\n  requirement AutomaticControlReq {\n    doc /* The vehicle controller shall enable automatic control operations like starting and shutdown */\n    id R13\n  }\n\n  requirement ConfigurationReq {\n    doc /* The system shall support configuration of fuel, maintenance intervals, temperature thresholds */\n    id R14\n  }\n\n  requirement IntelligentManagementReq {\n    doc /* The system shall achieve intelligent, safe, efficient management of vehicle operation */\n    id R15\n  }\n\n  part def Vehicle {\n    satisfiedBy AutonomousOperationReq, AutonomousHealthReq, \n      StartupReq, SelfInspectionReq, PowerSupplyReq,\n      TemperatureSensingReq, OverheatWarningReq, DegradedModeReq, OverheatSafetyReq,\n      MaintenanceReq, FaultRecoveryReq\n  }\n\n  part def VehicleController {\n    satisfiedBy SignalProcessingReq, AutomaticControlReq \n  }\n\n  part def VehicleSystem {\n    satisfiedBy ConfigurationReq, IntelligentManagementReq\n    part vehicle: Vehicle\n    part vehicleController: VehicleController\n  }\n\n}\n```",
    " ```sysml\npackage VehicleDynamicsSimulation {\n\n  requirement req VehicleDynamicsSimulationSystem {\n    doc \"This system is designed for spatiotemporal simulation of the dynamic behavior of vehicles on roads at different moments. Users can define parameters such as the vehicle's mass, position, velocity, and acceleration, and, combined with the road's slope (angle) and surface friction coefficient, depict the state of the vehicle and the road at specific time points. The system supports snapshot recording at multiple moments within the simulation time series, enabling tracking of the vehicle's state transitions from start-up (on state), through the driving process, to shutdown (off state). This provides detailed data to support vehicle dynamics analysis and road adaptability assessment, helping users predict vehicle performance under specific road and time conditions in a virtual environment.\"\n  }\n\n  part def Vehicle {\n    mass: Real\n    position: Coordinate\n    velocity: Velocity  \n    acceleration: Acceleration\n  }\n\n  part def Road {\n    slope: Angle\n    frictionCoefficient: Real  \n  }\n  \n  enum VehicleState {\n    ON,\n    DRIVING, \n    OFF\n  }\n\n  item def Coordinate {\n    x: Real\n    y: Real\n    z: Real\n  }\n  \n  item def Velocity {\n    x: Real\n    y: Real\n    z: Real\n  }\n\n  item def Acceleration {\n    x: Real\n    y: Real\n    z: Real\n  }\n\n  action def SimulateVehicleDynamics(vehicle: Vehicle, road: Road, duration: Duration) {\n    in vehicle: Vehicle\n    in road: Road\n    in duration: Duration\n  }\n  \n  action def RecordSnapshot(vehicle: Vehicle, road: Road, time: Real) {\n    in vehicle: Vehicle\n    in road: Road  \n    in time: Real\n  }\n\n  action def AnalyzeVehicleDynamics(snapshots: Snapshot[*]) {\n    in snapshots: Snapshot[*]\n  }\n\n  action def AssessRoadAdaptability(snapshots: Snapshot[*], road: Road) {\n    in snapshots: Snapshot[*]\n    in road: Road\n  }\n\n  item def Snapshot {\n    vehicle: Vehicle\n    road: Road\n    vehicleState: VehicleState\n    time: Real\n  }\n  \n  part def Simulation {\n    vehicle: Vehicle\n    road: Road \n    duration: Duration\n    snapshots: Snapshot[*]\n\n    simulate: SimulateVehicleDynamics(vehicle, road, duration)\n    record: RecordSnapshot(vehicle, road, time)\n    analyze: AnalyzeVehicleDynamics(snapshots)\n    assess: AssessRoadAdaptability(snapshots, road)\n  }\n}\n```",
    " ```sysml\npackage ConfigurationManagementSystem {\n\n  requirement Vehicle {\n    doc /* The automobile, as the main system, can select different subsystem configurations according to various needs and conditions. */\n    part subsystemA : SubsystemA[1] {\n      doc /* Subsystem A offers two configuration options */\n    }\n    part subsystemB : SubsystemB[1] {\n      doc /* Subsystem B also has two configuration options */\n    }\n    satisfy subsystemConfigurationConstraint\n  }\n\n  requirement SubsystemA {\n    doc /* Subsystem A offers two configuration options: one consisting of Component 1 and Component 2, and the other consisting of Component 2 and Component 3. */\n    part component1 : Component1[0..1]\n    part component2 : Component2[0..1]\n    part component3 : Component3[0..1]\n    variation config1 {\n      component1[1]\n      component2[1]\n    }\n    variation config2 {\n      component2[1]\n      component3[1]  \n    }\n  }\n\n  requirement SubsystemB {\n    doc /* Subsystem B also has two configuration options: one consisting of Component 4 and Component 5, and the other consisting of Component 5 and Component 6. */\n    part component4 : Component4[0..1]\n    part component5 : Component5[0..1]\n    part component6 : Component6[0..1] \n    variation config1 {\n      component4[1]\n      component5[1]\n    }\n    variation config2 {  \n      component5[1]\n      component6[1]\n    }\n  }\n\n  requirement Component1 { }\n  requirement Component2 { }  \n  requirement Component3 { }\n  requirement Component4 { }\n  requirement Component5 { }\n  requirement Component6 { }\n\n  requirement subsystemConfigurationConstraint {\n    doc /* If the second configuration of Subsystem A is selected, then Subsystem B must select the third configuration, or Subsystem A must not be the second configuration. */\n    assert {\n      subsystemA.config2 implies subsystemB.config2\n    }\n  }\n\n  requirement ConfigurationA {\n    doc /* Configuration A adopts the first implementation of Subsystem A (Component 1 and Component 2) together with the third implementation of Subsystem B (Component 4 and Component 5). */\n    refine vehicle : Vehicle {\n      subsystemA.config1\n      subsystemB.config1\n    }\n  }\n\n  requirement ConfigurationB {\n    doc /* Configuration B adopts the second implementation of Subsystem A (Component 2 and Component 3) combined with the third implementation of Subsystem B (Component 4 and Component 5). */\n    refine vehicle : Vehicle {\n      subsystemA.config2\n      subsystemB.config1\n    }\n  }\n\n}\n```",
    " ```sysml\npackage ConfigurableVehiclePlatform {\n\n    abstract part def Subsystem {\n    }\n\n    part def SubsystemA : Subsystem {\n        part part1 : Part1;\n        part part2 : Part2;\n        part part3 : Part3;\n    }\n\n    part def SubsystemB : Subsystem {\n        part part4 : Part4;\n        part part5 : Part5;\n        part part6 : Part6;\n    }\n\n    part def Part1 {\n    }\n\n    part def Part2 {\n    }\n\n    part def Part3 {\n        port p1 : ~Transmission;\n    }\n    \n    part def Part4 {\n    }\n    \n    part def Part5 {\n        port p2 : ~Transmission;\n        variant behVariant1 : Part5Behavior1;\n        variant behVariant2 : Part5Behavior2;\n    }\n    \n    part def Part6 {\n    }\n\n    abstract requirement def SubsystemConstraint {\n    }\n\n    requirement def SubsystemAConstraint : SubsystemConstraint {\n    }\n\n    requirement def SubsystemBConstraint : SubsystemConstraint {\n    }\n\n    abstract requirement def ConfigurationConstraint {\n    }\n\n    requirement def VehicleConfigAConstraint : ConfigurationConstraint {\n    }\n\n    requirement def VehicleConfigBConstraint : ConfigurationConstraint {\n    }\n\n    abstract configuration def VehicleConfiguration {\n    }\n\n    configuration def VehicleConfigA : VehicleConfiguration {\n        part subsystemA : SubsystemA;\n        part subsystemB : SubsystemB;\n        \n        connector c1 : AssemblyConnector;\n        \n        connection binding subsystemA.part3.p1 -> c1 -> subsystemB.part5.p2;\n\n        constraint VehicleConfigAConstraint;\n    }\n\n    configuration def VehicleConfigB : VehicleConfiguration {\n        part subsystemA : SubsystemA;\n        part subsystemB : SubsystemB {\n            property part4Quant : Integer = 2;\n            part part4 : Part4 [part4Quant];\n        }\n        \n        connector c2 : AssemblyConnector;\n        \n        connection binding subsystemA.part2 -> c2 -> subsystemB.part4;\n\n        constraint VehicleConfigBConstraint;\n    }\n\n    abstract action def Part5Behavior {\n    }\n\n    action def Part5Behavior1 : Part5Behavior {\n    }\n\n    action def Part5Behavior2 : Part5Behavior {\n    }\n\n    connector def Transmission {\n    }\n    \n    connector def AssemblyConnector : Transmission {\n    }\n}\n```",
    " package VehicleConfigurationSystem {\n  \n  requirement Flexible_ProductLine_Configuration {\n    description \"Provide flexible solutions for vehicle product line configuration, capable of automatically matching suitable combinations of engines, transmissions, and wheels based on different performance requirements and user preferences.\"\n  }\n  \n  abstract requirement Performance_Requirement {}\n  \n  requirement High_Performance extends Performance_Requirement {\n    description \"When high performance is required, the system will configure a 6-cylinder engine, automatic transmission, and wide-rim wheels, ensuring compatibility among these components.\"\n  }\n  \n  requirement Standard_Performance extends Performance_Requirement {\n    description \"For standard performance requirements, a combination of a 4-cylinder engine, manual transmission, and narrow-rim wheels is offered.\"\n  }\n  \n  requirement Enforce_Configuration_Constraints {\n    description \"The system enforces a series of configuration constraints to ensure that each configuration scheme meets vehicle performance and component compatibility requirements, preventing unreasonable combinations.\"\n  }\n  \n  requirement Customized_Vehicles {\n    description \"Enable customized vehicles tailored to individual user needs.\"\n  }\n  \n  requirement Multiple_Vehicle_Model_Variants {\n    description \"The system supports the selection of multiple vehicle model variants, allowing enterprises to quickly respond to market demands and achieve flexible expansion and management of their product lines.\"\n  }\n  \n  part def Engine {}\n  part def Transmission {}\n  part def Wheel {}\n  \n  part def Six_Cylinder_Engine extends Engine {}\n  part def Four_Cylinder_Engine extends Engine {}\n  \n  part def Automatic_Transmission extends Transmission {}\n  part def Manual_Transmission extends Transmission {}\n  \n  part def Wide_Rim_Wheel extends Wheel {}\n  part def Narrow_Rim_Wheel extends Wheel {}\n  \n  abstract part def Vehicle {\n    part eng: Engine;\n    part trans: Transmission; \n    part whl: Wheel;\n  }\n  \n  part def High_Performance_Vehicle extends Vehicle {\n    part eng: Six_Cylinder_Engine;\n    part trans: Automatic_Transmission;\n    part whl: Wide_Rim_Wheel;  \n  }\n  \n  part def Standard_Performance_Vehicle extends Vehicle {\n    part eng: Four_Cylinder_Engine;\n    part trans: Manual_Transmission; \n    part whl: Narrow_Rim_Wheel;\n  }\n  \n  abstract part def Vehicle_Model_Variant {\n    part vehicle: Vehicle;  \n  }\n  \n}",
    " ```sysml\npackage VehicleSpecifications {\n\n    requirement vehicle {\n        doc /* This system is intended to define and manage the primary specifications \n        and performance requirements related to automobiles, covering aspects such as \n        vehicle mass, fuel status, powertrain, and reliability. */\n\n        requirement mass {\n            doc /* The system must support the definition and management of vehicles \n            with different mass grades (such as 2000 kg and 2500 kg). Each vehicle \n            should reflect its actual mass and comply with the corresponding maximum \n            mass limitations to prevent overloading. */\n        }\n\n        requirement fuelStatus {\n            doc /* The system must also regulate fuel status, such as requiring some \n            vehicles to meet mass requirements when fully fueled, while others are \n            accepted in an empty-fuel state. */  \n        }\n\n        requirement powertrain {\n            doc /* In terms of the powertrain, vehicles must have power delivery \n            functionality, requiring the engine to output torque and be effectively \n            connected to the transmission via a drive interface to ensure reliable \n            power transfer. */\n\n            part def engine {\n                requirement outputTorque;\n            }\n\n            part def transmission;\n\n            part def driveInterface {\n                connector def engineToTransmission {\n                    connect engine to transmission;\n                }\n            }\n        }\n        \n        requirement reliability {\n            doc /* For specific models, requirements also include tracking and \n            fulfilling reliability, ensuring that vehicles possess specified \n            performance and durability throughout their lifecycle. */\n        }\n    }\n\n    comment /* The entire system is structured to define vehicles, engines, \n    transmissions, and their key interfaces, and decomposes, allocates, and \n    validates each requirement. This supports standardized management and \n    quality control of vehicles throughout the processes of design, testing, \n    and practical application. */\n\n}\n```",
    " ```sysml\npackage VehicleMassComplianceVerificationSystem {\n\n  requirement vehicle_mass_compliance {\n    doc /* This system is designed to verify vehicle mass compliance to ensure that \n           the actual mass of the tested vehicles does not exceed the specified \n           maximum permissible mass. */\n  }\n  \n  requirement measure_actual_vehicle_mass {\n    doc /* Each participating vehicle must have its actual mass measured using \n           weighing equipment operated by a test operator. */\n    satisfy vehicle_mass_compliance\n  }\n  \n  requirement compare_measured_mass_to_limit {\n    doc /* The system then compares the measured mass with the required value \n           (e.g., a maximum permissible mass of 2,500 kilograms). */\n    satisfy vehicle_mass_compliance\n  }\n  \n  requirement determine_compliance {  \n    doc /* If the vehicle's actual mass is less than or equal to the strictly \n           defined upper limit, it is considered compliant; otherwise, it is \n           deemed non-compliant. */\n    satisfy vehicle_mass_compliance\n  }\n  \n  requirement support_sequential_testing {\n    doc /* The system supports sequential testing and result determination for \n           multiple vehicles, providing a reliable and automated solution for \n           compliance management of vehicle-related product quality. */\n    satisfy vehicle_mass_compliance\n  }\n  \n  part VehicleUnderTest\n  \n  part WeighingEquipment {\n    perform measure_actual_vehicle_mass\n  }\n  \n  part TestOperator {\n    perform measure_actual_vehicle_mass\n  }\n  \n  part ComplianceManagementSystem {\n    perform compare_measured_mass_to_limit, \n           determine_compliance,\n           support_sequential_testing \n  }\n  \n  valuetype Mass {\n    unit kg\n  }\n  \n  valuetype VehicleMassLimit {\n    value maxPermissibleMass = 2500 : Mass\n  }\n\n}\n```",
    " ```sysml\npackage WaterSupply {\n\n  requirement WaterSupplyReq {\n    doc \"This system is designed to implement a water supply network that delivers hot and cold water from a main supply pipe (SpigotBank) through corresponding interfaces (Spigot) to one or more faucets (Faucet). Each faucet is equipped with hot and cold water inlets (FaucetInlet). The system is required to reliably deliver hot and cold water from the respective outlets of the main supply pipe to the corresponding inlets of all downstream faucets, ensuring simultaneous supply to multiple water usage points. Additionally, the system must guarantee correct connection and smooth transmission of the hot and cold water pipelines, thereby meeting the basic requirements for distributed hot and cold water supply in various settings.\"\n  }\n\n  system WaterSupplySystem {\n    satisfies WaterSupplyReq\n    \n    part def spigotBank : SpigotBank [1]\n    part def faucets : Faucet [1..*]\n\n    conn def hotWaterConn : HotWater\n    conn def coldWaterConn : ColdWater\n  }\n\n  part def SpigotBank {\n    port def hotWaterOut : Spigot [1]\n    port def coldWaterOut : Spigot [1]\n  }\n\n  part def Faucet {\n    port def hotWaterIn : FaucetInlet [1]\n    port def coldWaterIn : FaucetInlet [1]\n  }\n\n  conn def HotWater {\n    end def hotSource : Spigot [1]\n    end def hotDestination : FaucetInlet [1..*]\n  }\n\n  conn def ColdWater {\n    end def coldSource : Spigot [1]  \n    end def coldDestination : FaucetInlet [1..*]\n  }\n\n  iface def Spigot\n  iface def FaucetInlet\n\n  part WaterSupplySystem.spigotBank {\n    hotWaterOut -> hotSource\n    coldWaterOut -> coldSource\n  }\n\n  conn WaterSupplySystem.hotWaterConn {\n    hotSource -> spigotBank.hotWaterOut  \n    hotDestination -> faucets.hotWaterIn\n  }\n\n  conn WaterSupplySystem.coldWaterConn {\n    coldSource -> spigotBank.coldWaterOut\n    coldDestination -> faucets.coldWaterIn  \n  }\n\n}\n```",
    " ```sysml\npackage VehicleQualityAnalysisSystem {\n\n  requirement VehicleAnalysis {\n    doc /* This system is designed to model and analyze the quality attributes of vehicles, \n           enabling effective management of both the entire vehicle and its key components \n           (including the engine, transmission, front axle assembly, and rear axle assembly). */\n  }\n\n  requirement QualityDataInput {\n    doc /* Users can input quality data for each component */\n  }\n\n  requirement TotalMassCalculation {\n    doc /* The system will automatically aggregate and calculate the total mass of the vehicle, \n           providing a data foundation for quality analysis. */\n  }\n\n  requirement QualityAnalysisRequirements {\n    doc /* The system also supports the definition of quality analysis requirements \n           and the formulation of analysis use cases. */\n  }\n\n  requirement AnalysisTaskGeneration {\n    doc /* Based on set analysis objectives, it can automatically generate analysis tasks and plans, \n           achieving comprehensive evaluation and requirements tracking for vehicle quality. */\n  }\n\n  requirement DesignOptimizationSupport {\n    doc /* Ultimately, the system provides scientific support for vehicle design and performance optimization, \n           improving overall development efficiency and product performance. */\n  }\n\n  part def Vehicle {\n    part engine: Engine;\n    part transmission: Transmission;\n    part frontAxle: FrontAxleAssembly;\n    part rearAxle: RearAxleAssembly;\n  }\n\n  part def Engine;\n  part def Transmission;\n  part def FrontAxleAssembly;\n  part def RearAxleAssembly;\n\n  abstract requirement QualityAttribute;\n\n  requirement Mass specializes QualityAttribute;\n\n  use case PerformQualityAnalysis {\n    doc /* Perform comprehensive quality analysis on the vehicle and its components */\n  }\n\n  use case InputQualityData {\n    doc /* Input quality data for vehicle components */\n  }\n\n  use case CalculateTotalMass {\n    doc /* Calculate the total mass of the vehicle */\n  }\n\n  use case DefineQualityRequirements {\n    doc /* Define quality analysis requirements */\n  }\n\n  use case GenerateAnalysisTasks {\n    doc /* Generate analysis tasks and plans based on objectives */\n  }\n  \n  PerformQualityAnalysis includes InputQualityData;\n  PerformQualityAnalysis includes CalculateTotalMass; \n  PerformQualityAnalysis includes DefineQualityRequirements;\n  PerformQualityAnalysis includes GenerateAnalysisTasks;\n\n  Vehicle satisfies VehicleAnalysis;\n  InputQualityData satisfies QualityDataInput;\n  CalculateTotalMass satisfies TotalMassCalculation;  \n  DefineQualityRequirements satisfies QualityAnalysisRequirements;\n  GenerateAnalysisTasks satisfies AnalysisTaskGeneration;\n  PerformQualityAnalysis satisfies DesignOptimizationSupport;\n\n}\n```",
    " ```sysml\npackage VehiclePowertrainOptimization {\n\n  requirement VehiclePowertrainOptimization {\n    doc \"This system aims to provide optimal solutions for vehicle powertrain configuration, focusing primarily on the trade-off analysis of engine types to select the engine configuration that performs best across multiple key performance indicators, including power, mass, efficiency, reliability, and cost.\"\n  }\n\n  requirement EngineStructureModeling {\n    doc \"The system supports modeling of various engine structures (such as four-cylinder engines, six-cylinder engines, etc.).\"\n  }\n\n  requirement ComponentAssembly {\n    doc \"The system is capable of automatically assembling related components, including cylinders, pistons, connecting rods, and crankshafts.\"\n  }\n\n  requirement TradeOffAnalysis {\n    doc \"A multi-attribute trade-off analysis method is used, and, through a pre-defined evaluation model, the system comprehensively assesses the performance data of different engine schemes.\"\n  }\n\n  requirement OptimalEngineSolution {\n    doc \"Based on the evaluation results, the system automatically recommends the optimal engine solution, ensuring the best balance between vehicle performance and economy.\"\n  }\n\n  requirement DecisionTransparency {\n    doc \"The system allows users to view explanations on the rationality of the engine selection, ensuring decision transparency and traceability.\"\n  }\n\n  part Engine {\n    part Cylinder;\n    part Piston; \n    part ConnectingRod;\n    part Crankshaft;\n  }\n\n  part FourCylinderEngine : Engine;\n  part SixCylinderEngine : Engine;\n\n  attribute power : Real;\n  attribute mass : Real;\n  attribute efficiency : Real;\n  attribute reliability : Real; \n  attribute cost : Real;\n\n  performanceMetrics : PerformanceMetrics {\n    attributes {power, mass, efficiency, reliability, cost};\n  }\n\n  evaluationModel : EvaluationModel;\n\n  action TradeOffAnalysis {\n    in engineSchemes : Engine[*];\n    out optimalSolution : Engine;\n    out decisionExplanation : String;\n  }\n\n  TransparentDecisionMaking : TransparentDecisionMaking {\n    actions {TradeOffAnalysis};\n  }\n\n}\n```",
    " ```sysml\npackage VehicleFuelEconomy {\n\n  requirement VehicleFuelEconomyRequirements {\n    doc \"This system is designed to ensure that vehicle fuel economy meets relevant regulatory and performance requirements.\"\n\n    requirement UrbanFuelEconomy {\n      doc \"Under urban driving conditions, the vehicle's range per gallon must not be less than 25 miles.\"\n\n      milePerGallon: Real = 25.0\n      gallon = \"US customary gallon (231 cubic inches)\"\n    }\n\n    requirement HighwayFuelEconomy {\n      doc \"Under highway conditions, the vehicle's range per gallon must not be less than 30 miles.\"\n\n      milePerGallon: Real = 30.0\n      gallon = \"US customary gallon (231 cubic inches)\"\n    }\n    \n    requirement FuelEconomyMeasurement {\n      doc \"Fuel economy is measured in 'miles per gallon', based on the US customary gallon (231 cubic inches). Fuel economy tests are conducted with the vehicle assuming an additional load of 1,000 pounds, under standard urban and highway driving scenarios respectively.\"\n      \n      additionalLoad = 1000 \"pounds\"\n      urbanScenario: Scenario\n      highwayScenario: Scenario\n    }\n    \n    requirement TargetAchievement {\n      doc \"The measured fuel economy must meet the minimum requirements stated above. The system models and analyzes key parameters such as vehicle powertrain, load, and operating conditions, supporting fuel consumption assessment under various conditions to ensure that the designed vehicle can achieve the regulatory fuel economy targets for both urban and highway scenarios.\"\n    \n      vehiclePowertrain: Item\n      operatingConditions: OperatingConditions\n    }\n  }\n  \n  item Vehicle {}\n   \n  scenario Scenario {}\n\n  item OperatingConditions {}\n    \n}\n```",
    " ```sysml\npackage VehicleDynamicsSimulator {\n\n  requirement def 'Purpose' {\n    doc /* \n      This system is designed to simulate and analyze the \n      longitudinal (straight-line) dynamic characteristics \n      of vehicle motion. \n    */\n  }\n\n  requirement def 'Input Parameters' {\n    doc /* \n      Users can input vehicle mass parameters, initial position, \n      initial velocity, and a set of segmented power output data.\n    */\n  }\n\n  requirement def 'Calculation Approach' {\n    doc /* \n      Based on the input power and operating conditions, the system \n      will successively calculate the vehicle's acceleration, \n      velocity, and position at each moment using dynamic equations \n      with a specified time step.\n    */\n  }\n\n  requirement def 'Output Results' {\n    doc /* \n      It will then output the sequences of acceleration, velocity \n      variation, and displacement throughout the vehicle's entire \n      motion process.\n    */\n  }\n\n  requirement def 'Applications' {\n    doc /* \n      This provides data support and a decision-making basis for \n      applications such as vehicle performance analysis, control \n      strategy development, and driving behavior evaluation.\n    */\n  }\n\n  part def Simulator {\n    part def InputProcessor {\n      attribute mass: Real;\n      attribute initialPosition: Real;\n      attribute initialVelocity: Real;\n      attribute powerProfile: Sequence<Real>;\n    }\n\n    part def DynamicsCalculator {\n      attribute acceleration: Sequence<Real>;  \n      attribute velocity: Sequence<Real>;\n      attribute position: Sequence<Real>;\n\n      action runSimulation(timeStep: Duration, endTime: Duration) {\n        // Iteratively calculate acceleration, velocity and position \n        // at each time step using input parameters and dynamic equations\n      }\n    }\n\n    part def OutputGenerator {\n      action generateReport() {\n        // Output the calculated acceleration, velocity and position sequences\n      }\n    }\n  }\n\n  part def User {\n    action specifyInputs() {\n      // User provides mass, initial conditions and power profile\n    }\n\n    action analyzeResults() {\n      // User reviews the simulation outputs for analysis and decision making \n    }\n  }\n\n  part def Application {\n    // Could be expanded to model specific applications like\n    // performance analysis, control development, driver evaluation\n  }\n\n  User -> Simulator.InputProcessor: specifyInputs;\n  Simulator.InputProcessor -> Simulator.DynamicsCalculator: mass, initialPosition, initialVelocity, powerProfile;\n  Simulator.DynamicsCalculator -> Simulator.OutputGenerator: acceleration, velocity, position;\n  Simulator.OutputGenerator -> User: generateReport;\n  User -> Application: analyzeResults;\n}\n```",
    " ```sysml\npackage VehicleSystem {\n\n  // Define the vehicle as a system block\n  system Vehicle {\n    mass: Real kg = 2500\n    part structure frontAxleAssembly: FrontAxleAssembly\n    part structure rearAxleAssembly: RearAxleAssembly\n  }\n\n  // Define the front axle assembly block\n  system FrontAxleAssembly {\n    mass: Real kg = 150\n    part frontAxle: FrontAxle\n    part frontWheel1: Wheel\n    part frontWheel2: Wheel\n  }\n\n  // Define the front axle block  \n  system FrontAxle {\n    mass: Real kg\n    steeringAngle: Real rad\n  }\n\n  // Define the rear axle assembly block\n  system RearAxleAssembly {\n    mass: Real kg = 250  \n    part rearAxle: RearAxle\n    part rearWheel1: Wheel\n    part rearWheel2: Wheel\n  }\n\n  // Define the rear axle block\n  system RearAxle {\n    mass: Real kg\n  }\n\n  // Define a generic wheel block\n  system Wheel {\n  }\n\n  // Define the part relationships\n  part def vehicleStructure {\n    FrontAxleAssembly_vehicleStructure: Vehicle.frontAxleAssembly\n    RearAxleAssembly_vehicleStructure: Vehicle.rearAxleAssembly\n\n    FrontAxle_frontAxleAssembly: FrontAxleAssembly.frontAxle\n    FrontWheel1_frontAxleAssembly: FrontAxleAssembly.frontWheel1\n    FrontWheel2_frontAxleAssembly: FrontAxleAssembly.frontWheel2\n\n    RearAxle_rearAxleAssembly: RearAxleAssembly.rearAxle \n    RearWheel1_rearAxleAssembly: RearAxleAssembly.rearWheel1\n    RearWheel2_rearAxleAssembly: RearAxleAssembly.rearWheel2\n  }\n\n}\n```",
    " ```sysml\npackage SafetyAndSecuritySystem {\n\n  requirement VehicleSafetyAndSecuritySystem {\n    doc /* This system is designed to manage and display vehicle safety and security-related\n           features and components, ensuring that users can intuitively understand the safety \n           and security configurations of the entire vehicle and its constituent parts. */\n\n    requirement ManageSafetyComponents {\n      doc /* The vehicle includes safety components such as seat belts, airbags, and bumpers. */\n    }\n\n    requirement ManageSecurityDevices {\n      doc /* The vehicle is equipped with security devices such as alarms and keyless entry systems. */\n    }\n\n    requirement FilterAndOrganizeComponents {\n      doc /* The system is capable of filtering and organizing all vehicle-related components \n             based on safety or security features. */\n    }\n\n    requirement VisualizeComponentHierarchy {\n      doc /* The system can visualize the safety and security components in forms such as\n             tree structures or tables. */\n    }\n\n    requirement IdentifyMandatoryComponents {\n      doc /* Among the safety components, seat belts and bumpers are mandatory features. */\n    }\n\n    requirement IdentifyOptionalComponents {\n      doc /* Airbags and anti-lock braking systems are optional safety features. */\n    }\n\n    requirement EnableUserReview {\n      doc /* This enables end users to quickly review the safety configurations of the whole\n             vehicle and its sub-systems, clearly distinguishing between mandatory and \n             non-mandatory safety functions. */\n    }\n\n    requirement AchieveComprehensiveManagement {\n      doc /* The system achieves comprehensive management and transparent display of the\n             vehicle's safety and security features. */\n    }\n  }\n\n  part def SafetyComponent {\n    doc /* An abstract part representing vehicle safety components */\n  }\n\n  part def SeatBelt specializes SafetyComponent {\n    doc /* A mandatory safety component */\n  }\n\n  part def Airbag specializes SafetyComponent {\n    doc /* An optional safety component */  \n  }\n\n  part def Bumper specializes SafetyComponent {\n    doc /* A mandatory safety component */\n  }\n\n  part def AntilockBrakes specializes SafetyComponent {\n    doc /* An optional safety component */\n  }\n\n  part def SecurityDevice {\n    doc /* An abstract part representing vehicle security devices */  \n  }\n\n  part def Alarm specializes SecurityDevice { }\n\n  part def KeylessEntry specializes SecurityDevice { }\n\n}\n```",
    " ```sysml\npackage system {\n\n  abstract requirement architectureRequirements {\n    doc /* This system adopts a layered architecture, including the application layer, \n            service layer, and data layer. The application layer needs to use the \n            functionalities provided by the service layer, while the service layer \n            relies on the data layer to retrieve and store data. */\n  }\n  \n  requirement attributeRequirements {\n    doc /* The system should possess three core attributes: x, y, and z, \n            where attribute z depends on attributes x and y. */\n  }\n\n  requirement responsibilitiesAndDependenciesRequirement {\n    doc /* The entire system must ensure clear division of responsibilities and \n            dependencies between layers, guaranteeing smooth data flow and \n            functional calls. */\n  }\n\n  abstract part System {\n    abstract part applicationLayer {\n      doc /* The application layer needs to use the functionalities provided by \n              the service layer. */\n    }\n    \n    abstract part serviceLayer {\n      doc /* The service layer relies on the data layer to retrieve and store data. */\n    }\n    \n    abstract part dataLayer {\n    }\n\n    part x {\n    }\n\n    part y {\n    }\n\n    part z {\n      dependency on x, y;\n    }\n  }\n\n  satisfy architectureRequirements -> System::applicationLayer, \n                                      System::serviceLayer, \n                                      System::dataLayer;\n\n  satisfy attributeRequirements -> System::x, System::y, System::z;\n  \n  satisfy responsibilitiesAndDependenciesRequirement -> System;\n}\n```",
    " ```sysml\npackage TorqueGenerationSystem {\n\n    requirement TorqueGeneration {\n        description \"This system is designed to realize the torque generation function within the powertrain system.\"\n    }\n\n    requirement RelevantComponents {\n        description \"The system should include relevant components capable of generating torque.\"\n    }\n\n    requirement TorqueGreaterThanZero {\n        description \"It is required that the torque produced during operation must be greater than zero newton-meters to ensure driving capability.\"\n    }\n\n    requirement AllocationToPhysicalLayer {\n        description \"During the design and implementation process, the logic layer's torque generator function should be effectively allocated and mapped to the physical layer of the powertrain (including actual components such as the engine), thereby ensuring the actual generation and transmission of torque to meet the overall vehicle power output requirements.\"\n    }\n\n    part PowertrainSystem {\n        part TorqueGenerator {\n            satisfy TorqueGeneration, RelevantComponents, TorqueGreaterThanZero\n        }\n        part Engine {}\n    }\n\n    satisfy {\n        TorqueGenerator satisfies TorqueGeneration, RelevantComponents, TorqueGreaterThanZero;\n        AllocationToPhysicalLayer satisfiedBy allocation a1;\n    }\n\n    allocation a1 {\n        from TorqueGenerator;\n        to Engine;\n    }\n\n    value torque {\n        unit \"N*m\"\n    }\n\n    constraint TorqueConstraint {\n        description \"Torque must be greater than zero.\"\n        assert torque > 0 \"N*m\"\n    }\n\n    requirement OverallPowerOutput {\n        description \"The torque generation should meet the overall vehicle power output requirements.\"\n    }\n\n    satisfy {\n        OverallPowerOutput satisfiedBy TorqueGenerator.torque;\n    }\n}\n```",
    " ```sysml\npackage PowertrainSystem {\n\n  requirement Req_PowerTransmission {\n    doc \"The system must be capable of transmitting and outputting power.\"\n  }\n\n  requirement Req_PowerProvision {\n    doc \"The system logically should have the ability to provide power as well as generate torque.\"\n  }\n\n  requirement Req_TorqueGenerator {\n    doc \"The system should include a torque generator component responsible for generating torque.\"\n  }\n\n  requirement Req_Powertrain {\n    doc \"At the physical level, the system must include a powertrain.\"\n  }\n\n  requirement Req_Engine {\n    doc \"The powertrain should contain an engine responsible for the actual execution of torque generation.\"\n  }\n\n  requirement Req_FunctionAllocation {\n    doc \"The function of the system's torque generator should be able to be mapped and implemented onto the engine within the powertrain, achieving effective correspondence and allocation between logical functions and physical implementation.\"\n  }\n\n  function TorqueGeneration() {\n    out torque: Torque;\n  }\n\n  part TorqueGenerator {\n    perform TorqueGeneration;\n  }\n\n  part Powertrain {\n    part Engine {\n      perform TorqueGeneration;\n    }\n  }\n\n  satisfy {\n    TorqueGenerator satisfies Req_TorqueGenerator;\n    TorqueGeneration allocated to Engine;\n  }\n\n  satisfy {\n    Powertrain satisfies Req_Powertrain;\n    Engine satisfies Req_Engine;\n  }\n  \n  satisfy {\n    Powertrain, TorqueGenerator satisfies Req_PowerTransmission, Req_PowerProvision, Req_FunctionAllocation; \n  }\n\n}\n```",
    " ```sysml\npackage VehicleSafetyAndAntiTheft {\n\n    requirement catalogue VehicleSafetyAndAntiTheftFunctionCatalogue {\n        doc \"This Vehicle Safety and Anti-theft Function Catalogue is intended to standardize the basic configuration requirements for key vehicle components in terms of safety and anti-theft performance.\"\n\n        requirement SafetyFeatures {\n            doc \"The vehicle must be equipped with safety features.\"\n            requirement BasicSafetyComponents {\n                doc \"At a minimum, basic safety components such as front seat belts and bumpers must be installed on the body and interior to ensure the fundamental personal safety of occupants.\"\n            }\n            requirement OptionalSafetyComponents {\n                doc \"Certain components, such as the driver's airbag and anti-lock braking system, are characterized as safety features but may or may not be mandatory depending on specific configurations.\"\n            }\n        }\n\n        requirement SecurityFeatures {\n            doc \"The vehicle should also be equipped with security components such as an alarm system and a keyless entry system, so as to enhance the overall security and protective capability of the vehicle.\"\n        }\n\n        requirement CatalogueDistinctions {\n            doc \"The catalogue distinguishes and describes all components that affect safety, all components that affect anti-theft, components that affect both safety and anti-theft, as well as all mandatory safety components, in order to meet regulatory requirements and users' needs for the most basic safety and protection functions of the vehicle.\"\n        }\n\n    }\n\n}\n```",
    " ```sysml\npackage FuelManagementSystem {\n\n  requirement req FuelManagementSystemRequirements {\n    id = \"FMS-001\"\n    text = \"This system is designed to provide complete fuel supply and return management functions for vehicles.\"\n  }\n\n  requirement req FuelTankAssemblyRequirements {\n    id = \"FTA-001\"\n    text = \"The vehicle is equipped with a fuel system composed of a fuel tank assembly, which integrates both the fuel pump and the fuel tank.\"\n  }\n\n  requirement req FuelPumpRequirements {\n    id = \"FP-001\"\n    text = \"The fuel pump is responsible for pressurizing fuel from the tank and delivering it to various fuel-consuming units within the vehicle, while allowing unused fuel to return to the tank via the return line.\"\n  }\n\n  requirement req FuelTemperatureMonitoringRequirements {\n    id = \"FTM-001\"\n    text = \"The system must monitor and transmit real-time fuel temperature information to ensure the safety and efficiency of fuel transport.\"\n  }\n\n  requirement req FuelFlowPathRequirements {\n    id = \"FFP-001\"\n    text = \"The overall fuel flow path and interface definitions are clearly specified, and both data and fuel flow between components are strictly bound according to the design, thereby achieving reliable fuel supply and effective return management.\"\n  }\n\n  part def FuelManagementSystem {\n    part fuelTankAssembly: FuelTankAssembly\n    part fuelPump: FuelPump\n    part fuelTemperatureSensor: FuelTemperatureSensor\n\n    fuelTankAssembly.fuelPump = fuelPump\n    fuelTankAssembly.fuelTemperatureSensor = fuelTemperatureSensor\n  }\n\n  part def FuelTankAssembly {\n    part tank: FuelTank\n    part fuelPump: FuelPump\n    part fuelTemperatureSensor: FuelTemperatureSensor\n  }\n\n  part def FuelPump {\n    port fuelIn: in Fuel\n    port fuelOut: out Fuel\n  }\n\n  part def FuelTank {\n    port fuelReturn: in Fuel\n  }\n\n  part def FuelTemperatureSensor {\n    port fuelTemperature: out Temperature\n  }\n\n  interface def Fuel\n  interface def Temperature\n\n  satisfy (FuelManagementSystem, FuelManagementSystemRequirements)\n  satisfy (FuelTankAssembly, FuelTankAssemblyRequirements)\n  satisfy (FuelPump, FuelPumpRequirements)  \n  satisfy (FuelTemperatureSensor, FuelTemperatureMonitoringRequirements)\n  satisfy (FuelManagementSystem, FuelFlowPathRequirements)\n\n}\n```",
    " ```sysml\npackage VehicleSafetyAndSecurityCompliance {\n\n  requirement VehicleInteriorSafetyRequirement {\n    doc \"The vehicle interior must be equipped with two seat belts, which are mandatory safety features.\"\n  }\n\n  requirement VehicleInteriorSecurityRequirement {\n    doc \"An anti-theft alarm device should be installed inside the vehicle to enhance security protection.\"\n  }\n\n  requirement OptionalVehicleInteriorSafetyRequirement {\n    doc \"An airbag should also be installed in the cockpit, but its application is not mandatory.\"\n  }\n\n  requirement VehicleBodySafetyRequirement {\n    doc \"The vehicle body must be equipped with a bumper, which is a required safety component.\"\n  }\n\n  requirement VehicleBodySecurityRequirement {\n    doc \"The vehicle body is also required to have a keyless entry system to improve security performance.\"\n  }\n\n  requirement VehicleChassisSafetyRequirement {\n    doc \"The chassis structure is to be fitted with two wheels.\"\n  }\n\n  requirement OptionalVehicleChassisSafetyRequirement {\n    doc \"The chassis structure is to be equipped with two sets of anti-lock braking systems, although the installation of such braking systems is not mandatory.\"\n  }\n\n  requirement ComplianceManagementRequirement {\n    doc \"All the aforementioned components related to safety and security are subject to identification and classification management by the system to ensure compliance with regulations regarding critical safety and security functions, thereby enhancing the vehicle's overall safety and security features.\"\n  }\n\n  satisfy VehicleInteriorSafetyRequirement, VehicleBodySafetyRequirement, VehicleChassisSafetyRequirement;\n  satisfy VehicleInteriorSecurityRequirement, VehicleBodySecurityRequirement;\n  satisfy if implemented OptionalVehicleInteriorSafetyRequirement, OptionalVehicleChassisSafetyRequirement;\n  satisfy ComplianceManagementRequirement;\n\n}\n```",
    " ```sysml\npackage VehicleSafetyAndSecurity {\n\n    part def VehicleSafetyAndSecuritySystem {\n        part def Interior {\n            part def AlarmSystem { }\n            part def SeatBelts { }\n            part def FrontRowSeats { }\n            part def DriverAirbag { }\n        }\n        \n        part def BodyAssembly {\n            part def VehicleBody { }\n            part def Bumper { }\n            part def KeylessEntrySystem { }\n        }\n    }\n\n    requirement def EnhanceProtectionDuringDriving {\n        satisfied by VehicleSafetyAndSecuritySystem::Interior::SeatBelts, \n                     VehicleSafetyAndSecuritySystem::Interior::DriverAirbag,\n                     VehicleSafetyAndSecuritySystem::BodyAssembly::Bumper\n    }\n\n    requirement def ProvideAntiTheftSupport {\n        satisfied by VehicleSafetyAndSecuritySystem::Interior::AlarmSystem\n    }\n\n    requirement def ProvideConvenientAccess {\n        satisfied by VehicleSafetyAndSecuritySystem::BodyAssembly::KeylessEntrySystem  \n    }\n\n    requirement def IntegrateSafetyAndSecurityFunctions {\n        composed of EnhanceProtectionDuringDriving, \n                    ProvideAntiTheftSupport,\n                    ProvideConvenientAccess\n    }\n\n    requirement def OfferComprehensiveSafetyProtection {\n        satisfied by IntegrateSafetyAndSecurityFunctions\n    }\n\n    requirement def OfferConvenientUserExperience {\n        satisfied by IntegrateSafetyAndSecurityFunctions\n    }\n}\n```",
    " ```sysml\npackage SecurityClassification {\n\n    requirement SecurityClassificationReq {\n        doc /* The system is required to classify and label each component to meet information security management requirements. Every component must be clearly assigned a security classification level, such as \"Unclassified,\" \"Confidential,\" or \"Secret.\" When a component is marked as \"Confidential,\" the system should be able to recognize and display its corresponding classification attribute, thereby enabling effective differentiation and protection of sensitive information during system operation and document management. */\n    }\n\n    enum SecurityClassificationLevel {\n        Unclassified,\n        Confidential,\n        Secret\n    }\n    \n    abstract part Component {\n        securityClassification: SecurityClassificationLevel;\n    }\n    \n    part SystemComponent: Component {\n        securityClassification = SecurityClassificationLevel::Unclassified;\n    }\n    \n    part ConfidentialComponent: Component {\n        securityClassification = SecurityClassificationLevel::Confidential;\n    }\n    \n    part SystemManager {\n        part components: Component[*];\n\n        action ManageComponents() {\n            for comp in components {\n                if (comp is ConfidentialComponent) {\n                    //Display corresponding classification attribute\n                    print(\"Component \" + comp.name + \" is classified as Confidential\");\n                }\n            }\n        }\n    }\n    \n    \n}\n```",
    " ```sysml\npackage ECU_Communication_And_Control {\n\n  part def VehicleControlUnit {\n    part def BusIF_VCU : BusInterface;\n  }\n\n  part def EngineControlUnit {\n    part def BusIF_ECU : BusInterface;\n  }\n  \n  part def CANBus {\n    connector def VCU_Connector: BusInterface;\n    connector def ECU_Connector: BusInterface;\n  }\n  \n  part def VehicleSensors {\n    // Reserved for future expansion\n  }\n  \n  part def EngineSensors {\n    // Reserved for future expansion  \n  }\n\n  connection CANBusConnection_VCU {\n    end1 CANBus.VCU_Connector;\n    end2 VehicleControlUnit.BusIF_VCU;\n  }\n\n  connection CANBusConnection_ECU {\n    end1 CANBus.ECU_Connector; \n    end2 EngineControlUnit.BusIF_ECU;\n  }\n\n  // Reserved sensor interfaces  \n  // connection VehicleSensorConnection {\n  //   end1 VehicleSensors;\n  //   end2 VehicleControlUnit;  \n  // }\n  \n  // connection EngineSensorConnection {\n  //   end1 EngineSensors;\n  //   end2 EngineControlUnit;\n  // }\n  \n}\n```",
    " ```sysml\npackage BloodGlucoseMeterSystem {\n\n  requirement HighReliabilityAndSafetyRequirement {\n    doc /* This system is designed to ensure high reliability and safety \n           of the blood glucose meter during use. */\n  }\n\n  requirement BatteryDepletionDetectionRequirement {\n    doc /* When the battery is depleted or cannot be charged, \n           the system should be able to automatically detect the battery status \n           and promptly alert the user to prevent failure to measure blood glucose levels \n           due to battery issues, as well as potential treatment delays resulting \n           from such failures. */\n  }\n  \n  requirement PreventiveBatteryStatusMeasuresRequirement {\n    doc /* To prevent the aforementioned failure scenarios, \n           the system requires the implementation of preventive measures \n           for battery status. */\n  }\n  \n  requirement BloodGlucoseMeasurementAbnormalityAlarmRequirement {\n    doc /* It must have appropriate alarm and emergency response mechanisms \n           in case of abnormalities in the blood glucose measurement function. */\n  }\n  \n  requirement RigorousApprovalOfRelatedSystemRequirementsRequirement {\n    doc /* The related system requirements have undergone rigorous approval. */\n  }\n  \n  requirement KeyRiskScenarioManagementRequirement {\n    doc /* Management measures have been established for key risk scenarios \n           to ensure that patients can receive timely, continuous, and safe \n           therapeutic support under all circumstances. */\n  }\n\n  satisfy HighReliabilityAndSafetyRequirement {\n    satisfiedBy BatteryDepletionDetectionRequirement, \n                PreventiveBatteryStatusMeasuresRequirement,\n                BloodGlucoseMeasurementAbnormalityAlarmRequirement,\n                RigorousApprovalOfRelatedSystemRequirementsRequirement,\n                KeyRiskScenarioManagementRequirement\n  }\n\n}\n```",
    " ```sysml\npackage ScientificConstants {\n\n  abstract constant pi: Real = 3.14159265358979323846\n  abstract constant e: Real = 2.71828182845904523536\n  abstract constant speedOfLightInVacuum: Real = 2.99792458E8 {unit: 'm/s'}\n  abstract constant fineStructureConstant: Real = 7.2973525693E-3\n  abstract constant electronProtonMassRatio: Real = 1.83615267389E3\n\n  abstract context EarthGravity {\n    abstract constant standardGravitationalAcceleration: Real = 9.80665 {unit: 'm/s^2'}\n  }\n\n  abstract context ModelXAmplifier {\n    abstract constant gainCoefficient: Real = 1.234E6\n  }\n\n  requirement ConstantPrecision {\n    requirement MathematicalConstantPrecision {\n      doc /* Mathematical constants shall have numerical precision up to 20 decimal places */\n    }\n    requirement PhysicalConstantUnits {\n      doc /* Physical constants shall have clear SI unit annotations */\n    }\n    requirement ContextSpecificParameters {\n      doc /* The system shall support scenario-based constants for specific contexts or products */\n    }\n  }\n\n  requirement ConstantAccessibility {\n    doc /* All constants shall be easily accessible and verifiable by the system */\n  }\n\n  requirement ScientificComputationStandards {\n    doc /* The constants shall meet the high standards of scientific computation and engineering domains */\n    requirementReference ref constant_precision: satisfy ConstantPrecision\n    requirementReference ref constant_accessibility: satisfy ConstantAccessibility\n  }\n  \n}\n```",
    " ```sysml\npackage ComponentSpecification {\n\n  attribute def RimDiameter {\n    type: Real\n  }\n\n  attribute def Width {\n    type: Integer\n  }\n\n  class Tire {\n    manufacturer: String\n    rimDiameter: RimDiameter\n    width: Width\n  }\n\n  instance MichelinTire of Tire {\n    manufacturer = \"Michelin\"\n    rimDiameter = 18.0\n    width = 245\n  }\n\n}\n```",
    " ```sysml\npackage AutomotiveComponents {\n\n    import SI::{m, kg, mm}\n    import Imperial::{inches}\n\n    unit inch {\n        baseUnit meters\n        factor 0.0254\n    }\n\n    part def Vehicle {\n        mass: kg = 1200.0 kg\n        length: m = 4.82 m\n        leftFrontWheel: Wheel\n        rightFrontWheel: Wheel\n    }\n\n    part def Wheel {\n        hubDiameter: inches = 18 inches\n        width: mm = 245 mm\n        outerDiameter: mm = (2 * tireHeight) + hubDiameter\n        tire: Tire\n    }\n\n    part def Tire {\n        height: mm\n    }\n\n    def ImperialDimensionConversion() {\n        inches: inch = m * 39.3701\n    }\n\n    def SIDimensionConversion() {\n        m: m = inches / 39.3701    \n    }\n    \n}\n```",
    " ```sysml\npackage VehiclePowertrain {\n\n    requirement VehiclePowertrainRequirement {\n        doc \"This system is used to configure the vehicle's powertrain, including the engine and transmission.\"\n    }\n\n    requirement EngineRequirement {\n        doc \"The vehicle can be equipped with either a four-cylinder engine or a six-cylinder engine.\"\n    }\n\n    requirement TransmissionRequirement {\n        doc \"The vehicle can be paired with either a manual transmission or an automatic transmission.\"\n    }\n\n    requirement OneEngineOneTransmissionRequirement {\n        doc \"Each vehicle must select one type of engine and one type of transmission.\"\n    }\n\n    requirement HighPerformanceRequirement {\n        doc \"If the vehicle is a high-performance model, it must be equipped with a six-cylinder engine; otherwise, a four-cylinder engine must be used.\"\n    }\n\n    requirement ValidPowertrainCombinationsRequirement {\n        doc \"There are only two valid powertrain combinations: either a four-cylinder engine with a manual transmission, or a six-cylinder engine with an automatic transmission. No other combinations are permitted.\"\n    }\n\n    part def Vehicle {\n        part engine: Engine [1]\n        part transmission: Transmission [1]\n    }\n\n    part def Engine {\n        part FourCylinderEngine {}\n        part SixCylinderEngine {}\n    }\n\n    part def Transmission {\n        part ManualTransmission {}\n        part AutomaticTransmission {}\n    }\n\n    satisfy VehiclePowertrainRequirement {\n        by EngineRequirement, TransmissionRequirement, OneEngineOneTransmissionRequirement, HighPerformanceRequirement, ValidPowertrainCombinationsRequirement\n    }\n\n    satisfy EngineRequirement {\n        by Vehicle.engine\n    }\n\n    satisfy TransmissionRequirement {\n        by Vehicle.transmission\n    }\n\n    satisfy OneEngineOneTransmissionRequirement {\n        assert Vehicle.engine.partClassifier in Engine\n        assert Vehicle.transmission.partClassifier in Transmission\n    }\n\n    satisfy HighPerformanceRequirement {\n        assert Vehicle.isHighPerformance implies Vehicle.engine instanceof SixCylinderEngine\n        assert not Vehicle.isHighPerformance implies Vehicle.engine instanceof FourCylinderEngine\n    }\n\n    satisfy ValidPowertrainCombinationsRequirement {\n        assert (Vehicle.engine instanceof FourCylinderEngine and Vehicle.transmission instanceof ManualTransmission) or\n               (Vehicle.engine instanceof SixCylinderEngine and Vehicle.transmission instanceof AutomaticTransmission)\n    }\n\n}\n```",
    " ```sysml\npackage WheelSystemStructure {\n\n    import SI.*\n\n    part def Vehicle {\n        mass: kilogram = 1200 kg\n        length: meter = 4.82 m\n        wheel_assemblies: WheelAssembly[2..*]\n    }\n\n    part def WheelAssembly {\n        tires: Tire[1]\n        brake_disc: BrakeDisc[1]\n        \n        constraint discRadiusLessThanWheelRadius {\n            brake_disc.radius*2 < tires.outer_diameter\n        }\n    }\n\n    part def Wheel {\n        rim: Rim[1]\n        tire: Tire[1]\n    }\n    \n    part def Rim {\n        diameter: inch = 18 in\n    }\n\n    part def Tire {\n        width: millimeter = 245 mm\n        height: millimeter = 45 mm\n        treadDepth: millimeter = 6.0 mm\n        \n        constraint treadDepthAboveMinimum {\n            treadDepth >= 3.5 mm\n        }\n        \n        calc def outer_diameter {\n            2 * (rim.diameter/2 + height)\n        }\n    }\n\n    part def BrakeDisc {\n        radius: millimeter = 95 mm\n    }\n    \n}\n```",
    " ```sysml\npackage FuelSystem {\n\n    requirement FuelSystemRequirements {\n        id = \"R-001\"\n        text = \"This system is used for the automotive fuel system and covers the requirements for components such as the fuel tank assembly, fuel pump, and fuel tank.\"\n    }\n\n    requirement FuelTankAssemblyRequirements {\n        id = \"R-002\"\n        text = \"The fuel tank assembly provides an outlet interface for fuel (including a return function), enabling the delivery of fuel to the engine or other components, as well as the reception of returned fuel.\"\n    }\n\n    requirement FuelPumpRequirements {\n        id = \"R-003\"\n        text = \"The fuel pump, installed inside the fuel tank assembly, serves to pump fuel from the fuel tank and supply it to the engine, while also being capable of receiving returned fuel.\"\n    }\n\n    requirement FuelTemperatureMonitoringRequirements {\n        id = \"R-004\" \n        text = \"The system is able to monitor and transmit fuel temperature information.\"\n    }\n\n    requirement FuelCirculationRequirements {\n        id = \"R-005\"\n        text = \"It is required that fuel can circulate efficiently and safely among all components, meeting the vehicle's overall requirements for fuel supply and return functions, and ensuring normal fuel supply to the engine.\"\n    }\n\n    system FuelSystem {\n        part fuelTankAssembly: FuelTankAssembly\n        part fuelPump: FuelPump\n    }\n\n    system FuelTankAssembly {\n        port fuelOutlet: FuelOutletInterface\n        port fuelReturn: FuelReturnInterface\n    }\n\n    system FuelPump {\n        port fuelSupply: FuelSupplyInterface\n        port fuelReturn: FuelReturnInterface\n    }\n\n    interface FuelOutletInterface {\n        item fuel: Fuel\n    }\n\n    interface FuelReturnInterface {\n        item returnedFuel: Fuel\n    }\n\n    interface FuelSupplyInterface {\n        item fuelToEngine: Fuel\n    }\n\n    item Fuel {\n    }\n\n    requirement FuelSystemRequirements satisfiedBy FuelSystem\n    requirement FuelTankAssemblyRequirements satisfiedBy FuelTankAssembly\n    requirement FuelPumpRequirements satisfiedBy FuelPump \n    requirement FuelTemperatureMonitoringRequirements satisfiedBy FuelSystem\n    requirement FuelCirculationRequirements satisfiedBy FuelSystem\n\n    fuelTankAssembly.fuelOutlet connects fuelPump.fuelSupply\n    fuelPump.fuelReturn connects fuelTankAssembly.fuelReturn\n}\n```",
    " package PhysicalQuantityManagement {\n\n  requirement req1 {\n    name = \"Support physical quantity data and units\"\n    text = \"The system must be capable of supporting and managing data and units related to physical quantities.\"\n  }\n\n  requirement req2 {\n    name = \"Cover ISQ base quantities\"\n    text = \"The system is required to cover various base physical quantities in the International System of Quantities (ISQ), such as length, mass, time, electric current, temperature, amount of substance, and luminous intensity.\"\n  }\n\n  requirement req3 {\n    name = \"Allow import and extension\" \n    text = \"The system should allow for corresponding import and extension of physical quantities.\"\n  }\n\n  requirement req4 {\n    name = \"Ensure accurate representation\"\n    text = \"The system must ensure accurate representation of relevant physical quantities and consistency of information.\"\n  }\n\n  requirement req5 {\n    name = \"Facilitate data processing and unit conversion\"\n    text = \"The system should facilitate physical quantity data processing and unit conversion operations in subsequent engineering or scientific development.\"\n  }\n\n  requirement req6 {\n    name = \"Meet diverse user requirements\"\n    text = \"The system must meet users' diverse requirements for managing physical quantity systems.\"\n  }\n\n  satisfiedBy PhysicalQuantitySystem {\n    \n    part BaseQuantities : ISQBaseQuantities {\n      length : Real\n      mass : Real\n      time : Real\n      electricCurrent : Real\n      temperature : Real \n      amountOfSubstance : Real\n      luminousIntensity : Real\n    }\n\n    part ExtensionMechanism : QuantityExtension\n    \n    part DataConsistency : AccurateQuantityRepresentation\n    \n    part ProcessingOperations : QuantityDataProcessing {\n      convert(quantity : Real, fromUnit : Unit, toUnit : Unit) : Real\n    }\n  }\n\n  interface QuantityExtension {\n    importQuantity(quantity : Quantity)\n    extendQuantity(quantity : Quantity)\n  }\n\n  interface AccurateQuantityRepresentation {\n    ensureAccuracy(quantity : Quantity) : Boolean  \n    maintainConsistency(quantities : Quantity[*]) : Boolean\n  }\n\n  interface QuantityDataProcessing {\n    convert(quantity : Real, fromUnit : Unit, toUnit : Unit) : Real\n  }\n\n}",
    " ```sysml\npackage UnitSystemLibrary {\n\n  requirement req UnitSystemLibraryRequirements {\n    doc /* This system is designed to provide a standardized unit system library that supports the interoperability and adaptation between the International System of Quantities (ISQ) and United States Customary Units (USCustomaryUnits). The goal is to enable users to conveniently manage, convert, and apply various units of physical quantities, effectively reducing confusion and errors caused by inconsistent units. At the same time, the system must ensure the accuracy and authoritative standardization of all unit types, meeting the measurement needs of engineering, scientific research, and daily life. This will enhance the efficiency and reliability of data processing and communication. */\n  }\n\n  requirement req ISQSupport {\n    doc /* The system shall support the International System of Quantities (ISQ) units. */\n  }\n\n  requirement req USCustomaryUnitsSupport {\n    doc /* The system shall support United States Customary Units (USCustomaryUnits). */\n  }\n\n  requirement req UnitConversion {\n    doc /* The system shall enable conversion between ISQ and USCustomaryUnits. */\n  }\n\n  requirement req UnitManagement {\n    doc /* The system shall allow users to manage various units of physical quantities. */\n  }\n\n  requirement req UnitStandardization {\n    doc /* The system shall ensure accuracy and authoritative standardization of all unit types. */\n  }\n\n  requirement req MeasurementNeeds {\n    doc /* The system shall meet the measurement needs of engineering, scientific research, and daily life. */\n  }\n  \n  requirement req DataProcessingEfficiency {\n    doc /* The system shall enhance the efficiency and reliability of data processing and communication. */\n  }\n\n  satisfy UnitSystemLibraryRequirements {\n    satisfiedBy ISQSupport, USCustomaryUnitsSupport, UnitConversion, UnitManagement, \n      UnitStandardization, MeasurementNeeds, DataProcessingEfficiency;\n  }\n  \n}\n```",
    " ```sysml\npackage HeadlampTiltAdjustmentVerificationSystem {\n\n    import SI::* // Import International System of Units (SI)\n    import QUDV::* // Import Quantities, Units, Dimensions, and Values (QUDV)\n    \n    requirement req_BeamTiltAngleRange {\n        description \"The tilt angle of the headlamp beam must be between 50 degrees and 80 degrees to comply with safety and regulatory standards.\"\n        \n        assert tiltAngle >= Angle(50, 'deg') and tiltAngle <= Angle(80, 'deg')\n    }\n    \n    part HeadlampTiltAdjustmentKnob {\n        attribute tiltAngle : Angle\n        \n        operation adjustTiltAngle(newAngle : Angle) {\n            tiltAngle = newAngle\n        }\n    }\n    \n    part VerificationSubsystem {\n        attribute maxAllowedTiltAngle : Angle = Angle(80, 'deg')\n        attribute minAllowedTiltAngle : Angle = Angle(50, 'deg')\n        \n        operation verifyTiltAngle(knob : HeadlampTiltAdjustmentKnob) {\n            assert knob.tiltAngle >= minAllowedTiltAngle and\n                   knob.tiltAngle <= maxAllowedTiltAngle\n        }\n    }\n    \n    part HeadlampTiltAdjustmentVerificationSystem {\n        attribute pi : Real = 3.14159265359\n        attribute e : Real = 2.71828182846\n        \n        part adjustmentKnob : HeadlampTiltAdjustmentKnob\n        part verificationSubsystem : VerificationSubsystem\n        \n        operation validateTiltAngle(newAngle : Angle) {\n            adjustmentKnob.adjustTiltAngle(newAngle)\n            verificationSubsystem.verifyTiltAngle(adjustmentKnob)\n        }\n    }\n}\n```",
    " ```sysml\npackage DataTypes {\n\n    datatype ColorLabel {\n        label : String\n    }\n\n    datatype UnsignedInt {\n        value : Integer [value >= 0]\n    }\n    \n    datatype UnsignedFloat {\n        value : Real [value >= 0.0]\n    }\n\n    datatype DateTime {\n        value : String\n    }\n\n    datatype StringType {\n        value : String\n    }\n\n    datatype BooleanType {\n        value : Boolean\n    }\n    \n    enum StatusColor {\n        red    \"Critical\"\n        yellow \"Warning\"\n        green  \"Normal\"\n    }\n\n    enum DiameterSize {\n        small   \"Small (60 mm)\"\n        medium  \"Medium (70 mm)\" \n        large   \"Large (80 mm)\"\n    }\n\n    datatype DiameterParameter {\n        size : DiameterSize = DiameterSize::small\n    }\n\n    requirement StatusColorMapping {\n        doc /* The system must provide color labeling for status conditions, \n               with \"red\", \"yellow\", and \"green\" respectively representing \n               different status levels (e.g., severity levels such as critical, \n               warning, and normal), and automatically associate each level \n               with the corresponding color. */\n    }\n    \n    requirement ExtensibleDataTypes {\n        doc /* The system's data types should be designed for future \n               extensibility and ensure correct enforcement of value \n               constraints and the logic that associates statuses with \n               their corresponding colors. */\n    }\n}\n```",
    " package System {\n\n    part def SparePartManagement {\n        part def sparePart: Bag<SparePart>;\n    }\n    \n    part def IntegerManagement {\n        part def integerList: List<Integer>;\n    }\n\n    part def StringManagement {\n        part def stringSet: Set<String>;\n    }\n\n    part def PersonnelManagement {\n        part def personnel: OrderedSet<Person>;\n    }\n\n    part def NestedCollectionManagement {\n        part def personnelSets: List<Set<Person>>;\n    }\n\n    part def RealNumberProcessing {\n        part def realArray: Real[4];\n    }\n\n    part def SparePart;\n    part def Person;\n\n}",
    " package TireInformationSystem {\n\n  class Tire {\n    manufacturer: String\n    rimDiameter: Real  // in inches\n    width: Integer\n    installationPosition: Coordinate3D [0..1]\n  }\n\n  class Coordinate3D {\n    x: Real\n    y: Real\n    z: Real\n  }\n\n}",
    " ```sysml\npackage SpacecraftTrajectory {\n\n    timeprecision Second\n\n    import ScalarValues::Real\n    import ScalarValues::DateTime\n\n    part def Spacecraft {\n        attribute launchDateTime: DateTime\n        attribute ascentTrajectory: AscentTrajectory\n    }\n\n    part def AscentTrajectory {\n        attribute samples: TrajectoryDataPoint[1..*]\n    }\n\n    part def TrajectoryDataPoint {\n        attribute timeFromLaunch: Real\n        attribute position: Position\n        attribute velocity: Velocity\n    }\n\n    part def Position {\n        attribute x: Real\n        attribute y: Real \n        attribute z: Real\n\n        unit meter\n    }\n\n    part def Velocity {\n        attribute x: Real\n        attribute y: Real\n        attribute z: Real\n\n        unit meters_per_second\n    }\n\n    requirement RecordAscentTrajectory {\n        doc /* \n        The system is required to sample and record the trajectory of the spacecraft during the ascent phase. \n        The system should use the mission liftoff time as the reference time zero, measured in seconds, \n        and be able to take the UTC liftoff time of the mission as the reference time. The system should collect \n        key parameters including the position and velocity of the spacecraft at different time points. Each set of \n        sampled data must associate a specific time point with the corresponding position and velocity data. \n        Both the three-dimensional position and velocity should be described in a Cartesian coordinate system, \n        with units of meters and meters per second, respectively. The system should record multiple sampling points \n        during the ascent phase, with each sampling point containing explicit information on time, position, and velocity, \n        in order to provide accurate data support for subsequent trajectory analysis and performance evaluation.\n        */\n\n        satisfy {\n            Spacecraft.ascentTrajectory.samples->forAll(s |\n                s.position->unit = meter and\n                s.velocity->unit = meters_per_second and\n                s.timeFromLaunch->unit = Second and\n                s.timeFromLaunch >= 0\n            )\n        }\n    }\n}\n```",
    " ```sysml\npackage MaterialsModel {\n\n  import SI.*\n\n  unit N\n  unit MPa = N / (mm ^ 2)\n\n  abstract class Material {\n    mass: kg\n    atomicMass: kg\n  }\n  \n  class Metal specializes Material {\n  }\n  \n  class Substance specializes Material {\n  }\n  \n  class Alloy specializes Material {\n    tensileStrength: MPa\n    /massFractionSum: Percent{0..100} = sum constituent.massFraction\n  }\n  \n  assoc Composition {\n    parent Alloy\n    child Constituent [2..*]\n  }\n\n  class Constituent {\n    role constituent\n    ref material: Material [1]\n    massFraction: Percent{0..100}\n  }\n  \n  class Iron specializes Metal {\n    mass = 7.874 g/cm^3\n    atomicMass = 55.845 u\n  }\n\n  class Carbon specializes Substance {\n    mass = 2.267 g/cm^3  \n    atomicMass = 12.011 u\n  }\n\n  class Manganese specializes Metal {\n    mass = 7.21 g/cm^3\n    atomicMass = 54.938 u    \n  }\n  \n  class Steel980 specializes Alloy {\n    tensileStrength = 980 MPa\n  }\n\n  part def steel980 : Steel980 {\n    constituent = (\n      iron1 : Constituent {\n        material = iron1 : Iron {}\n        massFraction = 97%\n      },\n      carbon1 : Constituent {\n        material = carbon1 : Carbon {}\n        massFraction = 0.15% \n      },\n      manganese1 : Constituent {\n        material = manganese1 : Manganese {}\n        massFraction = 2.1%\n      }\n    )\n  }\n}\n```",
    " package MaterialsDatabase {\n  \n  part database {\n    part metals {\n      part alloys {  \n      }\n    }\n  }\n\n  abstract part Material {\n    mass atomicMass;\n    string composition;\n    value mechanicalProperties;\n  }\n  \n  part Alloy specializes Material {\n    map<string, mass> constituentMaterials;\n  }\n\n  part Steel_980 specializes Alloy {\n    constituentMaterials = {\n      \"iron\" : 95.7%,\n      \"carbon\" : 0.2%,\n      \"manganese\" : 2.1%\n    };\n    \n    pressure tensileStrength {\n      value = 980 MPa;\n      value = 142 ksi;\n    }\n  }\n\n  abstract value MechanicalProperty {  \n  }\n  \n  value Pressure specializes MechanicalProperty {\n    mass forcePerArea;\n  }\n\n  value TensileStrength specializes Pressure {\n  }\n\n  unit pascal = N/m^2;\n  unit MPa = 10^6 pascal;\n  unit ksi = 1000 lbf/in^2;\n    \n}",
    " ```sysml\npackage PubSubSystem {\n\n  requirement req1 {\n    id = \"REQ1\"\n    text = \"The system shall implement a typical Publish-Subscribe (Pub-Sub) message interaction model.\"\n  }\n\n  requirement req2 {\n    id = \"REQ2\" \n    text = \"The system shall support message producers to publish messages on specific topics to the server.\"\n  }\n\n  requirement req3 {\n    id = \"REQ3\"\n    text = \"The system shall allow consumers to subscribe to topics of interest through the server.\"\n  }\n\n  requirement req4 {\n    id = \"REQ4\"\n    text = \"When a producer publishes a new message, the system shall ensure the server promptly receives the published information.\"\n  }\n\n  requirement req5 {\n    id = \"REQ5\" \n    text = \"The server shall distribute and deliver published messages to corresponding subscribers according to existing topic subscription relationships.\"\n  }\n\n  requirement req6 {\n    id = \"REQ6\"\n    text = \"The system shall ensure that subscribers can accurately and promptly receive the message content of the topics they follow.\"\n  }\n  \n  requirement req7 {\n    id = \"REQ7\"\n    text = \"Users shall only need to declare the topics they wish to subscribe to, without needing to know the specific publishers or other subscribers.\"\n  }\n\n  requirement req8 {\n    id = \"REQ8\" \n    text = \"The entire process shall feature clear management and efficient processing of message subscription, publishing, and distribution flows.\"\n  }\n\n  part Producer {\n    perform pub: Publish \n  }\n\n  part Consumer {\n    perform sub: Subscribe \n  }\n\n  part PubSubServer {\n    perform routing: RouteMessages\n  }\n\n  action Publish {\n    in msg: Message\n    in topic: Topic\n  }\n\n  action Subscribe {\n    in topics: Topic[*]\n  }\n \n  action RouteMessages {\n    in publishedMessage: Message\n    in subscribedTopics: Topic[*]\n    out messagesToDeliver: Message[*]\n  } \n\n  connect Producer.pub to PubSubServer.routing::publishedMessage\n  connect Consumer.sub to PubSubServer.routing::subscribedTopics  \n}\n```",
    " ```sysml\npackage FuelSystem {\n\n    import sysml::* ;\n\n    part def Engine ;\n\n    part def FuelTankAssembly {\n        port in FuelReturn : FuelLine ;\n        port out FuelSupply : FuelLine ;\n    }\n\n    part def FuelLine ;\n\n    abstract connector def FuelTransferConnector ( \n        engine : Engine, \n        tank : FuelTankAssembly\n    ) {\n        connect engine to tank.FuelSupply ;\n        connect tank.FuelReturn to engine ;\n    }\n\n    abstract requirement def FuelSupplyRequirement {\n        doc \"The fuel tank assembly shall supply fuel to the engine.\" ;\n    }\n\n    abstract requirement def FuelReturnRequirement {\n        doc \"The engine shall return unused fuel to the fuel tank assembly.\" ;\n    }\n\n    abstract requirement def FuelTemperatureMonitoringRequirement {\n        doc \"The system shall monitor and transmit fuel temperature information throughout the fuel flow process.\" ;\n    }\n\n    abstract requirement def ContinuousFuelSupplyRequirement {\n        doc \"The fuel system shall provide a continuous and stable fuel supply to the vehicle during operation.\" ;\n    }\n\n    abstract requirement def ExcessFuelRecyclingRequirement {\n        doc \"The fuel system shall effectively recycle excess fuel from the engine.\" ;\n    }\n\n    abstract requirement def ResourceUtilizationOptimizationRequirement {\n        doc \"The fuel system shall optimize resource utilization.\" ;\n    }\n\n    requirement def FuelSystemRequirements {\n        include FuelSupplyRequirement ;\n        include FuelReturnRequirement ;\n        include FuelTemperatureMonitoringRequirement ;\n        include ContinuousFuelSupplyRequirement ;\n        include ExcessFuelRecyclingRequirement ;\n        include ResourceUtilizationOptimizationRequirement ;\n    }\n\n    abstract part def FuelSystem {\n        part engine : Engine ;\n        part fuelTankAssembly : FuelTankAssembly ;\n        connector FuelTransferConnector(engine, fuelTankAssembly) ;\n\n        satisfy FuelSystemRequirements ;\n    }\n\n}\n```",
    " ```sysml\npackage PublishSubscribeSystem {\n\n  requirement MessageFlowRequirement {\n    doc \"This system aims to implement a typical publish-subscribe message flow architecture, consisting of three main participants: producers, server, and consumers. The system requires that producers can publish topic messages to the server, while consumers can subscribe to specific topics via the server. Upon successful subscription, when a new message related to the topic is published, the server needs to push and deliver the message to all consumers who have subscribed to that topic. The entire process includes consumers sending subscription requests to the server, producers publishing messages to the server, and after receiving the messages, the server sending them to all corresponding subscribers, thus achieving reliable message publishing and distribution and ensuring efficient information exchange between different users.\"\n  }\n\n  actor Producer {\n    doc \"Publishes topic messages to the Server\"\n    abstract action Publish(msg: Message, topic: Topic)\n  }\n\n  actor Consumer {\n    doc \"Subscribes to specific topics and receives messages from the Server\"  \n    abstract action Subscribe(topic: Topic)\n    abstract action ReceiveMessage(msg: Message)\n  }\n\n  system Server {\n    doc \"Manages subscriptions and message distribution\"\n    part \"subscriptions: Subscription[*]\" {topic, subscribers}\n    abstract action ReceiveMessage(msg: Message, topic: Topic)\n    abstract action ForwardMessage(msg: Message, topic: Topic)\n  }\n\n  part def Message {\n    doc \"A published message\"\n    part payload: String\n  }\n\n  part def Topic {\n    doc \"A message category that can be subscribed to\"\n    part name: String\n  }\n  \n  part def Subscription {\n    doc \"Tracks a topic and its subscribers\"\n    part topic: Topic\n    part \"subscribers: Consumer[*]\"\n  }\n\n  action ReceiveSubscription(consumer: Consumer, topic: Topic) {\n    doc \"Server receives a subscription request from a consumer\"\n    server: Server;\n    server.subscriptions += Subscription(topic, consumer);\n  }\n\n  action ReceiveMessage(msg: Message, topic: Topic) {\n    doc \"Server receives a published message from a producer\"\n    server: Server;\n    server.ForwardMessage(msg, topic);\n  }\n  \n  action ForwardMessage(msg: Message, topic: Topic) {\n    doc \"Server forwards a received message to subscribed consumers\"  \n    server: Server;\n    subscription: server.subscriptions[topic == topic];\n    for sub in subscription.subscribers {\n      sub.ReceiveMessage(msg);\n    }\n  }\n\n}\n```",
    " ```sysml\npackage TransportationSystem {\n\n  requirement TransportationServices {\n    doc \"This system is designed to provide transportation services for users.\"\n  }\n\n  requirement UserBoarding {\n    doc \"Users (the driver and up to four passengers) can enter the vehicle.\"\n  }\n\n  requirement DriverResponsibility {\n    doc \"The driver is responsible for operating the vehicle to complete travel tasks.\"\n  }\n\n  requirement RefuelingProcess {\n    doc \"During vehicle use, if the fuel level falls below 10% of the maximum tank capacity, the driver may go to a gas station to refuel, thus ensuring the vehicle can continue operating.\"\n  }\n\n  requirement EnvironmentalFactors {\n    doc \"Environmental factors will also be taken into account throughout the process.\"\n  }\n\n  requirement SafeExit {\n    doc \"After transportation is completed, all individuals exit the vehicle safely.\"\n  }\n\n  requirement SystemFocus {\n    doc \"This system focuses on facilitating user boarding, timely refueling during the journey, and ensuring the smooth boarding and alighting of passengers and the driver, thereby guaranteeing an efficient and safe travel experience.\"\n  }\n\n  part Vehicle {\n    part FuelTank {\n      value maxCapacity: Real\n      value currentLevel: Real\n    }\n  }\n\n  part User {\n    part Driver\n    part Passenger[0..4]\n  }\n\n  action BoardVehicle {\n    subject User\n  }\n\n  action OperateVehicle {\n    subject Driver\n  }\n\n  action Refuel {\n    subject Driver\n    target Vehicle::FuelTank\n  }\n\n  action ExitVehicle {\n    subject User\n  }\n\n  stm TravelProcess {\n    initial\n      on BoardVehicle do {\n        OperateVehicle \n      }\n    state Operating {\n      on [Vehicle::FuelTank::currentLevel < 0.1 * Vehicle::FuelTank::maxCapacity] do {\n        Refuel\n      }\n    }\n    final \n      on ExitVehicle\n  }\n}\n```",
    " ```sysml\npackage FuelManagementSystem {\n\n  import PS = 'PhysicalSystems';\n\n  part def FuelTank {\n    port out FuelOutlet: PS::FuelInterface;\n    port in FuelReturn: PS::FuelInterface;\n  }\n  \n  part def Engine {\n    port in FuelInlet: PS::FuelInterface;\n    port out FuelReturnOutlet: PS::FuelInterface;\n  }\n  \n  part def FuelManagementSystem {\n    part fuelTank: FuelTank;\n    part engine: Engine;\n\n    connector fuelSupply: FuelInterface {\n      connect fuelTank.FuelOutlet to engine.FuelInlet;\n    }\n    \n    connector fuelReturn: FuelInterface {\n      connect engine.FuelReturnOutlet to fuelTank.FuelReturn;  \n    }\n  }\n\n  requirement def FuelSupplyManagement {\n    doc /* The system shall provide fuel supply from the fuel tank to the engine */\n  }\n  \n  requirement def FuelReturnManagement {\n    doc /* The system shall provide fuel return from the engine to the fuel tank */\n  }\n  \n  requirement def FuelTemperatureMonitoring {\n    doc /* The system shall monitor fuel temperature at the fuel tank outlet and engine inlet */\n  }\n  \n  requirement def ContinuousFuelSupply {\n    doc /* The system shall ensure the engine continuously receives the required fuel */\n  }\n  \n  requirement def EfficientFuelCirculation {\n    doc /* The system shall ensure efficient fuel circulation between the fuel tank and engine */\n  }\n  \n  requirement def SafeFuelManagement {\n    doc /* The system shall improve the safety of the overall vehicle fuel management */\n  }\n\n  satisfy FuelManagementSystem -> FuelSupplyManagement, FuelReturnManagement, \n          FuelTemperatureMonitoring, ContinuousFuelSupply, EfficientFuelCirculation, \n          SafeFuelManagement;\n}\n\npackage PhysicalSystems {\n  \n  interface def FuelInterface {\n    in temp: Real;\n  }\n}\n```",
    " ```sysml\npackage FuelSystem {\n\n  requirement FuelFlow {\n    id = \"R1\"\n    text = \"Fuel must flow from the fuel tank to the engine through the fuel supply port, while the engine can also return unused fuel back to the fuel tank.\"\n  }\n\n  requirement FuelTemperature {\n    id = \"R2\"  \n    text = \"Each fuel interface should provide the current temperature information of the fuel to facilitate subsequent monitoring and regulation.\"\n  }\n\n  requirement SystemEfficiency {\n    id = \"R3\"\n    text = \"The system should ensure efficient fuel flow and information tracking during both supply and return processes, meeting the requirements for reliability, safety, and monitoring of fuel delivery during normal vehicle operation.\"\n  }\n  \n  part def FuelSystem {\n    part fuelTank: FuelTankAssembly;\n    part engine: Engine;\n\n    connector supplyConnector: FuelConnector(\n      port1 => fuelTank.fuelSupplyPort, \n      port2 => engine.fuelSupplyPort\n    );\n\n    connector returnConnector: FuelConnector(\n      port1 => engine.fuelReturnPort, \n      port2 => fuelTank.fuelReturnPort  \n    );\n  }\n\n  part def FuelTankAssembly {\n    port fuelSupplyPort: FuelInterface;\n    port fuelReturnPort: FuelInterface;\n  }\n\n  part def Engine {\n    port fuelSupplyPort: FuelInterface;  \n    port fuelReturnPort: FuelInterface;\n  }\n\n  interface def FuelInterface {\n    temperature: Real;\n  }\n\n  connector def FuelConnector {\n    port1: FuelInterface;\n    port2: FuelInterface;\n  }\n\n  satisfy(FuelFlow) {\n    by supplyConnector, returnConnector;\n  }\n\n  satisfy(FuelTemperature) {\n    by FuelInterface.temperature;  \n  }\n\n  satisfy(SystemEfficiency) {\n    by FuelSystem;\n  }\n\n}\n```",
    " ```sysml\npackage PhotoCapture {\n\n    requirement Obtain_Photos_From_Real_World_Scenes {\n        id = \"R1\"\n        text = \"The system should enable users to obtain photos from real-world scenes.\"\n    }\n\n    requirement Automatically_Perform_Focusing {\n        id = \"R1.1\"\n        text = \"After a user selects a scene they wish to capture, the system should first automatically perform focusing for the selected scene and generate an intermediate image.\"\n    }\n\n    requirement Capture_And_Output_Final_Photo {\n        id = \"R1.2\"\n        text = \"Based on the focused image, the system should capture and output the final photo.\"\n    }\n\n    requirement Obtain_Photos_Directly {\n        id = \"R1.3\"\n        text = \"Users can directly obtain photos that meet their requirements from the selected scene.\"\n    }\n\n    requirement Complete_Processes_Automatically {\n        id = \"R1.4\"  \n        text = \"The system completes the focusing and shooting processes automatically in the background, without requiring manual intervention at each step.\"\n    }\n\n    satisfy Obtain_Photos_From_Real_World_Scenes_Satisfied {\n        satisfiedBy Automatically_Perform_Focusing, Capture_And_Output_Final_Photo, Obtain_Photos_Directly, Complete_Processes_Automatically\n    }\n    \n    part def Camera {\n    }\n    \n    part def User {\n    }\n\n    part def Scene {\n    }\n\n    action AutomaticallyFocus {\n        subject = Camera\n    }\n\n    action UserSelectsScene {\n        subject = User\n    }\n\n    action GenerateIntermediateImage {\n        subject = Camera\n    }\n\n    action CapturePhoto {\n        subject = Camera\n    }\n\n    action OutputPhoto {\n        subject = Camera\n    }\n\n    action ObtainPhoto {\n        subject = User\n    }\n\n    sequence PhotoCaptureSequence {\n        UserSelectsScene -> AutomaticallyFocus -> GenerateIntermediateImage -> CapturePhoto -> OutputPhoto -> ObtainPhoto\n    }\n}\n```",
    " ```sysml\npackage PhotographyWorkflow {\n\n  requirement 'Support Photography Workflow' {\n    doc \"This system is designed to support the photography workflow, enabling the complete process from focusing on a scene to producing the final image.\"\n  }\n\n  requirement 'Select or Set Scene' {\n    doc \"The user first selects or sets a scene to be photographed.\"\n  }\n\n  requirement 'Perform Focusing' {\n    doc \"The system then automatically performs focusing on the selected scene and generates an intermediate image.\"\n  }\n\n  requirement 'Perform Shooting' {\n    doc \"Subsequently, the system carries out the shooting operation based on the focused image, thereby outputting the final photograph.\"\n  }\n\n  requirement 'Sequential Workflow' {\n    doc \"The entire workflow is completed sequentially through the two steps of \"Focusing\" and \"Shooting,\" ensuring that the image has achieved clear focus before shooting and resulting in high-quality photo output.\"\n  }\n\n  requirement 'Concise and Coherent Operation' {\n    doc \"The system operation process is concise and coherent, enabling users to efficiently obtain the desired photographs.\"\n  }\n\n  action Focus {\n    doc \"Automatically perform focusing on the selected scene and generate an intermediate image.\"\n  }\n\n  action Shoot {\n    doc \"Carry out the shooting operation based on the focused image, outputting the final photograph.\"\n  }\n\n  part def Camera {\n    perform focus: Focus;\n    perform shoot: Shoot;\n  }\n\n  activity PhotographyProcess() {\n    parameter out finalImage;\n    sceneSelection: \"Select or set scene\" ;\n    focusing: perform Camera.focus;\n    shooting: perform Camera.shoot out finalImage;\n\n    sceneSelection -> focusing -> shooting;\n  }\n  \n}\n```",
    " ```sysml\npackage PhotographyWorkflowSystem {\n\n    requirement 'Support photography workflows' {\n        doc \"This system is designed to support photography workflows, allowing users to frame and capture a scene.\"\n    }\n\n    requirement 'Select scene' {\n        doc \"First, the user selects a specific scene.\"\n    }\n\n    requirement 'Perform focusing' {\n        doc \"The system performs a focusing process on the selected scene to generate an image.\"\n    }\n\n    requirement 'Carry out shooting' {\n        doc \"Based on this image, the system carries out the shooting process to produce a final photograph.\"\n    }\n\n    requirement 'Automate workflow' {\n        doc \"The overall workflow automatically completes the focusing and shooting steps, ensuring that users can conveniently convert the scenes they see into high-quality photographs without manually handling intermediate image processing and conversion tasks.\"\n    }\n\n    part def Camera {\n        perform action FocusScene(scene: Scene): Image\n        perform action TakeShot(image: Image): Photograph\n    }\n\n    part def User {\n        perform action SelectScene(): Scene\n    }\n\n    action def FocusScene(scene: Scene): Image\n\n    action def TakeShot(image: Image): Photograph\n\n    action def SelectScene(): Scene\n\n    part property scene: Scene\n    part property image: Image\n    part property photograph: Photograph\n\n    activity PhotographyWorkflow() {\n        actions {\n            user = new User()\n            camera = new Camera()\n\n            scene = user.SelectScene()\n            image = camera.FocusScene(scene)\n            photograph = camera.TakeShot(image)\n        }\n    }\n\n}\n```",
    " ```sysml\npackage PhotographySystem {\n\n  requirement PhotographyAutomationRequirement {\n    doc /* This system is designed to automate the photography process. \n           Users only need to provide a shooting scene, and the system will \n           first perform focus processing on the scene to generate an image \n           suitable for shooting. It will then convert the image into a \n           photograph through a shooting operation. The entire process is \n           seamlessly integrated, requiring no in-depth user intervention \n           in focusing or shooting details. This simplifies the photography \n           workflow, helping users obtain the final photograph easily and \n           efficiently. */\n  }\n\n  requirement FocusProcessingRequirement {\n    doc /* The system shall perform focus processing on the provided scene \n           to generate an image suitable for shooting. */\n  }\n\n  requirement ShootingOperationRequirement {\n    doc /* The system shall convert the focused image into a photograph \n           through a shooting operation. */\n  }\n\n  requirement SeamlessIntegrationRequirement {\n    doc /* The entire process shall be seamlessly integrated, requiring no \n           in-depth user intervention in focusing or shooting details. */\n  }\n\n  requirement SimplifiedWorkflowRequirement {\n    doc /* The system shall simplify the photography workflow, helping users \n           obtain the final photograph easily and efficiently. */\n  }\n\n  part def PhotographySystemContext {\n    part user : User;\n    part photographySystem : PhotographySystem;\n\n    user ->photographySystem : ProvidedShootingScene;\n    photographySystem ->user : FinalPhotograph;\n  }\n\n  part def PhotographySystem {\n    part imageFocusSubsystem : ImageFocusSubsystem;\n    part imageCapturingSubsystem : ImageCapturingSubsystem;\n\n    imageFocusSubsystem ->imageCapturingSubsystem : FocusedImage;\n  }\n\n  part def ImageFocusSubsystem;\n  part def ImageCapturingSubsystem;\n  \n  item ProvidedShootingScene;\n  item FocusedImage;  \n  item FinalPhotograph;\n   \n}\n```",
    " ```sysml\npackage PhotographyWorkflow {\n\n    requirement def REQ_Photography {\n        doc /* Users can complete the entire photography processfrom composition to imaging to photo outputthrough a software package called \"PhotographyWorkflow.\" When a user needs to take a photograph, the system first focuses (Focus) on the captured scene (Scene) to generate a frame of image (Image). The system then performs a shooting (Shoot) operation on the focused image to ultimately produce a photograph (Picture). Users only need to input the desired scene to be photographed; the system will automatically complete the focusing and imaging operations and directly output the required photograph, thereby realizing an automated and streamlined photography workflow. */\n    }\n  \n    abstract action def Photograph(in scene: Scene, out picture: Picture) {\n        Focus(scene => focusedImage);\n        Shoot(focusedImage => picture);\n    }\n    \n    action def Focus(in scene: Scene, out focusedImage: Image);\n    \n    action def Shoot(in focusedImage: Image, out picture: Picture);\n\n    part def Scene;\n    \n    part def Image;\n    \n    part def Picture;\n\n}\n```",
    " ```sysml\npackage PhotographySystem {\n\n    requirement 'Photography Workflow Support' {\n        doc /* This system is designed to support the photography workflow, allowing users to select a scene and capture it as a photograph. */\n    }\n\n    requirement 'Auto Focus' {\n        doc /* In the shooting process, the selected scene is first focused to ensure optimal image sharpness. */\n    }\n\n    requirement 'Focus Detection' {\n        doc /* If the camera detects that the focus is clear, it will proceed to take the photo, generating the final image. */\n    }\n\n    requirement 'One-Click Shooting' {\n        doc /* The entire process automatically performs focusing and shooting operations in sequence, providing users with a convenient one-click shooting experience while ensuring the clarity and quality of the photos. */\n    }\n\n    abstract action Shoot {\n        in scene : Scene\n        out photo : Photo\n    }\n\n    action AutoFocus {\n        in scene : Scene\n        out focusedScene : Scene\n    }\n\n    action DetectFocus {\n        in focusedScene : Scene\n        out isFocusClear : Boolean\n    }\n\n    action CapturePhoto {\n        in focusedScene : Scene\n        out photo : Photo\n    }\n\n    part def Camera {\n        part lens : Lens\n        part sensor : Sensor\n        part processor : ImageProcessor\n    }\n\n    abstract part Lens\n    abstract part Sensor\n    abstract part ImageProcessor\n\n    item Scene\n    item Photo\n\n    Camera::Shoot {\n        in scene : Scene\n        out photo : Photo\n\n        subject camera : Camera\n\n        camera.lens -> AutoFocus(scene => this.scene)\n        camera.processor -> DetectFocus(focusedScene => AutoFocus.focusedScene)\n\n        if (DetectFocus.isFocusClear) {\n            camera.sensor -> CapturePhoto(focusedScene => AutoFocus.focusedScene)\n            photo = CapturePhoto.photo\n        }\n    }\n}\n```\n\nThis SysML v2 model captures the key requirements and actions involved in the photography system:\n\n- Requirements for supporting the photography workflow, auto focus, focus detection, and one-click shooting are defined.\n- Abstract action `Shoot` represents the overall shooting process, with `scene` as input and `photo` as output.\n- Actions `AutoFocus`, `DetectFocus`, and `CapturePhoto` represent the individual steps in the shooting process.\n- The `Camera` part definition includes `lens`, `sensor`, and `processor` parts.\n- `Scene` and `Photo` are defined as items representing the input scene and output photo.\n- The `Shoot` action usage within the `Camera` part specifies the flow and conditions for the shooting process, linking the actions and parts together.",
    " ```sysml\npackage PhotographyWorkflow {\n\n  requirement Requirement_1 {\n    doc \"This system is designed to support users in a workflow for capturing high-quality photographs.\"\n  }\n\n  requirement Requirement_2 {\n    doc \"Users can select a scene, after which the system first performs focusing on the scene and generates an image that is then evaluated for focus quality.\"\n  }\n\n  requirement Requirement_3 {\n    doc \"If the image is determined to be well-focused, the system proceeds with the shooting operation, converting the focused image into a photograph and ultimately producing the final photo required by the user.\"\n  }\n\n  requirement Requirement_4 {\n    doc \"The entire shooting process is automatically linked from scene input to photo output, ensuring that shooting only takes place when the focus is appropriate, thereby improving the clarity and quality of the resulting photographs.\"\n  }\n\n  action SelectScene {\n    doc \"User selects a scene to photograph\"\n  }\n\n  action PerformFocus {\n    doc \"System performs focusing on the selected scene\"\n  }\n\n  action GenerateImage {\n    doc \"System generates an image from the focused scene\"\n  }\n\n  action EvaluateFocusQuality {\n    doc \"System evaluates the focus quality of the generated image\"\n  }\n\n  action ConvertToPhotograph {\n    doc \"System converts the focused image into a photograph\"\n  }\n\n  action ProduceFinalPhoto {\n    doc \"System produces the final photo for the user\"\n  }\n\n  part def User {\n    doc \"User of the photography system\"\n  }\n\n  part def System {\n    doc \"Photography system\"\n  }\n\n  part def Scene {\n    doc \"Scene selected by the user for photography\"\n  }\n\n  part def Image {\n    doc \"Image generated by the system from the focused scene\"\n  }\n\n  part def Photograph {\n    doc \"Photograph created by the system from the focused image\"\n  }\n\n  part def FinalPhoto {\n    doc \"Final photo produced by the system for the user\"\n  }\n\n  stm PhotographyWorkflow {\n    initial init\n    state Idle\n    state SceneSelected\n    state Focused\n    state ImageGenerated\n    state WellFocused\n    state PhotographCreated\n    state FinalPhotoProduced\n    final done\n\n    init -> Idle : start\n    Idle -> SceneSelected : SelectScene\n    SceneSelected -> Focused : PerformFocus\n    Focused -> ImageGenerated : GenerateImage \n    ImageGenerated -> WellFocused : [EvaluateFocusQuality == \"well-focused\"]\n    ImageGenerated -> SceneSelected : [EvaluateFocusQuality == \"not well-focused\"]\n    WellFocused -> PhotographCreated : ConvertToPhotograph\n    PhotographCreated -> FinalPhotoProduced : ProduceFinalPhoto\n    FinalPhotoProduced -> done : end\n  }\n\n}\n```",
    " ```\npackage PhotographyWorkflow {\n\n    requirement TakePhotoAutomatically {\n        id = \"R1\"\n        text = \"The system shall automatically complete all steps of the photography workflow after the user triggers the 'take photo' operation once.\"\n    }\n\n    requirement AutoFocus {\n        id = \"R2\"\n        text = \"The system shall acquire the current shooting scene and automatically perform focusing to generate an image.\"\n    }\n\n    requirement TakePhoto {\n        id = \"R3\"\n        text = \"The system shall execute the shooting operation based on the focused image to produce the final photograph.\"\n    }\n\n    requirement DisplayPhoto {\n        id = \"R4\" \n        text = \"The system shall immediately display the resulting photo after shooting is finished, enabling the user to view the result.\"\n    }\n\n    requirement SeamlessIntegration {\n        id = \"R5\"\n        text = \"The system shall seamlessly integrate the entire photography process without requiring manual intervention from the user at each step.\"\n    }\n\n    part User {\n        part TriggerTakePhoto {\n            perform: TakePhotoOperation\n        }\n    }\n\n    part System {\n        part CurrentShootingScene {} \n        part FocusFunction {\n            inout scene: CurrentShootingScene\n            out focusedImage: Image\n        }\n        part ShootingOperation {\n            in focusedImage: Image\n            out photograph: Photograph \n        }\n        part DisplayFunction {\n            in photograph: Photograph\n        }\n        \n        perform TakePhotoOperation:\n            in scene: CurrentShootingScene\n            out photograph: Photograph {\n\n            step AcquireScene {\n                in scene\n                out acquiredScene\n                perform: FocusFunction.scene = scene\n            }\n            \n            step PerformFocus {\n                in acquiredScene\n                out focusedImage\n                perform: FocusFunction.focusedImage\n            }\n                        \n            step TakePhotograph {\n                in focusedImage\n                out photograph\n                perform: ShootingOperation.photograph\n            }\n            \n            step DisplayPhotograph {\n                in photograph\n                perform: DisplayFunction.photograph = photograph\n            }\n        }        \n    }\n\n    satisfy {\n        TakePhotoAutomatically satisfiedBy System.TakePhotoOperation\n        AutoFocus satisfiedBy System.FocusFunction\n        TakePhoto satisfiedBy System.ShootingOperation  \n        DisplayPhoto satisfiedBy System.DisplayFunction\n        SeamlessIntegration satisfiedBy System.TakePhotoOperation\n    }\n}\n```",
    " ```sysml\npackage BrakeControlSystem {\n\n    requirement def BrakeControlFunctions {\n        doc /* This system is designed to provide automatic braking control functions for vehicles. */\n    }\n\n    requirement def AutomaticActivation {\n        doc /* When the user turns the vehicle key to the start position, the system is automatically activated */\n        \n        satisfy item Activation is satisfied by BrakeControlSystem::ActivationBehavior::Activate\n    }\n\n    requirement def ContinuousMonitoring {\n        doc /* and continuously monitors the status of the brake pedal as well as traction information such as road adhesion. */\n        \n        satisfy item BrakePedalMonitoring is satisfied by BrakeControlSystem::MonitoringBehavior::MonitorBrakePedal\n        satisfy item TractionMonitoring is satisfied by BrakeControlSystem::MonitoringBehavior::MonitorTraction\n    }\n\n    requirement def IntelligentBrakePressureAdjustment {\n        doc /* By detecting the brake pressure generated when the driver presses the brake pedal and evaluating traction variations under different road conditions, the system can intelligently adjust the brake pressure and modulation frequency during the braking process. */\n        \n        satisfy item BrakePressureAdjustment is satisfied by BrakeControlSystem::BrakingBehavior::AdjustBrakePressure\n        satisfy item ModulationFrequencyAdjustment is satisfied by BrakeControlSystem::BrakingBehavior::AdjustModulationFrequency\n    }\n\n    requirement def SafeBrakingPerformance {\n        doc /* This ensures that the vehicle achieves safe and reliable braking performance under various operating conditions, thereby enhancing driving safety and comfort. */\n        \n        satisfy item SafeBraking is satisfied by BrakeControlSystem::BrakingBehavior::Safe\n        satisfy item ReliableBraking is satisfied by BrakeControlSystem::BrakingBehavior::Reliable  \n    }\n\n    requirement def AutomaticMonitoringAndRegulation {\n        doc /* The entire process is automatically monitored and dynamically regulated without user intervention, ensuring that the braking system always operates in its optimal state. */\n        \n        satisfy item AutomaticMonitoring is satisfied by BrakeControlSystem::MonitoringBehavior::Automatic\n        satisfy item DynamicRegulation is satisfied by BrakeControlSystem::BrakingBehavior::DynamicRegulation\n    }\n\n    part def BrakeControlSystem {\n        perform action def ActivationBehavior {\n            action def Activate {\n                // Activation logic\n            } \n        }\n\n        perform action def MonitoringBehavior {\n            action def MonitorBrakePedal {\n                // Brake pedal monitoring logic  \n            }\n            action def MonitorTraction {\n                // Traction monitoring logic\n            }\n            action def Automatic {\n                // Automatic monitoring logic \n            }\n        }\n\n        perform action def BrakingBehavior {\n            action def AdjustBrakePressure {\n                // Brake pressure adjustment logic\n            }\n            action def AdjustModulationFrequency {\n                // Modulation frequency adjustment logic  \n            }\n            action def Safe {\n                // Safe braking logic\n            }\n            action def Reliable {\n                // Reliable braking logic\n            }\n            action def DynamicRegulation {\n                // Dynamic regulation logic\n            }\n        }\n    }\n}\n```",
    " ```sysml\npackage BatteryChargingControlSystem {\n\n  requirement batteryLevelMonitoring {\n    doc /* The system shall monitor the current battery level in real time. */\n  }\n\n  requirement automaticCharging {\n    doc /* The system shall automatically supply charge when the battery level is below 100%. */\n  }\n\n  requirement chargingTerminationControl {\n    doc /* When the battery level reaches or exceeds 100%, the system shall automatically terminate \n            the charging process without manual intervention. */\n  }\n\n  requirement enhanceConvenienceAndSafety {\n    doc /* The system shall ensure healthy charging of the battery and enhance convenience and safety of use. */\n  }\n\n  part batteryCapacityMonitor {\n    doc /* Monitors the current battery capacity level. */\n  }\n\n  part automaticCharger {\n    doc /* Automatically supplies charge to the battery when needed. */\n  }\n\n  part chargingTerminator {\n    doc /* Automatically terminates charging when battery level reaches 100%. */\n  }\n\n  requirement req batteryCapacityMonitor {\n    satisfiedBy batteryCapacityMonitor\n  }\n\n  requirement req automaticCharger {\n    satisfiedBy automaticCharger\n  }\n  \n  requirement req chargingTerminator {\n    satisfiedBy chargingTerminator\n  }\n\n}\n```",
    " ```sysml\npackage BatteryChargingSystem {\n\n  requirement BatteryMonitoringAndControl {\n    id = \"REQ-001\"\n    text = \"This system is designed to implement continuous monitoring and control during the battery charging process. Once charging begins, the system continuously monitors the current battery level (displayed as a percentage). If the battery level is below 100%, it will automatically replenish the battery. This cycle repeats until the battery level reaches or exceeds 100%, at which point the system automatically terminates the charging process. The entire charging operation is fully automated, requiring no manual intervention, thereby ensuring the battery is safely and reliably fully charged while preventing overcharging.\"\n  }\n\n  requirement ContinuousMonitoring {\n    id = \"REQ-002\"\n    text = \"The system shall continuously monitor the current battery level during the charging process.\"\n    satisfy BatteryMonitoringAndControl\n  }\n\n  requirement AutomaticCharging {\n    id = \"REQ-003\"\n    text = \"If the battery level is below 100%, the system shall automatically replenish the battery.\"\n    satisfy BatteryMonitoringAndControl\n  }\n\n  requirement TerminateChargingAtFullCapacity {\n    id = \"REQ-004\"\n    text = \"The system shall automatically terminate the charging process when the battery level reaches or exceeds 100%.\"\n    satisfy BatteryMonitoringAndControl\n  }\n\n  requirement FullyAutomated {\n    id = \"REQ-005\"\n    text = \"The entire charging operation shall be fully automated, requiring no manual intervention.\"\n    satisfy BatteryMonitoringAndControl\n  }\n\n  part BatteryChargingSystem {\n    part Battery {\n      attribute batteryLevel: Percentage\n    }\n    \n    part ChargingController {\n      attribute currentBatteryLevel: Percentage\n      \n      operation monitorBattery() {\n        // Continuously monitor battery level\n      }\n      \n      operation chargeBattery() {\n        // Replenish battery if level is below 100%\n      }\n      \n      operation terminateCharging() {\n        // Terminate charging when battery level reaches or exceeds 100%\n      }\n    }\n  }\n\n  valuetype Percentage {\n    value: Real [0..100]\n  }\n  \n  association MonitorsBattery {\n    source = ChargingController::monitorBattery\n    target = Battery::batteryLevel\n  }\n  \n  association ControlsBattery {\n    source = ChargingController::chargeBattery\n    target = Battery\n  }\n  \n  association TerminatesCharging {\n    source = ChargingController::terminateCharging\n    target = Battery\n  }\n\n}\n```",
    " ```\npackage CameraSystem {\n\n  requirement TakingPhotosOfScenes {\n    doc /* This system is designed to implement a camera function capable of taking photos \n           of various scenes. The system includes automatic focusing on objects within the \n           scene and the imaging process. When the user selects a scene, the camera first\n           obtains a clear and realistic image through the autofocus subsystem. Afterwards,\n           the imaging subsystem captures this image as a photograph. All photos taken are\n           recorded and saved by the system. Users do not need to concern themselves with \n           the internal technical details; they only need to select or confirm the scene to\n           be photographed, and the camera will automatically complete the focusing and \n           imaging operations to generate high-quality photos for the user. */\n  }\n\n  abstract requirement Camera {\n    doc /* Camera system to take photos of user-selected scenes */\n  }\n\n  requirement AutoFocus {\n    doc /* Autofocus subsystem to obtain clear and realistic image of selected scene */\n    satisfiedBy AutoFocusSystem\n  }\n\n  requirement Imaging {\n    doc /* Imaging subsystem to capture focused image as a photograph */  \n    satisfiedBy ImagingSystem\n  }\n  \n  requirement PhotoRecording {\n    doc /* System to record and save all photos taken */\n    satisfiedBy PhotoRecordingSystem\n  }\n  \n  requirement UserSelection {\n    doc /* User selects or confirms scene to be photographed */\n  }\n\n  system CameraSystem satisfies Camera {\n    part af: AutoFocusSystem satisfies AutoFocus\n    part is: ImagingSystem satisfies Imaging\n    part ps: PhotoRecordingSystem satisfies PhotoRecording\n\n    af -> is: SceneImage\n    is -> ps: Photo\n  }\n\n  system AutoFocusSystem {\n    in scene: SelectedScene\n    out focused: SceneImage\n  }\n\n  system ImagingSystem {\n    in image: SceneImage \n    out photo: Photo\n  }\n\n  system PhotoRecordingSystem {\n    in photo: Photo\n  }\n\n  item SelectedScene\n  item SceneImage  \n  item Photo\n}\n```",
    " ```sysml\npackage ShootingSystem {\n\n    requirement ShootingSystemReq {\n        id = \"SSR-001\"\n        text = \"This system is designed to implement the shooting process of a digital camera, enabling users to complete the entire procedure from viewfinding and focusing to imaging with a single, simple operation.\"\n    }\n\n    requirement SceneSelectionReq {\n        id = \"SSR-002\"\n        text = \"Users only need to select the shooting scene; the camera will then automatically focus on the selected scene and generate an image that meets the requirements.\"\n    }\n\n    requirement AutoFocusReq {\n        id = \"SSR-003\"\n        text = \"The camera will automatically focus on the selected scene without the need for users to manually adjust the focus.\"\n    }\n\n    requirement AutoImagingReq {\n        id = \"SSR-004\"\n        text = \"The imaging module will capture and produce the final photo without the need for users to initiate imaging.\"\n    }\n\n    requirement FullyAutomatedReq {\n        id = \"SSR-005\"\n        text = \"The entire shooting process is fully automated, ensuring an efficient and convenient shooting experience.\"\n    }\n\n    requirement HighQualityPhotosReq {\n        id = \"SSR-006\"\n        text = \"All functional modules collaborate to complete the entire process of shooting and image acquisition, outputting high-quality photos.\"\n    }\n\n    system ShootingSystem {\n        part Viewfinder {\n            interact { focus ViewfinderFocus }\n        }\n        \n        part SceneSelector {\n            interact { select SceneSelection }\n        }\n        \n        part AutoFocus {\n            interact { focus AutoFocusFocus }\n        }\n        \n        part ImagingModule {\n            interact { capture ImagingCapture }\n        }\n        \n        interaction ViewfinderFocus\n        interaction SceneSelection\n        interaction AutoFocusFocus\n        interaction ImagingCapture\n        \n        stategroup ShootingProcess {\n            state Viewfinding\n            state Focusing\n            state Imaging\n            \n            initial Viewfinding\n            transition -> Focusing when SceneSelection\n            transition Focusing -> Imaging when AutoFocusFocus\n        }\n        \n        satisfy ShootingSystemReq\n        satisfy SceneSelectionReq\n        satisfy AutoFocusReq\n        satisfy AutoImagingReq\n        satisfy FullyAutomatedReq\n        satisfy HighQualityPhotosReq\n    }\n}\n```",
    " ```sysml\npackage VehicleSimulation {\n\n  requirement VehicleSimulationReq {\n    doc /* This system is designed to simulate a vehicle with a known mass moving \n           along a one-dimensional straight path, predicting its position over time \n           based on a given time-varying power input sequence. Users are required to \n           provide the vehicle's mass, initial position, initial velocity, the time\n           interval of each simulation step, as well as the power input at each time \n           step. The system sequentially calculates the vehicle's speed and position\n           at each moment according to the input data, and outputs the trajectory of\n           the vehicle's position at each time step. This helps users analyze the \n           vehicle's motion behavior under different power inputs. */\n  }\n\n  block Vehicle {\n    mass: Real;\n    position: Real;\n    velocity: Real;\n  }\n\n  block Simulation {\n    vehicle: Vehicle;\n    timestep: Real;\n    totalTime: Integer;\n    powerInput: Real[1..*];\n\n    def run(): Real[1..*] {\n      let trajectory: Real[this.totalTime];\n      for (i in 1..this.totalTime) {\n        this.vehicle.velocity += this.powerInput[i] / this.vehicle.mass * this.timestep;\n        this.vehicle.position += this.vehicle.velocity * this.timestep;\n        trajectory[i] = this.vehicle.position;\n      }\n      return trajectory;\n    }\n  }\n\n  part def userInput(\n    mass: Real,\n    initialPosition: Real, \n    initialVelocity: Real,\n    timestep: Real,\n    powerInput: Real[1..*]\n  ): Simulation {\n    return Simulation {\n      vehicle: Vehicle {\n        mass: mass;\n        position: initialPosition;\n        velocity: initialVelocity;  \n      };\n      timestep: timestep;\n      totalTime: powerInput->size();\n      powerInput: powerInput;\n    };\n  }\n\n  part def main() {\n    let mass = 1000.0;\n    let initialPosition = 0.0;\n    let initialVelocity = 0.0; \n    let timestep = 1.0;\n    let powerInput: Real[5] = [100.0, 200.0, 50.0, 0.0, 75.0];\n\n    let simulation = userInput(\n      mass, \n      initialPosition,\n      initialVelocity,\n      timestep,\n      powerInput\n    );\n    \n    let trajectory = simulation.run();\n    trajectory->forEach(p => {\n      println p;\n    });\n  }\n\n}\n```",
    " ```sysml\npackage CameraSystem {\n\n    requirement 'Basic Camera Functionality' {\n        id = \"CAM-REQ-1\"\n        text = \"This system is designed to implement basic camera shooting and display functionality. While framing, the user can input the current scene into the system. The system first performs a focusing process on the scene to obtain an image; then, it captures the obtained image to generate a photo. Finally, the system automatically displays the captured photo on the screen, allowing the user to view the shooting result immediately. The entire process ensures that scene processing, image generation, and photo display are seamlessly and automatically integrated. The user only needs to perform a simple shooting operation to obtain a complete experience of photographing and viewing the result.\"\n    }\n\n    block Camera {\n        part focusingSystem : FocusingSystem;\n        part imageCaptureSystem : ImageCaptureSystem;\n        part displaySystem : DisplaySystem;\n\n        activity 'Capture Photo' {\n            parameter in scene;\n            parameter out photo;\n\n            action Focus {\n                in scene;\n                out image;\n            }\n\n            action Capture {\n                in image;\n                out photo;\n            }\n\n            action Display {\n                in photo;\n            }\n\n            Focus -> Capture -> Display;\n        }\n    }\n\n    block FocusingSystem {\n        operation focus(in scene, out image);\n    }\n\n    block ImageCaptureSystem {\n        operation capture(in image, out photo);\n    }\n\n    block DisplaySystem {\n        operation display(in photo);\n    }\n\n    actor User {\n        performs 'Frame Scene' : 'Frame the scene for capture';\n        performs 'View Result' : 'View the captured photo';\n    }\n\n    item Scene {\n        doc = \"The current scene being framed by the user for capture\";\n    }\n\n    item Image {\n        doc = \"The focused image obtained from the scene\";\n    }\n\n    item Photo {\n        doc = \"The final captured photo generated from the image\";\n    }\n\n    User performs 'Frame Scene' on Scene;\n    Scene is input to Camera.'Capture Photo';\n    Camera.'Capture Photo'.Focus realizes FocusingSystem.focus;\n    Camera.'Capture Photo'.Capture realizes ImageCaptureSystem.capture;\n    Camera.'Capture Photo'.Display realizes DisplaySystem.display;\n    Photo is output from Camera.'Capture Photo';\n    User performs 'View Result' on Photo;\n\n}\n```",
    " ```sysml\npackage CameraSystem {\n\n    requirement ProcessImage {\n        doc \"When a user selects a scene through the camera's viewfinder (viewPort), the system first focuses on the scene to obtain an image (Image). This image is then captured to generate a photograph (Picture). After the photograph is generated, the system displays it on the screen via the display port (displayPort).\"\n    }\n\n    requirement UserSimplicity {\n        doc \"The user does not need to be concerned with specific technical details during operation and only needs to complete scene selection and shooting.\"\n    }\n    \n    requirement AutomaticProcessing {\n        doc \"The system will automatically handle the processes of focusing, capturing, and displaying the photograph.\"\n    }\n\n    part def Camera {\n        port viewPort: in data;\n        port displayPort: out data;\n\n        part viewFinder: ViewFinder;\n        part imageSensor: ImageSensor;\n        part imageProcessor: ImageProcessor;\n        part display: Display;\n\n        viewPort -> viewFinder.sceneSelect;\n        viewFinder.image -> imageSensor.image;\n        imageSensor.rawImage -> imageProcessor.rawImage;\n        imageProcessor.picture -> display.picture;\n        display.imageOut -> displayPort;\n    }\n\n    part def ViewFinder {\n        port sceneSelect: in data;\n        port image: out data;\n    }\n\n    part def ImageSensor {\n        port image: in data;\n        port rawImage: out data;\n    }\n\n    part def ImageProcessor {\n        port rawImage: in data;\n        port picture: out data;\n    }\n\n    part def Display {\n        port picture: in data;\n        port imageOut: out data;\n    }\n\n    interface def Image {\n    }\n\n    interface def Picture {\n    }\n\n}\n```",
    " ```sysml\npackage SensorManagementSystem {\n\n    requirement ManageSensors {\n        doc \"The system needs to be capable of managing multiple sensors and support monitoring and updating the status of these sensors.\"\n    }\n\n    requirement DetectReadySensors {\n        doc \"When the system detects that any sensor is in a ready state, it should automatically perform an update operation on that sensor.\"\n    }\n\n    requirement TraverseAndUpdateSensors {\n        doc \"The system should be able to automatically traverse all registered sensors and promptly process and maintain each sensor that meets the ready condition, thereby ensuring that all available sensors are kept up-to-date.\"\n    }\n\n    requirement EnhanceResponsivenessAndReliability {\n        doc \"This will enhance the overall responsiveness and reliability of the system.\"\n    }\n\n    part SensorManagementSubsystem {\n        satisfy ManageSensors, DetectReadySensors, TraverseAndUpdateSensors, EnhanceResponsivenessAndReliability\n    }\n\n    part Sensor {\n        state ready\n    }\n\n    part SystemInterface {\n\n    }\n\n    action UpdateSensor {\n\n    }\n\n    action MonitorSensorStatus {\n\n    }\n\n    SensorManagementSubsystem performs MonitorSensorStatus\n    SensorManagementSubsystem performs UpdateSensor\n\n    Sensor connected_to SystemInterface\n    SystemInterface receives_status_of Sensor::ready\n\n    MonitorSensorStatus reads_status_of Sensor::ready\n    UpdateSensor updates Sensor\n\n}\n```",
    " ```sysml\npackage VehicleStartupShutdownSystem {\n\n  requirement StartupShutdownReq {\n    doc /* This system is used to manage the start-up and shutdown states of a vehicle. The vehicle is initially in the off state. Upon receiving a \"vehicle start signal,\" the vehicle switches to the \"starting\" state. Subsequently, when a \"vehicle power-on signal\" is received, the vehicle transitions to the \"on\" state. At any time, if a \"vehicle shutdown signal\" is received, the vehicle state switches back to the \"off\" state. The system must, according to the above logic, reliably ensure that the vehicle state responds appropriately to the corresponding control signals, and safely and sequentially transitions between each state. */\n  }\n\n  statemachine VehicleState {\n    initialState Off\n\n    state Off {}\n    state Starting {}\n    state On {}\n\n    transition t1 {\n      source Off\n      trigger VehicleStartSignal\n      target Starting\n    }\n\n    transition t2 {\n      source Starting  \n      trigger VehiclePowerOnSignal\n      target On\n    }\n\n    transition t3 {\n      source On\n      trigger VehicleShutdownSignal \n      target Off\n    }\n\n    transition t4 {\n      source Starting\n      trigger VehicleShutdownSignal\n      target Off  \n    }\n  }\n\n  event VehicleStartSignal\n  event VehiclePowerOnSignal\n  event VehicleShutdownSignal\n\n}\n```",
    " ```sysml\npackage VehicleOperationalStatusManagement {\n\n    statemachine VehicleStatusStateMachine {\n        initialstate Off\n        state Starting\n        state On\n\n        transition OffToStarting {\n            from Off\n            to Starting\n            trigger VehicleStartSignal\n        }\n\n        transition StartingToOn {\n            from Starting\n            to On\n            trigger VehicleOnSignal\n        }\n\n        transition OnToOff {\n            from On\n            to Off\n            trigger VehicleOffSignal\n        }\n    }\n\n    signal VehicleStartSignal\n    signal VehicleOnSignal\n    signal VehicleOffSignal\n\n}\n```",
    " ```sysml\npackage VehiclePowerManagement {\n\n    requirement VehiclePowerManagementReq {\n        id = \"VPMR-001\"\n        text = \"This system is designed to manage the power status of a vehicle, enabling automatic switching between different operating states according to various control signals.\"\n    }\n\n    statemachine VehiclePowerState {\n        state Off\n        state StartPhase\n        state PoweredOn\n\n        transition OffToStartPhase {\n            from Off\n            to StartPhase\n            trigger VehicleStartCommand\n        }\n\n        transition StartPhaseToPoweredOn {\n            from StartPhase\n            to PoweredOn \n            trigger VehicleStartedSignal\n        }\n\n        transition PoweredOnToOff {\n            from PoweredOn\n            to Off\n            trigger VehicleShutdownCommand\n        }\n    }\n\n    action VehicleStartCommand {\n        id = \"VSC-001\"\n    }\n\n    action VehicleStartedSignal {\n        id = \"VSS-001\" \n    }\n\n    action VehicleShutdownCommand {\n        id = \"VDC-001\"\n    }\n\n    requirement SelfDiagnosisReq {\n        id = \"SDR-001\"\n        text = \"During the powered-on period, the system automatically performs self-diagnosis operations.\"\n    }\n\n    requirement PowerSupplyReq {\n        id = \"PSR-001\" \n        text = \"During the powered-on period, the system continuously supplies power to various functional units of the vehicle.\"\n    }\n\n    requirement SafetyOperationsReq {\n        id = \"SOR-001\"\n        text = \"When the user issues a vehicle shutdown command, the system automatically executes safety operations such as parking brake engagement.\"\n    }\n\n    requirement PowerOffReq {\n        id = \"POR-001\"\n        text = \"When the user issues a vehicle shutdown command, the system returns the vehicle to the off state to cut off the power supply, ensuring safety.\"\n    }\n}\n```",
    " ```sysml\npackage VehicleControlSystem {\n\n    requirement req1 {\n        id = \"REQ-001\"\n        text = \"The system shall be capable of managing the vehicle's start-up, operation, and shutdown processes.\"\n    }\n\n    statemachine VehicleStates {\n        state Shutdown\n        state Startup\n        state Running\n\n        transition StartVehicle {\n            from Shutdown\n            to Startup\n            trigger StartSignal\n        }\n\n        transition VehicleStarted {\n            from Startup\n            to Running\n            trigger VehicleStartedSignal\n        }\n\n        transition ShutdownVehicle {\n            from Running\n            to Shutdown\n            trigger ShutdownSignal\n        }\n    }\n\n    requirement req2 {\n        id = \"REQ-002\"\n        text = \"When the user issues a vehicle start signal while the vehicle is in the shutdown state, the vehicle should enter the start-up state.\"\n    }\n\n    requirement req3 {\n        id = \"REQ-003\"\n        text = \"Upon receiving a vehicle started signal, the system shall set the vehicle status to running.\"\n    }\n\n    requirement req4 {\n        id = \"REQ-004\"\n        text = \"If the user issues a vehicle shutdown signal during operation, the vehicle status shall return to shutdown.\"\n    }\n\n    requirement req5 {\n        id = \"REQ-005\"\n        text = \"The system must accurately respond to the corresponding signals, enabling automatic switching among the three main statesshutdown, start-up, and runningso that the user can conveniently and safely control the vehicle's start and stop processes.\"\n    }\n\n    satisfy {\n        VehicleStates satisfies req1, req2, req3, req4, req5\n    }\n\n    signal StartSignal\n    signal VehicleStartedSignal\n    signal ShutdownSignal\n}\n```",
    " ```sysml\npackage PowerManagementSystem {\n\n  requirement vehicle_power_management {\n    doc /* This system is designed to implement power management for vehicles. \n           The vehicle has multiple operating states, including Off, Start, and On. \n           Under normal circumstances, the vehicle remains in the Off state. \n           The user can switch the vehicle from the Off state to the Start state by issuing a start signal. \n           Once the startup is complete and the vehicle receives an On signal, it transitions to the On state. \n           While in the On state, the user can switch the vehicle back to the Off state by issuing an off signal. \n           The system must ensure that the vehicle's operating state can be switched accurately and promptly \n           in accordance with the various control signals issued by the user, thus meeting the power management needs during daily use. \n           Meanwhile, the system also reserves functionality for health state management to allow for future expansion of vehicle health monitoring capabilities. */\n  }\n\n  statemachine VehiclePowerStates {\n    state Off\n    state Start\n    state On\n    \n    initial Off\n    transition start: Off -> Start\n    transition on: Start -> On\n    transition off: On -> Off \n  }\n\n  part vehicle {\n    perform power: VehiclePowerStates\n  }\n\n  abstract requirement health_state_management {\n    doc /* The system reserves functionality for health state management \n           to allow for future expansion of vehicle health monitoring capabilities. */\n  }\n}\n```",
    " ```sysml\npackage VehicleHealthMonitoringSystem {\n\n    requirement vehicleHealthMonitoring {\n        doc /* \n        This system is designed to enable intelligent monitoring and management of vehicle health status. \n        During normal operation, the system automatically senses the current vehicle temperature and compares \n        it with the preset maximum allowable temperature. If the vehicle temperature exceeds the maximum allowable \n        value, the system promptly sends an over-temperature warning to the vehicle controller and switches the \n        vehicle health status to \"degraded\" mode; when the temperature returns to a safe range, the status \n        automatically reverts to normal. In addition, the vehicle undergoes periodic maintenance at scheduled \n        intervals. When the specified maintenance time is reached, the system automatically enters maintenance \n        status, and after maintenance is completed, the next maintenance cycle time is updated. After the maintenance \n        status has lasted for 48 hours, the vehicle automatically returns to normal operating status. This system \n        operates automatically, helping users to detect and address vehicle over-temperature and maintenance needs \n        in a timely manner, thereby enhancing the safety and reliability of vehicle operation and reducing manual \n        intervention.\n        */\n    }\n\n    part def VehicleTemperatureSensor;\n    part def VehicleController;\n\n    enum VehicleHealthStatus {\n        NORMAL,\n        DEGRADED,\n        MAINTENANCE\n    }\n\n    attribute def temperature : Real;\n    attribute def maxAllowableTemperature : Real;\n    attribute def healthStatus : VehicleHealthStatus;\n    attribute def maintenanceCycleTime : Duration;\n    attribute def nextMaintenanceTime : Instant;\n\n    action def MonitorVehicleTemperature() {\n        temperature = VehicleTemperatureSensor.sense();\n        if (temperature > maxAllowableTemperature) {\n            VehicleController.overTemperatureWarning();\n            healthStatus = VehicleHealthStatus::DEGRADED;\n        } else {\n            healthStatus = VehicleHealthStatus::NORMAL;\n        }\n    }\n\n    action def PerformMaintenance() {\n        healthStatus = VehicleHealthStatus::MAINTENANCE;\n        // Perform maintenance activities\n        nextMaintenanceTime = Instant::now() + maintenanceCycleTime;\n    }\n\n    action def CheckMaintenanceStatus() {\n        if (Instant::now() >= nextMaintenanceTime) {\n            PerformMaintenance();\n        }\n    }\n\n    action def UpdateHealthStatus() {\n        if (healthStatus == VehicleHealthStatus::MAINTENANCE &&\n            Duration::between(Instant::now(), nextMaintenanceTime) >= Duration::ofHours(48)) {\n            healthStatus = VehicleHealthStatus::NORMAL;\n        }\n    }\n\n    statemachine VehicleHealthMonitor {\n        initial state Monitoring {\n            do {\n                MonitorVehicleTemperature();\n                CheckMaintenanceStatus();\n                UpdateHealthStatus();\n            }\n        }\n    }\n\n    part vehicleTemperatureSensor : VehicleTemperatureSensor;\n    part vehicleController : VehicleController;\n    \n    vehicleTemperatureSensor.temperature = temperature;\n    vehicleController.overTemperatureWarning = overTemperatureWarning;\n\n}\n```",
    " ```sysml\npackage ServerSystem {\n\n  requirement req1 {\n    doc /* The system implements a server that exhibits timed clock behavior. The server \n           features a local clock and a port for receiving requests. */\n  }\n\n  requirement req2 {\n    doc /* After startup, the server initially enters the \"off\" state and requires a \"start\" \n           command received through the request port to transition into the waiting state. */\n  }\n\n  requirement req3 {\n    doc /* In the waiting state, the server can receive \"request\" messages, upon which it \n           switches to the response state. */\n  }\n\n  requirement req4 {\n    doc /* In the response state, the server waits for five minutes before reverting back to \n           the waiting state. */\n  }\n\n  requirement req5 {\n    doc /* Additionally, every day at 11:59:00, the server automatically switches back to the \n           off state. */\n  }\n\n  requirement req6 {\n    doc /* The system supports multiple periodic request and response cycles within a single \n           day and can automatically manage its power state according to the preset schedule, \n           thereby ensuring controllable response timing and orderly service operations. */\n  }\n\n  clock localClock {}\n\n  port requestPort {\n    in start: Command;\n    in request: Message;\n  }\n\n  enum ServerState {\n    OFF,\n    WAITING,\n    RESPONDING\n  }\n\n  part server {\n    initial state OFF : ServerState;\n\n    state WAITING : ServerState;\n\n    state RESPONDING : ServerState;\n\n    transition -> OFF;\n\n    transition OFF -> WAITING \n      trigger start : start;\n\n    transition WAITING -> RESPONDING\n      trigger request : request;\n\n    transition RESPONDING -> WAITING\n      after 5 min;\n\n    transition * -> OFF\n      trigger at 11:59:00;\n  }\n\n  satisfy (req1, server);\n  satisfy (req1, localClock);\n  satisfy (req1, requestPort);\n  satisfy (req2, server);  \n  satisfy (req3, server);\n  satisfy (req4, server);\n  satisfy (req5, server);\n  satisfy (req6, server);\n\n}\n```",
    " ```sysml\npackage StartStopSystem {\n\n    requirement VehicleStartStopControl {\n        doc \"This system is used to control the vehicle's start-stop process.\"\n    }\n\n    stm VehicleStates {\n        initial state Off\n        state Starting\n        state Operating\n        final state Stopping\n\n        transition -> Off\n        transition Off -> Starting on StartSignal\n        transition Starting -> Operating on PowerOnSignal [BrakePedalDepressed]\n        transition Operating -> Stopping on StopSignal\n        transition Stopping -> Off\n    }\n\n    action StartVehicle {\n        in event StartSignal\n        out event StartControllerSignal\n    }\n\n    action StopVehicle {\n        in event StopSignal\n        out event ApplyParkingBrake\n    }\n\n    action PerformSelfCheck {\n        doc \"Automatically perform a self-check when entering the operating state\"\n    }\n\n    action SupplyPower {\n        doc \"Continuously supply power to the vehicle in the operating state\"\n    }\n\n    part Controller {\n        doc \"The controller that receives the start signal\"\n    }\n\n    part BrakePedal {\n        doc \"The brake pedal that must be depressed for the power-on signal\"\n    }\n\n    part ParkingBrake {\n        doc \"The parking brake that is automatically applied when leaving the operating state\"\n    }\n\n    requirement SafetyAndReliability {\n        doc \"The overall system is designed to ensure the safety and reliability of the vehicle's start-stop process\"\n    }\n\n    requirement CoordinatedControl {\n        doc \"The system should have coordinated control with the controller\"\n        derive from SafetyAndReliability\n    }\n\n}\n```",
    " package VehicleStartStopSystem {\n\n  requirement vehicle_start_signal {\n    doc /* The system receives a vehicle start signal when the driver prepares to start the vehicle */\n  }\n  \n  requirement brake_pedal_depressed {\n    doc /* The brake pedal must be depressed to allow the vehicle to start */\n  }\n  \n  requirement vehicle_on_signal {\n    doc /* The system receives a vehicle-on signal to initiate the start process */\n  }\n  \n  requirement send_start_control_signal {\n    doc /* The system sends a start control signal to the vehicle controller to enter the started state */\n  }\n  \n  requirement perform_self_check {\n    doc /* The system automatically performs a self-check while in the started state */\n  }\n  \n  requirement supply_power {\n    doc /* The system continuously supplies power to the vehicle while in the started state */\n  }\n  \n  requirement receive_shutdown_signal {\n    doc /* The system receives a shutdown signal when the vehicle needs to be shut down */\n  }\n  \n  requirement switch_to_off_state {\n    doc /* The system switches the vehicle state to off during shutdown */\n  }\n  \n  requirement apply_parking_brake {\n    doc /* The system ensures the parking brake is applied before shutdown for safety */\n  }\n  \n  statemachine VehicleState {\n    initialstate Off\n    state Started\n    \n    transition initialize {\n      from Off\n      to Off\n      trigger vehicle_start_signal\n      guard brake_pedal_depressed\n    }\n    \n    transition start {\n      from Off\n      to Started\n      trigger vehicle_on_signal\n      action send_start_control_signal\n    }\n    \n    state Started {\n      entry perform_self_check\n      do supply_power\n    }\n    \n    transition shutdown {\n      from Started \n      to Off\n      trigger receive_shutdown_signal\n      action switch_to_off_state, apply_parking_brake\n    }\n  }\n\n}",
    " ```sysml\npackage CruiseControlSystem {\n\n  requirement req1 {\n    doc /* This system is a cruise control system, mainly composed of the driver, cruise controller, speedometer, engine, and vehicle, among other components. The driver activates the cruise function by sending a command to set the desired speed. The cruise controller inside the vehicle receives this set-speed command and subsequently obtains the actual vehicle speed information from the speedometer. Based on these inputs, the cruise controller generates and sends corresponding fuel control commands to the engine. The speedometer collects the real-time speed of the vehicle and transmits this information to the cruise controller, while the engine adjusts its output according to the received fuel control commands to ensure the vehicle travels at the set speed. The aforementioned modules exchange information through events to realize the cruise control function as expected by the driver. */\n  }\n  \n  part def Driver;\n  part def CruiseController;\n  part def Speedometer;\n  part def Engine;\n  part def Vehicle;\n   \n  part def speed: Real;\n  part def fuelControl: Real;\n  \n  event SetSpeed(speed: Real); \n  event ActualSpeed(speed: Real);\n  event FuelControl(fuelControl: Real);\n  \n  action ActivateCruiseControl {\n    part Driver;\n    in {SetSpeed};\n    out {ActualSpeed, FuelControl};\n  }\n     \n  action ControlVehicleSpeed {\n    part CruiseController;\n    in {SetSpeed, ActualSpeed};\n    out {FuelControl};\n  }\n  \n  action MeasureVehicleSpeed {\n    part Speedometer;\n    in {Vehicle::speed};\n    out {ActualSpeed};\n  }\n\n  action AdjustEngineOutput {\n    part Engine;\n    in {FuelControl};\n    out {Vehicle::speed};\n  }\n\n}\n```",
    " ```sysml\npackage CruiseControl {\n\n    requirement req1 {\n        doc /* This system is designed to implement the cruise control function for vehicles. The driver can send a set speed command to the cruise controller through operation. After receiving the set speed, the cruise controller acquires the real-time vehicle speed information from the speedometer. Subsequently, the cruise controller generates a corresponding throttle control command based on the difference between the actual vehicle speed and the set speed, and sends this command to the engine system to adjust the vehicle's power output, thereby achieving automatic control of the vehicle speed. The entire process realizes the automatic response to the driver's intent, improving driving comfort and safety. */\n    }\n\n    part def CruiseControlSystem {\n        part controller: CruiseController;\n        part speedometer: Speedometer;\n        part engine: Engine;\n    }\n\n    part def Driver;\n\n    part def CruiseController {\n        in setSpeed: SetSpeedInterface;\n        in currentSpeed: CurrentSpeedInterface;\n        out throttleCommand: ThrottleCommandInterface;\n    }\n\n    part def Speedometer {\n        out currentSpeed: CurrentSpeedInterface;\n    }\n    \n    part def Engine {\n        in throttleCommand: ThrottleCommandInterface;\n    }\n\n    interface def SetSpeedInterface;\n    interface def CurrentSpeedInterface;\n    interface def ThrottleCommandInterface;\n\n    connection setSpeedConn: SetSpeedInterface {\n        conforms Driver -> controller;\n    }\n\n    connection currentSpeedConn: CurrentSpeedInterface {\n        conforms speedometer -> controller;\n    }\n\n    connection throttleCommandConn: ThrottleCommandInterface {\n        conforms controller -> engine;\n    }\n    \n    req1 satisfied by CruiseControlSystem;\n\n}\n```",
    " ```sysml\npackage CruiseControlSystem {\n\n  requirement def CruiseControlReq {\n    doc \"This system is designed to implement an automotive cruise control function.\"\n  }\n\n  requirement def DriverSetSpeedReq {\n    doc \"The driver sends a set speed command to the system via the in-vehicle control interface.\"\n  }\n\n  requirement def CruiseControllerCompareSpeedReq {\n    doc \"After receiving this command, the cruise controller compares the set speed with the current vehicle speed information provided by the speed sensor (speedometer).\"\n  }\n\n  requirement def CruiseControllerCalculateDiffReq {\n    doc \"Upon obtaining the current vehicle speed, the cruise controller calculates the difference between the set speed and the actual speed, generates the corresponding throttle control command, and sends it to the engine.\"\n  }\n\n  requirement def EngineAdjustOutputReq {\n    doc \"This adjusts the engine output to maintain or reach the set speed.\"\n  }\n\n  requirement def SystemCollaborationReq {\n    doc \"Throughout this process, the driver, cruise controller, speedometer, and engine work together through message transmission.\"\n  }\n\n  requirement def AutomaticSpeedMaintainReq {\n    doc \"As a result, after the driver sets the target speed, the vehicle can automatically maintain that speed without the driver needing to continuously operate the accelerator pedal.\"\n  }\n\n  part def Driver {\n  }\n\n  part def CruiseController {\n  }\n\n  part def Speedometer {\n  }\n\n  part def Engine {\n  }\n\n  part def Vehicle {\n  }\n  \n  item flow def SetSpeedCmd {\n  }\n\n  item flow def VehicleSpeedInfo {\n  }\n\n  item flow def ThrottleControlCmd {\n  }\n\n  connector def SetSpeedCmdConn {\n    end driver: Driver;\n    end cruiseController: CruiseController;\n    item flow: SetSpeedCmd;\n  }\n\n  connector def VehicleSpeedInfoConn {\n    end speedometer: Speedometer;\n    end cruiseController: CruiseController;\n    item flow: VehicleSpeedInfo;\n  }\n\n  connector def ThrottleControlCmdConn {\n    end cruiseController: CruiseController;\n    end engine: Engine;\n    item flow: ThrottleControlCmd;\n  }\n\n  connector def EngineVehicleConn {\n    end engine: Engine;\n    end vehicle: Vehicle;\n  }\n\n}\n```",
    " ```sysml\npackage CruiseControl {\n\n    requirement req01 {\n        doc \"When the driver wishes to set the vehicle's cruising speed, they can send a command specifying the desired speed.\"\n    }\n\n    requirement req02 {\n        doc \"Upon receiving this command, the vehicle's cruise controller calculates and sends appropriate throttle control instructions to the engine based on real-time speed information from the speedometer.\"\n    }\n\n    requirement req03 {\n        doc \"This enables the automatic adjustment and maintenance of the vehicle at the set cruising speed.\"\n    }\n\n    requirement req04 {\n        doc \"The system workflow includes promptly collecting and transmitting the driver's speed setting request, real-time sensing and feedback of the vehicle speed, and intelligent throttle adjustment by the cruise controller to the engine.\"\n    }\n\n    requirement req05 {\n        doc \"The system aims to ensure convenience and comfort for the driver during operation while enabling the vehicle to automatically cruise at the preset speed with accuracy and smoothness.\"\n    }\n\n    part def Driver {\n        port out speedCommand: SpeedCommand\n    }\n\n    part def CruiseController {\n        port in speedCommand: SpeedCommand\n        port in currentSpeed: Speed\n        port out throttleControl: ThrottleControl\n    }\n\n    part def Speedometer {\n        port out speed: Speed\n    }\n\n    part def Engine {\n        port in throttleControl: ThrottleControl\n    }\n\n    part def Vehicle {\n        part driver: Driver\n        part cruiseController: CruiseController\n        part speedometer: Speedometer\n        part engine: Engine\n\n        connect driver.speedCommand to cruiseController.speedCommand\n        connect speedometer.speed to cruiseController.currentSpeed\n        connect cruiseController.throttleControl to engine.throttleControl\n    }\n\n    item def SpeedCommand {\n        value speedSetting: Real\n    }\n\n    item def Speed {\n        value currentSpeed: Real\n    }\n    \n    item def ThrottleControl {\n        value throttleSetting: Real\n    }\n\n    activity SetCruiseControlSpeed(in speedCommand: SpeedCommand) {\n        action CalculateThrottle {\n            in speedCommand: SpeedCommand\n            in currentSpeed: Speed\n            out throttleControl: ThrottleControl\n        }\n\n        object cruiseController: CruiseController\n\n        speedCommand -> cruiseController\n        currentSpeed -> cruiseController\n\n        cruiseController -> CalculateThrottle\n        CalculateThrottle -> throttleControl\n    }\n\n}\n```",
    " ```sysml\npackage CruiseControl {\n\n  requirement req1 {\n    doc /* This system aims to implement an automotive cruise control function that enables the driver to set a target speed through the cruise control interface. The vehicle can automatically detect the current speed and, based on the set target speed, automatically adjust the engine output to maintain steady vehicle speed. */\n  }\n\n  requirement req2 {\n    doc /* When the driver sends a set speed command via the cruise control interface, the instruction is transmitted to the vehicle's cruise controller. */\n  }\n  \n  requirement req3 {\n    doc /* The vehicle obtains real-time actual speed information via a speed sensor, and the detected speed information is fed back to the cruise controller. */\n  }\n\n  requirement req4 {\n    doc /* The cruise controller compares the set speed with the actual speed and automatically generates corresponding engine fuel control commands, which are sent to the engine to adjust the vehicle's power so that the driving speed remains as close as possible to the target speed set by the driver. */\n  }\n\n  requirement req5 {\n    doc /* Each component of the system exchanges information such as set speed, speed sensing, and fuel control efficiently and accurately via data ports, ensuring simple driver operation and reliable system operation, and effectively fulfilling the requirements for automatic cruise control. */\n  }\n\n  part def CruiseControlSystem {\n    part cruiseControlInterface: CruiseControlInterface;\n    part cruiseController: CruiseController;\n    part speedSensor: SpeedSensor; \n    part engine: Engine;\n  }\n\n  part def CruiseControlInterface {\n    port out setSpeedCommand: SetSpeedCmd;\n  }\n\n  part def CruiseController {\n    port in setSpeedCmd: SetSpeedCmd;\n    port in actualSpeed: SpeedData;\n    port out fuelControlCommand: FuelControlCmd;\n  }\n\n  part def SpeedSensor {\n    port out currentSpeed: SpeedData;\n  }\n\n  part def Engine {\n    port in fuelControl: FuelControlCmd;\n  }\n  \n  port def SetSpeedCmd;\n  port def SpeedData;\n  port def FuelControlCmd;\n\n  connection setSpeedPath(cruiseControlInterface.setSpeedCommand, cruiseController.setSpeedCmd);\n  connection speedSensingPath(speedSensor.currentSpeed, cruiseController.actualSpeed);  \n  connection fuelControlPath(cruiseController.fuelControlCommand, engine.fuelControl);\n\n}\n```",
    " ```sysml\npackage CruiseControlSystem {\n\n    requirement vehicle_cruise_control {\n        doc /* This system is designed to provide a message interaction mechanism for vehicles equipped with cruise control functionality. Drivers can send set speed commands, which are first processed by the cruise controller upon receipt. The cruise controller then reads real-time speed information from the speed sensor (speedometer). Based on the difference between the set speed and the actual speed, the cruise controller calculates and generates a fuel control command. This fuel control command is first transmitted to the engine controller for processing, after which the engine controller forwards the command to the engine to ultimately control fuel flow and achieve speed adjustment and stabilization. Throughout the entire process, each system component communicates and collaborates via standardized message interfaces, thereby ensuring reliable, efficient, and safe operation of the cruise control function. */\n    }\n\n    part def CruiseController {\n        port in setSpeedCmd: SetSpeedCmd\n        port in actualSpeed: Speed\n        port out fuelControlCmd: FuelControlCmd\n    }\n\n    part def SpeedSensor {\n        port out actualSpeed: Speed\n    }\n\n    part def EngineController {\n        port in fuelControlCmd: FuelControlCmd\n        port out engineFuelControlCmd: FuelControlCmd\n    }\n\n    part def Engine {\n        port in fuelControlCmd: FuelControlCmd\n    }\n\n    part def Driver {\n        port out setSpeedCmd: SetSpeedCmd\n    }\n\n    connector def driver_to_cruiseController: SetSpeedCmd {\n        end driver.setSpeedCmd\n        end cruiseController.setSpeedCmd\n    }\n\n    connector def speedSensor_to_cruiseController: Speed {\n        end speedSensor.actualSpeed\n        end cruiseController.actualSpeed\n    }\n\n    connector def cruiseController_to_engineController: FuelControlCmd {\n        end cruiseController.fuelControlCmd\n        end engineController.fuelControlCmd\n    }\n\n    connector def engineController_to_engine: FuelControlCmd {\n        end engineController.engineFuelControlCmd\n        end engine.fuelControlCmd\n    }\n\n    action cruiseControl (in setSpeed: SetSpeedCmd, in actualSpeed: Speed): FuelControlCmd {\n        // Calculate fuel control command based on set speed and actual speed\n    }\n\n}\n```",
    " ```sysml\npackage VehicleLifecycleManagementSystem {\n\n  requirement req VehicleLifecycleManagement {\n    doc /* This system is designed to manage and track the entire lifecycle of a vehicle. */\n  }\n\n  requirement req AssemblyAndDelivery {\n    doc /* First, a vehicle will go through the assembly and delivery stages. \n            The specific delivery date must be recorded at the time of delivery for each vehicle. */\n  }\n\n  requirement req OwnershipManagement {\n    doc /* After delivery, the vehicle may undergo multiple ownership changes, \n            each of which requires clearly recording the owner's information \n            and ensuring that each stage can be traced to a unique owner. */\n  }\n\n  requirement req DriverManagement {\n    doc /* During each ownership period, different drivers can be tracked and recorded; \n            each driving operation must specify the actual driver. */\n  }\n\n  requirement req EndOfUseManagement {\n    doc /* When the vehicle reaches the end-of-use stage, \n            its scrapping (or de-registration) information should also be recorded. */\n  }\n\n  requirement req InformationManagement {\n    doc /* The entire system should be able to accurately and comprehensively record \n            and manage all lifecycle-related data from vehicle assembly, delivery, \n            ownership transfer, driving details to final scrapping, \n            and should support inquiry and traceability of relevant information. */\n  }\n  \n  part def Vehicle {\n    part assemblyInfo : AssemblyInfo [0..1];\n    part deliveryInfo : DeliveryInfo [0..1];\n    part ownershipInfo : OwnershipInfo [0..*];\n    part driverInfo : DriverInfo [0..*];\n    part endOfUseInfo : EndOfUseInfo [0..1];\n  }\n\n  part def AssemblyInfo {\n    // Assembly related information\n  }\n\n  part def DeliveryInfo {\n    deliveryDate: Date;\n  }\n\n  part def OwnershipInfo {\n    owner: Person;\n    startDate: Date;\n    endDate: Date [0..1];\n  }\n\n  part def DriverInfo {\n    driver: Person;\n    startDate: Date;\n    endDate: Date;\n  }\n\n  part def EndOfUseInfo {\n    scrapDate: Date;\n    deregistrationDate: Date;\n  }\n\n  part def Person {\n    name: String;\n    // Other person related attributes\n  }\n  \n  @datatype Date;\n  @datatype String;\n\n}\n```",
    " ```sysml\npackage VehicleModel {\n\n  part def Vehicle {\n    mass: Real;\n    operational_status: OperationalStatus;\n\n    part engine: Engine;\n    part wheels: Wheel[2..*];\n    ref driver: Driver;\n  }\n\n  part def Wheel {\n    diameter: Real;\n    pressure: Real;\n  }\n\n  part def Engine {\n    horsepower: Real;\n    fuel_type: FuelType;\n  }\n\n  enum OperationalStatus {\n    PARKING,\n    DRIVING\n  }\n\n  enum GearSetting {\n    PARK,\n    REVERSE,\n    NEUTRAL,\n    DRIVE\n  }\n\n  enum FuelType {\n    GASOLINE,\n    DIESEL,\n    ELECTRIC   \n  }\n\n  part def Driver;\n\n  part def vehicle_1 : Vehicle {\n    snapshot vehicle_1_initial {\n      mass = 1500.0;\n      operational_status = PARKING;\n      engine.horsepower = 200.0;\n      engine.fuel_type = GASOLINE;\n      wheels[1] is leftFrontWheel;\n      wheels[2] is rightFrontWheel;\n    }\n\n    snapshot vehicle_1_driving {\n      operational_status = DRIVING;  \n      wheels[1].pressure = 32.0;\n      wheels[2].pressure = 32.0;\n    }\n  }\n\n  part leftFrontWheel : Wheel {\n    diameter = 17.0;\n  }\n\n  part rightFrontWheel : Wheel {\n    diameter = 17.0;  \n  }\n\n}\n```",
    " ```sysml\npackage VehicleSystem {\n\n    attribute mass: Mass\n    attribute gearSetting: Integer\n    attribute acceleratorPosition: Real\n\n    part def Vehicle {\n        attribute mass: Mass\n        attribute state: VehicleState\n    }\n\n    part def VehicleState {\n        attribute gearSetting: Integer\n        attribute acceleratorPosition: Real\n    }\n\n    part def Engine\n    part def Driver\n\n    part def Vehicle_1: Vehicle {\n        attribute initialState: VehicleState {\n            gearSetting = 0\n            acceleratorPosition = 0.0  \n        }\n        attribute mass -> 2000 kg\n\n        event changeState {\n            attribute changedMass: Mass -> 1500 kg \n            attribute changedState: VehicleState {\n                gearSetting = 2\n                acceleratorPosition = 0.5\n            }\n        }        \n    }\n\n    connection def VehicleComposition {\n        part engine: Engine [1]\n        part vehicle: Vehicle [1]\n    }\n\n    connection def OperationalContext {\n        part driver: Driver [1]\n        part vehicle: Vehicle [1] \n    }\n}\n```",
    " ```sysml\npackage VehicleModel {\n\n    class Vehicle {\n        mass: Real\n        gear: Gear\n        throttle: Real\n        engine: Engine\n        driver: Driver[0..1]\n\n        parts\n            engine: Engine\n    }\n\n    class Engine {\n    }\n\n    class Driver {\n        name: String\n    }\n\n    enum Gear {\n        Neutral, First, Second, Third, Fourth, Fifth, Reverse\n    }\n\n    timeslice InitialState {\n        predicate \n            mass == 2000 && gear == Gear::Neutral && throttle == 0\n    }\n\n    timeslice SubsequentState {\n        predicate \n            mass == 1500 && gear == Gear::Second && throttle == 0.5\n    }\n\n    individual vehicle: Vehicle\n\n    individual alice: Driver {\n        name = 'Alice'\n    }\n\n    individual bob: Driver {\n        name = 'Bob'\n    }\n\n    stateConfiguration InitialConfiguration {\n        vehicle {\n            mass = 2000\n            gear = Gear::Neutral\n            throttle = 0\n            driver = alice\n        }\n    }\n\n    stateConfiguration SubsequentConfiguration {\n        vehicle {\n            mass = 1500 \n            gear = Gear::Second\n            throttle = 0.5\n            driver = bob\n        }\n    }\n\n    timeline VehicleTimeline {\n        happens InitialState precedes SubsequentState\n    }\n\n    timeline DriverTimeline {\n        happens alice precedes bob\n    }\n}\n```",
    " ```sysml\npackage VehicleMassModel {\n\n  abstract block Component {\n    value mass: Real\n\n    abstract operation totalMass(): Real {\n      return mass\n    }\n  }\n\n  abstract block CompositeComponent extends Component {\n    part components: Component [0..*]\n\n    operation totalMass(): Real {\n      return mass + components->totalMass()->sum()\n    }\n  }\n\n  block Vehicle extends CompositeComponent {\n    part body: Body [1]\n    part engine: Engine [1] \n    part transmission: Transmission [1]\n  }\n\n  block Body extends Component {\n  }\n  \n  block Engine extends Component {\n  }\n\n  block Transmission extends Component {  \n  }\n\n  block Wheel extends Component {\n  }\n  \n  block Seat extends Component {\n  }\n\n  // Other component definitions can be added as needed\n\n}\n```",
    " ```sysml\npackage VehicleMassManagement {\n\n    part def Vehicle {\n        vin: String;\n        mass: Real;\n        parts: VehicleComponent[1..*];\n    }\n\n    part def VehicleComponent {\n        serialNumber: String;\n        mass: Real;\n        parts: VehicleComponent[0..*];\n    }\n\n    part def Engine specializes VehicleComponent;\n    part def Transmission specializes VehicleComponent;\n\n    requirement def R1 {\n        txt = \"The system shall support comprehensive management and calculation of vehicle and component mass\";\n    }\n\n    requirement def R2 {\n        txt = \"Each vehicle shall be composed of multiple components with measurable mass\";\n    }\n\n    requirement def R3 {\n        txt = \"Each component shall be defined with a simple mass attribute\";\n    }\n\n    requirement def R4 {\n        txt = \"The total mass of a vehicle shall equal its own mass plus the combined mass of all its components\";\n    }\n\n    requirement def R5 {\n        txt = \"The system shall support recursive composition of components\";\n    }\n\n    requirement def R6 {\n        txt = \"The system shall support mass filtering, e.g. only counting subcomponents with mass >= a threshold\";\n    }\n\n    requirement def R7 {\n        txt = \"Each vehicle component shall have a unique serial number\";\n    }\n\n    requirement def R8 {\n        txt = \"Each vehicle shall have a unique Vehicle Identification Number (VIN)\";\n    }\n\n    requirement def R9 {\n        txt = \"Key subcomponents such as engine and transmission shall be specifically defined along with their masses\";\n    }\n\n    requirement def R10 {\n        txt = \"Users shall be able to input mass data for each main component\";\n    }\n\n    requirement def R11 {\n        txt = \"The system shall automatically summarize the information and provide a clear overview of total vehicle mass\";\n    }\n\n    satisfy R1, R2, R3, R4, R5, R6, R7, R8, R9, R10, R11;\n\n    calc def TotalMass(vehicle: Vehicle): Real {\n        return vehicle.mass + Sum(p: vehicle.parts | p.mass >= vehicle.massThreshold); \n    }\n}\n```",
    " ```sysml\npackage MassAggregation {\n\n    abstract object Thing {\n        mass: Mass;\n        /totalMass: Mass;\n    }\n\n    object Mass {\n        value: Real;\n        unit: MassUnit;\n    }\n\n    enum MassUnit {\n        KG,\n        G,\n    }\n\n    object SimpleThing extends Thing {\n        totalMass: Mass := mass;\n    }\n\n    object CompositeThing extends Thing {\n        parts: Part[0..*];\n\n        totalMass: Mass := mass.value + parts->mass.value->sum();\n    }\n\n    part def Part {\n        thing: Thing[1];\n    }\n\n    requirement ReqHierarchicalMassAggregation {\n        doc /* \n            This system is used for the quality aggregation management of objects with mass attributes.\n            Each object has a basic mass attribute (simpleMass) and a total mass attribute (totalMass). \n            For the most basic object (simpleThing), its total mass is equal to its own basic mass. \n            For a composite object (compositeThing), it can contain several subcomponents, each of which is an object with mass. \n            Its total mass is the sum of its own basic mass and the total mass of all its subcomponents.\n            The system can automatically calculate and aggregate the mass of components at all levels of the composite,\n            achieving hierarchical management and statistics of mass.\n        */\n    }\n\n    satisfy of ReqHierarchicalMassAggregation {\n        verifiedBy MassAggregation::Thing::totalMass;\n    }\n\n}\n```",
    " ```sysml\npackage MassManagementSystem {\n\n    abstract class MassObject {\n        mass: Real\n        /totalMass: Real\n        parts subcomponents: MassObject[0..*]\n\n        abstract totalMass(): Real\n        totalMassFiltered(massThreshold: Real): Real = \n            mass + subcomponents->select(c | c.mass >= massThreshold).totalMass()->sum()\n    }\n\n    class LeafMassObject extends MassObject {\n        totalMass(): Real = mass\n    }\n\n    class CompositeMassObject extends MassObject {\n        totalMass(): Real = mass + subcomponents.totalMass()->sum()\n    }\n\n    requirement TotalMassCalculation {\n        text = \"The system shall automatically calculate the total mass of an object, including all its subcomponents.\"\n    }\n\n    requirement FilteredMassAggregation {\n        text = \"The system shall support mass-based filtering and aggregation of components based on a minimum mass threshold.\"\n    }\n\n    requirement HierarchicalMassDecomposition {\n        text = \"The system shall support hierarchical decomposition and overall mass control of complex product or equipment structures.\"\n    }\n\n    requirement FlexibleMassAggregation {\n        text = \"The system shall enable users to flexibly aggregate mass information from different dimensions according to actual needs.\"\n    }\n\n    test case TotalMassTest for TotalMassCalculation {\n        // Test setup and assertions would go here\n    }\n\n    test case FilteredMassTest for FilteredMassAggregation {\n        // Test setup and assertions would go here\n    }\n}\n```",
    " package VehicleDynamics {\n  requirement req VehicleDynamicsCalculation {\n    description \"The system must be capable of calculating the core parameters of vehicle dynamics, including the vehicle's power output, acceleration, speed, and position under various operating conditions.\"\n  }\n  \n  requirement req PowerOutputCalculation {\n    description \"It should accurately calculate the vehicle's actual available power output based on key input parameters such as wheel power, aerodynamic drag coefficient, friction coefficient, vehicle mass, and speed.\"\n  }\n  \n  requirement req AccelerationCalculation {\n    description \"The system should be able to deduce the vehicle's acceleration based on effective power, mass, and current speed.\"\n  }\n  \n  requirement req SpeedCalculation {\n    description \"The system should utilize the obtained acceleration, initial speed, and time to calculate the vehicle's speed at any given moment.\"\n  }\n  \n  requirement req DisplacementCalculation {\n    description \"The system should have the capability to estimate vehicle displacement based on speed and time.\"\n  }\n  \n  requirement req PerformanceAnalysis {\n    description \"The system should help end-users comprehensively analyze and predict the dynamic performance of the vehicle under specific operating conditions.\"\n  }\n  \n  requirement req AccuracyEmphasis {\n    description \"The overall requirements emphasize high accuracy, clear logical relationships between parameters, and results that are convenient for practical engineering applications.\"\n  }\n  \n  satisfy VehicleDynamicsCalculation {\n    satisfiedBy PowerOutputCalculation, AccelerationCalculation, SpeedCalculation, DisplacementCalculation;\n  }\n  \n  satisfy PowerOutputCalculation {\n    satisfiedBy AccuracyEmphasis;\n  }\n  \n  satisfy AccelerationCalculation {\n    satisfiedBy AccuracyEmphasis;\n  }\n  \n  satisfy SpeedCalculation {\n    satisfiedBy AccuracyEmphasis;\n  }\n  \n  satisfy DisplacementCalculation {\n    satisfiedBy AccuracyEmphasis;\n  }\n  \n  satisfy PerformanceAnalysis {\n    satisfiedBy PowerOutputCalculation, AccelerationCalculation, SpeedCalculation, DisplacementCalculation;\n  }\n}",
    " package VehicleDynamicsSimulation {\n\n  requirement req VehicleDynamicsSimulationRequirement {\n    description \"This system is designed to simulate and compute the dynamic behavior of vehicles during straight-line driving, taking into account influencing factors such as aerodynamic drag and rolling resistance. By utilizing the wheel-end output power and the total vehicle mass, the system dynamically calculates the vehicle's acceleration, speed, and position. Given the initial speed and position, as well as a specified time step, and by comprehensively considering parameters such as the aerodynamic drag coefficient and rolling resistance coefficient, the system first determines the available driving power under current conditions, then calculates the vehicle's acceleration accordingly, and further derives the new speed and position of the vehicle at the end of the time step. The system allows users to flexibly set key parameters and can provide accurate physical modeling and computational foundations for applications such as straight-line driving performance analysis, energy consumption simulation, and driving strategy optimization.\"\n  }\n\n  block VehicleDynamicsSimulator {\n    part vehicle: Vehicle;\n    part environment: Environment;\n    \n    value initialSpeed: Real;\n    value initialPosition: Real;\n    value timeStep: Real;\n    \n    action simulateVehicleDynamics() {\n      // Determine available driving power\n      // Calculate vehicle acceleration\n      // Derive new speed and position\n    }\n  }\n\n  block Vehicle {\n    value mass: Real;\n    value aerodynamicDragCoefficient: Real;\n    value rollingResistanceCoefficient: Real;\n    value wheelEndOutputPower: Real;\n    \n    value acceleration: Real;\n    value speed: Real;\n    value position: Real;\n  }\n\n  block Environment {\n    // Environmental factors (e.g., air density, road conditions)\n  }\n\n  valuetype VehicleParameters {\n    value mass: Real;\n    value aerodynamicDragCoefficient: Real;\n    value rollingResistanceCoefficient: Real;\n    value wheelEndOutputPower: Real;\n  }\n\n  valuetype SimulationSettings {\n    value initialSpeed: Real;\n    value initialPosition: Real;\n    value timeStep: Real;\n  }\n\n  valuetype SimulationResults {\n    value acceleration: Real;\n    value speed: Real;\n    value position: Real;\n  }\n  \n}",
    " ```sysml\npackage VehicleDynamicsModel {\n\n  requirement vehicle_mass {\n    doc /* The vehicle mass */\n  }\n\n  requirement wheel_power {\n    doc /* The power output at the wheels */\n  }\n\n  requirement drag_coefficient {\n    doc /* The vehicle's aerodynamic drag coefficient */\n  }\n  \n  requirement rolling_resistance {\n    doc /* The vehicle's rolling resistance coefficient */\n  }\n\n  requirement initial_speed {\n    doc /* The vehicle's initial speed */\n  }\n  \n  requirement initial_position {\n    doc /* The vehicle's initial position */\n  }\n\n  requirement req1 {\n    doc /* This system shall model and compute the vehicle's driving dynamics based on \n            user input parameters such as vehicle mass, wheel power, aerodynamic drag coefficient, \n            and rolling resistance coefficient, together with initial speed and position. */\n    satisfy vehicle_mass, wheel_power, drag_coefficient, rolling_resistance, initial_speed, initial_position\n  }\n  \n  requirement req2 {\n    doc /* The system shall automatically calculate and update the vehicle's speed and \n            position at each time step. */\n  }\n\n  requirement req3 {\n    doc /* The system shall comprehensively account for the effects of air resistance \n            and frictional resistance on vehicle dynamics. */\n  }\n\n  requirement req4 {\n    doc /* The system shall predict the vehicle's velocity, acceleration, displacement,\n            and other dynamic states over time. */\n  }\n\n  requirement req5 {\n    doc /* The system shall assist end users in analyzing vehicle performance under \n            different operating conditions. */\n  }\n  \n  requirement req6 {\n    doc /* The system shall enable the automation and efficient management of vehicle \n            dynamics simulation. */\n  }\n\n  part def VehicleDynamicsSimulator {\n    satisfy req1, req2, req3, req4, req5, req6\n  }\n\n}\n```",
    " ```sysml\npackage VehicleDynamics {\n\n  requirement req1 {\n    doc /* This system is designed to describe and calculate the longitudinal dynamic constraints \n           and state changes of a vehicle moving in a straight line. */\n  }\n  \n  requirement req2 {\n    doc /* Users are required to provide the initial position, initial velocity, vehicle mass, \n           wheel-end drive power, and time interval at a specific moment. */\n  }\n\n  requirement req3 {\n    doc /* Based on the input power, drag coefficient, friction coefficient, and other parameters, \n           the system can automatically calculate the vehicle's acceleration, final velocity, \n           and final position within the given time interval. */\n  }\n\n  requirement req4 {\n    doc /* During the computation, the system comprehensively considers the effects of air resistance, \n           frictional resistance, and other factors, and solves the dynamic equations under relevant \n           constraints to ensure the physical consistency and accuracy of the motion simulation. */\n  }\n   \n  requirement req5 {\n    doc /* This system is suitable for scenarios involving linear uniformly accelerated motion, \n           and can meet the basic needs for vehicle dynamic performance simulation and analysis. */\n  }\n   \n  requirement req6 {\n    doc /* It provides a computational basis for vehicle system dynamics modeling \n           and performance evaluation. */\n  }\n\n  part def Vehicle {\n    attribute initialPosition: Real;\n    attribute initialVelocity: Real;\n    attribute mass: Real;\n    attribute wheelPower: Real;\n    attribute timeInterval: Real;\n    attribute dragCoefficient: Real;\n    attribute frictionCoefficient: Real;\n\n    part def Dynamics {\n      attribute acceleration: Real;\n      attribute finalVelocity: Real;\n      attribute finalPosition: Real;\n    }\n\n    action def CalculateDynamics() {\n      in initialPosition: Real;\n      in initialVelocity: Real; \n      in mass: Real;\n      in wheelPower: Real;\n      in timeInterval: Real;\n      in dragCoefficient: Real;\n      in frictionCoefficient: Real;\n      out acceleration: Real;\n      out finalVelocity: Real;\n      out finalPosition: Real;\n    }\n  }\n\n  satisfaction VehicleDynamicsSatisfaction {\n    subject Vehicle satisfies req1, req2, req3, req4, req5, req6;\n  }\n\n}\n```",
    " ```sysml\npackage VehicleMassManagementSystem {\n\n    requirement VehicleMassLimit {\n        doc \"The vehicle's total mass shall not exceed the maximum permitted limit of 2,500 kilograms.\"\n        \n        requirementVerificationCase TotalMassVerification {\n            doc \"Verify that the total mass of the chassis, engine, and gearbox does not exceed 2,500 kilograms.\"\n        }\n    }\n\n    part Chassis {\n        mass: Real kg;\n    }\n\n    part Engine {\n        mass: Real kg;\n    }\n\n    part Gearbox {\n        mass: Real kg;\n    }\n\n    part Vehicle {\n        chassis: Chassis;\n        engine: Engine;\n        gearbox: Gearbox;\n\n        totalMass: Real kg;\n\n        totalMass = chassis.mass + engine.mass + gearbox.mass;\n        \n        verify (totalMass <= 2500.0) otherwise {\n            notify \"Overweight warning: The total mass of the vehicle exceeds the maximum permitted limit.\";\n        }\n    }\n\n}\n```",
    " ```sysml\npackage VehicleMassBudget {\n\n    import SI::Kilogram\n\n    requirement MassLimit {\n        doc /* The total mass of the complete vehicle shall not exceed 2,500 kilograms */\n        assert TotalMass <= 2500 Kilogram\n    }\n\n    requirement RecordComponentMasses {\n        doc /* The actual mass of each component shall be entered and uniformly measured using kilograms */\n    }\n    \n    requirement CalculateTotalMass {\n        doc /* The system shall automatically calculate the sum of the component masses */\n        assert TotalMass = sum(component: Component :: component.mass)\n    }\n\n    requirement CheckMassLimit {\n        doc /* If the total mass exceeds 2,500 kg, the design requirements are not met */\n        assert TotalMass <= 2500 Kilogram\n    }\n    \n    requirement RecordCriticalComponentMasses {\n        doc /* The masses of the engine and transmission must be separately recorded and managed */\n    }\n\n    part def Component {\n        mass: Kilogram\n    }\n\n    part def Chassis : Component {\n    }\n\n    part def Engine : Component {\n    }\n\n    part def Transmission : Component {  \n    }\n\n    part def Vehicle {\n        chassis: Chassis\n        engine: Engine\n        transmission: Transmission\n    }\n\n    abstract requirement def TotalMass {\n        doc /* Sum of all component masses */  \n    }\n}\n```",
    " ```sysml\npackage VehicleMassComplianceSystem {\n\n  requirement VehicleMassCompliance {\n    description \"The total mass of the complete vehicle (i.e., the sum of the masses of the chassis, engine, and transmission) must not exceed 2,500 kilograms in order to meet vehicle mass compliance requirements.\"\n  }\n\n  part def Chassis {\n    property mass: Real;\n  }\n\n  part def Engine {\n    property mass: Real;\n  }\n\n  part def Transmission {\n    property mass: Real;\n  }\n\n  part def Vehicle {\n    part p_chassis: Chassis;\n    part p_engine: Engine;\n    part p_transmission: Transmission;\n\n    requirement MassLimit {\n      description \"The total mass of the vehicle must not exceed 2,500 kg.\"\n      assert totalMass <= 2500.0;\n    }\n\n    calc def totalMass: Real = p_chassis.mass + p_engine.mass + p_transmission.mass;\n  }\n\n  requirement VerifyMassCompliance {\n    description \"The system shall verify that the total mass of the vehicle does not exceed the specified limit.\"\n    satisfy vehicle.MassLimit;\n  }\n\n  part def System {\n    part vehicle: Vehicle;\n    requirement r_compliance: VehicleMassCompliance;\n    requirement r_verify: VerifyMassCompliance;\n  }\n\n}\n```",
    " ```sysml\npackage VehicleWeightManagementSystem {\n\n  requirement VehicleWeightLimit {\n    description \"The combined weight of the main vehicle components (including the chassis, engine, and transmission) shall not exceed 2,500 kilograms.\"\n    verify WeightVerification \n  }\n\n  requirement WeightDataInput {\n    description \"The system shall be able to accurately record and manage the weight of each component, with the weight data for the chassis, engine, and transmission all required as inputs.\"\n    satisfy WeightDataManagement\n  }\n\n  requirement WeightWarningAndRestriction {\n    description \"When the total weight exceeds the specified limit, the system shall provide a warning or impose restrictions to ensure that the designed vehicle's total weight complies with relevant regulatory requirements.\"\n    satisfy WeightComplianceCheck\n  }\n\n  part Chassis {\n    property weight: Real\n  }\n\n  part Engine {\n    property weight: Real\n  }\n\n  part Transmission {\n    property weight: Real \n  }\n\n  part Vehicle {\n    part chassis: Chassis\n    part engine: Engine \n    part transmission: Transmission\n\n    action totalWeight(): Real {\n      return chassis.weight + engine.weight + transmission.weight\n    }\n  }\n\n  function WeightDataManagement(chassis: Real, engine: Real, transmission: Real) {\n    Vehicle.chassis.weight = chassis\n    Vehicle.engine.weight = engine\n    Vehicle.transmission.weight = transmission\n  }\n\n  function WeightComplianceCheck() {\n    if Vehicle.totalWeight() > 2500.0 {\n      // Provide warning or impose restrictions\n    }\n  }\n\n  testcase WeightVerification {\n    Vehicle.chassis.weight = 1000.0\n    Vehicle.engine.weight = 800.0 \n    Vehicle.transmission.weight = 500.0\n    assert Vehicle.totalWeight() <= 2500.0\n  }\n\n}\n```",
    " ```sysml\npackage VehicleSpecification {\n\n  requirement VehicleMassConstraint {\n    description \"The total mass of all vehicle components must not exceed 2,500 kilograms.\"\n  }\n\n  requirement DynamicConstraints {\n    description \"The system supports modeling the vehicle's dynamic constraints under known initial velocity, final velocity, mass, applied force, and over a given period of time, ensuring that the mass must be greater than zero, and that the physical relationship among force, time, and change in velocity is satisfied.\"\n  }\n\n  part def Vehicle {\n    part chassis : Chassis;\n    part engine : Engine;\n    part transmission : Transmission;\n\n    mass : Real kg;\n\n    constraint MassConstraint {\n      chassis.mass + engine.mass + transmission.mass <= 2500 kg;\n    }\n  }\n\n  part def Chassis {\n    mass : Real kg;\n  }\n\n  part def Engine {\n    mass : Real kg;\n  }\n\n  part def Transmission {\n    mass : Real kg;\n  }\n\n  constraint def VehicleDynamics (\n    initialVelocity : Real m/s,\n    finalVelocity : Real m/s,\n    mass : Real kg,\n    force : Real N,\n    time : Real s\n  ) {\n    assume {\n      mass > 0 kg;\n    }\n    assert {\n      (finalVelocity - initialVelocity) * mass = force * time;\n    }\n  }\n\n}\n```",
    " ```sysml\npackage VehicleMaintenanceSystem {\n\n  requirement MaintenanceSchedule {\n    doc /* For each vehicle, a specific time for the next maintenance and a fixed maintenance interval will be set, and the maximum allowed temperature will be recorded. */\n  }\n\n  requirement MaintenanceTimeReached {\n    doc /* The system will automatically determine whether the vehicle has reached the maintenance time. */\n  }\n\n  requirement UnderMaintenance {\n    doc /* Once the scheduled maintenance time is reached, the vehicle status will switch to \"under maintenance.\" */\n  }\n\n  requirement MaintenanceStartTime {\n    doc /* The system requires that the actual maintenance start time must be later than the scheduled maintenance time, and the maintenance must be initiated within 2 seconds after the previous healthy state ends. */\n  }\n\n  requirement MaintenanceDuration {\n    doc /* The duration of the maintenance must not exceed 48 hours. */\n  }\n\n  requirement NextMaintenanceTime {\n    doc /* After the maintenance is completed, the vehicle's next maintenance time will be automatically postponed according to the maintenance interval, and its health status will be restored to normal. */\n  }\n\n  part def Vehicle {\n    attribute nextMaintenanceTime: Real\n    attribute maintenanceInterval: Real\n    attribute maxTemperature: Real\n    attribute status: VehicleStatus\n\n    timingRequirement def initiateWithin2Sec {\n      assert sequence {\n        this.status == VehicleStatus.HEALTHY\n        this.status == VehicleStatus.UNDER_MAINTENANCE\n        duration >= 0.0 & duration <= 2.0\n      }\n    }\n\n    timingRequirement def limitMaintenanceDuration {\n      assert sequence {\n        this.status == VehicleStatus.UNDER_MAINTENANCE\n        this.status != VehicleStatus.UNDER_MAINTENANCE\n        duration <= 48.0\n      }\n    }\n  }\n\n  enum VehicleStatus {\n    HEALTHY,\n    UNDER_MAINTENANCE\n  }\n\n  action MaintenanceComplete {\n    parameter vehicle: Vehicle\n    vehicle.status = VehicleStatus.HEALTHY\n    vehicle.nextMaintenanceTime = vehicle.nextMaintenanceTime + vehicle.maintenanceInterval\n  }\n\n  action StartMaintenance {\n    parameter vehicle: Vehicle\n    vehicle.status = VehicleStatus.UNDER_MAINTENANCE\n  }\n  \n  timingRequirement def startMaintenanceOnTime {\n    assert sequence {\n      any v: Vehicle satisfies v.nextMaintenanceTime <= time\n      any v: Vehicle satisfies v.status == VehicleStatus.UNDER_MAINTENANCE\n    }\n  }\n\n}\n```",
    " ```sysml\npackage VehicleRequirements {\n\n  requirement VehicleMassRequirement {\n    satisfy {\n      TotalMassLimit: mass.kg <= MaxMassLimit\n      FuelMassPositive: fuelMass > mass.kg(0)\n    }\n  }\n\n  requirement EngineTorqueRequirement {\n    satisfy {\n      EngineTorqueCurve: engine.torque = f(engine.speed)\n    }\n  }\n\n  requirement PowerTransmissionRequirement {\n    satisfy {\n      EngineToTransmission: engine.torque -> transmission.inputTorque\n    }\n  }\n\n  part def vehicle {\n    part engine {\n      torque: torque\n      speed: angularVelocity\n    }\n    part transmission {\n      inputTorque: torque\n    }\n    part clutch {\n      connect engine.torque to transmission.inputTorque\n    }\n    mass: mass\n    fuelMass: mass\n  }\n\n  values {\n    value MaxMassLimit: mass.kg\n  }\n\n}\n```",
    " ```sysml\npackage VehicleRequirements {\n\n    requirement VehicleMassLimit {\n        description \"With a full fuel tank, the vehicle's total mass must not exceed 2000 kg, while with an empty fuel tank, the total mass must not exceed 1500 kg.\"\n        \n        satisfy {\n            VehicleMassFullTank : expr {vehicleMass <= 2000 kg}\n            VehicleMassEmptyTank : expr {vehicleMass <= 1500 kg}\n        }\n    }\n\n    requirement EngineTorqueTransmission {\n        description \"The engine must be capable of transmitting its generated torque to the transmission via the clutch interface.\"\n        \n        satisfy item clutch : Clutch\n    }\n    \n    requirement EnginePerformance {\n        description \"The engine is required to deliver the necessary torque according to the speed-torque curve (see Table 1).\"\n        \n        satisfy item engine : Engine {\n            speedTorqueCurve = speedTorqueTable\n        }\n    }\n    \n    part def Engine {\n        property speedTorqueCurve : Table\n    }\n    \n    part def Clutch {\n    }\n    \n    part def Transmission {        \n    }\n    \n    part def SpeedTorqueTable {\n        isTable\n    }\n    \n    part def vehicleMass {\n        unit kg\n    }\n    \n}\n```",
    " ```sysml\npackage VehicleSystem {\n\n  requirement vehicle {\n    doc /* The system model of this project primarily outlines the basic requirements for a vehicle and its engine. */\n    \n    requirement mass {\n      doc /* The vehicle's total mass must not exceed 2000 kilograms when fully fueled, and should not be higher than 1500 kilograms when empty. */\n      assert totalMass <= 2000 kg\n      assert emptyMass <= 1500 kg\n    }\n  }\n  \n  requirement engine {\n    requirement torqueTransmission {\n      doc /* The engine must be capable of effectively transmitting its generated torque to the transmission system through a clutch interface */\n      satisfy transmission.torqueInput\n    }\n    \n    requirement torqueProfile {\n      doc /* The torque generated by the engine should vary with speed, conforming to the relevant performance table specifications. */\n      assert engineTorque->forAll(t | t == f(engineSpeed))\n    }\n  }\n  \n  requirement designConstraints {\n    doc /* The design of both the vehicle and its engine must meet these critical requirements for mass and power interface to ensure overall vehicle performance and safety. */\n    \n    assert vehicle.mass.totalMass <= 2000 kg\n    assert vehicle.mass.emptyMass <= 1500 kg\n    assert engine.torqueTransmission.satisfied()\n    assert engine.torqueProfile.engineTorque->forAll(t | t == f(engineSpeed))\n  }\n  \n  part def Vehicle {\n    part engine: Engine\n    part transmission: Transmission   \n  }\n  \n  part def Engine {\n    torque: Real\n    speed: Real\n  }\n  \n  part def Transmission {\n    torqueInput: Real\n  }\n\n}\n```",
    " ```sysml\npackage VehicleMassAndPower {\n\n    requirement vehicleMassLimit {\n        description \"The actual mass of the vehicle must not exceed the specified limit under two operating conditions.\"\n        \n        requirement fuelTankFullMassLimit {\n            description \"When the fuel tank is full, the total vehicle mass must not exceed 2000 kg.\"\n            \n            satisfy vehicleMass::fuelTankFull\n        }\n        \n        requirement fuelTankEmptyMassLimit {\n            description \"When the fuel tank is empty, the total vehicle mass must not exceed 1500 kg.\"\n            \n            satisfy vehicleMass::fuelTankEmpty\n        }\n        \n        requirement totalMassCalculation {\n            description \"The sum of the vehicle's curb mass and the fuel mass is considered as the total vehicle mass for calculation purposes.\"\n        }\n    }\n\n    requirement engineTorqueGeneration {\n        description \"The engine must be capable of generating the specified torque characteristics at various speeds.\"\n    }\n    \n    requirement torqueTransmission {\n        description \"The generated torque must be effectively transmitted to the gearbox through the clutch interface to ensure smooth power delivery.\"\n    }\n    \n    requirement complianceWithStandards {\n        description \"The above requirements ensure that vehicle mass control and power transmission comply with design and safety standards.\"\n    }\n    \n    part def vehicle {\n        part vehicleCurbMass : Mass\n        part fuelMass : Mass\n        \n        constraint vehicleMass {\n            constraint fuelTankFull {\n                {vehicleCurbMass.value + fuelMass.maxValue} <= 2000 kg \n            }\n            \n            constraint fuelTankEmpty {\n                {vehicleCurbMass.value + fuelMass.minValue} <= 1500 kg\n            }\n        }\n    }\n    \n    part engine {\n        satisfiedBy engineTorqueGeneration\n    }\n    \n    part clutch {\n        satisfiedBy torqueTransmission\n    }\n    \n    part gearbox\n    \n    connection engineClutch : Power {\n        source is engine\n        target is clutch\n    }\n    \n    connection clutchGearbox : Power {\n        source is clutch\n        target is gearbox\n    }\n\n}\n```",
    " ```sysml\npackage VehiclePerformanceAnalysis {\n\n    requirement req01 {\n        description = \"The system shall model and calculate the power demand, acceleration, speed, and position variations over time during straight-line driving.\"\n    }\n\n    requirement req02 {\n        description = \"The system shall allow users to set vehicle attributes such as curb weight, payload, wheel diameter, transmission efficiency, and fuel economy under urban and highway conditions.\"\n    }\n\n    requirement req03 {\n        description = \"The system shall allow users to input specific driving cycles, including time-stamped position and speed information.\"\n    }\n\n    requirement req04 {\n        description = \"The system shall analyze the required engine power, acceleration, and other dynamic parameters necessary to meet the specified driving conditions.\"\n    }\n\n    requirement req05 {\n        description = \"The system shall calculate the vehicle's fuel economy throughout the entire driving cycle.\"\n    }\n\n    requirement req06 {\n        description = \"The system shall support compliance verification based on specified energy consumption targets, such as fuel consumption per 100 kilometers or miles per gallon.\"\n    }\n\n    requirement req07 {\n        description = \"The system shall enable users to check whether the vehicle can achieve a specified fuel economy target under given scenarios and vehicle configurations.\"\n    }\n\n    requirement req08 {\n        description = \"The system shall feature adjustable configuration options, allowing users to input various vehicle parameters and drive cycle scenarios.\"\n    }\n\n    requirement req09 {\n        description = \"The system shall facilitate vehicle performance analysis and energy consumption assessment to provide data support and decision-making references for vehicle design optimization and achievement of energy consumption targets.\"\n    }\n\n    part VehicleAttributes {\n        attribute curbWeight: Real;\n        attribute payload: Real;\n        attribute wheelDiameter: Real;\n        attribute transmissionEfficiency: Real;\n        attribute urbanFuelEconomy: Real;\n        attribute highwayFuelEconomy: Real;\n    }\n\n    part DrivingCycle {\n        attribute timeStamps: Sequence<Real>;\n        attribute positions: Sequence<Real>;\n        attribute speeds: Sequence<Real>;\n    }\n\n    part PerformanceParameters {\n        attribute powerDemand: Sequence<Real>;\n        attribute acceleration: Sequence<Real>;\n        attribute speed: Sequence<Real>;\n        attribute position: Sequence<Real>;\n    }\n\n    part FuelEconomyResult {\n        attribute fuelEconomy: Real;\n    }\n\n    part ComplianceResult {\n        attribute isCompliant: Boolean;\n    }\n\n    action AnalyzePerformance {\n        in attributes: VehicleAttributes;\n        in driveCycle: DrivingCycle;\n        out performanceParams: PerformanceParameters;\n        out fuelEconomy: FuelEconomyResult;\n    }\n\n    action VerifyCompliance {\n        in attributes: VehicleAttributes;\n        in driveCycle: DrivingCycle; \n        in target: Real;\n        out result: ComplianceResult;\n    }\n\n}\n```",
    " package VehicleFuelEconomySimulation {\n\n  requirement VehicleFuelEconomySimulation {\n    title 'Vehicle Fuel Economy Simulation'\n    description 'This system aims to perform simulation analysis on vehicle fuel economy. By setting different urban and highway driving scenarios, it calculates the actual fuel economy of vehicles under these conditions to verify whether they meet the requirement of exceeding 30 miles per gallon.'\n  }\n\n  requirement VehicleParameters {\n    description 'Vehicle parameters include curb weight, load, wheel diameter, transmission efficiency, and others.'\n  }\n  \n  requirement DrivingScenarios {\n    description 'Under given driving trajectories and speed variations, the model analyzes the required wheel power, applies vehicle dynamics to calculate acceleration and energy consumption, and further estimates the actual engine power demand.'\n  }\n  \n  requirement FuelConsumptionCalculation {\n    description 'Ultimately, it determines the corresponding fuel consumption and fuel economy in terms of liters per 100 kilometers.'\n  }\n  \n  requirement UserAssessment {\n    description 'Users can use these results to assess whether the vehicle design meets energy-saving, emissions reduction, and regulatory compliance requirements in real-world use scenarios.'\n  }\n\n  part VehicleSimulationModel {\n    satisfies VehicleFuelEconomySimulation, VehicleParameters, DrivingScenarios, FuelConsumptionCalculation, UserAssessment\n  }\n  \n  part Vehicle {\n    attribute curbWeight: Real\n    attribute load: Real\n    attribute wheelDiameter: Real\n    attribute transmissionEfficiency: Real\n  }\n  \n  part DrivingScenario {\n    attribute drivingTrajectory: Trajectory\n    attribute speedVariation: SpeedVariation\n  }\n  \n  part Trajectory {\n  }\n  \n  part SpeedVariation {\n  }\n  \n  part VehicleDynamics {\n    attribute wheelPower: Real\n    attribute acceleration: Real\n    attribute energyConsumption: Real\n  }\n  \n  part EngineModel {\n    attribute powerDemand: Real\n  }\n  \n  part FuelConsumptionModel {\n    attribute fuelConsumption: Real\n    attribute fuelEconomy: Real\n  }\n  \n  VehicleSimulationModel.parts = Vehicle, DrivingScenario\n  DrivingScenario.parts = Trajectory, SpeedVariation\n  VehicleSimulationModel.parts = VehicleDynamics, EngineModel, FuelConsumptionModel\n}",
    " ```sysml\npackage EngineSelectionSystem {\n\n  requirement comprehensive_selection_analysis {\n    doc /* This system is designed to conduct a comprehensive selection analysis for various types of engines, \n           including four-cylinder and six-cylinder engines. */\n  }\n  \n  requirement aggregate_calculate_kpis {\n    doc /* For each type of engine, the system will aggregate and calculate key performance indicators \n           such as power, mass, efficiency, and cost. */\n  }\n  \n  requirement comprehensive_assessment {\n    doc /* Based on these indicators, a unified evaluation function will be used to comprehensively assess each engine. */\n  }\n  \n  requirement auto_screen_recommend {\n    doc /* Finally, according to the comprehensive evaluation results, the system will automatically screen and \n           recommend the optimal engine selection from all candidates, thereby maximizing both engine performance\n           and economic efficiency. */\n  }\n  \n  abstract Engine;\n  \n  part def FourCylinderEngine : Engine;\n  part def SixCylinderEngine : Engine;\n  \n  abstract EngineKPI {\n    value power: Real;\n    value mass: Real;\n    value efficiency: Real;\n    value cost: Real;\n  }\n  \n  part kpis : EngineKPI[1];\n  \n  abstract EvaluationFunction {\n    def evaluateEngine(eng: Engine): Real;\n  }\n  \n  part evalFn : EvaluationFunction[1];\n  \n  requirement kpi_constraint {\n    doc /* Engine KPIs must be positive and within reasonable ranges */\n    assert kpis->forAll(k | k.power > 0 && k.mass > 0 && k.efficiency > 0 && k.cost > 0);\n  }\n   \n  abstract EngineSelector {\n    def selectOptimalEngine(engines: Engine[1..*]): Engine {\n      engines->sortedBy(eng | evalFn[1].evaluateEngine(eng))->last()\n    }\n  }\n  \n  part selector: EngineSelector[1];\n\n}\n```",
    " ```sysml\npackage VehicleWeightCheck {\n\n    requirement VehicleWeightRequirement {\n        description \"The curb weight of each vehicle must be less than or equal to 2,500 kilograms.\"\n        \n        satisfy {\n            VehicleWeightCheckAction.output.result\n        }\n    }\n\n    action VehicleWeightCheckAction {\n        in actualWeight: Mass\n        out result: VehicleWeightResult\n\n        parts {\n            ac: CollectWeightDataAction\n            ap: ProcessWeightDataAction\n            ae: EvaluateWeightAction\n        }\n\n        ac.output -> ap.input\n        ap.output -> ae.input\n    }\n\n    action CollectWeightDataAction {\n        out output: Mass\n    }\n\n    action ProcessWeightDataAction {\n        in input: Mass\n        out output: Mass\n    }\n\n    action EvaluateWeightAction {\n        in input: Mass\n        out output: VehicleWeightResult\n    }\n\n    enum VehicleWeightResult {\n        qualified\n        unqualified\n    }\n\n    unit kilogram {\n        symbol \"kg\"\n    }\n\n    value type Mass {\n        baseUnit kilogram\n    }\n    \n}\n```",
    " ```sysml\npackage MassVerificationSystem {\n\n  requirement MassLimit {\n    doc \"The actual mass of each vehicle shall not exceed 2,500 kilograms.\"\n  }\n\n  requirement MassInspection {\n    doc \"Every vehicle to be inspected shall undergo a mass inspection process to check whether its mass complies with the specified upper limit.\"\n  }\n\n  part Vehicle {\n    doc \"A vehicle that requires mass verification.\"\n  }\n\n  part WeighingEquipment {\n    doc \"Equipment used to measure the actual mass of a vehicle.\"\n  }\n  \n  part MassVerificationUnit {\n    doc \"A unit that processes and evaluates the measured mass data.\"\n  }\n\n  action MeasureMass {\n    doc \"Measure the current actual mass of the vehicle using the weighing equipment.\"\n  }\n\n  action ProcessMassData {\n    doc \"Process and evaluate the measured mass data.\"\n  }\n\n  action DetermineQualificationStatus {\n    doc \"Determine if the vehicle is qualified or unqualified based on its measured mass.\"\n  }\n\n  value QualificationStatus {\n    doc \"The qualification status of a vehicle based on its mass.\"\n    enum qualified {\n      doc \"The vehicle's mass is less than or equal to 2,500 kilograms.\"\n    }\n    enum unqualified {\n      doc \"The vehicle's mass exceeds 2,500 kilograms.\"\n    }\n  }\n\n  action PerformMassVerification {\n    doc \"Carry out the entire mass verification process independently for each vehicle.\"\n    parts {\n      vehicle: Vehicle;\n      weighingEquipment: WeighingEquipment;\n      verificationUnit: MassVerificationUnit;\n    }\n    actions {\n      measureMass: MeasureMass;\n      processMassData: ProcessMassData;\n      determineStatus: DetermineQualificationStatus;\n    }\n  }\n  \n  satisfy (PerformMassVerification -> MassInspection) {\n    doc \"The PerformMassVerification action satisfies the MassInspection requirement.\"\n  }\n  \n  verify (MassLimit) {\n    doc \"The mass limit of 2,500 kilograms is verified through the mass verification process.\"\n  }\n}\n```",
    " ```sysml\npackage TransportationSystem {\n\n    requirement REQ_ConvenientTransportation {\n        doc \"The system shall provide end users with a convenient mode of transportation.\"\n    }\n    \n    requirement REQ_EfficientTransportation {\n        doc \"The system shall provide end users with an efficient mode of transportation.\"\n    }\n    \n    requirement REQ_DriverAndPassengers {\n        doc \"The system shall be capable of supporting a driver and up to four passengers sharing a vehicle.\"\n    }\n    \n    requirement REQ_SafeTravel {\n        doc \"The system shall enable the driver and passengers to travel safely from the starting point to the destination.\"\n    }\n    \n    requirement REQ_ComfortableTravel {\n        doc \"The system shall enable the driver and passengers to travel comfortably from the starting point to the destination.\"\n    }\n    \n    requirement REQ_EasyEntry {\n        doc \"The system shall ensure that users can freely enter the vehicle in a simple and smooth process.\"\n    }\n    \n    requirement REQ_EasyExit {\n        doc \"The system shall ensure that users can freely exit the vehicle in a simple and smooth process.\"\n    }\n    \n    requirement REQ_EnvironmentalFactors {\n        doc \"The system shall fully consider and integrate surrounding environmental factors.\"\n    }\n    \n    requirement REQ_SafeJourney {\n        doc \"The system shall ensure the safety of the entire journey.\"\n    }\n    \n    requirement REQ_SustainableJourney {\n        doc \"The system shall ensure the sustainability of the entire journey.\"\n    }\n    \n    requirement REQ_InfrastructureCompatibility {\n        doc \"The system shall be compatible with related infrastructure such as gas stations.\"\n    }\n    \n    requirement REQ_HumanCenteredOperation {\n        doc \"The system's operation shall be centered on human needs.\"\n    }\n    \n    requirement REQ_RideExperience {\n        doc \"The system shall focus on providing a good ride experience for passengers and drivers.\"\n    }\n    \n    requirement REQ_Conveniences {\n        doc \"The system shall provide various conveniences to assist passengers and drivers.\"\n    }\n    \n    requirement REQ_DailyTransportationTasks {\n        doc \"The system shall assist passengers and drivers in smoothly completing all kinds of daily transportation tasks.\"\n    }\n    \n}\n```",
    " ```\npackage TransportationSystem {\n\n  requirement 'Vehicle occupancy' {\n    doc /* The vehicle shall safely transport a driver and up to \n           four passengers from the starting point to the destination */\n  }\n\n  requirement 'Enter vehicle' {\n    doc /* The users shall enter the vehicle before the journey begins */\n  }\n  \n  requirement 'Driver operates vehicle' {\n    doc /* The driver shall operate the vehicle under the influence \n           of environmental conditions */\n  }\n  \n  requirement 'Refuel vehicle' {\n    doc /* The driver shall refuel the vehicle at a gas station as \n           needed to ensure a smooth journey */\n  }\n  \n  requirement 'Exit vehicle' {\n    doc /* Upon arrival at the destination, the driver and passengers\n           shall safely exit the vehicle */\n  }\n  \n  requirement 'Simple interactions' {\n    doc /* The system shall ensure that interactions among all \n           participants are simple and convenient */\n  }\n  \n  requirement 'Meet transportation needs' {\n    doc /* The system shall meet the primary needs of daily \n           transportation */\n  }\n\n  part def TransportationSystem {\n    part users: Users [1]\n    part vehicle: Vehicle [1]\n    part environment: Environment [1]\n    part gasStation: GasStation [0..1]\n  }\n\n  part def Users {\n    part driver: Driver [1]\n    part passengers: Passenger [0..4] \n  }\n\n  part def Vehicle {\n  }\n\n  part def Environment {\n  }\n  \n  part def GasStation {\n  }\n  \n  part def Driver {\n  }\n\n  part def Passenger {\n  }\n\n  action enterVehicle {\n    subject users\n    target vehicle\n  }\n  \n  action driveVehicle {\n    subject driver\n    target vehicle\n  }\n\n  action refuelVehicle {\n    subject driver\n    target gasStation\n  }\n\n  action exitVehicle {\n    subject users\n    from vehicle\n  }\n  \n  stm TransportScenario {\n    enterVehicle\n    driveVehicle\n    refuelVehicle?\n    driveVehicle\n    exitVehicle\n  }\n\n}\n```",
    " ```sysml\npackage VehicleConfigurationManagement {\n\n    requirement VehicleConfigurationRequirements {\n        doc \"This system is primarily designed for configuration management of the vehicle product line and aims to support the diverse requirements for engine and transmission combinations.\"\n\n        requirement CylinderRequirements {\n            doc \"Vehicles can be equipped with different types of engines, including four-cylinder and six-cylinder engines; the four-cylinder engine has 4 cylinders, while the six-cylinder engine has 6 cylinders.\"\n        }\n\n        requirement CylinderDiameterRequirements {\n            doc \"For each cylinder, the diameter can be selected as either small (70 mm) or large (100 mm).\"\n        }\n\n        requirement TransmissionRequirements {\n            doc \"Vehicles can also choose between manual and automatic transmissions, but there are strict combination constraints:\"\n            requirement ManualTransmissionConstraint {\n                doc \"manual transmissions are only allowed when a four-cylinder engine is selected,\"\n            }\n            requirement AutomaticTransmissionConstraint {\n                doc \"six-cylinder engines can only be paired with automatic transmissions; no other combinations are permitted.\"\n            }\n        }\n\n        requirement VariantSupportRequirements {\n            doc \"The system needs to flexibly support the creation of these variants while ensuring that each vehicle satisfies the above combination rules to guarantee the correctness and rationality of the product structure.\"\n        }\n    }\n\n    abstract VehicleSystem {\n        part e: Engine;\n        part t: Transmission;\n    }\n\n    abstract Engine;\n\n    part def FourCylinderEngine : Engine {\n        cylinder1: Cylinder;\n        cylinder2: Cylinder;\n        cylinder3: Cylinder;\n        cylinder4: Cylinder;\n    }\n\n    part def SixCylinderEngine : Engine {\n        cylinder1: Cylinder;\n        cylinder2: Cylinder;\n        cylinder3: Cylinder; \n        cylinder4: Cylinder;\n        cylinder5: Cylinder;\n        cylinder6: Cylinder;\n    }\n\n    abstract Cylinder {\n        value diameter: Diameter;\n    }\n\n    type Diameter;\n    \n    value SmallDiameter : Diameter = 70 [mm];\n    value LargeDiameter : Diameter = 100 [mm];\n\n    abstract Transmission;\n\n    part def ManualTransmission : Transmission;\n    part def AutomaticTransmission : Transmission;\n\n    part def Vehicle : VehicleSystem {\n        satisfies VehicleConfigurationRequirements;\n        e: Engine;\n        t: Transmission;\n\n        constraint ManualOnly {\n            guard t is ManualTransmission;\n            check e is FourCylinderEngine; \n        }\n\n        constraint AutomaticOnly {\n            guard t is AutomaticTransmission;\n            check e is SixCylinderEngine;\n        }\n    }\n}\n```",
    " ```sysml\npackage EngineSystem {\n\n    requirement EngineSystemRequirement {\n        id = \"ESR-1\"\n        text = \"This system requires the design of a configurable engine, with a basic structure composed of multiple cylinders. The number of cylinders can be either 4 or 6. Each cylinder is available in two diameters: 70 mm and 100 mm, with the specific selection depending on actual requirements. In terms of engine configurations, the system should support at least two engine variants: a four-cylinder engine and a six-cylinder engine. Users can choose the appropriate combination of cylinder quantity and diameter according to different application scenarios, thereby enabling flexible adjustment of engine performance and size.\"\n    }\n\n    part def Engine {\n        part cylinder: Cylinder [4..6]\n        part cylinderConfiguration: CylinderConfiguration [1]\n    }\n\n    part def Cylinder {\n        attribute diameter: Real\n    }\n\n    part def CylinderConfiguration {\n        attribute numberOfCylinders: Integer\n        attribute cylinderDiameter: Real\n    }\n\n    constraint CylinderDiameterConstraint {\n        Cylinder.diameter in (70.0, 100.0)\n    }\n\n    constraint NumberOfCylindersConstraint {\n        CylinderConfiguration.numberOfCylinders in (4, 6)\n    }\n\n    viewpoint EngineConfigurationView {\n        stakeholder \"User\"\n        concern \"Engine configuration\"\n\n        rendering {\n            projection EngineConfigurationTable {\n                property Engine.cylinder.diameter\n                property Engine.cylinderConfiguration.numberOfCylinders\n                property Engine.cylinderConfiguration.cylinderDiameter\n            }\n        }\n    }\n\n    satisfy EngineSystemRequirement\n}\n```",
    " ```sysml\npackage VehicleConfiguration {\n\n  class Engine {\n    numberOfCylinders : Integer\n    cylinderDiameter : Real\n  }\n\n  class FourCylinderEngine specializes Engine {\n    numberOfCylinders = 4\n    cylinderDiameter : Real\n  }\n\n  class SixCylinderEngine specializes Engine {\n    numberOfCylinders = 6\n    cylinderDiameter : Real\n  }\n  \n  class Transmission {\n  }\n  \n  class ManualTransmission specializes Transmission {\n  }\n  \n  class AutomaticTransmission specializes Transmission {\n  }\n  \n  class Vehicle {\n    engine : Engine [1]\n    transmission : Transmission [1]\n  }\n    \n  constraint FourCylinderEngineTransmission {\n    FourCylinderEngine::transmission is ManualTransmission\n  }\n\n  constraint SixCylinderEngineTransmission {\n    SixCylinderEngine::transmission is AutomaticTransmission\n  }\n\n  valuetype CylinderDiameter {\n    value : Real\n  }\n\n  val cylinderDiameterSpec1 : CylinderDiameter = {value = 70.0}\n  val cylinderDiameterSpec2 : CylinderDiameter = {value = 100.0}\n\n}\n```",
    " ```sysml\npackage System {\n\n    requirement SystemRequirements {\n        doc /* This system must be composed of a system assembly, which includes a computer subsystem and a storage subsystem. The software design section should define the message format and data format. The computer subsystem must be capable of utilizing and integrating all functions specified in the software design, while the storage subsystem must be able to access and be compatible with the message and data formats defined by the software. The software and hardware of the entire system must be able to work together seamlessly to ensure that the processes of information storage, transmission, and processing within the system are efficient, reliable, and compliant with the required data structure specifications. */\n    }\n\n    requirement ComputerSubsystemRequirement {\n        doc /* The computer subsystem must be capable of utilizing and integrating all functions specified in the software design */\n    }\n\n    requirement StorageSubsystemRequirement {\n        doc /* The storage subsystem must be able to access and be compatible with the message and data formats defined by the software */\n    }\n\n    requirement SystemIntegrationRequirement {\n        doc /* The software and hardware of the entire system must be able to work together seamlessly to ensure that the processes of information storage, transmission, and processing within the system are efficient, reliable, and compliant with the required data structure specifications. */\n    }\n\n    part def SystemAssembly {\n        part computer: ComputerSubsystem;\n        part storage: StorageSubsystem;\n    }\n\n    part def ComputerSubsystem {\n        doc /* Computer subsystem */\n        satisfy ComputerSubsystemRequirement;\n    }\n\n    part def StorageSubsystem {\n        doc /* Storage subsystem */\n        satisfy StorageSubsystemRequirement;\n    }\n\n    part def Software {\n        doc /* Software design */\n        attribute messageFormat: MessageFormat;\n        attribute dataFormat: DataFormat;\n    }\n\n    part def MessageFormat {\n        doc /* Message format defined by the software */  \n    }\n\n    part def DataFormat {\n        doc /* Data format defined by the software */\n    }\n\n    satisfy SystemRequirements;\n    \n}\n```",
    " ```sysml\npackage PowertrainSystem {\n\n    requirement AllocationAndManagement {\n        doc \"This system is designed to achieve efficient allocation and management of the powertrain system.\"\n    }\n\n    requirement LogicalLayer {\n        doc \"The powertrain system consists of a logical layer.\"\n    }\n\n    requirement PhysicalLayer {\n        doc \"The powertrain system consists of a physical layer.\"\n    }\n\n    requirement TorqueGeneratorMapping {\n        doc \"The system needs to ensure that the torque generator in the logical layer can be effectively mapped to the corresponding power unit (such as an engine) in the physical layer.\"\n    }\n\n    requirement FunctionalRequirementsRealization {\n        doc \"Through this mapping relationship, all functional requirements can be accurately realized in the physical hardware, thus ensuring that the vehicle or equipment possesses power transmission and torque output capabilities, and meets the user's core demands for power performance.\"\n    }\n\n    part def LogicalPowertrainSystem {\n        doc \"Logical components of the powertrain system.\"\n\n        part def PowerProvider {\n            doc \"Provides power.\"\n        }\n        \n        part def TorqueGenerator {\n            doc \"Converts power into torque.\"\n        }\n    }\n\n    part def PhysicalPowertrainSystem {\n        doc \"Physical components of the powertrain system.\"\n\n        part def PowerUnit {\n            doc \"Capable of both power output and torque generation.\"\n        }\n    }\n\n    requirement def TorqueGeneratorToPhysicalMapping {\n        doc \"The torque generator in the logical layer shall be mapped to a corresponding power unit in the physical layer.\"\n    }\n\n    satisfy TorqueGeneratorToPhysicalMapping {\n        doc \"Ensures effective mapping between logical and physical components.\"\n        TorqueGenerator -> PowerUnit \n    }\n\n}\n```",
    " ```sysml\npackage PowerTransmissionSystem {\n\n    requirement PowerTransmissionReq {\n        doc /* The system requires the power transmission system to provide power and generate torque. */\n    }\n\n    abstract LogicalModel {\n        capability DeliverPower {\n            doc /* The system possesses the capability to deliver power and generate torque */\n        }\n\n        abstract TorqueGenerator {\n            action GenerateTorque {\n                doc /* The action of \"generating torque\" by the torque generator component, enabling the transfer and conversion of power */\n            }\n        }\n\n        DeliverPower -> TorqueGenerator::GenerateTorque\n    }\n\n    abstract PhysicalModel {\n        abstract Powertrain {\n            part Engine {\n                perform GenerateTorqueFunction\n            }\n        }\n\n        abstract GenerateTorqueFunction {\n            doc /* The engine actually performs the function of generating torque */\n        }\n    }\n\n    allocation LogicalModelToPhysicalModel {\n        from LogicalModel::TorqueGenerator\n        to PhysicalModel::Powertrain\n\n        from LogicalModel::TorqueGenerator::GenerateTorque\n        to PhysicalModel::GenerateTorqueFunction\n    }\n\n    requirement OutputManagementReq {\n        doc /* The system as a whole must ensure, through the above division and allocation, effective generation and \n        management of power and torque to meet the practical requirements for power output during vehicle operation. */\n\n        satisfy LogicalModel::DeliverPower\n        satisfy LogicalModelToPhysicalModel\n    }\n}\n```",
    " ```sysml\npackage VehicleFeatureAnnotation {\n\n  requirement VehicleSafetyAndProtection {\n    doc /* This system is a vehicle feature annotation system, designed to identify \n           and manage the safety and anti-theft (security and protection) configurations \n           of various parts within a complete vehicle model. */\n  }\n\n  requirement BasicSafetyFeatures {\n    doc /* The vehicle should be equipped with basic safety features such as \n           seat belts, driver airbags, and bumpers. */\n  }\n\n  requirement SecurityFeatures {\n    doc /* The vehicle should have security features including anti-theft alarms \n           and keyless entry systems. */\n  }\n\n  system VehicleFeatureAnnotationSystem {\n    doc /* The system structure covers two main assemblies: the interior and \n           the body assembly. */\n\n    part interior : InteriorAssembly;\n    part body : BodyAssembly;\n\n    requirement DistributeComponents {\n      doc /* The system must clearly indicate the distribution of these components \n             within the vehicle structure and specify their respective safety or \n             protection functions. */\n    }\n\n    requirement MeetAutomotiveRequirements {\n      doc /* The system must comprehensively meet requirements for automotive safety \n             and protection, user convenience, and property security. */\n    }\n  }\n\n  part def InteriorAssembly {\n    doc /* The interior includes components such as seat belts, front seats, \n           driver airbag, and alarm system. */\n\n    part seatBelts : SeatBelt [1..*];\n    part frontSeats : FrontSeat [2]; \n    part driverAirbag : Airbag;\n    part alarmSystem : AlarmSystem;\n  }\n\n  part def BodyAssembly {\n    doc /* The body assembly includes the body shell, bumpers, and keyless entry device. */\n\n    part bodyShell : BodyShell;\n    part bumpers : Bumper [2];\n    part keylessEntry : KeylessEntryDevice; \n  }\n\n  part def SeatBelt;\n  part def FrontSeat;\n  part def Airbag;\n  part def AlarmSystem;\n  part def BodyShell;\n  part def Bumper; \n  part def KeylessEntryDevice;\n\n}\n```",
    " ```sysml\npackage VehicleDynamicsSimulation {\n\n    requirement req VehicleDynamicSimulation {\n        doc /* The system shall be capable of performing automated simulation and analysis of vehicle dynamic behavior. */\n    }\n\n    requirement req UserInputs {\n        doc /* Users should be able to input the vehicle's initial velocity, initial position, acceleration at a specific moment, and the time step. */\n\n        requirement req InitialVelocity {\n            doc /* Input the vehicle's initial velocity */\n        }\n\n        requirement req InitialPosition {\n            doc /* Input the vehicle's initial position */\n        }\n\n        requirement req Acceleration {\n            doc /* Input the vehicle's acceleration at a specific moment */\n        }\n\n        requirement req TimeStep {\n            doc /* Input the time step for the simulation */\n        }\n    }\n\n    requirement req ModelCenterIntegration {\n        doc /* Through integration with the ModelCenter analysis tool, the system shall automatically calculate and output the vehicle's velocity and position after the specified time step based on the given physical model. */\n    }\n\n    requirement req DataAccuracyAndReliability {\n        doc /* The system must ensure accurate data transfer and reliable output of simulation results */\n    }\n\n    requirement req UserConvenience {\n        doc /* Enabling users to conveniently obtain key dynamic parameters to support vehicle performance analysis and design optimization. */\n\n        requirement req OutputVelocity {\n            doc /* Output the vehicle's velocity after the specified time step */\n        }\n\n        requirement req OutputPosition {\n            doc /* Output the vehicle's position after the specified time step */\n        }\n    }\n\n    satisfy {\n        VehicleDynamicSimulation satisfiedBy UserInputs, ModelCenterIntegration, DataAccuracyAndReliability, UserConvenience;\n        UserConvenience satisfiedBy OutputVelocity, OutputPosition;\n    }\n\n}\n```",
    " ```sysml\npackage VehicleSafety {\n\n  requirement CarSafetyCompliance {\n    doc \"This system model describes the safety compliance requirements of a car.\"\n  }\n\n  requirement Interior {\n    doc \"The interior must be equipped with two mandatory seat belts, and explicitly states that the driver's airbag is not a mandatory requirement (optional).\"\n  }\n\n  part SeatBelts {\n    isMandatory = true\n    quantity = 2\n    @Safety\n  }\n  \n  part DriversAirbag {\n    isMandatory = false\n    @Safety  \n  }\n\n  requirement BodySection {\n    doc \"The bumper in the body section is set as a mandatory safety device, while the keyless entry system is not a required safety option.\"\n  }\n\n  part Bumper {\n    isMandatory = true \n    @Safety\n  }\n  \n  part KeylessEntry {\n    isMandatory = false\n  }\n\n  requirement WheelAssembly {\n    doc \"For the wheel assembly, the car is equipped with two wheels and includes an optional anti-lock braking system (ABS).\" \n  }\n  \n  part Wheels {\n    quantity = 2\n  }\n  \n  part ABS {\n    isMandatory = false\n    @Safety\n  }\n  \n  package SafetyFeatures {\n    doc \"All components marked as safety-relevant (@Safety) are recorded in Safety Features.\"\n  }\n  \n  package MandatorySafetyFeatures {\n    doc \"Only those that are both safety components and marked as mandatory (@Safety and isMandatory=true) appear in the category of Mandatory Safety Features.\"\n  }\n  \n}\n```",
    " ```sysml\npackage VehicleSafetyComplianceSystem {\n\n  requirement VehicleSafetyCompliance {\n    doc /* The vehicle safety compliance system requires that all components \n           of the vehicle possess corresponding safety features, some of which \n           are mandatory. */\n  }\n\n  part def VehicleInterior {\n    doc /* The vehicle interior must be equipped with two seat belts, \n           and both seat belts are required safety features. */\n           \n    part def DriverSeatBelt : SeatBelt;\n    part def PassengerSeatBelt : SeatBelt;\n    \n    part def DriverAirbag : Airbag {\n      isOptional;\n      doc /* The driver's airbag is an optional safety feature and is not mandatory. */\n    }\n  }\n\n  part def VehicleBody {\n    part def Bumper {\n      doc /* For the vehicle body, a bumper is required as a mandatory safety component */  \n    }\n    \n    part def KeylessEntrySystem {\n      isOptional;\n      doc /* the keyless entry system is a non-mandatory configuration. */\n    }\n  }\n   \n  part def ChassisSafety {\n    part def Tires {\n      isFixed;\n      doc /* In the chassis system, the number of tires is fixed */\n    }\n    \n    part def AntiLockBrakingSystem : ABS {\n      isOptional;\n      doc /* the anti-lock braking system (ABS) is an optional safety feature. */\n    }\n  }\n    \n  requirement SafetyPartCategorization {\n    doc /* The system categorizes and manages all safety-related parts and further \n           distinguishes which safety components are required by law or industry \n           standards and which are non-mandatory configurations, ensuring that the \n           vehicle meets fundamental safety standards while offering more optional\n           safety functions. */\n  }\n    \n  abstract part def SafetyPart;\n  \n  part def MandatorySafetyPart :> SafetyPart {\n    isMandatory;\n  }\n   \n  part def OptionalSafetyPart :> SafetyPart {\n    isOptional; \n  }\n    \n  part def SeatBelt :> MandatorySafetyPart;\n  part def Airbag :> OptionalSafetyPart;\n  part def ABS :> OptionalSafetyPart;\n    \n}\n```",
    " ```sysml\npackage RiskAndFailureManagementSystem {\n\n  requirement RiskAndFailureModelingAndManagement {\n    doc /* This system is designed for modeling and managing risks and failures. */\n  }\n\n  requirement IdentifyAndDescribeSituations {\n    doc /* It is capable of identifying and describing various possible situations, \n            the causes leading to their occurrence, and the potential failures that may result. */\n  }\n\n  requirement RecordProbabilityAndSeverity {\n    doc /* The system should be able to record the probability of each cause \n            and the severity level of each failure. */\n  }\n\n  requirement AnalyzeCausalRelationships {\n    doc /* By establishing causal relationships, it analyzes the sequence \n            and impact mechanisms among different situations. */\n  }\n\n  requirement ModelRiskScenarios {\n    doc /* In addition, the system should support comprehensive modeling of \n            different risk scenarios, enabling users to evaluate and manage \n            potential risks and failures in an all-round manner. */\n  }\n\n  requirement SupportRiskControlAndDecisionMaking {\n    doc /* This provides a basis for risk control and decision-making. */\n  }\n\n  part Situation {\n    doc /* Represents a possible situation. */\n  }\n\n  part Cause {\n    doc /* Represents a cause leading to a situation. */\n    value probability: Real;\n  }\n\n  part Failure {\n    doc /* Represents a potential failure resulting from a situation. */  \n    value severity: SeverityLevel;\n  }\n\n  enum SeverityLevel {\n    LOW,\n    MEDIUM,\n    HIGH,\n    CRITICAL\n  }\n\n  part CausalRelationship {\n    doc /* Represents a causal relationship between situations. */\n  }\n\n  part RiskScenario {\n    doc /* Represents a risk scenario. */\n    part situation: Situation[1..*];\n    part cause: Cause[0..*];\n    part failure: Failure[0..*];\n    part relationship: CausalRelationship[0..*];\n  }\n\n  RiskAndFailureModelingAndManagement satisfiedBy IdentifyAndDescribeSituations, \n                                                   RecordProbabilityAndSeverity,\n                                                   AnalyzeCausalRelationships,\n                                                   ModelRiskScenarios,\n                                                   SupportRiskControlAndDecisionMaking;\n\n}\n```",
    " package RiskMetadataModeling {\n\n  class Scenario;\n  class Cause;\n  class Failure;\n  class RiskScenario;\n\n  class Scenario {\n    description: String;\n    causes: Cause[0..*];\n    failures: Failure[0..*];\n    relatedScenarios: Scenario[0..*];\n  }\n\n  class Cause {\n    description: String;\n    probability: Real;\n    scenario: Scenario[1];\n  }\n  \n  class Failure {\n    description: String;\n    severity: FailureSeverity;\n    scenario: Scenario[1];\n  }\n  \n  enum FailureSeverity {\n    Low,\n    Medium,\n    High    \n  }\n\n  class RiskScenario {\n    description: String;\n    scenarios: Scenario[1..*];\n  }\n\n  association ScenarioCause {\n    scenario: Scenario[1];\n    cause: Cause[0..*];\n  }\n\n  association ScenarioFailure {\n    scenario: Scenario[1];\n    failure: Failure[0..*];\n  }\n  \n  association ScenarioScenario {\n    source: Scenario[0..*];\n    target: Scenario[0..*];\n  }\n\n  association RiskScenarioScenario {\n    riskScenario: RiskScenario[1];\n    scenario: Scenario[1..*];\n  }\n\n}",
    " package EquipmentRiskAnalysisSystem {\n  requirement IdentifyRisksAndFailureScenarios {\n    id = \"REQ-1\"\n    text = \"This system is designed to identify and analyze potential risks and failure scenarios that may occur in the equipment.\"\n  }\n  \n  requirement MonitorBatteryLevel {\n    id = \"REQ-2\"\n    text = \"The equipment includes key components such as batteries, and it is required to continuously monitor the battery level during operation.\"\n  }\n\n  requirement DetectBatteryAgingRisk {\n    id = \"REQ-3\"\n    text = \"When the probability of battery failure increases due to aging or other factors, the system must be able to detect such situations and identify the risk that \\\"battery aging\\\" may lead to \\\"low battery level.\\\"\"\n  }\n\n  requirement DetectLowBatteryState {\n    id = \"REQ-4\" \n    text = \"When the battery level falls below the set minimum threshold, the system should determine that the equipment is in a \\\"low battery\\\" state and further analyze the situation.\"\n  }\n  \n  requirement AnalyzeLowBatteryStatePersistence {\n    id = \"REQ-5\"\n    text = \"If this state persists for a prolonged period without recovery, the device may automatically shut down, resulting in the failure consequence of \\\"device shutdown.\\\"\"\n  }\n\n  requirement AssignSeverityLevelForHighLevelFailures {\n    id = \"REQ-6\" \n    text = \"For high-level failures that may cause the interruption of critical device functions, the system should assign an appropriate severity level in order to alert users and maintenance personnel, allowing timely intervention to mitigate potential risks and thus ensure the reliable operation of the equipment and the normal usage needs of the user.\"\n  }\n  \n  part def Battery {\n  }\n\n  part def Equipment {\n    part battery: Battery;\n  }\n  \n  state BatteryAging {\n  }\n\n  state LowBattery {\n    entry {\n      batteryLevel < minimumThreshold;\n    }\n  }\n\n  state DeviceShutdown {\n  }\n  \n  failure BatteryAgingLeadsToLowBattery {\n    cause = BatteryAging\n    effect = LowBattery \n  }\n  \n  failure ProlongedLowBatteryLeadsToShutdown {\n    cause = LowBattery\n    effect = DeviceShutdown\n  }\n}",
    " ```sysml\npackage StructuralDecompositionRequirement {\n\n  requirement StructuralDecomposition {\n    doc /* The system must possess a clear capability for structural decomposition, namely, \n           the ability to explicitly present a top-down hierarchical structure, dividing the \n           system into multiple subsystems and components, and ensuring that the functions and \n           capabilities of each level are fully covered. */\n  }\n\n  requirement WellDefinedInterfaces {\n    doc /* The interfaces between system components should be well defined, so that each\n           component can be independently understood and analyzed while also collaborating\n           effectively within the overall system. */\n  }\n\n  requirement ComprehensibilityVerifiability {\n    doc /* System engineers and parties involved in Independent Verification and Validation \n           (IV&V) must be able to use this structural view to comprehend and verify the \n           system's integrity and modular design, thereby ensuring that the system's various\n           functional and performance requirements are met. */\n  }\n\n  requirement req StructuralDecomposition {\n    satisfy WellDefinedInterfaces\n    satisfy ComprehensibilityVerifiability\n  }\n\n  systemRequirement TopLevelSystem {\n    satisfy StructuralDecomposition \n  }\n\n  system TopLevel {\n    part Sub1 : Subsystem1\n    part Sub2 : Subsystem2\n\n    req satisfy TopLevelSystem\n  }\n\n  system Subsystem1 {\n    part Comp1 : Component1\n    part Comp2 : Component2\n  }\n\n  system Subsystem2 {\n    part Comp3 : Component3  \n    part Comp4 : Component4\n  }\n\n  interface Interface1\n  interface Interface2\n\n  connection itf1: Interface1 {\n    connect TopLevel.Sub1.Comp1 to TopLevel.Sub2.Comp3\n  }\n\n  connection itf2: Interface2 {\n    connect TopLevel.Sub1.Comp2 to TopLevel.Sub2.Comp4  \n  }\n\n}\n```",
    " package AutomobileSystem {\n  import sysml:* ;\n  \n  // Top-level system component\n  component AutomobileSystem {\n    component Body;\n    component Chassis;\n    component Powertrain;\n    component Interior;\n    component SafetyComponents;\n  }\n\n  // Subsystems\n  component Body {\n    component ExteriorPanels;\n    component Doors;\n  }\n\n  component Chassis {\n    component Suspension;\n    component Brakes;\n    component Wheels;\n    component SteeringSystem;\n  }\n  \n  component Powertrain {\n    component Engine;\n    component Transmission;\n    component FuelSystem;\n  }\n  \n  component Interior {  \n    component Seats;\n    component Dashboard;\n    component HVAC;\n  }\n  \n  // Safety components  \n  component SafetyComponents {\n    SafetyComponent Seatbelts : mandatory;\n    SafetyComponent Bumpers : mandatory;\n    SafetyComponent DriverAirbag : optional;\n    SafetyComponent ABS : optional;\n  }\n\n  // Generic safety component  \n  abstract component SafetyComponent {\n    isMandatory : Boolean;\n  }\n  \n  package Views {\n    // Hierarchical component structure view\n    view HierarchicalStructure {\n      tree components AutomobileSystem, Body, Chassis, Powertrain, \n           Interior, SafetyComponents, Seatbelts, Bumpers, \n           DriverAirbag, ABS;\n    }\n\n    // Safety components view  \n    view SafetyComponentsView {\n      table safetyComponents {\n        component : SafetyComponent;\n        isMandatory : Boolean;\n      }\n      safetyComponents <- AutomobileSystem->>(SafetyComponent);\n    }\n\n    // Non-safety components view\n    view NonSafetyComponentsView {\n      table nonSafetyComponents {\n        component : Component;  \n      }\n      nonSafetyComponents <-\n        AutomobileSystem->>(Component) - AutomobileSystem->>(SafetyComponent);\n    }\n  }\n\n}",
    " ```sysml\npackage AutomobileDomain {\n\n    import SI::Quantities::*\n\n    doc \"This system model aims to provide standardized definitions and annotations for fundamental concepts and elements in the automotive domain.\"\n    part def  {\n        doc \"In the model, '' (automobile) is designated as a core component.\"\n        alias  as \"Car\" \n            doc \"The alias ' (Car)' is defined to facilitate communication and usage in various application scenarios.\"\n    }\n\n    part def  {\n        doc \"The model associates relevant physical quantities such as ' (Torque)' to ensure standardized and consistent expression of automotive characteristics.\"\n        unit \"N*m\"\n    }\n\n}\n```",
    " ```sysml\npackage AutomobileDocumentManagement {\n\n    import SI:ISQ:* // Import ISQ units from Systems International\n\n    // Automobile is the core object in the system\n    class Automobile {\n        doc \"The core object representing an automobile in the document management system\" \n    }\n\n    // Car is an alias for Automobile\n    class alias Car for Automobile {\n        doc \"An alias for Automobile, allowing flexible searching and usage by different user groups\"\n    }\n\n    // Torque is a managed physical quantity \n    class Torque {\n        value: TorqueValue {unit: N*m}\n        doc \"The torque of an automobile, using the ISQ standard unit of N*m\"\n    }\n\n    // AutomobileInfo represents various information related to an automobile\n    class AutomobileInfo {\n        automobile: Automobile\n        doc: Document [0..*]\n        torque: Torque [0..1]\n    }\n\n    // Document represents explanatory documents that can be added to objects\n    class Document {\n        content: String\n        doc \"Explanatory document that can be added to objects to provide clear annotation and traceability\"\n    }\n\n    // User represents a user of the system\n    actor User {\n        enter(info: AutomobileInfo): AutomobileInfo\n        query(criteria: String): AutomobileInfo [0..*] \n        archive(info: AutomobileInfo)\n    }\n}\n```",
    " ```sysml\npackage Automobiles {\n\n    import QUDV:ScalarValues::{ScalarValue}\n    import QUDV:Quantities::{TorqueQuantity}\n\n    type Automobile {\n        alias Car\n    }\n\n    type TorqueValue specializes ScalarValue {\n        alias Torque\n        quantity TorqueQuantity\n    }\n\n}\n```",
    " ```sysml\npackage VehicleSystem {\n  requirement def StandardVehicleEngine {\n    doc /* In standard vehicles, each engine contains 4 to 6 cylinders. */\n  }\n\n  requirement def SmallVehicleEngine {\n    doc /* For small vehicles, the engine is required to contain only 4 cylinders. */\n  }\n  \n  requirement def LargeVehicleEngine {\n    doc /* For large vehicles, the engine needs to be equipped with 6 cylinders. */\n  }\n\n  requirement def VehicleSizing {\n    doc /* The system should automatically select and configure the appropriate number of \n            engine cylinders according to the vehicle size to meet the practical application \n            requirements of different types of vehicles. */\n  }\n\n  abstract part def Vehicle {\n    part engine: Engine [1]\n  }\n\n  abstract part def Engine {\n    part cylinder: Cylinder [4..6]\n  }\n\n  part def SmallVehicle specializes Vehicle {\n    satisfy SmallVehicleEngine\n    engine is SmallEngine\n  }\n\n  part def LargeVehicle specializes Vehicle {\n    satisfy LargeVehicleEngine\n    engine is LargeEngine\n  }\n\n  part def SmallEngine specializes Engine {\n    satisfy SmallVehicleEngine\n    cylinder [4]\n  }\n\n  part def LargeEngine specializes Engine {\n    satisfy LargeVehicleEngine\n    cylinder [6]\n  }  \n\n  part def Cylinder {\n  }\n\n  part vehicleSystem {\n    satisfy VehicleSizing\n\n    part smallVehicle: SmallVehicle [0..*]\n    part largeVehicle: LargeVehicle [0..*]\n  }\n}\n```",
    " ```sysml\npackage FuelManagementSystem {\n\n  requirement FuelFlowManagement {\n    id = \"R1\"\n    text = \"The system shall be capable of managing fuel flow, ensuring that fuel can be delivered from the fuel tank to the engine and supporting fuel return.\"\n  }\n\n  requirement FuelTemperatureManagement {\n    id = \"R2\"\n    text = \"During operation, the system shall monitor and manage the temperature of the fuel.\"\n  }\n\n  requirement FuelInterfaces {\n    id = \"R3\"\n    text = \"The system shall realize fuel supply and return through fuel interfaces.\"\n  }\n\n  requirement StandardizedFuelInterfaces {\n    id = \"R4\"\n    text = \"The fuel tank and the engine shall be connected via standardized fuel interfaces to ensure the reliability and safety of fuel flow.\"\n  }\n\n  part def FuelTank {\n    id = \"FT\"\n  }\n\n  part def Engine {\n    id = \"E\"\n  }\n\n  part def FuelManagementSystem {\n    id = \"FMS\"\n  }\n\n  part def FuelSupplyInterface {\n    id = \"FSI\"\n  }\n\n  part def FuelReturnInterface {\n    id = \"FRI\"\n  }\n\n  connector def FuelSupply {\n    id = \"FS\"\n    end source FuelTank\n    end target Engine\n  }\n\n  connector def FuelReturn {\n    id = \"FR\"\n    end source Engine\n    end target FuelTank\n  }\n\n  requirement FS_Requirement {\n    id = \"FS_R\"\n    text = \"The FuelSupply connector shall conform to the FuelSupplyInterface.\"\n    satisfiedBy FuelSupply\n  }\n\n  requirement FR_Requirement {\n    id = \"FR_R\"\n    text = \"The FuelReturn connector shall conform to the FuelReturnInterface.\"\n    satisfiedBy FuelReturn\n  }\n\n  requirement FMS_Requirement {\n    id = \"FMS_R\"\n    text = \"The FuelManagementSystem shall satisfy the FuelFlowManagement, FuelTemperatureManagement, and FuelInterfaces requirements.\"\n    satisfiedBy FuelManagementSystem\n    satisfies FuelFlowManagement, FuelTemperatureManagement, FuelInterfaces\n  }\n\n}\n```",
    " ```sysml\npackage VehicleStructure {\n\n  part def Vehicle {\n    mass: Real kg\n    axles: AxleAssembly[2]\n\n    part front: AxleAssembly {\n      axle: FrontAxle\n      leftWheel: Wheel\n      rightWheel: Wheel\n    }\n\n    part rear: AxleAssembly {\n      axle: RearAxle  \n      leftWheel: Wheel\n      rightWheel: Wheel\n    }\n  }\n\n  part def AxleAssembly {\n    axle: Axle\n    wheels: Wheel[2] ordered\n  }\n\n  part def Axle {\n  }\n\n  part def FrontAxle :> Axle {\n    steeringAngle: Real deg\n  }\n\n  part def RearAxle :> Axle {\n  }\n\n  part def Wheel {\n  }\n\n}\n\npackage VehicleConfigurations {\n\n  part def Sedan :> VehicleStructure::Vehicle {\n    mass = 1750 kg\n  }\n\n  part def SUV :> VehicleStructure::Vehicle {\n    mass = 2000 kg\n  }\n  \n}\n```"
]