[
    "package VehicleSystem {\n   part def Vehicle {\n      attribute mass : Real;\n      part status : VehicleStatus[1];\n      part engine : Engine[1];\n      reference driver : Driver[0..1];\n   }\n\n   part def VehicleStatus {\n      attribute gearSetting : String;\n      attribute acceleratorPedalPosition : Real;\n   }\n\n   part def Engine { }\n\n   part def Driver { }\n}",
    "package VehicleModel {\n    block Personnel;\n    block Engine;\n\n    abstract block Vehicle;\n\n    block ManuallyOperatedVehicle extends Vehicle {\n        part driver: Personnel[1];\n    }\n\n    block PoweredVehicle extends Vehicle {\n        part engine: Engine[1];\n    }\n\n    block ManuallyOperatedPoweredVehicle extends ManuallyOperatedVehicle, PoweredVehicle;\n}",
    "package VehicleStructure [\n   abstract part def VehicleComponent;\n\n   part def Engine :> VehicleComponent;\n   part def Transmission :> VehicleComponent;\n   part def Wheel :> VehicleComponent;\n\n   abstract part def Vehicle;\n\n   part def StandardVehicle :> Vehicle {\n      part engine : Engine[1];\n      part transmission : Transmission[1];\n      part wheels : Wheel[4];\n   }\n]",
    "package VehicleSystem {\n   block Vehicle {\n      part engine : Engine;\n   }\n\n   block SmallVehicle: Vehicle {\n      part smallEngine: SmallEngine redefines engine;\n   }\n\n   block LargeVehicle: Vehicle {\n      part largeEngine: LargeEngine redefines engine;\n   }\n\n   block Engine {\n      part cylinders[1..*]: Cylinder;\n   }\n\n   block SmallEngine: Engine {\n      part smallCylinders: Cylinder[4] redefines cylinders;\n   }\n\n   block LargeEngine: Engine {\n      part largeCylinders: Cylinder[6] redefines cylinders;\n   }\n\n   block Cylinder;\n}",
    "enum TrafficLightColor {\n   Green;\n   Yellow;\n   Red;\n}\n\nblock TrafficSignal {\n   currentColor: TrafficLightColor;\n}\n\nblock AlwaysGreenTrafficSignal :> TrafficSignal {\n   constraint alwaysGreen: currentColor = TrafficLightColor::Green;\n}\n\nblock TrafficSignalSystem {\n   part generalSignal: TrafficSignal[1];\n   part fixedGreenSignal: AlwaysGreenTrafficSignal[1];\n}",
    "enum InformationLevelKind {\n   Unclassified,\n   Confidential,\n   Secret\n}\n\nclass InformationLevel {\n   level: InformationLevelKind[1];\n   code: String[1];\n   color: String[1];\n}\n\npart def InformationClassification {\n   unclassified: InformationLevel {\n      level = InformationLevelKind::Unclassified;\n      code = \"uncl\";\n      color = \"green\";\n   }\n   confidential: InformationLevel {\n      level = InformationLevelKind::Confidential;\n      code = \"conf\";\n      color = \"yellow\";\n   }\n   secret: InformationLevel {\n      level = InformationLevelKind::Secret;\n      code = \"secr\";\n      color = \"red\";\n   }\n}\n\nenum GradeLevel {\n   A,\n   B,\n   C,\n   D,\n   F\n}\n\nclass Grade {\n   level: GradeLevel[1];\n   points: Real[1];\n}\n\npart def GradeClassification {\n   a: Grade {\n      level = GradeLevel::A;\n      points = 4.0;\n   }\n   b: Grade {\n      level = GradeLevel::B;\n      points = 3.0;\n   }\n   c: Grade {\n      level = GradeLevel::C;\n      points = 2.0;\n   }\n   d: Grade {\n      level = GradeLevel::D;\n      points = 1.0;\n   }\n   f: Grade {\n      level = GradeLevel::F;\n      points = 0.0;\n   }\n}",
    "part def Cylinder;\n\nblock Engine {\n   part cylinder : Cylinder[0..*];\n}\n\nblock SmallEngine :> Engine {\n   redef part cylinder : Cylinder[4];\n}\n\nblock LargeEngine :> Engine {\n   redef part cylinder : Cylinder[6];\n}\n\nblock Vehicle {\n   part engine : Engine[1];\n}\n\nblock SmallVehicle :> Vehicle {\n   redef part engine : SmallEngine[1];\n}\n\nblock LargeVehicle :> Vehicle {\n   redef part engine : LargeEngine[1];\n}\n\nblock VehicleSystem {\n   part vehicle : Vehicle[0..*];\n}",
    "package VehicleModel {\n    part def System {\n        part vehicles : Vehicle[*];\n        part personnel : Personnel[*];\n        part fuelTypes : FuelType[*];\n    }\n\n    part def Vehicle {\n        attribute qualityAttributes : String;\n        reference driver : Driver[1];\n        part fuelTank : FuelTank[1];\n    }\n\n    part def FuelTank {\n        reference fuelType : FuelType[1];\n    }\n\n    part def FuelType {\n        attribute name : String;\n    }\n\n    part def Personnel {\n        attribute name : String;\n        attribute id : String;\n    }\n\n    part def Driver :> Personnel {\n        attribute licenseNumber : String;\n    }\n}",
    "package WheelAssemblyModel {\n    partdef WheelBearingUnit\n    partdef Bead\n    partdef Tire {\n        part leftBead: Bead [1];\n        part rightBead: Bead [1];\n    }\n    partdef Rim\n    partdef Hub {\n        part leftRim: Rim [1];\n        part rightRim: Rim [1];\n        part mountingHoles: BoltMountingHole [*];\n        part threadedHoles: ThreadedHole [*];\n    }\n    partdef BoltMountingHole\n    partdef ThreadedHole\n    partdef BoltConnection {\n        end mountingPoint: BoltMountingHole [1];\n        end threadedPoint: ThreadedHole [1];\n    }\n    partdef WheelAssembly {\n        part bearing: WheelBearingUnit [1];\n        part tire: Tire [1];\n        part hub: Hub [1];\n        part connections: BoltConnection [*] {\n            end mountingPoint: hub.mountingHoles [1];\n            end threadedPoint: hub.threadedHoles [1];\n        }\n        association beadToRimLeft: between {\n            tire.leftBead;\n            hub.leftRim;\n        }\n        association beadToRimRight: between {\n            tire.rightBead;\n            hub.rightRim;\n        }\n    }\n}",
    "package FuelFlowManagement {\n    flow specification Fuel {\n        property flowRate: Real;\n        property temperature: Real;\n    }\n\n    part def FuelTankAssembly {\n        out fuelSupply: Fuel;\n        in fuelReturn: Fuel;\n    }\n\n    part def Engine {\n        in fuelIn: Fuel;\n        out fuelReturn: Fuel;\n    }\n\n    part def FuelFlowManagementSystem {\n        part fuelTank: FuelTankAssembly;\n        part engine: Engine;\n\n        connection fuelSupply: fuelTank.fuelSupply -> engine.fuelIn {\n            flow supply: Fuel;\n        }\n        connection fuelReturn: engine.fuelReturn -> fuelTank.fuelReturn {\n            flow return: Fuel;\n        }\n\n        flow specification MonitoringData {\n            property supplyFlowRate: Real;\n            property returnFlowRate: Real;\n            property supplyTemperature: Real;\n            property returnTemperature: Real;\n        }\n\n        out monitor: MonitoringData;\n\n        constraint {\n            monitor.supplyFlowRate = fuelSupply.supply.flowRate;\n            monitor.returnFlowRate = fuelReturn.return.flowRate;\n            monitor.supplyTemperature = fuelSupply.supply.temperature;\n            monitor.returnTemperature = fuelReturn.return.temperature;\n        }\n    }\n}",
    "package VehicleConfiguration {\n   part def Tire {\n      attribute mass: Real;\n   }\n\n   part def Axle {\n      attribute mass: Real;\n      part tire[2] : Tire;\n   }\n\n   part def SteeringAxle : Axle {\n      attribute steeringAngle: Real;\n   }\n\n   part def Vehicle {\n      attribute mass: Real = 1750;\n      part front: Axle;\n      part rear: Axle;\n   }\n\n   configuration vehicle1_c1 {\n      v: Vehicle {\n         mass = 2000;\n         front = new SteeringAxle;\n         rear = new Axle;\n      }\n   }\n}",
    "package CouplingSystem {\n    interface def HitchMount {}\n    interface def BallConnector {}\n\n    part def Vehicle {\n        port mount: HitchMount;\n    }\n\n    part def Hitch {\n        port vehicleMount: HitchMount;\n        part ball: Ball;\n        port trailerConnector: BallConnector;\n        binding trailerConnector to ball.coupler;\n    }\n\n    part def Ball {\n        port coupler: BallConnector;\n    }\n\n    part def Trailer {\n        port hitchPoint: BallConnector;\n    }\n\n    part def CouplingSystem {\n        part vehicle: Vehicle;\n        part trailer: Trailer;\n        part hitch: Hitch;\n\n        connector vehicleHitch: vehicle.mount <-> hitch.vehicleMount;\n        connector hitchTrailer: hitch.trailerConnector <-> trailer.hitchPoint;\n    }\n}",
    "package VehiclePowerTransmission {\n    type ControlSignal: flow;\n    type RotationalPower: flow;\n    type TractionForce: flow;\n\n    part def Engine {\n        port fuelCommand: in ControlSignal;\n        port powerOutput: out RotationalPower;\n        port clutchInterface: out RotationalPower;\n    }\n\n    part def Transmission {\n        port engineClutch: in RotationalPower;\n        port enginePower: in RotationalPower;\n        port output: out RotationalPower;\n    }\n\n    part def Clutch {\n        port engineSide: in RotationalPower;\n        port transmissionSide: out RotationalPower;\n    }\n\n    part def Driveshaft {\n        port transmissionEnd: in RotationalPower;\n        port axleEnd: out RotationalPower;\n    }\n\n    part def Differential {\n        port input: in RotationalPower;\n        port leftOutput: out RotationalPower;\n        port rightOutput: out RotationalPower;\n    }\n\n    part def HalfShaft {\n        port differentialEnd: in RotationalPower;\n        port wheelEnd: out RotationalPower;\n    }\n\n    part def Wheel {\n        port axleInterface: in RotationalPower;\n        port roadInterface: out TractionForce;\n    }\n\n    part def RearAxleAssembly {\n        port driveshaftInput: in RotationalPower;\n        port leftOutput: out RotationalPower;\n        port rightOutput: out RotationalPower;\n\n        part differential: Differential;\n        part leftHalfShaft: HalfShaft;\n        part rightHalfShaft: HalfShaft;\n\n        connections {\n            driveshaftInput -> differential.input;\n            differential.leftOutput -> leftHalfShaft.differentialEnd;\n            differential.rightOutput -> rightHalfShaft.differentialEnd;\n            leftHalfShaft.wheelEnd -> leftOutput;\n            rightHalfShaft.wheelEnd -> rightOutput;\n        }\n    }\n\n    part def VehiclePowerTransmissionSystem {\n        part engine: Engine;\n        part transmission: Transmission;\n        part clutch: Clutch;\n        part driveshaft: Driveshaft;\n        part rearAxle: RearAxleAssembly;\n        part leftWheel: Wheel;\n        part rightWheel: Wheel;\n\n        connections {\n            engine.clutchInterface -> clutch.engineSide;\n            clutch.transmissionSide -> transmission.engineClutch;\n            engine.powerOutput -> transmission.enginePower;\n            transmission.output -> driveshaft.transmissionEnd;\n            driveshaft.axleEnd -> rearAxle.driveshaftInput;\n            rearAxle.leftOutput -> leftWheel.axleInterface;\n            rearAxle.rightOutput -> rightWheel.axleInterface;\n        }\n    }\n}",
    "package SystemModel {\n   interface def pe {}\n   interface def pf {}\n\n   part def ComponentC1 {\n      port pb : pe;\n   }\n\n   part def ComponentC2 {\n      port port_x : pe;\n   }\n\n   part def ComponentC3 {\n      port pd : pf;\n   }\n\n   part def ComponentC4 {\n      port port_y : pf;\n   }\n\n   part def SubsystemB11 {\n      part c1 : ComponentC1;\n      part c2 : ComponentC2;\n      port pb_ext : pe;\n      binding path binding1: pb_ext to c1.pb;\n      connector conn1: c1.pb to c2.port_x;\n   }\n\n   part def SubsystemB12 {\n      part c3 : ComponentC3;\n      part c4 : ComponentC4;\n      port pd_ext : pf;\n      binding path binding1: pd_ext to c3.pd;\n      connector conn1: c3.pd to c4.port_y;\n   }\n\n   part def SystemDecomposition1 {\n      part b11 : SubsystemB11;\n      part b12 : SubsystemB12;\n      connector conn_b11_b12: b11.pb_ext to b12.pd_ext;\n   }\n\n   part def ModuleB21 {\n      part c1 : ComponentC1;\n      part c2 : ComponentC2;\n   }\n\n   part def ModuleB22 {\n      part c3 : ComponentC3;\n      part c4 : ComponentC4;\n   }\n\n   part def SystemDecomposition2 {\n      part b21 : ModuleB21;\n      part b22 : ModuleB22;\n      connector conn_b21_b22: b21.c1.pb to b22.c3.pd;\n   }\n}",
    "package PowertrainModel {\n   value type FuelCommand {\n      value: Real;\n   }\n\n   enum StartStopCommand {\n      start,\n      stop\n   }\n\n   value type Torque {\n      value: Real;\n   }\n\n   part def Engine {\n      in fuelCommand: FuelCommand;\n      in startStop: StartStopCommand;\n      out torqueOutput: Torque;\n   }\n\n   part def Transmission {\n      in torqueInput: Torque;\n      out torqueOutput: Torque;\n   }\n\n   part def Driveshaft {\n      in torqueInput: Torque;\n      out leftOutput: Torque;\n      out rightOutput: Torque;\n   }\n\n   part def Wheel {\n      in torqueInput: Torque;\n   }\n\n   part def PowertrainSystem {\n      in fuelCommand: FuelCommand;\n      in startStop: StartStopCommand;\n\n      part engine: Engine;\n      part transmission: Transmission;\n      part driveshaft: Driveshaft;\n      part leftWheel: Wheel;\n      part rightWheel: Wheel;\n\n      engine.fuelCommand = fuelCommand;\n      engine.startStop = startStop;\n      engine.torqueOutput -> transmission.torqueInput;\n      transmission.torqueOutput -> driveshaft.torqueInput;\n      driveshaft.leftOutput -> leftWheel.torqueInput;\n      driveshaft.rightOutput -> rightWheel.torqueInput;\n   }\n}",
    "package AutomotivePowertrain {\n    part def AutomotivePowertrainControlSystem {\n        attribute fuelControlCommand : Boolean;\n        attribute stallSignal : Boolean;\n        attribute engineRunning : Boolean;\n        attribute wheelTorque : Real;\n\n        constraint PowerTransmissionSequence {\n            requirementId: \"R2\";\n            expression: \n                if fuelControlCommand then\n                    engineRunning and\n                    eventually (wheelTorque > 0)\n                else true;\n        }\n\n        constraint StallResponse {\n            requirementId: \"R3\";\n            expression: \n                when stallSignal then\n                    not engineRunning and\n                    wheelTorque == 0\n                within 500ms;\n        }\n\n        state def OperationalState {\n            state Off;\n            state Starting;\n            state Running;\n            state Halting;\n\n            transition from Off to Starting on fuelControlCommand;\n            transition from Starting to Running on engineRunning;\n            transition from Running to Halting on stallSignal;\n            transition from Halting to Off on wheelTorque==0;\n        }\n\n        action def StartEngine {\n            in fuelCommand : Boolean;\n            out engineStatus : Boolean;\n            requirementId: \"R1\";\n        }\n\n        action def GenerateTorque {\n            in engineStatus : Boolean;\n            out baseTorque : Real;\n        }\n\n        action def AmplifyTorque {\n            in baseTorque : Real;\n            out amplifiedTorque : Real;\n        }\n\n        action def TransmitTorque {\n            in amplifiedTorque : Real;\n            out transmittedTorque : Real;\n        }\n\n        action def DistributeTorque {\n            in transmittedTorque : Real;\n            out wheelTorque : Real;\n            requirementId: \"R2\";\n        }\n\n        action def Shutdown {\n            in stallSignal : Boolean;\n            out engineStatus : Boolean;\n            requirementId: \"R4\";\n        }\n\n        activity def PowerTransmission {\n            requirementId: \"R5\";\n            param fuelCommand : Boolean;\n            param stallSignal : Boolean;\n            param wheelOutput : Real;\n\n            sequence {\n                StartEngine(fuelCommand, engineRunning);\n                GenerateTorque(engineRunning, baseTorque);\n                AmplifyTorque(baseTorque, amplifiedTorque);\n                TransmitTorque(amplifiedTorque, transmittedTorque);\n                DistributeTorque(transmittedTorque, wheelOutput);\n            } interrupt when stallSignal {\n                Shutdown(stallSignal, engineRunning);\n            }\n        }\n    }\n\n    requirement def R1 {\n        id: \"R1\";\n        text: \"Upon receiving a fuel control command, the system sequentially starts the engine and generates torque\";\n    }\n\n    requirement def R2 {\n        id: \"R2\";\n        text: \"The generated torque is then successively amplified, transmitted, and distributed, delivering power to the drive wheels\";\n    }\n\n    requirement def R3 {\n        id: \"R3\";\n        text: \"When a stall signal is detected, the relevant operational processes will be halted\";\n    }\n\n    requirement def R4 {\n        id: \"R4\";\n        text: \"The system supports engine start and shutdown control\";\n    }\n\n    requirement def R5 {\n        id: \"R5\";\n        text: \"The system supports the entire power transmission process from fuel commands to actual wheel output torque\";\n    }\n}",
    "package VehiclePowertrain {\n   part engine : Engine;\n   part transmission : Transmission;\n   part distributor : TorqueDistributor;\n   parts wheels : Wheel[4];\n\n   activity ManagePowertrain {\n      input fuelCommand : Real;\n      input startSignal : Boolean;\n      input shutdownSignal : Boolean;\n\n      // Wait for engine start signal\n      accept event when startSignal;\n\n      // Main torque management loop\n      while not shutdownSignal {\n         // Generate engine torque based on fuel command\n         engineTorque : Real = engine.generateTorque(fuelCommand);\n         \n         // Amplify torque through transmission\n         amplifiedTorque : Real = transmission.amplifyTorque(engineTorque);\n         \n         // Distribute torque to all wheels\n         distributor.distribute(amplifiedTorque, wheels);\n      }\n   }\n\n   block Engine {\n      operation generateTorque(fuelInput : Real) : Real;\n   }\n\n   block Transmission {\n      operation amplifyTorque(inputTorque : Real) : Real;\n   }\n\n   block TorqueDistributor {\n      operation distribute(totalTorque : Real, targetWheels : Wheel[*]);\n   }\n\n   block Wheel {\n      attribute receivedTorque : Real;\n   }\n}",
    "package HitchingSystem {\n   part def VehicleFrame;\n   part def TrailerFrame;\n   part def HitchBall;\n   part def TrailerCoupler;\n\n   part def Vehicle {\n      part frame : VehicleFrame;\n      part hitch : HitchBall;\n   }\n\n   part def Trailer {\n      part frame : TrailerFrame;\n      part coupler : TrailerCoupler;\n   }\n\n   association def HitchConnection {\n      end1 ball : HitchBall[0..1];\n      end2 coupler : TrailerCoupler[0..1];\n   }\n\n   part def VehicleTrailerSystem {\n      part vehicle : Vehicle;\n      part trailer : Trailer;\n      reference connection : HitchConnection[0..1] {\n         from vehicle.hitch;\n         to trailer.coupler;\n      }\n   }\n}",
    "package VehicleTrailerSystem {\n    partdef Vehicle {\n        part chassis: Chassis;\n        part towBall: TowBall;\n    }\n\n    partdef Trailer {\n        part frame: TrailerFrame;\n        part coupler: Coupler;\n    }\n\n    partdef Chassis;\n    partdef TowBall;\n    partdef TrailerFrame;\n    partdef Coupler;\n\n    systemdef TrailerManagementSystem {\n        part vehicle: Vehicle[1];\n        part trailer: Trailer[1];\n        connector physicalConnection: vehicle.towBall <-> trailer.coupler;\n    }\n}",
    "package TrailerHitchSystem {\n    partdef Vehicle {\n        part chassis: Chassis;\n    }\n\n    partdef Chassis {\n        part towBall: TowBall;\n    }\n\n    partdef TowBall;\n\n    partdef Trailer {\n        part trailerChassis: TrailerChassis;\n    }\n\n    partdef TrailerChassis {\n        part coupler: Coupler;\n    }\n\n    partdef Coupler {\n        behavior engage(in target: TowBall);\n        behavior disengage();\n        reference connectedTowBall: TowBall[0..1];\n    }\n\n    partdef DynamicConnectionSystem {\n        part vehicle: Vehicle;\n        part trailer: Trailer;\n\n        behavior hitch() {\n            do vehicle.chassis.towBall->then (tb: TowBall) {\n                do trailer.trailerChassis.coupler.engage(tb);\n            }\n        }\n\n        behavior unhitch() {\n            do trailer.trailerChassis.coupler.disengage();\n        }\n    }\n\n    constraint CouplerEngagement {\n        coupler: Coupler;\n        towBall: TowBall;\n        when: coupler.connectedTowBall = towBall {\n            comment \"Securely latched when connected\";\n        }\n        else {\n            comment \"Smoothly separated when disconnected\";\n        }\n    }\n}",
    "package FuelSystem {\n   part def FuelTank {\n      port fuelOut: out FuelFlow;\n      port fuelIn: in FuelFlow;\n   }\n\n   part def Engine {\n      port fuelIn: in FuelFlow;\n      port fuelOut: out FuelFlow;\n   }\n\n   block FuelSystem {\n      part tank: FuelTank;\n      part engine: Engine;\n\n      connector supplyLine: tank.fuelOut -> engine.fuelIn;\n      connector returnLine: engine.fuelOut -> tank.fuelIn;\n\n      constraint SafetyMonitoring {\n         requirement \"Monitor fuel temperature during flow\";\n         param fuelTemp: Real;\n         constraint tempRange: fuelTemp >= -40 and fuelTemp <= 120;\n      }\n   }\n\n   flow specification FuelFlow {\n      flow fuel: Fluid;\n   }\n\n   item type Fluid {\n      attribute temperature: Real;\n   }\n}",
    "package FuelDeliverySystem {\n   value type Volume {\n      unit: 'liter';\n      value: Real;\n   }\n\n   block Fuel {\n   }\n\n   port def FuelPort {\n   }\n\n   block StorageTank {\n      value capacity: Volume;\n      value currentLevel: Volume;\n      port output: FuelPort;\n   }\n\n   block FuelPump {\n      port input: FuelPort;\n      port output: FuelPort;\n   }\n\n   block VehicleFuelTank {\n      value maxCapacity: Volume;\n      value currentLevel: Volume;\n      port input: FuelPort;\n   }\n\n   block FuelDeliverySystem {\n      part storageTank: StorageTank;\n      part fuelPump: FuelPump;\n      part vehicleFuelTank: VehicleFuelTank;\n\n      connector from storageTank.output to fuelPump.input;\n      connector from fuelPump.output to vehicleFuelTank.input;\n\n      item flow Fuel on storageTank.output->fuelPump.input->vehicleFuelTank.input;\n   }\n}",
    "part def Vehicle {\n   part gearbox: Gearbox[0..1];\n   part engine: Engine[0..1];\n}\n\npart def BaseVehicle: Vehicle {\n   constraint noParts: 'gearbox = null and engine = null';\n}\n\npart def VehicleWithGearbox: Vehicle {\n   constraint hasGearbox: 'gearbox <> null and engine = null';\n}\n\npart def FullyAssembledVehicle: Vehicle {\n   constraint fullyAssembled: 'gearbox <> null and engine <> null';\n}\n\npart def Gearbox {\n   // Functional unit for power transmission\n}\n\npart def Engine {\n   // Functional unit for power generation\n}\n\nactivity def FinalAssembly {\n   in baseVehicle: BaseVehicle;\n   in newGearbox: Gearbox;\n   in newEngine: Engine;\n   out assembledVehicle: FullyAssembledVehicle;\n\n   action installGearbox {\n      in base: BaseVehicle;\n      in gb: Gearbox;\n      out intermediate: VehicleWithGearbox;\n   }\n\n   action installEngine {\n      in intermediate: VehicleWithGearbox;\n      in eng: Engine;\n      out complete: FullyAssembledVehicle;\n   }\n\n   object flow baseVehicle -> installGearbox.base;\n   object flow newGearbox -> installGearbox.gb;\n   object flow installGearbox.intermediate -> installEngine.intermediate;\n   object flow newEngine -> installEngine.eng;\n   object flow installEngine.complete -> assembledVehicle;\n}",
    "package VehicleControlSystem {\n  part def VehicleA;\n\n  event startSignal;\n  event vehicleOnSignal;\n  event overTemperature;\n  event restoreToNormalSignal;\n  event shutdownSignal;\n\n  state machine {\n    state Off;\n    state Starting;\n    state Running {\n      entry / {\n        perform self-checks;\n        supply power to VehicleA;\n      }\n      exit / {\n        automatically apply parking brake;\n      }\n    };\n    state HealthManagement;\n    state Degraded;\n    state Maintenance;\n    state Normal;\n\n    Off -> Starting: startSignal [brakePedalPressed] / {};\n    Starting -> Running: vehicleOnSignal / {};\n    Running -> Degraded: overTemperature / {\n      send overTemperatureSignal to controller;\n    };\n    Degraded -> Normal: restoreToNormalSignal / {};\n    Normal -> Running: / {};\n    Running -> HealthManagement: / {};\n    HealthManagement -> Normal: / {};\n    Running -> Off: shutdownSignal / {};\n  }\n}",
    "package VehicleSystem {\n   part def Vehicle {\n      attributes:\n         fuelLevel: Real;\n         maintenanceInterval: Time;\n         temperatureThreshold: Real;\n         currentTemperature: Real;\n         brakePedalPressed: Boolean;\n      events:\n         startSignalReceived: Event;\n         shutdownSignalReceived: Event;\n         overheatDetected: Event;\n         maintenanceRequired: Event;\n         recoveryComplete: Event;\n      requires:\n         controller: VehicleController;\n      state machine {\n         state Shutdown;\n         state Starting {\n            entry / {\n               performSelfInspection();\n               performPowerSupply();\n            }\n         };\n         state Normal;\n         state Degraded;\n         state Maintenance;\n         state Fault;\n         transition from Shutdown to Starting on startSignalReceived [brakePedalPressed];\n         transition from Starting to Normal when (selfInspectionComplete and powerSupplyComplete);\n         transition from Normal to Degraded on overheatDetected {\n            effect / {\n               controller.handleWarning(new overheatWarning);\n            }\n         };\n         transition from Normal to Maintenance on maintenanceRequired;\n         transition from Maintenance to Normal when maintenanceComplete;\n         transition from Fault to Normal on recoveryComplete;\n         transition from any to Shutdown on shutdownSignalReceived;\n      }\n   }\n\n   part def VehicleController {\n      operations:\n         handleWarning(in warning: overheatWarning);\n         sendStartSignal();\n         sendShutdownSignal();\n   }\n\n   signal overheatWarning;\n\n   part def VehicleSystem {\n      parts:\n         vehicle: Vehicle;\n         controller: VehicleController;\n      connections:\n         controlLink: controller -> vehicle;\n   }\n}",
    "package VehicleSimulation {\n   enum VehicleState {\n      on,\n      off\n   }\n\n   block Vehicle {\n      attribute mass: Real;\n      attribute position: Real;\n      attribute velocity: Real;\n      attribute acceleration: Real;\n      attribute state: VehicleState;\n   }\n\n   block Road {\n      attribute slope: Real;\n      attribute frictionCoefficient: Real;\n   }\n\n   value type VehicleStateValue {\n      mass: Real;\n      position: Real;\n      velocity: Real;\n      acceleration: Real;\n      state: VehicleState;\n   }\n\n   value type RoadStateValue {\n      slope: Real;\n      frictionCoefficient: Real;\n   }\n\n   block Snapshot {\n      value time: Real;\n      value vehicle: VehicleStateValue;\n      value road: RoadStateValue;\n   }\n\n   block VehicleDynamicsSimulator {\n      part vehicle: Vehicle;\n      part road: Road;\n      part history: Snapshot[*];\n   }\n}",
    "part Component1;\npart Component2;\npart Component3;\npart Component4;\npart Component5;\npart Component6;\n\npart SubsystemA {\n    configuration ConfigA1 {\n        part comp1: Component1;\n        part comp2: Component2;\n    }\n    configuration ConfigA2 {\n        part comp2: Component2;\n        part comp3: Component3;\n    }\n}\n\npart SubsystemB {\n    configuration ConfigB1 {\n        part comp4: Component4;\n        part comp5: Component5;\n    }\n    configuration ConfigB2 {\n        part comp5: Component5;\n        part comp6: Component6;\n    }\n}\n\npart Automobile {\n    part subA: SubsystemA;\n    part subB: SubsystemB;\n    \n    constraint ConfigConstraint {\n        if subA.selected = SubsystemA.ConfigA2 \n        then subB.selected = SubsystemB.ConfigB1;\n    }\n}\n\nconfiguration ConfigurationA for Automobile {\n    subA.selected = SubsystemA.ConfigA1;\n    subB.selected = SubsystemB.ConfigB1;\n}\n\nconfiguration ConfigurationB for Automobile {\n    subA.selected = SubsystemA.ConfigA2;\n    subB.selected = SubsystemB.ConfigB1;\n}",
    "package ModularVehiclePlatform {\n    abstract part def VehicleComponent;\n\n    part def part1:> VehicleComponent;\n    part def part2:> VehicleComponent;\n    port def p1;\n    part def part3:> VehicleComponent {\n        port :> p1;\n    }\n    part def part4:> VehicleComponent;\n    port def p2;\n    behavior def part5Behavior;\n    part def part5:> VehicleComponent {\n        port :> p2;\n        behavior :> part5Behavior;\n    }\n    part def part6:> VehicleComponent;\n\n    part def SubsystemA {\n        part comp: VehicleComponent [0..*];\n        port sysPort:> p1;\n    }\n\n    part def SubsystemB {\n        part comp: VehicleComponent [0..*];\n        port sysPort:> p2;\n    }\n\n    part def VehicleSystem {\n        part subsystemA: SubsystemA;\n        part subsystemB: SubsystemB;\n        connect subsystemA.sysPort <-> subsystemB.sysPort;\n    }\n\n    configuration def VehicleConfigA {\n        part subsystemA {\n            comp = {part1, part2, part3};\n        }\n        part subsystemB {\n            comp = {part4, part5, part6};\n        }\n    }\n\n    configuration def VehicleConfigB {\n        part subsystemA {\n            comp = {part3, part4};\n        }\n        part subsystemB {\n            comp = {part5, part6};\n        }\n    }\n\n    constraint def SystemConstraint {\n        param totalWeight: Real;\n        param maxCapacity: Real;\n        constraint: totalWeight <= maxCapacity;\n    }\n}",
    "package VehicleProductLine {\n   enum PerformanceRequirement {\n      High;\n      Standard\n   }\n\n   enum EngineType {\n      V6; // 6-cylinder\n      I4  // 4-cylinder\n   }\n\n   enum TransmissionType {\n      Automatic;\n      Manual\n   }\n\n   enum WheelType {\n      WideRim;\n      NarrowRim\n   }\n\n   part def Engine {\n      attribute type: EngineType;\n   }\n\n   part def Transmission {\n      attribute type: TransmissionType;\n   }\n\n   part def Wheel {\n      attribute type: WheelType;\n   }\n\n   value allowedConfigurations: Set(Tuple(PerformanceRequirement, EngineType, TransmissionType, WheelType)) = {\n      (PerformanceRequirement::High, EngineType::V6, TransmissionType::Automatic, WheelType::WideRim),\n      (PerformanceRequirement::Standard, EngineType::I4, TransmissionType::Manual, WheelType::NarrowRim)\n   };\n\n   part def Vehicle {\n      attribute performanceReq: PerformanceRequirement;\n      part engine: Engine;\n      part transmission: Transmission;\n      part wheel: Wheel;\n\n      constraint ComponentCompatibility {\n         (performanceReq, engine.type, transmission.type, wheel.type) in allowedConfigurations\n      }\n   }\n}",
    "package AutomobileSpecificationSystem {\n    part def Vehicle {\n        attribute mass : kg;\n        attribute fuelStatus : FuelStatus;\n        attribute reliability : Reliability;\n\n        requirement MassRequirement {\n            requirement id 'REQ-MASS';\n            text \"Vehicle must reflect actual mass and comply with maximum mass limitations to prevent overloading.\";\n        }\n\n        requirement FuelStatusRequirement {\n            requirement id 'REQ-FUEL';\n            text \"Vehicle must meet mass requirements in specified fuel state (fully fueled or empty).\";\n        }\n\n        requirement ReliabilityRequirement {\n            requirement id 'REQ-REL';\n            text \"Vehicle must possess specified performance and durability throughout lifecycle.\";\n        }\n    }\n\n    part def Engine {\n        attribute outputTorque : N⋅m;\n\n        requirement PowerOutputRequirement {\n            requirement id 'REQ-ENG';\n            text \"Engine must output torque for power delivery.\";\n        }\n    }\n\n    part def Transmission {}\n\n    interface DriveInterface {\n        connector engineToTransmission : Engine -> Transmission;\n    }\n\n    requirement PowertrainRequirement {\n        requirement id 'REQ-POW';\n        text \"Engine must connect to transmission via drive interface to ensure reliable power transfer.\";\n        satisfy {\n            verify {\n                validate \"Power transfer validation\" {\n                    case \"Check torque transmission\" : \"Verify torque delivery through interface\";\n                }\n            }\n        }\n    }\n\n    requirement SystemRequirement {\n        requirement id 'REQ-SYS';\n        text \"System must define/manage vehicle specifications including mass, fuel status, powertrain, and reliability.\";\n        decompose {\n            Vehicle::MassRequirement;\n            Vehicle::FuelStatusRequirement;\n            Vehicle::ReliabilityRequirement;\n            Engine::PowerOutputRequirement;\n            PowertrainRequirement;\n        }\n    }\n\n    enum FuelStatus {\n        FULLY_FUELED,\n        EMPTY\n    }\n\n    value type kg {\n        unit kilogram;\n    }\n\n    value type N⋅m {\n        unit newton_meter;\n    }\n\n    value type Reliability {\n        attribute meanTimeBetweenFailures : hours;\n        attribute lifecycleDuration : years;\n    }\n\n    constraint MaxMassConstraint {\n        constraint id 'CONST-MASS';\n        expression \"mass <= maxMass\";\n        parameter mass : kg;\n        parameter maxMass : kg;\n        satisfy Vehicle::MassRequirement;\n    }\n\n    allocation {\n        allocate PowertrainRequirement to DriveInterface;\n        allocate Vehicle::ReliabilityRequirement to Vehicle;\n        allocate Engine::PowerOutputRequirement to Engine;\n    }\n\n    verification MassVerification {\n        verify Vehicle::MassRequirement {\n            method \"Weigh vehicle under specified conditions\";\n        }\n    }\n\n    verification FuelVerification {\n        verify Vehicle::FuelStatusRequirement {\n            method \"Measure mass at required fuel state\";\n        }\n    }\n}",
    "package VehicleMassCompliance {\n    value type Mass {\n        :> value: Real;\n        :> unit: String = 'kg';\n    }\n\n    block Vehicle {\n        :> maxPermissibleMass: Mass;\n        :> actualMass: Mass?;\n    }\n\n    activity MeasureMass {\n        :> inout vehicle: Vehicle;\n    }\n\n    activity VerifySingleVehicleCompliance {\n        :> inout v: Vehicle;\n        :> out isCompliant: Boolean;\n\n        action measure: CallBehaviorAction {\n            :> behavior = MeasureMass;\n            :> argument = v;\n        }\n\n        expression compare: Boolean {\n            :> = v.actualMass.value <= v.maxPermissibleMass.value;\n        }\n\n        assignment setResult: {\n            :> isCompliant = compare;\n        }\n    }\n\n    activity TestMultipleVehicles {\n        :> in vehicles: Vehicle[*];\n        :> out results: Boolean[*];\n\n        local index: Integer = 0;\n        local allResults: Boolean[0..*] = [];\n\n        loop: While (condition: index < vehicles->size()) {\n            expression currentVehicle: Vehicle {\n                :> = vehicles->at(index);\n            }\n\n            action verify: CallBehaviorAction {\n                :> behavior = VerifySingleVehicleCompliance;\n                :> argument = currentVehicle;\n                :> result isCompliant: Boolean;\n            }\n\n            expression append: {\n                :> allResults = allResults->append(verify.isCompliant);\n            }\n\n            expression increment: {\n                :> index = index + 1;\n            }\n        }\n\n        assignment setOutput: {\n            :> results = allResults;\n        }\n    }\n\n    block VehicleMassComplianceSystem {\n        :> performs TestMultipleVehicles;\n    }\n}",
    "package WaterSupplyNetwork {\n    interface Water;\n    interface HotWater : Water;\n    interface ColdWater : Water;\n\n    part def SpigotBank {\n        port hotSupply: output HotWater[1..*];\n        port coldSupply: output ColdWater[1..*];\n    }\n\n    part def Faucet {\n        port hotInlet: input HotWater;\n        port coldInlet: input ColdWater;\n    }\n\n    part def WaterSupplySystem {\n        part mainSupply: SpigotBank;\n        parts faucets: Faucet[1..*];\n\n        connector hotNetwork: \n            mainSupply.hotSupply -> faucets.hotInlet;\n        connector coldNetwork: \n            mainSupply.coldSupply -> faucets.coldInlet;\n\n        constraint sufficientHotSpigots: \n            mainSupply.hotSupply->size() >= faucets->size();\n        constraint sufficientColdSpigots: \n            mainSupply.coldSupply->size() >= faucets->size();\n    }\n}",
    "package VehicleQualityAnalysis {\n   part def Vehicle {\n      part engine : Engine;\n      part transmission : Transmission;\n      part frontAxle : FrontAxleAssembly;\n      part rearAxle : RearAxleAssembly;\n\n      value totalMass : Real;\n      constraint MassAggregation {\n         totalMass = engine.mass + transmission.mass + frontAxle.mass + rearAxle.mass\n      }\n\n      action aggregateMass() {\n         totalMass = engine.mass + transmission.mass + frontAxle.mass + rearAxle.mass\n      }\n   }\n\n   part def Engine {\n      value mass : Real;\n   }\n\n   part def Transmission {\n      value mass : Real;\n   }\n\n   part def FrontAxleAssembly {\n      value mass : Real;\n   }\n\n   part def RearAxleAssembly {\n      value mass : Real;\n   }\n\n   requirement QualityAnalysisRequirement {\n      id = \"QR1\";\n      text = \"Evaluate vehicle quality attributes and optimize design\";\n   }\n\n   use case QualityAnalysisUseCase {\n      action inputComponentData {\n         in engineMass : Real;\n         in transmissionMass : Real;\n         in frontAxleMass : Real;\n         in rearAxleMass : Real;\n      }\n      action defineAnalysisObjectives;\n      action generateAnalysisPlan;\n      action performComprehensiveEvaluation;\n   }\n\n   satisfy QualitySatisfaction {\n      requirement = QualityAnalysisRequirement;\n      design = QualityAnalysisUseCase;\n   }\n\n   action GenerateAnalysisTasks {\n      in analysisObjectives : String;\n      out analysisPlan : String;\n      out evaluationReport : String;\n   }\n\n   activity QualityAnalysisWorkflow {\n      action inputData : QualityAnalysisUseCase::inputComponentData;\n      action defineObjectives : QualityAnalysisUseCase::defineAnalysisObjectives;\n      action generatePlan : QualityAnalysisUseCase::generateAnalysisPlan;\n      action performEvaluation : QualityAnalysisUseCase::performComprehensiveEvaluation;\n      edge inputData -> defineObjectives;\n      edge defineObjectives -> generatePlan;\n      edge generatePlan -> performEvaluation;\n   }\n\n   analysis def VehicleQualityAnalysis {\n      subject Vehicle;\n      case QualityAnalysisUseCase;\n      objective QualityAnalysisRequirement;\n      method GenerateAnalysisTasks;\n      result totalMass : Real;\n   }\n}",
    "package VehiclePowertrainConfiguration {\n   part def VehiclePowertrainConfigurationSystem {\n      attribute : Engine[0..*];\n      attribute : selectedEngine : Engine[0..1];\n      attribute : evaluationModel : EngineEvaluation[1];\n\n      part def components {\n         part cylinder : Cylinder[1..*];\n         part piston : Piston[1..*];\n         part connectingRod : ConnectingRod[1..*];\n         part crankshaft : Crankshaft[1];\n      }\n\n      requirement \"OptimizeEngineSelection\" {\n         id: 'REQ1';\n         text: \"Recommend optimal engine configuration balancing power, mass, efficiency, reliability, and cost\";\n      }\n\n      requirement \"ProvideSelectionRationale\" {\n         id: 'REQ2';\n         text: \"Display engine selection rationale ensuring transparency and traceability\";\n      }\n\n      constraint \"TradeOffAnalysis\" {\n         requirement = \"OptimizeEngineSelection\";\n         param engine : Engine[0..*];\n         param bestEngine : Engine[0..1];\n         expr: bestEngine = engine->maxBy(e | evaluationModel.evaluate(e));\n      }\n\n      action \"AssembleComponents\" {\n         inout targetEngine : Engine;\n         expr: targetEngine.cylinders = components.cylinder;\n         expr: targetEngine.pistons = components.piston;\n         expr: targetEngine.connectingRods = components.connectingRod;\n         expr: targetEngine.crankshaft = components.crankshaft;\n      }\n\n      action \"RecommendEngine\" {\n         out recommendation : Engine[1];\n         expr: recommendation = selectedEngine;\n         satisfy \"OptimizeEngineSelection\";\n      }\n\n      action \"DisplayRationale\" {\n         in engine : Engine[1];\n         out rationale : Rationale[1];\n         expr: rationale = engine.justification;\n         satisfy \"ProvideSelectionRationale\";\n      }\n   }\n\n   part def Engine {\n      abstract;\n      value power : Power;\n      value mass : Mass;\n      value efficiency : Efficiency;\n      value reliability : Reliability;\n      value cost : Cost;\n      attribute justification : Rationale[1];\n      part cylinders : Cylinder[4..12];\n      part pistons : Piston[4..12];\n      part connectingRods : ConnectingRod[4..12];\n      part crankshaft : Crankshaft[1];\n   }\n\n   part FourCylinderEngine :> Engine {\n      part cylinders : Cylinder[4];\n      part pistons : Piston[4];\n      part connectingRods : ConnectingRod[4];\n   }\n\n   part SixCylinderEngine :> Engine {\n      part cylinders : Cylinder[6];\n      part pistons : Piston[6];\n      part connectingRods : ConnectingRod[6];\n   }\n\n   part Cylinder;\n   part Piston;\n   part ConnectingRod;\n   part Crankshaft;\n\n   value type Power: Real (unit: 'kW');\n   value type Mass: Real (unit: 'kg');\n   value type Efficiency: Real (unit: '%', min: 0, max: 100);\n   value type Reliability: Real (min: 0, max: 10);\n   value type Cost: Real (unit: 'USD');\n   value type Rationale: Text;\n\n   constraint def EngineEvaluation {\n      param candidate : Engine;\n      result score : Real;\n      expr: score = (candidate.power * 0.3) + \n                   (candidate.efficiency * 0.25) + \n                   (candidate.reliability * 0.2) - \n                   (candidate.mass * 0.15) - \n                   (candidate.cost * 0.1);\n   }\n}",
    "package FuelEconomyModel {\n   unit mile;\n   unit usGallon;\n   derived unit milesPerUSGallon = mile / usGallon;\n   unit pound;\n\n   value type FuelEconomy {\n      unit: milesPerUSGallon;\n   }\n   value type Load {\n      unit: pound;\n   }\n\n   requirement UrbanFuelEconomyRequirement {\n      id = \"REQ-1\";\n      text = \"Under urban driving conditions, the vehicle’s range per gallon must not be less than 25 miles\";\n      constraint minUrban : FuelEconomy = 25;\n   }\n\n   requirement HighwayFuelEconomyRequirement {\n      id = \"REQ-2\";\n      text = \"Under highway conditions, the vehicle’s range per gallon must not be less than 30 miles\";\n      constraint minHighway : FuelEconomy = 30;\n   }\n\n   requirement TestConditionRequirement {\n      id = \"REQ-3\";\n      text = \"Fuel economy tests are conducted with the vehicle assuming an additional load of 1,000 pounds\";\n      constraint testLoad : Load = 1000;\n   }\n\n   block Vehicle {\n      value property baseLoad : Load;\n      value property currentLoad : Load;\n      value property fuelEconomyUrban : FuelEconomy;\n      value property fuelEconomyHighway : FuelEconomy;\n   }\n\n   block Powertrain;\n\n   block OperatingConditions {\n      attribute conditionType : String;\n   }\n\n   block VehicleFuelEconomySystem {\n      part powertrain : Powertrain;\n      part operatingConditions : OperatingConditions;\n      part vehicle : Vehicle;\n\n      satisfy UrbanFuelEconomyRequirement {\n         constraint = vehicle.fuelEconomyUrban >= UrbanFuelEconomyRequirement.minUrban;\n      }\n      satisfy HighwayFuelEconomyRequirement {\n         constraint = vehicle.fuelEconomyHighway >= HighwayFuelEconomyRequirement.minHighway;\n      }\n      satisfy TestConditionRequirement {\n         constraint = vehicle.currentLoad == vehicle.baseLoad + TestConditionRequirement.testLoad;\n      }\n   }\n}",
    "package VehicleLongitudinalDynamics {\n    structure PowerSegment {\n        startTime: Real;\n        endTime: Real;\n        power: Real;\n    }\n\n    block VehicleSimulationSystem {\n        attribute mass: Real;\n        attribute initialPosition: Real;\n        attribute initialVelocity: Real;\n        attribute powerSegments: PowerSegment[*];\n        attribute accelerationSequence: Sequence<Real>;\n        attribute velocitySequence: Sequence<Real>;\n        attribute displacementSequence: Sequence<Real>;\n\n        operation runSimulation(in timeStep: Real);\n    }\n}",
    "package VehicleModel {\n   partdef Vehicle {\n      value property totalMass : Real = 2500.0;\n      part frontAxle : FrontAxleAssembly [1];\n      part rearAxle : RearAxleAssembly [1];\n   }\n\n   partdef FrontAxleAssembly {\n      value property mass : Real = 150.0;\n      part wheel : FrontWheel [2];\n      part axle : FrontAxle [1];\n   }\n\n   partdef RearAxleAssembly {\n      value property mass : Real = 250.0;\n      part wheel : RearWheel [2];\n      part axle : RearAxle [1];\n   }\n\n   partdef FrontWheel { }\n\n   partdef RearWheel { }\n\n   partdef FrontAxle {\n      value property mass : Real;\n      value property steeringAngle : Real;\n   }\n\n   partdef RearAxle {\n      value property mass : Real;\n   }\n}",
    "package VehicleSafetySecurity {\n   abstract def Feature;\n\n   def SafetyFeature :> Feature;\n   def SecurityFeature :> Feature;\n\n   def MandatorySafetyFeature :> SafetyFeature;\n   def OptionalSafetyFeature :> SafetyFeature;\n\n   def SeatBelt :> MandatorySafetyFeature;\n   def Bumper :> MandatorySafetyFeature;\n   def Airbag :> OptionalSafetyFeature;\n   def AntiLockBrakingSystem :> OptionalSafetyFeature;\n   def Alarm :> SecurityFeature;\n   def KeylessEntrySystem :> SecurityFeature;\n\n   def Vehicle {\n      part seatBelt: SeatBelt;\n      part airbag: Airbag;\n      part bumper: Bumper;\n      part abs: AntiLockBrakingSystem;\n      part alarm: Alarm;\n      part keylessEntry: KeylessEntrySystem;\n   }\n\n   def VehicleSafetySecuritySystem {\n      reference target: Vehicle;\n\n      requirement displayReq:\n         \"Filter, organize, and visualize vehicle components by safety/security features using tree/table views, enabling review of safety configurations with mandatory/non-mandatory distinction\";\n\n      satisfy displayReq;\n   }\n}",
    "package Model {\n   part def ApplicationLayer;\n   part def ServiceLayer;\n   part def DataLayer;\n\n   block System {\n      attributes: {\n         x: Real;\n         y: Real;\n         z: Real;\n      }\n\n      parts: {\n         applicationLayer: ApplicationLayer;\n         serviceLayer: ServiceLayer;\n         dataLayer: DataLayer;\n      }\n\n      dependencies: {\n         appToService: dependency applicationLayer -> serviceLayer;\n         serviceToData: dependency serviceLayer -> dataLayer;\n      }\n\n      constraint: {\n         zDependency: {\n            ZConstraint;\n         }\n      }\n\n      bindings: {\n         bind x to zDependency.x;\n         bind y to zDependency.y;\n         bind z to zDependency.z;\n      }\n   }\n\n   constraint block ZConstraint {\n      parameters: {\n         x: Real;\n         y: Real;\n         z: Real;\n      }\n      constraints: {\n         expr: constraint = 'z = f(x, y)';\n      }\n   }\n}",
    "package PowertrainModel {\n   part def PowertrainSystem {\n      part engine: Engine;\n      performedActivity: GenerateTorque;\n   }\n\n   part def Engine {\n      performedActivity: GenerateTorque;\n   }\n\n   activity GenerateTorque {\n      output torque: Real {\n         unit: newton * meter;\n      }\n   }\n\n   requirement TorqueRequirement {\n      id: \"REQ1\";\n      text: \"Torque produced during operation must be greater than zero newton-meters\";\n      constraint torquePositive {\n         expression: torque > 0;\n      }\n   }\n\n   satisfy PowertrainSystem satisfies TorqueRequirement;\n}",
    "package Model {\n   part def PowerSystem {\n      part torqueGenerator: TorqueGenerator;\n      part powertrain: Powertrain;\n      action generateTorque: GenerateTorque;\n      action providePower: ProvidePower;\n      action transmitPower: TransmitPower;\n      action outputPower: OutputPower;\n      generateTorque.performance = torqueGenerator;\n      allocate generateTorque to powertrain.engine;\n   }\n\n   part def TorqueGenerator { }\n\n   part def Powertrain {\n      part engine: Engine;\n   }\n\n   part def Engine { }\n\n   action def GenerateTorque { }\n\n   action def ProvidePower { }\n\n   action def TransmitPower { }\n\n   action def OutputPower { }\n}",
    "package VehicleSafetyAndAntiTheftCatalogue {\n    feature Safety;\n    feature AntiTheft;\n\n    part def Component;\n\n    part def BasicSafetyComponent:> Component {\n        feature: Safety;\n    }\n\n    part def SecurityComponent:> Component {\n        feature: AntiTheft;\n    }\n\n    part def DualFunctionComponent:> Component {\n        feature: Safety;\n        feature: AntiTheft;\n    }\n\n    part def MandatorySafetyComponent:> BasicSafetyComponent;\n\n    part def SeatBelt:> MandatorySafetyComponent;\n    part def Bumper:> MandatorySafetyComponent;\n    part def Airbag:> BasicSafetyComponent;\n    part def AntiLockBrakingSystem:> BasicSafetyComponent;\n    part def AlarmSystem:> SecurityComponent;\n    part def KeylessEntrySystem:> SecurityComponent;\n\n    part def Vehicle {\n        part safetyComponents: BasicSafetyComponent[*];\n        part securityComponents: SecurityComponent[*];\n        part dualComponents: DualFunctionComponent[*];\n        part mandatorySafety: MandatorySafetyComponent[*];\n    }\n\n    requirement req {\n        requirementId: \"REQ-1\";\n        text: \"Vehicle must include basic safety components: front seat belts and bumpers\";\n    }\n\n    requirement req {\n        requirementId: \"REQ-2\";\n        text: \"Vehicle should include security components: alarm system and keyless entry\";\n    }\n\n    satisfy seatBeltSatisfaction {\n        satisfiedRequirement = req->select(id == \"REQ-1\");\n        satisfyingFeature = Vehicle::mandatorySafety->select(oclIsKindOf(SeatBelt));\n    }\n\n    satisfy bumperSatisfaction {\n        satisfiedRequirement = req->select(id == \"REQ-1\");\n        satisfyingFeature = Vehicle::mandatorySafety->select(oclIsKindOf(Bumper));\n    }\n\n    satisfy securitySatisfaction {\n        satisfiedRequirement = req->select(id == \"REQ-2\");\n        satisfyingFeature = Vehicle::securityComponents;\n    }\n}",
    "package FuelSystem {\n    item type Fluid;\n    item type TemperatureData;\n\n    block FuelTank {\n        port in returnInlet: Fluid;\n        port out fuelOutlet: Fluid;\n        port out tempOutput: TemperatureData;\n    }\n\n    block FuelPump {\n        port in fuelInlet: Fluid;\n        port out supplyOutlet: Fluid;\n    }\n\n    block FuelTankAssembly {\n        part tank: FuelTank;\n        part pump: FuelPump;\n        \n        port in returnInlet: Fluid = tank.returnInlet;\n        port out supplyOutlet: Fluid = pump.supplyOutlet;\n        port out tempOutput: TemperatureData = tank.tempOutput;\n        \n        connection fuelTransfer: tank.fuelOutlet -> pump.fuelInlet;\n    }\n\n    block FuelConsumingUnits {\n        port in fuelSupply: Fluid;\n        port out fuelReturn: Fluid;\n    }\n\n    system FuelSupplySystem {\n        part tankAssembly: FuelTankAssembly;\n        part consumingUnits: FuelConsumingUnits;\n        \n        port out tempData: TemperatureData = tankAssembly.tempOutput;\n        \n        connection supplyLine: tankAssembly.supplyOutlet -> consumingUnits.fuelSupply {\n            item flow fuel: Fluid;\n        }\n        \n        connection returnLine: consumingUnits.fuelReturn -> tankAssembly.returnInlet {\n            item flow returnFuel: Fluid;\n        }\n    }\n}",
    "package VehicleSystem {\n   part def SeatBelt;\n   part def Airbag;\n   part def AntiTheftAlarm;\n   part def Bumper;\n   part def KeylessEntry;\n   part def Wheel;\n   part def AntiLockBrakingSystem;\n\n   block Interior {\n      parts: \n         seatBelt: SeatBelt[2];\n         airbag: Airbag[0..1];\n         antiTheftAlarm: AntiTheftAlarm[0..1];\n   }\n\n   block Body {\n      parts: \n         bumper: Bumper[1];\n         keylessEntry: KeylessEntry[1];\n   }\n\n   block Chassis {\n      parts: \n         wheel: Wheel[2];\n         antiLockBrakingSystem: AntiLockBrakingSystem[0..2];\n   }\n\n   block Vehicle {\n      parts: \n         interior: Interior;\n         body: Body;\n         chassis: Chassis;\n   }\n\n   requirement SafetySecurityCompliance {\n      id: \"REQ-1\";\n      text: \"The vehicle interior must be equipped with two seat belts, which are mandatory safety features.\";\n   }\n   requirement AirbagInstallation {\n      id: \"REQ-2\";\n      text: \"An airbag should also be installed in the cockpit, but its application is not mandatory.\";\n   }\n   requirement AntiTheftRequirement {\n      id: \"REQ-3\";\n      text: \"An anti-theft alarm device should be installed inside the vehicle to enhance security protection.\";\n   }\n   requirement BumperRequirement {\n      id: \"REQ-4\";\n      text: \"The vehicle body must be equipped with a bumper, which is a required safety component.\";\n   }\n   requirement KeylessEntryRequirement {\n      id: \"REQ-5\";\n      text: \"The vehicle body is required to have a keyless entry system to improve security performance.\";\n   }\n   requirement WheelRequirement {\n      id: \"REQ-6\";\n      text: \"The chassis structure is to be fitted with two wheels.\";\n   }\n   requirement ABSRequirement {\n      id: \"REQ-7\";\n      text: \"The chassis structure is to be equipped with two sets of anti-lock braking systems, although the installation of such braking systems is not mandatory.\";\n   }\n   requirement ComponentManagement {\n      id: \"REQ-8\";\n      text: \"All safety and security components must undergo identification and classification management to ensure regulatory compliance for critical functions.\";\n   }\n\n   Vehicle satisfies SafetySecurityCompliance;\n   Vehicle satisfies AirbagInstallation;\n   Vehicle satisfies AntiTheftRequirement;\n   Vehicle satisfies BumperRequirement;\n   Vehicle satisfies KeylessEntryRequirement;\n   Vehicle satisfies WheelRequirement;\n   Vehicle satisfies ABSRequirement;\n   Vehicle satisfies ComponentManagement;\n}",
    "part VehicleSafetyAndSecurityComponentSystem {\n    part interior: Interior;\n    part bodyAssembly: BodyAssembly;\n}\n\npart Interior {\n    part alarmSystem: AlarmSystem;\n    part seatBelts: SeatBelts;\n    part frontRowSeats: FrontRowSeats;\n    part driversAirbag: Airbag;\n}\n\npart BodyAssembly {\n    part vehicleBody: VehicleBody;\n    part bumper: Bumper;\n    part keylessEntrySystem: KeylessEntrySystem;\n}\n\nconcern Safety;\nconcern Security;\n\nVehicleSafetyAndSecurityComponentSystem {\n    concern safety: Safety;\n    concern security: Security;\n    \n    safety.include(interior.seatBelts);\n    safety.include(interior.driversAirbag);\n    safety.include(bodyAssembly.bumper);\n    \n    security.include(interior.alarmSystem);\n    security.include(bodyAssembly.keylessEntrySystem);\n}\n\npart AlarmSystem;\npart SeatBelts;\npart FrontRowSeats;\npart Airbag;\npart VehicleBody;\npart Bumper;\npart KeylessEntrySystem;",
    "enum SecurityClassification {\n   Unclassified,\n   Confidential,\n   Secret\n}\n\npart def Component {\n   attr: SecurityClassification classification [1];\n}\n\npart def System {\n   action def DisplayClassification {\n      in component: Component [1];\n   }\n}",
    "package AutomotiveECUModel {\n   block VehicleControlUnit {\n      port busConnection: Port;\n      port sensorData: Port[*];\n   }\n\n   block EngineControlUnit {\n      port busConnection: Port;\n      port sensorData: Port[*];\n   }\n\n   block BusInterface {\n      port unitSide: Port;\n      port busSide: Port;\n   }\n\n   block CANBus {\n      port busPort: Port[*];\n   }\n\n   block AutomotiveECUSystem {\n      part vcu: VehicleControlUnit;\n      part ecu: EngineControlUnit;\n      part vcuBusIF: BusInterface;\n      part ecuBusIF: BusInterface;\n      part canBus: CANBus;\n\n      connection vcuToBusIF: vcu.busConnection -> vcuBusIF.unitSide;\n      connection busIFToCAN: vcuBusIF.busSide -> canBus.busPort;\n      connection ecuToBusIF: ecu.busConnection -> ecuBusIF.unitSide;\n      connection ecuBusIFToCAN: ecuBusIF.busSide -> canBus.busPort;\n   }\n}",
    "package BloodGlucoseMeter {\n   requirement HighReliabilitySafety {\n      id = \"REQ-1\";\n      text = \"Ensure high reliability and safety during use\";\n   }\n\n   requirement BatteryStatusDetection {\n      id = \"REQ-2\";\n      text = \"Automatically detect battery depletion or charging failure\";\n   }\n\n   requirement UserAlert {\n      id = \"REQ-3\";\n      text = \"Promptly alert user during battery failure to prevent measurement failure and treatment delays\";\n   }\n\n   requirement PreventiveMeasures {\n      id = \"REQ-4\";\n      text = \"Implement preventive measures for battery status\";\n   }\n\n   requirement AlarmEmergencyResponse {\n      id = \"REQ-5\";\n      text = \"Provide alarm and emergency response mechanisms for measurement abnormalities\";\n   }\n\n   requirement RiskManagement {\n      id = \"REQ-6\";\n      text = \"Establish management measures for key risk scenarios to ensure timely, continuous, and safe therapeutic support\";\n   }\n\n   HighReliabilitySafety :> {\n      BatteryStatusDetection,\n      UserAlert,\n      PreventiveMeasures,\n      AlarmEmergencyResponse,\n      RiskManagement\n   }\n\n   part def BloodGlucoseMeter {\n      part battery : Battery;\n\n      action DetectBatteryStatus {\n         requirement = BatteryStatusDetection;\n      }\n\n      action AlertUser {\n         requirement = UserAlert;\n      }\n\n      action ImplementPreventiveMeasures {\n         requirement = PreventiveMeasures;\n      }\n\n      action TriggerAlarm {\n         requirement = AlarmEmergencyResponse;\n      }\n\n      action ManageRisks {\n         requirement = RiskManagement;\n      }\n   }\n\n   part def Battery {\n      attribute status : String;\n      state def OperationalState {\n         state Charged;\n         state Depleted;\n         state ChargingFailure;\n      }\n   }\n}",
    "package ScientificConstants {\n   const e: Real = 2.71828182845904523536;\n   const pi: Real = 3.14159265358979323846;\n   \n   const speedOfLight: Real (unit = m/s) = 299792458.0;\n   const fineStructureConstant: Real = 0.0072973525693;\n   const electronProtonMassRatio: Real = 0.000544617021;\n   \n   const gravitationalAccelerationEarth: Real (unit = m/s^2) = 9.80665;\n   const amplifierGainModelX: Real (unit = 1) = 10.5;\n}",
    "package AutomotiveComponents {\n   part def Tire {\n      attribute manufacturer: String;\n      attribute rimDiameter: Real;\n      attribute width: Integer;\n      attribute country: String;\n   }\n\n   instance michelinTire: Tire {\n      manufacturer = \"Michelin\";\n      rimDiameter = 18.0;\n      width = 245;\n      country = \"French\";\n   }\n}",
    "import Units::SI;\nimport Units::USCustomary;\n\npart def Vehicle {\n    attribute mass: Real[1] { unit = SI::kg; } = 1200;\n    attribute length: Real[1] { unit = SI::m; } = 4.82;\n    part leftFront: Wheel[1];\n    part rightFront: Wheel[1];\n}\n\npart def Wheel {\n    attribute hubDiameter: Real[1] { unit = USCustomary::inch; } = 18;\n    attribute width: Real[1] { unit = SI::mm; } = 245;\n    attribute /outerDiameter: Real[1] { unit = USCustomary::inch; };\n    part tire: Tire[1];\n    \n    constraint OuterDiameterComputation {\n        outerDiameter = hubDiameter + 2 * (tire.height -> convert(USCustomary::inch));\n    }\n}\n\npart def Tire {\n    attribute height: Real[1] { unit = SI::mm; };\n}",
    "package PowertrainConfiguration {\n   part def PowertrainConfigurationSystem;\n\n   part def Vehicle {\n      attribute isHighPerformance : Boolean;\n      part powertrain : Powertrain;\n   }\n\n   part def Powertrain {\n      part engine : Engine;\n      part transmission : Transmission;\n   }\n\n   abstract part def Engine;\n   part def FourCylinderEngine :> Engine;\n   part def SixCylinderEngine :> Engine;\n\n   abstract part def Transmission;\n   part def ManualTransmission :> Transmission;\n   part def AutomaticTransmission :> Transmission;\n\n   constraint HighPerformanceEngineConstraint for Vehicle {\n      constraint: (isHighPerformance implies (powertrain.engine : SixCylinderEngine)) and \n                  (not isHighPerformance implies (powertrain.engine : FourCylinderEngine));\n   }\n\n   constraint ValidCombinationConstraint for Powertrain {\n      constraint: (engine : FourCylinderEngine and transmission : ManualTransmission) or \n                  (engine : SixCylinderEngine and transmission : AutomaticTransmission);\n   }\n}",
    "package AutomotiveComponents {\n   part def Car {\n      attribute mass: Real (unit: kg) = 1200.0;\n      attribute length: Real (unit: m) = 4.82;\n      part wheelAssembly: WheelAssembly[4];\n   }\n\n   part def WheelAssembly {\n      part wheel: Wheel;\n      part brakeDisc: BrakeDisc;\n      constraint brakeDiscClearance {\n         brakeDisc.diameter < wheel.outerDiameter\n      }\n   }\n\n   part def Wheel {\n      part rim: Rim;\n      part tire: Tire;\n      attribute outerDiameter: Real (unit: mm);\n      constraint calcOuterDiameter {\n         outerDiameter = rim.diameter * 25.4 + 2 * tire.height\n      }\n   }\n\n   part def Rim {\n      attribute diameter: Real (unit: inch) = 18.0;\n   }\n\n   part def Tire {\n      attribute width: Real (unit: mm) = 245.0;\n      attribute height: Real (unit: mm) = 45.0;\n      attribute defaultTreadDepth: Real (unit: mm) = 6.0;\n      attribute minTreadDepth: Real (unit: mm) = 3.5;\n      attribute treadDepth: Real (unit: mm) = defaultTreadDepth;\n      constraint treadSafety {\n         treadDepth >= minTreadDepth\n      }\n   }\n\n   part def BrakeDisc {\n      attribute radius: Real (unit: mm) = 95.0;\n      attribute diameter: Real (unit: mm) = 2 * radius;\n   }\n}",
    "package AutomotiveFuelSystem {\n    import Systems::SystemsLibrary::*\n    import Items::ItemsLibrary::*\n    import Values::ValuesLibrary::*\n\n    item Fuel\n\n    value type Temperature {\n        unit: °C\n    }\n\n    block AutomotiveFuelSystem {\n        part fuelTankAssembly: FuelTankAssembly\n\n        requirement {\n            id: 'REQ1'\n            text: \"Fuel shall circulate efficiently and safely among all components\"\n        }\n        requirement {\n            id: 'REQ2'\n            text: \"System shall meet vehicle's overall requirements for fuel supply and return functions\"\n        }\n        requirement {\n            id: 'REQ3'\n            text: \"System shall ensure normal fuel supply to the engine\"\n        }\n    }\n\n    block FuelTankAssembly {\n        part fuelTank: FuelTank\n        part fuelPump: FuelPump\n\n        port fuelDeliveryPort: out ItemPort<Fuel>\n        port fuelReturnPort: in ItemPort<Fuel>\n        port temperaturePort: out Temperature\n\n        connector fuelTank.fuelOutlet -> fuelPump.fuelInlet\n        connector fuelPump.fuelDelivery -> fuelDeliveryPort\n        connector fuelReturnPort -> fuelPump.fuelReturn\n        connector fuelTank.temperaturePort -> temperaturePort\n    }\n\n    block FuelTank {\n        port fuelOutlet: out ItemPort<Fuel>\n        port temperaturePort: out Temperature\n        attribute temperature: Temperature\n\n        binding temperaturePort to temperature\n    }\n\n    block FuelPump {\n        port fuelInlet: in ItemPort<Fuel>\n        port fuelDelivery: out ItemPort<Fuel>\n        port fuelReturn: in ItemPort<Fuel>\n    }\n}",
    "package PhysicalQuantitySystem {\n   import Units::*;\n\n   quantity kind Length;\n   quantity kind Mass;\n   quantity kind Time;\n   quantity kind ElectricCurrent;\n   quantity kind Temperature;\n   quantity kind AmountOfSubstance;\n   quantity kind LuminousIntensity;\n\n   unit meter: Length;\n   unit kilogram: Mass;\n   unit second: Time;\n   unit ampere: ElectricCurrent;\n   unit kelvin: Temperature;\n   unit mole: AmountOfSubstance;\n   unit candela: LuminousIntensity;\n\n   part def QuantityManager {\n      attribute baseQuantities: QuantityKind[7] = {\n         Length, Mass, Time, ElectricCurrent, \n         Temperature, AmountOfSubstance, LuminousIntensity\n      };\n      attribute supportedUnits: Unit[*] = {\n         meter, kilogram, second, ampere, \n         kelvin, mole, candela\n      };\n\n      operation importQuantity(q: QuantityKind);\n      operation extendSystem(newUnit: Unit, forQuantity: QuantityKind);\n      operation convertValue(\n         value: Real, \n         sourceUnit: Unit, \n         targetUnit: Unit\n      ): Real;\n      operation validateConsistency();\n   }\n\n   part manager: QuantityManager;\n}",
    "package StandardUnitSystemLibrary {\n   quantity Length;\n   quantity Mass;\n   quantity Time;\n   quantity Force;\n   quantity Temperature;\n\n   unit Meter: Length;\n   unit Kilogram: Mass;\n   unit Second: Time;\n   unit Newton: Force;\n   unit Kelvin: Temperature;\n\n   unit Foot: Length;\n   unit PoundMass: Mass;\n   unit PoundForce: Force;\n   unit Fahrenheit: Temperature;\n\n   conversion Foot to Meter: 0.3048;\n   conversion PoundMass to Kilogram: 0.45359237;\n   conversion PoundForce to Newton: 4.4482216152605;\n   conversion Fahrenheit to Kelvin: (x - 32) * 5/9 + 273.15;\n\n   unit system ISQ {\n      base units: Meter for Length, Kilogram for Mass, Second for Time, Kelvin for Temperature;\n      derived units: Newton = Kilogram * Meter / (Second ^ 2);\n   }\n\n   unit system USCustomaryUnits {\n      base units: Foot for Length, PoundMass for Mass, Second for Time, Fahrenheit for Temperature;\n      derived units: PoundForce = PoundMass * Foot / (Second ^ 2);\n   }\n}",
    "package HeadlampTiltAdjustment {\n   unit rad;\n   unit deg;\n   conversion deg: rad = (pi/180);\n\n   constant pi: Real = 3.141592653589793;\n\n   value type TiltAngle {\n      value: Real;\n      unit: deg;\n   }\n\n   block HeadlampSystem {\n      attribute beamTiltAngle: TiltAngle;\n   }\n\n   constraint block TiltAngleConstraint {\n      parameter angle: TiltAngle;\n      constraint validRange: angle.value >= 50.0 and angle.value <= 80.0;\n   }\n\n   block VerificationSystem {\n      reference headlamp: HeadlampSystem;\n      constraint tiltCheck: TiltAngleConstraint {\n         angle = headlamp.beamTiltAngle;\n      }\n   }\n}",
    "package CoreDataTypes {\n    type UnsignedInteger: Integer {\n        constraint { self >= 0 }\n    }\n    \n    type UnsignedFloat: Real {\n        constraint { self >= 0.0 }\n    }\n    \n    enum StatusLevel {\n        critical,\n        warning,\n        normal\n    }\n    \n    type Status {\n        level: StatusLevel;\n        color: String {\n            derives from {\n                if level == StatusLevel::critical then \"red\"\n                else if level == StatusLevel::warning then \"yellow\"\n                else \"green\"\n            }\n        }\n    }\n    \n    enum DiameterOption {\n        Small,\n        Medium,\n        Large\n    }\n    \n    type Diameter {\n        option: DiameterOption;\n        value: Real {\n            derives from {\n                if option == DiameterOption::Small then 60.0\n                else if option == DiameterOption::Medium then 70.0\n                else 80.0\n            }\n        }\n        default option = DiameterOption::Small;\n    }\n}",
    "package CollectionManagement {\n   import SysML::Libraries::PrimitiveValueTypes;\n\n   type SparePart;\n   type Person;\n\n   system SparePartManagementSystem {\n      attribute spareParts: Bag<SparePart>;\n      attribute integerStorage: List<Integer>;\n      attribute stringManagement: Set<String>;\n      attribute personnelManagement: OrderedSet<Person>;\n      attribute nestedCollections: List<Set<Person>>;\n      attribute realNumberProcessing: Real[4];\n   }\n}",
    "unit inch;\n\nstructure Vector3D {\n    attribute x: Real;\n    attribute y: Real;\n    attribute z: Real;\n}\n\nstructure def Tire {\n    attribute manufacturer: String;\n    attribute rimDiameter: Real[1] (unit = inch);\n    attribute tireWidth: Integer[1];\n    attribute installationPosition: Vector3D[0..1];\n}",
    "unit s;\nunit m;\nunit m_per_s = m / s;\n\nvalue type Vector3D {\n   attribute x: Real;\n   attribute y: Real;\n   attribute z: Real;\n}\n\npart def SamplingPoint {\n   attribute time: Real (unit: s);\n   attribute position: Vector3D (unit: m);\n   attribute velocity: Vector3D (unit: m_per_s);\n}\n\npart def Trajectory {\n   attribute points: Sequence<SamplingPoint> [1];\n}\n\npart def Mission {\n   attribute liftoffTime: String;\n   attribute ascentTrajectory: Trajectory [1];\n}\n\npart def TrajectoryRecordingSystem {\n   reference targetMission: Mission [1];\n}",
    "package MaterialsScience {\n   import Units::*;\n\n   unit u; // Unified atomic mass unit\n   unit N_per_mm2 = newton / (millimeter^2); // Derived unit for tensile strength\n\n   type Substance {\n      name: String;\n      atomicMass: Real[0..1] {\n         unit: u;\n      }\n      tensileStrength: Real[0..1] {\n         unit: N_per_mm2;\n      }\n   }\n\n   part def Composition {\n      constituent: Substance[1];\n      massFraction: Real[1] {\n         unit: 1; // Unitless fraction\n      }\n   }\n\n   type Alloy extends Substance {\n      compositions: Composition[2..*]; // Requires ≥2 components\n   }\n\n   part iron: Substance {\n      name = \"Iron\";\n      atomicMass = 55.845 u;\n      tensileStrength = 200 N_per_mm2;\n   }\n\n   part carbon: Substance {\n      name = \"Carbon\";\n      atomicMass = 12.011 u;\n   }\n\n   part manganese: Substance {\n      name = \"Manganese\";\n      atomicMass = 54.938 u;\n   }\n\n   part steel980: Alloy {\n      name = \"Steel 980\";\n      compositions = {\n         Composition {\n            constituent = iron;\n            massFraction = 0.98;\n         },\n         Composition {\n            constituent = carbon;\n            massFraction = 0.02;\n         }\n      };\n      tensileStrength = 980 N_per_mm2;\n   }\n}",
    "dimension Pressure;\nunit Pa for Pressure;\nunit MPa = 10^6 Pa for Pressure;\nunit N_per_mm_sq = 10^6 Pa for Pressure;\n\npart def Constituent {\n    property massFraction: Real[0..1];\n    ref material: Material;\n}\n\nblock Material {\n    property name: String;\n    property tensileStrength: Real[Pressure]?;\n}\n\nblock Element extends Material {\n    property atomicMass: Real;\n}\n\nblock Alloy extends Material {\n    part constituent: Constituent[*];\n}\n\nblock EngineeringMaterialsDatabaseSystem;\n\npart sys: EngineeringMaterialsDatabaseSystem {\n    part iron: Element {\n        name = \"Iron\";\n        atomicMass = 55.845;\n    }\n    part carbon: Element {\n        name = \"Carbon\";\n        atomicMass = 12.011;\n    }\n    part manganese: Element {\n        name = \"Manganese\";\n        atomicMass = 54.938;\n    }\n    part steel_980: Alloy {\n        name = \"Steel_980\";\n        constituent = [\n            new Constituent {\n                massFraction = 0.98;\n                material = iron\n            },\n            new Constituent {\n                massFraction = 0.01;\n                material = carbon\n            },\n            new Constituent {\n                massFraction = 0.01;\n                material = manganese\n            }\n        ];\n        tensileStrength = 980 N_per_mm_sq;\n    }\n}",
    "package PubSubSystem {\n   interface PublisherService {\n      in publish(topic: String, content: String);\n   }\n\n   interface SubscriptionService {\n      in subscribe(topic: String, delivery: DeliveryService);\n   }\n\n   interface DeliveryService {\n      in deliver(topic: String, content: String);\n   }\n\n   part Producer {\n      port pub: out PublisherService;\n   }\n\n   part Consumer {\n      port delivery: in DeliveryService;\n      port sub: out SubscriptionService;\n   }\n\n   part Server {\n      port publisher: in PublisherService;\n      port subscription: in SubscriptionService;\n   }\n\n   partdef PubSubSystem {\n      part producers: Producer[1..*];\n      part server: Server;\n      part consumers: Consumer[1..*];\n\n      connector pubConn: producers[*].pub to server.publisher;\n      connector subConn: consumers[*].sub to server.subscription;\n   }\n}",
    "package FuelSystem {\n   value type Temperature {\n      unit: '°C';\n   }\n\n   item def Fuel {\n      attribute temp: Temperature;\n   }\n\n   port def FuelPort;\n\n   connector def FuelLine;\n\n   block FuelTankAssembly {\n      port supplyPort: FuelPort;\n      port returnPort: FuelPort;\n   }\n\n   block Engine {\n      port fuelInlet: FuelPort;\n      port fuelOutlet: FuelPort;\n   }\n\n   block VehicleFuelSystem {\n      part fuelTank: FuelTankAssembly;\n      part engine: Engine;\n\n      connector supply: FuelLine;\n      connector return: FuelLine;\n\n      connection supplyLine: FuelLine between fuelTank.supplyPort, engine.fuelInlet via supply;\n      connection returnLine: FuelLine between engine.fuelOutlet, fuelTank.returnPort via return;\n\n      item flow fuelSupply: Fuel on supplyLine from fuelTank to engine;\n      item flow fuelReturn: Fuel on returnLine from engine to fuelTank;\n   }\n}",
    "package PubSubSystem {\n    interface IServerConsumer {\n        in signal subscriptionRequest(topic: String);\n        out signal messageDelivery(topic: String, content: String);\n    }\n\n    interface IServerProducer {\n        in signal messagePublication(topic: String, content: String);\n    }\n\n    block Producer {\n        conjugated proxy port server: IServerProducer;\n    }\n\n    block Consumer {\n        conjugated proxy port server: IServerConsumer;\n    }\n\n    block Server {\n        proxy port consumer: IServerConsumer;\n        proxy port producer: IServerProducer;\n    }\n\n    block PubSubSystem {\n        part producers: Producer[*];\n        part server: Server;\n        part consumers: Consumer[*];\n\n        connections {\n            producers.server to server.producer;\n            consumers.server to server.consumer;\n        }\n    }\n\n    interaction PubSubInteraction {\n        participant producer1: Producer;\n        participant server: Server;\n        participant consumer1: Consumer;\n        participant consumer2: Consumer;\n\n        consumer1.server -> server.consumer: subscriptionRequest(topic=\"news\");\n        consumer2.server -> server.consumer: subscriptionRequest(topic=\"news\");\n        producer1.server -> server.producer: messagePublication(topic=\"news\", content=\"Hello\");\n        server.consumer -> consumer1.server: messageDelivery(topic=\"news\", content=\"Hello\");\n        server.consumer -> consumer2.server: messageDelivery(topic=\"news\", content=\"Hello\");\n    }\n}",
    "package TransportationSystem {\n   part def Vehicle {\n      attribute fuelLevel: Real;\n      attribute maxTankCapacity: Real;\n      constraint fuelLow: fuelLevel < 0.1 * maxTankCapacity;\n   }\n\n   part def Driver {\n      association refuelingStation: GasStation[0..1];\n   }\n\n   part def Passenger {\n   }\n\n   part def GasStation {\n   }\n\n   part def Environment {\n   }\n\n   requirement \"Provide Transportation Services\" {\n      id: \"REQ1\"\n      text: \"The system shall provide transportation services for users including boarding, travel, refueling, and safe exit\"\n   }\n\n   requirement \"User Boarding\" {\n      id: \"REQ2\"\n      text: \"Driver and up to four passengers shall be able to enter the vehicle\"\n   }\n\n   requirement \"Travel Operation\" {\n      id: \"REQ3\"\n      text: \"Driver shall operate the vehicle to complete travel tasks\"\n   }\n\n   requirement \"Low Fuel Refueling\" {\n      id: \"REQ4\"\n      text: \"When fuel level falls below 10% of max capacity, driver may refuel at gas station to continue operation\"\n   }\n\n   requirement \"Environmental Consideration\" {\n      id: \"REQ5\"\n      text: \"Environmental factors shall be accounted for during vehicle operation\"\n   }\n\n   requirement \"Safe Exit\" {\n      id: \"REQ6\"\n      text: \"All occupants shall exit vehicle safely after transportation completion\"\n   }\n\n   activity TravelTask {\n      action enter: Entry {\n         performer: Driver;\n         performer: Passenger[0..4];\n      }\n      action operate: Operation {\n         performer: Driver;\n      }\n      decision fuelCheck: Vehicle.fuelLow;\n      action refuel: Refueling {\n         performer: Driver;\n         in: fuelCheck = true;\n      }\n      action completeTravel: Completion;\n      action exit: Exit {\n         performer: Driver;\n         performer: Passenger[0..4];\n      }\n      edge enter -> operate;\n      edge operate -> fuelCheck;\n      edge fuelCheck -> refuel [guard: \"low fuel\"];\n      edge refuel -> operate;\n      edge fuelCheck -> completeTravel [guard: \"sufficient fuel\"];\n      edge completeTravel -> exit;\n   }\n\n   scenario NormalTravel {\n      step: enter;\n      step: operate;\n      step: completeTravel;\n      step: exit;\n   }\n\n   scenario RefuelScenario {\n      step: enter;\n      step: operate;\n      step: fuelCheck [condition: Vehicle.fuelLow = true];\n      step: refuel;\n      step: operate;\n      step: completeTravel;\n      step: exit;\n   }\n\n   REQ1 :> {\n      satisfy -> TravelTask;\n      satisfy -> NormalTravel;\n      satisfy -> RefuelScenario;\n   }\n   REQ2 :> { satisfy -> enter; }\n   REQ3 :> { satisfy -> operate; }\n   REQ4 :> { satisfy -> refuel; }\n   REQ5 :> { satisfy -> Environment; }\n   REQ6 :> { satisfy -> exit; }\n}",
    "package VehicleFuelManagement {\n   interface block FuelFlow {\n      temperature: Real;\n   }\n\n   part def FuelTankAssembly {\n      out supplyPort: FuelFlow;\n      in returnPort: FuelFlow;\n   }\n\n   part def EngineUnit {\n      in fuelInlet: FuelFlow;\n      out returnOutlet: FuelFlow;\n   }\n\n   part def VehicleFuelManagementSystem {\n      part fuelTank: FuelTankAssembly;\n      part engine: EngineUnit;\n\n      connection supplyConnection: fuelTank.supplyPort -> engine.fuelInlet;\n      connection returnConnection: engine.returnOutlet -> fuelTank.returnPort;\n   }\n}",
    "package VehicleFuelSystem {\n   value type Fuel {\n      mass: Real;\n      temperature: Real;\n   }\n\n   part def FuelTankAssembly {\n      port supplyPort: out Fuel;\n      port returnPort: in Fuel;\n   }\n\n   part def Engine {\n      port fuelInPort: in Fuel;\n      port returnPort: out Fuel;\n   }\n\n   part def VehicleFuelSystem {\n      part fuelTank: FuelTankAssembly;\n      part engine: Engine;\n\n      connection supplyLine: fuelTank.supplyPort -> engine.fuelInPort;\n      connection returnLine: engine.returnPort -> fuelTank.returnPort;\n   }\n}",
    "package PhotoCaptureSystem {\n   part def Scene;\n   part def Image;\n   part def Photo;\n\n   action Focus {\n      in selectedScene: Scene;\n      out focusedImage: Image;\n   }\n\n   action Capture {\n      in focusedImage: Image;\n      out finalPhoto: Photo;\n   }\n\n   activity CapturePhoto {\n      in sceneSelection: Scene;\n      out capturedPhoto: Photo;\n\n      action performFocus: Focus;\n      action performCapture: Capture;\n\n      edge sceneSelection -> performFocus.selectedScene;\n      edge performFocus.focusedImage -> performCapture.focusedImage;\n      edge performCapture.finalPhoto -> capturedPhoto;\n   }\n\n   block PhotoCaptureSystem {\n      behavior: CapturePhoto;\n   }\n}",
    "package PhotographyWorkflow {\n   part def Image\n   part def Scene\n\n   action def Focusing {\n      in scene: Scene\n      out focusedImage: Image\n   }\n\n   action def Shooting {\n      in focusedImage: Image\n      out finalPhotograph: Image\n   }\n\n   activity def PhotographyWorkflow {\n      in selectedScene: Scene\n      out finalPhoto: Image\n\n      part focus: Focusing {\n         in scene => ^selectedScene\n         out focusedImage: Image\n      }\n\n      part shoot: Shooting {\n         in focusedImage => focus.focusedImage\n         out finalPhotograph => ^finalPhoto\n      }\n   }\n}",
    "part def Scene;\npart def Image;\npart def Photograph;\naction Focusing {\n   in scene: Scene;\n   out image: Image;\n}\naction Shooting {\n   in image: Image;\n   out photograph: Photograph;\n}\nactivity PhotographyWorkflow {\n   in scene: Scene;\n   out photograph: Photograph;\n   action focus: Focusing;\n   action shoot: Shooting;\n   sequence {\n      focus -> shoot;\n   }\n   bind {\n      scene -> focus.scene;\n      focus.image -> shoot.image;\n      shoot.photograph -> photograph;\n   }\n}",
    "package PhotographyAutomation {\n   type ShootingScene;\n   type FocusedImage;\n   type Photograph;\n\n   part def AutomatedPhotographySystem {\n      activity AutomatePhotography {\n         in scene: ShootingScene;\n         out photo: Photograph;\n\n         action focusProcessing {\n            in inputScene: ShootingScene;\n            out processedImage: FocusedImage;\n         }\n\n         action shootingOperation {\n            in inputImage: FocusedImage;\n            out outputPhoto: Photograph;\n         }\n\n         scene -> focusProcessing.inputScene;\n         focusProcessing.processedImage -> shootingOperation.inputImage;\n         shootingOperation.outputPhoto -> photo;\n      }\n   }\n}",
    "package PhotographyWorkflow {\n   value type Scene;\n   value type Image;\n   value type Picture;\n\n   activity Focus {\n      in scene: Scene;\n      out image: Image;\n   }\n\n   activity Shoot {\n      in image: Image;\n      out picture: Picture;\n   }\n\n   activity PhotographyProcess {\n      in scene: Scene;\n      out picture: Picture;\n\n      action focus: Focus;\n      action shoot: Shoot;\n\n      sequence {\n         focus -> shoot;\n      }\n\n      bindings {\n         in scene -> focus.scene;\n         focus.image -> shoot.image;\n         shoot.picture -> out picture;\n      }\n   }\n\n   part def PhotographyWorkflow {\n      behavior: PhotographyProcess;\n   }\n}",
    "package PhotographyWorkflow {\n   type Scene;\n   type Image;\n\n   activity PhotographyWorkflow {\n      input selectedScene: Scene;\n      output resultPhoto: Image[0..1];\n\n      action FocusScene {\n         input scene: Scene;\n         output focusedScene: Scene;\n         output focusClear: Boolean;\n      } [0..1];\n\n      action CapturePhoto {\n         input scene: Scene;\n         output photo: Image;\n      } [0..1];\n\n      edge selectedScene -> FocusScene.scene;\n      edge FocusScene.focusedScene -> CapturePhoto.scene;\n      edge after(FocusScene) to CapturePhoto\n         when FocusScene.focusClear;\n      edge CapturePhoto.photo -> resultPhoto;\n   }\n}",
    "value type User;\nvalue type Scene;\nvalue type Image;\nvalue type Photo;\nvalue type Boolean;\n\nactivity PhotographyWorkflow {\n   in scene: Scene;\n   out finalPhoto: Photo;\n\n   object node buffer: Image;\n\n   action focusing: {\n      in scene: Scene;\n      out focusedImage: Image;\n   }\n\n   action evaluateFocus: {\n      in focusedImage: Image;\n      out isWellFocused: Boolean;\n   }\n\n   action shoot: {\n      in focusedImage: Image;\n      out photograph: Photo;\n   }\n\n   initial start;\n   final activityFinalSuccess;\n   final activityFinalFailure;\n   fork fork1;\n   decision decision1: Boolean;\n\n   edge start -> focusing;\n   edge scene -> focusing.scene;\n   edge focusing.focusedImage -> fork1;\n   edge fork1 -> evaluateFocus.focusedImage;\n   edge fork1 -> buffer;\n   edge evaluateFocus.isWellFocused -> decision1;\n   edge decision1 -> shoot [guard: decision1 = true];\n   edge decision1 -> activityFinalFailure [guard: else];\n   edge buffer -> shoot.focusedImage;\n   edge shoot.photograph -> finalPhoto;\n   edge shoot -> activityFinalSuccess;\n}",
    "package PhotographySystem {\n   block System {\n      operation takePhoto()\n   }\n\n   activity PhotographyWorkflow {\n      action acquireScene {\n         output scene: Scene\n      }\n\n      action focus {\n         input scene: Scene\n         output image: Image\n      }\n\n      action shoot {\n         input image: Image\n         output photo: Photograph\n      }\n\n      action displayPhoto {\n         input photo: Photograph\n      }\n\n      initial node start\n      edge start -> acquireScene\n      edge acquireScene -> focus\n      edge focus -> shoot\n      edge shoot -> displayPhoto\n      final node end\n      edge displayPhoto -> end\n   }\n\n   item type Scene\n   item type Image\n   item type Photograph\n\n   System::takePhoto = activity PhotographyWorkflow\n}",
    "package AutomaticBrakingControl {\n    part def Vehicle {\n        part brakingSystem: AutomaticBrakingSystem;\n    }\n\n    block AutomaticBrakingSystem {\n        part brakePedal: BrakePedal;\n        part tractionSensor: TractionSensor;\n        part brakeController: BrakeController;\n\n        state machine {\n            initial state Off;\n            state Active {\n                do: [MonitorSensors, AdjustBraking];\n            };\n            transition activation: Off -> Active on KeyTurnedStart;\n        }\n\n        event KeyTurnedStart: Event;\n        activity MonitorSensors {\n            in brakeStatus: BrakePedal::status;\n            in tractionInfo: TractionSensor::roadAdhesion;\n        }\n        activity AdjustBraking {\n            inout brakePressure: BrakeController::pressure;\n            inout modulationFrequency: BrakeController::frequency;\n        }\n    }\n\n    block BrakePedal {\n        attribute status: Boolean;\n        attribute pressure: Real;\n    }\n\n    block TractionSensor {\n        attribute roadAdhesion: Real;\n    }\n\n    block BrakeController {\n        attribute pressure: Real;\n        attribute frequency: Real;\n    }\n\n    requirement BrakingPerformanceReq {\n        id: \"R1\";\n        text: \"Achieve safe and reliable braking performance under various operating conditions\";\n    }\n    requirement AutomaticOperationReq {\n        id: \"R2\";\n        text: \"Operate without user intervention while maintaining optimal braking state\";\n    }\n\n    AutomaticBrakingSystem :> satisfy BrakingPerformanceReq;\n    AutomaticBrakingSystem :> satisfy AutomaticOperationReq;\n}",
    "package BatteryChargingControlSystem {\n  part def Battery {\n    value property level : Real;\n  }\n\n  part def Charger {\n    action startCharging();\n    action stopCharging();\n  }\n\n  part def Controller {\n    attribute currentLevel : Real;\n    \n    state machine {\n      state Idle;\n      state Charging;\n      state Monitoring;\n      \n      initial -> Monitoring;\n      \n      transition Monitoring -> Charging \n        when [currentLevel < 100] \n        do { /charger.startCharging(); };\n        \n      transition Charging -> Monitoring \n        when [currentLevel >= 100] \n        do { /charger.stopCharging(); };\n        \n      transition Monitoring -> Idle \n        when [currentLevel >= 100];\n    }\n  }\n\n  part def BatteryChargingControlSystem {\n    part battery : Battery;\n    part charger : Charger;\n    part controller : Controller;\n    \n    requirement \"Monitor battery level\" {\n      text: \"Monitor current battery level in real time\";\n      satisfiedBy: controller.Monitoring state;\n    }\n    \n    requirement \"Automatic charging\" {\n      text: \"Automatically supply charge when battery level < 100%\";\n      satisfiedBy: controller.Monitoring->Charging transition;\n    }\n    \n    requirement \"Termination control\" {\n      text: \"Terminate charging when battery level >= 100%\";\n      satisfiedBy: controller.Charging->Monitoring transition;\n    }\n    \n    constraint \"Healthy charging\" {\n      text: \"Ensure safe and efficient full charging\";\n      constrainedParameters: battery.level;\n    }\n    \n    connection battery.level -> controller.currentLevel;\n  }\n}",
    "package BatteryChargingSystem {\n    block Battery {\n        attribute level: Real [0.0..100.0];\n    }\n\n    block ChargingController {\n        part battery: Battery;\n\n        action charge() {\n            while (battery.level < 100.0) {\n                replenish();\n            }\n        }\n\n        action replenish() {\n            battery.level = battery.level + 1.0;\n            if (battery.level > 100.0) {\n                battery.level = 100.0;\n            }\n        }\n    }\n}",
    "package CameraSystem {\n   part def Camera {\n      part autofocus : Autofocus;\n      part imaging : Imaging;\n\n      action TakePhoto {\n         in scene : Scene;\n         out photo : Photo;\n\n         sequence {\n            autofocus.Focus(scene) -> focusedImage;\n            imaging.Capture(focusedImage) -> photo;\n         }\n      }\n   }\n\n   part def Autofocus {\n      operation Focus(in scene : Scene) : Image;\n   }\n\n   part def Imaging {\n      operation Capture(in image : Image) : Photo;\n   }\n\n   item type Scene;\n   item type Image;\n   item type Photo;\n}",
    "package DigitalCamera {\n   part def DigitalCameraSystem {\n      part viewfinder: Viewfinder;\n      part autofocus: Autofocus;\n      part imagingModule: ImagingModule;\n\n      activity ShootingProcess {\n         in selectedScene: String;\n         action focus: CallOperation {\n            operation = autofocus.focusOn;\n            target = autofocus;\n            argument (value: selectedScene) -> operation.scene;\n         }\n         action capture: CallOperation {\n            operation = imagingModule.captureAndProduce;\n            target = imagingModule;\n            argument (value: selectedScene) -> operation.scene;\n         }\n         edge focus -> capture;\n      }\n   }\n\n   part def Viewfinder {}\n\n   part def Autofocus {\n      operation focusOn {\n         in scene: String;\n      }\n   }\n\n   part def ImagingModule {\n      operation captureAndProduce {\n         in scene: String;\n      }\n   }\n}",
    "package VehicleSimulation {\n   part def Vehicle {\n      attribute mass: Real;\n      attribute initialPosition: Real;\n      attribute initialVelocity: Real;\n   }\n\n   part def PowerInput {\n      attribute timeStep: Real;\n      attribute powerSequence: sequence<Real>;\n   }\n\n   part def SimulationResult {\n      attribute trajectory: sequence<Real>;\n   }\n\n   part def Simulator {\n      attribute vehicle: Vehicle;\n      attribute input: PowerInput;\n      attribute result: SimulationResult;\n\n      constraint {\n         result.trajectory[0] == vehicle.initialPosition;\n         velocity[0] == vehicle.initialVelocity;\n         for i in range(0, len(input.powerSequence)) {\n            acceleration = input.powerSequence[i] / (vehicle.mass * velocity[i]);\n            velocity[i+1] == velocity[i] + acceleration * input.timeStep;\n            result.trajectory[i+1] == result.trajectory[i] + velocity[i] * input.timeStep + 0.5 * acceleration * input.timeStep^2;\n         }\n      }\n   }\n}",
    "package CameraSystem {\n   value type Scene;\n   value type Image;\n   value type Photo;\n\n   action FocusAction {\n      in inputPort: Scene;\n      out outputPort: Image;\n   }\n\n   action CaptureAction {\n      in inputPort: Image;\n      out outputPort: Photo;\n   }\n\n   action DisplayAction {\n      in inputPort: Photo;\n   }\n\n   activity CameraShootingAndDisplayProcess {\n      parameter scene: in Scene;\n\n      action focus: FocusAction;\n      action capture: CaptureAction;\n      action display: DisplayAction;\n\n      edge scene -> focus.inputPort;\n      edge focus.outputPort -> capture.inputPort;\n      edge capture.outputPort -> display.inputPort;\n   }\n}",
    "package CameraSystem {\n   type Scene;\n   type Image;\n   type Picture;\n\n   interface CameraViewPort {\n      in scene: Scene;\n   }\n\n   interface DisplayPort {\n      out picture: Picture;\n   }\n\n   activity CameraWorkflow {\n      input parameter sceneSelection: Scene;\n      output parameter toDisplay: Picture;\n\n      action focus {\n         input selectedScene: Scene;\n         output focusedImage: Image;\n      }\n\n      action capture {\n         input image: Image;\n         output photograph: Picture;\n      }\n\n      action display {\n         input photo: Picture;\n         output displayedPhoto: Picture;\n      }\n\n      edge sceneSelection -> focus.selectedScene;\n      edge focus.focusedImage -> capture.image;\n      edge capture.photograph -> display.photo;\n      edge display.displayedPhoto -> toDisplay;\n   }\n\n   part def CameraSystem {\n      port viewPort: required CameraViewPort;\n      port displayPort: provided DisplayPort;\n\n      behavior: CameraWorkflow;\n\n      bind sceneSelection to viewPort.scene;\n      bind toDisplay to displayPort.picture;\n   }\n}",
    "package SensorSystem {\n   enum SensorState {\n      ready;\n      updating;\n      idle;\n   }\n\n   block Sensor {\n      attribute status: SensorState;\n   }\n\n   block SensorManager {\n      part sensors: Sensor[*];\n\n      operation updateSensor(target: Sensor);\n\n      behavior {\n         state machine {\n            state Monitoring;\n            state Updating;\n            initial -> Monitoring;\n            transition from Monitoring to Updating {\n               trigger: any sensor: sensors[status == SensorState::ready];\n               effect: updateSensor(sensor);\n            }\n            transition from Updating to Monitoring {\n               guard: current update completed;\n            }\n         }\n      }\n\n      activity MonitorAndUpdate {\n         while true {\n            for sensor in sensors {\n               if sensor.status == SensorState::ready {\n                  updateSensor(sensor);\n               }\n            }\n         }\n      }\n   }\n}",
    "package VehicleSystem {\n   part def Vehicle {\n      state machine {\n         event vehicleStartSignal: signal;\n         event vehiclePowerOnSignal: signal;\n         event vehicleShutdownSignal: signal;\n\n         initial state off;\n         state starting;\n         state on;\n\n         transition: off -> starting on vehicleStartSignal;\n         transition: starting -> on on vehiclePowerOnSignal;\n         transition: off -> off on vehicleShutdownSignal;\n         transition: starting -> off on vehicleShutdownSignal;\n         transition: on -> off on vehicleShutdownSignal;\n      }\n   }\n}",
    "package VehicleStateManagement {\n    event VehicleStartSignal;\n    event VehicleOnSignal;\n    event VehicleOffSignal;\n\n    part def Vehicle {\n        state machine {\n            initial state off;\n            state starting;\n            state on;\n\n            transition from off to starting on VehicleStartSignal;\n            transition from starting to on on VehicleOnSignal;\n            transition from on to off on VehicleOffSignal;\n        }\n    }\n}",
    "package VehiclePowerManagement {\n   signal vehicleStartCommand\n   signal vehicleStartedSignal\n   signal vehicleShutdownCommand\n\n   statemachine VehiclePowerStateMachine {\n      initial: -> Off\n\n      state Off\n\n      state StartPhase\n\n      state PoweredOn {\n         do activity: 'self-diagnosis and power supply'\n      }\n\n      state ShuttingDown {\n         do activity: 'safety operations'\n         -> Off\n      }\n\n      Off -> StartPhase: on vehicleStartCommand\n      StartPhase -> PoweredOn: on vehicleStartedSignal\n      PoweredOn -> ShuttingDown: on vehicleShutdownCommand\n   }\n}",
    "package VehicleSystem {\n   part def VehicleController {\n      state def VehicleStateMachine {\n         initial shutdown;\n         state shutdown;\n         state startUp;\n         state running;\n         transition from shutdown to startUp on vehicleStartSignal;\n         transition from startUp to running on vehicleStartedSignal;\n         transition from running to shutdown on vehicleShutdownSignal;\n      }\n   }\n   signal vehicleStartSignal;\n   signal vehicleStartedSignal;\n   signal vehicleShutdownSignal;\n}",
    "package VehiclePowerManagement {\n    signal startSignal;\n    signal onSignal;\n    signal offSignal;\n\n    state machine VehicleStateMachine {\n        initial state Off;\n        state Start;\n        state On;\n\n        Off -> Start on startSignal;\n        Start -> On on onSignal;\n        On -> Off on offSignal;\n    }\n\n    part vehicle {\n        attribute operatingState : VehicleStateMachine;\n    }\n}",
    "package VehicleHealthSystem {\n  import Libraries::Time;\n\n  event overTemperature\n  event temperatureSafe\n  event maintenanceDue\n  event maintenanceCompleted\n\n  block VehicleHealthMonitoringSystem {\n    part temperatureSensor : TemperatureSensor;\n    part timer : Timer;\n    part maintenanceScheduler : MaintenanceScheduler;\n    part vehicleController : VehicleController;\n\n    value maxAllowableTemperature : Real;\n    attribute healthStatus : String;\n\n    state machine {\n      initial state normal {\n        entry {\n          healthStatus = \"normal\";\n        }\n      }\n\n      state degraded {\n        entry {\n          healthStatus = \"degraded\";\n        }\n      }\n\n      state maintenance {\n        entry {\n          healthStatus = \"maintenance\";\n          timer.start(duration = Duration(48, 'h'));\n        }\n        exit {\n          timer.cancel();\n        }\n      }\n\n      transition T1: normal -> degraded on overTemperature {\n        effect {\n          vehicleController.sendWarning(message = \"Over-temperature warning\");\n        }\n      }\n\n      transition T2: degraded -> normal on temperatureSafe\n\n      transition T3: normal -> maintenance on maintenanceDue\n      transition T4: degraded -> maintenance on maintenanceDue\n\n      transition T5: maintenance -> normal on timer.timeout\n\n      internal transition IT1: in maintenance on maintenanceCompleted {\n        effect {\n          maintenanceScheduler.updateNextCycle();\n        }\n      }\n    }\n\n    behavior {\n      while true {\n        if temperatureSensor.currentTemperature > maxAllowableTemperature {\n          generate overTemperature;\n        } else {\n          generate temperatureSafe;\n        }\n        wait Duration(1, 's');\n      }\n    }\n  }\n\n  block TemperatureSensor {\n    reference currentTemperature : Real;\n  }\n\n  block Timer {\n    event timeout\n    operation start ( duration : Duration ) : Boolean\n    operation cancel : Boolean\n  }\n\n  block MaintenanceScheduler {\n    operation updateNextCycle : Boolean\n  }\n\n  block VehicleController {\n    operation sendWarning ( message : String ) : Boolean\n  }\n}",
    "package ServerModel {\n    signal StartCommand;\n    signal RequestMessage;\n\n    part def Server {\n        port requestPort : Signal<StartCommand | RequestMessage>;\n\n        state machine {\n            initial off;\n\n            state off;\n            composite state operational {\n                initial waiting;\n                state waiting;\n                state response;\n\n                transition from waiting to response on RequestMessage via requestPort;\n                transition from response to waiting after 5 min;\n            }\n\n            transition from off to operational on StartCommand via requestPort;\n            transition from operational to off on TimeEvent(when=timeOfDay(11,59,0), every=1 d);\n        }\n    }\n}",
    "part def StartStopSystem {\n    ref controller: Controller;\n    attr brakePedalDepressed: Boolean;\n\n    state machine {\n        initial state off;\n        state start_process;\n        state operating;\n\n        transition from off to start_process on start_signal;\n        \n        transition from start_process to operating on power_on_signal\n            when brakePedalDepressed\n            effect {\n                controller.startSignal();\n            };\n        \n        state operating {\n            entry {\n                selfCheck();\n                supplyPower();\n            }\n            do {\n                maintainPowerSupply();\n            }\n            exit {\n                applyParkingBrake();\n            }\n        }\n        \n        transition from operating to off on stop_signal;\n    }\n    \n    operation selfCheck();\n    operation supplyPower();\n    operation maintainPowerSupply();\n    operation applyParkingBrake();\n}\n\npart def Controller {\n    reception startSignal();\n}\n\nevent start_signal;\nevent power_on_signal;\nevent stop_signal;",
    "part def VehicleControlSystem {\n    state machine VehicleControlStateMachine {\n        initial: Off;\n\n        event vehicleStartSignal;\n        event vehicleOnSignal;\n        event shutdownSignal;\n        event parkingBrakeAppliedEvent;\n        signal startControlSignal;\n        signal shutdownControlSignal;\n\n        state Off;\n        state Starting;\n        state Started {\n            do: selfCheckAndSupplyPower;\n        };\n        state ShuttingDown {\n            exit: send shutdownControlSignal;\n        };\n\n        Off -> Starting on vehicleStartSignal;\n        Starting -> Started on vehicleOnSignal [brakePedalDepressed] / {\n            send startControlSignal;\n        };\n        Started -> ShuttingDown on shutdownSignal;\n        ShuttingDown -> Off when parkingBrakeApplied;\n        ShuttingDown -> Off on parkingBrakeAppliedEvent;\n    }\n}",
    "package CruiseControlSystem {\n    import Systems::Blocks::Events::*;\n\n    event SetSpeedCommand {\n        desiredSpeed: Real;\n    }\n\n    event CurrentSpeed {\n        actualSpeed: Real;\n    }\n\n    event FuelControlCommand {\n        throttleLevel: Real;\n    }\n\n    part def Driver {\n        port setSpeed: out Event<SetSpeedCommand>;\n    }\n\n    part def CruiseController {\n        port setSpeedIn: in Event<SetSpeedCommand>;\n        port currentSpeedIn: in Event<CurrentSpeed>;\n        port fuelControlOut: out Event<FuelControlCommand>;\n    }\n\n    part def Speedometer {\n        port speedOut: out Event<CurrentSpeed>;\n        ref targetVehicle: Vehicle;\n    }\n\n    part def Engine {\n        port fuelControlIn: in Event<FuelControlCommand>;\n        ref hostVehicle: Vehicle;\n    }\n\n    part def Vehicle {\n        attribute speed: Real;\n    }\n\n    part def CruiseControlSystem {\n        part driver: Driver;\n        part cruiseController: CruiseController;\n        part speedometer: Speedometer;\n        part engine: Engine;\n        part vehicle: Vehicle;\n\n        connector setSpeedLink: driver.setSpeed -> cruiseController.setSpeedIn;\n        connector speedDataLink: speedometer.speedOut -> cruiseController.currentSpeedIn;\n        connector fuelControlLink: cruiseController.fuelControlOut -> engine.fuelControlIn;\n        connector speedometerBinding: speedometer.targetVehicle = vehicle;\n        connector engineBinding: engine.hostVehicle = vehicle;\n    }\n}",
    "package CruiseControlSystem {\n   signal SetSpeed {\n      speed: Real;\n   }\n\n   signal ThrottleCommand {\n      level: Real;\n   }\n\n   valueType Speed: Real;\n\n   block Driver {\n      out port setSpeedOut: SetSpeed;\n   }\n\n   block Speedometer {\n      out port currentSpeedOut: Speed;\n   }\n\n   block Engine {\n      in port throttleIn: ThrottleCommand;\n   }\n\n   block CruiseController {\n      in port setSpeedIn: SetSpeed;\n      in port currentSpeedIn: Speed;\n      out port throttleOut: ThrottleCommand;\n\n      activity Control {\n         in parameter setPoint: Speed;\n         in parameter actualSpeed: Speed;\n         out parameter throttleCmd: ThrottleCommand;\n\n         start {\n            actualSpeed = currentSpeedIn.value;\n            let error: Real = setPoint - actualSpeed;\n            throttleCmd = new ThrottleCommand(level = error * 0.1);\n            throttleOut.send(throttleCmd);\n         }\n      }\n   }\n\n   block VehicleSystem {\n      part driver: Driver;\n      part cruiseController: CruiseController;\n      part speedometer: Speedometer;\n      part engine: Engine;\n\n      connections {\n         driver.setSpeedOut -> cruiseController.setSpeedIn;\n         speedometer.currentSpeedOut -> cruiseController.currentSpeedIn;\n         cruiseController.throttleOut -> engine.throttleIn;\n      }\n   }\n}",
    "package AutomotiveCruiseControl {\n    signal SetSpeed {\n        value: Real;\n    }\n\n    signal CurrentSpeed {\n        value: Real;\n    }\n\n    signal ThrottleCommand {\n        level: Real;\n    }\n\n    part def Driver {\n        port out setSpeed: OutEvent<SetSpeed>;\n    }\n\n    part def CruiseController {\n        port in setSpeed: InEvent<SetSpeed>;\n        port out getSpeed: OutEvent<Request>;\n        port in currentSpeed: InEvent<CurrentSpeed>;\n        port out throttle: OutEvent<ThrottleCommand>;\n    }\n\n    part def SpeedSensor {\n        port in request: InEvent<Request>;\n        port out currentSpeed: OutEvent<CurrentSpeed>;\n    }\n\n    part def Engine {\n        port in throttle: InEvent<ThrottleCommand>;\n    }\n\n    part def VehicleSystem {\n        part driver: Driver;\n        part controller: CruiseController;\n        part speedSensor: SpeedSensor;\n        part engine: Engine;\n\n        connection setSpeedConn: connect(driver.setSpeed, controller.setSpeed);\n        connection requestConn: connect(controller.getSpeed, speedSensor.request);\n        connection speedConn: connect(speedSensor.currentSpeed, controller.currentSpeed);\n        connection throttleConn: connect(controller.throttle, engine.throttle);\n    }\n}",
    "value type Speed {\n   value: Real;\n}\n\nvalue type Throttle {\n   value: Real;\n}\n\nblock CruiseController {\n   in port setSpeed: Speed;\n   in port currentSpeed: Speed;\n   out port throttleCommand: Throttle;\n}\n\nblock Speedometer {\n   out port currentSpeed: Speed;\n}\n\nblock Engine {\n   in port throttleCommand: Throttle;\n}\n\nblock Driver {\n   out port setSpeed: Speed;\n}\n\nblock CruiseControlSystem {\n   part driver: Driver;\n   part controller: CruiseController;\n   part speedometer: Speedometer;\n   part engine: Engine;\n\n   connector driver.setSpeed -> controller.setSpeed;\n   connector speedometer.currentSpeed -> controller.currentSpeed;\n   connector controller.throttleCommand -> engine.throttleCommand;\n}",
    "package AutomotiveCruiseControl {\n   part def Vehicle {\n      part sensor : SpeedSensor;\n      part engine : Engine;\n      part controller : CruiseController;\n      part interface : CruiseControlInterface;\n\n      connection speedFeedback {\n         source : sensor.speedOut;\n         target : controller.actualSpeedIn;\n      }\n      connection controlSignal {\n         source : controller.fuelControlOut;\n         target : engine.fuelControlIn;\n      }\n      connection setCommand {\n         source : interface.setSpeedOut;\n         target : controller.setSpeedIn;\n      }\n   }\n\n   block CruiseControlInterface {\n      port setSpeedOut : out data Float;\n   }\n\n   block SpeedSensor {\n      port speedOut : out data Float;\n   }\n\n   block CruiseController {\n      port setSpeedIn : in data Float;\n      port actualSpeedIn : in data Float;\n      port fuelControlOut : out data Float;\n   }\n\n   block Engine {\n      port fuelControlIn : in data Float;\n   }\n}",
    "package CruiseControlSystem {\n   type SetSpeedCommand;\n   type Speed;\n   type FuelControlCommand;\n\n   interface SetSpeedIF {\n      in setSpeed(in command : SetSpeedCommand);\n   }\n\n   interface SpeedSensorIF {\n      out currentSpeed() : Speed;\n   }\n\n   interface FuelControlIF {\n      in adjustFuel(in command : FuelControlCommand);\n   }\n\n   part Driver {\n      port setSpeedPort : out SetSpeedIF;\n   }\n\n   part CruiseController {\n      port commandIn : in SetSpeedIF;\n      port speedIn : in SpeedSensorIF;\n      port fuelOut : out FuelControlIF;\n   }\n\n   part SpeedSensor {\n      port speedOut : out SpeedSensorIF;\n   }\n\n   part EngineController {\n      port fuelIn : in FuelControlIF;\n      port engineOut : out FuelControlIF;\n   }\n\n   part Engine {\n      port fuelIn : in FuelControlIF;\n   }\n\n   partdef VehicleSystem {\n      part driver : Driver;\n      part cruiseController : CruiseController;\n      part speedSensor : SpeedSensor;\n      part engineController : EngineController;\n      part engine : Engine;\n\n      connection setSpeedLink between driver.setSpeedPort, cruiseController.commandIn;\n      connection speedLink between cruiseController.speedIn, speedSensor.speedOut;\n      connection fuelLink1 between cruiseController.fuelOut, engineController.fuelIn;\n      connection fuelLink2 between engineController.engineOut, engine.fuelIn;\n   }\n\n   interaction ControlSequence in VehicleSystem {\n      setSpeed(setPoint) from :driver to :cruiseController;\n      currentSpeed() from :cruiseController to :speedSensor;\n      currentSpeed() response (actualSpeed) from :speedSensor to :cruiseController;\n      adjustFuel(controlCmd) from :cruiseController to :engineController;\n      adjustFuel(controlCmd) from :engineController to :engine;\n   }\n}",
    "package VehicleLifecycle {\n   import Dates; // Assuming a library for Date and DateTime types\n\n   type Date;\n   type DateTime;\n\n   block Vehicle {\n      attribute assemblyDate: Date;\n      attribute deliveryDate: Date;\n      attribute scrappingDate: Date[0..1];\n\n      part ownerships: Ownership[*] ordered;\n   }\n\n   block Ownership {\n      attribute startDate: Date;\n      attribute endDate: Date[0..1];\n\n      reference owner: Owner[1];\n      part drivingOperations: DrivingOperation[*];\n   }\n\n   block Owner {\n      attribute name: String;\n      attribute contactInfo: String;\n   }\n\n   block DrivingOperation {\n      attribute timestamp: DateTime;\n\n      reference driver: Driver[1];\n   }\n\n   block Driver {\n      attribute name: String;\n      attribute licenseNumber: String;\n   }\n\n   association VehicleOwnership {\n      vehicle: Vehicle[1];\n      ownershipHistory: Ownership[*] ordered;\n   }\n\n   association OwnershipDriving {\n      ownershipPeriod: Ownership[1];\n      operations: DrivingOperation[*];\n   }\n}",
    "package VehicleModel {\n   value type Mass {\n      value: Real;\n   }\n\n   value type GearSetting: String;\n\n   value type PedalPosition: Real;\n\n   value type OperationalStatus {\n      gearSetting: GearSetting;\n      acceleratorPedalPosition: PedalPosition;\n   }\n\n   part def Engine;\n\n   part def Driver;\n\n   timeslice def WheelState for Wheel {\n      time: TimeValue;\n      description: String;\n   }\n\n   part def Wheel {\n      state: WheelState[*];\n   }\n\n   part def Vehicle {\n      value mass: Mass;\n      value operationalStatus: OperationalStatus;\n      part engine: Engine;\n      ref driver: Driver;\n      part wheels: Wheel[*];\n   }\n\n   unit s: Unit;\n\n   instance vehicle_1: Vehicle {\n      mass = 1500;\n      operationalStatus = {\n         gearSetting = \"park\";\n         acceleratorPedalPosition = 0;\n      };\n      part engine = new Engine;\n      ref driver = new Driver;\n      part wheels = {\n         leftFront: new Wheel {\n            state = {\n               new WheelState {\n                  time = timeValue(0, s);\n                  description = \"Initial state\";\n               },\n               new WheelState {\n                  time = timeValue(10, s);\n                  description = \"After 10 seconds\";\n               }\n            }\n         },\n         rightFront: new Wheel {\n            state = {\n               new WheelState {\n                  time = timeValue(0, s);\n                  description = \"Initial state\";\n               },\n               new WheelState {\n                  time = timeValue(10, s);\n                  description = \"After 10 seconds\";\n               }\n            }\n         }\n      };\n   }\n}",
    "package VehicleSystem {\n    value type MassValue: Real {\n        unit = 'kg';\n    }\n\n    value type VehicleStateValue {\n        gear: Integer;\n        acceleratorPosition: Real;\n    }\n\n    block Engine;\n    block Driver;\n\n    block Vehicle {\n        mass: MassValue;\n        state: VehicleStateValue;\n        engine: Engine[1];\n        driver: Driver[1];\n    }\n\n    part Vehicle_1: Vehicle;\n}\n\nsnapshot initial: Snapshot {\n    VehicleSystem::Vehicle_1.mass = 2000;\n    VehicleSystem::Vehicle_1.state.gear = 0;\n    VehicleSystem::Vehicle_1.state.acceleratorPosition = 0.0;\n}\n\nsnapshot next: Snapshot {\n    VehicleSystem::Vehicle_1.mass = 1500;\n    VehicleSystem::Vehicle_1.state.gear = 2;\n    VehicleSystem::Vehicle_1.state.acceleratorPosition = 0.5;\n}",
    "package VehicleModel {\n   type Driver;\n   part Alice: Driver;\n   part Bob: Driver;\n\n   enum GearPosition {\n      neutral,\n      second\n   }\n\n   partdef Engine;\n\n   partdef Vehicle {\n      attribute mass: Real;\n      attribute gearPosition: GearPosition;\n      attribute throttlePedalPosition: Real;\n      part engine: Engine;\n      reference driver: Driver;\n   }\n\n   part myVehicle: Vehicle;\n\n   snapshot initial of myVehicle {\n      mass = 2000.0;\n      gearPosition = GearPosition::neutral;\n      throttlePedalPosition = 0.0;\n      driver = Alice;\n   }\n\n   snapshot subsequent of myVehicle {\n      mass = 1500.0;\n      gearPosition = GearPosition::second;\n      throttlePedalPosition = 0.5;\n      driver = Bob;\n   }\n}",
    "package MassAggregation {\n   value type Mass: Real;\n\n   abstract def Component {\n      attr id: String;\n      attr ownMass: Mass;\n      ref totalMass: Mass;\n   }\n\n   def SimpleComponent: Component {\n      constraint totalMassDerivation {\n         totalMass = ownMass;\n      }\n   }\n\n   def CompositeComponent: Component {\n      part subcomponent: Component[*];\n      constraint totalMassDerivation {\n         totalMass = ownMass + subcomponent.totalMass->sum();\n      }\n   }\n\n   def Body: SimpleComponent;\n   def Engine: SimpleComponent;\n   def Transmission: SimpleComponent;\n\n   def Vehicle: CompositeComponent;\n\n   part def WholeVehicle: Vehicle {\n      part body: Body;\n      part engine: Engine;\n      part transmission: Transmission;\n      constraint subcomponentAggregation {\n         subcomponent = body + engine + transmission;\n      }\n   }\n}",
    "part def Component {\n   attribute serialNumber: string;\n   attribute mass: float;\n   part subcomponents: Component[*];\n   op totalMass(threshold: float=0.0): float {\n      = mass + subcomponents->select(mass>=threshold)->collect(totalMass(0.0))->sum()\n   }\n}\n\npart def Vehicle {\n   attribute vin: string;\n   attribute baseMass: float;\n   part components: Component[*];\n   op totalMass(threshold: float=0.0): float {\n      = baseMass + components->select(mass>=threshold)->collect(totalMass(0.0))->sum()\n   }\n}\n\npart def Engine: Component;\npart def Transmission: Component;",
    "package MassAggregation {\n   abstract def Thing {\n      simpleMass: Real;\n      totalMass: Real { derived; }\n   }\n\n   def SimpleThing :> Thing {\n      totalMass: Real = simpleMass;\n   }\n\n   def CompositeThing :> Thing {\n      composite part subcomponent: Thing[0..*];\n      totalMass: Real = simpleMass + subcomponent.totalMass->sum();\n   }\n}",
    "part def MassObject {\n   attribute basicMass : Real;\n   part subcomponents : MassObject[0..*] {\n      isComposite = true;\n   }\n   operation totalMass(in minThreshold: Real = 0) : Real {\n      result = basicMass + \n               subcomponents->select(s | s.totalMass(0) >= minThreshold)\n                          ->sum(s | s.totalMass(0));\n   }\n}",
    "package VehicleDynamics {\n   import Values::Real;\n\n   block VehicleDynamicsCalculator {\n      attribute wheelPower: Real;\n      attribute dragCoefficient: Real;\n      attribute frictionCoefficient: Real;\n      attribute mass: Real;\n      attribute speed: Real;\n      attribute time: Real;\n      attribute initialSpeed: Real;\n\n      attribute availablePower: Real;\n      attribute acceleration: Real;\n      attribute currentSpeed: Real;\n      attribute displacement: Real;\n\n      constraint PowerCalculation {\n         availablePower == wheelPower - (dragCoefficient * speed^2 + frictionCoefficient * mass * 9.81) * speed\n      }\n\n      constraint AccelerationCalculation {\n         acceleration == availablePower / (mass * speed)\n      }\n\n      constraint SpeedCalculation {\n         currentSpeed == initialSpeed + acceleration * time\n      }\n\n      constraint DisplacementCalculation {\n         displacement == currentSpeed * time\n      }\n   }\n}",
    "package VehicleDynamics {\n    import ModelingLibrary::Math::Real;\n\n    block Vehicle {\n        attribute mass: Real;\n        attribute dragCoefficient: Real;\n        attribute rollingResistanceCoefficient: Real;\n        attribute frontalArea: Real;\n        attribute airDensity: Real = 1.225;\n    }\n\n    constraint block StraightLineDynamicsStep {\n        in power: Real;\n        in timeStep: Real;\n        in mass: Real;\n        in dragCoefficient: Real;\n        in rollingResistanceCoefficient: Real;\n        in frontalArea: Real;\n        in airDensity: Real;\n        in speedIn: Real;\n        in positionIn: Real;\n        out acceleration: Real;\n        out speedOut: Real;\n        out positionOut: Real;\n\n        constraints {\n            var F_roll: Real = rollingResistanceCoefficient * mass * 9.81;\n            var F_drag: Real = 0.5 * dragCoefficient * airDensity * frontalArea * (speedIn^2);\n            var F_drive: Real = power / max(speedIn, 0.1);\n            var F_net: Real = F_drive - F_roll - F_drag;\n            acceleration = F_net / mass;\n            speedOut = speedIn + acceleration * timeStep;\n            positionOut = positionIn + speedIn * timeStep + 0.5 * acceleration * (timeStep^2);\n        }\n    }\n\n    block Simulation {\n        attribute initialSpeed: Real;\n        attribute initialPosition: Real;\n        attribute timeStep: Real;\n        reference vehicle: Vehicle;\n        attribute currentSpeed: Real = initialSpeed;\n        attribute currentPosition: Real = initialPosition;\n\n        operation step(in power: Real) {\n            // Uses StraightLineDynamicsStep constraint to update state\n        }\n    }\n}",
    "package VehicleDynamics {\n    import Systems;\n    import BaseUnits;\n\n    block VehicleDynamicsSystem {\n        value properties {\n            mass: Real [kg];\n            wheelPower: Real [W];\n            dragCoefficient: Real;\n            rollingResistanceCoefficient: Real;\n            initialSpeed: Real [m/s];\n            initialPosition: Real [m];\n            airDensity: Real [kg/m^3] = 1.225;\n            frontalArea: Real [m^2] = 2.2;\n            timeStep: Real [s] = 0.1;\n            currentSpeed: Real [m/s] = initialSpeed;\n            currentPosition: Real [m] = initialPosition;\n            acceleration: Real [m/s^2];\n        }\n\n        constraint {\n            F_air == 0.5 * dragCoefficient * airDensity * frontalArea * currentSpeed^2;\n            F_roll == rollingResistanceCoefficient * mass * 9.81;\n            F_wheel == (currentSpeed > 0) ? (wheelPower / currentSpeed) : 0.0;\n            F_net == F_wheel - F_air - F_roll;\n            acceleration == F_net / mass;\n            nextSpeed: Real [m/s] = currentSpeed + acceleration * timeStep;\n            nextPosition: Real [m] = currentPosition + currentSpeed * timeStep;\n        }\n\n        state machine {\n            initial -> Operational;\n            state Operational {\n                do activity {\n                    currentSpeed = nextSpeed;\n                    currentPosition = nextPosition;\n                } while (true)\n            }\n        }\n    }\n}",
    "package VehicleDynamics {\n  import SIUnits::*;\n\n  block VehicleLongitudinalDynamics {\n    attribute mass: Real (unit = kg);\n    attribute dragCoefficient: Real;\n    attribute frictionCoefficient: Real;\n\n    part dynamics : VehicleMotionCalculation;\n\n    constraint PhysicalConsistency {\n      dynamics.acceleration == (dynamics.driveForce - dynamics.dragForce - dynamics.frictionForce) / mass;\n      dynamics.finalVelocity == dynamics.initialVelocity + dynamics.acceleration * dynamics.timeInterval;\n      dynamics.finalPosition == dynamics.initialPosition + dynamics.initialVelocity * dynamics.timeInterval \n        + 0.5 * dynamics.acceleration * dynamics.timeInterval^2;\n    }\n  }\n\n  part def VehicleMotionCalculation {\n    attribute initialPosition: Real (unit = m);\n    attribute initialVelocity: Real (unit = m/s);\n    attribute drivePower: Real (unit = W);\n    attribute timeInterval: Real (unit = s);\n    \n    attribute acceleration: Real (unit = m/s^2);\n    attribute finalVelocity: Real (unit = m/s);\n    attribute finalPosition: Real (unit = m);\n    \n    attribute driveForce: Real (unit = N);\n    attribute dragForce: Real (unit = N);\n    attribute frictionForce: Real (unit = N);\n    \n    constraint ForceCalculations {\n      driveForce == drivePower / (initialVelocity + 0.001);\n      dragForce == dragCoefficient * initialVelocity^2;\n      frictionForce == frictionCoefficient * mass * 9.81;\n    }\n  }\n}",
    "package VehicleMassManagement {\n   import SIUnits::SIUnits::*;\n\n   block Vehicle {\n      part chassis: Chassis;\n      part engine: Engine;\n      part gearbox: Gearbox;\n\n      attribute totalMass: Mass {\n         = chassis.mass + engine.mass + gearbox.mass;\n      }\n\n      constraint MassLimit {\n         totalMass <= 2500kg;\n      }\n\n      activity CheckMass {\n         output warning: String;\n         warning = if totalMass > 2500kg then \"Overweight warning\" else null;\n      }\n   }\n\n   block Chassis {\n      attribute mass: Mass;\n   }\n\n   block Engine {\n      attribute mass: Mass;\n   }\n\n   block Gearbox {\n      attribute mass: Mass;\n   }\n\n   requirement MaxMassRequirement {\n      id = \"R1\";\n      text = \"The overall vehicle weight shall not exceed 2,500 kilograms.\";\n   }\n\n   satisfy MassRequirementSatisfaction {\n      satisfiedRequirement = MaxMassRequirement;\n      satisfyingSubject = Vehicle;\n   }\n}",
    "unit kg;\n\nvalue type Mass {\n    unit: kg;\n}\n\nrequirement TotalMassRequirement {\n    id: \"REQ1\";\n    text: \"The total mass of the complete vehicle—including major components such as the chassis, engine, and transmission—does not exceed 2,500 kilograms.\";\n}\n\nrequirement SeparateRecordingRequirement {\n    id: \"REQ2\";\n    text: \"The masses of the engine and the transmission must be separately recorded and managed.\";\n}\n\nrequirement UnitRequirement {\n    id: \"REQ3\";\n    text: \"The actual mass of each component shall be entered and uniformly measured using the international unit of kilograms.\";\n}\n\nabstract block Part {\n    mass: Mass;\n}\n\nblock Chassis extends Part;\nblock Engine extends Part;\nblock Transmission extends Part;\n\nconstraint block MassBudget {\n    total: Mass;\n    limit: Mass;\n    constraint { total <= limit }\n}\n\nblock Vehicle {\n    part chassis: Chassis[1];\n    part engine: Engine[1];\n    part transmission: Transmission[1];\n    part otherParts: Part[*];\n\n    derived totalMass: Mass = chassis.mass + engine.mass + transmission.mass + otherParts.mass->sum();\n\n    const massLimit: Mass = 2500;\n\n    constraint totalMassConstraint: MassBudget {\n        total = totalMass;\n        limit = massLimit;\n    }\n\n    satisfy totalMassSatisfaction {\n        requirement = TotalMassRequirement;\n    }\n\n    satisfy separateRecordingSatisfaction {\n        requirement = SeparateRecordingRequirement;\n    }\n\n    satisfy unitSatisfaction {\n        requirement = UnitRequirement;\n    }\n}",
    "package VehicleMassCompliance {\n   unit kilogram;\n   value type Mass {\n      unit: kilogram;\n   }\n\n   block Chassis {\n      value mass: Mass;\n   }\n\n   block Engine {\n      value mass: Mass;\n   }\n\n   block Transmission {\n      value mass: Mass;\n   }\n\n   constraint block TotalMassConstraint {\n      parameters: \n         total: Mass;\n         limit: Mass;\n      constraint: total <= limit;\n   }\n\n   block Vehicle {\n      part chassis: Chassis;\n      part engine: Engine;\n      part transmission: Transmission;\n\n      constraint massCompliance: TotalMassConstraint {\n         total: chassis.mass + engine.mass + transmission.mass;\n         limit: 2500 kilogram;\n      }\n   }\n}",
    "package VehicleWeightManagement {\n   requirement «requirement» WeightLimitRequirement {\n      id = 'REQ1'\n      text = \"The combined weight of the main vehicle components (chassis, engine, transmission) must not exceed 2500 kg.\"\n   }\n\n   requirement «requirement» WeightRecordingRequirement {\n      id = 'REQ2'\n      text = \"The system must accurately record and manage the weight of each component (chassis, engine, transmission).\"\n   }\n\n   requirement «requirement» WarningRequirement {\n      id = 'REQ3'\n      text = \"When total weight exceeds 2500 kg, the system must provide a warning or impose restrictions.\"\n   }\n\n   constraint block WeightSumConstraint {\n      parameters: \n         chassisWeight: Real,\n         engineWeight: Real,\n         transmissionWeight: Real,\n         limit: Real = 2500.0\n      constraints:\n         (chassisWeight + engineWeight + transmissionWeight) <= limit\n   }\n\n   part def VehicleComponent {\n      value weight: Real;\n   }\n\n   part def Chassis :> VehicleComponent;\n   part def Engine :> VehicleComponent;\n   part def Transmission :> VehicleComponent;\n\n   block WeightManagementSystem {\n      part chassis: Chassis;\n      part engine: Engine;\n      part transmission: Transmission;\n\n      constraint componentWeightLimit: WeightSumConstraint {\n         chassisWeight -> chassis.weight,\n         engineWeight -> engine.weight,\n         transmissionWeight -> transmission.weight\n      }\n   }\n\n   satisfy WeightLimitSatisfaction {\n      requirement = WeightLimitRequirement\n      ownedMembers = WeightManagementSystem::componentWeightLimit\n   }\n\n   satisfy WeightRecordingSatisfaction {\n      requirement = WeightRecordingRequirement\n      ownedMembers = WeightManagementSystem::chassis,\n                     WeightManagementSystem::engine,\n                     WeightManagementSystem::transmission\n   }\n\n   satisfy WarningSatisfaction {\n      requirement = WarningRequirement\n      ownedMembers = WeightManagementSystem\n   }\n}",
    "package VehicleModel {\n   import Systems;\n   import Units::SI;\n\n   block Chassis {\n      attribute mass: Real (units: SI::kg);\n   }\n\n   block Engine {\n      attribute mass: Real (units: SI::kg);\n   }\n\n   block Transmission {\n      attribute mass: Real (units: SI::kg);\n   }\n\n   constraint TotalMassConstraint {\n      parameters:\n         chassisMass: Real (units: SI::kg);\n         engineMass: Real (units: SI::kg);\n         transmissionMass: Real (units: SI::kg);\n         totalMax: Real (units: SI::kg) = 2500;\n      constraints:\n         total: chassisMass + engineMass + transmissionMass <= totalMax;\n   }\n\n   constraint DynamicConstraint {\n      parameters:\n         m: Real (units: SI::kg);\n         v_i: Real (units: SI::m/s);\n         v_f: Real (units: SI::m/s);\n         F: Real (units: SI::N);\n         t: Real (units: SI::s);\n      constraints:\n         massPositive: m > 0;\n         newton: F * t =?= m * (v_f - v_i);\n   }\n\n   block Vehicle {\n      parts:\n         chassis: Chassis;\n         engine: Engine;\n         transmission: Transmission;\n\n      constraints:\n         totalMass: TotalMassConstraint {\n            chassisMass: chassis.mass,\n            engineMass: engine.mass,\n            transmissionMass: transmission.mass\n         };\n   }\n}",
    "package MaintenanceManagementSystem {\n   part def Vehicle {\n      attribute nextMaintenanceTime: Time;\n      attribute maintenanceInterval: Duration;\n      attribute maxAllowedTemperature: Real;\n      attribute lastHealthyStateEndTime: Time[0..1];\n      attribute maintenanceStartTime: Time[0..1];\n      attribute maintenanceEndTime: Time[0..1];\n\n      state machine {\n         initial -> Healthy;\n         state Healthy {\n            transition -> UnderMaintenance on MaintenanceDue {\n               effect {\n                  maintenanceStartTime = occurrence.time;\n                  lastHealthyStateEndTime = nextMaintenanceTime;\n               }\n            }\n         }\n         state UnderMaintenance {\n            transition -> Healthy on MaintenanceCompleted {\n               effect {\n                  maintenanceEndTime = occurrence.time;\n                  nextMaintenanceTime = maintenanceEndTime + maintenanceInterval;\n               }\n            }\n         }\n      }\n\n      constraint MaintenanceTiming {\n         condition: maintenanceStartTime exists implies {\n            maintenanceStartTime > nextMaintenanceTime;\n            maintenanceStartTime <= nextMaintenanceTime + 2 seconds;\n         }\n         condition: maintenanceEndTime exists implies \n            maintenanceEndTime - maintenanceStartTime <= 48 hours;\n      }\n   }\n\n   event MaintenanceDue;\n   event MaintenanceCompleted;\n}",
    "model VehicleSystem {\n  package MassValues {\n    value type kg {\n      unit = 'kg';\n    }\n  }\n\n  package TorqueValues {\n    value type Nm {\n      unit = 'N*m';\n    }\n  }\n\n  package SpeedValues {\n    value type rpm {\n      unit = 'rpm';\n    }\n  }\n\n  function engineTorqueFunction {\n    in speed : SpeedValues::rpm;\n    out torque : TorqueValues::Nm;\n  }\n\n  requirement Req1 {\n    id = 'REQ-1';\n    text = 'Total vehicle mass (curb weight + fuel mass) must not exceed maximum mass limit; fuel mass must be positive.';\n  }\n\n  requirement Req2 {\n    id = 'REQ-2';\n    text = 'Engine must generate torque per speed curve; torque must be transmitted through clutch to transmission for smooth power delivery.';\n  }\n\n  partdef Engine {\n    attribute speed : SpeedValues::rpm;\n    attribute torque : TorqueValues::Nm;\n    output torqueOut : TorqueValues::Nm;\n\n    constraint torqueCurve {\n      : torque = engineTorqueFunction(speed);\n    }\n  }\n\n  partdef Clutch {\n    input torqueIn : TorqueValues::Nm;\n    output torqueOut : TorqueValues::Nm;\n  }\n\n  partdef Transmission {\n    input torqueIn : TorqueValues::Nm;\n    output torqueOut : TorqueValues::Nm;\n  }\n\n  partdef DriveSystem {\n    input torqueIn : TorqueValues::Nm;\n  }\n\n  partdef Vehicle {\n    attribute curbWeight : MassValues::kg;\n    attribute fuelMass : MassValues::kg;\n    attribute maxMassLimit : MassValues::kg;\n\n    part engine : Engine;\n    part clutch : Clutch;\n    part transmission : Transmission;\n    part driveSystem : DriveSystem;\n\n    constraint totalMassConstraint {\n      : curbWeight + fuelMass <= maxMassLimit;\n      : fuelMass > 0;\n    }\n\n    connection engineToClutch {\n      end engine.torqueOut;\n      end clutch.torqueIn;\n    }\n\n    connection clutchToTransmission {\n      end clutch.torqueOut;\n      end transmission.torqueIn;\n    }\n\n    connection transmissionToDriveSystem {\n      end transmission.torqueOut;\n      end driveSystem.torqueIn;\n    }\n  }\n\n  satisfy MassRequirementSatisfaction {\n    requirement = Req1;\n    satisfiedBy = Vehicle.totalMassConstraint;\n  }\n\n  satisfy EngineRequirementSatisfaction {\n    requirement = Req2;\n    satisfiedBy = Vehicle.engine.torqueCurve;\n  }\n\n  satisfy TransmissionRequirementSatisfaction {\n    requirement = Req2;\n    satisfiedBy = Vehicle.engineToClutch, Vehicle.clutchToTransmission, Vehicle.transmissionToDriveSystem;\n  }\n}",
    "package VehicleSystem {\n  import sysml::core::*;\n  import sysml::units::si::*;\n\n  value type Mass {\n    unit: kilogram;\n    value: Real;\n  }\n\n  value type Torque {\n    unit: newton * meter;\n    value: Real;\n  }\n\n  requirement MassConstraints {\n    requirementId: \"REQ-1\";\n    text: \"With full fuel tank, total mass ≤ 2000 kg; with empty tank, total mass ≤ 1500 kg\";\n  }\n\n  requirement TorqueTransmission {\n    requirementId: \"REQ-2\";\n    text: \"Engine transmits generated torque to transmission via clutch interface\";\n  }\n\n  requirement EnginePerformance {\n    requirementId: \"REQ-3\";\n    text: \"Engine delivers torque according to speed-torque curve (Table 1)\";\n  }\n\n  interface ClutchInterface {\n    in torqueInput: Torque;\n    out torqueOutput: Torque;\n  }\n\n  part def Engine {\n    attribute maxTorque: Torque;\n    constraint TorqueCurve {\n      = \"Conforms to Table 1 speed-torque curve\";\n    }\n    port clutch: ClutchInterface::torqueOutput;\n  }\n\n  part def Transmission {\n    port clutch: ClutchInterface::torqueInput;\n  }\n\n  part def Vehicle {\n    attribute dryMass: Mass;\n    attribute fuelMass: Mass;\n    attribute totalMass: Mass {\n      = dryMass + fuelMass;\n    }\n    part engine: Engine;\n    part transmission: Transmission;\n    connection powertrain: ClutchInterface {\n      from engine.clutch;\n      to transmission.clutch;\n    }\n    constraint FullTankMass {\n      = totalMass <= 2000;\n    }\n    constraint EmptyTankMass {\n      = totalMass <= 1500;\n    }\n  }\n\n  satisfy MassSatisfaction {\n    requirement = MassConstraints;\n    satisfiedBy = [\n      Vehicle::FullTankMass,\n      Vehicle::EmptyTankMass\n    ];\n  }\n\n  satisfy TorqueSatisfaction {\n    requirement = TorqueTransmission;\n    satisfiedBy = Vehicle::powertrain;\n  }\n\n  satisfy PerformanceSatisfaction {\n    requirement = EnginePerformance;\n    satisfiedBy = Engine::TorqueCurve;\n  }\n}",
    "package VehicleProject {\n   part def Vehicle {\n      attributes:\n         emptyMass: Real;\n         fullMass: Real;\n      constraints:\n         massReq: Constraint {\n            parameters:\n               empty: Real;\n               full: Real;\n            constraints: [\n               empty <= 1500,\n               full <= 2000\n            ]\n         } {\n            bind empty to Vehicle::emptyMass;\n            bind full to Vehicle::fullMass;\n         }\n   }\n\n   part def Engine {\n      ports:\n         clutch: TorqueTransmitter;\n      attributes:\n         speed: Real;\n         torque: Real;\n      constraints:\n         torqueCurve: Constraint {\n            parameters:\n               spd: Real;\n               trq: Real;\n            constraint:\n               expression = \"trq conforms to performance table for given spd\"\n         } {\n            bind spd to Engine::speed;\n            bind trq to Engine::torque;\n         }\n   }\n\n   interfaceblock TorqueTransmitter {\n      flow torque: Real;\n   }\n\n   part Vehicle {\n      parts:\n         powertrain: Engine;\n   }\n}",
    "package VehicleSystem {\n   import SysML::libraries::SIUnits;\n\n   value type mass {\n      unit: SIUnits::kg;\n   }\n\n   value type newtonMeter {\n      unit: SIUnits::N*m;\n   }\n\n   interface Torque {\n      attribute value : newtonMeter;\n   }\n\n   block FuelTank {\n      attribute fuelMass : mass;\n   }\n\n   block Engine {\n      output torqueOutput : Torque;\n   }\n\n   block Clutch {\n      input torqueInput : Torque;\n      output torqueOutput : Torque;\n   }\n\n   block Gearbox {\n      input torqueInput : Torque;\n   }\n\n   constraint block MassConstraint {\n      parameter curbMass : mass;\n      parameter fuelMass : mass;\n      parameter limit : mass;\n      constraint totalMass : curbMass + fuelMass <= limit;\n   }\n\n   block Vehicle {\n      part fuelTank : FuelTank;\n      part engine : Engine;\n      part clutch : Clutch;\n      part gearbox : Gearbox;\n      attribute curbMass : mass;\n\n      constraint fullTankMass : MassConstraint {\n         curbMass = self.curbMass;\n         fuelMass = self.fuelTank.fuelMass;\n         limit = 2000 kg;\n      }\n\n      constraint emptyTankMass : MassConstraint {\n         curbMass = self.curbMass;\n         fuelMass = 0 kg;\n         limit = 1500 kg;\n      }\n\n      connections {\n         engine.torqueOutput -> clutch.torqueInput;\n         clutch.torqueOutput -> gearbox.torqueInput;\n      }\n   }\n\n   requirement MassReqFull {\n      id: 'REQ-MASS-FULL';\n      text: \"When fuel tank is full, total vehicle mass must not exceed 2000 kg.\";\n   }\n\n   requirement MassReqEmpty {\n      id: 'REQ-MASS-EMPTY';\n      text: \"When fuel tank is empty, total vehicle mass must not exceed 1500 kg.\";\n   }\n\n   requirement EngineTorqueReq {\n      id: 'REQ-ENG-TORQUE';\n      text: \"Engine must generate specified torque characteristics at various speeds.\";\n   }\n\n   requirement TorqueTransmissionReq {\n      id: 'REQ-TORQUE-TRANS';\n      text: \"Generated torque must be effectively transmitted to gearbox through clutch.\";\n   }\n\n   requirement ComplianceReq {\n      id: 'REQ-COMPLIANCE';\n      text: \"Vehicle mass control and power transmission must comply with design and safety standards.\";\n   }\n\n   satisfy MassFullSatisfaction {\n      requirement = MassReqFull;\n      subject = Vehicle::fullTankMass;\n   }\n\n   satisfy MassEmptySatisfaction {\n      requirement = MassReqEmpty;\n      subject = Vehicle::emptyTankMass;\n   }\n\n   satisfy EngineTorqueSatisfaction {\n      requirement = EngineTorqueReq;\n      subject = Engine;\n   }\n\n   satisfy TorqueTransmissionSatisfaction {\n      requirement = TorqueTransmissionReq;\n      subject = Vehicle::connections;\n   }\n\n   decompose ComplianceReq {\n      satisfy: MassReqFull;\n      satisfy: MassReqEmpty;\n      satisfy: EngineTorqueReq;\n      satisfy: TorqueTransmissionReq;\n   }\n}",
    "package VehicleDynamicPerformanceAnalysis {\n   part def DrivingCycle {\n      attribute time: Real[*];\n      attribute position: Real[*];\n      attribute speed: Real[*];\n   }\n\n   part def Vehicle {\n      attribute curbWeight: Real;\n      attribute payload: Real;\n      attribute wheelDiameter: Real;\n      attribute transmissionEfficiency: Real;\n      attribute fuelEconomyUrban: Real;\n      attribute fuelEconomyHighway: Real;\n   }\n\n   part def AnalysisSystem {\n      attribute vehicle: Vehicle;\n      attribute drivingCycle: DrivingCycle;\n      attribute energyConsumptionTarget: Real;\n\n      operation calculatePowerDemand(): Real[*];\n      operation calculateAcceleration(): Real[*];\n      operation calculateSpeed(): Real[*];\n      operation calculatePosition(): Real[*];\n      operation calculateFuelEconomy(): Real;\n      operation verifyCompliance(): Boolean;\n   }\n\n   requirement FuelEconomyRequirement {\n      requirementId: \"REQ-Energy\";\n      requirementText: \"Achieve specified fuel economy target\";\n   }\n\n   satisfy FuelEconomySatisfaction {\n      requirement = FuelEconomyRequirement;\n      assertedBy = AnalysisSystem::verifyCompliance;\n   }\n}",
    "package FuelEconomySimulation {\n    requirement FuelEconomyRequirement {\n        id: \"REQ-1\";\n        text: \"Vehicle fuel economy must exceed 30 miles per gallon under specified driving scenarios\";\n    }\n\n    part def Vehicle {\n        attribute curbWeight: Real;\n        attribute load: Real;\n        attribute wheelDiameter: Real;\n        attribute transmissionEfficiency: Real;\n    }\n\n    scenario def DrivingScenario {\n        attribute trajectory: Sequence(Real[3]);\n        attribute speedProfile: Sequence(Real[2]);\n    }\n\n    part def UrbanDrivingScenario: DrivingScenario;\n    part def HighwayDrivingScenario: DrivingScenario;\n\n    activity SimulateFuelEconomy {\n        in vehicle: Vehicle;\n        in scenario: DrivingScenario;\n        out fuelEconomyMPG: Real;\n        out fuelConsumptionLper100km: Real;\n\n        action CalculateWheelPower {\n            in vehicle: Vehicle;\n            in scenario: DrivingScenario;\n            out wheelPower: Real;\n        }\n\n        action ComputeVehicleDynamics {\n            in wheelPower: Real;\n            in vehicle: Vehicle;\n            out acceleration: Real;\n            out energyConsumption: Real;\n        }\n\n        action EstimateEnginePower {\n            in energyConsumption: Real;\n            in vehicle: Vehicle;\n            out enginePower: Real;\n        }\n\n        action CalculateFuelConsumption {\n            in enginePower: Real;\n            out fuelConsumption: Real;\n        }\n\n        action ConvertToMPG {\n            in fuelConsumption: Real;\n            out fuelEconomyMPG: Real;\n        }\n\n        action ConvertToLper100km {\n            in fuelConsumption: Real;\n            out fuelConsumptionLper100km: Real;\n        }\n\n        sequence {\n            wheelPower: CalculateWheelPower(\n                vehicle <- vehicle,\n                scenario <- scenario\n            ) -> \n            dynamics: ComputeVehicleDynamics(\n                wheelPower <- wheelPower,\n                vehicle <- vehicle\n            ) -> \n            enginePower: EstimateEnginePower(\n                energyConsumption <- dynamics.energyConsumption,\n                vehicle <- vehicle\n            ) -> \n            fuel: CalculateFuelConsumption(\n                enginePower <- enginePower\n            ) -> \n            mpg: ConvertToMPG(\n                fuelConsumption <- fuel.fuelConsumption\n            ) -> \n            l100km: ConvertToLper100km(\n                fuelConsumption <- fuel.fuelConsumption\n            );\n            fuelEconomyMPG: mpg.fuelEconomyMPG;\n            fuelConsumptionLper100km: l100km.fuelConsumptionLper100km;\n        }\n    }\n\n    case def VerifyFuelEconomy {\n        in testVehicle: Vehicle;\n        step urbanTest: SimulateFuelEconomy {\n            vehicle: testVehicle;\n            scenario: UrbanDrivingScenario;\n        };\n        step highwayTest: SimulateFuelEconomy {\n            vehicle: testVehicle;\n            scenario: HighwayDrivingScenario;\n        };\n        accept condition: urbanTest.fuelEconomyMPG > 30.0 and highwayTest.fuelEconomyMPG > 30.0;\n    }\n\n    satisfy FuelEconomyVerification {\n        requirement: FuelEconomyRequirement;\n        verifiedBy: VerifyFuelEconomy;\n    }\n}",
    "package EngineSelection {\n   block Engine {\n      value power: Real;\n      value mass: Real;\n      value efficiency: Real;\n      value cost: Real;\n   }\n\n   part def FourCylinderEngine : Engine;\n   part def SixCylinderEngine : Engine;\n\n   block EngineSelectionSystem {\n      part candidateEngines: Engine[*];\n      value recommendedEngine: Engine[0..1];\n\n      function evaluate(e: Engine): Real;\n\n      constraint {\n         if candidateEngines->isEmpty() then {\n            recommendedEngine = null;\n         } else {\n            recommendedEngine = candidateEngines->maxBy(e | evaluate(e));\n         }\n      }\n   }\n}",
    "package VehicleQualityCheck {\n   requirement def CurbWeightRequirement {\n      id: \"REQ-1\";\n      text: \"The curb weight of each vehicle must be less than or equal to 2,500 kilograms.\";\n   }\n\n   part def Vehicle {\n      attribute curbWeight: Real;\n   }\n\n   test case def CurbWeightTest {\n      verifiedRequirement = CurbWeightRequirement;\n      parameter vehicle: Vehicle;\n\n      action def CollectWeightData {\n         input vehicle: Vehicle;\n         output rawWeight: Real = vehicle.curbWeight;\n      }\n\n      action def ProcessWeightData {\n         input rawWeight: Real;\n         output processedWeight: Real = rawWeight;\n      }\n\n      action def EvaluateWeight {\n         input processedWeight: Real;\n         constraint : [processedWeight <= 2500];\n         output result: Boolean = (processedWeight <= 2500);\n      }\n\n      sequence {\n         CollectWeightData [vehicle = vehicle];\n         ProcessWeightData [rawWeight = CollectWeightData::rawWeight];\n         EvaluateWeight [processedWeight = ProcessWeightData::processedWeight];\n      }\n   }\n\n   part def QualityCheckSystem {\n      action: CurbWeightTest;\n   }\n}",
    "package MassVerificationSystem {\n    requirement MassLimit {\n        :> \"The actual mass of each vehicle must not exceed 2500 kilograms.\";\n    }\n\n    block Vehicle {\n        attribute mass: Real; // Represents current mass in kilograms\n    }\n\n    block WeighingEquipment {\n        operation measureMass(in vehicle: Vehicle): Real;\n    }\n\n    block MassVerificationUnit {\n        operation evaluateMass(in mass: Real): Boolean {\n            :> \"Returns true if mass <= 2500, false otherwise\";\n        }\n    }\n\n    block MassVerificationSystem {\n        part weighingEquipment: WeighingEquipment;\n        part massVerificationUnit: MassVerificationUnit;\n\n        activity VerifyMass {\n            parameter vehicle: Vehicle;\n            output isQualified: Boolean;\n\n            step measure: Real = weighingEquipment.measureMass(vehicle);\n            step isQualified = massVerificationUnit.evaluateMass(measure);\n        }\n\n        satisfy MassLimit {\n            :> VerifyMass;\n        }\n    }\n}",
    "package TransportationSystem {\n    part vehicle : Vehicle[1];\n    actor Driver;\n    actor Passenger[0..4];\n\n    requirement TransportationService : \"Provide convenient and efficient transportation\";\n    requirement OccupantCapacity : \"Support driver and up to four passengers\";\n    requirement Accessibility : \"Enable free and smooth entry/exit for users\";\n    requirement JourneySafety : \"Ensure safe travel from start to destination\";\n    requirement TravelComfort : \"Maintain comfortable ride experience\";\n    requirement EnvironmentalIntegration : \"Integrate environmental factors for safety and sustainability\";\n    requirement InfrastructureCompatibility : \"Maintain compatibility with related infrastructure\";\n    requirement HumanCenteredDesign : \"Center operation on human needs and conveniences\";\n\n    use case Travel {\n        satisfy TransportationService;\n        satisfy JourneySafety;\n        satisfy TravelComfort;\n        satisfy EnvironmentalIntegration;\n        satisfy InfrastructureCompatibility;\n    }\n    use case EnterExitVehicle {\n        satisfy Accessibility;\n        satisfy HumanCenteredDesign;\n    }\n\n    block Vehicle {\n        satisfy OccupantCapacity;\n        operation enter() : Boolean;\n        operation exit() : Boolean;\n        operation travel() : Boolean;\n    }\n\n    association environment : Environment[0..*];\n    association infrastructure : Infrastructure[0..*];\n}\n\nblock Environment;\nblock Infrastructure;",
    "package TransportationSystem {\n    part def Driver;\n    part def Passenger;\n    part def Vehicle;\n    part def Environment;\n    part def GasStation;\n\n    scenario def TransportationScenario {\n        :enterVehicle: {\n            action EnterVehicle {\n                performer Driver;\n                participant Passenger[0..4];\n                participant Vehicle;\n            }\n        }\n        :operateVehicle: {\n            action OperateVehicle {\n                performer Driver;\n                participant Vehicle;\n                input Environment;\n            }\n        }\n        :refuelOptional: [0..1] {\n            action Refuel {\n                performer Driver;\n                participant Vehicle;\n                participant GasStation;\n            }\n        }\n        :exitVehicle: {\n            action ExitVehicle {\n                performer Driver;\n                participant Passenger[0..4];\n                participant Vehicle;\n            }\n        }\n        sequence {\n            :enterVehicle -> :operateVehicle;\n            :operateVehicle -> :refuelOptional?;\n            :refuelOptional? -> :exitVehicle;\n        }\n    }\n\n    requirement \"Transportation Process\" {\n        text: \"Enable driver and up to four passengers to be transported safely from start to destination with simple interactions.\";\n        satisfiedBy: TransportationScenario;\n    }\n}",
    "package VehicleProductLine {\n   enum DiameterOption {\n      small = 70.0,\n      large = 100.0\n   }\n\n   part def Cylinder {\n      attribute diameter: DiameterOption;\n   }\n\n   abstract part def Engine {\n      part cylinder[*]: Cylinder;\n   }\n\n   part def FourCylinder: Engine {\n      part cylinder: Cylinder[4];\n   }\n\n   part def SixCylinder: Engine {\n      part cylinder: Cylinder[6];\n   }\n\n   abstract part def Transmission;\n\n   part def Manual: Transmission;\n\n   part def Automatic: Transmission;\n\n   part def Vehicle {\n      part engine: Engine;\n      part transmission: Transmission;\n\n      constraint ManualOnlyWithFourCylinder {\n         if transmission :> Manual then engine :> FourCylinder\n      }\n\n      constraint SixCylinderOnlyWithAutomatic {\n         if engine :> SixCylinder then transmission :> Automatic\n      }\n   }\n}",
    "package EngineSystem {\n   enum DiameterValue {\n      _70mm;\n      _100mm;\n   }\n\n   part def Cylinder {\n      attribute diameter : DiameterValue;\n   }\n\n   part def Engine {\n      attribute numberOfCylinders : Integer;\n      attribute cylinderDiameter : DiameterValue;\n\n      part cylinders : Cylinder[numberOfCylinders] {\n         :> diameter = cylinderDiameter;\n      }\n\n      constraint {\n         (numberOfCylinders = 4) or (numberOfCylinders = 6);\n      }\n   }\n\n   config FourCylinderEngine : Engine {\n      spec {\n         numberOfCylinders = 4;\n      }\n   }\n\n   config SixCylinderEngine : Engine {\n      spec {\n         numberOfCylinders = 6;\n      }\n   }\n}",
    "package AutomotiveConfiguration {\n    import Units::SI;\n\n    value type DiameterValue: Real {\n        unit SI::mm;\n    }\n\n    constraint block AllowedDiameter {\n        param diameter: DiameterValue;\n        constraint: diameter == 70 or diameter == 100;\n    }\n\n    abstract block Engine {\n        attribute cylinderDiameter: DiameterValue;\n        constraint diameterConstraint: AllowedDiameter {\n            diameter = cylinderDiameter;\n        }\n    }\n\n    block FourCylinderEngine:> Engine {}\n    block SixCylinderEngine:> Engine {}\n\n    abstract block Transmission {}\n    block ManualTransmission:> Transmission {}\n    block AutomaticTransmission:> Transmission {}\n\n    constraint block EngineTransmissionRule {\n        engine: Engine;\n        transmission: Transmission;\n        constraint: (engine instanceof FourCylinderEngine) implies (transmission instanceof ManualTransmission);\n        constraint: (engine instanceof SixCylinderEngine) implies (transmission instanceof AutomaticTransmission);\n    }\n\n    block Vehicle {\n        part engine: Engine[1];\n        part transmission: Transmission[1];\n        constraint configRule: EngineTransmissionRule {\n            engine = engine;\n            transmission = transmission;\n        }\n    }\n}",
    "package SystemModel {\n   value type DataFormat;\n   value type MessageFormat;\n\n   part def SoftwareDesign {\n      attribute dataFormat: DataFormat;\n      attribute messageFormat: MessageFormat;\n   }\n\n   part def ComputerSubsystem {\n      part software: SoftwareDesign;\n   }\n\n   part def StorageSubsystem {\n      attribute storedData: DataFormat[*];\n      operation storeMessage(in msg: MessageFormat);\n      operation retrieveMessage(out msg: MessageFormat);\n   }\n\n   part def SystemAssembly {\n      part computer: ComputerSubsystem;\n      part storage: StorageSubsystem;\n   }\n\n   requirement def SystemRequirement {\n      id: \"REQ-1\";\n      text: \"The software and hardware of the entire system must be able to work together seamlessly to ensure that the processes of information storage, transmission, and processing within the system are efficient, reliable, and compliant with the required data structure specifications.\";\n   }\n\n   satisfy SystemRequirement by SystemAssembly;\n}",
    "package PowertrainManagement {\n   part def PowertrainSystem {\n      part logicalLayer : LogicalLayer;\n      part physicalLayer : PhysicalLayer;\n\n      allocate logicalLayer.torqueGenerator to physicalLayer.powerUnit;\n   }\n\n   part def LogicalLayer {\n      part torqueGenerator : TorqueGenerator;\n   }\n\n   part def PhysicalLayer {\n      part powerUnit : PowerUnit;\n   }\n\n   part def TorqueGenerator {\n      action convertPowerToTorque {\n         in power : Power;\n         out torque : Torque;\n      }\n   }\n\n   part def PowerUnit {\n      action outputPower {\n         out power : Power;\n      }\n      action generateTorque {\n         out torque : Torque;\n      }\n   }\n\n   value type Power;\n   value type Torque;\n}",
    "package PowerTransmissionModel {\n   part def System {\n      part logical : TorqueGenerator;\n      part physical : Powertrain;\n      capability : PowerTorqueCapability;\n      satisfy {\n         satisfiedCapability = capability;\n         satisfyingFeature = logical.generateTorque;\n      }\n   }\n\n   capability def PowerTorqueCapability {\n      attribute : powerOutput;\n      attribute : torqueOutput;\n   }\n\n   part def TorqueGenerator {\n      action generateTorque {\n         in power : Power;\n         out torque : Torque;\n      }\n   }\n\n   part def Powertrain {\n      part engine : Engine;\n   }\n\n   part def Engine {\n      action generateTorque {\n         in fuel : Fuel;\n         out torque : Torque;\n      }\n   }\n\n   allocate System.logical to System.physical;\n   allocate System.logical.generateTorque to System.physical.engine.generateTorque;\n}",
    "package VehicleFeatureAnnotationSystem {\n    part def Vehicle {\n        attribute featureType : FeatureType;\n    }\n\n    part def InteriorAssembly {\n        attribute featureType : FeatureType;\n    }\n\n    part def BodyAssembly {\n        attribute featureType : FeatureType;\n    }\n\n    part def SeatBelt {\n        attribute function : String = \"Restrain occupants during collisions\";\n        attribute featureType : FeatureType = FeatureType::Safety;\n    }\n\n    part def FrontSeat {\n        attribute featureType : FeatureType = FeatureType::Safety;\n    }\n\n    part def DriverAirbag {\n        attribute function : String = \"Deploy during frontal impacts\";\n        attribute featureType : FeatureType = FeatureType::Safety;\n    }\n\n    part def AlarmSystem {\n        attribute function : String = \"Deter unauthorized access\";\n        attribute featureType : FeatureType = FeatureType::Security;\n    }\n\n    part def BodyShell {\n        attribute featureType : FeatureType = FeatureType::Safety;\n    }\n\n    part def Bumper {\n        attribute function : String = \"Absorb impact energy\";\n        attribute featureType : FeatureType = FeatureType::Safety;\n    }\n\n    part def KeylessEntry {\n        attribute function : String = \"Enable secure access without physical key\";\n        attribute featureType : FeatureType = FeatureType::Security;\n    }\n\n    enum FeatureType {\n        Safety,\n        Security\n    }\n\n    part Vehicle vehicle {\n        part interior : InteriorAssembly;\n        part body : BodyAssembly;\n    }\n\n    part InteriorAssembly interior {\n        part seatBelt : SeatBelt;\n        part frontSeat : FrontSeat;\n        part driverAirbag : DriverAirbag;\n        part alarm : AlarmSystem;\n    }\n\n    part BodyAssembly body {\n        part shell : BodyShell;\n        part bumper : Bumper;\n        part keylessEntry : KeylessEntry;\n    }\n}",
    "package VehicleDynamicSimulation {\n   part modelCenter : ModelCenter;\n\n   block VehicleDynamicSimulator {\n      reference analysisTool : ModelCenter;\n\n      operation runSimulation {\n         in initialVelocity: Real;\n         in initialPosition: Real;\n         in acceleration: Real;\n         in timeStep: Real;\n         out finalVelocity: Real;\n         out finalPosition: Real;\n      } = activity SimulateDynamics;\n   }\n\n   activity SimulateDynamics {\n      in initialVelocity: Real;\n      in initialPosition: Real;\n      in acceleration: Real;\n      in timeStep: Real;\n      out finalVelocity: Real;\n      out finalPosition: Real;\n\n      action compute: CallOperationAction {\n         target: this.analysisTool;\n         calledOperation: ModelCenter::compute;\n         argument initialVelocity: initialVelocity;\n         argument initialPosition: initialPosition;\n         argument acceleration: acceleration;\n         argument timeStep: timeStep;\n         result finalVelocity: finalVelocity;\n         result finalPosition: finalPosition;\n      }\n   }\n\n   block ModelCenter {\n      operation compute {\n         in initialVelocity: Real;\n         in initialPosition: Real;\n         in acceleration: Real;\n         in timeStep: Real;\n         out finalVelocity: Real;\n         out finalPosition: Real;\n      }\n   }\n\n   requirement \"Automated Simulation\" {\n      text: \"The system shall be capable of performing automated simulation and analysis of vehicle dynamic behavior.\";\n   }\n\n   requirement \"User Inputs\" {\n      text: \"Users should be able to input the vehicle’s initial velocity, initial position, acceleration at a specific moment, and the time step.\";\n   }\n\n   requirement \"ModelCenter Integration\" {\n      text: \"Through integration with the ModelCenter analysis tool, the system shall automatically calculate and output the vehicle’s velocity and position after the specified time step based on the given physical model.\";\n   }\n\n   requirement \"Data Integrity\" {\n      text: \"The system must ensure accurate data transfer and reliable output of simulation results, enabling users to conveniently obtain key dynamic parameters to support vehicle performance analysis and design optimization.\";\n   }\n\n   satisfy \"SimulationSatisfaction\" {\n      requirement = \"Automated Simulation\";\n      design = VehicleDynamicSimulator;\n   }\n\n   satisfy \"InputSatisfaction\" {\n      requirement = \"User Inputs\";\n      design = VehicleDynamicSimulator::runSimulation;\n   }\n\n   satisfy \"IntegrationSatisfaction\" {\n      requirement = \"ModelCenter Integration\";\n      design = [VehicleDynamicSimulator::analysisTool, SimulateDynamics::compute];\n   }\n\n   satisfy \"DataSatisfaction\" {\n      requirement = \"Data Integrity\";\n      design = [SimulateDynamics, ModelCenter::compute];\n   }\n}",
    "stereotype Safety {\n    attribute isMandatory: Boolean;\n}\n\npartdef SeatBelt {\n    :> Safety (isMandatory = true);\n}\n\npartdef Airbag {\n    :> Safety (isMandatory = false);\n}\n\npartdef Bumper {\n    :> Safety (isMandatory = true);\n}\n\npartdef ABS {\n    :> Safety (isMandatory = false);\n}\n\npartdef Wheel;\n\npartdef KeylessEntry;\n\npartdef Interior {\n    part seatBelt: SeatBelt[2];\n    part airbag: Airbag[0..1];\n}\n\npartdef Body {\n    part bumper: Bumper;\n}\n\npartdef WheelAssembly {\n    part wheel: Wheel[2];\n    part abs: ABS[0..1];\n}\n\npartdef Car {\n    part interior: Interior;\n    part body: Body;\n    part wheelAssembly: WheelAssembly;\n    part keylessEntry: KeylessEntry[0..1];\n}\n\npackage SafetyFeatures {\n    member SeatBelt;\n    member Airbag;\n    member Bumper;\n    member ABS;\n}\n\npackage MandatorySafetyFeatures {\n    member SeatBelt;\n    member Bumper;\n}",
    "package VehicleSafetyCompliance {\n    enum SafetyClassification {\n        mandatory,\n        optional\n    }\n\n    abstract block SafetyFeature {\n        attribute classification : SafetyClassification;\n    }\n\n    block MandatorySafetyFeature :> SafetyFeature {\n        attribute classification : SafetyClassification = SafetyClassification::mandatory;\n    }\n\n    block OptionalSafetyFeature :> SafetyFeature {\n        attribute classification : SafetyClassification = SafetyClassification::optional;\n    }\n\n    block SeatBelt :> MandatorySafetyFeature;\n    block DriversAirbag :> OptionalSafetyFeature;\n    block Bumper :> MandatorySafetyFeature;\n    block KeylessEntry :> OptionalSafetyFeature;\n    block ABS :> OptionalSafetyFeature;\n\n    block VehicleInterior {\n        part seatBelt : SeatBelt[2];\n        part driversAirbag : DriversAirbag[0..1];\n    }\n\n    block VehicleBody {\n        part bumper : Bumper;\n        part keylessEntry : KeylessEntry[0..1];\n    }\n\n    block ChassisSystem {\n        part abs : ABS[0..1];\n    }\n\n    block Vehicle {\n        part interior : VehicleInterior;\n        part body : VehicleBody;\n        part chassis : ChassisSystem;\n    }\n\n    block VehicleSafetyComplianceSystem {\n        reference targetVehicle : Vehicle;\n    }\n}",
    "package RiskManagementModel {\n    enum SeverityLevel {\n        Low,\n        Medium,\n        High,\n        Critical\n    }\n\n    abstract part def Occurrence {\n        attribute description: String;\n    }\n\n    part def Cause extends Occurrence {\n        attribute probability: Real; // Represents likelihood [0..1]\n    }\n\n    part def Situation extends Occurrence;\n\n    part def Failure extends Occurrence {\n        attribute severity: SeverityLevel;\n    }\n\n    association CausalRelationship {\n        source: Occurrence[1];\n        target: Occurrence[1];\n    }\n\n    part def RiskScenario {\n        attribute name: String;\n        reference involvedOccurrences: Occurrence[*];\n        reference causalLinks: CausalRelationship[*];\n    }\n}",
    "package RiskManagement {\n   enum Severity {\n      low;\n      medium;\n      high;\n      critical;\n   }\n\n   part def Failure {\n      attr: string description;\n      attr: Severity severityLevel;\n   }\n\n   part def Cause {\n      attr: string description;\n      attr: real occurrenceProbability;\n   }\n\n   part def Scenario {\n      attr: string description;\n      ref: Cause[*] cause;\n      ref: Failure[*] failure;\n      ref: Scenario[*] causalSource;\n      ref: Scenario[*] causalTarget;\n   }\n\n   part def RiskScenario {\n      attr: string description;\n      part: Scenario[*] scenario;\n      part: Cause[*] cause;\n      part: Failure[*] failure;\n   }\n}",
    "package RiskAnalysis {\n    part def Equipment {\n        part battery: Battery;\n    }\n\n    part def Battery {\n        attribute level: Real;\n        attribute age: Real;\n    }\n\n    state def OperationalState {\n        state normal;\n        state low_battery;\n        state shutdown;\n\n        transition from normal to low_battery: when [battery.level < MinThreshold];\n        transition from low_battery to shutdown: when [persists(low_battery, CriticalDuration)];\n    }\n\n    value def MinThreshold: Real = 15.0;\n    value def CriticalDuration: Duration = 30.0 min;\n\n    risk def BatteryAgingRisk {\n        cause: battery.age > AgingLimit;\n        effect: OperationalState::low_battery;\n    }\n\n    value def AgingLimit: Real = 5.0;\n\n    failure def DeviceShutdownFailure {\n        consequence: OperationalState::shutdown;\n        severity: 9;\n    }\n\n    part def RiskAnalysisSystem {\n        behavior MonitorBattery {\n            continuous {\n                monitor battery.level;\n                monitor battery.age;\n            }\n        }\n\n        behavior DetectFailureScenarios {\n            if OperationalState::low_battery then {\n                analyze failureScenario;\n            }\n            if OperationalState::shutdown then {\n                assign DeviceShutdownFailure.severity;\n                alert \"Critical failure: Device shutdown imminent\";\n            }\n        }\n    }\n\n    association between RiskAnalysisSystem and Equipment;\n}",
    "package StructuralDecomposition {\n   part def System {\n      :> topLevel;\n      part subsystem1: Subsystem;\n      part subsystem2: Subsystem;\n      connect subsystem1.interface1 -> subsystem2.interface2;\n   }\n\n   part def Subsystem {\n      part component1: Component;\n      part component2: Component;\n      port def interface1: Interface;\n      port def interface2: Interface;\n      connect component1.portA -> component2.portB;\n   }\n\n   part def Component {\n      port def portA: Interface;\n      port def portB: Interface;\n   }\n\n   interface def Interface {\n      in flow dataInput: Real;\n      out flow dataOutput: Real;\n   }\n\n   requirement def StructuralRequirement {\n      :> \"The system must possess clear structural decomposition capabilities\";\n   }\n\n   requirement def InterfaceRequirement {\n      :> \"Interfaces between components must be well-defined\";\n   }\n\n   requirement def VerificationRequirement {\n      :> \"IV&V parties must verify system integrity through structural view\";\n   }\n\n   satisfy StructuralRequirementSatisfaction {\n      satisfiedBy = topLevel;\n      requirement = StructuralRequirement;\n   }\n\n   satisfy InterfaceRequirementSatisfaction {\n      satisfiedBy = System.interface1, System.interface2;\n      requirement = InterfaceRequirement;\n   }\n\n   satisfy VerificationRequirementSatisfaction {\n      satisfiedBy = topLevel;\n      requirement = VerificationRequirement;\n   }\n}",
    "package AutomotiveSystem {\n   enum SafetyStatus {\n      mandatory,\n      optional\n   }\n\n   block Component {\n      port interface : Interface;\n   }\n\n   block SafetyComponent extends Component {\n      attribute safetyStatus : SafetyStatus;\n   }\n\n   block AutomotiveSystem {\n      part subsystem : Subsystem[*];\n      part component : Component[*];\n   }\n\n   block Subsystem {\n      part component : Component[*];\n   }\n\n   part automotiveSystem : AutomotiveSystem;\n\n   part seatBelt : SafetyComponent {\n      safetyStatus = SafetyStatus::mandatory;\n   }\n\n   part bumper : SafetyComponent {\n      safetyStatus = SafetyStatus::mandatory;\n   }\n\n   part driverAirbag : SafetyComponent {\n      safetyStatus = SafetyStatus::optional;\n   }\n\n   part abs : SafetyComponent {\n      safetyStatus = SafetyStatus::optional;\n   }\n\n   view TreeView {\n      description: \"Hierarchical structure of all components\";\n      tree automotiveSystem;\n   }\n\n   view SafetyTableView {\n      description: \"Safety components with status\";\n      table SafetyComponent {\n         column part;\n         column safetyStatus;\n      }\n   }\n\n   view NonSafetyTableView {\n      description: \"Non-safety components list\";\n      table Component {\n         filter not oclIsKindOf(SafetyComponent);\n         column part;\n      }\n   }\n}",
    "package AutomotiveDomain {\n   comment \"Standardized definitions and annotations for fundamental automotive concepts.\"\n\n   value type Torque {\n      comment \"Physical quantity representing rotational force, measured in Newton meters (N·m).\"\n   }\n\n   part def Automobile {\n      alias \"汽车 (Car)\"\n      comment \"Core component representing a road vehicle, typically with four wheels, powered by an internal combustion engine or electric motor.\"\n\n      attribute engineTorque: Torque {\n         comment \"Maximum torque output of the vehicle's powertrain system.\"\n      }\n   }\n\n   comment \"Model designed for clarity and extensibility to support development, integration, and maintenance of automotive systems.\"\n}",
    "package DocumentManagementPlatform {\n    class Automobile {\n        alias car: Car[1];\n    }\n\n    alias Car = Automobile;\n\n    class Document;\n\n    class ExplanatoryDocument :> Document;\n\n    type TorqueValue: Real {\n        unit: 'N·m';\n    }\n\n    association {\n        annotatedElement: Element[0..*];\n        explanatoryDocument: ExplanatoryDocument[0..*];\n    }\n\n    part def ManagementSystem {\n        attribute managedAutomobiles: Automobile[0..*];\n        attribute storedDocuments: Document[0..*];\n    }\n}",
    "package AutomobileSystem {\n   import PhysicalQuantities::*;\n\n   alias Car = Automobile;\n\n   block Automobile {\n      attribute torqueSpec: Torque;\n   }\n}\n\npackage PhysicalQuantities {\n   unit Nm;\n\n   value type TorqueValue {\n      value: Real;\n      unit: Nm;\n   }\n\n   alias Torque = TorqueValue;\n}",
    "part def Cylinder {\n}\n\npart def Engine {\n   part cylinders : Cylinder[4..6];\n}\n\npart def Vehicle {\n   part engine : Engine;\n}\n\npart def SmallVehicle : Vehicle {\n   constraint {\n      engine.cylinders->size() = 4\n   }\n}\n\npart def LargeVehicle : Vehicle {\n   constraint {\n      engine.cylinders->size() = 6\n   }\n}",
    "package FuelSystem {\n   interface FuelSupplyInterface;\n   interface FuelReturnInterface;\n\n   part FuelTank {\n      port supply: out FuelSupplyInterface;\n      port return: in FuelReturnInterface;\n   }\n\n   part Engine {\n      port supply: in FuelSupplyInterface;\n      port return: out FuelReturnInterface;\n   }\n\n   part FuelManagementSystem {\n      part tank: FuelTank;\n      part engine: Engine;\n\n      connection fuelSupply: from tank.supply to engine.supply;\n      connection fuelReturn: from engine.return to tank.return;\n\n      action manageFlow: {\n         inout fuel: via fuelSupply, fuelReturn;\n         do manageTemperature;\n      }\n\n      action manageTemperature: {\n         inout fuel: via fuelSupply, fuelReturn;\n      }\n   }\n}",
    "package VehicleStructure {\n   unit kg;\n   unit deg;\n\n   part def Wheel {\n   }\n\n   part def Axle {\n   }\n\n   part def FrontAxle specializes Axle {\n      value property steeringAngle: Real (unit = deg);\n   }\n\n   part def AxleAssembly {\n      part left: Wheel;\n      part right: Wheel;\n      part axle: Axle;\n   }\n\n   part def Vehicle {\n      value property mass: Real (unit = kg);\n      part front: AxleAssembly;\n      part rear: AxleAssembly;\n   }\n}"
]