[
    "package 'Vehicle System' {\n    attribute def Mass;\n    attribute def Gear;\n    attribute def Accelerator;\n    part def Engine;\n    part def Driver;\n    part def Vehicle {\n        value mass: Mass;\n        value currentGear: Gear;\n        value acceleratorPosition: Accelerator;\n        part engine: Engine;\n        reference driver: Driver[0..1];\n    }\n}",
    "package 'Vehicle System' {\n    part def Personnel;\n    part def Engine;\n    class def Vehicle;\n    class def ManuallyOperated: Vehicle {\n        part driver: Personnel[1];\n    }\n    class def Powered: Vehicle {\n        part powerSource: Engine[1];\n    }\n    class def ManuallyOperatedPowered: ManuallyOperated, Powered;\n}",
    "package 'VehicleStructure' {\n    abstract part def VehicleComponent;\n    part def Engine :> VehicleComponent;\n    part def Transmission :> VehicleComponent;\n    part def Wheel :> VehicleComponent;\n    abstract part def Vehicle;\n    part def StandardVehicle :> Vehicle {\n        part engine: Engine[1];\n        part transmission: Transmission[1];\n        part wheel: Wheel[4];\n    }\n}",
    "package 'VehicleSystem' {\n    class Vehicle {\n        part engine : Engine[1];\n    }\n    class SmallVehicle subclass Vehicle {\n        part engine : SmallEngine[1] redefines Vehicle::engine;\n    }\n    class LargeVehicle subclass Vehicle {\n        part engine : LargeEngine[1] redefines Vehicle::engine;\n    }\n    class Engine {\n        attribute cylinders : Integer;\n    }\n    class SmallEngine subclass Engine {\n        attribute cylinders = 4;\n        constraint cylinders == 4;\n    }\n    class LargeEngine subclass Engine {\n        attribute cylinders = 6;\n        constraint cylinders == 6;\n    }\n}",
    "package 'TrafficSignalSystem' {\n    enum TrafficLightColor {\n        Green;\n        Yellow;\n        Red;\n    }\n    part def TrafficSignal {\n        attribute currentColor: TrafficLightColor;\n    }\n    part def AlwaysGreenSignal:> TrafficSignal {\n        constraint currentColor == TrafficLightColor::Green;\n    }\n}",
    "package 'InformationClassification' {\n    enum SecurityLevel {\n        Unclassified,\n        Confidential,\n        Secret\n    }\n    enum Grade {\n        A,\n        B,\n        C,\n        D,\n        F\n    }\n    part def SecurityClassification {\n        attribute level: SecurityLevel;\n        attribute code: string;\n        attribute color: string;\n    }\n    individual Unclassified: SecurityClassification {\n        level = SecurityLevel::Unclassified;\n        code = \"uncl\";\n        color = \"green\";\n    }\n    individual Confidential: SecurityClassification {\n        level = SecurityLevel::Confidential;\n        code = \"conf\";\n        color = \"yellow\";\n    }\n    individual Secret: SecurityClassification {\n        level = SecurityLevel::Secret;\n        code = \"secr\";\n        color = \"red\";\n    }\n    part def GradeClassification {\n        attribute grade: Grade;\n        attribute points: float;\n    }\n    individual GradeA: GradeClassification {\n        grade = Grade::A;\n        points = 4.0;\n    }\n    individual GradeB: GradeClassification {\n        grade = Grade::B;\n        points = 3.0;\n    }\n    individual GradeC: GradeClassification {\n        grade = Grade::C;\n        points = 2.0;\n    }\n    individual GradeD: GradeClassification {\n        grade = Grade::D;\n        points = 1.0;\n    }\n    individual GradeF: GradeClassification {\n        grade = Grade::F;\n        points = 0.0;\n    }\n    part def Information {\n        attribute security: SecurityClassification;\n        attribute grade: GradeClassification;\n    }\n}",
    "package 'VehicleSystem' {\n    block Cylinder;\n\n    block Engine;\n\n    block FourCylinderEngine specializes Engine {\n        part cylinder[4] : Cylinder;\n    }\n\n    block SixCylinderEngine specializes Engine {\n        part cylinder[6] : Cylinder;\n    }\n\n    block Vehicle {\n        part engine : Engine;\n    }\n\n    block SmallVehicle specializes Vehicle {\n        redefines engine : FourCylinderEngine;\n    }\n\n    block LargeVehicle specializes Vehicle {\n        redefines engine : SixCylinderEngine;\n    }\n}",
    "package 'VehicleModelingSystem' {\n    attribute def QualityAttribute;\n    attribute def FuelType;\n    attribute def Personnel {\n        attribute name: string;\n    }\n    part def FuelTank {\n        attribute fuelType: ref FuelType;\n    }\n    part def Vehicle {\n        attribute quality: QualityAttribute;\n        attribute driver: ref Personnel;\n        part fuelTank: FuelTank;\n    }\n    part context {\n        part vehicles: Vehicle[*];\n        part personnelList: Personnel[*];\n        part fuelTypes: FuelType[*];\n    }\n}",
    "package 'AutomobileWheelAssembly' {\n    part def WheelBearingUnit {\n        part threadedHoles: ThreadedHole[4];\n    }\n    part def Tire {\n        part beads: Bead[2];\n    }\n    part def Hub {\n        part rims: Rim[2];\n        part mountingHoles: BoltMountingHole[4];\n    }\n    part def Bolt;\n    part def Bead;\n    part def Rim;\n    part def BoltMountingHole;\n    part def ThreadedHole;\n    part context {\n        part wheelBearingUnit: WheelBearingUnit;\n        part tire: Tire;\n        part hub: Hub;\n        part bolts: Bolt[4];\n        connector beadToRim[2] {\n            for i in 1..2 {\n                connect tire.beads[i] to hub.rims[i];\n            }\n        }\n        connector hubToWheelBearingUnit[4] {\n            for i in 1..4 {\n                connect hub.mountingHoles[i] to wheelBearingUnit.threadedHoles[i] via bolts[i];\n            }\n        }\n    }\n}",
    "package 'FuelFlowManagement' {\n    attribute def Fuel;\n    attribute def Temperature;\n    attribute def FuelFlowData {\n        attribute supplyFlow: Real;\n        attribute returnFlow: Real;\n        attribute temp: Temperature;\n    }\n    port def FuelInterface {\n        out supply: Fuel;\n        in return: Fuel;\n    }\n    port def MonitoringPort {\n        out data: FuelFlowData;\n    }\n    action fuelManagement {\n        action supplyFuel { out supply: Fuel; }\n        action receiveSupply { in supply: Fuel; }\n        succession flow supplyFlow from supplyFuel.supply to receiveSupply.supply;\n        action returnExcess { out return: Fuel; }\n        action receiveReturn { in return: Fuel; }\n        succession flow returnFlow from returnExcess.return to receiveReturn.return;\n        action measureTemperature { out temperature: Temperature; }\n        action collectData {\n            in supply: Fuel;\n            in return: Fuel;\n            in temperature: Temperature;\n            out data: FuelFlowData;\n        }\n        action sendData { out data: FuelFlowData; }\n        action receiveData { in data: FuelFlowData; }\n        flow from supplyFuel.supply to collectData.supply;\n        flow from receiveReturn.return to collectData.return;\n        flow from measureTemperature.temperature to collectData.temperature;\n        flow from collectData.data to sendData.data;\n        succession flow dataFlow from sendData.data to receiveData.data;\n    }\n    part context {\n        part fuelTank {\n            port fuelInterface: FuelInterface;\n            port monitoringPort: MonitoringPort;\n            perform fuelManagement.supplyFuel {\n                out supply = fuelInterface.supply;\n            }\n            perform fuelManagement.receiveReturn {\n                in return = fuelInterface.return;\n            }\n            perform fuelManagement.measureTemperature;\n            perform fuelManagement.collectData;\n            perform fuelManagement.sendData {\n                out data = monitoringPort.data;\n            }\n        }\n        part engine {\n            port fuelInterface: ~FuelInterface;\n            perform fuelManagement.receiveSupply {\n                in supply = fuelInterface.supply;\n            }\n            perform fuelManagement.returnExcess {\n                out return = fuelInterface.return;\n            }\n        }\n        part user {\n            port monitoringPort: ~MonitoringPort;\n            perform fuelManagement.receiveData {\n                in data = monitoringPort.data;\n            }\n        }\n        interface fuelTransfer \n            connect fuelTank.fuelInterface to engine.fuelInterface \n        {\n            ref flow references fuelManagement.supplyFlow \n                from source.supply to target.supply;\n            ref flow references fuelManagement.returnFlow \n                from target.return to source.return;\n        }\n        interface monitoring \n            connect fuelTank.monitoringPort to user.monitoringPort \n        {\n            ref flow references fuelManagement.dataFlow \n                from source.data to target.data;\n        }\n    }\n}",
    "package 'Vehicle Configuration' {\n    attribute def Mass: Real;\n    attribute def SteeringAngle: Real;\n    \n    part def Tire {\n        attribute mass: Mass;\n    }\n    \n    part def Axle {\n        attribute mass: Mass;\n        part tire: Tire[2] ordered;\n    }\n    \n    part def FrontAxle: Axle;\n    part def RearAxle: Axle;\n    \n    part def FrontAxleWithSteering: FrontAxle {\n        attribute steeringAngle: SteeringAngle;\n    }\n    \n    part def Vehicle {\n        attribute mass: Mass = 1750;\n        part frontAxle: FrontAxle[1];\n        part rearAxle: RearAxle[1];\n    }\n    \n    part defaultVehicle: Vehicle;\n    \n    part vehicle1_c1: Vehicle {\n        attribute mass = 2000;\n        part frontAxle: FrontAxleWithSteering;\n    }\n}",
    "package 'CouplingSystem' {\n    port def HitchAttachPort;\n    port def BallSocketPort;\n    \n    part def Vehicle {\n        port hitchPort: ~HitchAttachPort;\n    }\n    \n    part def Ball {\n        port socket: BallSocketPort;\n    }\n    \n    part def Hitch {\n        port vehicleAttachPort: HitchAttachPort;\n        part ball: Ball;\n        port ballPort: BallSocketPort {\n            bind to ball.socket;\n        }\n    }\n    \n    part def Trailer {\n        port couplingPort: ~BallSocketPort;\n    }\n    \n    part context {\n        part vehicle: Vehicle;\n        part trailer: Trailer;\n        part hitch: Hitch;\n        \n        connector vehicleToHitch connect vehicle.hitchPort to hitch.vehicleAttachPort;\n        connector trailerToBall connect trailer.couplingPort to hitch.ballPort;\n    }\n}",
    "package 'VehiclePowerTransmission' {\n    attribute def FuelCmd;\n    attribute def MechanicalPower;\n    attribute def ClutchEngagement;\n    \n    port def FuelCmdPort {\n        in fuelCmd: FuelCmd;\n    }\n    port def ClutchEngagementPort {\n        out clutchEngagement: ClutchEngagement;\n    }\n    port def MechanicalPowerPort {\n        out mechanicalPower: MechanicalPower;\n    }\n    \n    part context {\n        part controller {\n            port fuelCmdPort: ~FuelCmdPort;\n        }\n        part engine {\n            port fuelCmdPort: FuelCmdPort;\n            port clutchEngagementPort: ClutchEngagementPort;\n            port powerPort: MechanicalPowerPort;\n        }\n        part clutch {\n            port enginePowerPort: ~MechanicalPowerPort;\n            port engineClutchPort: ~ClutchEngagementPort;\n            port transmissionPowerPort: MechanicalPowerPort;\n        }\n        part transmission {\n            port inputPowerPort: ~MechanicalPowerPort;\n            port outputPowerPort: MechanicalPowerPort;\n        }\n        part driveshaft {\n            port inputPowerPort: ~MechanicalPowerPort;\n            port outputPowerPort: MechanicalPowerPort;\n        }\n        part rearAxle {\n            port inputPowerPort: ~MechanicalPowerPort;\n            port leftOutputPort: MechanicalPowerPort;\n            port rightOutputPort: MechanicalPowerPort;\n            \n            part differential {\n                port inputPowerPort: ~MechanicalPowerPort;\n                port leftOutputPort: MechanicalPowerPort;\n                port rightOutputPort: MechanicalPowerPort;\n            }\n            part leftHalfShaft {\n                port inputPowerPort: ~MechanicalPowerPort;\n                port outputPowerPort: MechanicalPowerPort;\n            }\n            part rightHalfShaft {\n                port inputPowerPort: ~MechanicalPowerPort;\n                port outputPowerPort: MechanicalPowerPort;\n            }\n            \n            binding differential.inputPowerPort = inputPowerPort;\n            binding leftHalfShaft.inputPowerPort = differential.leftOutputPort;\n            binding rightHalfShaft.inputPowerPort = differential.rightOutputPort;\n            binding leftHalfShaft.outputPowerPort = leftOutputPort;\n            binding rightHalfShaft.outputPowerPort = rightOutputPort;\n        }\n        part leftWheel {\n            port axlePort: ~MechanicalPowerPort;\n            port roadPort: MechanicalPowerPort;\n        }\n        part rightWheel {\n            port axlePort: ~MechanicalPowerPort;\n            port roadPort: MechanicalPowerPort;\n        }\n        part road {\n            port leftWheelPort: ~MechanicalPowerPort;\n            port rightWheelPort: ~MechanicalPowerPort;\n        }\n        \n        interface fuelFlow connect controller.fuelCmdPort to engine.fuelCmdPort;\n        interface enginePowerToClutch connect engine.powerPort to clutch.enginePowerPort;\n        interface engineClutchToClutch connect engine.clutchEngagementPort to clutch.engineClutchPort;\n        interface clutchToTransmission connect clutch.transmissionPowerPort to transmission.inputPowerPort;\n        interface transmissionToDriveshaft connect transmission.outputPowerPort to driveshaft.inputPowerPort;\n        interface driveshaftToRearAxle connect driveshaft.outputPowerPort to rearAxle.inputPowerPort;\n        interface leftAxleToWheel connect rearAxle.leftOutputPort to leftWheel.axlePort;\n        interface rightAxleToWheel connect rearAxle.rightOutputPort to rightWheel.axlePort;\n        interface leftWheelToRoad connect leftWheel.roadPort to road.leftWheelPort;\n        interface rightWheelToRoad connect rightWheel.roadPort to road.rightWheelPort;\n    }\n}",
    "package 'MultiArchSystem' {\n    signal def SignalType;\n    interface def pe;\n    interface def pf;\n    port def pb: pe;\n    port def pd: pf;\n    port def signalPort: SignalType;\n    \n    part def c1 {\n        port pb: pb;\n        port p1: signalPort;\n    }\n    part def c2 {\n        port p2: signalPort;\n    }\n    part def c3 {\n        port pd: pd;\n        port p3: signalPort;\n    }\n    part def c4 {\n        port p4: signalPort;\n    }\n    \n    part def b11 {\n        part c1: c1;\n        part c2: c2;\n        connection c1ToC2 connect c1.p1 to c2.p2;\n        port pePort: pe;\n        bind peBinding bind pePort to c1.pb;\n    }\n    part def b12 {\n        part c3: c3;\n        part c4: c4;\n        connection c3ToC4 connect c3.p3 to c4.p4;\n        port pfPort: pf;\n        bind pfBinding bind pfPort to c3.pd;\n    }\n    part context system1 {\n        part b11: b11;\n        part b12: b12;\n        connection b11ToB12 connect b11.pePort to b12.pfPort;\n    }\n    \n    part def b21 {\n        part c1: c1;\n        part c2: c2;\n    }\n    part def b22 {\n        part c3: c3;\n        part c4: c4;\n    }\n    part context system2 {\n        part b21: b21;\n        part b22: b22;\n    }\n}",
    "package 'AutomotivePowertrain' {\n    attribute def StartStopCmd;\n    attribute def FuelCmd;\n    attribute def Torque;\n    port def StartStopPort {\n        out startStop: StartStopCmd;\n    }\n    port def FuelPort {\n        out fuel: FuelCmd;\n    }\n    port def TorquePort {\n        out torque: Torque;\n    }\n    part context {\n        part user {\n            port startStopPort: StartStopPort;\n            port fuelPort: FuelPort;\n            perform powertrainOperation.sendStartStopCmd {\n                out startStop = startStopPort.startStop;\n            }\n            perform powertrainOperation.sendFuelCmd {\n                out fuel = fuelPort.fuel;\n            }\n        }\n        interface userToEngine connect user.startStopPort, user.fuelPort to engine.startStopPort, engine.fuelPort {\n            ref flow references powertrainOperation.cmdFlow\n                from source.startStop to target.startStop;\n            ref flow references powertrainOperation.fuelFlow\n                from source.fuel to target.fuel;\n        }\n        part engine {\n            port startStopPort: ~StartStopPort;\n            port fuelPort: ~FuelPort;\n            port torquePort: TorquePort;\n            perform powertrainOperation.produceTorque {\n                in startStop = startStopPort.startStop;\n                in fuel = fuelPort.fuel;\n                out torque = torquePort.torque;\n            }\n        }\n        part transmission {\n            port torqueInPort: ~TorquePort;\n            port torqueOutPort: TorquePort;\n            perform powertrainOperation.amplifyTorque {\n                in torque = torqueInPort.torque;\n                out torque = torqueOutPort.torque;\n            }\n        }\n        interface engineToTransmission connect engine.torquePort to transmission.torqueInPort {\n            ref flow references powertrainOperation.torqueFlow1\n                from source.torque to target.torque;\n        }\n        part driveshaft {\n            port torqueInPort: ~TorquePort;\n            port torqueOutPort: TorquePort;\n            perform powertrainOperation.transmitTorque {\n                in torque = torqueInPort.torque;\n                out torque = torqueOutPort.torque;\n            }\n        }\n        interface transmissionToDriveshaft connect transmission.torqueOutPort to driveshaft.torqueInPort {\n            ref flow references powertrainOperation.torqueFlow2\n                from source.torque to target.torque;\n        }\n        part differential {\n            port torqueInPort: ~TorquePort;\n            port leftTorquePort: TorquePort;\n            port rightTorquePort: TorquePort;\n            perform powertrainOperation.distributeTorque {\n                in torque = torqueInPort.torque;\n                out leftTorque = leftTorquePort.torque;\n                out rightTorque = rightTorquePort.torque;\n            }\n        }\n        interface driveshaftToDifferential connect driveshaft.torqueOutPort to differential.torqueInPort {\n            ref flow references powertrainOperation.torqueFlow3\n                from source.torque to target.torque;\n        }\n    }\n    action powertrainOperation {\n        action sendStartStopCmd { out startStop: StartStopCmd; }\n        action sendFuelCmd { out fuel: FuelCmd; }\n        succession flow cmdFlow from sendStartStopCmd.startStop to produceTorque.startStop;\n        succession flow fuelFlow from sendFuelCmd.fuel to produceTorque.fuel;\n        action produceTorque { in startStop; in fuel; out torque: Torque; }\n        succession flow torqueFlow1 from produceTorque.torque to amplifyTorque.torque;\n        action amplifyTorque { in torque: Torque; out torque: Torque; }\n        succession flow torqueFlow2 from amplifyTorque.torque to transmitTorque.torque;\n        action transmitTorque { in torque: Torque; out torque: Torque; }\n        succession flow torqueFlow3 from transmitTorque.torque to distributeTorque.torque;\n        action distributeTorque { in torque: Torque; out leftTorque: Torque; out rightTorque: Torque; }\n    }\n}",
    "package 'AutomotivePowertrain' {\n    attribute def FuelControlCmd;\n    attribute def StallSignal;\n    attribute def Torque;\n    \n    port def FuelControlPort {\n        out fuelControlCmd: FuelControlCmd;\n    }\n    port def StallSignalPort {\n        out stallSignal: StallSignal;\n    }\n    port def TorquePort {\n        out torque: Torque;\n    }\n    \n    part context {\n        part user {\n            port fuelControlPort: FuelControlPort;\n            port stallSignalPort: StallSignalPort;\n            perform powertrainControl.sendFuelControlCmd {\n                out fuelControlCmd = fuelControlPort.fuelControlCmd;\n            }\n            perform haltProcesses.sendStallSignal {\n                out stallSignal = stallSignalPort.stallSignal;\n            }\n        }\n        interface userToPowertrainFuel connect user.fuelControlPort to powertrain.fuelControlPort {\n            ref flow references powertrainControl.fuelControlFlow \n                from source.fuelControlCmd to target.fuelControlCmd;\n        }\n        interface userToPowertrainStall connect user.stallSignalPort to powertrain.stallSignalPort {\n            ref flow references haltProcesses.stallSignalFlow \n                from source.stallSignal to target.stallSignal;\n        }\n        part powertrain {\n            port fuelControlPort: ~FuelControlPort;\n            port stallSignalPort: ~StallSignalPort;\n            port torquePort: TorquePort;\n            perform powertrainControl.engineStart {\n                in fuelControlCmd = fuelControlPort.fuelControlCmd;\n                out torque = torquePort.torque;\n            }\n            perform haltProcesses.engineShutdown {\n                in stallSignal = stallSignalPort.stallSignal;\n            }\n        }\n        part driveWheels {\n            port torquePort: ~TorquePort;\n            perform powertrainControl.deliverTorque {\n                in torque = torquePort.torque;\n            }\n        }\n        interface powertrainToWheels connect powertrain.torquePort to driveWheels.torquePort {\n            ref flow references powertrainControl.torqueFlow \n                from source.torque to target.torque;\n        }\n    }\n    \n    action powertrainControl {\n        action sendFuelControlCmd { out fuelControlCmd: FuelControlCmd; }\n        action engineStart { in fuelControlCmd; out torque: Torque; }\n        succession flow fuelControlFlow from sendFuelControlCmd.fuelControlCmd to engineStart.fuelControlCmd;\n        \n        action amplifyTorque { in torque; out amplifiedTorque: Torque; }\n        succession flow torqueAmplifyFlow from engineStart.torque to amplifyTorque.torque;\n        \n        action transmitTorque { in amplifiedTorque; out transmittedTorque: Torque; }\n        succession flow torqueTransmitFlow from amplifyTorque.amplifiedTorque to transmitTorque.amplifiedTorque;\n        \n        action distributeTorque { in transmittedTorque; out distributedTorque: Torque; }\n        succession flow torqueDistributeFlow from transmitTorque.transmittedTorque to distributeTorque.transmittedTorque;\n        \n        action deliverTorque { in distributedTorque: Torque; }\n        succession flow torqueFlow from distributeTorque.distributedTorque to deliverTorque.distributedTorque;\n    }\n    \n    action haltProcesses {\n        action sendStallSignal { out stallSignal: StallSignal; }\n        action engineShutdown { in stallSignal: StallSignal; }\n        succession flow stallSignalFlow from sendStallSignal.stallSignal to engineShutdown.stallSignal;\n    }\n}",
    "package 'VehiclePowertrain' {\n    attribute def FuelCmd;\n    attribute def StartSignal;\n    attribute def ShutdownSignal;\n    attribute def Torque;\n    \n    port def DriverPort {\n        out fuelCmd: FuelCmd;\n        out startSignal: StartSignal;\n        out shutdownSignal: ShutdownSignal;\n    }\n    \n    port def EnginePort {\n        in fuelCmd: FuelCmd;\n        in startSignal: StartSignal;\n        in shutdownSignal: ShutdownSignal;\n        out torque: Torque;\n    }\n    \n    port def TransmissionPort {\n        in torque: Torque;\n        out amplifiedTorque: Torque;\n    }\n    \n    port def WheelDistributorPort {\n        in torque: Torque;\n    }\n    \n    part context {\n        part driver {\n            port driverPort: DriverPort;\n            perform powertrainManagement.sendCommands {\n                out fuelCmd = driverPort.fuelCmd;\n                out startSignal = driverPort.startSignal;\n                out shutdownSignal = driverPort.shutdownSignal;\n            }\n        }\n        \n        part powertrainSystem {\n            port enginePort: ~EnginePort;\n            port transmissionPort: ~TransmissionPort;\n            port distributorPort: ~WheelDistributorPort;\n            \n            perform powertrainManagement.generateTorque {\n                in fuelCmd = enginePort.fuelCmd;\n                in startSignal = enginePort.startSignal;\n                in shutdownSignal = enginePort.shutdownSignal;\n                out torque = enginePort.torque;\n            }\n            \n            perform powertrainManagement.amplifyTorque {\n                in torque = transmissionPort.torque;\n                out amplifiedTorque = transmissionPort.amplifiedTorque;\n            }\n            \n            perform powertrainManagement.distributeTorque {\n                in torque = distributorPort.torque;\n            }\n        }\n        \n        interface driverToEngine connect driver.driverPort to powertrainSystem.enginePort {\n            ref flow references powertrainManagement.cmdFlow\n                from source.fuelCmd to target.fuelCmd,\n                from source.startSignal to target.startSignal,\n                from source.shutdownSignal to target.shutdownSignal;\n        }\n        \n        interface engineToTransmission connect powertrainSystem.enginePort.torque to powertrainSystem.transmissionPort.torque {\n            ref flow references powertrainManagement.torqueFlow1\n                from source to target;\n        }\n        \n        interface transmissionToDistributor connect powertrainSystem.transmissionPort.amplifiedTorque to powertrainSystem.distributorPort.torque {\n            ref flow references powertrainManagement.torqueFlow2\n                from source to target;\n        }\n    }\n    \n    action powertrainManagement {\n        action sendCommands {\n            out fuelCmd: FuelCmd;\n            out startSignal: StartSignal;\n            out shutdownSignal: ShutdownSignal;\n        }\n        \n        action generateTorque {\n            in fuelCmd: FuelCmd;\n            in startSignal: StartSignal;\n            in shutdownSignal: ShutdownSignal;\n            out torque: Torque;\n        }\n        \n        action amplifyTorque {\n            in torque: Torque;\n            out amplifiedTorque: Torque;\n        }\n        \n        action distributeTorque {\n            in torque: Torque;\n        }\n        \n        succession flow cmdFlow from sendCommands to generateTorque;\n        succession flow torqueFlow1 from generateTorque.torque to amplifyTorque.torque;\n        succession flow torqueFlow2 from amplifyTorque.amplifiedTorque to distributeTorque.torque;\n    }\n}",
    "package 'TrailerHitchingSystem' {\n    attribute def ConnectionState: ['Connected', 'Disconnected'];\n    attribute def HitchingCommand: ['Connect', 'Disconnect'];\n    \n    port def CommandPort {\n        out command: HitchingCommand;\n    }\n    port def StatePort {\n        out state: ConnectionState;\n    }\n    port def MechanicalPort;\n    port def ElectricalPort;\n    \n    part context {\n        part user {\n            port cmdPort: CommandPort;\n            perform hitchingAction.issueCommand {\n                out command = cmdPort.command;\n            }\n        }\n        part vehicle {\n            part frame;\n            part hitchBall {\n                port mechPort: MechanicalPort;\n            }\n            part electricalConnector {\n                port elecPort: ElectricalPort;\n            }\n            port cmdPort: ~CommandPort;\n            port statePort: StatePort;\n        }\n        part trailer {\n            part frame;\n            part coupler {\n                port mechPort: ~MechanicalPort;\n            }\n            part electricalConnector {\n                port elecPort: ~ElectricalPort;\n            }\n            port statePort: StatePort;\n        }\n        part hitchingMechanism {\n            port cmdPort: ~CommandPort;\n            port statePort: StatePort;\n            perform hitchingAction.changeState {\n                in command = cmdPort.command;\n                out state = statePort.state;\n            }\n        }\n        interface userToMechanism connect user.cmdPort to hitchingMechanism.cmdPort {\n            ref flow references hitchingAction.cmdFlow\n                from source.command to target.command;\n        }\n        interface mechToVehicleState connect hitchingMechanism.statePort to vehicle.statePort {\n            ref flow references hitchingAction.stateFlow\n                from source.state to target.state;\n        }\n        interface mechToTrailerState connect hitchingMechanism.statePort to trailer.statePort {\n            ref flow references hitchingAction.stateFlow\n                from source.state to target.state;\n        }\n        interface ballToCoupler connect vehicle.hitchBall.mechPort to trailer.coupler.mechPort;\n        interface elecConnection connect vehicle.electricalConnector.elecPort to trailer.electricalConnector.elecPort;\n    }\n    \n    action hitchingAction {\n        action issueCommand { out command: HitchingCommand; }\n        action changeState { in command; out state: ConnectionState; }\n        succession flow cmdFlow from issueCommand.command to changeState.command;\n        succession flow stateFlow from changeState.state;\n    }\n}",
    "package 'TrailerHitchSystem' {\n    attribute def ConnectionStatus;\n    port def HitchPort {\n        out command: ConnectionStatus;\n    }\n    part context {\n        part user {\n            port hitchPort: HitchPort;\n            perform trailerOperations.issueHitchCommand {\n                out command = hitchPort.command;\n            }\n        }\n        part vehicle {\n            part chassis {\n                part towBall {\n                    port hitchPort: ~HitchPort;\n                }\n            }\n        }\n        part trailer {\n            part trailerFrame {\n                part coupler {\n                    port hitchPort: ~HitchPort;\n                }\n            }\n        }\n        interface userToVehicle connect user.hitchPort to vehicle.chassis.towBall.hitchPort {\n            ref flow references trailerOperations.hitchFlow\n                from source.command to target.command;\n        }\n        connector vehicleToTrailer connect vehicle.chassis.towBall.hitchPort to trailer.trailerFrame.coupler.hitchPort {\n            ref flow references trailerOperations.connectionFlow\n                from source.command to target.command;\n        }\n    }\n    action trailerOperations {\n        action issueHitchCommand { out command: ConnectionStatus; }\n        action establishConnection { in command: ConnectionStatus; }\n        succession flow hitchFlow from issueHitchCommand.command to establishConnection.command;\n        succession flow connectionFlow from establishConnection.command to establishConnection.command;\n    }\n}",
    "package 'TrailerHitchSystem' {\n    attribute def HitchUnhitchCmd;\n    attribute def ConnectionState: ['Engaged', 'Disengaged'];\n    port def UserCmdPort {\n        out command: HitchUnhitchCmd;\n    }\n    port def HitchControlPort {\n        in command: HitchUnhitchCmd;\n    }\n    port def CouplerPort {\n        inout state: ConnectionState;\n    }\n    part context {\n        part user {\n            port cmdPort: UserCmdPort;\n            perform TrailerHitchOperation.sendCommand {\n                out command = cmdPort.command;\n            }\n        }\n        part vehicle {\n            part chassis {\n                port towBall: CouplerPort;\n            }\n            port cmdPort: ~HitchControlPort;\n            perform TrailerHitchOperation.processCommand {\n                in command = cmdPort.command;\n                out state = chassis.towBall.state;\n            }\n        }\n        part trailer {\n            part chassis {\n                port coupler: CouplerPort;\n            }\n            perform TrailerHitchOperation.engageDisengage {\n                in state = chassis.coupler.state;\n            }\n        }\n        interface userToVehicle connect user.cmdPort to vehicle.cmdPort {\n            ref flow cmdFlow from source.command to target.command;\n        }\n        interface hitchConnection connect vehicle.chassis.towBall to trailer.chassis.coupler {\n            ref flow stateFlow from source.state to target.state;\n        }\n    }\n    action TrailerHitchOperation {\n        action sendCommand { out command: HitchUnhitchCmd; }\n        succession flow cmdFlow from sendCommand.command to processCommand.command;\n        action processCommand { in command; out state: ConnectionState; }\n        succession flow stateFlow from processCommand.state to engageDisengage.state;\n        action engageDisengage { in state: ConnectionState; }\n    }\n}",
    "package 'FuelSystem' {\n    attribute def Fuel;\n    attribute def Temperature;\n    port def FuelSupplyPort {\n        out fuel: Fuel;\n    }\n    port def FuelReturnPort {\n        in fuel: Fuel;\n    }\n    part context {\n        part fuelTank {\n            port supplyPort: FuelSupplyPort;\n            port returnPort: FuelReturnPort;\n            perform fuelFlow.supplyFuel {\n                out fuel = supplyPort.fuel;\n            }\n            perform fuelFlow.returnFuel {\n                in fuel = returnPort.fuel;\n            }\n        }\n        part engine {\n            port supplyPort: ~FuelSupplyPort;\n            port returnPort: ~FuelReturnPort;\n            perform fuelFlow.consumeFuel {\n                in fuel = supplyPort.fuel;\n                out returnedFuel = returnPort.fuel;\n            }\n            perform fuelFlow.monitorParameters {\n                in fuel = supplyPort.fuel;\n            }\n        }\n        interface supplyLine connect fuelTank.supplyPort to engine.supplyPort {\n            ref flow references fuelFlow.supplyFlow\n                from source.fuel to target.fuel;\n        }\n        interface returnLine connect engine.returnPort to fuelTank.returnPort {\n            ref flow references fuelFlow.returnFlow\n                from source.fuel to target.fuel;\n        }\n    }\n    action fuelFlow {\n        action supplyFuel { out fuel: Fuel; }\n        succession flow supplyFlow from supplyFuel.fuel to consumeFuel.fuel;\n        action consumeFuel {\n            in fuel: Fuel;\n            out returnedFuel: Fuel;\n        }\n        succession flow returnFlow from consumeFuel.returnedFuel to returnFuel.fuel;\n        action returnFuel { in fuel: Fuel; }\n        action monitorParameters { in fuel: Fuel; }\n        flow monitorFlow from supplyFuel.fuel to monitorParameters.fuel;\n    }\n}",
    "package 'FuelDeliverySystem' {\n    attribute def Fuel;\n    port def FuelOutPort {\n        out fuel: Fuel;\n    }\n    port def FuelInPort {\n        in fuel: Fuel;\n    }\n    part context {\n        part storageTank {\n            port outPort: FuelOutPort;\n            perform fuelDelivery.provideFuel {\n                out fuel = outPort.fuel;\n            }\n        }\n        interface storageToPump connect storageTank.outPort to fuelPump.inPort {\n            ref flow references fuelDelivery.fuelFlow1\n                from source.fuel to target.fuel;\n        }\n        part fuelPump {\n            port inPort: FuelInPort;\n            port outPort: FuelOutPort;\n            perform fuelDelivery.transferFuel {\n                in fuel = inPort.fuel;\n                out fuel = outPort.fuel;\n            }\n        }\n        interface pumpToVehicle connect fuelPump.outPort to vehicleFuelTank.inPort {\n            ref flow references fuelDelivery.fuelFlow2\n                from source.fuel to target.fuel;\n        }\n        part vehicleFuelTank {\n            attribute capacity: Real;\n            attribute currentLevel: Real;\n            port inPort: FuelInPort;\n            perform fuelDelivery.receiveFuel {\n                in fuel = inPort.fuel;\n            }\n        }\n    }\n    action fuelDelivery {\n        action provideFuel { out fuel: Fuel; }\n        succession flow fuelFlow1 from provideFuel.fuel to transferFuel.fuel;\n        action transferFuel { in fuel: Fuel; out fuel: Fuel; }\n        succession flow fuelFlow2 from transferFuel.fuel to receiveFuel.fuel;\n        action receiveFuel { in fuel: Fuel; }\n    }\n}",
    "package 'AutomobileAssembly' {\n    part def BaseVehicle;\n    part def Gearbox;\n    part def Engine;\n    part def VehicleWithGearbox {\n        part base: BaseVehicle;\n        part gearbox: Gearbox;\n    }\n    part def FullyAssembledVehicle {\n        part base: BaseVehicle;\n        part gearbox: Gearbox;\n        part engine: Engine;\n    }\n    action assemblyProcess {\n        in baseVehicle: BaseVehicle;\n        in gearbox: Gearbox;\n        in engine: Engine;\n        out assembledVehicle: FullyAssembledVehicle;\n        action installGearbox {\n            in base: BaseVehicle;\n            in gbox: Gearbox;\n            out vehicleWithGearbox: VehicleWithGearbox;\n        }\n        action installEngine {\n            in vehicle: VehicleWithGearbox;\n            in eng: Engine;\n            out vehicleComplete: FullyAssembledVehicle;\n        }\n        flow from baseVehicle to installGearbox.base;\n        flow from gearbox to installGearbox.gbox;\n        flow from installGearbox.vehicleWithGearbox to installEngine.vehicle;\n        flow from engine to installEngine.eng;\n        flow from installEngine.vehicleComplete to assembledVehicle;\n        succession from installGearbox to installEngine;\n    }\n}",
    "package 'VehicleSystem' {\n    signal def StartSignal;\n    signal def VehicleOnSignal;\n    signal def ShutdownSignal;\n    signal def RestoreToNormalSignal;\n    signal def OverTemperatureSignal;\n    \n    port def ControllerOutputPort {\n        out startSignal: StartSignal;\n        out vehicleOnSignal: VehicleOnSignal;\n        out shutdownSignal: ShutdownSignal;\n        out restoreToNormalSignal: RestoreToNormalSignal;\n    }\n    \n    port def ControllerInputPort {\n        in startSignal: StartSignal;\n        in vehicleOnSignal: VehicleOnSignal;\n        in shutdownSignal: ShutdownSignal;\n        in restoreToNormalSignal: RestoreToNormalSignal;\n    }\n    \n    port def HealthOutputPort {\n        out overTemperatureSignal: OverTemperatureSignal;\n    }\n    \n    port def HealthInputPort {\n        in overTemperatureSignal: OverTemperatureSignal;\n    }\n    \n    block def VehicleController {\n        port outSignals: ControllerOutputPort;\n        port healthInput: HealthInputPort;\n    }\n    \n    block def VehicleA {\n        attribute brakePedalPressed: Boolean;\n        attribute temperature: Real;\n        attribute temperatureThreshold: Real = 100.0;\n        \n        port controllerInput: ~ControllerInputPort;\n        port healthOutput: HealthOutputPort;\n        \n        state machine def VehicleStateMachine {\n            state Off;\n            state Starting;\n            state Running {\n                entry / {\n                    action performSelfChecks;\n                    action supplyPower;\n                }\n                exit / {\n                    action applyParkingBrake;\n                }\n            }\n            state HealthManagement;\n            state Maintenance;\n            state Degraded;\n            \n            initial -> Off;\n            \n            transition from Off to Starting on controllerInput.startSignal\n                when brakePedalPressed;\n            \n            transition from Starting to Running on controllerInput.vehicleOnSignal;\n            \n            transition from Running to Off on controllerInput.shutdownSignal;\n            \n            transition from Running to Degraded\n                when temperature > temperatureThreshold\n                then healthOutput.overTemperatureSignal();\n            \n            transition from Degraded to Running on controllerInput.restoreToNormalSignal;\n        }\n    }\n    \n    part context {\n        part controller: VehicleController;\n        part vehicle: VehicleA;\n        \n        connection controllerToVehicle connect controller.outSignals to vehicle.controllerInput;\n        connection vehicleToController connect vehicle.healthOutput to controller.healthInput;\n    }\n}",
    "package 'VehicleSystem' {\n    attribute def BrakePedalStatus;\n    attribute def StartSignal;\n    attribute def Temperature;\n    attribute def WarningSignal;\n    attribute def VehicleStatus;\n    attribute def ControlCommand;\n    attribute def Fuel;\n    attribute def MaintenanceInterval;\n    attribute def TemperatureThreshold;\n    \n    port def VehicleSensorPort {\n        in brakePedal: BrakePedalStatus;\n        in temperature: Temperature;\n    }\n    port def ControllerToVehiclePort {\n        out startSignal: StartSignal;\n        out controlCommand: ControlCommand;\n    }\n    port def VehicleToControllerPort {\n        out warning: WarningSignal;\n        out status: VehicleStatus;\n    }\n    \n    part context {\n        part vehicle {\n            port sensorPort: ~VehicleSensorPort;\n            port controllerPort: ~ControllerToVehiclePort;\n            port toControllerPort: VehicleToControllerPort;\n            attribute fuel: Fuel;\n            attribute maintenanceInterval: MaintenanceInterval;\n            attribute temperatureThreshold: TemperatureThreshold;\n            \n            perform vehicleOperation.manageStartup {\n                in brakePedal = sensorPort.brakePedal;\n                in startSignal = controllerPort.startSignal;\n            }\n            perform vehicleOperation.monitorTemperature {\n                in temperature = sensorPort.temperature;\n                in threshold = temperatureThreshold;\n                out warning = toControllerPort.warning;\n                out status = toControllerPort.status;\n            }\n            perform vehicleOperation.healthManagement {\n                in maintenanceInterval = maintenanceInterval;\n            }\n        }\n        \n        part vehicleController {\n            port fromVehiclePort: ~VehicleToControllerPort;\n            port toVehiclePort: ControllerToVehiclePort;\n            \n            perform vehicleOperation.processControl {\n                in warning = fromVehiclePort.warning;\n                in status = fromVehiclePort.status;\n                out startSignal = toVehiclePort.startSignal;\n                out controlCommand = toVehiclePort.controlCommand;\n            }\n        }\n        \n        interface vehicleSensing connect vehicle.sensorPort to environment.sensorSource {\n            ref flow brakeFlow from source.brakePedal to target.brakePedal;\n            ref flow tempFlow from source.temperature to target.temperature;\n        }\n        interface controlConnect \n            connect vehicle.controllerPort to vehicleController.toVehiclePort \n            connect vehicleController.fromVehiclePort to vehicle.toControllerPort {\n            ref flow warningFlow from source.warning to target.warning;\n            ref flow statusFlow from source.status to target.status;\n            ref flow startFlow from source.startSignal to target.startSignal;\n            ref flow commandFlow from source.controlCommand to target.controlCommand;\n        }\n        \n        part environment {\n            part sensorSource {\n                port brakePedal: BrakePedalStatus;\n                port temperature: Temperature;\n            }\n        }\n    }\n    \n    action vehicleOperation {\n        action manageStartup {\n            in brakePedal: BrakePedalStatus;\n            in startSignal: StartSignal;\n            action selfInspection;\n            action powerSupply;\n            constraint startupCondition: brakePedal and startSignal;\n            succession from startupCondition to selfInspection;\n            succession from selfInspection to powerSupply;\n        }\n        \n        action monitorTemperature {\n            in temperature: Temperature;\n            in threshold: TemperatureThreshold;\n            out warning: WarningSignal;\n            out status: VehicleStatus;\n            action detectOverheat {\n                constraint overheat: temperature > threshold;\n            }\n            action sendWarning;\n            action setDegradedMode;\n            succession from detectOverheat to sendWarning;\n            succession from sendWarning to setDegradedMode;\n            bind setDegradedMode.status = status;\n            bind sendWarning.warning = warning;\n        }\n        \n        action healthManagement {\n            in maintenanceInterval: MaintenanceInterval;\n            action performMaintenance;\n            action recoverFaults;\n            constraint maintenanceTrigger: periodic(maintenanceInterval);\n            succession from maintenanceTrigger to performMaintenance;\n            succession from performMaintenance to recoverFaults;\n        }\n        \n        action processControl {\n            in warning: WarningSignal;\n            in status: VehicleStatus;\n            out startSignal: StartSignal;\n            out controlCommand: ControlCommand;\n            action handleWarning;\n            action executeShutdown;\n            action executeStart;\n            flow signalFlow from handleWarning to executeShutdown;\n            bind handleWarning.warning = warning;\n            bind executeShutdown.controlCommand = controlCommand;\n            bind executeStart.startSignal = startSignal;\n        }\n    }\n}",
    "package 'VehicleSimulation' {\n    attribute def State: string;\n    attribute def Mass: Real;\n    attribute def Position: Real;\n    attribute def Velocity: Real;\n    attribute def Acceleration: Real;\n    attribute def Slope: Real;\n    attribute def FrictionCoefficient: Real;\n    attribute def Time: Real;\n    \n    attribute def VehicleState {\n        state: State;\n        mass: Mass;\n        position: Position;\n        velocity: Velocity;\n        acceleration: Acceleration;\n    }\n    \n    attribute def RoadState {\n        slope: Slope;\n        frictionCoefficient: FrictionCoefficient;\n    }\n    \n    attribute def Snapshot {\n        time: Time;\n        vehicleState: VehicleState;\n        roadState: RoadState;\n    }\n    \n    port def SimulationControlPort {\n        in initialVehicle: VehicleState;\n        in initialRoad: RoadState;\n        in snapshotTimes: Time[];\n    }\n    \n    port def SimulationOutputPort {\n        out snapshots: Snapshot[];\n    }\n    \n    part context {\n        part user {\n            port simulationControlPort: ~SimulationControlPort;\n            port simulationOutputPort: ~SimulationOutputPort;\n            perform simulationControl.sendParameters {\n                out initialVehicle = simulationControlPort.initialVehicle;\n                out initialRoad = simulationControlPort.initialRoad;\n                out snapshotTimes = simulationControlPort.snapshotTimes;\n            }\n            perform simulationOutput.receiveSnapshots {\n                in snapshots = simulationOutputPort.snapshots;\n            }\n        }\n        \n        part simulation {\n            port simulationControlPort: SimulationControlPort;\n            port simulationOutputPort: SimulationOutputPort;\n            perform runSimulation {\n                in initialVehicle = simulationControlPort.initialVehicle;\n                in initialRoad = simulationControlPort.initialRoad;\n                in snapshotTimes = simulationControlPort.snapshotTimes;\n                out snapshots = simulationOutputPort.snapshots;\n            }\n        }\n        \n        interface userToSimulationControl connect user.simulationControlPort to simulation.simulationControlPort {\n            ref flow references simulationControl.parametersFlow \n                from source.initialVehicle to target.initialVehicle,\n                from source.initialRoad to target.initialRoad,\n                from source.snapshotTimes to target.snapshotTimes;\n        }\n        \n        interface simulationToUserOutput connect simulation.simulationOutputPort to user.simulationOutputPort {\n            ref flow references simulationOutput.snapshotsFlow \n                from source.snapshots to target.snapshots;\n        }\n    }\n    \n    action simulationControl {\n        action sendParameters {\n            out initialVehicle: VehicleState;\n            out initialRoad: RoadState;\n            out snapshotTimes: Time[];\n        }\n    }\n    \n    action runSimulation {\n        in initialVehicle: VehicleState;\n        in initialRoad: RoadState;\n        in snapshotTimes: Time[];\n        out snapshots: Snapshot[];\n        action computeSnapshots {\n            in initialVehicle;\n            in initialRoad;\n            in snapshotTimes;\n            out snapshots;\n        }\n        succession flow from computeSnapshots.initialVehicle to computeSnapshots.snapshots;\n        succession flow from computeSnapshots.initialRoad to computeSnapshots.snapshots;\n        succession flow from computeSnapshots.snapshotTimes to computeSnapshots.snapshots;\n    }\n    \n    action simulationOutput {\n        action receiveSnapshots {\n            in snapshots: Snapshot[];\n        }\n    }\n}",
    "package 'AutomotiveConfiguration' {\n    enum SubsystemAConfig { ConfigA1, ConfigA2 }\n    enum SubsystemBConfig { ConfigB1, ConfigB2 }\n    \n    part def Component1;\n    part def Component2;\n    part def Component3;\n    part def Component4;\n    part def Component5;\n    part def Component6;\n    \n    part def SubsystemA {\n        attribute selectedConfig: SubsystemAConfig;\n        part comp1: Component1 [0..1];\n        part comp2: Component2;\n        part comp3: Component3 [0..1];\n        constraint {\n            if selectedConfig == SubsystemAConfig.ConfigA1 then {\n                comp1 != null;\n                comp3 == null;\n            } else if selectedConfig == SubsystemAConfig.ConfigA2 then {\n                comp1 == null;\n                comp3 != null;\n            }\n        }\n    }\n    \n    part def SubsystemB {\n        attribute selectedConfig: SubsystemBConfig;\n        part comp4: Component4 [0..1];\n        part comp5: Component5;\n        part comp6: Component6 [0..1];\n        constraint {\n            if selectedConfig == SubsystemBConfig.ConfigB1 then {\n                comp4 != null;\n                comp6 == null;\n            } else if selectedConfig == SubsystemBConfig.ConfigB2 then {\n                comp4 == null;\n                comp6 != null;\n            }\n        }\n    }\n    \n    part def Automobile {\n        part subsystemA: SubsystemA;\n        part subsystemB: SubsystemB;\n        constraint configConstraint {\n            (subsystemA.selectedConfig == SubsystemAConfig.ConfigA2) implies \n                (subsystemB.selectedConfig == SubsystemBConfig.ConfigB1);\n        }\n    }\n    \n    configuration ConfigurationA for Automobile {\n        subsystemA.selectedConfig = SubsystemAConfig.ConfigA1;\n        subsystemB.selectedConfig = SubsystemBConfig.ConfigB1;\n    }\n    \n    configuration ConfigurationB for Automobile {\n        subsystemA.selectedConfig = SubsystemAConfig.ConfigA2;\n        subsystemB.selectedConfig = SubsystemBConfig.ConfigB1;\n    }\n}",
    "package 'ModularVehiclePlatform' {\n    port def p1;\n    port def p2;\n    port def SubsystemPort;\n    \n    part def part1;\n    part def part2;\n    part def part3 {\n        port p1Port: p1;\n    }\n    part def part4;\n    part def part5 {\n        port p2Port: p2;\n        variability behaviorVariability;\n        variant behaviorVariant1 for behaviorVariability;\n        variant behaviorVariant2 for behaviorVariability;\n    }\n    part def part6;\n    \n    abstract part def SubsystemA {\n        variability componentVariability;\n        port subPort: SubsystemPort;\n    }\n    \n    abstract part def SubsystemB {\n        variability componentVariability;\n        port subPort: SubsystemPort;\n    }\n    \n    part def VehicleConfig {\n        part subsystemA: SubsystemA;\n        part subsystemB: SubsystemB;\n        interface subsystemConnection connect subsystemA.subPort to subsystemB.subPort;\n    }\n    \n    part VehicleConfigA: VehicleConfig;\n    part VehicleConfigB: VehicleConfig;\n    \n    requirement def 'SystemConstraints' {\n        id = 'SYS_CONST_001';\n        text = 'Ensure configuration consistency and rationality';\n    }\n    \n    part context {\n        part configurator {\n            perform configureVehicle {\n                in selectedConfig: VehicleConfig;\n            }\n        }\n        part componentPool {\n            part part1: part1;\n            part part2: part2;\n            part part3: part3;\n            part part4: part4;\n            part part5: part5;\n            part part6: part6;\n        }\n        part configA: VehicleConfigA;\n        part configB: VehicleConfigB;\n    }\n    \n    action configureVehicle {\n        in selectedConfig: VehicleConfig;\n        constraint 'ApplyConstraints' {\n            satisfy 'SystemConstraints';\n        }\n    }\n}",
    "package 'VehicleProductLine' {\n    attribute def EngineType {\n        value: String;\n    }\n    attribute def TransmissionType {\n        value: String;\n    }\n    attribute def WheelType {\n        value: String;\n    }\n    attribute def PerformanceRequirement {\n        value: String;\n    }\n    attribute def UserPreferences;\n    part def Configuration {\n        part engine: EngineType;\n        part transmission: TransmissionType;\n        part wheel: WheelType;\n    }\n    port def RequirementPort {\n        attribute perfReq: PerformanceRequirement;\n        attribute userPrefs: UserPreferences;\n    }\n    port def ConfigurationPort {\n        attribute config: Configuration;\n    }\n    part context {\n        part user {\n            port requirementPort: RequirementPort;\n            perform configureVehicle.provideRequirements {\n                out perfReq = requirementPort.perfReq;\n                out userPrefs = requirementPort.userPrefs;\n            }\n        }\n        part configurator {\n            port requirementPort: ~RequirementPort;\n            port configurationPort: ConfigurationPort;\n            perform configureVehicle.determineConfiguration {\n                in perfReq = requirementPort.perfReq;\n                in userPrefs = requirementPort.userPrefs;\n                out config = configurationPort.config;\n            }\n        }\n        part vehicleFactory {\n            port configurationPort: ~ConfigurationPort;\n            perform configureVehicle.buildVehicle {\n                in config = configurationPort.config;\n            }\n        }\n        interface userToConfigurator connect user.requirementPort to configurator.requirementPort {\n            ref flow references configureVehicle.reqFlow\n                from source.perfReq to target.perfReq,\n                from source.userPrefs to target.userPrefs;\n        }\n        interface configuratorToFactory connect configurator.configurationPort to vehicleFactory.configurationPort {\n            ref flow references configureVehicle.configFlow\n                from source.config to target.config;\n        }\n    }\n    action configureVehicle {\n        action provideRequirements {\n            out perfReq: PerformanceRequirement;\n            out userPrefs: UserPreferences;\n        }\n        action determineConfiguration {\n            in perfReq: PerformanceRequirement;\n            in userPrefs: UserPreferences;\n            out config: Configuration;\n            constraint highPerfConstraint {\n                (perfReq.value == \"High\") implies (\n                    config.engine.value == \"6-cylinder\" and\n                    config.transmission.value == \"automatic\" and\n                    config.wheel.value == \"wide-rim\"\n                )\n            }\n            constraint standardPerfConstraint {\n                (perfReq.value == \"Standard\") implies (\n                    config.engine.value == \"4-cylinder\" and\n                    config.transmission.value == \"manual\" and\n                    config.wheel.value == \"narrow-rim\"\n                )\n            }\n        }\n        action buildVehicle {\n            in config: Configuration;\n        }\n        succession flow reqFlow from provideRequirements.perfReq to determineConfiguration.perfReq;\n        succession flow reqPrefFlow from provideRequirements.userPrefs to determineConfiguration.userPrefs;\n        succession flow configFlow from determineConfiguration.config to buildVehicle.config;\n    }\n}",
    "package 'AutomotiveSystem' {\n    attribute def Mass;\n    attribute def FuelStatus;\n    attribute def Torque;\n    attribute def ReliabilityMetric;\n    \n    requirement def MassRequirement {\n        requirement id 'R1';\n        text 'Vehicle shall comply with maximum mass limitations';\n    }\n    \n    requirement def FuelStatusRequirement {\n        requirement id 'R2';\n        text 'Vehicle mass shall meet specifications under defined fuel conditions';\n    }\n    \n    requirement def PowertrainRequirement {\n        requirement id 'R3';\n        text 'Engine shall output torque to transmission via drive interface';\n    }\n    \n    requirement def ReliabilityRequirement {\n        requirement id 'R4';\n        text 'Vehicle shall meet specified reliability metrics throughout lifecycle';\n    }\n    \n    port def DriveInterface {\n        in torque: Torque;\n    }\n    \n    part def Vehicle {\n        attribute mass: Mass;\n        attribute maxMass: Mass;\n        attribute fuelStatus: FuelStatus;\n        attribute reliability: ReliabilityMetric;\n        \n        satisfy massReq: MassRequirement;\n        satisfy fuelReq: FuelStatusRequirement;\n        satisfy reliabilityReq: ReliabilityRequirement;\n    }\n    \n    part def Engine {\n        attribute outputTorque: Torque;\n        port drivePort: DriveInterface {\n            out torque = outputTorque;\n        }\n    }\n    \n    part def Transmission {\n        port drivePort: ~DriveInterface;\n    }\n    \n    part context {\n        part vehicle: Vehicle;\n        part engine: Engine;\n        part transmission: Transmission;\n        \n        satisfy powertrainReq: PowertrainRequirement by powertrainConnection;\n        \n        interface powertrainConnection connect engine.drivePort to transmission.drivePort {\n            ref flow torqueFlow from source.torque to target.torque;\n        }\n    }\n    \n    action ManageSpecifications {\n        action defineMass {\n            out mass: Mass;\n            out maxMass: Mass;\n        }\n        action defineFuelStatus {\n            out fuelStatus: FuelStatus;\n        }\n        action defineReliability {\n            out reliability: ReliabilityMetric;\n        }\n        action deliverPower {\n            action produceTorque {\n                out torque: Torque;\n            }\n            action transferTorque {\n                in torque: Torque;\n            }\n            succession flow powerFlow from produceTorque.torque to transferTorque.torque;\n        }\n        action validateRequirements {\n            in mass: Mass;\n            in maxMass: Mass;\n            in fuelStatus: FuelStatus;\n            in reliability: ReliabilityMetric;\n        }\n        succession specFlow from defineMass to defineFuelStatus to defineReliability;\n        succession reqFlow from specFlow to validateRequirements;\n    }\n}",
    "package 'VehicleMassComplianceSystem' {\n    attribute def Mass;\n    attribute def MaxPermissibleMass;\n    attribute def ComplianceStatus;\n    port def MeasurementPort {\n        out mass: Mass;\n    }\n    port def LimitPort {\n        out maxMass: MaxPermissibleMass;\n    }\n    port def ResultPort {\n        out status: ComplianceStatus;\n    }\n    port def TriggerPort {\n        out command;\n    }\n    part context {\n        part vehicle {\n            port measurementPort: ~MeasurementPort;\n        }\n        part weighingEquipment {\n            port triggerPort: ~TriggerPort;\n            port measurementPort: MeasurementPort;\n            perform verifyCompliance.measureMass {\n                in command = triggerPort.command;\n                out mass = measurementPort.mass;\n            }\n        }\n        part testOperator {\n            port triggerPort: TriggerPort;\n            perform verifyCompliance.initiateTest {\n                out command = triggerPort.command;\n            }\n        }\n        part complianceChecker {\n            port measurementPort: ~MeasurementPort;\n            port limitPort: ~LimitPort;\n            port resultPort: ResultPort;\n            perform verifyCompliance.checkCompliance {\n                in mass = measurementPort.mass;\n                in maxMass = limitPort.maxMass;\n                out status = resultPort.status;\n            }\n        }\n        part limitSource {\n            port limitPort: LimitPort;\n            perform verifyCompliance.provideLimit {\n                out maxMass = limitPort.maxMass;\n            }\n        }\n        interface operatorToEquipment connect testOperator.triggerPort to weighingEquipment.triggerPort {\n            ref flow references verifyCompliance.triggerFlow\n                from source.command to target.command;\n        }\n        interface equipmentToChecker connect weighingEquipment.measurementPort to complianceChecker.measurementPort {\n            ref flow references verifyCompliance.massFlow\n                from source.mass to target.mass;\n        }\n        interface sourceToChecker connect limitSource.limitPort to complianceChecker.limitPort {\n            ref flow references verifyCompliance.limitFlow\n                from source.maxMass to target.maxMass;\n        }\n    }\n    action verifyCompliance {\n        action initiateTest { out command; }\n        succession flow triggerFlow from initiateTest.command to measureMass.command;\n        action measureMass { in command; out mass: Mass; }\n        succession flow massFlow from measureMass.mass to checkCompliance.mass;\n        action provideLimit { out maxMass: MaxPermissibleMass; }\n        succession flow limitFlow from provideLimit.maxMass to checkCompliance.maxMass;\n        action checkCompliance { in mass: Mass; in maxMass: MaxPermissibleMass; out status: ComplianceStatus; }\n    }\n}",
    "package 'WaterSupplyNetwork' {\n    attribute def HotWater;\n    attribute def ColdWater;\n    \n    port def HotWaterOutPort {\n        out water: HotWater;\n    }\n    port def ColdWaterOutPort {\n        out water: ColdWater;\n    }\n    port def HotWaterInPort {\n        in water: HotWater;\n    }\n    port def ColdWaterInPort {\n        in water: ColdWater;\n    }\n    \n    part def SpigotBank {\n        port hotSpigot: HotWaterOutPort;\n        port coldSpigot: ColdWaterOutPort;\n    }\n    \n    part def Faucet {\n        port hotInlet: HotWaterInPort;\n        port coldInlet: ColdWaterInPort;\n    }\n    \n    part context {\n        part spigotBank: SpigotBank;\n        part faucets: Faucet[1..*];\n        \n        interface hotWaterConnection connect spigotBank.hotSpigot to faucets.hotInlet {\n            ref flow references deliverWater.hotFlow \n                from source.water to target.water;\n        }\n        \n        interface coldWaterConnection connect spigotBank.coldSpigot to faucets.coldInlet {\n            ref flow references deliverWater.coldFlow \n                from source.water to target.water;\n        }\n        \n        perform deliverWater.supplyHot at spigotBank {\n            out hot = hotSpigot.water;\n        }\n        perform deliverWater.supplyCold at spigotBank {\n            out cold = coldSpigot.water;\n        }\n        perform deliverWater.receiveHot at faucets {\n            in hot = hotInlet.water;\n        }\n        perform deliverWater.receiveCold at faucets {\n            in cold = coldInlet.water;\n        }\n    }\n    \n    action deliverWater {\n        action supplyHot { out hot: HotWater; }\n        action receiveHot { in hot: HotWater; }\n        succession flow hotFlow from supplyHot.hot to receiveHot.hot;\n        \n        action supplyCold { out cold: ColdWater; }\n        action receiveCold { in cold: ColdWater; }\n        succession flow coldFlow from supplyCold.cold to receiveCold.cold;\n    }\n}",
    "package 'Vehicle Quality System' {\n    attribute def Mass;\n    attribute def QualityData;\n    attribute def AnalysisRequirement;\n    attribute def AnalysisUseCase;\n    attribute def AnalysisTask;\n    attribute def AnalysisPlan;\n    attribute def EvaluationResult;\n    \n    part def Vehicle {\n        attribute totalMass: Mass;\n        part engine: Engine;\n        part transmission: Transmission;\n        part frontAxle: FrontAxleAssembly;\n        part rearAxle: RearAxleAssembly;\n    }\n    \n    part def Engine { attribute mass: Mass; attribute qualityData: QualityData; }\n    part def Transmission { attribute mass: Mass; attribute qualityData: QualityData; }\n    part def FrontAxleAssembly { attribute mass: Mass; attribute qualityData: QualityData; }\n    part def RearAxleAssembly { attribute mass: Mass; attribute qualityData: QualityData; }\n    \n    port def QualityDataPort {\n        in qualityData: QualityData;\n    }\n    \n    port def AnalysisReqPort {\n        in analysisReq: AnalysisRequirement;\n    }\n    \n    part context {\n        part user {\n            port qualityDataPort: QualityDataPort;\n            port analysisReqPort: AnalysisReqPort;\n            perform vehicleQualityMgmt.inputComponentData {\n                out qualityData = qualityDataPort.qualityData;\n            }\n            perform vehicleQualityMgmt.defineAnalysisReq {\n                out analysisReq = analysisReqPort.analysisReq;\n            }\n        }\n        \n        part qualitySystem {\n            port qualityDataPort: ~QualityDataPort;\n            port analysisReqPort: ~AnalysisReqPort;\n            perform vehicleQualityMgmt.calculateTotalMass;\n            perform vehicleQualityMgmt.formulateUseCase {\n                in analysisReq = analysisReqPort.analysisReq;\n            }\n            perform vehicleQualityMgmt.generateAnalysisPlan;\n            perform vehicleQualityMgmt.performEvaluation;\n            perform vehicleQualityMgmt.trackRequirements;\n        }\n        \n        part vehicle: Vehicle;\n        \n        interface userToSystem connect user.qualityDataPort to qualitySystem.qualityDataPort {\n            ref flow references vehicleQualityMgmt.dataFlow\n                from source.qualityData to target.qualityData;\n        }\n        \n        interface userToSystemReq connect user.analysisReqPort to qualitySystem.analysisReqPort {\n            ref flow references vehicleQualityMgmt.reqFlow\n                from source.analysisReq to target.analysisReq;\n        }\n    }\n    \n    action vehicleQualityMgmt {\n        action inputComponentData { out qualityData: QualityData; }\n        action calculateTotalMass { out totalMass: Mass; }\n        action defineAnalysisReq { out analysisReq: AnalysisRequirement; }\n        action formulateUseCase { in analysisReq; out useCase: AnalysisUseCase; }\n        action generateAnalysisTask { in useCase; out task: AnalysisTask; }\n        action generateAnalysisPlan { in task; out plan: AnalysisPlan; }\n        action performEvaluation { in plan; out result: EvaluationResult; }\n        action trackRequirements { in result; }\n        \n        succession flow dataFlow from inputComponentData.qualityData to calculateTotalMass;\n        succession flow reqFlow from defineAnalysisReq.analysisReq to formulateUseCase.analysisReq;\n        succession from formulateUseCase.useCase to generateAnalysisTask.useCase;\n        succession from generateAnalysisTask.task to generateAnalysisPlan.task;\n        succession from generateAnalysisPlan.plan to performEvaluation.plan;\n        succession from performEvaluation.result to trackRequirements.result;\n    }\n}",
    "package 'Powertrain Configuration System' {\n    attribute def Power: Real;\n    attribute def Mass: Real;\n    attribute def Efficiency: Real;\n    attribute def Reliability: Real;\n    attribute def Cost: Real;\n    \n    part def Engine {\n        attribute id: String;\n        attribute power: Power;\n        attribute mass: Mass;\n        attribute efficiency: Efficiency;\n        attribute reliability: Reliability;\n        attribute cost: Cost;\n    }\n    \n    part def Cylinder;\n    part def Piston;\n    part def ConnectingRod;\n    part def Crankshaft;\n    \n    part def EngineAssembly {\n        part cylinders: Cylinder[4..*];\n        part pistons: Piston[4..*];\n        part connectingRods: ConnectingRod[4..*];\n        part crankshaft: Crankshaft;\n    }\n    \n    action TradeOffAnalysis {\n        in engineCandidates: Engine[*];\n        out optimalEngine: Engine;\n        out explanation: String;\n        \n        action EvaluateEngine {\n            in engine: Engine;\n            out score: Real;\n        }\n        \n        action CompareScores {\n            in engines: Engine[*];\n            in scores: Real[*];\n            out bestEngine: Engine;\n            out rationale: String;\n        }\n        \n        succession flow evaluationFlow from EvaluateEngine to CompareScores;\n        succession flow engineInput from engineCandidates to EvaluateEngine.engine;\n        succession flow resultOutput from CompareScores.bestEngine to optimalEngine;\n        succession flow explanationOutput from CompareScores.rationale to explanation;\n    }\n    \n    part def ConfigurationSystem {\n        port def UserInterface {\n            in engineOptions: Engine[*];\n            out recommendedEngine: Engine;\n            out selectionRationale: String;\n        }\n        port ui: UserInterface;\n        \n        perform TradeOffAnalysis {\n            in engineCandidates = ui.engineOptions;\n            out optimalEngine = ui.recommendedEngine;\n            out explanation = ui.selectionRationale;\n        }\n    }\n}",
    "package 'Vehicle Fuel Economy System' {\n    attribute def FuelEconomy: Real (unit: 'mile per US gallon');\n    attribute def Load: Real (unit: 'pound');\n    attribute def Distance: Real (unit: 'mile');\n    attribute def Volume: Real (unit: 'cubic inch');\n    \n    enum DrivingCondition {\n        urban;\n        highway;\n    }\n    \n    attribute def UrbanMin: FuelEconomy = 25;\n    attribute def HighwayMin: FuelEconomy = 30;\n    attribute def TestLoad: Load = 1000;\n    \n    requirement 'Urban Fuel Economy Requirement' {\n        id = 'REQ1';\n        text = 'Under urban driving conditions, the vehicles range per gallon must not be less than 25 miles.';\n        constraint: FuelEconomy >= UrbanMin;\n    }\n    \n    requirement 'Highway Fuel Economy Requirement' {\n        id = 'REQ2';\n        text = 'Under highway conditions, the vehicles range per gallon must not be less than 30 miles.';\n        constraint: FuelEconomy >= HighwayMin;\n    }\n    \n    part context {\n        part vehicle {\n            part powertrain;\n            attribute curbWeight: Load;\n        }\n        \n        part testScenario {\n            attribute condition: DrivingCondition;\n            attribute additionalLoad: Load = TestLoad;\n        }\n        \n        part regulatoryRequirement {\n            ref requirement urbanReq: 'Urban Fuel Economy Requirement';\n            ref requirement highwayReq: 'Highway Fuel Economy Requirement';\n        }\n        \n        action overallComplianceAssessment {\n            action test: conductFuelEconomyTest {\n                in vehicle = .vehicle;\n                in scenario = .testScenario;\n            }\n            action verify: verifyFuelEconomyRequirement {\n                in condition = .testScenario.condition;\n                in measuredEconomy = test.measuredEconomy;\n            }\n            succession from test to verify;\n        }\n    }\n    \n    action conductFuelEconomyTest {\n        in vehicle: vehicle;\n        in scenario: testScenario;\n        out measuredEconomy: FuelEconomy;\n    }\n    \n    action verifyFuelEconomyRequirement {\n        in condition: DrivingCondition;\n        in measuredEconomy: FuelEconomy;\n        out isCompliant: Boolean;\n        constraint {\n            if condition == DrivingCondition::urban then\n                isCompliant = (measuredEconomy >= UrbanMin)\n            else if condition == DrivingCondition::highway then\n                isCompliant = (measuredEconomy >= HighwayMin)\n            else\n                isCompliant = false\n        }\n    }\n}",
    "package 'Vehicle Dynamics Simulation' {\n    attribute def Mass;\n    attribute def Position;\n    attribute def Velocity;\n    attribute def Acceleration;\n    attribute def Power;\n    attribute def TimeStep;\n    \n    port def SimulationInput {\n        in mass: Mass;\n        in initialPosition: Position;\n        in initialVelocity: Velocity;\n        in powerData: Power[*];\n        in timeStep: TimeStep;\n    }\n    \n    port def SimulationOutput {\n        out accelerationSeq: Acceleration[*];\n        out velocitySeq: Velocity[*];\n        out displacementSeq: Position[*];\n    }\n    \n    part context {\n        part user {\n            port simulationInputPort: ~SimulationInput;\n            port simulationOutputPort: ~SimulationOutput;\n            perform simulateDynamics.provideInput {\n                out mass = simulationInputPort.mass;\n                out initialPosition = simulationInputPort.initialPosition;\n                out initialVelocity = simulationInputPort.initialVelocity;\n                out powerData = simulationInputPort.powerData;\n                out timeStep = simulationInputPort.timeStep;\n            }\n        }\n        \n        part simulationSystem {\n            port input: SimulationInput;\n            port output: SimulationOutput;\n            perform simulateDynamics.runSimulation {\n                in mass = input.mass;\n                in initialPosition = input.initialPosition;\n                in initialVelocity = input.initialVelocity;\n                in powerData = input.powerData;\n                in timeStep = input.timeStep;\n                out accelerationSeq = output.accelerationSeq;\n                out velocitySeq = output.velocitySeq;\n                out displacementSeq = output.displacementSeq;\n            }\n        }\n        \n        interface inputConnection connect user.simulationInputPort to simulationSystem.input {\n            ref flow references simulateDynamics.massFlow \n                from source.mass to target.mass;\n            ref flow references simulateDynamics.posFlow \n                from source.initialPosition to target.initialPosition;\n            ref flow references simulateDynamics.velFlow \n                from source.initialVelocity to target.initialVelocity;\n            ref flow references simulateDynamics.powerFlow \n                from source.powerData to target.powerData;\n            ref flow references simulateDynamics.timeStepFlow \n                from source.timeStep to target.timeStep;\n        }\n        \n        interface outputConnection connect simulationSystem.output to user.simulationOutputPort {\n            ref flow references simulateDynamics.accFlow \n                from source.accelerationSeq to target.accelerationSeq;\n            ref flow references simulateDynamics.velSeqFlow \n                from source.velocitySeq to target.velocitySeq;\n            ref flow references simulateDynamics.dispFlow \n                from source.displacementSeq to target.displacementSeq;\n        }\n    }\n    \n    action simulateDynamics {\n        action provideInput {\n            out mass: Mass;\n            out initialPosition: Position;\n            out initialVelocity: Velocity;\n            out powerData: Power[*];\n            out timeStep: TimeStep;\n        }\n        \n        action runSimulation {\n            in mass: Mass;\n            in initialPosition: Position;\n            in initialVelocity: Velocity;\n            in powerData: Power[*];\n            in timeStep: TimeStep;\n            out accelerationSeq: Acceleration[*];\n            out velocitySeq: Velocity[*];\n            out displacementSeq: Position[*];\n        }\n        \n        action sendOutput {\n            in accelerationSeq: Acceleration[*];\n            in velocitySeq: Velocity[*];\n            in displacementSeq: Position[*];\n        }\n        \n        succession flow massFlow from provideInput.mass to runSimulation.mass;\n        succession flow posFlow from provideInput.initialPosition to runSimulation.initialPosition;\n        succession flow velFlow from provideInput.initialVelocity to runSimulation.initialVelocity;\n        succession flow powerFlow from provideInput.powerData to runSimulation.powerData;\n        succession flow timeStepFlow from provideInput.timeStep to runSimulation.timeStep;\n        succession flow accFlow from runSimulation.accelerationSeq to sendOutput.accelerationSeq;\n        succession flow velSeqFlow from runSimulation.velocitySeq to sendOutput.velocitySeq;\n        succession flow dispFlow from runSimulation.displacementSeq to sendOutput.displacementSeq;\n    }\n}",
    "package 'VehicleSystem' {\n    attribute def Mass {\n        value: Real;\n    }\n    attribute def SteeringAngle {\n        value: Real;\n    }\n    part def Car {\n        attribute totalMass: Mass = 2500;\n        part frontAxleAssembly: FrontAxleAssembly;\n        part rearAxleAssembly: RearAxleAssembly;\n    }\n    part def FrontAxleAssembly {\n        attribute mass: Mass = 150;\n        part leftFrontWheel: Wheel;\n        part rightFrontWheel: Wheel;\n        part frontAxle: FrontAxle;\n    }\n    part def FrontAxle {\n        attribute mass: Mass;\n        attribute steeringAngle: SteeringAngle;\n    }\n    part def RearAxleAssembly {\n        attribute mass: Mass = 250;\n        part leftRearWheel: Wheel;\n        part rightRearWheel: Wheel;\n        part rearAxle: RearAxle;\n    }\n    part def RearAxle {\n        attribute mass: Mass;\n    }\n    part def Wheel {}\n}",
    "package 'VehicleSafetySecurity' {\n    enum Category { SAFETY; SECURITY }\n    enum RequirementType { MANDATORY; OPTIONAL }\n    attribute def DisplayCommand;\n    attribute def Visualization;\n    attribute def OrganizedData;\n    \n    port def DisplayCommandPort {\n        in displayCommand: DisplayCommand;\n    }\n    port def VisualizationPort {\n        out visualization: Visualization;\n    }\n    \n    block VehicleComponent {\n        attribute category: Category;\n        attribute requirement: RequirementType;\n    }\n    \n    block Vehicle {\n        part safetyFeatures: VehicleComponent[0..*];\n        part securityFeatures: VehicleComponent[0..*];\n    }\n    \n    block SafetySecurityManagementSystem {\n        reference managedVehicle: Vehicle;\n        port displayCommandPort: ~DisplayCommandPort;\n        port visualizationPort: VisualizationPort;\n        \n        action ManageAndDisplay {\n            in displayCommand: DisplayCommand;\n            in vehicle: Vehicle;\n            out visualization: Visualization;\n            \n            action retrieveComponents {\n                in vehicle: Vehicle;\n                out safetyComps: VehicleComponent[*];\n                out securityComps: VehicleComponent[*];\n            }\n            action filterOrganize {\n                in safetyComps: VehicleComponent[*];\n                in securityComps: VehicleComponent[*];\n                out organizedData: OrganizedData;\n            }\n            action visualize {\n                in organizedData: OrganizedData;\n                out visualization: Visualization;\n            }\n            succession flow from retrieveComponents.(safetyComps, securityComps) \n                to filterOrganize.(safetyComps, securityComps);\n            succession flow from filterOrganize.organizedData \n                to visualize.organizedData;\n        }\n        perform ManageAndDisplay {\n            in displayCommand = displayCommandPort.displayCommand;\n            in vehicle = managedVehicle;\n            out visualization = visualizationPort.visualization;\n        }\n    }\n    \n    part context {\n        part user {\n            port displayCommandPort: DisplayCommandPort;\n            port visualizationPort: ~VisualizationPort;\n        }\n        part system: SafetySecurityManagementSystem {\n            port displayCommandPort: ~DisplayCommandPort;\n            port visualizationPort: VisualizationPort;\n            reference managedVehicle: Vehicle;\n        }\n        part vehicle: Vehicle;\n        binding system.managedVehicle to vehicle;\n        interface cmdConnect \n            connect user.displayCommandPort to system.displayCommandPort;\n        interface visConnect \n            connect system.visualizationPort to user.visualizationPort;\n    }\n}",
    "package 'LayeredSystem' {\n    attribute def x;\n    attribute def y;\n    attribute def z;\n    constraint def ZConstraint {\n        subject x, y, z;\n        constraint z = f(x,y);\n    }\n    port def ServiceInterface;\n    port def DataInterface;\n    part context {\n        attribute x;\n        attribute y;\n        attribute z;\n        constraint zConstraint: ZConstraint;\n        part application {\n            port serviceReq: ~ServiceInterface;\n            perform systemOperation.initiateRequest {\n                out request = serviceReq;\n            }\n            perform systemOperation.processResponse {\n                in response = serviceReq;\n            }\n        }\n        part service {\n            port serviceProv: ServiceInterface;\n            port dataReq: ~DataInterface;\n            perform systemOperation.handleServiceRequest {\n                in request = serviceProv;\n                out dataRequest = dataReq;\n            }\n            perform systemOperation.provideServiceResponse {\n                in dataResponse = dataReq;\n                out response = serviceProv;\n            }\n        }\n        part data {\n            port dataProv: DataInterface;\n            perform systemOperation.accessData {\n                in dataRequest = dataProv;\n                out dataResponse = dataProv;\n            }\n        }\n        interface appToService connect application.serviceReq to service.serviceProv;\n        interface serviceToData connect service.dataReq to data.dataProv;\n    }\n    action systemOperation {\n        action initiateRequest { out request; }\n        action handleServiceRequest { in request; out dataRequest; }\n        action accessData { in dataRequest; out dataResponse; }\n        action provideServiceResponse { in dataResponse; out response; }\n        action processResponse { in response; }\n        succession flow requestFlow from initiateRequest.request to handleServiceRequest.request;\n        succession flow dataRequestFlow from handleServiceRequest.dataRequest to accessData.dataRequest;\n        succession flow dataResponseFlow from accessData.dataResponse to provideServiceResponse.dataResponse;\n        succession flow responseFlow from provideServiceResponse.response to processResponse.response;\n    }\n}",
    "package 'Powertrain' {\n    attribute def Torque {\n        constraint positive: value > 0 Nm;\n    }\n    port def TorqueOutPort {\n        out torque: Torque;\n    }\n    port def TorqueInPort {\n        in torque: Torque;\n    }\n    part context {\n        part logicLayer {\n            part torqueGenerator {\n                port torqueOut: TorqueOutPort;\n                perform torqueGeneration.generate {\n                    out torque = torqueOut.torque;\n                }\n            }\n        }\n        part physicalLayer {\n            part engine {\n                port torqueOut: TorqueOutPort;\n            }\n            part transmission {\n                port torqueIn: TorqueInPort;\n                perform torqueGeneration.transmit {\n                    in torque = torqueIn.torque;\n                }\n            }\n        }\n        allocation allocateGenerator: logicLayer.torqueGenerator to physicalLayer.engine;\n        interface engineToTransmission connect physicalLayer.engine.torqueOut to physicalLayer.transmission.torqueIn {\n            ref flow torqueFlow from source.torque to target.torque;\n        }\n    }\n    action torqueGeneration {\n        action generate {\n            out torque: Torque;\n        }\n        action transmit {\n            in torque: Torque;\n        }\n        succession flow torqueFlow from generate.torque to transmit.torque;\n    }\n}",
    "package 'PowerSystem' {\n    attribute def Power;\n    attribute def Torque;\n    port def PowerPort {\n        out power: Power;\n    }\n    port def TorquePort {\n        out torque: Torque;\n    }\n    part context {\n        part logical {\n            part torqueGenerator {\n                port torquePort: TorquePort;\n                perform generateTorque.generate {\n                    out torque = torquePort.torque;\n                }\n            }\n        }\n        part physical {\n            part powertrain {\n                part engine {\n                    port torquePort: TorquePort;\n                    perform produceTorque.produce {\n                        out torque = torquePort.torque;\n                    }\n                }\n            }\n        }\n        allocate logical.torqueGenerator to physical.powertrain.engine;\n    }\n    action generateTorque {\n        action generate { out torque: Torque; }\n    }\n    action produceTorque {\n        action produce { out torque: Torque; }\n    }\n}",
    "package 'Vehicle Safety and Anti-theft Function Catalogue' {\n    attribute def Safety;\n    attribute def AntiTheft;\n    attribute def Mandatory;\n    \n    part def Component;\n    \n    part def FrontSeatBelts:> Component {\n        attribute safety: Safety = true;\n        attribute mandatory: Mandatory = true;\n    }\n    \n    part def Bumpers:> Component {\n        attribute safety: Safety = true;\n        attribute mandatory: Mandatory = true;\n    }\n    \n    part def DriversAirbag:> Component {\n        attribute safety: Safety = true;\n    }\n    \n    part def AntiLockBrakingSystem:> Component {\n        attribute safety: Safety = true;\n    }\n    \n    part def AlarmSystem:> Component {\n        attribute antiTheft: AntiTheft = true;\n    }\n    \n    part def KeylessEntrySystem:> Component {\n        attribute antiTheft: AntiTheft = true;\n    }\n    \n    set def SafetyComponents {\n        value: Component[?] = {FrontSeatBelts, Bumpers, DriversAirbag, AntiLockBrakingSystem};\n    }\n    \n    set def AntiTheftComponents {\n        value: Component[?] = {AlarmSystem, KeylessEntrySystem};\n    }\n    \n    set def MandatorySafetyComponents {\n        value: Component[?] = {FrontSeatBelts, Bumpers};\n    }\n    \n    part def Vehicle {\n        part frontSeatBelts: FrontSeatBelts;\n        part bumpers: Bumpers;\n        part? driversAirbag: DriversAirbag;\n        part? antiLockBrakingSystem: AntiLockBrakingSystem;\n        part alarmSystem: AlarmSystem;\n        part keylessEntrySystem: KeylessEntrySystem;\n    }\n}",
    "package 'FuelSystem' {\n    attribute def Fuel;\n    attribute def FuelPressurized;\n    attribute def Temperature;\n    \n    port def FuelSupplyPort {\n        out pressurizedFuel: FuelPressurized;\n    }\n    port def FuelReturnPort {\n        in returnedFuel: Fuel;\n    }\n    port def TemperaturePort {\n        out temp: Temperature;\n    }\n    \n    part context {\n        part fuelTankAssembly {\n            port supplyPort: FuelSupplyPort;\n            port returnPort: ~FuelReturnPort;\n            port tempPort: TemperaturePort;\n            perform fuelManagement.pressurizeFuel {\n                out pressurizedFuel = supplyPort.pressurizedFuel;\n            }\n            perform fuelManagement.monitorTemperature {\n                out temp = tempPort.temp;\n            }\n            perform fuelManagement.returnFuel {\n                in returnedFuel = returnPort.returnedFuel;\n            }\n        }\n        part fuelConsumingUnits {\n            port supplyPort: ~FuelSupplyPort;\n            port returnPort: FuelReturnPort;\n            perform fuelManagement.consumeFuel {\n                in pressurizedFuel = supplyPort.pressurizedFuel;\n                out returnedFuel = returnPort.returnedFuel;\n            }\n        }\n        part vehicleControlSystem {\n            port tempPort: ~TemperaturePort;\n            perform fuelManagement.receiveTemperature {\n                in temp = tempPort.temp;\n            }\n        }\n        interface supplyLine connect fuelTankAssembly.supplyPort to fuelConsumingUnits.supplyPort {\n            ref flow references fuelManagement.fuelSupplyFlow \n                from source.pressurizedFuel to target.pressurizedFuel;\n        }\n        interface returnLine connect fuelConsumingUnits.returnPort to fuelTankAssembly.returnPort {\n            ref flow references fuelManagement.fuelReturnFlow \n                from source.returnedFuel to target.returnedFuel;\n        }\n        interface tempDataLine connect fuelTankAssembly.tempPort to vehicleControlSystem.tempPort {\n            ref flow references fuelManagement.tempFlow \n                from source.temp to target.temp;\n        }\n    }\n    \n    action fuelManagement {\n        action pressurizeFuel { out pressurizedFuel: FuelPressurized; }\n        action consumeFuel { \n            in pressurizedFuel: FuelPressurized; \n            out returnedFuel: Fuel; \n        }\n        action returnFuel { in returnedFuel: Fuel; }\n        action monitorTemperature { out temp: Temperature; }\n        action receiveTemperature { in temp: Temperature; }\n        succession flow fuelSupplyFlow from pressurizeFuel.pressurizedFuel to consumeFuel.pressurizedFuel;\n        succession flow fuelReturnFlow from consumeFuel.returnedFuel to returnFuel.returnedFuel;\n        succession flow tempFlow from monitorTemperature.temp to receiveTemperature.temp;\n    }\n}",
    "package 'VehicleSystem' {\n    enum FeatureKind { safety, security }\n    \n    block SeatBelt { featureKind: FeatureKind = safety; }\n    block Airbag { featureKind: FeatureKind = safety; }\n    block AntiTheftAlarm { featureKind: FeatureKind = security; }\n    block Bumper { featureKind: FeatureKind = safety; }\n    block KeylessEntry { featureKind: FeatureKind = security; }\n    block Wheel { featureKind: FeatureKind = safety; }\n    block ABS { featureKind: FeatureKind = safety; }\n    \n    block Interior {\n        part seatBelts: SeatBelt[2];\n        part airbag: Airbag[0..1];\n        part antiTheftAlarm: AntiTheftAlarm[0..1];\n    }\n    \n    block Body {\n        part bumper: Bumper[1];\n        part keylessEntry: KeylessEntry[1];\n    }\n    \n    block Chassis {\n        part wheels: Wheel[2];\n        part absSystems: ABS[0..2];\n    }\n    \n    block Vehicle {\n        part interior: Interior[1];\n        part body: Body[1];\n        part chassis: Chassis[1];\n    }\n    \n    part vehicle: Vehicle;\n}",
    "package 'Vehicle Safety and Security' {\n    part def VehicleSafetySecuritySystem {\n        part interior: Interior;\n        part bodyAssembly: BodyAssembly;\n    }\n    part def Interior {\n        part alarmSystem: AlarmSystem;\n        part seatBelts: SeatBelts;\n        part frontRowSeats: FrontRowSeats;\n        part driversAirbag: DriversAirbag;\n    }\n    part def BodyAssembly {\n        part vehicleBody: VehicleBody;\n        part bumper: Bumper;\n        part keylessEntrySystem: KeylessEntrySystem;\n    }\n    part def AlarmSystem;\n    part def SeatBelts;\n    part def FrontRowSeats;\n    part def DriversAirbag;\n    part def VehicleBody;\n    part def Bumper;\n    part def KeylessEntrySystem;\n    attribute def Safety;\n    attribute def Security;\n    VehicleSafetySecuritySystem:> Safety, Security;\n    SeatBelts:> Safety;\n    DriversAirbag:> Safety;\n    Bumper:> Safety;\n    AlarmSystem:> Security;\n    KeylessEntrySystem:> Security;\n}",
    "package 'SecurityManagement' {\n    attribute def SecurityClassification: ['Unclassified', 'Confidential', 'Secret'];\n    port def ClassificationPort {\n        out classification: SecurityClassification;\n    }\n    port def DisplayPort {\n        out classification: SecurityClassification;\n    }\n    part context {\n        part admin {\n            port classificationPort: ClassificationPort;\n            port displayPort: ~DisplayPort;\n            perform securityProcess.assignClassification {\n                out classification = classificationPort.classification;\n            }\n            perform securityProcess.displayClassification {\n                in classification = displayPort.classification;\n            }\n        }\n        part component {\n            attribute securityLevel: SecurityClassification;\n            port classificationPort: ~ClassificationPort;\n            port displayPort: DisplayPort;\n            perform securityProcess.assignClassification {\n                in classification = classificationPort.classification;\n            }\n            perform securityProcess.displayClassification {\n                out classification = displayPort.classification;\n            }\n        }\n        interface classificationConnect \n            connect admin.classificationPort to component.classificationPort;\n        interface displayConnect \n            connect component.displayPort to admin.displayPort;\n    }\n    action securityProcess {\n        action assignClassification {\n            in classification: SecurityClassification;\n        }\n        action displayClassification {\n            out classification: SecurityClassification;\n        }\n    }\n}",
    "package 'Automotive System' {\n    attribute def CANMessage;\n    port def CANPort {\n        inout message: CANMessage;\n    }\n    port def UnitPort {\n        inout data: CANMessage;\n    }\n    port def SensorDataPort;\n    part def BusIF {\n        port unitPort: UnitPort;\n        port busPort: CANPort;\n        connection internalConnect connect unitPort to busPort {\n            ref flow dataFlow from unitPort.data to busPort.message;\n            ref flow dataFlow from busPort.message to unitPort.data;\n        }\n    }\n    part def VehicleControlUnit {\n        port busIFPort: ~UnitPort;\n        port sensorDataPort: SensorDataPort;\n    }\n    part def EngineControlUnit {\n        port busIFPort: ~UnitPort;\n        port sensorDataPort: SensorDataPort;\n    }\n    part def CAN_Bus {\n        port busPort1: CANPort;\n        port busPort2: CANPort;\n    }\n    part context {\n        part vcu: VehicleControlUnit;\n        part ecu: EngineControlUnit;\n        part busIF_VCU: BusIF;\n        part busIF_ECU: BusIF;\n        part canBus: CAN_Bus;\n        connection connectVCU_BusIF connect vcu.busIFPort to busIF_VCU.unitPort;\n        connection connectECU_BusIF connect ecu.busIFPort to busIF_ECU.unitPort;\n        connection connectVCU_Bus connect busIF_VCU.busPort to canBus.busPort1;\n        connection connectECU_Bus connect busIF_ECU.busPort to canBus.busPort2;\n    }\n}",
    "package 'BloodGlucoseMeterSystem' {\n    attribute def BatteryStatus;\n    attribute def Alert;\n    attribute def MeasurementAbnormality;\n    attribute def RiskScenario;\n    \n    port def BatteryStatusPort {\n        out batteryStatus: BatteryStatus;\n    }\n    port def AlertPort {\n        out alert: Alert;\n    }\n    port def AbnormalityPort {\n        out abnormality: MeasurementAbnormality;\n    }\n    \n    part context {\n        part battery {\n            port statusPort: BatteryStatusPort;\n            perform safetyMonitoring.sendBatteryStatus {\n                out batteryStatus = statusPort.batteryStatus;\n            }\n        }\n        part bloodGlucoseMeter {\n            port batteryStatusInPort: ~BatteryStatusPort;\n            port alertPort: AlertPort;\n            port abnormalityPort: AbnormalityPort;\n            perform safetyMonitoring.checkBattery {\n                in batteryStatus = batteryStatusInPort.batteryStatus;\n                out alert = alertPort.alert;\n            }\n            perform safetyMonitoring.detectAbnormality {\n                out abnormality = abnormalityPort.abnormality;\n            }\n        }\n        part user {\n            port alertInPort: ~AlertPort;\n            perform safetyMonitoring.receiveAlert {\n                in alert = alertInPort.alert;\n            }\n        }\n        part riskManager {\n            port abnormalityInPort: ~AbnormalityPort;\n            perform safetyMonitoring.manageRisk {\n                in abnormality = abnormalityInPort.abnormality;\n            }\n        }\n        \n        interface batteryToMeter connect battery.statusPort to bloodGlucoseMeter.batteryStatusInPort {\n            ref flow references safetyMonitoring.batteryStatusFlow\n                from source.batteryStatus to target.batteryStatus;\n        }\n        interface meterToUser connect bloodGlucoseMeter.alertPort to user.alertInPort {\n            ref flow references safetyMonitoring.alertFlow\n                from source.alert to target.alert;\n        }\n        interface meterToRiskManager connect bloodGlucoseMeter.abnormalityPort to riskManager.abnormalityInPort {\n            ref flow references safetyMonitoring.abnormalityFlow\n                from source.abnormality to target.abnormality;\n        }\n    }\n    \n    action safetyMonitoring {\n        action sendBatteryStatus { out batteryStatus: BatteryStatus; }\n        action checkBattery {\n            in batteryStatus: BatteryStatus;\n            out alert: Alert;\n        }\n        action detectAbnormality { out abnormality: MeasurementAbnormality; }\n        action receiveAlert { in alert: Alert; }\n        action manageRisk { in abnormality: MeasurementAbnormality; }\n        \n        succession flow batteryStatusFlow from sendBatteryStatus.batteryStatus to checkBattery.batteryStatus;\n        succession flow alertFlow from checkBattery.alert to receiveAlert.alert;\n        succession flow abnormalityFlow from detectAbnormality.abnormality to manageRisk.abnormality;\n    }\n}",
    "package 'ScientificConstants' {\n    unit m;\n    unit s;\n    unit dimensionless = 1;\n    unit m_per_s = m / s;\n    unit m_per_s2 = m / (s^2);\n    \n    block MathematicalConstants {\n        attribute e : Real { initial: 2.71828182845904523536; }\n        attribute pi : Real { initial: 3.14159265358979323846; }\n    }\n    \n    block PhysicalConstants {\n        attribute speedOfLight : Real { initial: 299792458; unit: m_per_s; }\n        attribute fineStructureConstant : Real { initial: 0.0072973525693; unit: dimensionless; }\n        attribute electronProtonMassRatio : Real { initial: 0.000544617023; unit: dimensionless; }\n    }\n    \n    block ScenarioConstants {\n        attribute earthGravity : Real { initial: 9.80665; unit: m_per_s2; }\n        attribute modelXAmplifierGain : Real { initial: 42.0; unit: dimensionless; }\n    }\n    \n    block ScientificConstantsSystem {\n        attribute math : MathematicalConstants;\n        attribute physical : PhysicalConstants;\n        attribute scenario : ScenarioConstants;\n    }\n}",
    "package 'AutomotiveComponents' {\n    part def CarTire {\n        attribute manufacturer: String;\n        attribute rimDiameter: Real;\n        attribute width: Integer;\n    }\n    \n    part michelinTire: CarTire {\n        manufacturer = \"Michelin\";\n        rimDiameter = 18.0;\n        width = 245;\n    }\n}",
    "package 'AutomotiveComponentModel' {\n  unit def kg;\n  unit def m;\n  unit def mm;\n  unit def inch;\n  part def Vehicle {\n    attribute mass: Real (unit = 'kg') = 1200;\n    attribute length: Real (unit = 'm') = 4.82;\n    part frontLeft: Wheel[1];\n    part frontRight: Wheel[1];\n  }\n  part def Wheel {\n    attribute hubDiameter: Real (unit = 'inch') = 18;\n    attribute width: Real (unit = 'mm') = 245;\n    part tire: Tire[1];\n    attribute outerDiameter: Real (unit = 'inch') {\n      constraint derive = hubDiameter + 2 * tire.height;\n    }\n  }\n  part def Tire {\n    attribute height: Real (unit = 'inch');\n  }\n}",
    "package 'Powertrain Configuration' {\n    enum EngineType {\n        FourCylinder,\n        SixCylinder\n    }\n    enum TransmissionType {\n        Manual,\n        Automatic\n    }\n    block Vehicle {\n        attribute isHighPerformance: Boolean;\n        attribute engineType: EngineType;\n        attribute transmissionType: TransmissionType;\n        constraint engineSelection {\n            (isHighPerformance implies (engineType == EngineType::SixCylinder)) and\n            (not isHighPerformance implies (engineType == EngineType::FourCylinder));\n        }\n        constraint validCombination {\n            (engineType == EngineType::FourCylinder and transmissionType == TransmissionType::Manual) or\n            (engineType == EngineType::SixCylinder and transmissionType == TransmissionType::Automatic);\n        }\n    }\n}",
    "package 'AutomotiveSystem' {\n    value type Length {\n        unit m;\n        unit mm = m / 1000;\n        unit inch = 25.4 mm;\n    }\n    value type Mass {\n        unit kg;\n    }\n    part def Car {\n        attribute mass: Mass = 1200 [kg];\n        attribute length: Length = 4.82 [m];\n        part wheelAssembly: WheelAssembly[*];\n    }\n    part def WheelAssembly {\n        part wheel: Wheel;\n        part brakeDisc: BrakeDisc;\n        constraint brakeDiscFit {\n            brakeDisc.diameter < wheel.outerDiameter;\n        }\n    }\n    part def Wheel {\n        part rim: Rim;\n        part tire: Tire;\n        attribute outerDiameter: Length = rim.diameter + 2 * tire.height;\n    }\n    part def Rim {\n        attribute diameter: Length = 18 [inch];\n    }\n    part def Tire {\n        attribute width: Length = 245 [mm];\n        attribute height: Length = 45 [mm];\n        attribute treadDepth: Length = 6.0 [mm];\n        constraint minTreadDepth {\n            treadDepth >= 3.5 [mm];\n        }\n    }\n    part def BrakeDisc {\n        attribute radius: Length = 95 [mm];\n        attribute diameter: Length = 2 * radius;\n    }\n}",
    "package 'AutomotiveFuelSystem' {\n    attribute def Fuel;\n    attribute def FuelTemperature;\n    \n    port def FuelPort {\n        in? fuel: Fuel;\n        out? fuel: Fuel;\n    }\n    port def TemperaturePort {\n        out temperature: FuelTemperature;\n    }\n    \n    part context {\n        part fuelTankAssembly {\n            port outlet: FuelPort;\n            port temperaturePort: TemperaturePort;\n            \n            part fuelTank {\n                port fuelPort: FuelPort;\n                port temperaturePort: TemperaturePort;\n                perform fuelSystem.measureTemperature;\n            }\n            part fuelPump {\n                port tankPort: FuelPort;\n                port enginePort: FuelPort;\n                perform fuelSystem.pumpToEngine;\n                perform fuelSystem.handleReturn;\n            }\n            \n            interface pumpToTank connect fuelPump.tankPort to fuelTank.fuelPort {\n                ref flow references fuelFlow from source.tankPort to target.fuelPort;\n            }\n            interface pumpToOutlet connect fuelPump.enginePort to outlet {\n                ref flow references outletFlow from source.enginePort to target.outlet;\n            }\n            interface tempConnect connect fuelTank.temperaturePort to temperaturePort {\n                ref flow references tempFlow from source.temperaturePort to target.temperaturePort;\n            }\n        }\n        \n        part engine {\n            port fuelPort: ~FuelPort;\n        }\n        part monitoringSystem {\n            port temperaturePort: ~TemperaturePort;\n        }\n        \n        interface supplyConnect fuelTankAssembly.outlet to engine.fuelPort {\n            ref flow references supplyFlow from source.outlet to target.fuelPort;\n        }\n        interface monitorConnect fuelTankAssembly.temperaturePort to monitoringSystem.temperaturePort {\n            ref flow references monitorFlow from source.temperaturePort to target.temperaturePort;\n        }\n    }\n    \n    action fuelSystem {\n        action measureTemperature { out temperature: FuelTemperature; }\n        \n        action pumpToEngine {\n            in fuelIn: Fuel;\n            out fuelOut: Fuel;\n            succession flow from fuelIn to fuelOut;\n        }\n        action handleReturn {\n            in fuelIn: Fuel;\n            out fuelOut: Fuel;\n            succession flow from fuelIn to fuelOut;\n        }\n    }\n}",
    "package 'PhysicalQuantitySystem' {\n  class BaseDimension {\n    attribute name: String;\n  }\n  class Dimension {\n    ref baseDimension: BaseDimension;\n    attribute exponent: Real;\n  }\n  class PhysicalQuantity {\n    part dimensions: Dimension[*];\n  }\n  class Unit {\n    ref quantity: PhysicalQuantity;\n    attribute conversionFactor: Real;\n    attribute offset: Real = 0;\n  }\n  action ConvertUnit {\n    in inputValue: Real;\n    in fromUnit: Unit;\n    in toUnit: Unit;\n    out outputValue: Real;\n  }\n  action AddBaseDimension {\n    in name: String;\n    out newBaseDimension: BaseDimension;\n  }\n  action AddPhysicalQuantity {\n    in baseDimensions: BaseDimension[*];\n    in exponents: Real[*];\n    out newPhysicalQuantity: PhysicalQuantity;\n  }\n  action AddUnit {\n    in quantity: PhysicalQuantity;\n    in conversionFactor: Real;\n    in offset: Real = 0;\n    out newUnit: Unit;\n  }\n  action Import {\n    in data: String;\n  }\n  part context {\n    part system {\n      part baseDimensions: BaseDimension[*];\n      part quantities: PhysicalQuantity[*];\n      part units: Unit[*];\n      perform addBaseDim: AddBaseDimension;\n      perform addPhysicalQty: AddPhysicalQuantity;\n      perform addUnit: AddUnit;\n      perform convert: ConvertUnit;\n      perform import: Import;\n    }\n  }\n}",
    "package 'UnitSystemLibrary' {\n    unit system def ISQ;\n    unit system def USCustomaryUnits;\n    unit system def UnitSystem;\n    ISQ: UnitSystem;\n    USCustomaryUnits: UnitSystem;\n    \n    attribute def QuantityKind;\n    attribute def Unit {\n        attribute system: UnitSystem;\n        attribute quantityKind: QuantityKind;\n    }\n    attribute def PhysicalQuantity {\n        attribute value: Real;\n        attribute unit: Unit;\n    }\n    attribute def ConversionRequest {\n        attribute input: PhysicalQuantity;\n        attribute targetUnit: Unit;\n    }\n    attribute def ConversionResult {\n        attribute output: PhysicalQuantity;\n    }\n    \n    port def UserRequestPort {\n        out request: ConversionRequest;\n    }\n    port def LibraryServicePort {\n        in request: ConversionRequest;\n        out result: ConversionResult;\n    }\n    \n    part context {\n        part user {\n            port requestPort: UserRequestPort;\n            perform conversionInteraction.sendRequest {\n                out request = requestPort.request;\n            }\n        }\n        part library {\n            port servicePort: LibraryServicePort;\n            perform conversionInteraction.convertUnits {\n                in request = servicePort.request;\n                out result = servicePort.result;\n            }\n        }\n        interface userToLibrary connect user.requestPort to library.servicePort {\n            ref flow requestFlow references conversionInteraction.requestFlow\n                from source.request to target.request;\n            ref flow resultFlow references conversionInteraction.resultFlow\n                from target.result to source.result;\n        }\n    }\n    action conversionInteraction {\n        action sendRequest { out request: ConversionRequest; }\n        action convertUnits {\n            in request: ConversionRequest;\n            out result: ConversionResult;\n        }\n        flow requestFlow: request;\n        flow resultFlow: result;\n        succession from sendRequest to convertUnits;\n        succession from convertUnits to sendRequest;\n    }\n}",
    "package 'HeadlampVerificationSystem' {\n    unit def deg;\n    constant def pi: Real = 3.141592653589793;\n    constant def e: Real = 2.718281828459045;\n    \n    attribute def TiltAngle: Real {\n        unit: deg;\n    }\n    \n    requirement def TiltAngleRequirement {\n        id: 'REQ1';\n        text: \"Headlamp beam tilt angle must be between 50 and 80 degrees.\";\n    }\n    \n    constraint def ValidTiltRange {\n        parameter angle: TiltAngle;\n        constraint: angle >= 50.0 and angle <= 80.0;\n    }\n    \n    verification def TiltAngleVerification {\n        requirement = TiltAngleRequirement;\n        method = \"Check tilt angle against valid range constraint\";\n        constraint = ValidTiltRange;\n    }\n    \n    part context {\n        part adjustmentKnob {\n            attribute tiltAngle: TiltAngle;\n        }\n        \n        satisfy TiltAngleRequirement {\n            constraint = TiltAngleVerification.constraint;\n            bind angle to adjustmentKnob.tiltAngle;\n        }\n    }\n}",
    "package 'DataManagementSystem' {\n    type UnsignedInteger {\n        value: Integer;\n        constraint { value >= 0 }\n    }\n    type UnsignedFloat {\n        value: Real;\n        constraint { value >= 0.0 }\n    }\n    type DateTime: String;\n    enum StatusLevel {\n        critical,\n        warning,\n        normal\n    }\n    type StatusCondition {\n        level: StatusLevel;\n        color: String;\n        constraint {\n            (level == StatusLevel::critical implies color == \"red\") and\n            (level == StatusLevel::warning implies color == \"yellow\") and\n            (level == StatusLevel::normal implies color == \"green\")\n        }\n    }\n    enum DiameterOption {\n        Small,\n        Medium,\n        Large\n    }\n    type Diameter {\n        option: DiameterOption;\n        value: Real;\n        constraint {\n            (option == DiameterOption::Small implies value == 60.0) and\n            (option == DiameterOption::Medium implies value == 70.0) and\n            (option == DiameterOption::Large implies value == 80.0)\n        }\n        initial: option = DiameterOption::Small;\n    }\n}",
    "package 'CollectionManagementSystem' {\n    type SparePart;\n    type Person;\n    type SetOfPerson : Person[*] { unordered, unique };\n    part def System {\n        attribute spareParts : SparePart[*] { unordered, nonunique };\n        attribute integers : Integer[*] { ordered, nonunique };\n        attribute strings : String[*] { unordered, unique };\n        attribute personnel : Person[*] { ordered, unique };\n        attribute nestedPersonnel : SetOfPerson[*] { ordered, nonunique };\n        attribute realNumbers : Real[4];\n    }\n}",
    "package 'TireSystem' {\n    dimension Length;\n    unit in for Length;\n\n    value type Vector3D {\n        attribute x: Real;\n        attribute y: Real;\n        attribute z: Real;\n    }\n\n    block Tire {\n        attribute manufacturer: String;\n        attribute rimDiameter: Length { unit = in; };\n        attribute width: Real;\n        attribute position: Vector3D[0..1];\n    }\n\n    block TireInformationSystem {\n        part tires: Tire[*];\n    }\n}",
    "package 'TrajectoryRecording' {\n    attribute def Time: Real;\n    attribute def Position: Vector3D;\n    attribute def Velocity: Vector3D;\n    attribute def UTCTime: String;\n    \n    structure Vector3D {\n        attribute x: Real;\n        attribute y: Real;\n        attribute z: Real;\n    }\n    \n    structure TrajectorySample {\n        attribute time: Time;\n        attribute position: Position;\n        attribute velocity: Velocity;\n    }\n    \n    port def StatePort {\n        out state: TrajectorySample;\n    }\n    \n    port def RecordingPort {\n        in sample: TrajectorySample;\n    }\n    \n    part context {\n        part spacecraft {\n            port statePort: StatePort;\n            perform recordTrajectory.provideState {\n                out state = statePort.state;\n            }\n        }\n        \n        part recorder {\n            attribute liftoffUTC: UTCTime;\n            port recordingPort: ~RecordingPort;\n            perform recordTrajectory.recordSample {\n                in sample = recordingPort.sample;\n            }\n        }\n        \n        interface stateConnection connect spacecraft.statePort to recorder.recordingPort {\n            ref flow references recordTrajectory.stateFlow \n                from source.state to target.sample;\n        }\n    }\n    \n    action recordTrajectory {\n        action provideState { out state: TrajectorySample; }\n        action recordSample { in sample: TrajectorySample; }\n        succession flow stateFlow from provideState.state to recordSample.sample;\n    }\n}",
    "package 'MaterialScience' {\n    unit def GramPerMole;\n    unit def NewtonPerSquareMillimeter;\n    \n    attribute def AtomicMass;\n    attribute def MassFraction;\n    attribute def TensileStrength;\n    \n    part def Material {\n        attribute name: string;\n        part atomicMass: AtomicMass {\n            attribute value: real;\n            port unit -> GramPerMole;\n        }\n    }\n    \n    part def Alloy {\n        attribute name: string;\n        part component: MaterialComponent[*];\n        part tensileStrength: TensileStrength {\n            attribute value: real;\n            port unit -> NewtonPerSquareMillimeter;\n        }\n    }\n    \n    part def MaterialComponent {\n        attribute massFraction: real;\n        port material: Material;\n    }\n    \n    part iron: Material {\n        name = \"Iron\";\n        atomicMass.value = 55.845;\n    }\n    \n    part carbon: Material {\n        name = \"Carbon\";\n        atomicMass.value = 12.011;\n    }\n    \n    part manganese: Material {\n        name = \"Manganese\";\n        atomicMass.value = 54.938;\n    }\n    \n    part steel980: Alloy {\n        name = \"Steel 980\";\n        part ironComp: MaterialComponent {\n            massFraction = 0.98;\n            port material -> iron;\n        }\n        part carbonComp: MaterialComponent {\n            massFraction = 0.02;\n            port material -> carbon;\n        }\n        tensileStrength.value = 980;\n    }\n    \n    action manageAlloyData {\n        action viewComposition;\n        action editProperty;\n        action expandDataset;\n        succession editThenView from editProperty to viewComposition;\n        succession viewThenExpand from viewComposition to expandDataset;\n    }\n}",
    "package 'MaterialsDatabase' {\n    dimension def Mass;\n    unit def Kilogram: Mass;\n    unit def Gram: Mass = 0.001 * Kilogram;\n    unit def AtomicMassUnit: Mass;\n    \n    dimension def Length;\n    unit def Meter: Length;\n    unit def Millimeter: Length = 0.001 * Meter;\n    \n    dimension def Area = Length^2;\n    unit def SquareMillimeter: Area = Millimeter^2;\n    \n    dimension def Force;\n    unit def Newton: Force;\n    unit def NewtonPerSquareMillimeter: Force / Area = Newton / SquareMillimeter;\n    \n    attribute def AtomicMass: Real (unit = AtomicMassUnit);\n    attribute def MassFraction: Real;\n    attribute def TensileStrength: Real (unit = NewtonPerSquareMillimeter);\n    \n    part def Material {\n        attribute name: String;\n    }\n    \n    part def Metal extends Material {\n        part composition: Composition;\n    }\n    \n    part def Composition {\n        part constituents: Constituent[*];\n    }\n    \n    part def Constituent {\n        attribute material: Material;\n        attribute massFraction: MassFraction;\n    }\n    \n    part def PropertySet {\n        attribute atomicMass: AtomicMass?;\n        attribute tensileStrength: TensileStrength?;\n    }\n    \n    part context {\n        part materialDB {\n            part materials: Material[*];\n            part propertySets: PropertySet[*];\n        }\n    }\n}",
    "package 'PubSubSystem' {\n    attribute def Topic;\n    attribute def Message;\n    port def PublisherPort {\n        out topic: Topic;\n        out message: Message;\n    }\n    port def SubscriberPort {\n        out topic: Topic;\n    }\n    port def DeliveryPort {\n        out message: Message;\n    }\n    part context {\n        part producer {\n            port publisherPort: PublisherPort;\n            perform pubSubInteraction.publish {\n                out topic = publisherPort.topic;\n                out message = publisherPort.message;\n            }\n        }\n        interface producerToServer connect producer.publisherPort to server.publisherPort {\n            ref flow references pubSubInteraction.pubFlow \n                from source.topic to target.topic;\n            ref flow references pubSubInteraction.pubFlow2 \n                from source.message to target.message;\n        }\n        part server {\n            port publisherPort: ~PublisherPort;\n            port subscriberPort: ~SubscriberPort;\n            port deliveryPort: DeliveryPort;\n            perform pubSubInteraction.receivePublication {\n                in topic = publisherPort.topic;\n                in message = publisherPort.message;\n            }\n            perform pubSubInteraction.receiveSubscription {\n                in topic = subscriberPort.topic;\n            }\n            perform pubSubInteraction.deliver {\n                out message = deliveryPort.message;\n            }\n        }\n        part consumer {\n            port subscriberPort: SubscriberPort;\n            port deliveryPort: ~DeliveryPort;\n            perform pubSubInteraction.subscribe {\n                out topic = subscriberPort.topic;\n            }\n            perform pubSubInteraction.receive {\n                in message = deliveryPort.message;\n            }\n        }\n        interface consumerToServer connect consumer.subscriberPort to server.subscriberPort {\n            ref flow references pubSubInteraction.subFlow \n                from source.topic to target.topic;\n        }\n        interface serverToConsumer connect server.deliveryPort to consumer.deliveryPort {\n            ref flow references pubSubInteraction.deliveryFlow \n                from source.message to target.message;\n        }\n    }\n    action pubSubInteraction {\n        action publish { out topic: Topic; out message: Message; }\n        action subscribe { out topic: Topic; }\n        action receivePublication { in topic: Topic; in message: Message; }\n        action receiveSubscription { in topic: Topic; }\n        action deliver { out message: Message; }\n        action receive { in message: Message; }\n        succession flow subFlow from subscribe.topic to receiveSubscription.topic;\n        succession flow pubFlow from publish.topic to receivePublication.topic;\n        succession flow pubFlow2 from publish.message to receivePublication.message;\n        succession flow deliveryFlow from deliver.message to receive.message;\n    }\n}",
    "package 'VehicleFuelSystem' {\n    attribute def Fuel;\n    attribute def Temperature;\n    port def FuelPort {\n        feature fuel: Fuel;\n    }\n    port def TemperaturePort {\n        out temperature: Temperature;\n    }\n    part def FuelTankAssembly {\n        port supplyPort: FuelPort {\n            out fuel;\n        }\n        port returnPort: FuelPort {\n            in fuel;\n        }\n        port tempPort: TemperaturePort;\n        perform fuelSystem.supplyFuel {\n            out fuel = supplyPort.fuel;\n            out temp = tempPort.temperature;\n        }\n        perform fuelSystem.receiveReturn {\n            in fuel = returnPort.fuel;\n        }\n    }\n    part def Engine {\n        port supplyPort: FuelPort {\n            in fuel;\n        }\n        port returnPort: FuelPort {\n            out fuel;\n        }\n        perform fuelSystem.consumeFuel {\n            in fuel = supplyPort.fuel;\n        }\n        perform fuelSystem.returnUnused {\n            out fuel = returnPort.fuel;\n        }\n    }\n    part context {\n        part fuelTank: FuelTankAssembly;\n        part engine: Engine;\n        interface supplyLine connect fuelTank.supplyPort to engine.supplyPort {\n            ref flow references fuelSystem.supplyFlow \n                from source.fuel to target.fuel;\n        }\n        interface returnLine connect engine.returnPort to fuelTank.returnPort {\n            ref flow references fuelSystem.returnFlow \n                from source.fuel to target.fuel;\n        }\n        port temperaturePort: TemperaturePort;\n        binding connect fuelTank.tempPort to temperaturePort;\n    }\n    action fuelSystem {\n        action supplyFuel { out fuel: Fuel; out temp: Temperature; }\n        action consumeFuel { in fuel: Fuel; }\n        action returnUnused { out fuel: Fuel; }\n        action receiveReturn { in fuel: Fuel; }\n        succession flow supplyFlow from supplyFuel.fuel to consumeFuel.fuel;\n        succession flow returnFlow from returnUnused.fuel to receiveReturn.fuel;\n    }\n}",
    "package 'PubSubSystem' {\n    attribute def Publication;\n    attribute def Subscription;\n    attribute def Delivery;\n    port def PublisherPort {\n        out publication: Publication;\n    }\n    port def SubscriberPort {\n        out subscription: Subscription;\n    }\n    port def DeliveryPort {\n        out delivery: Delivery;\n    }\n    part context {\n        part producer {\n            port publisherPort: PublisherPort;\n            perform pubSubFlow.publish {\n                out publication = publisherPort.publication;\n            }\n        }\n        part server {\n            port publisherPort: ~PublisherPort;\n            port subscriberPort: ~SubscriberPort;\n            port deliveryPort: DeliveryPort;\n            perform pubSubFlow.receivePublication {\n                in publication = publisherPort.publication;\n                out delivery = deliveryPort.delivery;\n            }\n            perform pubSubFlow.receiveSubscription {\n                in subscription = subscriberPort.subscription;\n            }\n        }\n        part consumer {\n            port subscriberPort: SubscriberPort;\n            port deliveryPort: ~DeliveryPort;\n            perform pubSubFlow.subscribe {\n                out subscription = subscriberPort.subscription;\n            }\n            perform pubSubFlow.receive {\n                in delivery = deliveryPort.delivery;\n            }\n        }\n        interface producerToServer connect producer.publisherPort to server.publisherPort {\n            ref flow references pubSubFlow.publicationFlow\n                from source.publication to target.publication;\n        }\n        interface consumerToServer connect consumer.subscriberPort to server.subscriberPort {\n            ref flow references pubSubFlow.subscriptionFlow\n                from source.subscription to target.subscription;\n        }\n        interface serverToConsumer connect server.deliveryPort to consumer.deliveryPort {\n            ref flow references pubSubFlow.deliveryFlow\n                from source.delivery to target.delivery;\n        }\n    }\n    action pubSubFlow {\n        action subscribe { out subscription: Subscription; }\n        action receiveSubscription { in subscription: Subscription; }\n        succession flow subscriptionFlow from subscribe.subscription to receiveSubscription.subscription;\n        action publish { out publication: Publication; }\n        action receivePublication { \n            in publication: Publication; \n            out delivery: Delivery; \n        }\n        succession flow publicationFlow from publish.publication to receivePublication.publication;\n        action receive { in delivery: Delivery; }\n        succession flow deliveryFlow from receivePublication.delivery to receive.delivery;\n    }\n}",
    "package 'TransportationService' {\n    attribute def FuelLevel;\n    attribute def MaxTankCapacity;\n    attribute def RefuelCmd;\n    attribute def EnvironmentFactor;\n    \n    port def FuelLevelPort {\n        out fuelLevel: FuelLevel;\n    }\n    port def RefuelCmdPort {\n        out refuelCmd: RefuelCmd;\n    }\n    port def EnvironmentPort {\n        out environment: EnvironmentFactor;\n    }\n    port def RefuelingPort {\n        out refueling: FuelLevel;\n    }\n    \n    part context {\n        part driver {\n            port fuelLevelPort: ~FuelLevelPort;\n            port refuelCmdPort: RefuelCmdPort;\n            port environmentPort: ~EnvironmentPort;\n            perform travelProcess.driverBoarding;\n            perform travelProcess.operateVehicle;\n            perform travelProcess.driverExiting;\n            perform travelProcess.monitorFuel {\n                in fuelLevel = fuelLevelPort.fuelLevel;\n                out refuelCmd = refuelCmdPort.refuelCmd;\n            }\n        }\n        part passengers[0..4] {\n            perform travelProcess.passengerBoarding;\n            perform travelProcess.passengerExiting;\n        }\n        part vehicle {\n            port fuelLevelPort: FuelLevelPort;\n            port refuelCmdPort: ~RefuelCmdPort;\n            port environmentPort: EnvironmentPort;\n            port refuelingPort: ~RefuelingPort;\n            perform travelProcess.consumeFuel {\n                out fuelLevel = fuelLevelPort.fuelLevel;\n            }\n        }\n        part gasStation {\n            port refuelCmdPort: ~RefuelCmdPort;\n            port refuelingPort: RefuelingPort;\n            perform travelProcess.refuelVehicle {\n                in refuelCmd = refuelCmdPort.refuelCmd;\n                out refueling = refuelingPort.refueling;\n            }\n        }\n        part environment {\n            port environmentPort: EnvironmentPort;\n            perform travelProcess.provideEnvironment {\n                out environment = environmentPort.environment;\n            }\n        }\n        interface driverToVehicle connect driver.fuelLevelPort to vehicle.fuelLevelPort {\n            ref flow fuelLevelFlow from source.fuelLevel to target.fuelLevel;\n        }\n        interface driverToGasStation connect driver.refuelCmdPort to gasStation.refuelCmdPort {\n            ref flow refuelCmdFlow from source.refuelCmd to target.refuelCmd;\n        }\n        interface gasStationToVehicle connect gasStation.refuelingPort to vehicle.refuelingPort {\n            ref flow refuelingFlow from source.refueling to target.refueling;\n        }\n        interface environmentToDriver connect environment.environmentPort to driver.environmentPort {\n            ref flow environmentFlow from source.environment to target.environment;\n        }\n        interface environmentToVehicle connect environment.environmentPort to vehicle.environmentPort {\n            ref flow environmentFlow from source.environment to target.environment;\n        }\n    }\n    \n    action travelProcess {\n        action driverBoarding;\n        action passengerBoarding;\n        succession boardingSequence from driverBoarding to passengerBoarding;\n        \n        action operateVehicle;\n        action consumeFuel {\n            out fuelLevel: FuelLevel;\n        }\n        succession operationFlow from operateVehicle to consumeFuel;\n        \n        action monitorFuel {\n            in fuelLevel: FuelLevel;\n            out refuelCmd: RefuelCmd;\n        }\n        flow fuelMonitoringFlow from consumeFuel.fuelLevel to monitorFuel.fuelLevel;\n        \n        action refuelVehicle {\n            in refuelCmd: RefuelCmd;\n            out refueling: FuelLevel;\n        }\n        succession refuelSequence from monitorFuel.refuelCmd to refuelVehicle.refuelCmd;\n        \n        action provideEnvironment {\n            out environment: EnvironmentFactor;\n        }\n        \n        action driverExiting;\n        action passengerExiting;\n        succession exitingSequence from passengerExiting to driverExiting;\n        \n        succession mainFlow from boardingSequence to operationFlow;\n        succession from operationFlow to exitingSequence;\n    }\n}",
    "package 'FuelSystem' {\n    attribute def Fuel {\n        temperature: Real;\n    }\n    port def FuelSupplyPort {\n        flow fuel: Fuel;\n    }\n    port def FuelReturnPort {\n        flow fuel: Fuel;\n    }\n    part def FuelTank {\n        port supplyPort: out FuelSupplyPort;\n        port returnPort: in FuelReturnPort;\n        perform fuelManagement.supplyFuel {\n            out fuel = supplyPort.fuel;\n        }\n        perform fuelManagement.receiveReturn {\n            in fuel = returnPort.fuel;\n        }\n    }\n    part def Engine {\n        port inletPort: in FuelSupplyPort;\n        port returnPort: out FuelReturnPort;\n        perform fuelManagement.consumeFuel {\n            in fuel = inletPort.fuel;\n        }\n        perform fuelManagement.returnFuel {\n            out fuel = returnPort.fuel;\n        }\n    }\n    part context {\n        part fuelTank: FuelTank;\n        part engine: Engine;\n        connect fuelTank.supplyPort to engine.inletPort;\n        connect engine.returnPort to fuelTank.returnPort;\n    }\n    action fuelManagement {\n        action supplyFuel { out fuel: Fuel; }\n        action consumeFuel { in fuel: Fuel; }\n        action returnFuel { out fuel: Fuel; }\n        action receiveReturn { in fuel: Fuel; }\n        succession flow supplyFlow from supplyFuel.fuel to consumeFuel.fuel;\n        succession flow returnFlow from returnFuel.fuel to receiveReturn.fuel;\n    }\n}",
    "package 'VehicleFuelSystem' {\n    attribute def Fuel {\n        attribute temperature: Real;\n    }\n    port def FuelPort {\n        feature fuel: Fuel;\n    }\n    part context {\n        part fuelTank: FuelTankAssembly;\n        part engine: Engine;\n        interface supplyLine connect fuelTank.supplyPort to engine.supplyPort {\n            ref flow references manageFuel.supplyFlow\n                from source.fuel to target.fuel;\n        }\n        interface returnLine connect engine.returnPort to fuelTank.returnPort {\n            ref flow references manageFuel.returnFlow\n                from source.fuel to target.fuel;\n        }\n    }\n    part def FuelTankAssembly {\n        port supplyPort: FuelPort [out];\n        port returnPort: FuelPort [in];\n        perform manageFuel.supplyFuel {\n            out fuel = supplyPort.fuel;\n        }\n        perform manageFuel.returnFuel {\n            in fuel = returnPort.fuel;\n        }\n    }\n    part def Engine {\n        port supplyPort: FuelPort [in];\n        port returnPort: FuelPort [out];\n        perform manageFuel.consumeFuel {\n            in fuel = supplyPort.fuel;\n        }\n        perform manageFuel.returnUnusedFuel {\n            out fuel = returnPort.fuel;\n        }\n    }\n    action manageFuel {\n        action supplyFuel { out fuel: Fuel; }\n        action consumeFuel { in fuel: Fuel; }\n        succession flow supplyFlow from supplyFuel.fuel to consumeFuel.fuel;\n        action returnUnusedFuel { out fuel: Fuel; }\n        action returnFuel { in fuel: Fuel; }\n        succession flow returnFlow from returnUnusedFuel.fuel to returnFuel.fuel;\n    }\n}",
    "package 'PhotoSystem' {\n    attribute def SceneSelection;\n    attribute def RawImage;\n    attribute def FocusedImage;\n    attribute def Photo;\n    \n    port def UserPort {\n        out sceneSelection: SceneSelection;\n        in photo: Photo;\n    }\n    port def SystemUserPort {\n        in sceneSelection: SceneSelection;\n        out photo: Photo;\n    }\n    port def SystemEnvPort {\n        out sceneSelection: SceneSelection;\n        in rawImage: RawImage;\n    }\n    port def EnvironmentPort {\n        in sceneSelection: SceneSelection;\n        out rawImage: RawImage;\n    }\n    \n    part context {\n        part user {\n            port userPort: UserPort;\n            perform obtainPhoto.selectScene {\n                out sceneSelection = userPort.sceneSelection;\n            }\n            perform obtainPhoto.receivePhoto {\n                in photo = userPort.photo;\n            }\n        }\n        part system {\n            port userPort: ~SystemUserPort;\n            port envPort: SystemEnvPort;\n            perform obtainPhoto.requestScene {\n                in sceneSelection = userPort.sceneSelection;\n                out sceneSelection = envPort.sceneSelection;\n            }\n            perform obtainPhoto.performFocusing {\n                in rawImage = envPort.rawImage;\n                out focusedImage: FocusedImage;\n            }\n            perform obtainPhoto.capturePhoto {\n                in focusedImage: FocusedImage;\n                out photo = userPort.photo;\n            }\n        }\n        part environment {\n            port envPort: ~EnvironmentPort;\n            perform obtainPhoto.provideScene {\n                in sceneSelection = envPort.sceneSelection;\n                out rawImage = envPort.rawImage;\n            }\n        }\n        interface userToSystem connect user.userPort to system.userPort {\n            ref flow references obtainPhoto.sceneSelectionFlow1\n                from source.sceneSelection to target.sceneSelection;\n            ref flow references obtainPhoto.photoFlow\n                from target.photo to source.photo;\n        }\n        interface systemToEnv connect system.envPort to environment.envPort {\n            ref flow references obtainPhoto.sceneSelectionFlow2\n                from source.sceneSelection to target.sceneSelection;\n            ref flow references obtainPhoto.rawImageFlow\n                from target.rawImage to source.rawImage;\n        }\n    }\n    \n    action obtainPhoto {\n        action selectScene { out sceneSelection: SceneSelection; }\n        action requestScene {\n            in sceneSelection: SceneSelection;\n            out sceneSelection: SceneSelection;\n        }\n        action provideScene {\n            in sceneSelection: SceneSelection;\n            out rawImage: RawImage;\n        }\n        action performFocusing { in rawImage: RawImage; out focusedImage: FocusedImage; }\n        action capturePhoto { in focusedImage: FocusedImage; out photo: Photo; }\n        action receivePhoto { in photo: Photo; }\n        \n        succession flow sceneSelectionFlow1 from selectScene.sceneSelection to requestScene.sceneSelection;\n        succession flow sceneSelectionFlow2 from requestScene.sceneSelection to provideScene.sceneSelection;\n        succession flow rawImageFlow from provideScene.rawImage to performFocusing.rawImage;\n        succession flow focusedImageFlow from performFocusing.focusedImage to capturePhoto.focusedImage;\n        succession flow photoFlow from capturePhoto.photo to receivePhoto.photo;\n    }\n}",
    "package 'PhotographySystem' {\n    attribute def Scene;\n    attribute def FocusedImage;\n    attribute def Photograph;\n    port def SceneSelectionPort {\n        out scene: Scene;\n    }\n    port def PhotographOutputPort {\n        out photograph: Photograph;\n    }\n    port def PhotographInputPort {\n        in photograph: Photograph;\n    }\n    part context {\n        part user {\n            port sceneSelectionPort: SceneSelectionPort;\n            port photographInputPort: ~PhotographInputPort;\n            perform photographyWorkflow.selectScene {\n                out scene = sceneSelectionPort.scene;\n            }\n            perform photographyWorkflow.receivePhotograph {\n                in photograph = photographInputPort.photograph;\n            }\n        }\n        interface userToSystem connect user.sceneSelectionPort to photographySystem.sceneSelectionPort {\n            ref flow references photographyWorkflow.sceneFlow\n                from source.scene to target.scene;\n        }\n        part photographySystem {\n            port sceneSelectionPort: ~SceneSelectionPort;\n            port photographOutputPort: PhotographOutputPort;\n            perform photographyWorkflow.focusing {\n                in scene = sceneSelectionPort.scene;\n                out focusedImage;\n            }\n            perform photographyWorkflow.shooting {\n                in focusedImage;\n                out photograph = photographOutputPort.photograph;\n            }\n        }\n        interface systemToUser connect photographySystem.photographOutputPort to user.photographInputPort {\n            ref flow references photographyWorkflow.photographFlow\n                from source.photograph to target.photograph;\n        }\n    }\n    action photographyWorkflow {\n        action selectScene { out scene: Scene; }\n        succession flow sceneFlow from selectScene.scene to focusing.scene;\n        action focusing { in scene: Scene; out focusedImage: FocusedImage; }\n        succession flow focusedImageFlow from focusing.focusedImage to shooting.focusedImage;\n        action shooting { in focusedImage: FocusedImage; out photograph: Photograph; }\n        succession flow photographFlow from shooting.photograph to receivePhotograph.photograph;\n        action receivePhotograph { in photograph: Photograph; }\n    }\n}",
    "package 'Photography System' {\n    attribute def Scene;\n    attribute def Image;\n    attribute def Photograph;\n    \n    port def ScenePort {\n        out scene: Scene;\n    }\n    port def ImagePort {\n        out image: Image;\n    }\n    port def PhotographPort {\n        out photograph: Photograph;\n    }\n    \n    part context {\n        part user {\n            port scenePort: ScenePort;\n            perform photographyWorkflow.selectScene {\n                out scene = scenePort.scene;\n            }\n        }\n        part system {\n            port scenePort: ~ScenePort;\n            port photographPort: PhotographPort;\n            perform photographyWorkflow.performFocusing {\n                in scene = scenePort.scene;\n                out image = imagePort.image;\n            }\n            port imagePort: ImagePort;\n            perform photographyWorkflow.carryOutShooting {\n                in image = imagePort.image;\n                out photograph = photographPort.photograph;\n            }\n        }\n        interface userToSystem connect user.scenePort to system.scenePort {\n            ref flow references photographyWorkflow.sceneFlow\n                from source.scene to target.scene;\n        }\n    }\n    \n    action photographyWorkflow {\n        action selectScene { out scene: Scene; }\n        action performFocusing { in scene: Scene; out image: Image; }\n        action carryOutShooting { in image: Image; out photograph: Photograph; }\n        \n        succession flow sceneFlow from selectScene.scene to performFocusing.scene;\n        succession flow imageFlow from performFocusing.image to carryOutShooting.image;\n    }\n}",
    "package 'AutomatedPhotographySystem' {\n    attribute def ShootingScene;\n    attribute def FocusedImage;\n    attribute def Photograph;\n    port def ScenePort {\n        in scene: ShootingScene;\n    }\n    port def PhotoPort {\n        out photo: Photograph;\n    }\n    part context {\n        part user {\n            port scenePort: ~ScenePort;\n            perform automatePhotography.provideScene {\n                out scene = scenePort.scene;\n            }\n            port photoPort: ~PhotoPort;\n            perform automatePhotography.receivePhotograph {\n                in photo = photoPort.photo;\n            }\n        }\n        interface sceneConnection connect user.scenePort to photographySystem.scenePort {\n            ref flow references automatePhotography.sceneFlow\n                from source.scene to target.scene;\n        }\n        interface photoConnection connect photographySystem.photoPort to user.photoPort {\n            ref flow references automatePhotography.photoFlow\n                from source.photo to target.photo;\n        }\n        part photographySystem {\n            port scenePort: ScenePort;\n            perform automatePhotography.performFocusProcessing {\n                in scene = scenePort.scene;\n                out focusedImage;\n            }\n            port photoPort: PhotoPort;\n            perform automatePhotography.performShootingOperation {\n                in focusedImage;\n                out photo = photoPort.photo;\n            }\n        }\n    }\n    action automatePhotography {\n        action provideScene { out scene: ShootingScene; }\n        succession flow sceneFlow from provideScene.scene to performFocusProcessing.scene;\n        action performFocusProcessing { in scene: ShootingScene; out focusedImage: FocusedImage; }\n        succession flow focusToShoot from performFocusProcessing.focusedImage to performShootingOperation.focusedImage;\n        action performShootingOperation { in focusedImage: FocusedImage; out photo: Photograph; }\n        succession flow photoFlow from performShootingOperation.photo to receivePhotograph.photo;\n        action receivePhotograph { in photo: Photograph; }\n    }\n}",
    "package 'PhotographyWorkflow' {\n    attribute def Scene;\n    attribute def Image;\n    attribute def Picture;\n    \n    port def ScenePort {\n        out scene: Scene;\n    }\n    port def PicturePort {\n        in picture: Picture;\n    }\n    \n    part context {\n        part user {\n            port scenePort: ScenePort;\n            port picturePort: ~PicturePort;\n            perform photographyProcess.provideScene {\n                out scene = scenePort.scene;\n            }\n            perform photographyProcess.receivePicture {\n                in picture = picturePort.picture;\n            }\n        }\n        \n        part photographyWorkflow {\n            port scenePort: ~ScenePort;\n            port picturePort: PicturePort;\n            perform photographyProcess.focus {\n                in scene = scenePort.scene;\n                out image;\n            }\n            perform photographyProcess.shoot {\n                in image;\n                out picture = picturePort.picture;\n            }\n        }\n        \n        interface userToWorkflow connect user.scenePort to photographyWorkflow.scenePort {\n            ref flow references photographyProcess.sceneFlow\n                from source.scene to target.scene;\n        }\n        \n        interface workflowToUser connect photographyWorkflow.picturePort to user.picturePort {\n            ref flow references photographyProcess.pictureFlow\n                from source.picture to target.picture;\n        }\n    }\n    \n    action photographyProcess {\n        action provideScene { out scene: Scene; }\n        action focus { in scene: Scene; out image: Image; }\n        action shoot { in image: Image; out picture: Picture; }\n        action receivePicture { in picture: Picture; }\n        \n        succession flow sceneFlow from provideScene.scene to focus.scene;\n        succession flow imageFlow from focus.image to shoot.image;\n        succession flow pictureFlow from shoot.picture to receivePicture.picture;\n    }\n}",
    "package 'PhotographySystem' {\n    attribute def ShootCommand;\n    attribute def FocusStatus;\n    attribute def Image;\n    \n    port def ShootCommandPort {\n        out shootCommand: ShootCommand;\n    }\n    port def ImagePort {\n        out image: Image;\n    }\n    \n    part context {\n        part user {\n            port shootCommandPort: ShootCommandPort;\n            perform photographyWorkflow.sendShootCommand {\n                out shootCommand = shootCommandPort.shootCommand;\n            }\n        }\n        part camera {\n            port shootCommandPort: ~ShootCommandPort;\n            port imagePort: ImagePort;\n            perform photographyWorkflow.cameraCapture {\n                in shootCommand = shootCommandPort.shootCommand;\n                out image = imagePort.image;\n            }\n        }\n        interface userToCamera connect user.shootCommandPort to camera.shootCommandPort {\n            ref flow references photographyWorkflow.commandFlow \n                from source.shootCommand to target.shootCommand;\n        }\n    }\n    \n    action photographyWorkflow {\n        action sendShootCommand {\n            out shootCommand: ShootCommand;\n        }\n        action cameraCapture {\n            in shootCommand: ShootCommand;\n            out image: Image;\n            \n            action focusScene {\n                out focusStatus: FocusStatus;\n            }\n            action takePhoto {\n                out image: Image;\n            }\n            succession from focusScene to takePhoto when (focusStatus == 'clear');\n            out image = takePhoto.image;\n        }\n        succession flow commandFlow from sendShootCommand.shootCommand to cameraCapture.shootCommand;\n    }\n}",
    "package 'PhotographySystem' {\n    attribute def Scene;\n    attribute def FocusedScene;\n    attribute def Image;\n    attribute def Photo;\n    attribute def FocusQuality;\n    \n    action capturePhotoWorkflow {\n        out photo: Photo;\n        \n        action selectScene {\n            out scene: Scene;\n        }\n        \n        action performFocusing {\n            in scene: Scene;\n            out focusedScene: FocusedScene;\n        }\n        \n        action generateImage {\n            in focusedScene: FocusedScene;\n            out image: Image;\n        }\n        \n        action evaluateFocusQuality {\n            in image: Image;\n            out focusQuality: FocusQuality;\n        }\n        \n        action shoot {\n            in image: Image;\n            out photo: Photo;\n        }\n        \n        succession flow sceneFlow from selectScene to performFocusing;\n        flow sceneData from selectScene.scene to performFocusing.scene;\n        \n        succession flow focusFlow from performFocusing to generateImage;\n        flow focusedSceneData from performFocusing.focusedScene to generateImage.focusedScene;\n        \n        succession flow imageGenFlow from generateImage to evaluateFocusQuality;\n        flow imageData from generateImage.image to evaluateFocusQuality.image;\n        \n        succession flow evalToShoot from evaluateFocusQuality to shoot \n            when \"evaluateFocusQuality.focusQuality = 'good'\";\n        flow shootImageData from generateImage.image to shoot.image;\n        \n        flow photoOutput from shoot.photo to capturePhotoWorkflow.photo;\n    }\n}",
    "package 'PhotographyWorkflow' {\n    attribute def Trigger;\n    attribute def Scene;\n    attribute def Image;\n    attribute def Photo;\n    \n    port def TriggerPort {\n        out trigger: Trigger;\n    }\n    \n    port def PhotoPort {\n        out photo: Photo;\n    }\n    \n    part context {\n        part user {\n            port triggerPort: TriggerPort;\n            perform takePhotoWorkflow.sendTrigger {\n                out trigger = triggerPort.trigger;\n            }\n        }\n        \n        part cameraSystem {\n            port triggerPort: ~TriggerPort;\n            port photoPort: PhotoPort;\n            perform takePhotoWorkflow.receiveTrigger {\n                in trigger = triggerPort.trigger;\n            }\n            perform takePhotoWorkflow.acquireScene {\n                out scene;\n            }\n            perform takePhotoWorkflow.autoFocus {\n                in scene;\n                out image;\n            }\n            perform takePhotoWorkflow.shoot {\n                in image;\n                out photo = photoPort.photo;\n            }\n        }\n        \n        part display {\n            port photoPort: ~PhotoPort;\n            perform takePhotoWorkflow.displayPhoto {\n                in photo = photoPort.photo;\n            }\n        }\n        \n        interface userToCamera connect user.triggerPort to cameraSystem.triggerPort {\n            ref flow references takePhotoWorkflow.triggerFlow\n                from source.trigger to target.trigger;\n        }\n        \n        interface cameraToDisplay connect cameraSystem.photoPort to display.photoPort {\n            ref flow references takePhotoWorkflow.photoFlow\n                from source.photo to target.photo;\n        }\n    }\n    \n    action takePhotoWorkflow {\n        action sendTrigger { out trigger: Trigger; }\n        action receiveTrigger { in trigger: Trigger; }\n        succession flow triggerFlow from sendTrigger.trigger to receiveTrigger.trigger;\n        succession startFlow from receiveTrigger to acquireScene;\n        action acquireScene { out scene: Scene; }\n        action autoFocus { in scene; out image: Image; }\n        succession flow sceneFlow from acquireScene.scene to autoFocus.scene;\n        action shoot { in image; out photo: Photo; }\n        succession flow imageFlow from autoFocus.image to shoot.image;\n        action displayPhoto { in photo; }\n        succession flow photoFlow from shoot.photo to displayPhoto.photo;\n    }\n}",
    "package 'Automatic Braking System' {\n    attribute def ActivationCmd;\n    attribute def BrakePedalStatus;\n    attribute def TractionInfo;\n    attribute def BrakePressure;\n    attribute def ModulationFrequency;\n    attribute def BrakeControl {\n        pressure: BrakePressure;\n        frequency: ModulationFrequency;\n    }\n    port def ActivationPort {\n        out activationCmd: ActivationCmd;\n    }\n    port def BrakePedalPort {\n        out brakePedalStatus: BrakePedalStatus;\n    }\n    port def TractionPort {\n        out tractionInfo: TractionInfo;\n    }\n    port def BrakeControlPort {\n        out brakeControl: BrakeControl;\n    }\n    part context {\n        part user {\n            port activationPort: ActivationPort;\n            perform brakingControl.sendActivation {\n                out activationCmd = activationPort.activationCmd;\n            }\n        }\n        part driver {\n            port brakePedalPort: BrakePedalPort;\n            perform brakingControl.provideBrakeInput {\n                out brakePedalStatus = brakePedalPort.brakePedalStatus;\n            }\n        }\n        part tractionSensor {\n            port tractionPort: TractionPort;\n            perform brakingControl.provideTractionData {\n                out tractionInfo = tractionPort.tractionInfo;\n            }\n        }\n        part brakeActuator {\n            port brakeControlPort: ~BrakeControlPort;\n            perform brakingControl.applyBrakeAdjustment {\n                in brakeControl = brakeControlPort.brakeControl;\n            }\n        }\n        interface userToSystem connect user.activationPort to abs.activationPort;\n        interface driverToSystem connect driver.brakePedalPort to abs.brakePedalPort;\n        interface sensorToSystem connect tractionSensor.tractionPort to abs.tractionPort;\n        interface systemToActuator connect abs.brakeControlPort to brakeActuator.brakeControlPort;\n        part abs {\n            port activationPort: ~ActivationPort;\n            port brakePedalPort: ~BrakePedalPort;\n            port tractionPort: ~TractionPort;\n            port brakeControlPort: BrakeControlPort;\n            perform brakingControl {\n                in activationCmd = activationPort.activationCmd;\n                in brakePedalStatus = brakePedalPort.brakePedalStatus;\n                in tractionInfo = tractionPort.tractionInfo;\n                out brakeControl = brakeControlPort.brakeControl;\n            }\n        }\n    }\n    action brakingControl {\n        in activationCmd: ActivationCmd;\n        in brakePedalStatus: BrakePedalStatus;\n        in tractionInfo: TractionInfo;\n        out brakeControl: BrakeControl;\n        action activateSystem {\n            in activationCmd;\n        }\n        action monitorAndAdjust: loop {\n            action monitorInputs {\n                out currentBrakeStatus: BrakePedalStatus;\n                out currentTraction: TractionInfo;\n            }\n            action evaluateConditions {\n                in currentBrakeStatus;\n                in currentTraction;\n                out reqPressure: BrakePressure;\n                out reqFrequency: ModulationFrequency;\n            }\n            action adjustBraking {\n                in reqPressure;\n                in reqFrequency;\n                out brakeControl: BrakeControl;\n            }\n            flow from monitorInputs.currentBrakeStatus to evaluateConditions.currentBrakeStatus;\n            flow from monitorInputs.currentTraction to evaluateConditions.currentTraction;\n            flow from evaluateConditions.reqPressure to adjustBraking.reqPressure;\n            flow from evaluateConditions.reqFrequency to adjustBraking.reqFrequency;\n            flow from adjustBraking.brakeControl to brakeControl;\n        }\n        bind monitorInputs.currentBrakeStatus = brakePedalStatus;\n        bind monitorInputs.currentTraction = tractionInfo;\n        succession from activateSystem to monitorAndAdjust;\n    }\n}",
    "package 'BatteryChargingSystem' {\n    attribute def BatteryLevel;\n    attribute def ChargeCmd;\n    port def BatteryLevelPort {\n        out level: BatteryLevel;\n    }\n    port def ChargeCmdPort {\n        out cmd: ChargeCmd;\n    }\n    part context {\n        part battery {\n            port levelPort: BatteryLevelPort;\n            perform chargingProcess.senseBattery {\n                out level = levelPort.level;\n            }\n            port chargeCmdPort: ~ChargeCmdPort;\n            perform chargingProcess.actuateCharge {\n                in cmd = chargeCmdPort.cmd;\n            }\n        }\n        part controller {\n            port levelPort: ~BatteryLevelPort;\n            perform chargingProcess.monitor {\n                in level = levelPort.level;\n            }\n            port chargeCmdPort: ChargeCmdPort;\n            perform chargingProcess.control {\n                out cmd = chargeCmdPort.cmd;\n            }\n        }\n        interface batteryToController connect battery.levelPort to controller.levelPort {\n            ref flow references chargingProcess.levelFlow\n                from source.level to target.level;\n        }\n        interface controllerToBattery connect controller.chargeCmdPort to battery.chargeCmdPort {\n            ref flow references chargingProcess.cmdFlow\n                from source.cmd to target.cmd;\n        }\n    }\n    action chargingProcess {\n        action senseBattery { out level: BatteryLevel; }\n        action monitor { in level: BatteryLevel; }\n        succession flow levelFlow from senseBattery.level to monitor.level;\n        action control { in level: BatteryLevel; out cmd: ChargeCmd; }\n        succession flow controlFlow from monitor.level to control.level;\n        action actuateCharge { in cmd: ChargeCmd; }\n        succession flow cmdFlow from control.cmd to actuateCharge.cmd;\n    }\n}",
    "package 'BatteryChargingSystem' {\n    attribute def BatteryLevel;\n    attribute def ChargingCmd;\n    port def BatteryLevelPort {\n        out level: BatteryLevel;\n    }\n    port def ChargingControlPort {\n        in cmd: ChargingCmd;\n    }\n    part context {\n        part chargingController {\n            port batteryLevelPort: ~BatteryLevelPort;\n            port chargingControlPort: ChargingControlPort;\n            perform chargingProcess.monitorLevel {\n                in level = batteryLevelPort.level;\n                out cmd = chargingControlPort.cmd;\n            }\n        }\n        part battery {\n            port batteryLevelPort: BatteryLevelPort;\n            port chargingControlPort: ~ChargingControlPort;\n            attribute level: BatteryLevel;\n        }\n        interface levelInterface connect chargingController.batteryLevelPort to battery.batteryLevelPort;\n        interface controlInterface connect chargingController.chargingControlPort to battery.chargingControlPort;\n    }\n    action chargingProcess {\n        action monitorLevel { in level: BatteryLevel; out cmd: ChargingCmd; }\n        action checkLevel { in level: BatteryLevel; out condition: Boolean = level < 100; }\n        action replenish { out cmd: ChargingCmd; }\n        action terminate;\n        succession from monitorLevel.level to checkLevel.level;\n        succession from checkLevel to replenish when checkLevel.condition == true;\n        succession from checkLevel to terminate when checkLevel.condition == false;\n        succession from replenish to monitorLevel;\n    }\n}",
    "package 'Camera System' {\n    attribute def SceneSelection;\n    attribute def FocusedImage;\n    attribute def Photo;\n    port def UserCmdPort {\n        out sceneSelection : SceneSelection;\n    }\n    port def PhotoPort {\n        out photo: Photo;\n    }\n    part context {\n        part user {\n            port userCmdPort: UserCmdPort;\n            perform photoCapture.selectScene {\n                out sceneSelection = userCmdPort.sceneSelection;\n            }\n        }\n        interface userToCamera connect user.userCmdPort to camera.userCmdPort {\n            ref flow references photoCapture.sceneSelectionFlow\n                from source.sceneSelection to target.sceneSelection;\n        }\n        part camera {\n            port userCmdPort: ~UserCmdPort;\n            part autofocus {\n                perform photoCapture.performAutofocus {\n                    in sceneSelection = userCmdPort.sceneSelection;\n                    out focusedImage = focusedImagePort.focusedImage;\n                }\n                port focusedImagePort: FocusedImagePort;\n            }\n            part imaging {\n                port focusedImagePort: ~FocusedImagePort;\n                perform photoCapture.captureImage {\n                    in focusedImage = focusedImagePort.focusedImage;\n                    out photo = photoPort.photo;\n                }\n                port photoPort: PhotoPort;\n            }\n            interface autofocusToImaging connect autofocus.focusedImagePort to imaging.focusedImagePort {\n                ref flow references photoCapture.focusedImageFlow\n                    from source.focusedImage to target.focusedImage;\n            }\n        }\n        part storage {\n            port photoPort: ~PhotoPort;\n            perform photoCapture.savePhoto {\n                in photo = photoPort.photo;\n            }\n        }\n        interface cameraToStorage connect camera.imaging.photoPort to storage.photoPort {\n            ref flow references photoCapture.photoFlow\n                from source.photo to target.photo;\n        }\n    }\n    port def FocusedImagePort {\n        out focusedImage: FocusedImage;\n    }\n    action photoCapture {\n        action selectScene { out sceneSelection: SceneSelection; }\n        action performAutofocus { in sceneSelection; out focusedImage: FocusedImage; }\n        action captureImage { in focusedImage; out photo: Photo; }\n        action savePhoto { in photo: Photo; }\n        succession flow sceneSelectionFlow from selectScene.sceneSelection to performAutofocus.sceneSelection;\n        succession flow focusedImageFlow from performAutofocus.focusedImage to captureImage.focusedImage;\n        succession flow photoFlow from captureImage.photo to savePhoto.photo;\n    }\n}",
    "package 'CameraSystem' {\n    attribute def SceneSelection;\n    attribute def Focus;\n    attribute def Photo;\n\n    port def SceneSelectionPort {\n        out sceneSelection: SceneSelection;\n    }\n    port def FocusPort {\n        out focus: Focus;\n    }\n    port def PhotoPort {\n        out photo: Photo;\n    }\n\n    part context {\n        part user {\n            port sceneSelectionPort: SceneSelectionPort;\n            perform shootingProcess.selectScene {\n                out sceneSelection = sceneSelectionPort.sceneSelection;\n            }\n        }\n\n        part camera {\n            port sceneSelectionPort: ~SceneSelectionPort;\n            port cameraPhotoPort: PhotoPort;\n\n            part autoFocusModule {\n                port sceneSelectionPort: ~SceneSelectionPort;\n                port focusPort: FocusPort;\n                perform shootingProcess.autoFocus {\n                    in sceneSelection = sceneSelectionPort.sceneSelection;\n                    out focus = focusPort.focus;\n                }\n            }\n\n            part imagingModule {\n                port focusPort: ~FocusPort;\n                port photoPort: PhotoPort;\n                perform shootingProcess.captureImage {\n                    in focus = focusPort.focus;\n                    out photo = photoPort.photo;\n                }\n            }\n\n            interface sceneInternalConnect connect sceneSelectionPort to autoFocusModule.sceneSelectionPort {\n                ref flow references shootingProcess.sceneFlow\n                    from source.sceneSelection to target.sceneSelection;\n            }\n\n            interface focusInternalConnect connect autoFocusModule.focusPort to imagingModule.focusPort {\n                ref flow references shootingProcess.focusFlow\n                    from source.focus to target.focus;\n            }\n\n            interface photoInternalConnect connect imagingModule.photoPort to cameraPhotoPort {\n                ref flow references shootingProcess.photoFlow\n                    from source.photo to target.photo;\n            }\n        }\n\n        interface userToCamera connect user.sceneSelectionPort to camera.sceneSelectionPort {\n            ref flow references shootingProcess.sceneFlow\n                from source.sceneSelection to target.sceneSelection;\n        }\n    }\n\n    action shootingProcess {\n        action selectScene {\n            out sceneSelection: SceneSelection;\n        }\n        action autoFocus {\n            in sceneSelection: SceneSelection;\n            out focus: Focus;\n        }\n        action captureImage {\n            in focus: Focus;\n            out photo: Photo;\n        }\n        out finalPhoto: Photo;\n\n        succession flow sceneFlow from selectScene.sceneSelection to autoFocus.sceneSelection;\n        succession flow focusFlow from autoFocus.focus to captureImage.focus;\n        succession flow photoFlow from captureImage.photo to finalPhoto;\n    }\n}",
    "package 'VehicleSimulation' {\n    attribute def Mass;\n    attribute def Position;\n    attribute def Velocity;\n    attribute def TimeStep;\n    attribute def Power;\n    attribute def Trajectory;\n    \n    port def InputPort {\n        out mass: Mass;\n        out initialPosition: Position;\n        out initialVelocity: Velocity;\n        out timeStep: TimeStep;\n        out powerSequence: Power[*];\n    }\n    \n    port def OutputPort {\n        out trajectory: Trajectory;\n    }\n    \n    part context {\n        part user {\n            port inputPort: InputPort;\n            perform motionSimulation.provideInputs {\n                out mass = inputPort.mass;\n                out initialPosition = inputPort.initialPosition;\n                out initialVelocity = inputPort.initialVelocity;\n                out timeStep = inputPort.timeStep;\n                out powerSequence = inputPort.powerSequence;\n            }\n            port outputPort: ~OutputPort;\n            perform motionSimulation.receiveTrajectory {\n                in trajectory = outputPort.trajectory;\n            }\n        }\n        \n        part simulator {\n            port inputPort: ~InputPort;\n            perform motionSimulation.calculateMotion {\n                in mass = inputPort.mass;\n                in initialPosition = inputPort.initialPosition;\n                in initialVelocity = inputPort.initialVelocity;\n                in timeStep = inputPort.timeStep;\n                in powerSequence = inputPort.powerSequence;\n                out trajectory = outputPort.trajectory;\n            }\n            port outputPort: OutputPort;\n        }\n        \n        interface inputConnection connect user.inputPort to simulator.inputPort {\n            ref flow references motionSimulation.inputFlow \n                from source.mass to target.mass,\n                from source.initialPosition to target.initialPosition,\n                from source.initialVelocity to target.initialVelocity,\n                from source.timeStep to target.timeStep,\n                from source.powerSequence to target.powerSequence;\n        }\n        \n        interface outputConnection connect simulator.outputPort to user.outputPort {\n            ref flow references motionSimulation.trajectoryFlow \n                from source.trajectory to target.trajectory;\n        }\n    }\n    \n    action motionSimulation {\n        action provideInputs {\n            out mass: Mass;\n            out initialPosition: Position;\n            out initialVelocity: Velocity;\n            out timeStep: TimeStep;\n            out powerSequence: Power[*];\n        }\n        \n        action calculateMotion {\n            in mass: Mass;\n            in initialPosition: Position;\n            in initialVelocity: Velocity;\n            in timeStep: TimeStep;\n            in powerSequence: Power[*];\n            out trajectory: Trajectory;\n        }\n        \n        action receiveTrajectory {\n            in trajectory: Trajectory;\n        }\n        \n        succession flow inputFlow from provideInputs to calculateMotion\n            for mass, initialPosition, initialVelocity, timeStep, powerSequence;\n        \n        succession flow trajectoryFlow from calculateMotion.trajectory to receiveTrajectory.trajectory;\n    }\n}",
    "package 'CameraSystem' {\n    attribute def Scene;\n    attribute def Image;\n    attribute def Photo;\n    port def UserInputPort {\n        out scene: Scene;\n    }\n    port def DisplayPort {\n        out photo: Photo;\n    }\n    part context {\n        part user {\n            port userInputPort: UserInputPort;\n            perform shootAndDisplay.inputScene {\n                out scene = userInputPort.scene;\n            }\n        }\n        interface userToCamera connect user.userInputPort to cameraSystem.userInputPort {\n            ref flow references shootAndDisplay.sceneFlow \n                from source.scene to target.scene;\n        }\n        part cameraSystem {\n            port userInputPort: ~UserInputPort;\n            perform shootAndDisplay.focus {\n                in scene = userInputPort.scene;\n            }\n            perform shootAndDisplay.capture {\n                out photo = displayPort.photo;\n            }\n            port displayPort: DisplayPort;\n        }\n        part screen {\n            port displayPort: ~DisplayPort;\n            perform shootAndDisplay.displayPhoto {\n                in photo = displayPort.photo;\n            }\n        }\n        interface cameraToScreen connect cameraSystem.displayPort to screen.displayPort {\n            ref flow references shootAndDisplay.photoFlow \n                from source.photo to target.photo;\n        }\n    }\n    action shootAndDisplay {\n        action inputScene { out scene: Scene; }\n        succession flow sceneFlow from inputScene.scene to focus.scene;\n        action focus { in scene: Scene; out image: Image; }\n        succession flow imageFlow from focus.image to capture.image;\n        action capture { in image: Image; out photo: Photo; }\n        succession flow photoFlow from capture.photo to displayPhoto.photo;\n        action displayPhoto { in photo: Photo; }\n    }\n}",
    "package 'CameraSystem' {\n    attribute def Scene;\n    attribute def Image;\n    attribute def Picture;\n    \n    port def ScenePort {\n        out scene: Scene;\n    }\n    port def PicturePort {\n        out picture: Picture;\n    }\n    \n    part context {\n        part user {\n            port scenePort: ScenePort;\n            perform photoWorkflow.selectScene {\n                out scene = scenePort.scene;\n            }\n        }\n        part camera {\n            port scenePort: ~ScenePort;\n            port displayPort: PicturePort;\n            perform photoWorkflow.focus {\n                in scene = scenePort.scene;\n                out image;\n            }\n            perform photoWorkflow.capture {\n                in image;\n                out picture = displayPort.picture;\n            }\n        }\n        part display {\n            port displayPort: ~PicturePort;\n            perform photoWorkflow.showPhoto {\n                in picture = displayPort.picture;\n            }\n        }\n        \n        interface userToCamera connect user.scenePort to camera.scenePort {\n            ref flow references photoWorkflow.sceneFlow\n                from source.scene to target.scene;\n        }\n        interface cameraToDisplay connect camera.displayPort to display.displayPort {\n            ref flow references photoWorkflow.pictureFlow\n                from source.picture to target.picture;\n        }\n    }\n    \n    action photoWorkflow {\n        action selectScene { out scene: Scene; }\n        action focus { in scene: Scene; out image: Image; }\n        action capture { in image: Image; out picture: Picture; }\n        action showPhoto { in picture: Picture; }\n        \n        succession flow sceneFlow from selectScene.scene to focus.scene;\n        succession flow imageFlow from focus.image to capture.image;\n        succession flow pictureFlow from capture.picture to showPhoto.picture;\n    }\n}",
    "package 'SensorManagementSystem' {\n    attribute def Status: enumeration { ready, notReady, updating };\n    attribute def UpdateCmd;\n    \n    port def StatusPort {\n        out status: Status;\n    }\n    port def UpdatePort {\n        in updateCmd: UpdateCmd;\n    }\n    \n    part def Sensor {\n        port statusPort: StatusPort;\n        port updatePort: UpdatePort;\n    }\n    \n    part context {\n        part manager {\n            perform manageSensors.traverseSensors;\n        }\n        part sensors: Sensor[1..*];\n    }\n    \n    action manageSensors {\n        action traverseSensors {\n            loop for sensor in context.sensors {\n                action monitorSensor {\n                    out status: Status;\n                }\n                flow statusFlow from sensor.statusPort.status to monitorSensor.status;\n                \n                action checkReady {\n                    in status: Status;\n                    out isReady: Boolean;\n                    condition isReady: status == Status::ready;\n                }\n                succession from monitorSensor to checkReady;\n                \n                action updateSensor {\n                    out updateCmd: UpdateCmd;\n                }\n                conditional if checkReady.isReady then updateSensor;\n                \n                flow updateFlow from updateSensor.updateCmd to sensor.updatePort.updateCmd;\n            }\n        }\n    }\n}",
    "package 'VehicleStateManagement' {\n    event def vehicleStartSignal;\n    event def vehiclePowerOnSignal;\n    event def vehicleShutdownSignal;\n    \n    stateMachine def VehicleStateMachine {\n        state off;\n        state starting;\n        state on;\n        \n        initial -> off;\n        \n        transition from off to starting on vehicleStartSignal;\n        transition from starting to on on vehiclePowerOnSignal;\n        transition from off to off on vehicleShutdownSignal;\n        transition from starting to off on vehicleShutdownSignal;\n        transition from on to off on vehicleShutdownSignal;\n    }\n}",
    "package 'VehicleStateManagement' {\n    event def VehicleStartSignal;\n    event def VehicleOnSignal;\n    event def VehicleOffSignal;\n    state def Off: initial;\n    state def Starting;\n    state def On;\n    state machine def VehicleStateMachine {\n        state off: Off;\n        state starting: Starting;\n        state on: On;\n        transition t1: off -> starting on VehicleStartSignal;\n        transition t2: starting -> on on VehicleOnSignal;\n        transition t3: on -> off on VehicleOffSignal;\n    }\n    part def Vehicle {\n        behavior stateMachine: VehicleStateMachine;\n    }\n    part context {\n        part vehicle: Vehicle;\n        part controller {\n            port signalPort: ~SignalPort;\n        }\n        interface controlInterface connect controller.signalPort to vehicle.signalPort;\n    }\n    port def SignalPort {\n        in startSignal: VehicleStartSignal?;\n        in onSignal: VehicleOnSignal?;\n        in offSignal: VehicleOffSignal?;\n    }\n}",
    "package 'VehiclePowerManagement' {\n    event def VehicleStartCommand;\n    event def VehicleStartedSignal;\n    event def VehicleShutdownCommand;\n    action def SelfDiagnosis;\n    action def SupplyPower;\n    action def EngageParkingBrake;\n    \n    port def UserCommandPort {\n        out vehicleStartCommand: VehicleStartCommand;\n        out vehicleShutdownCommand: VehicleShutdownCommand;\n    }\n    port def VehicleSignalPort {\n        out vehicleStartedSignal: VehicleStartedSignal;\n    }\n    port def SystemCommandPort {\n        in vehicleStartCommand: VehicleStartCommand;\n        in vehicleShutdownCommand: VehicleShutdownCommand;\n    }\n    port def SystemSignalPort {\n        in vehicleStartedSignal: VehicleStartedSignal;\n    }\n    port def SystemControlPort {\n        out engageParkingBrake: EngageParkingBrake;\n    }\n    \n    part def PowerManagementSystem {\n        port systemCommandPort: SystemCommandPort;\n        port systemSignalPort: SystemSignalPort;\n        port systemControlPort: SystemControlPort;\n        \n        state machine {\n            initial state Off;\n            state StartPhase;\n            state PoweredOn {\n                do SelfDiagnosis;\n                do SupplyPower;\n            }\n            \n            transition from Off to StartPhase on systemCommandPort.vehicleStartCommand;\n            transition from StartPhase to PoweredOn on systemSignalPort.vehicleStartedSignal;\n            transition from PoweredOn to Off on systemCommandPort.vehicleShutdownCommand {\n                effect EngageParkingBrake;\n            }\n        }\n    }\n    \n    part context {\n        part user {\n            port userCommandPort: UserCommandPort;\n        }\n        part vehicle {\n            port vehicleSignalPort: VehicleSignalPort;\n        }\n        part powerManagementSystem: PowerManagementSystem;\n        \n        interface userToSystem connect user.userCommandPort to powerManagementSystem.systemCommandPort {\n            ref flow startCmdFlow from source.vehicleStartCommand to target.vehicleStartCommand;\n            ref flow shutdownCmdFlow from source.vehicleShutdownCommand to target.vehicleShutdownCommand;\n        }\n        interface vehicleToSystem connect vehicle.vehicleSignalPort to powerManagementSystem.systemSignalPort {\n            ref flow startedSignalFlow from source.vehicleStartedSignal to target.vehicleStartedSignal;\n        }\n        interface systemToVehicle connect powerManagementSystem.systemControlPort to vehicle.vehicleControlPort {\n            ref flow brakeEngageFlow from source.engageParkingBrake to target.engageParkingBrake;\n        }\n    }\n}",
    "package 'Vehicle Management' {\n    attribute def VehicleStartSignal;\n    attribute def VehicleStartedSignal;\n    attribute def VehicleShutdownSignal;\n    state def Shutdown;\n    state def StartUp;\n    state def Running;\n    port def UserCommandPort {\n        in vehicleStartSignal: VehicleStartSignal;\n        in vehicleShutdownSignal: VehicleShutdownSignal;\n    }\n    port def VehicleStatusPort {\n        in vehicleStartedSignal: VehicleStartedSignal;\n    }\n    part def VehicleManagementSystem {\n        port userCommandPort: UserCommandPort;\n        port vehicleStatusPort: VehicleStatusPort;\n        stateMachine VehicleStateMachine {\n            initial Shutdown;\n            state StartUp;\n            state Running;\n            transition from Shutdown to StartUp {\n                trigger on userCommandPort.vehicleStartSignal;\n            }\n            transition from StartUp to Running {\n                trigger on vehicleStatusPort.vehicleStartedSignal;\n            }\n            transition from Running to Shutdown {\n                trigger on userCommandPort.vehicleShutdownSignal;\n            }\n        }\n    }\n    part context {\n        part user {\n            port userCommandPort: ~UserCommandPort;\n        }\n        part vehicle {\n            port vehicleStatusPort: ~VehicleStatusPort;\n        }\n        part system: VehicleManagementSystem;\n        interface userToSystem connect user.userCommandPort to system.userCommandPort;\n        interface vehicleToSystem connect vehicle.vehicleStatusPort to system.vehicleStatusPort;\n    }\n}",
    "package 'Power Management' {\n    attribute def StartSignal;\n    attribute def OnSignal;\n    attribute def OffSignal;\n    attribute def HealthStatus;\n    \n    port def ControlPort {\n        out startSignal: StartSignal[0..1];\n        out onSignal: OnSignal[0..1];\n        out offSignal: OffSignal[0..1];\n    }\n    \n    port def VehiclePort {\n        in control: ~ControlPort;\n        out healthStatus: HealthStatus;\n    }\n    \n    part context {\n        part user {\n            port controlPort: ControlPort;\n            perform sendSignal {\n                out controlPort.startSignal = new StartSignal;\n                out controlPort.onSignal = new OnSignal;\n                out controlPort.offSignal = new OffSignal;\n            }\n        }\n        \n        part vehicle {\n            port vehiclePort: VehiclePort;\n            \n            state def OperatingState {\n                initial state Off;\n                state Start;\n                state On;\n                \n                transition from Off to Start on vehiclePort.control.startSignal;\n                transition from Start to On on vehiclePort.control.onSignal;\n                transition from On to Off on vehiclePort.control.offSignal;\n            }\n            \n            action def HealthStateManagement {\n                out vehiclePort.healthStatus;\n            }\n        }\n        \n        interface userToVehicle connect user.controlPort to vehicle.vehiclePort.control;\n    }\n}",
    "package 'Vehicle Health Monitoring System' {\n    attribute def Temperature;\n    attribute def MaxAllowableTemperature;\n    attribute def VehicleHealthStatus: enum { normal, degraded, maintenance };\n    attribute def OverTemperatureWarning;\n    attribute def CurrentTime;\n    attribute def MaintenanceCycleTime;\n    attribute def MaintenanceDuration;\n    \n    port def TimePort {\n        in currentTime: CurrentTime;\n    }\n    port def TempSensorPort {\n        in currentTemp: Temperature;\n    }\n    port def WarningPort {\n        out warning: OverTemperatureWarning;\n    }\n    port def StatusPort {\n        inout status: VehicleHealthStatus;\n    }\n    port def CyclePort {\n        inout nextCycle: MaintenanceCycleTime;\n    }\n    \n    part context {\n        part healthMonitor {\n            port timePort: ~TimePort;\n            port tempPort: ~TempSensorPort;\n            port warningPort: WarningPort;\n            port statusPort: StatusPort;\n            port cyclePort: CyclePort;\n            attribute maxTemp: MaxAllowableTemperature;\n            attribute maintenanceStart: CurrentTime?;\n            \n            perform manageHealth.monitorTemperature;\n            perform manageHealth.checkMaintenance;\n        }\n        \n        part clock {\n            port timePort: TimePort;\n        }\n        \n        part tempSensor {\n            port tempPort: TempSensorPort;\n        }\n        \n        part controller {\n            port warningPort: ~WarningPort;\n        }\n        \n        part statusManager {\n            port statusPort: ~StatusPort;\n        }\n        \n        part scheduler {\n            port cyclePort: ~CyclePort;\n        }\n        \n        interface timeFlow connect clock.timePort to healthMonitor.timePort;\n        interface tempFlow connect tempSensor.tempPort to healthMonitor.tempPort;\n        interface warningFlow connect healthMonitor.warningPort to controller.warningPort;\n        interface statusFlow connect healthMonitor.statusPort to statusManager.statusPort;\n        interface cycleFlow connect healthMonitor.cyclePort to scheduler.cyclePort;\n    }\n    \n    action manageHealth {\n        action monitorTemperature {\n            in currentTemp: Temperature;\n            in maxTemp: MaxAllowableTemperature;\n            inout status: VehicleHealthStatus;\n            out warning: OverTemperatureWarning?;\n        }\n        \n        action checkMaintenance {\n            in currentTime: CurrentTime;\n            inout status: VehicleHealthStatus;\n            inout nextCycle: MaintenanceCycleTime;\n            inout maintenanceStart: CurrentTime?;\n            const maintenanceDuration: MaintenanceDuration = 48h;\n        }\n        \n        action updateMaintenanceCycle {\n            in currentTime: CurrentTime;\n            inout nextCycle: MaintenanceCycleTime;\n        }\n        \n        succession flow tempFlow from monitorTemperature to checkMaintenance;\n    }\n}",
    "package 'ServerSystem' {\n    enum CommandKind {\n        Start;\n        Request;\n    }\n    signal CommandSignal {\n        attribute kind: CommandKind;\n    }\n    port def RequestPort {\n        in command: CommandSignal;\n    }\n    part def Server {\n        port requestPort: RequestPort;\n        state machine {\n            initial off;\n            state off;\n            composite state operational {\n                initial waiting;\n                state waiting;\n                state response;\n                transition from waiting to response on requestPort.command(kind=CommandKind.Request);\n                transition from response to waiting after 5 min;\n            }\n            transition from off to operational on requestPort.command(kind=CommandKind.Start);\n            transition from operational to off on periodic(1 day, Time(11,59,0));\n        }\n    }\n}",
    "package 'VehicleStartStopSystem' {\n    attribute def StartSignal;\n    attribute def PowerOnSignal;\n    attribute def StopSignal;\n    attribute def BrakeDepressed;\n    attribute def StartSignalToController;\n    attribute def ApplyParkingBrake;\n    \n    port def DriverPort {\n        in startSignal: StartSignal;\n        in powerOnSignal: PowerOnSignal;\n        in stopSignal: StopSignal;\n    }\n    port def BrakeSensorPort {\n        in brakeDepressed: BrakeDepressed;\n    }\n    port def ControllerPort {\n        out startSignalToController: StartSignalToController;\n    }\n    port def BrakeActuatorPort {\n        out applyParkingBrake: ApplyParkingBrake;\n    }\n    \n    part context {\n        part driver {\n            port driverPort: DriverPort;\n            perform startStopProcess.driverInput {\n                out startSignal = driverPort.startSignal;\n                out powerOnSignal = driverPort.powerOnSignal;\n                out stopSignal = driverPort.stopSignal;\n            }\n        }\n        part brakePedal {\n            port brakeSensorPort: BrakeSensorPort;\n            perform startStopProcess.senseBrake {\n                out brakeDepressed = brakeSensorPort.brakeDepressed;\n            }\n        }\n        part controller {\n            port controllerPort: ~ControllerPort;\n            perform startStopProcess.receiveStartSignal {\n                in startSignalToController = controllerPort.startSignalToController;\n            }\n        }\n        part brakeActuator {\n            port brakeActuatorPort: ~BrakeActuatorPort;\n            perform startStopProcess.applyParkingBrake {\n                in applyParkingBrake = brakeActuatorPort.applyParkingBrake;\n            }\n        }\n        part vehicleControlSystem {\n            port driverPort: ~DriverPort;\n            port brakeSensorPort: ~BrakeSensorPort;\n            port controllerPort: ControllerPort;\n            port brakeActuatorPort: BrakeActuatorPort;\n            perform startStopProcess.controlProcess {\n                in startSignal = driverPort.startSignal;\n                in powerOnSignal = driverPort.powerOnSignal;\n                in stopSignal = driverPort.stopSignal;\n                in brakeDepressed = brakeSensorPort.brakeDepressed;\n                out startSignalToController = controllerPort.startSignalToController;\n                out applyParkingBrake = brakeActuatorPort.applyParkingBrake;\n            }\n        }\n        interface driverToControl connect driver.driverPort to vehicleControlSystem.driverPort;\n        interface brakeToControl connect brakePedal.brakeSensorPort to vehicleControlSystem.brakeSensorPort;\n        interface controlToController connect vehicleControlSystem.controllerPort to controller.controllerPort;\n        interface controlToBrake connect vehicleControlSystem.brakeActuatorPort to brakeActuator.brakeActuatorPort;\n    }\n    \n    action startStopProcess {\n        action driverInput {\n            out startSignal: StartSignal;\n            out powerOnSignal: PowerOnSignal;\n            out stopSignal: StopSignal;\n        }\n        action senseBrake {\n            out brakeDepressed: BrakeDepressed;\n        }\n        action controlProcess {\n            in startSignal: StartSignal;\n            in powerOnSignal: PowerOnSignal;\n            in stopSignal: StopSignal;\n            in brakeDepressed: BrakeDepressed;\n            out startSignalToController: StartSignalToController;\n            out applyParkingBrake: ApplyParkingBrake;\n        }\n        action receiveStartSignal {\n            in startSignalToController: StartSignalToController;\n        }\n        action applyParkingBrake {\n            in applyParkingBrake: ApplyParkingBrake;\n        }\n        \n        succession flow startSignalFlow from driverInput.startSignal to controlProcess.startSignal;\n        succession flow powerOnSignalFlow from driverInput.powerOnSignal to controlProcess.powerOnSignal;\n        succession flow stopSignalFlow from driverInput.stopSignal to controlProcess.stopSignal;\n        succession flow brakeFlow from senseBrake.brakeDepressed to controlProcess.brakeDepressed;\n        succession flow controllerFlow from controlProcess.startSignalToController to receiveStartSignal.startSignalToController;\n        succession flow brakeActuatorFlow from controlProcess.applyParkingBrake to applyParkingBrake.applyParkingBrake;\n    }\n}",
    "package 'VehicleControlSystem' {\n    attribute def VehicleState;\n    signal def VehicleStartSignal;\n    signal def VehicleOnSignal;\n    signal def ShutdownSignal;\n    signal def StartControlSignal;\n    attribute def BrakePedalDepressed: Boolean;\n    attribute def ParkingBrakeApplied: Boolean;\n\n    port def DriverInputPort {\n        in vehicleStartSignal: VehicleStartSignal;\n        in vehicleOnSignal: VehicleOnSignal;\n        in shutdownSignal: ShutdownSignal;\n    }\n    port def VehicleControllerPort {\n        out startControlSignal: StartControlSignal;\n    }\n    port def SensorPort {\n        out brakePedalDepressed: BrakePedalDepressed;\n        out parkingBrakeApplied: ParkingBrakeApplied;\n    }\n\n    part context {\n        part driver {\n            port driverPort: DriverInputPort;\n            perform controlSequence.initiateStart {\n                out vehicleStartSignal = driverPort.vehicleStartSignal;\n            }\n        }\n        part controlSystem {\n            port driverInputPort: ~DriverInputPort;\n            port vehicleControllerPort: VehicleControllerPort;\n            port sensorPort: ~SensorPort;\n            state machine {\n                initial -> off;\n                state off {\n                    on driverInputPort.vehicleStartSignal -> starting;\n                }\n                state starting {\n                    on driverInputPort.vehicleOnSignal [sensorPort.brakePedalDepressed] / {\n                        send vehicleControllerPort.startControlSignal;\n                    } -> started;\n                }\n                state started {\n                    entry / { perform selfCheck; }\n                    do / { perform supplyPower; }\n                    on driverInputPort.shutdownSignal -> shuttingDown;\n                }\n                state shuttingDown {\n                    on change (sensorPort.parkingBrakeApplied) [sensorPort.parkingBrakeApplied] -> off;\n                }\n            }\n        }\n        part vehicleController {\n            port controlPort: ~VehicleControllerPort;\n            perform controlSequence.executeStart {\n                in startControlSignal = controlPort.startControlSignal;\n            }\n        }\n        part sensors {\n            port sensorPort: SensorPort;\n        }\n        interface driverToSystem connect driver.driverPort to controlSystem.driverInputPort {\n            ref flow references controlSequence.startSignalFlow\n                from source.vehicleStartSignal to target.vehicleStartSignal;\n        }\n        interface systemToController connect controlSystem.vehicleControllerPort to vehicleController.controlPort {\n            ref flow references controlSequence.startControlFlow\n                from source.startControlSignal to target.startControlSignal;\n        }\n        interface sensorsToSystem connect sensors.sensorPort to controlSystem.sensorPort {\n            ref flow references controlSequence.brakeStatusFlow\n                from source.brakePedalDepressed to target.brakePedalDepressed;\n            ref flow references controlSequence.parkingBrakeStatusFlow\n                from source.parkingBrakeApplied to target.parkingBrakeApplied;\n        }\n    }\n\n    action controlSequence {\n        action initiateStart { out vehicleStartSignal: VehicleStartSignal; }\n        succession flow startSignalFlow from initiateStart.vehicleStartSignal to processStart.vehicleStartSignal;\n        action processStart { in vehicleStartSignal; }\n        action checkBrake { in brakePedalDepressed: BrakePedalDepressed; }\n        succession flow brakeStatusFlow from checkBrake.brakePedalDepressed to authorizeStart.brakePedalDepressed;\n        action authorizeStart { \n            in brakePedalDepressed; \n            in vehicleOnSignal: VehicleOnSignal; \n            out startControlSignal: StartControlSignal; \n        }\n        succession flow startControlFlow from authorizeStart.startControlSignal to executeStart.startControlSignal;\n        action executeStart { in startControlSignal; }\n        action selfCheck;\n        action supplyPower;\n        action checkParkingBrake { in parkingBrakeApplied: ParkingBrakeApplied; }\n        succession flow parkingBrakeStatusFlow from checkParkingBrake.parkingBrakeApplied to shutdownCheck.parkingBrakeApplied;\n        action shutdownCheck { in parkingBrakeApplied; }\n    }\n}",
    "package 'CruiseControl' {\n    attribute def SetSpeedCmd;\n    attribute def ActualSpeed;\n    attribute def FuelControlCmd;\n    port def SetSpeedCmdPort {\n        out setSpeedCmd: SetSpeedCmd;\n    }\n    port def ActualSpeedPort {\n        out actualSpeed: ActualSpeed;\n    }\n    port def FuelControlCmdPort {\n        out fuelControlCmd: FuelControlCmd;\n    }\n    part context {\n        part driver {\n            port setSpeedCmdPort: SetSpeedCmdPort;\n            perform cruiseControl.sendSetSpeed {\n                out setSpeedCmd = setSpeedCmdPort.setSpeedCmd;\n            }\n        }\n        interface driverToController connect driver.setSpeedCmdPort to cruiseController.setSpeedCmdPort {\n            ref flow references cruiseControl.setSpeedFlow\n                from source.setSpeedCmd to target.setSpeedCmd;\n        }\n        part cruiseController {\n            port setSpeedCmdPort: ~SetSpeedCmdPort;\n            port actualSpeedPort: ~ActualSpeedPort;\n            port fuelControlCmdPort: FuelControlCmdPort;\n            perform cruiseControl.receiveSetSpeed {\n                in setSpeedCmd = setSpeedCmdPort.setSpeedCmd;\n            }\n            perform cruiseControl.getActualSpeed {\n                in actualSpeed = actualSpeedPort.actualSpeed;\n            }\n            perform cruiseControl.computeFuelControl {\n                in setSpeed = receiveSetSpeed.setSpeedCmd;\n                in actualSpeed = getActualSpeed.actualSpeed;\n                out fuelControlCmd = fuelControlCmdPort.fuelControlCmd;\n            }\n        }\n        part speedometer {\n            port actualSpeedPort: ActualSpeedPort;\n            perform cruiseControl.sendActualSpeed {\n                out actualSpeed = actualSpeedPort.actualSpeed;\n            }\n        }\n        interface speedometerToController connect speedometer.actualSpeedPort to cruiseController.actualSpeedPort {\n            ref flow references cruiseControl.actualSpeedFlow\n                from source.actualSpeed to target.actualSpeed;\n        }\n        part engine {\n            port fuelControlCmdPort: ~FuelControlCmdPort;\n            perform cruiseControl.adjustOutput {\n                in fuelControlCmd = fuelControlCmdPort.fuelControlCmd;\n            }\n        }\n        interface controllerToEngine connect cruiseController.fuelControlCmdPort to engine.fuelControlCmdPort {\n            ref flow references cruiseControl.fuelFlow\n                from source.fuelControlCmd to target.fuelControlCmd;\n        }\n    }\n    action cruiseControl {\n        action sendSetSpeed { out setSpeedCmd: SetSpeedCmd; }\n        succession flow setSpeedFlow from sendSetSpeed.setSpeedCmd to receiveSetSpeed.setSpeedCmd;\n        action receiveSetSpeed { in setSpeedCmd: SetSpeedCmd; }\n        action sendActualSpeed { out actualSpeed: ActualSpeed; }\n        succession flow actualSpeedFlow from sendActualSpeed.actualSpeed to getActualSpeed.actualSpeed;\n        action getActualSpeed { in actualSpeed: ActualSpeed; }\n        succession afterSetSpeed: receiveSetSpeed -> getActualSpeed;\n        action computeFuelControl {\n            in setSpeed: SetSpeedCmd;\n            in actualSpeed: ActualSpeed;\n            out fuelControlCmd: FuelControlCmd;\n        }\n        flow setSpeedToCompute: from receiveSetSpeed.setSpeedCmd to computeFuelControl.setSpeed;\n        flow actualSpeedToCompute: from getActualSpeed.actualSpeed to computeFuelControl.actualSpeed;\n        succession afterGetSpeed: getActualSpeed -> computeFuelControl;\n        action adjustOutput { in fuelControlCmd: FuelControlCmd; }\n        succession flow fuelFlow from computeFuelControl.fuelControlCmd to adjustOutput.fuelControlCmd;\n    }\n}",
    "package 'CruiseControl' {\n    attribute def SetSpeedCmd;\n    attribute def VehicleSpeed;\n    attribute def ThrottleCmd;\n    \n    port def SetSpeedPort {\n        out setSpeedCmd: SetSpeedCmd;\n    }\n    port def SpeedPort {\n        out currentSpeed: VehicleSpeed;\n    }\n    port def ThrottlePort {\n        out throttleCmd: ThrottleCmd;\n    }\n    \n    part context {\n        part driver {\n            port setSpeedPort: SetSpeedPort;\n            perform cruiseControlFunction.sendSetSpeed {\n                out setSpeedCmd = setSpeedPort.setSpeedCmd;\n            }\n        }\n        part cruiseController {\n            port setSpeedPort: ~SetSpeedPort;\n            port speedPort: ~SpeedPort;\n            port throttlePort: ThrottlePort;\n            perform cruiseControlFunction.computeThrottle {\n                in setSpeedCmd = setSpeedPort.setSpeedCmd;\n                in currentSpeed = speedPort.currentSpeed;\n                out throttleCmd = throttlePort.throttleCmd;\n            }\n        }\n        part speedometer {\n            port speedPort: SpeedPort;\n            perform cruiseControlFunction.acquireSpeed {\n                out currentSpeed = speedPort.currentSpeed;\n            }\n        }\n        part engineSystem {\n            port throttlePort: ~ThrottlePort;\n            perform cruiseControlFunction.adjustPower {\n                in throttleCmd = throttlePort.throttleCmd;\n            }\n        }\n        \n        interface driverToController connect driver.setSpeedPort to cruiseController.setSpeedPort {\n            ref flow references cruiseControlFunction.setSpeedFlow\n                from source.setSpeedCmd to target.setSpeedCmd;\n        }\n        interface speedToController connect speedometer.speedPort to cruiseController.speedPort {\n            ref flow references cruiseControlFunction.speedFlow\n                from source.currentSpeed to target.currentSpeed;\n        }\n        interface controllerToEngine connect cruiseController.throttlePort to engineSystem.throttlePort {\n            ref flow references cruiseControlFunction.throttleFlow\n                from source.throttleCmd to target.throttleCmd;\n        }\n    }\n    \n    action cruiseControlFunction {\n        action sendSetSpeed { out setSpeedCmd: SetSpeedCmd; }\n        action acquireSpeed { out currentSpeed: VehicleSpeed; }\n        action computeThrottle {\n            in setSpeedCmd: SetSpeedCmd;\n            in currentSpeed: VehicleSpeed;\n            out throttleCmd: ThrottleCmd;\n        }\n        action adjustPower { in throttleCmd: ThrottleCmd; }\n        \n        succession flow setSpeedFlow from sendSetSpeed.setSpeedCmd to computeThrottle.setSpeedCmd;\n        succession flow speedFlow from acquireSpeed.currentSpeed to computeThrottle.currentSpeed;\n        succession flow throttleFlow from computeThrottle.throttleCmd to adjustPower.throttleCmd;\n    }\n}",
    "package 'CruiseControl' {\n    attribute def SetSpeedCmd;\n    attribute def CurrentSpeed;\n    attribute def ThrottleCmd;\n    \n    port def SetSpeedPort {\n        out setSpeed: SetSpeedCmd;\n    }\n    port def CurrentSpeedPort {\n        out currentSpeed: CurrentSpeed;\n    }\n    port def ThrottlePort {\n        out throttle: ThrottleCmd;\n    }\n    \n    part context {\n        part driver {\n            port setSpeedPort: SetSpeedPort;\n            perform maintainSpeed.sendSetSpeed {\n                out setSpeed = setSpeedPort.setSpeed;\n            }\n        }\n        part cruiseController {\n            port setSpeedInPort: ~SetSpeedPort;\n            port currentSpeedInPort: ~CurrentSpeedPort;\n            port throttlePort: ThrottlePort;\n            perform maintainSpeed.calculateThrottle {\n                in setSpeed = setSpeedInPort.setSpeed;\n                in currentSpeed = currentSpeedInPort.currentSpeed;\n                out throttle = throttlePort.throttle;\n            }\n        }\n        part speedometer {\n            port currentSpeedPort: CurrentSpeedPort;\n            perform maintainSpeed.provideCurrentSpeed {\n                out currentSpeed = currentSpeedPort.currentSpeed;\n            }\n        }\n        part engine {\n            port throttleInPort: ~ThrottlePort;\n            perform maintainSpeed.adjustEngine {\n                in throttle = throttleInPort.throttle;\n            }\n        }\n        \n        interface driverToController connect driver.setSpeedPort to cruiseController.setSpeedInPort {\n            ref flow references maintainSpeed.setSpeedFlow \n                from source.setSpeed to target.setSpeed;\n        }\n        interface speedToController connect speedometer.currentSpeedPort to cruiseController.currentSpeedInPort {\n            ref flow references maintainSpeed.currentSpeedFlow \n                from source.currentSpeed to target.currentSpeed;\n        }\n        interface controllerToEngine connect cruiseController.throttlePort to engine.throttleInPort {\n            ref flow references maintainSpeed.throttleFlow \n                from source.throttle to target.throttle;\n        }\n    }\n    \n    action maintainSpeed {\n        action sendSetSpeed { out setSpeed: SetSpeedCmd; }\n        action provideCurrentSpeed { out currentSpeed: CurrentSpeed; }\n        action calculateThrottle {\n            in setSpeed: SetSpeedCmd;\n            in currentSpeed: CurrentSpeed;\n            out throttle: ThrottleCmd;\n        }\n        action adjustEngine { in throttle: ThrottleCmd; }\n        \n        succession flow setSpeedFlow from sendSetSpeed.setSpeed to calculateThrottle.setSpeed;\n        succession flow currentSpeedFlow from provideCurrentSpeed.currentSpeed to calculateThrottle.currentSpeed;\n        succession flow throttleFlow from calculateThrottle.throttle to adjustEngine.throttle;\n    }\n}",
    "package 'CruiseControl' {\n    attribute def DesiredSpeed;\n    attribute def CurrentSpeed;\n    attribute def ThrottleControl;\n    port def DesiredSpeedPort {\n        out desiredSpeed: DesiredSpeed;\n    }\n    port def CurrentSpeedPort {\n        out currentSpeed: CurrentSpeed;\n    }\n    port def ThrottleControlPort {\n        out throttleControl: ThrottleControl;\n    }\n    part context {\n        part driver {\n            port desiredSpeedPort: DesiredSpeedPort;\n            perform cruiseControl.sendDesiredSpeed {\n                out desiredSpeed = desiredSpeedPort.desiredSpeed;\n            }\n        }\n        interface driverToController connect driver.desiredSpeedPort to cruiseController.desiredSpeedPort {\n            ref flow references cruiseControl.desiredSpeedFlow\n                from source.desiredSpeed to target.desiredSpeed;\n        }\n        part cruiseController {\n            port desiredSpeedPort: ~DesiredSpeedPort;\n            port currentSpeedPort: ~CurrentSpeedPort;\n            port throttleControlPort: ThrottleControlPort;\n            perform cruiseControl.calculateThrottle {\n                in desiredSpeed = desiredSpeedPort.desiredSpeed;\n                in currentSpeed = currentSpeedPort.currentSpeed;\n                out throttleControl = throttleControlPort.throttleControl;\n            }\n        }\n        part speedometer {\n            port currentSpeedPort: CurrentSpeedPort;\n            perform cruiseControl.senseSpeed {\n                out currentSpeed = currentSpeedPort.currentSpeed;\n            }\n        }\n        interface speedometerToController connect speedometer.currentSpeedPort to cruiseController.currentSpeedPort {\n            ref flow references cruiseControl.currentSpeedFlow\n                from source.currentSpeed to target.currentSpeed;\n        }\n        part engine {\n            port throttleControlPort: ~ThrottleControlPort;\n            perform cruiseControl.adjustThrottle {\n                in throttleControl = throttleControlPort.throttleControl;\n            }\n        }\n        interface controllerToEngine connect cruiseController.throttleControlPort to engine.throttleControlPort {\n            ref flow references cruiseControl.throttleControlFlow\n                from source.throttleControl to target.throttleControl;\n        }\n    }\n    action cruiseControl {\n        action sendDesiredSpeed { out desiredSpeed: DesiredSpeed; }\n        action senseSpeed { out currentSpeed: CurrentSpeed; }\n        succession flow desiredSpeedFlow from sendDesiredSpeed.desiredSpeed to calculateThrottle.desiredSpeed;\n        succession flow currentSpeedFlow from senseSpeed.currentSpeed to calculateThrottle.currentSpeed;\n        action calculateThrottle {\n            in desiredSpeed: DesiredSpeed;\n            in currentSpeed: CurrentSpeed;\n            out throttleControl: ThrottleControl;\n        }\n        succession flow throttleControlFlow from calculateThrottle.throttleControl to adjustThrottle.throttleControl;\n        action adjustThrottle { in throttleControl: ThrottleControl; }\n    }\n}",
    "package 'CruiseControl' {\n    attribute def SetSpeedCmd;\n    attribute def ActualSpeed;\n    attribute def FuelControlCmd;\n    \n    port def SetSpeedCmdPort {\n        out setSpeedCmd: SetSpeedCmd;\n    }\n    port def ActualSpeedPort {\n        out actualSpeed: ActualSpeed;\n    }\n    port def FuelControlCmdPort {\n        out fuelControlCmd: FuelControlCmd;\n    }\n    \n    part context {\n        part driver {\n            port setSpeedCmdPort: SetSpeedCmdPort;\n            perform cruiseControl.setTargetSpeed {\n                out setSpeedCmd = setSpeedCmdPort.setSpeedCmd;\n            }\n        }\n        part cruiseInterface {\n            port setSpeedCmdPort: ~SetSpeedCmdPort;\n            perform cruiseControl.forwardSetSpeedCmd {\n                in setSpeedCmd = setSpeedCmdPort.setSpeedCmd;\n                out setSpeedCmd = toController.setSpeedCmd;\n            }\n            port toController: SetSpeedCmdPort;\n        }\n        interface driverToInterface connect driver.setSpeedCmdPort to cruiseInterface.setSpeedCmdPort {\n            ref flow references cruiseControl.setSpeedFlow1\n                from source.setSpeedCmd to target.setSpeedCmd;\n        }\n        part cruiseController {\n            port setSpeedCmdPort: ~SetSpeedCmdPort;\n            port actualSpeedPort: ~ActualSpeedPort;\n            port fuelControlCmdPort: FuelControlCmdPort;\n            perform cruiseControl.compareAndControl {\n                in setSpeedCmd = setSpeedCmdPort.setSpeedCmd;\n                in actualSpeed = actualSpeedPort.actualSpeed;\n                out fuelControlCmd = fuelControlCmdPort.fuelControlCmd;\n            }\n        }\n        interface interfaceToController connect cruiseInterface.toController to cruiseController.setSpeedCmdPort {\n            ref flow references cruiseControl.setSpeedFlow2\n                from source.setSpeedCmd to target.setSpeedCmd;\n        }\n        part speedSensor {\n            port actualSpeedPort: ActualSpeedPort;\n            perform cruiseControl.senseSpeed {\n                out actualSpeed = actualSpeedPort.actualSpeed;\n            }\n        }\n        interface sensorToController connect speedSensor.actualSpeedPort to cruiseController.actualSpeedPort {\n            ref flow references cruiseControl.speedFlow\n                from source.actualSpeed to target.actualSpeed;\n        }\n        part engine {\n            port fuelControlCmdPort: ~FuelControlCmdPort;\n            perform cruiseControl.adjustEngine {\n                in fuelControlCmd = fuelControlCmdPort.fuelControlCmd;\n            }\n        }\n        interface controllerToEngine connect cruiseController.fuelControlCmdPort to engine.fuelControlCmdPort {\n            ref flow references cruiseControl.fuelFlow\n                from source.fuelControlCmd to target.fuelControlCmd;\n        }\n    }\n    \n    action cruiseControl {\n        action setTargetSpeed { out setSpeedCmd: SetSpeedCmd; }\n        action forwardSetSpeedCmd { in setSpeedCmd; out setSpeedCmd: SetSpeedCmd; }\n        succession flow setSpeedFlow1 from setTargetSpeed.setSpeedCmd to forwardSetSpeedCmd.setSpeedCmd;\n        \n        action senseSpeed { out actualSpeed: ActualSpeed; }\n        \n        action compareAndControl {\n            in setSpeedCmd: SetSpeedCmd;\n            in actualSpeed: ActualSpeed;\n            out fuelControlCmd: FuelControlCmd;\n        }\n        succession flow setSpeedFlow2 from forwardSetSpeedCmd.setSpeedCmd to compareAndControl.setSpeedCmd;\n        succession flow speedFlow from senseSpeed.actualSpeed to compareAndControl.actualSpeed;\n        \n        action adjustEngine { in fuelControlCmd: FuelControlCmd; }\n        succession flow fuelFlow from compareAndControl.fuelControlCmd to adjustEngine.fuelControlCmd;\n    }\n}",
    "package 'CruiseControlSystem' {\n    attribute def SetSpeedCmd;\n    attribute def Speed;\n    attribute def FuelControlCmd;\n    \n    port def SetSpeedCmdPort {\n        out setSpeedCmd: SetSpeedCmd;\n    }\n    port def SpeedPort {\n        out speed: Speed;\n    }\n    port def FuelControlCmdPort {\n        out fuelControlCmd: FuelControlCmd;\n    }\n    port def EngineCmdPort {\n        out fuelControlCmd: FuelControlCmd;\n    }\n    \n    part context {\n        part driver {\n            port setSpeedCmdPort: SetSpeedCmdPort;\n            perform speedAdjustment.sendSetSpeedCmd {\n                out setSpeedCmd = setSpeedCmdPort.setSpeedCmd;\n            }\n        }\n        part cruiseController {\n            port setSpeedCmdPort: ~SetSpeedCmdPort;\n            port speedPort: ~SpeedPort;\n            port fuelControlCmdPort: FuelControlCmdPort;\n            perform speedAdjustment.processSetSpeed {\n                in setSpeedCmd = setSpeedCmdPort.setSpeedCmd;\n            }\n            perform speedAdjustment.readSpeed {\n                in speed = speedPort.speed;\n            }\n            perform speedAdjustment.calculateFuelCmd {\n                out fuelControlCmd = fuelControlCmdPort.fuelControlCmd;\n            }\n        }\n        part speedSensor {\n            port speedPort: SpeedPort;\n            perform speedAdjustment.provideSpeed {\n                out speed = speedPort.speed;\n            }\n        }\n        part engineController {\n            port fuelControlCmdPort: ~FuelControlCmdPort;\n            port engineCmdPort: EngineCmdPort;\n            perform speedAdjustment.forwardFuelCmd {\n                in fuelControlCmd = fuelControlCmdPort.fuelControlCmd;\n                out fuelControlCmd = engineCmdPort.fuelControlCmd;\n            }\n        }\n        part engine {\n            port engineCmdPort: ~EngineCmdPort;\n            perform speedAdjustment.adjustFuel {\n                in fuelControlCmd = engineCmdPort.fuelControlCmd;\n            }\n        }\n        \n        interface driverToCruise connect driver.setSpeedCmdPort to cruiseController.setSpeedCmdPort {\n            ref flow references speedAdjustment.setSpeedFlow\n                from source.setSpeedCmd to target.setSpeedCmd;\n        }\n        interface cruiseToSensor connect cruiseController.speedPort to speedSensor.speedPort {\n            ref flow references speedAdjustment.speedFlow\n                from source.speed to target.speed;\n        }\n        interface cruiseToEngineCtrl connect cruiseController.fuelControlCmdPort to engineController.fuelControlCmdPort {\n            ref flow references speedAdjustment.fuelCmdFlow\n                from source.fuelControlCmd to target.fuelControlCmd;\n        }\n        interface engineCtrlToEngine connect engineController.engineCmdPort to engine.engineCmdPort {\n            ref flow references speedAdjustment.engineCmdFlow\n                from source.fuelControlCmd to target.fuelControlCmd;\n        }\n    }\n    \n    action speedAdjustment {\n        action sendSetSpeedCmd { out setSpeedCmd: SetSpeedCmd; }\n        action processSetSpeed { in setSpeedCmd: SetSpeedCmd; }\n        succession flow setSpeedFlow from sendSetSpeedCmd.setSpeedCmd to processSetSpeed.setSpeedCmd;\n        \n        action provideSpeed { out speed: Speed; }\n        action readSpeed { in speed: Speed; }\n        succession flow speedFlow from provideSpeed.speed to readSpeed.speed;\n        \n        action calculateFuelCmd {\n            in setSpeedCmd: SetSpeedCmd;\n            in speed: Speed;\n            out fuelControlCmd: FuelControlCmd;\n        }\n        succession flow setSpeedToCalc from processSetSpeed.setSpeedCmd to calculateFuelCmd.setSpeedCmd;\n        succession flow speedToCalc from readSpeed.speed to calculateFuelCmd.speed;\n        \n        action forwardFuelCmd {\n            in fuelControlCmd: FuelControlCmd;\n            out fuelControlCmd: FuelControlCmd;\n        }\n        succession flow fuelCmdFlow from calculateFuelCmd.fuelControlCmd to forwardFuelCmd.fuelControlCmd;\n        \n        action adjustFuel { in fuelControlCmd: FuelControlCmd; }\n        succession flow engineCmdFlow from forwardFuelCmd.fuelControlCmd to adjustFuel.fuelControlCmd;\n        \n        succession afterSetSpeed from processSetSpeed to calculateFuelCmd;\n        succession afterCalc from calculateFuelCmd to forwardFuelCmd;\n    }\n}",
    "package 'VehicleLifecycle' {\n    attribute def Date;\n    attribute def OwnerInfo;\n    attribute def DriverInfo;\n    attribute def ScrapInfo;\n    \n    part def Vehicle;\n    \n    part def DeliveryEvent {\n        attribute deliveryDate: Date;\n    }\n    \n    part def OwnershipEvent {\n        attribute owner: OwnerInfo;\n        attribute changeDate: Date;\n    }\n    \n    part def DrivingEvent {\n        attribute driver: DriverInfo;\n        attribute operationDate: Date;\n    }\n    \n    part def ScrappingEvent {\n        attribute scrapInfo: ScrapInfo;\n        attribute scrapDate: Date;\n    }\n    \n    part context {\n        part vehicle: Vehicle;\n        part lifecycleManager {\n            perform manageLifecycle.recordAssembly for vehicle;\n            perform manageLifecycle.recordDelivery for vehicle;\n            perform manageLifecycle.recordOwnershipChange for vehicle;\n            perform manageLifecycle.recordDriving for vehicle;\n            perform manageLifecycle.recordScrapping for vehicle;\n            perform queryLifecycle for vehicle;\n        }\n    }\n    \n    action manageLifecycle {\n        action recordAssembly;\n        action recordDelivery {\n            out deliveryEvent: DeliveryEvent;\n        }\n        action recordOwnershipChange {\n            out ownershipEvent: OwnershipEvent;\n        }\n        action recordDriving {\n            out drivingEvent: DrivingEvent;\n        }\n        action recordScrapping {\n            out scrappingEvent: ScrappingEvent;\n        }\n        \n        succession from recordAssembly to recordDelivery;\n        succession from recordDelivery to recordOwnershipChange;\n        succession from recordOwnershipChange to recordDriving;\n        succession from recordDriving to recordScrapping;\n    }\n    \n    action queryLifecycle for vehicle {\n        in vehicle;\n    }\n}",
    "package 'VehicleSystem' {\n    attribute def Mass: Real;\n    attribute def GearSetting: String;\n    attribute def AcceleratorPedalPosition: Real;\n    attribute def OperationalStatus {\n        attribute gear: GearSetting;\n        attribute accelerator: AcceleratorPedalPosition;\n    }\n    attribute def RotationSpeed: Real;\n    \n    part def Engine;\n    part def Driver {\n        external;\n    }\n    part def Wheel {\n        attribute rotationSpeed: RotationSpeed;\n    }\n    part def Vehicle {\n        attribute mass: Mass;\n        attribute operationalStatus: OperationalStatus;\n        part engine: Engine;\n        part driver: Driver;\n        part leftFront: Wheel;\n        part rightFront: Wheel;\n    }\n    \n    instance vehicle_1: Vehicle {\n        mass = 1500.0;\n    }\n    \n    state snapshot1 for vehicle_1 @ 0 {\n        vehicle_1.operationalStatus.gear = \"P\";\n        vehicle_1.operationalStatus.accelerator = 0.0;\n        vehicle_1.leftFront.rotationSpeed = 0.0;\n        vehicle_1.rightFront.rotationSpeed = 0.0;\n    }\n    \n    state snapshot2 for vehicle_1 @ 10 {\n        vehicle_1.operationalStatus.gear = \"D\";\n        vehicle_1.operationalStatus.accelerator = 50.0;\n        vehicle_1.leftFront.rotationSpeed = 10.0;\n        vehicle_1.rightFront.rotationSpeed = 10.0;\n    }\n}",
    "package 'VehicleSystem' {\n    type Mass: Real;\n    type Gear: Integer;\n    type Accelerator: Real;\n    struct VehicleState {\n        gear: Gear;\n        accelerator: Accelerator;\n    }\n    part def Engine {}\n    part def Driver {}\n    part def Vehicle {\n        attribute mass: Mass;\n        attribute state: VehicleState;\n        part engine: Engine;\n        part driver: Driver;\n    }\n    part context {\n        part Vehicle_1: Vehicle {\n            part engine: Engine;\n            part driver: Driver;\n        }\n    }\n    scenario def VehicleEvolution {\n        participant Vehicle_1: Vehicle;\n        state def Initial: Vehicle {\n            mass = 2000;\n            state = {gear=0, accelerator=0.0};\n        }\n        state def Next: Vehicle {\n            mass = 1500;\n            state = {gear=2, accelerator=0.5};\n        }\n        sequence {\n            Initial -> Next;\n        }\n    }\n}",
    "package 'VehicleSystem' {\n    unit kg;\n    \n    value type Mass: Real {\n        unit = kg;\n    }\n    \n    value type ThrottlePosition: Real;\n    \n    enum GearPosition {\n        neutral,\n        first,\n        second,\n        third,\n        fourth,\n        fifth,\n        sixth\n    }\n    \n    part def Driver;\n    \n    individual alice: Driver;\n    individual bob: Driver;\n    \n    part def Engine;\n    \n    part def Vehicle {\n        attribute mass: Mass;\n        attribute gearPosition: GearPosition;\n        attribute throttlePedalPosition: ThrottlePosition;\n        part engine: Engine;\n        reference driver: Driver;\n        stateMachine behavior: VehicleStateMachine;\n    }\n    \n    stateMachine def VehicleStateMachine {\n        state initialState {\n            entry {\n                this.mass = 2000;\n                this.gearPosition = GearPosition::neutral;\n                this.throttlePedalPosition = 0.0;\n                this.driver = alice;\n            }\n        }\n        state subsequentState {\n            entry {\n                this.mass = 1500;\n                this.gearPosition = GearPosition::second;\n                this.throttlePedalPosition = 0.5;\n                this.driver = bob;\n            }\n        }\n        transition from initialState to subsequentState;\n    }\n}",
    "package 'Vehicle Mass Model' {\n    value type Mass: Real;\n\n    block Component {\n        attribute id: String;\n        attribute ownMass: Mass;\n        attribute totalMass: Mass {\n            derive: ownMass + subcomponent->sum(totalMass);\n        }\n        part subcomponent: Component[*];\n    }\n\n    block Vehicle extends Component;\n}",
    "package 'Vehicle Mass Management' {\n    value type Mass = Real;\n\n    part def Component {\n        attribute serialNumber: String;\n        attribute mass: Mass;\n        part subcomponents: Component[*];\n        perform computeOwnMassWithSubcomponents in (threshold: Mass?) out (total: Mass);\n    }\n\n    part def Engine specializes Component;\n    part def Transmission specializes Component;\n\n    part def Vehicle {\n        attribute vin: String;\n        attribute ownMass: Mass;\n        part components: Component[*];\n        perform computeTotalMass in (threshold: Mass?) out (total: Mass);\n    }\n}",
    "package 'MassAggregation' {\n    attribute def Mass: Real;\n    part def Thing {\n        attribute simpleMass: Mass;\n        attribute totalMass: Mass;\n    }\n    part def SimpleThing :> Thing {\n        constraint totalMassConstraint {\n            totalMass = simpleMass;\n        }\n    }\n    part def CompositeThing :> Thing {\n        part subcomponent[*]: Thing;\n        constraint totalMassConstraint {\n            totalMass = simpleMass + (subcomponent.totalMass->sum());\n        }\n    }\n}",
    "package 'MassAggregationSystem' {\n    block MassObject {\n        attribute basicMass: Real;\n        part subcomponents: MassObject[0..*];\n        action calculateTotalMass {\n            in threshold: Real;\n            out totalMass: Real;\n        }\n    }\n}",
    "package 'VehicleDynamics' {\n    attribute def WheelPower;\n    attribute def DragCoefficient;\n    attribute def FrictionCoefficient;\n    attribute def Mass;\n    attribute def Speed;\n    attribute def Time;\n    attribute def PowerOutput;\n    attribute def Acceleration;\n    attribute def Displacement;\n    \n    port def SystemInputPort {\n        in wheelPower: WheelPower;\n        in dragCoefficient: DragCoefficient;\n        in frictionCoefficient: FrictionCoefficient;\n        in mass: Mass;\n        in initialSpeed: Speed;\n        in time: Time;\n    }\n    \n    port def SystemOutputPort {\n        out powerOutput: PowerOutput;\n        out acceleration: Acceleration;\n        out newSpeed: Speed;\n        out displacement: Displacement;\n    }\n    \n    action calculateDynamics {\n        in wheelPower: WheelPower;\n        in dragCoefficient: DragCoefficient;\n        in frictionCoefficient: FrictionCoefficient;\n        in mass: Mass;\n        in initialSpeed: Speed;\n        in time: Time;\n        \n        out powerOutput: PowerOutput;\n        out acceleration: Acceleration;\n        out newSpeed: Speed;\n        out displacement: Displacement;\n        \n        part calcPower {\n            in wheelPower: WheelPower;\n            in dragCoefficient: DragCoefficient;\n            in frictionCoefficient: FrictionCoefficient;\n            in mass: Mass;\n            in speed: Speed;\n            out powerOutput: PowerOutput;\n        }\n        \n        part calcAcceleration {\n            in powerOutput: PowerOutput;\n            in mass: Mass;\n            in speed: Speed;\n            out acceleration: Acceleration;\n        }\n        \n        part calcSpeed {\n            in acceleration: Acceleration;\n            in initialSpeed: Speed;\n            in time: Time;\n            out newSpeed: Speed;\n        }\n        \n        part calcDisplacement {\n            in initialSpeed: Speed;\n            in time: Time;\n            out displacement: Displacement;\n        }\n        \n        bind calcPower.wheelPower = wheelPower;\n        bind calcPower.dragCoefficient = dragCoefficient;\n        bind calcPower.frictionCoefficient = frictionCoefficient;\n        bind calcPower.mass = mass;\n        bind calcPower.speed = initialSpeed;\n        \n        bind calcAcceleration.mass = mass;\n        bind calcAcceleration.speed = initialSpeed;\n        \n        bind calcSpeed.initialSpeed = initialSpeed;\n        bind calcSpeed.time = time;\n        \n        bind calcDisplacement.initialSpeed = initialSpeed;\n        bind calcDisplacement.time = time;\n        \n        succession flow powerFlow from calcPower.powerOutput to calcAcceleration.powerOutput;\n        succession flow accelFlow from calcAcceleration.acceleration to calcSpeed.acceleration;\n        \n        bind powerOutput = calcPower.powerOutput;\n        bind acceleration = calcAcceleration.acceleration;\n        bind newSpeed = calcSpeed.newSpeed;\n        bind displacement = calcDisplacement.displacement;\n    }\n    \n    part context {\n        part user {\n            port inputsProvider: ~SystemInputPort;\n            port outputsReceiver: ~SystemOutputPort;\n        }\n        \n        part calculator {\n            port systemInputPort: SystemInputPort;\n            port systemOutputPort: SystemOutputPort;\n            perform calculateDynamics as calculateDynamicsAction {\n                in wheelPower = systemInputPort.wheelPower;\n                in dragCoefficient = systemInputPort.dragCoefficient;\n                in frictionCoefficient = systemInputPort.frictionCoefficient;\n                in mass = systemInputPort.mass;\n                in initialSpeed = systemInputPort.initialSpeed;\n                in time = systemInputPort.time;\n                out powerOutput = systemOutputPort.powerOutput;\n                out acceleration = systemOutputPort.acceleration;\n                out newSpeed = systemOutputPort.newSpeed;\n                out displacement = systemOutputPort.displacement;\n            }\n        }\n        \n        interface userToSystem connect user.inputsProvider to calculator.systemInputPort;\n        interface systemToUser connect calculator.systemOutputPort to user.outputsReceiver;\n    }\n}",
    "package 'VehicleDynamicsSimulation' {\n    attribute def TotalVehicleMass;\n    attribute def AerodynamicDragCoefficient;\n    attribute def RollingResistanceCoefficient;\n    attribute def WheelEndOutputPower;\n    attribute def TimeStep;\n    attribute def InitialSpeed;\n    attribute def InitialPosition;\n    attribute def Acceleration;\n    attribute def Speed;\n    attribute def Position;\n    attribute def AvailableDrivingPower;\n    port def SimulationInputPort {\n        in totalVehicleMass: TotalVehicleMass;\n        in aerodynamicDragCoefficient: AerodynamicDragCoefficient;\n        in rollingResistanceCoefficient: RollingResistanceCoefficient;\n        in wheelEndOutputPower: WheelEndOutputPower;\n        in timeStep: TimeStep;\n        in initialSpeed: InitialSpeed;\n        in initialPosition: InitialPosition;\n    }\n    port def SimulationOutputPort {\n        out acceleration: Acceleration;\n        out speed: Speed;\n        out position: Position;\n    }\n    part context {\n        part user {\n            port simulationInputPort: SimulationInputPort;\n            perform dynamicsSimulation.provideInputs {\n                out totalVehicleMass = simulationInputPort.totalVehicleMass;\n                out aerodynamicDragCoefficient = simulationInputPort.aerodynamicDragCoefficient;\n                out rollingResistanceCoefficient = simulationInputPort.rollingResistanceCoefficient;\n                out wheelEndOutputPower = simulationInputPort.wheelEndOutputPower;\n                out timeStep = simulationInputPort.timeStep;\n                out initialSpeed = simulationInputPort.initialSpeed;\n                out initialPosition = simulationInputPort.initialPosition;\n            }\n        }\n        interface userToSimulator connect user.simulationInputPort to simulator.simulationInputPort {\n            ref flow references dynamicsSimulation.inputFlow\n                from source.simulationInputPort to target.simulationInputPort;\n        }\n        part simulator {\n            port simulationInputPort: ~SimulationInputPort;\n            port simulationOutputPort: SimulationOutputPort;\n            perform dynamicsSimulation.computeDynamics {\n                in totalVehicleMass = simulationInputPort.totalVehicleMass;\n                in aerodynamicDragCoefficient = simulationInputPort.aerodynamicDragCoefficient;\n                in rollingResistanceCoefficient = simulationInputPort.rollingResistanceCoefficient;\n                in wheelEndOutputPower = simulationInputPort.wheelEndOutputPower;\n                in timeStep = simulationInputPort.timeStep;\n                in initialSpeed = simulationInputPort.initialSpeed;\n                in initialPosition = simulationInputPort.initialPosition;\n                out acceleration = simulationOutputPort.acceleration;\n                out speed = simulationOutputPort.speed;\n                out position = simulationOutputPort.position;\n            }\n        }\n    }\n    action dynamicsSimulation {\n        action provideInputs {\n            out totalVehicleMass: TotalVehicleMass;\n            out aerodynamicDragCoefficient: AerodynamicDragCoefficient;\n            out rollingResistanceCoefficient: RollingResistanceCoefficient;\n            out wheelEndOutputPower: WheelEndOutputPower;\n            out timeStep: TimeStep;\n            out initialSpeed: InitialSpeed;\n            out initialPosition: InitialPosition;\n        }\n        succession flow inputFlow from provideInputs to computeDrivingPower;\n        action computeDrivingPower {\n            in totalVehicleMass;\n            in aerodynamicDragCoefficient;\n            in rollingResistanceCoefficient;\n            in initialSpeed;\n            in wheelEndOutputPower;\n            out availableDrivingPower: AvailableDrivingPower;\n        }\n        succession flow powerFlow from computeDrivingPower to calculateAcceleration;\n        action calculateAcceleration {\n            in availableDrivingPower;\n            in totalVehicleMass;\n            out acceleration: Acceleration;\n        }\n        succession flow accelFlow from calculateAcceleration to updateSpeed;\n        action updateSpeed {\n            in initialSpeed;\n            in acceleration;\n            in timeStep;\n            out newSpeed: Speed;\n        }\n        succession flow speedFlow from updateSpeed to updatePosition;\n        action updatePosition {\n            in initialPosition;\n            in initialSpeed;\n            in acceleration;\n            in timeStep;\n            out newPosition: Position;\n        }\n    }\n}",
    "package 'VehicleDynamics' {\n    attribute def Mass;\n    attribute def Power;\n    attribute def DragCoefficient;\n    attribute def RollingResistanceCoefficient;\n    attribute def Speed;\n    attribute def Position;\n    attribute def Acceleration;\n    attribute def TimeStep;\n    \n    part def Parameters {\n        attribute mass: Mass;\n        attribute wheelPower: Power;\n        attribute dragCoefficient: DragCoefficient;\n        attribute rollingResistance: RollingResistanceCoefficient;\n    }\n    \n    part def State {\n        attribute speed: Speed;\n        attribute position: Position;\n        attribute acceleration: Acceleration;\n    }\n    \n    port def InitializationPort {\n        in initialParameters: Parameters;\n        in initialState: State;\n        in timeStep: TimeStep;\n    }\n    \n    port def StateOutputPort {\n        out currentState: State;\n    }\n    \n    part def VehicleSystem {\n        attribute parameters: Parameters;\n        attribute currentState: State;\n        attribute timeStep: TimeStep;\n        \n        port initializationPort: ~InitializationPort;\n        port stateOutputPort: StateOutputPort;\n        \n        bind parameters = initializationPort.initialParameters;\n        bind currentState = initializationPort.initialState;\n        bind timeStep = initializationPort.timeStep;\n        bind stateOutputPort.currentState = currentState;\n        \n        perform dynamicsUpdate: ComputeDynamics {\n            in params = parameters;\n            in currentState = currentState;\n            in timeStep = timeStep;\n            out nextState -> currentState;\n        }\n    }\n    \n    action ComputeDynamics {\n        in params: Parameters;\n        in currentState: State;\n        in timeStep: TimeStep;\n        out nextState: State;\n    }\n    \n    part context {\n        part user {\n            port def UserInitPort {\n                out initialParameters: Parameters;\n                out initialState: State;\n                out timeStep: TimeStep;\n            }\n            port def StateInputPort {\n                in currentState: State;\n            }\n            \n            port userInitPort: UserInitPort;\n            port stateInputPort: StateInputPort;\n        }\n        \n        part vehicleSystem: VehicleSystem;\n        \n        interface initConnection connect user.userInitPort to vehicleSystem.initializationPort;\n        interface stateConnection connect vehicleSystem.stateOutputPort to user.stateInputPort;\n    }\n}",
    "package 'VehicleLongitudinalDynamics' {\n    attribute def InputParameters {\n        initialPosition: Real;\n        initialVelocity: Real;\n        mass: Real;\n        power: Real;\n        timeInterval: Real;\n        dragCoefficient: Real;\n        frictionCoefficient: Real;\n    }\n    attribute def OutputResults {\n        acceleration: Real;\n        finalVelocity: Real;\n        finalPosition: Real;\n    }\n    port def InputPort {\n        in parameters: InputParameters;\n    }\n    port def OutputPort {\n        out results: OutputResults;\n    }\n    part context {\n        part user {\n            port inputPort: InputPort;\n            perform computeDynamics.provideInputs {\n                out parameters = inputPort.parameters;\n            }\n        }\n        part vehicle {\n            port inputPort: ~InputPort;\n            port outputPort: OutputPort;\n            perform computeDynamics.compute {\n                in parameters = inputPort.parameters;\n                out results = outputPort.results;\n            }\n        }\n        interface userToVehicle connect user.inputPort to vehicle.inputPort {\n            ref flow references computeDynamics.parametersFlow \n                from source.parameters to target.parameters;\n        }\n    }\n    action computeDynamics {\n        action provideInputs { out parameters: InputParameters; }\n        action compute {\n            in parameters: InputParameters;\n            out results: OutputResults;\n        }\n        succession flow parametersFlow from provideInputs.parameters to compute.parameters;\n    }\n}",
    "package 'VehicleMassManagement' {\n    attribute def Mass: Real;\n    attribute def Warning: String;\n    part def Chassis {\n        attribute mass: Mass;\n    }\n    part def Engine {\n        attribute mass: Mass;\n    }\n    part def Gearbox {\n        attribute mass: Mass;\n    }\n    port def WarningPort {\n        out warning: Warning;\n    }\n    action checkMassCompliance {\n        in chassisMass: Mass;\n        in engineMass: Mass;\n        in gearboxMass: Mass;\n        in maxMass: Mass;\n        out warning: Warning;\n        constraint {\n            let total = chassisMass + engineMass + gearboxMass;\n            if total > maxMass then\n                warning = \"Overweight: total mass \" + total + \" kg exceeds limit of \" + maxMass + \" kg\";\n        }\n    }\n    part def Vehicle {\n        part chassis: Chassis;\n        part engine: Engine;\n        part gearbox: Gearbox;\n        attribute maxMass: Mass = 2500.0;\n        port warningPort: WarningPort;\n        perform massCheck {\n            in chassisMass = chassis.mass;\n            in engineMass = engine.mass;\n            in gearboxMass = gearbox.mass;\n            in maxMass = this.maxMass;\n            out warning = warningPort.warning;\n        }\n    }\n}",
    "package 'VehicleMassBudget' {\n    attribute def Mass: Real;\n    attribute def MassLimit: Real = 2500;\n    part def Chassis {\n        attribute mass: Mass;\n    }\n    part def Engine {\n        attribute mass: Mass;\n    }\n    part def Transmission {\n        attribute mass: Mass;\n    }\n    part def OtherComponent {\n        attribute mass: Mass;\n    }\n    part def Vehicle {\n        part chassis: Chassis;\n        part engine: Engine;\n        part transmission: Transmission;\n        part otherComponents: OtherComponent[*];\n        attribute totalMass: Real = chassis.mass + engine.mass + transmission.mass + otherComponents.mass->sum();\n        attribute massLimit: MassLimit;\n        constraint massConstraint {\n            totalMass <= massLimit\n        }\n    }\n    part context {\n        part vehicle: Vehicle;\n    }\n}",
    "package 'Vehicle Mass Management' {\n    attribute def Mass: Real;\n    requirement def MassComplianceRequirement {\n        attribute maxTotalMass: Mass = 2500;\n    }\n    port def MassPort {\n        out mass: Mass;\n    }\n    part def Chassis {\n        attribute mass: Mass;\n        port massPort: MassPort {\n            out mass = .mass;\n        }\n    }\n    part def Engine {\n        attribute mass: Mass;\n        port massPort: MassPort {\n            out mass = .mass;\n        }\n    }\n    part def Transmission {\n        attribute mass: Mass;\n        port massPort: MassPort {\n            out mass = .mass;\n        }\n    }\n    part def Vehicle {\n        part chassis: Chassis;\n        part engine: Engine;\n        part transmission: Transmission;\n        port chassisMassPort: ~MassPort = chassis.massPort;\n        port engineMassPort: ~MassPort = engine.massPort;\n        port transmissionMassPort: ~MassPort = transmission.massPort;\n    }\n    action verifyMassCompliance {\n        in chassisMass: Mass;\n        in engineMass: Mass;\n        in transmissionMass: Mass;\n        in maxAllowed: Mass;\n        attribute totalMass: Mass = chassisMass + engineMass + transmissionMass;\n        constraint totalMass <= maxAllowed;\n    }\n    part context {\n        part vehicle: Vehicle;\n        part massReq: MassComplianceRequirement;\n        perform complianceCheck: verifyMassCompliance;\n        flow chassisFlow from vehicle.chassisMassPort.mass to complianceCheck.chassisMass;\n        flow engineFlow from vehicle.engineMassPort.mass to complianceCheck.engineMass;\n        flow transFlow from vehicle.transmissionMassPort.mass to complianceCheck.transmissionMass;\n        flow maxFlow from massReq.maxTotalMass to complianceCheck.maxAllowed;\n    }\n}",
    "package 'WeightManagementSystem' {\n    attribute def ChassisWeight;\n    attribute def EngineWeight;\n    attribute def TransmissionWeight;\n    attribute def TotalWeight;\n    attribute def TotalWeightLimit;\n    attribute def WeightWarning;\n\n    port def ChassisWeightPort {\n        out chassisWeight: ChassisWeight;\n    }\n    port def EngineWeightPort {\n        out engineWeight: EngineWeight;\n    }\n    port def TransmissionWeightPort {\n        out transmissionWeight: TransmissionWeight;\n    }\n    port def WarningPort {\n        out warning: WeightWarning;\n    }\n\n    part context {\n        part chassis {\n            port weightPort: ChassisWeightPort;\n            perform weightProcessing.provideChassisWeight {\n                out chassisWeight = weightPort.chassisWeight;\n            }\n        }\n        part engine {\n            port weightPort: EngineWeightPort;\n            perform weightProcessing.provideEngineWeight {\n                out engineWeight = weightPort.engineWeight;\n            }\n        }\n        part transmission {\n            port weightPort: TransmissionWeightPort;\n            perform weightProcessing.provideTransmissionWeight {\n                out transmissionWeight = weightPort.transmissionWeight;\n            }\n        }\n        part weightManager {\n            port chassisWeightPort: ~ChassisWeightPort;\n            port engineWeightPort: ~EngineWeightPort;\n            port transmissionWeightPort: ~TransmissionWeightPort;\n            port warningPort: WarningPort;\n            perform weightProcessing.computeAndCheck {\n                in chassisWeight = chassisWeightPort.chassisWeight;\n                in engineWeight = engineWeightPort.engineWeight;\n                in transmissionWeight = transmissionWeightPort.transmissionWeight;\n                in limit = 2500;\n                out warning = warningPort.warning;\n            }\n        }\n        part controlSystem {\n            port warningPort: ~WarningPort;\n            perform weightProcessing.handleWarning {\n                in warning = warningPort.warning;\n            }\n        }\n        interface chassisToManager connect chassis.weightPort to weightManager.chassisWeightPort {\n            ref flow references weightProcessing.chassisFlow\n                from source.chassisWeight to target.chassisWeight;\n        }\n        interface engineToManager connect engine.weightPort to weightManager.engineWeightPort {\n            ref flow references weightProcessing.engineFlow\n                from source.engineWeight to target.engineWeight;\n        }\n        interface transmissionToManager connect transmission.weightPort to weightManager.transmissionWeightPort {\n            ref flow references weightProcessing.transmissionFlow\n                from source.transmissionWeight to target.transmissionWeight;\n        }\n        interface managerToControl connect weightManager.warningPort to controlSystem.warningPort {\n            ref flow references weightProcessing.warningFlow\n                from source.warning to target.warning;\n        }\n    }\n    action weightProcessing {\n        action provideChassisWeight { out chassisWeight: ChassisWeight; }\n        action provideEngineWeight { out engineWeight: EngineWeight; }\n        action provideTransmissionWeight { out transmissionWeight: TransmissionWeight; }\n        action computeTotal {\n            in chassisWeight: ChassisWeight;\n            in engineWeight: EngineWeight;\n            in transmissionWeight: TransmissionWeight;\n            out total: TotalWeight;\n        }\n        action checkLimit {\n            in total: TotalWeight;\n            in limit: TotalWeightLimit;\n            out warning: WeightWarning;\n        }\n        action handleWarning { in warning: WeightWarning; }\n        succession flow chassisFlow from provideChassisWeight.chassisWeight to computeTotal.chassisWeight;\n        succession flow engineFlow from provideEngineWeight.engineWeight to computeTotal.engineWeight;\n        succession flow transmissionFlow from provideTransmissionWeight.transmissionWeight to computeTotal.transmissionWeight;\n        succession flow totalFlow from computeTotal.total to checkLimit.total;\n        succession flow limitFlow from weightProcessing.limit to checkLimit.limit;\n        succession flow warningFlow from checkLimit.warning to handleWarning.warning;\n    }\n}",
    "package 'VehicleSystem' {\n    attribute def Mass: Real;\n    attribute def Force: Real;\n    attribute def Velocity: Real;\n    attribute def Time: Real;\n    \n    part def Chassis {\n        attribute mass: Mass;\n    }\n    \n    part def Engine {\n        attribute mass: Mass;\n    }\n    \n    part def Transmission {\n        attribute mass: Mass;\n    }\n    \n    part def Vehicle {\n        part chassis: Chassis;\n        part engine: Engine;\n        part transmission: Transmission;\n        attribute totalMass: Mass;\n        \n        constraint totalMassConstraint {\n            totalMass = chassis.mass + engine.mass + transmission.mass;\n            totalMass <= 2500.0;\n        }\n    }\n    \n    constraint def Dynamics {\n        attribute m: Mass;\n        attribute F: Force;\n        attribute v0: Velocity;\n        attribute vf: Velocity;\n        attribute t: Time;\n        \n        constraint massPositive { m > 0.0; }\n        constraint newtonLaw { F = m * (vf - v0) / t; }\n    }\n    \n    part context vehicleScenario {\n        part vehicle: Vehicle;\n        attribute F: Force;\n        attribute v0: Velocity;\n        attribute vf: Velocity;\n        attribute t: Time;\n        \n        constraint dynamicsConstraint: Dynamics;\n        bind dynamicsConstraint.m = vehicle.totalMass;\n        bind dynamicsConstraint.F = F;\n        bind dynamicsConstraint.v0 = v0;\n        bind dynamicsConstraint.vf = vf;\n        bind dynamicsConstraint.t = t;\n    }\n}",
    "package 'VehicleMaintenanceSystem' {\n    attribute def Time;\n    attribute def Duration;\n    attribute def NextMaintenanceTime: Time;\n    attribute def MaintenanceInterval: Duration;\n    attribute def MaxAllowedTemperature: Real;\n    attribute def VehicleStatus;\n    \n    port def TimePort {\n        out currentTime: Time;\n    }\n    \n    stateMachine def VehicleStateMachine {\n        state healthy;\n        state underMaintenance {\n            constraint: duration() <= 48h;\n        }\n        transition from healthy to underMaintenance {\n            trigger: timerExpired('maintenanceTimer');\n            constraint: startTime(underMaintenance) > ..nextMaintenanceTime and \n                        startTime(underMaintenance) <= ..nextMaintenanceTime + 2s;\n        }\n        transition from underMaintenance to healthy {\n            effect: ..nextMaintenanceTime = ..timePort.currentTime + ..maintenanceInterval;\n        }\n    }\n    \n    part def Vehicle {\n        attribute nextMaintenanceTime: NextMaintenanceTime;\n        attribute maintenanceInterval: MaintenanceInterval;\n        attribute maxAllowedTemperature: MaxAllowedTemperature;\n        port timePort: in TimePort;\n        part stateMachine: VehicleStateMachine {\n            state healthy {\n                entry: setTimer('maintenanceTimer', ..nextMaintenanceTime);\n            }\n        }\n    }\n    \n    part def MaintenanceScheduler {\n        port timePort: out TimePort;\n    }\n    \n    part context {\n        part scheduler: MaintenanceScheduler;\n        part vehicle: Vehicle;\n        interface timeService connect scheduler.timePort to vehicle.timePort;\n    }\n}",
    "package 'VehicleSystem' {\n    attribute def Mass;\n    attribute def Torque;\n    attribute def Speed;\n    \n    port def TorquePort {\n        out torque: Torque;\n    }\n    port def SpeedPort {\n        out speed: Speed;\n    }\n    \n    constraint def MassConstraints {\n        attribute curbWeight: Mass;\n        attribute fuelMass: Mass;\n        attribute maxMassLimit: Mass;\n        constraint totalMass: curbWeight + fuelMass <= maxMassLimit;\n        constraint positiveFuel: fuelMass > 0;\n    }\n    \n    part context {\n        part vehicle {\n            attribute curbWeight: Mass;\n            attribute fuelMass: Mass;\n            attribute maxMassLimit: Mass;\n            satisfy massConstraints: MassConstraints {\n                curbWeight = vehicle.curbWeight;\n                fuelMass = vehicle.fuelMass;\n                maxMassLimit = vehicle.maxMassLimit;\n            }\n        }\n        \n        part engine {\n            port speedPort: ~SpeedPort;\n            port torquePort: TorquePort;\n            perform powertrain.generateTorque {\n                in speed = speedPort.speed;\n                out torque = torquePort.torque;\n            }\n        }\n        \n        part clutch {\n            port inTorquePort: ~TorquePort;\n            port outTorquePort: TorquePort;\n            perform powertrain.transmitTorque {\n                in inputTorque = inTorquePort.torque;\n                out outputTorque = outTorquePort.torque;\n            }\n        }\n        \n        part transmission {\n            port inTorquePort: ~TorquePort;\n            port outTorquePort: TorquePort;\n            perform powertrain.transmitTorque {\n                in inputTorque = inTorquePort.torque;\n                out outputTorque = outTorquePort.torque;\n            }\n        }\n        \n        part driveSystem {\n            port torquePort: ~TorquePort;\n        }\n        \n        part speedSource {\n            port speedPort: SpeedPort;\n        }\n        \n        interface speedToEngine connect speedSource.speedPort to engine.speedPort {\n            ref flow references powertrain.speedFlow from source.speed to target.speed;\n        }\n        interface engineToClutch connect engine.torquePort to clutch.inTorquePort {\n            ref flow references powertrain.torqueFlow1 from source.torque to target.torque;\n        }\n        interface clutchToTransmission connect clutch.outTorquePort to transmission.inTorquePort {\n            ref flow references powertrain.torqueFlow2 from source.torque to target.torque;\n        }\n        interface transmissionToDrive connect transmission.outTorquePort to driveSystem.torquePort {\n            ref flow references powertrain.torqueFlow3 from source.torque to target.torque;\n        }\n    }\n    \n    action powertrain {\n        action generateTorque {\n            in speed: Speed;\n            out torque: Torque;\n        }\n        action transmitTorque {\n            in inputTorque: Torque;\n            out outputTorque: Torque;\n        }\n        \n        part gen: generateTorque;\n        part clutchXmit: transmitTorque;\n        part transXmit: transmitTorque;\n        \n        flow speedFlow: Speed from external to gen.speed;\n        flow torqueFlow1 from gen.torque to clutchXmit.inputTorque;\n        flow torqueFlow2 from clutchXmit.outputTorque to transXmit.inputTorque;\n        flow torqueFlow3 from transXmit.outputTorque to external;\n    }\n}",
    "package 'VehicleSystem' {\n    attribute def Mass;\n    attribute def Torque;\n    port def TorqueOutputPort {\n        out torque: Torque;\n    }\n    port def TorqueInputPort {\n        in torque: Torque;\n    }\n    part context {\n        part vehicle {\n            attribute dryMass: Mass;\n            attribute fuelMass: Mass;\n            attribute maxFuelMass: Mass;\n            constraint fullTankMass {\n                expression: dryMass + maxFuelMass <= 2000;\n            }\n            constraint emptyTankMass {\n                expression: dryMass <= 1500;\n            }\n            part engine {\n                port torqueOutput: TorqueOutputPort;\n                constraint torquePerformance {\n                    expression: \"Must deliver torque per speed-torque curve (Table 1)\";\n                }\n                perform powertrainOperation.generateTorque {\n                    out torque = torqueOutput.torque;\n                }\n            }\n            part transmission {\n                port torqueInput: TorqueInputPort;\n                perform powertrainOperation.transmitTorque {\n                    in torque = torqueInput.torque;\n                }\n            }\n            interface clutchInterface connect engine.torqueOutput to transmission.torqueInput {\n                ref flow references powertrainOperation.torqueFlow\n                    from source.torque to target.torque;\n            }\n        }\n    }\n    action powertrainOperation {\n        action generateTorque { out torque: Torque; }\n        action transmitTorque { in torque: Torque; }\n        succession flow torqueFlow from generateTorque.torque to transmitTorque.torque;\n    }\n}",
    "package 'VehicleProject' {\n    value type Mass {\n        unit = 'kg';\n        value = Real;\n    }\n    value type Torque {\n        unit = 'N*m';\n        value = Real;\n    }\n    value type Speed {\n        unit = 'rpm';\n        value = Real;\n    }\n    port def TorquePort {\n        in torque: Torque;\n    }\n    constraint def TorqueCurveConstraint {\n        attribute speed: Speed;\n        attribute torque: Torque;\n        constraint torqueCurve: \"torque = f(speed) per performance table\";\n    }\n    part def Engine {\n        attribute torque: Torque;\n        attribute speed: Speed;\n        port clutchInterface: TorquePort;\n        constraint torqueCurve: TorqueCurveConstraint {\n            bind torque to self.torque;\n            bind speed to self.speed;\n        }\n    }\n    part def Transmission {\n        port clutchInterface: ~TorquePort;\n    }\n    part def Vehicle {\n        attribute emptyMass: Mass;\n        attribute fueledMass: Mass;\n        constraint massConstraints {\n            constraint emptyMass <= 1500;\n            constraint fueledMass <= 2000;\n        }\n        part engine: Engine;\n        part transmission: Transmission;\n        connection engineToTransmission connect engine.clutchInterface to transmission.clutchInterface;\n    }\n}",
    "package 'VehicleSystem' {\n    attribute def Mass;\n    attribute def Torque;\n    port def TorquePort {\n        out torque: Torque;\n    }\n    part context {\n        part vehicle {\n            attribute curbMass: Mass;\n            attribute fuelMass: Mass;\n        }\n        part engine {\n            port torqueOut: TorquePort;\n            perform powerTransmission.generateTorque {\n                out torque = torqueOut.torque;\n            }\n        }\n        part clutch {\n            port torqueIn: ~TorquePort;\n            port torqueOut: TorquePort;\n            perform powerTransmission.transmitTorque {\n                in torque = torqueIn.torque;\n                out torque = torqueOut.torque;\n            }\n        }\n        part gearbox {\n            port torqueIn: ~TorquePort;\n            perform powerTransmission.deliverTorque {\n                in torque = torqueIn.torque;\n            }\n        }\n        interface engineToClutch connect engine.torqueOut to clutch.torqueIn {\n            ref flow references powerTransmission.torqueFlow1\n                from source.torque to target.torque;\n        }\n        interface clutchToGearbox connect clutch.torqueOut to gearbox.torqueIn {\n            ref flow references powerTransmission.torqueFlow2\n                from source.torque to target.torque;\n        }\n    }\n    action powerTransmission {\n        action generateTorque { out torque: Torque; }\n        succession flow torqueFlow1 from generateTorque.torque to transmitTorque.torque;\n        action transmitTorque { in torque; out torque: Torque; }\n        succession flow torqueFlow2 from transmitTorque.torque to deliverTorque.torque;\n        action deliverTorque { in torque: Torque; }\n    }\n    requirement MassLimitFull {\n        id: 'REQ1';\n        text: \"When fuel tank is full, total vehicle mass must not exceed 2000 kg\";\n    }\n    requirement MassLimitEmpty {\n        id: 'REQ2';\n        text: \"When fuel tank is empty, total vehicle mass must not exceed 1500 kg\";\n    }\n    requirement TorqueTransmission {\n        id: 'REQ3';\n        text: \"Engine must generate specified torque characteristics and transmit to gearbox via clutch\";\n    }\n}",
    "package 'VehiclePerformanceAnalysis' {\n    attribute def CurbWeight: Real;\n    attribute def Payload: Real;\n    attribute def WheelDiameter: Real;\n    attribute def TransmissionEfficiency: Real;\n    attribute def UrbanFuelEcon: Real;\n    attribute def HighwayFuelEcon: Real;\n    attribute def DrivingCyclePoint {\n        attribute time: Real;\n        attribute position: Real;\n        attribute speed: Real;\n    }\n    attribute def DrivingCycle: DrivingCyclePoint[*];\n    attribute def PerformancePoint {\n        attribute time: Real;\n        attribute power: Real;\n        attribute acceleration: Real;\n        attribute speed: Real;\n        attribute position: Real;\n    }\n    attribute def PerformanceSeries: PerformancePoint[*];\n    attribute def OverallFuelEconomy: Real;\n    attribute def EnergyConsumptionTarget: Real;\n    attribute def ComplianceResult: Boolean;\n    \n    port def ConfigPort {\n        attribute curbWeight: CurbWeight;\n        attribute payload: Payload;\n        attribute wheelDiameter: WheelDiameter;\n        attribute transmissionEfficiency: TransmissionEfficiency;\n        attribute urbanFuelEcon: UrbanFuelEcon;\n        attribute highwayFuelEcon: HighwayFuelEcon;\n    }\n    port def CyclePort {\n        attribute drivingCycle: DrivingCycle;\n    }\n    port def TargetPort {\n        attribute target: EnergyConsumptionTarget;\n    }\n    port def PerformancePort {\n        attribute performance: PerformanceSeries;\n    }\n    port def EconomyPort {\n        attribute fuelEconomy: OverallFuelEconomy;\n    }\n    port def CompliancePort {\n        attribute compliance: ComplianceResult;\n    }\n    \n    part context {\n        part user {\n            port configPort: ConfigPort;\n            port cyclePort: CyclePort;\n            port targetPort: TargetPort;\n            port performancePort: ~PerformancePort;\n            port economyPort: ~EconomyPort;\n            port compliancePort: ~CompliancePort;\n        }\n        part analyzer {\n            port configPort: ~ConfigPort;\n            port cyclePort: ~CyclePort;\n            port targetPort: ~TargetPort;\n            port performancePort: PerformancePort;\n            port economyPort: EconomyPort;\n            port compliancePort: CompliancePort;\n            \n            perform analysis.calculatePerformance {\n                in curbWeight = configPort.curbWeight;\n                in payload = configPort.payload;\n                in wheelDiameter = configPort.wheelDiameter;\n                in transmissionEfficiency = configPort.transmissionEfficiency;\n                in drivingCycle = cyclePort.drivingCycle;\n                out performance = performancePort.performance;\n            }\n            perform analysis.calculateFuelEconomy {\n                in performance = performancePort.performance;\n                in urbanFuelEcon = configPort.urbanFuelEcon;\n                in highwayFuelEcon = configPort.highwayFuelEcon;\n                out fuelEconomy = economyPort.fuelEconomy;\n            }\n            perform analysis.verifyCompliance {\n                in fuelEconomy = economyPort.fuelEconomy;\n                in target = targetPort.target;\n                out compliance = compliancePort.compliance;\n            }\n        }\n        interface configConnect connect user.configPort to analyzer.configPort;\n        interface cycleConnect connect user.cyclePort to analyzer.cyclePort;\n        interface targetConnect connect user.targetPort to analyzer.targetPort;\n        interface perfConnect connect analyzer.performancePort to user.performancePort;\n        interface economyConnect connect analyzer.economyPort to user.economyPort;\n        interface complianceConnect connect analyzer.compliancePort to user.compliancePort;\n    }\n    \n    action analysis {\n        action calculatePerformance {\n            in curbWeight: CurbWeight;\n            in payload: Payload;\n            in wheelDiameter: WheelDiameter;\n            in transmissionEfficiency: TransmissionEfficiency;\n            in drivingCycle: DrivingCycle;\n            out performance: PerformanceSeries;\n        }\n        action calculateFuelEconomy {\n            in performance: PerformanceSeries;\n            in urbanFuelEcon: UrbanFuelEcon;\n            in highwayFuelEcon: HighwayFuelEcon;\n            out fuelEconomy: OverallFuelEconomy;\n        }\n        action verifyCompliance {\n            in fuelEconomy: OverallFuelEconomy;\n            in target: EnergyConsumptionTarget;\n            out compliance: ComplianceResult;\n        }\n        succession flow perfToFuel from calculatePerformance.performance to calculateFuelEconomy.performance;\n        succession flow fuelToCompliance from calculateFuelEconomy.fuelEconomy to verifyCompliance.fuelEconomy;\n    }\n}",
    "package 'FuelEconomySimulation' {\n    attribute def VehicleParameters;\n    attribute def DrivingScenario;\n    attribute def Power;\n    attribute def Energy;\n    attribute def Acceleration;\n    attribute def Volume;\n    attribute def MPG;\n    attribute def LitersPer100km;\n    attribute def Boolean;\n    port def InputPort {\n        in vehicleParams: VehicleParameters;\n        in scenario: DrivingScenario;\n    }\n    port def OutputPort {\n        out fuelEconomyMPG: MPG;\n        out fuelEconomyLiters: LitersPer100km;\n        out meetsRequirement: Boolean;\n    }\n    part context {\n        part user {\n            port inputPort: ~InputPort;\n            port outputPort: ~OutputPort;\n            perform simulateAndVerify.sendInputs {\n                out vehicleParams = inputPort.vehicleParams;\n                out scenario = inputPort.scenario;\n            }\n            perform simulateAndVerify.receiveResults {\n                in fuelEconomyMPG = outputPort.fuelEconomyMPG;\n                in fuelEconomyLiters = outputPort.fuelEconomyLiters;\n                in meetsRequirement = outputPort.meetsRequirement;\n            }\n        }\n        part simulationSystem {\n            port inputPort: InputPort;\n            port outputPort: OutputPort;\n            perform simulateAndVerify {\n                in vehicleParams = inputPort.vehicleParams;\n                in scenario = inputPort.scenario;\n                out fuelEconomyMPG = outputPort.fuelEconomyMPG;\n                out fuelEconomyLiters = outputPort.fuelEconomyLiters;\n                out meetsRequirement = outputPort.meetsRequirement;\n            }\n        }\n        interface userToSystem connect user.inputPort to simulationSystem.inputPort {\n            ref flow vehicleParamsFlow from source.vehicleParams to target.vehicleParams;\n            ref flow scenarioFlow from source.scenario to target.scenario;\n        }\n        interface systemToUser connect simulationSystem.outputPort to user.outputPort {\n            ref flow mpgFlow from source.fuelEconomyMPG to target.fuelEconomyMPG;\n            ref flow litersFlow from source.fuelEconomyLiters to target.fuelEconomyLiters;\n            ref flow meetsReqFlow from source.meetsRequirement to target.meetsRequirement;\n        }\n    }\n    action simulateAndVerify {\n        in vehicleParams: VehicleParameters;\n        in scenario: DrivingScenario;\n        out fuelEconomyMPG: MPG;\n        out fuelEconomyLiters: LitersPer100km;\n        out meetsRequirement: Boolean;\n        action sendInputs {\n            out vehicleParams: VehicleParameters;\n            out scenario: DrivingScenario;\n        }\n        action calculateWheelPower {\n            in scenario: DrivingScenario;\n            out wheelPower: Power;\n        }\n        action applyVehicleDynamics {\n            in wheelPower: Power;\n            in vehicleParams: VehicleParameters;\n            out acceleration: Acceleration;\n            out energyConsumption: Energy;\n        }\n        action estimateEnginePower {\n            in wheelPower: Power;\n            in transmissionEfficiency: Real;\n            out enginePower: Power;\n        }\n        action calculateFuelConsumption {\n            in enginePower: Power;\n            in scenario: DrivingScenario;\n            out fuelConsumption: Volume;\n        }\n        action calculateFuelEconomy {\n            in fuelConsumption: Volume;\n            in scenario: DrivingScenario;\n            out fuelEconomyMPG: MPG;\n            out fuelEconomyLiters: LitersPer100km;\n        }\n        action verifyRequirement {\n            in fuelEconomyMPG: MPG;\n            out meetsRequirement: Boolean;\n        }\n        action receiveResults {\n            in fuelEconomyMPG: MPG;\n            in fuelEconomyLiters: LitersPer100km;\n            in meetsRequirement: Boolean;\n        }\n        bind calculateWheelPower.scenario = scenario;\n        bind applyVehicleDynamics.vehicleParams = vehicleParams;\n        bind estimateEnginePower.transmissionEfficiency = vehicleParams.transmissionEfficiency;\n        bind calculateFuelConsumption.scenario = scenario;\n        bind calculateFuelEconomy.scenario = scenario;\n        bind verifyRequirement.fuelEconomyMPG = calculateFuelEconomy.fuelEconomyMPG;\n        bind fuelEconomyMPG = calculateFuelEconomy.fuelEconomyMPG;\n        bind fuelEconomyLiters = calculateFuelEconomy.fuelEconomyLiters;\n        bind meetsRequirement = verifyRequirement.meetsRequirement;\n        succession flow wheelPowerToDynamics from calculateWheelPower.wheelPower to applyVehicleDynamics.wheelPower;\n        succession flow wheelPowerToEngine from calculateWheelPower.wheelPower to estimateEnginePower.wheelPower;\n        succession flow enginePowerToFuel from estimateEnginePower.enginePower to calculateFuelConsumption.enginePower;\n        succession flow fuelConsumptionToEconomy from calculateFuelConsumption.fuelConsumption to calculateFuelEconomy.fuelConsumption;\n        succession flow economyToVerify from calculateFuelEconomy.fuelEconomyMPG to verifyRequirement.fuelEconomyMPG;\n    }\n}",
    "package 'EngineSelectionSystem' {\n    attribute def Power;\n    attribute def Mass;\n    attribute def Efficiency;\n    attribute def Cost;\n    attribute def EvaluationScore;\n    part def Engine {\n        attribute type: string;\n        attribute power: Power;\n        attribute mass: Mass;\n        attribute efficiency: Efficiency;\n        attribute cost: Cost;\n    }\n    port def EnginesPort {\n        out engines: Engine[*];\n    }\n    port def BestEnginePort {\n        in bestEngine: Engine;\n    }\n    part context {\n        part engineSelectionSystem {\n            port enginesPort: ~EnginesPort;\n            port bestEnginePort: BestEnginePort;\n            perform selectionProcess.conductAnalysis {\n                in engines = enginesPort.engines;\n                out bestEngine = bestEnginePort.bestEngine;\n            }\n        }\n        part engines {\n            port enginesPort: EnginesPort;\n        }\n        interface enginesToSystem connect engines.enginesPort to engineSelectionSystem.enginesPort {\n            ref flow references selectionProcess.enginesFlow\n                from source.engines to target.engines;\n        }\n    }\n    action selectionProcess {\n        action conductAnalysis {\n            in engines: Engine[*];\n            out bestEngine: Engine;\n            action aggregateKPIs {\n                in engines: Engine[*];\n                out enginesWithKPIs: Engine[*];\n            }\n            action evaluateEngines {\n                in engines: Engine[*];\n                out scores: EvaluationScore[*];\n            }\n            action selectOptimal {\n                in engines: Engine[*];\n                in scores: EvaluationScore[*];\n                out bestEngine: Engine;\n            }\n            succession flow enginesFlow from engines to aggregateKPIs.engines;\n            succession flow kpisFlow from aggregateKPIs.enginesWithKPIs to evaluateEngines.engines;\n            succession flow scoresFlow from evaluateEngines.scores to selectOptimal.scores;\n            succession flow enginesToSelectFlow from aggregateKPIs.enginesWithKPIs to selectOptimal.engines;\n            succession flow bestEngineFlow from selectOptimal.bestEngine to bestEngine;\n        }\n    }\n}",
    "package 'VehicleQualityInspection' {\n    attribute def Weight;\n    attribute def EvaluationResult: enum {qualified, unqualified};\n    port def WeightDataPort {\n        in rawWeight: Weight;\n    }\n    port def ResultPort {\n        out result: EvaluationResult;\n    }\n    part context {\n        part vehicle {\n            attribute curbWeight: Weight;\n            port weightDataPort: ~WeightDataPort;\n            perform provideWeight {\n                out rawWeight = weightDataPort.rawWeight;\n            }\n        }\n        part qualityInspectionSystem {\n            port weightDataPort: WeightDataPort;\n            port resultPort: ResultPort;\n            perform inspectionProcess.performInspection {\n                in rawWeight = weightDataPort.rawWeight;\n                out result = resultPort.result;\n            }\n        }\n        interface vehicleToSystem connect vehicle.weightDataPort to qualityInspectionSystem.weightDataPort {\n            ref flow references inspectionProcess.dataFlow\n                from source.rawWeight to target.rawWeight;\n        }\n    }\n    action inspectionProcess {\n        action collectData { in rawWeight: Weight; }\n        action processData { in rawWeight; out processedWeight: Weight; }\n        action evaluateResult { \n            in processedWeight; \n            out result: EvaluationResult;\n            constraint {\n                result = if processedWeight <= 2500 then \n                    EvaluationResult.qualified \n                else \n                    EvaluationResult.unqualified;\n            }\n        }\n        succession flow dataFlow from collectData.rawWeight to processData.rawWeight;\n        succession flow evaluationFlow from processData.processedWeight to evaluateResult.processedWeight;\n    }\n}",
    "package 'MassVerificationSystem' {\n    attribute def Mass;\n    attribute def Status;\n    port def MassPort {\n        out mass: Mass;\n    }\n    port def StatusPort {\n        out status: Status;\n    }\n    part context {\n        part vehicle { }\n        part weighingEquipment {\n            port massPort: MassPort;\n            perform verifyMass.measureMass {\n                out mass = massPort.mass;\n            }\n        }\n        part massVerificationUnit {\n            port massPort: ~MassPort;\n            port statusPort: StatusPort;\n            perform verifyMass.evaluateMass {\n                in mass = massPort.mass;\n                out status = statusPort.status;\n            }\n        }\n        interface massFlow connect weighingEquipment.massPort to massVerificationUnit.massPort {\n            ref flow references verifyMass.massFlow \n                from source.mass to target.mass;\n        }\n    }\n    action verifyMass {\n        action measureMass { out mass: Mass; }\n        action evaluateMass { in mass: Mass; out status: Status; }\n        succession flow massFlow from measureMass.mass to evaluateMass.mass;\n    }\n}",
    "package 'TransportationSystem' {\n    attribute def BoardingCmd;\n    attribute def AlightingCmd;\n    attribute def EnvironmentalData;\n    attribute def RefuelingCmd;\n    attribute def TravelStatus;\n    port def UserCmdPort {\n        out boardingCmd: BoardingCmd;\n        out alightingCmd: AlightingCmd;\n    }\n    port def VehicleUserPort {\n        in boardingCmd: BoardingCmd;\n        in alightingCmd: AlightingCmd;\n    }\n    port def EnvPort {\n        out environmentalData: EnvironmentalData;\n    }\n    port def VehicleEnvPort {\n        in environmentalData: EnvironmentalData;\n    }\n    port def RefuelingPort {\n        in refuelingCmd: RefuelingCmd;\n    }\n    port def GasStationPort {\n        in refuelingCmd: RefuelingCmd;\n    }\n    part def Passenger {\n        port userCmdPort: UserCmdPort;\n    }\n    part context {\n        part driver {\n            port userCmdPort: UserCmdPort;\n            perform TransportationAction.driverBoarding {\n                out boardingCmd = userCmdPort.boardingCmd;\n            }\n            perform TransportationAction.driverAlighting {\n                out alightingCmd = userCmdPort.alightingCmd;\n            }\n        }\n        part passenger: Passenger {\n            port userCmdPort: UserCmdPort;\n            perform TransportationAction.passengerBoarding {\n                out boardingCmd = userCmdPort.boardingCmd;\n            }\n            perform TransportationAction.passengerAlighting {\n                out alightingCmd = userCmdPort.alightingCmd;\n            }\n        }\n        part vehicle {\n            port userPort: ~VehicleUserPort;\n            port envPort: ~VehicleEnvPort;\n            port refuelingPort: ~RefuelingPort;\n            perform TransportationAction.driverBoarding {\n                in boardingCmd = userPort.boardingCmd;\n            }\n            perform TransportationAction.passengerBoarding {\n                in boardingCmd = userPort.boardingCmd;\n            }\n            perform TransportationAction.traveling {\n                in environmentalData = envPort.environmentalData;\n                perform refueling {\n                    out refuelingCmd = refuelingPort.refuelingCmd;\n                }\n            }\n            perform TransportationAction.driverAlighting {\n                in alightingCmd = userPort.alightingCmd;\n            }\n            perform TransportationAction.passengerAlighting {\n                in alightingCmd = userPort.alightingCmd;\n            }\n        }\n        part environment {\n            port envPort: EnvPort;\n        }\n        part gasStation {\n            port refuelingPort: GasStationPort;\n        }\n        interface driverToVehicle connect driver.userCmdPort to vehicle.userPort {\n            ref flow references boardingFlow from source.boardingCmd to target.boardingCmd;\n            ref flow references alightingFlow from source.alightingCmd to target.alightingCmd;\n        }\n        interface passengerToVehicle connect passenger.userCmdPort to vehicle.userPort {\n            ref flow references boardingFlow from source.boardingCmd to target.boardingCmd;\n            ref flow references alightingFlow from source.alightingCmd to target.alightingCmd;\n        }\n        interface envToVehicle connect environment.envPort to vehicle.envPort {\n            ref flow references envDataFlow from source.environmentalData to target.environmentalData;\n        }\n        interface vehicleToGasStation connect vehicle.refuelingPort to gasStation.refuelingPort {\n            ref flow references refuelingFlow from source.refuelingCmd to target.refuelingCmd;\n        }\n    }\n    action TransportationAction {\n        action driverBoarding { in boardingCmd: BoardingCmd; }\n        action passengerBoarding { in boardingCmd: BoardingCmd; }\n        action traveling {\n            in environmentalData: EnvironmentalData;\n            action moving;\n            action refueling { out refuelingCmd: RefuelingCmd; }\n            during moving do refueling;\n        }\n        action driverAlighting { in alightingCmd: AlightingCmd; }\n        action passengerAlighting { in alightingCmd: AlightingCmd; }\n        succession flow from driverBoarding to traveling;\n        succession flow from traveling to driverAlighting;\n    }\n}",
    "package 'Transportation System' {\n    attribute def EnterCmd;\n    attribute def ExitCmd;\n    attribute def DriveCmd;\n    attribute def EnvironmentalCondition;\n    attribute def Fuel;\n    attribute def RefuelCmd;\n    port def UserCmdPort {\n        out enterCmd: EnterCmd;\n        out exitCmd: ExitCmd;\n    }\n    port def DriveCmdPort {\n        out driveCmd: DriveCmd;\n    }\n    port def EnvironmentalPort {\n        out condition: EnvironmentalCondition;\n    }\n    port def RefuelCmdPort {\n        out refuelCmd: RefuelCmd;\n    }\n    port def FuelPort {\n        in fuel: Fuel;\n    }\n    part context {\n        part driver {\n            port userCmdPort: UserCmdPort;\n            port driveCmdPort: DriveCmdPort;\n            port refuelCmdPort: RefuelCmdPort;\n            perform transport.enterVehicle {\n                out enterCmd = userCmdPort.enterCmd;\n            }\n            perform transport.drive {\n                out driveCmd = driveCmdPort.driveCmd;\n            }\n            perform transport.requestRefuel {\n                out refuelCmd = refuelCmdPort.refuelCmd;\n            }\n            perform transport.exitVehicle {\n                out exitCmd = userCmdPort.exitCmd;\n            }\n        }\n        part passengers {\n            port userCmdPort: UserCmdPort;\n            perform transport.enterVehicle {\n                out enterCmd = userCmdPort.enterCmd;\n            }\n            perform transport.exitVehicle {\n                out exitCmd = userCmdPort.exitCmd;\n            }\n        }\n        part vehicle {\n            port userCmdPort: ~UserCmdPort;\n            port driveCmdPort: ~DriveCmdPort;\n            port environmentalPort: ~EnvironmentalPort;\n            port refuelCmdPort: ~RefuelCmdPort;\n            port fuelPort: FuelPort;\n            perform transport.enterVehicle {\n                in enterCmd = userCmdPort.enterCmd;\n            }\n            perform transport.drive {\n                in driveCmd = driveCmdPort.driveCmd;\n                in condition = environmentalPort.condition;\n            }\n            perform transport.refuel {\n                in refuelCmd = refuelCmdPort.refuelCmd;\n                in fuel = fuelPort.fuel;\n            }\n            perform transport.exitVehicle {\n                in exitCmd = userCmdPort.exitCmd;\n            }\n        }\n        part environment {\n            port environmentalPort: EnvironmentalPort;\n            perform transport.drive {\n                out condition = environmentalPort.condition;\n            }\n        }\n        part gasStation {\n            port fuelPort: ~FuelPort;\n            perform transport.refuel {\n                out fuel = fuelPort.fuel;\n            }\n        }\n        interface userToVehicle connect driver.userCmdPort, passengers.userCmdPort to vehicle.userCmdPort {\n            ref flow references transport.enterFlow from source.enterCmd to target.enterCmd;\n            ref flow references transport.exitFlow from source.exitCmd to target.exitCmd;\n        }\n        interface driverToVehicle connect driver.driveCmdPort to vehicle.driveCmdPort {\n            ref flow references transport.driveFlow from source.driveCmd to target.driveCmd;\n        }\n        interface envToVehicle connect environment.environmentalPort to vehicle.environmentalPort {\n            ref flow references transport.envFlow from source.condition to target.condition;\n        }\n        interface driverToVehicleRefuel connect driver.refuelCmdPort to vehicle.refuelCmdPort {\n            ref flow references transport.refuelCmdFlow from source.refuelCmd to target.refuelCmd;\n        }\n        interface gasStationToVehicle connect gasStation.fuelPort to vehicle.fuelPort {\n            ref flow references transport.fuelFlow from source.fuel to target.fuel;\n        }\n    }\n    action transport {\n        action enterVehicle {\n            out enterCmd: EnterCmd;\n            in enterCmd;\n        }\n        succession flow enterFlow from enterVehicle.enterCmd[source] to enterVehicle.enterCmd[target];\n        action drive {\n            out driveCmd: DriveCmd;\n            out condition: EnvironmentalCondition;\n            in driveCmd;\n            in condition;\n        }\n        succession flow driveFlow from drive.driveCmd[source] to drive.driveCmd[target];\n        succession flow envFlow from drive.condition[source] to drive.condition[target];\n        action refuel {\n            out refuelCmd: RefuelCmd;\n            out fuel: Fuel;\n            in refuelCmd;\n            in fuel;\n        }\n        succession flow refuelCmdFlow from refuel.refuelCmd[source] to refuel.refuelCmd[target];\n        succession flow fuelFlow from refuel.fuel[source] to refuel.fuel[target];\n        action exitVehicle {\n            out exitCmd: ExitCmd;\n            in exitCmd;\n        }\n        succession flow exitFlow from exitVehicle.exitCmd[source] to exitVehicle.exitCmd[target];\n        succession from enterVehicle to drive;\n        succession from drive to refuel;\n        succession from refuel to exitVehicle;\n    }\n}",
    "package 'Vehicle Product Line' {\n    enum EngineType { FourCylinder; SixCylinder; }\n    enum TransmissionType { Manual; Automatic; }\n    enum CylinderDiameter { Small = 70; Large = 100; }\n    \n    part def Engine {\n        attribute type: EngineType;\n        attribute cylinderDiameter: CylinderDiameter;\n    }\n    \n    part def Transmission {\n        attribute type: TransmissionType;\n    }\n    \n    part def Vehicle {\n        part engine: Engine;\n        part transmission: Transmission;\n    }\n    \n    constraint def CombinationRules {\n        parameter engine: Engine;\n        parameter transmission: Transmission;\n        constraint {\n            (transmission.type == TransmissionType::Manual) implies \n                (engine.type == EngineType::FourCylinder) and\n            (engine.type == EngineType::SixCylinder) implies \n                (transmission.type == TransmissionType::Automatic)\n        }\n    }\n    \n    part Vehicle {\n        satisfy rules: CombinationRules {\n            engine = this.engine;\n            transmission = this.transmission;\n        }\n    }\n}",
    "package 'EngineSystem' {\n    enum CylinderDiameter {\n        d70mm,\n        d100mm\n    }\n    block Cylinder {\n        attribute diameter: CylinderDiameter;\n    }\n    block Engine {\n        attribute numCylinders: Integer;\n        attribute cylinderDiameter: CylinderDiameter;\n        part cylinders: Cylinder[0..*];\n        constraint {\n            (numCylinders = 4) or (numCylinders = 6)\n        }\n        constraint {\n            cylinders->size() = numCylinders\n        }\n        constraint {\n            cylinders->forAll(cyl | cyl.diameter = cylinderDiameter)\n        }\n    }\n}",
    "package 'Automotive Configuration' {\n    enum def EngineType { FourCylinder, SixCylinder }\n    enum def TransmissionType { Manual, Automatic }\n    enum def CylinderDiameter { '70mm', '100mm' }\n    \n    part def Engine {\n        attribute type: EngineType;\n        attribute cylinderDiameter: CylinderDiameter;\n    }\n    \n    part def Transmission {\n        attribute type: TransmissionType;\n    }\n    \n    part def Vehicle {\n        part engine: Engine;\n        part transmission: Transmission;\n        \n        constraint {\n            engine.type = EngineType.FourCylinder implies transmission.type = TransmissionType.Manual;\n            engine.type = EngineType.SixCylinder implies transmission.type = TransmissionType.Automatic;\n        }\n    }\n}",
    "package 'System' {\n    attribute def MessageFormat;\n    attribute def DataFormat;\n    port def SoftwareInterface {\n        inout message: MessageFormat;\n        inout data: DataFormat;\n    }\n    part systemAssembly {\n        part computer: Computer;\n        part storage: Storage;\n        interface integration connect computer.softwarePort to storage.softwarePort {\n            ref flow references dataFlow from source.data to target.data;\n            ref flow references messageFlow from source.message to target.message;\n        }\n    }\n    part Computer {\n        port softwarePort: SoftwareInterface;\n        perform SystemFunctions.processing {\n            out processedData = softwarePort.data;\n            out processedMessage = softwarePort.message;\n        }\n    }\n    part Storage {\n        port softwarePort: ~SoftwareInterface;\n        perform SystemFunctions.storing {\n            in storedData = softwarePort.data;\n            in storedMessage = softwarePort.message;\n        }\n    }\n    action SystemFunctions {\n        action processing {\n            out processedData: DataFormat;\n            out processedMessage: MessageFormat;\n        }\n        action transmission {\n            in transmittedData: DataFormat;\n            in transmittedMessage: MessageFormat;\n        }\n        action storing {\n            in storedData: DataFormat;\n            in storedMessage: MessageFormat;\n        }\n        flow dataFlow from processing.processedData to transmission.transmittedData;\n        flow messageFlow from processing.processedMessage to transmission.transmittedMessage;\n        flow from transmission to storing;\n    }\n}",
    "package 'Powertrain' {\n    attribute def Power;\n    attribute def Torque;\n    port def PowerPort {\n        out power: Power;\n    }\n    port def TorquePort {\n        out torque: Torque;\n    }\n    part context {\n        part logicalLayer {\n            part torqueGenerator {\n                port powerIn: ~PowerPort;\n                port torqueOut: TorquePort;\n                perform convertPowerToTorque {\n                    in power = powerIn.power;\n                    out torque = torqueOut.torque;\n                }\n            }\n        }\n        part physicalLayer {\n            part powerUnit {\n                port powerOut: PowerPort;\n                port torqueOut: TorquePort;\n                perform generatePower {\n                    out power = powerOut.power;\n                }\n                perform generateTorque {\n                    out torque = torqueOut.torque;\n                }\n            }\n        }\n        allocate logicalLayer.torqueGenerator to physicalLayer.powerUnit;\n    }\n    action convertPowerToTorque {\n        in power: Power;\n        out torque: Torque;\n    }\n}",
    "package 'PowerTransmissionSystem' {\n    attribute def Power;\n    attribute def Torque;\n    \n    part context {\n        part logical {\n            part torqueGenerator {\n                perform generateTorque;\n            }\n        }\n        part physical {\n            part powertrain {\n                part engine {\n                    perform generateTorque;\n                }\n            }\n        }\n        allocate logical.torqueGenerator to physical.powertrain;\n        allocate logical.torqueGenerator.generateTorque to physical.powertrain.engine;\n    }\n    \n    action generateTorque {\n        out torque: Torque;\n    }\n}",
    "package 'VehicleFeatureAnnotation' {\n    enum def FeatureType {\n        Safety;\n        Security;\n    }\n    part def Vehicle {\n        part interior: Interior;\n        part bodyAssembly: BodyAssembly;\n    }\n    part def Interior {\n        part seatBelts: SeatBelts;\n        part frontSeats: FrontSeats;\n        part driverAirbag: DriverAirbag;\n        part alarmSystem: AlarmSystem;\n    }\n    part def BodyAssembly {\n        part bodyShell: BodyShell;\n        part bumpers: Bumpers;\n        part keylessEntry: KeylessEntry;\n    }\n    part def SeatBelts {\n        attribute function: FeatureType = FeatureType::Safety;\n    }\n    part def DriverAirbag {\n        attribute function: FeatureType = FeatureType::Safety;\n    }\n    part def Bumpers {\n        attribute function: FeatureType = FeatureType::Safety;\n    }\n    part def AlarmSystem {\n        attribute function: FeatureType = FeatureType::Security;\n    }\n    part def KeylessEntry {\n        attribute function: FeatureType = FeatureType::Security;\n    }\n    part def FrontSeats;\n    part def BodyShell;\n}",
    "package 'VehicleDynamicsSimulation' {\n    attribute def InitialVelocity;\n    attribute def InitialPosition;\n    attribute def Acceleration;\n    attribute def TimeStep;\n    attribute def FinalVelocity;\n    attribute def FinalPosition;\n    \n    port def UserInputPort {\n        in initialVelocity: InitialVelocity;\n        in initialPosition: InitialPosition;\n        in acceleration: Acceleration;\n        in timeStep: TimeStep;\n    }\n    \n    port def SimulationOutputPort {\n        out finalVelocity: FinalVelocity;\n        out finalPosition: FinalPosition;\n    }\n    \n    port def ModelCenterInputPort {\n        in modelCenterInput: {\n            initialVelocity: InitialVelocity;\n            initialPosition: InitialPosition;\n            acceleration: Acceleration;\n            timeStep: TimeStep;\n        };\n    }\n    \n    port def ModelCenterOutputPort {\n        out modelCenterOutput: {\n            finalVelocity: FinalVelocity;\n            finalPosition: FinalPosition;\n        };\n    }\n    \n    part context {\n        part user {\n            port userInputPort: UserInputPort;\n            port simulationOutputPort: ~SimulationOutputPort;\n            perform simulateDynamics.provideInput {\n                out userInput = userInputPort;\n            }\n        }\n        \n        part dynamicsSimulator {\n            port userInputPort: ~UserInputPort;\n            port simulationOutputPort: SimulationOutputPort;\n            port modelCenterInputPort: ModelCenterInputPort;\n            port modelCenterOutputPort: ~ModelCenterOutputPort;\n            \n            perform simulateDynamics.computeDynamics {\n                in userInput = userInputPort;\n                out simulationOutput = simulationOutputPort;\n                out modelCenterInput = modelCenterInputPort;\n                in modelCenterOutput = modelCenterOutputPort;\n            }\n        }\n        \n        part modelCenter {\n            port modelCenterInputPort: ~ModelCenterInputPort;\n            port modelCenterOutputPort: ModelCenterOutputPort;\n            perform simulateDynamics.runAnalysis {\n                in modelCenterInput = modelCenterInputPort;\n                out modelCenterOutput = modelCenterOutputPort;\n            }\n        }\n        \n        interface userToSimulator connect user.userInputPort to dynamicsSimulator.userInputPort {\n            ref flow references simulateDynamics.inputFlow\n                from source.userInput to target.userInput;\n        }\n        \n        interface simulatorToModelCenter connect dynamicsSimulator.modelCenterInputPort to modelCenter.modelCenterInputPort {\n            ref flow references simulateDynamics.analysisRequestFlow\n                from source.modelCenterInput to target.modelCenterInput;\n        }\n        \n        interface modelCenterToSimulator connect modelCenter.modelCenterOutputPort to dynamicsSimulator.modelCenterOutputPort {\n            ref flow references simulateDynamics.analysisResultFlow\n                from source.modelCenterOutput to target.modelCenterOutput;\n        }\n        \n        interface simulatorToUser connect dynamicsSimulator.simulationOutputPort to user.simulationOutputPort {\n            ref flow references simulateDynamics.outputFlow\n                from source.simulationOutput to target.simulationOutput;\n        }\n    }\n    \n    action simulateDynamics {\n        action provideInput { out userInput: UserInputPort; }\n        action computeDynamics {\n            in userInput: UserInputPort;\n            out simulationOutput: SimulationOutputPort;\n            out modelCenterInput: ModelCenterInputPort;\n            in modelCenterOutput: ModelCenterOutputPort;\n        }\n        action runAnalysis {\n            in modelCenterInput: ModelCenterInputPort;\n            out modelCenterOutput: ModelCenterOutputPort;\n        }\n        \n        succession flow inputFlow from provideInput.userInput to computeDynamics.userInput;\n        succession flow analysisRequestFlow from computeDynamics.modelCenterInput to runAnalysis.modelCenterInput;\n        succession flow analysisResultFlow from runAnalysis.modelCenterOutput to computeDynamics.modelCenterOutput;\n        succession flow outputFlow from computeDynamics.simulationOutput;\n    }\n}",
    "package 'Car Safety Compliance' {\n    attribute def Safety;\n    attribute def isMandatory: Boolean;\n\n    part def SeatBelt {\n        attribute safety: Safety = Safety;\n        attribute mandatory: isMandatory = true;\n    }\n    part def Airbag {\n        attribute safety: Safety = Safety;\n        attribute mandatory: isMandatory = false;\n    }\n    part def Bumper {\n        attribute safety: Safety = Safety;\n        attribute mandatory: isMandatory = true;\n    }\n    part def KeylessEntry {\n        attribute safety: Safety = Safety;\n        attribute mandatory: isMandatory = false;\n    }\n    part def ABS {\n        attribute safety: Safety = Safety;\n        attribute mandatory: isMandatory = false;\n    }\n\n    package 'Safety Features' {\n        part seatBelt: SeatBelt;\n        part airbag: Airbag;\n        part bumper: Bumper;\n        part keylessEntry: KeylessEntry;\n        part abs: ABS;\n    }\n\n    package 'Mandatory Safety Features' {\n        part seatBelt: SeatBelt;\n        part bumper: Bumper;\n    }\n}",
    "package 'Vehicle Safety Compliance System' {\n    abstract part def SafetyFeature {\n        attribute isMandatory: Boolean;\n    }\n    part def SeatBelt: SafetyFeature {\n        attribute isMandatory = true;\n    }\n    part def DriverAirbag: SafetyFeature {\n        attribute isMandatory = false;\n    }\n    part def Bumper: SafetyFeature {\n        attribute isMandatory = true;\n    }\n    part def KeylessEntry: SafetyFeature {\n        attribute isMandatory = false;\n    }\n    part def ABS: SafetyFeature {\n        attribute isMandatory = false;\n    }\n    part def VehicleInterior {\n        part seatBelts: SeatBelt[2];\n        part driverAirbag: DriverAirbag[0..1];\n    }\n    part def VehicleBody {\n        part bumper: Bumper[1];\n        part keylessEntry: KeylessEntry[0..1];\n    }\n    part def Chassis {\n        part abs: ABS[0..1];\n    }\n    part def Vehicle {\n        part interior: VehicleInterior;\n        part body: VehicleBody;\n        part chassis: Chassis;\n    }\n}",
    "package 'RiskManagement' {\n    attribute def Probability;\n    attribute def Severity;\n    attribute def Description: string;\n    type Cause {\n        attribute probability: Probability;\n        attribute description: Description;\n    }\n    type Situation {\n        attribute description: Description;\n    }\n    type Failure {\n        attribute severity: Severity;\n        attribute description: Description;\n    }\n    action RiskScenario {\n        action causeOccurs { \n            out cause: Cause; \n        }\n        action situationOccurs { \n            in cause: Cause; \n            out situation: Situation;\n        }\n        action failureOccurs { \n            in situation: Situation; \n            out failure: Failure;\n        }\n        succession flow causeToSituation from causeOccurs.cause to situationOccurs.cause;\n        succession flow situationToFailure from situationOccurs.situation to failureOccurs.situation;\n    }\n    part context {\n        part riskScenario: RiskScenario;\n    }\n}",
    "package 'RiskSystem' {\n    part def Scenario {\n        attribute description: String;\n        part cause: CauseWithProbability[*];\n        part failure: FailureWithSeverity[*];\n    }\n    part def Cause {\n        attribute description: String;\n    }\n    part def FailureType {\n        attribute description: String;\n    }\n    part def CauseWithProbability {\n        attribute probability: Real[0..1];\n        reference cause: Cause;\n    }\n    part def FailureWithSeverity {\n        attribute severity: String;\n        reference failureType: FailureType;\n    }\n    association def CausalLink {\n        end source: Scenario[1];\n        end target: Scenario[1];\n    }\n    part def RiskScenario {\n        attribute description: String;\n        reference scenarios: Scenario[*];\n    }\n}",
    "package 'RiskAnalysisSystem' {\n    attribute def BatteryLevel;\n    attribute def AgingFactor;\n    attribute def Risk;\n    attribute def State;\n    attribute def Threshold;\n    attribute def Failure;\n    attribute def SeverityLevel;\n\n    port def BatteryDataPort {\n        out batteryLevel: BatteryLevel;\n        out agingFactor: AgingFactor;\n    }\n    port def RiskPort {\n        out risk: Risk;\n    }\n    port def StatePort {\n        out state: State;\n    }\n    port def FailurePort {\n        out failure: Failure;\n    }\n    port def SeverityPort {\n        out severity: SeverityLevel;\n    }\n\n    part context {\n        part equipment {\n            part battery {\n                port batteryDataPort: BatteryDataPort;\n            }\n            part monitoringSystem {\n                port batteryDataPort: ~BatteryDataPort;\n                port riskPort: RiskPort;\n                port statePort: StatePort;\n                port failurePort: FailurePort;\n                port severityPort: SeverityPort;\n                perform riskAnalysis.analyze {\n                    in batteryLevel = batteryDataPort.batteryLevel;\n                    in agingFactor = batteryDataPort.agingFactor;\n                    out risk = riskPort.risk;\n                    out state = statePort.state;\n                    out failure = failurePort.failure;\n                    out severity = severityPort.severity;\n                }\n            }\n            interface batteryToMonitor connect battery.batteryDataPort to monitoringSystem.batteryDataPort {\n                ref flow references riskAnalysis.dataFlow\n                    from source.batteryLevel to target.batteryLevel,\n                    from source.agingFactor to target.agingFactor;\n            }\n            part user {\n                port severityPort: ~SeverityPort;\n            }\n            part maintenance {\n                port severityPort: ~SeverityPort;\n            }\n            interface monitorToUser connect monitoringSystem.severityPort to user.severityPort {\n                ref flow references riskAnalysis.alertFlow\n                    from source.severity to target.severity;\n            }\n            interface monitorToMaintenance connect monitoringSystem.severityPort to maintenance.severityPort {\n                ref flow references riskAnalysis.alertFlow\n                    from source.severity to target.severity;\n            }\n        }\n    }\n\n    action riskAnalysis {\n        in batteryLevel: BatteryLevel;\n        in agingFactor: AgingFactor;\n        out risk: Risk;\n        out state: State;\n        out failure: Failure;\n        out severity: SeverityLevel;\n\n        action detectRisk {\n            in agingFactor;\n            out risk: Risk;\n        }\n        action monitorBattery {\n            in batteryLevel;\n            out currentLevel: BatteryLevel;\n        }\n        value threshold: Threshold = 15.0;\n        action determineState {\n            in currentLevel;\n            in threshold;\n            out state: State;\n        }\n        action analyzeFailure {\n            in state;\n            out failure: Failure;\n        }\n        action assignSeverity {\n            in failure;\n            out severity: SeverityLevel;\n        }\n\n        flow dataFlow from batteryLevel to monitorBattery.batteryLevel,\n                      from agingFactor to detectRisk.agingFactor;\n        succession flow riskFlow from detectRisk.risk to risk;\n        flow levelFlow from monitorBattery.currentLevel to determineState.currentLevel;\n        bind determineState.threshold to threshold;\n        flow stateFlow from determineState.state to analyzeFailure.state;\n        succession flow failureFlow from analyzeFailure.failure to assignSeverity.failure;\n        flow severityFlow from assignSeverity.severity to severity;\n        flow stateOutput from determineState.state to state;\n        flow alertFlow from assignSeverity.severity to severity;\n    }\n}",
    "package 'StructuralDecompositionSystem' {\n    port def ComponentInterface;\n    part def System {\n        part subsystem: Subsystem[1..*];\n        port systemInterface: ComponentInterface;\n    }\n    part def Subsystem {\n        part component: Component[1..*];\n        port subsystemInterface: ~ComponentInterface;\n    }\n    part def Component {\n        port componentInterface: ~ComponentInterface;\n    }\n    action IVV_Verification {\n        in system: System;\n        action verifyHierarchy {\n            in system;\n        }\n        action verifyInterfaces {\n            in system;\n        }\n        action verifyCoverage {\n            in system;\n        }\n        succession from verifyHierarchy to verifyInterfaces to verifyCoverage;\n    }\n    part context {\n        part systemEngineers {\n            perform IVV_Verification;\n        }\n        part ivvTeam {\n            perform IVV_Verification;\n        }\n        connector connectSystem connect System.subsystem[1].subsystemInterface \n            to System.subsystem[2].subsystemInterface;\n    }\n}",
    "package 'AutomotiveSystem' {\n    enum SafetyClassification {\n        mandatory;\n        optional;\n    }\n    \n    port def ComponentInterface;\n    \n    part def RootComponent {\n        port interface: ComponentInterface;\n        part powertrain: PowertrainSubsystem[1];\n        part safety: SafetySubsystem[1];\n        part infotainment: InfotainmentSubsystem[1];\n    }\n    \n    part def PowertrainSubsystem {\n        port interface: ComponentInterface;\n        part engine: Engine[1];\n        part transmission: Transmission[1];\n        part abs: AntiLockBrakingSystem[0..1];\n    }\n    \n    part def SafetySubsystem {\n        port interface: ComponentInterface;\n        part seatBelt: SeatBelt[1];\n        part bumper: Bumper[1];\n        part driverAirbag: DriverAirbag[0..1];\n    }\n    \n    part def InfotainmentSubsystem {\n        port interface: ComponentInterface;\n        part radio: Radio[1];\n        part display: Display[1];\n    }\n    \n    part def Engine {\n        port interface: ComponentInterface;\n    }\n    \n    part def Transmission {\n        port interface: ComponentInterface;\n    }\n    \n    part def AntiLockBrakingSystem {\n        attribute safety: SafetyClassification = SafetyClassification::optional;\n        port interface: ComponentInterface;\n    }\n    \n    part def SeatBelt {\n        attribute safety: SafetyClassification = SafetyClassification::mandatory;\n        port interface: ComponentInterface;\n    }\n    \n    part def Bumper {\n        attribute safety: SafetyClassification = SafetyClassification::mandatory;\n        port interface: ComponentInterface;\n    }\n    \n    part def DriverAirbag {\n        attribute safety: SafetyClassification = SafetyClassification::optional;\n        port interface: ComponentInterface;\n    }\n    \n    part def Radio {\n        port interface: ComponentInterface;\n    }\n    \n    part def Display {\n        port interface: ComponentInterface;\n    }\n}",
    "package 'Automotive Domain' {\n    comment \"Standardized definitions and annotations for fundamental automotive concepts\";\n    \n    value type  as Real (unit = \"Nm\") {\n        comment \"Rotational force acting on an object\";\n    }\n    \n    block  {\n        alias  (Car);\n        comment \"Core automotive component representing a road vehicle\";\n        \n        attribute : [0..1] {\n            comment \"Peak torque output of the vehicle's powertrain\";\n        }\n        attribute : [0..1] {\n            comment \"Torque delivered to the wheels through transmission\";\n        }\n    }\n    \n    part context {\n        part domainModel {\n            comment \"Comprehensive model with standardized automotive terminology\";\n            part automobile: ;\n        }\n    }\n}",
    "package 'DocumentManagementPlatform' {\n    type Automobile;\n    type Car:> Automobile;\n    type Concept;\n    type Term:> Concept {\n        attribute name: String;\n    }\n    type Document;\n    type PhysicalQuantity;\n    type ISQPhysicalQuantity:> PhysicalQuantity;\n    type TorqueValue:> ISQPhysicalQuantity;\n    \n    association {\n        Term term [0..*] -> Concept concept [1];\n    }\n    association {\n        Concept concept [0..*] <~> Document document [0..*];\n    }\n    \n    attribute def EnterCmd;\n    attribute def QueryCmd;\n    attribute def ArchiveCmd;\n    \n    port def UserCmdPort {\n        out enterCmd: EnterCmd;\n        out queryCmd: QueryCmd;\n        out archiveCmd: ArchiveCmd;\n    }\n    port def PlatformCmdPort {\n        in enterCmd: EnterCmd;\n        in queryCmd: QueryCmd;\n        in archiveCmd: ArchiveCmd;\n    }\n    \n    action ManageInfo {\n        action sendEnterCmd { out enterCmd: EnterCmd; }\n        action sendQueryCmd { out queryCmd: QueryCmd; }\n        action sendArchiveCmd { out archiveCmd: ArchiveCmd; }\n        \n        action processEnterCmd { in enterCmd: EnterCmd; }\n        action processQueryCmd { in queryCmd: QueryCmd; }\n        action processArchiveCmd { in archiveCmd: ArchiveCmd; }\n        \n        succession flow enterFlow from sendEnterCmd.enterCmd to processEnterCmd.enterCmd;\n        succession flow queryFlow from sendQueryCmd.queryCmd to processQueryCmd.queryCmd;\n        succession flow archiveFlow from sendArchiveCmd.archiveCmd to processArchiveCmd.archiveCmd;\n    }\n    \n    part context {\n        part user {\n            port userCmdPort: UserCmdPort;\n            perform ManageInfo.sendEnterCmd {\n                out enterCmd = userCmdPort.enterCmd;\n            }\n            perform ManageInfo.sendQueryCmd {\n                out queryCmd = userCmdPort.queryCmd;\n            }\n            perform ManageInfo.sendArchiveCmd {\n                out archiveCmd = userCmdPort.archiveCmd;\n            }\n        }\n        part platform {\n            port platformCmdPort: ~PlatformCmdPort;\n            perform ManageInfo.processEnterCmd {\n                in enterCmd = platformCmdPort.enterCmd;\n            }\n            perform ManageInfo.processQueryCmd {\n                in queryCmd = platformCmdPort.queryCmd;\n            }\n            perform ManageInfo.processArchiveCmd {\n                in archiveCmd = platformCmdPort.archiveCmd;\n            }\n        }\n        interface userToPlatform connect user.userCmdPort to platform.platformCmdPort {\n            ref flow references ManageInfo.enterFlow\n                from source.enterCmd to target.enterCmd;\n            ref flow references ManageInfo.queryFlow\n                from source.queryCmd to target.queryCmd;\n            ref flow references ManageInfo.archiveFlow\n                from source.archiveCmd to target.archiveCmd;\n        }\n    }\n}",
    "package 'AutomobileSystem' {\n    type Automobile;\n    alias Car for Automobile;\n    value type PhysicalQuantity;\n    value type TorqueValue:> PhysicalQuantity;\n    alias Torque for TorqueValue;\n    part def Automobile {\n        attribute torque: TorqueValue;\n    }\n}",
    "package 'VehicleSystem' {\n    enum VehicleSize {\n        Small;\n        Large;\n        Standard;\n    }\n    part def Cylinder;\n    part def Engine {\n        part cylinder: Cylinder[4..6];\n    }\n    part def Vehicle {\n        attribute size: VehicleSize;\n        part engine: Engine;\n        constraint cylinderCount {\n            (size == VehicleSize::Small implies engine.cylinder->size() = 4) and\n            (size == VehicleSize::Large implies engine.cylinder->size() = 6)\n        }\n    }\n}",
    "package 'FuelSystem' {\n    attribute def Fuel;\n    attribute def Temperature;\n    port def FuelSupplyPort {\n        out fuel: Fuel;\n    }\n    port def FuelReturnPort {\n        in fuel: Fuel;\n    }\n    part context {\n        part fuelTank {\n            port supplyPort: FuelSupplyPort;\n            port returnPort: ~FuelReturnPort;\n        }\n        part engine {\n            port supplyPort: ~FuelSupplyPort;\n            port returnPort: FuelReturnPort;\n        }\n        interface supplyLine connect fuelTank.supplyPort to engine.supplyPort {\n            ref flow references fuelFlow.supplyFlow\n                from source.fuel to target.fuel;\n        }\n        interface returnLine connect engine.returnPort to fuelTank.returnPort {\n            ref flow references fuelFlow.returnFlow\n                from source.fuel to target.fuel;\n        }\n        part fms {\n            port monitorPort: ~FuelSupplyPort;\n            port controlPort: FuelReturnPort;\n            perform fuelFlow.manageTemperature {\n                in fuel = monitorPort.fuel;\n                out fuel = controlPort.fuel;\n            }\n        }\n    }\n    action fuelFlow {\n        action supplyFlow { out fuel: Fuel; }\n        action returnFlow { in fuel: Fuel; }\n        action manageTemperature {\n            in fuel: Fuel;\n            out fuel: Fuel;\n        }\n        succession flow supplyFlow from supplyFlow.fuel to manageTemperature.fuel;\n        succession flow returnFlow from manageTemperature.fuel to returnFlow.fuel;\n    }\n}",
    "package 'VehicleStructure' {\n    attribute def Mass;\n    attribute def SteeringAngle;\n    part def Wheel;\n    part def Axle;\n    part def SteeringAxle :> Axle {\n        attribute steeringAngle: SteeringAngle;\n    }\n    part def AxleAssembly {\n        part axle: Axle;\n        part leftWheel: Wheel;\n        part rightWheel: Wheel;\n    }\n    part def Vehicle {\n        attribute mass: Mass;\n        part frontAxleAssembly: AxleAssembly;\n        part rearAxleAssembly: AxleAssembly;\n    }\n}"
]