[
    "package VehicleSystem {\n    part def Vehicle {\n        attribute mass : Real;\n        attribute currentStatus : VehicleStatus;\n        part engine : Engine[1];\n        part driver : Driver[0..1];\n    }\n\n    part def Engine {\n        // Engine attributes and operations can be added here\n    }\n\n    part def Driver {\n        // Driver attributes and operations can be added here\n    }\n\n    part def VehicleStatus {\n        attribute gear : Integer;\n        attribute acceleratorPedalPosition : Real;\n    }\n}",
    "package VehicleModel {\n    abstract def Vehicle;\n\n    part def Personnel;\n    part def Engine;\n\n    def ManuallyOperatedVehicle :> Vehicle {\n        reference driver: Personnel[1];\n    }\n\n    def PoweredVehicle :> Vehicle {\n        part engine: Engine[1];\n    }\n\n    def ManuallyOperatedPoweredVehicle :> ManuallyOperatedVehicle, PoweredVehicle;\n}",
    "package VehicleStructure {\n   abstract part def VehicleComponent;\n\n   part def Engine :> VehicleComponent;\n   part def Transmission :> VehicleComponent;\n   part def Wheel :> VehicleComponent;\n\n   part def Vehicle {\n      part engine: Engine[1];\n      part transmission: Transmission[1];\n      part wheel: Wheel[4];\n   }\n}",
    "package VehicleSystem {\n   block Cylinder\n\n   abstract block CylinderSubsystem\n\n   block SmallCylinderSubsystem : CylinderSubsystem {\n      part cylinders: Cylinder[4]\n   }\n\n   block LargeCylinderSubsystem : CylinderSubsystem {\n      part cylinders: Cylinder[6]\n   }\n\n   abstract block Engine\n\n   block SmallEngine : Engine {\n      part cylinderSubsystem: SmallCylinderSubsystem[1]\n   }\n\n   block LargeEngine : Engine {\n      part cylinderSubsystem: LargeCylinderSubsystem[1]\n   }\n\n   abstract block Vehicle {\n      part engine: Engine[1]\n   }\n\n   block SmallVehicle : Vehicle {\n      redefines engine: SmallEngine[1]\n   }\n\n   block LargeVehicle : Vehicle {\n      redefines engine: LargeEngine[1]\n   }\n}",
    "enum TrafficLightColor {\n   green,\n   yellow,\n   red\n}\n\npart def TrafficSignal {\n   attribute currentColor: TrafficLightColor;\n}\n\npart def AlwaysGreenTrafficSignal :> TrafficSignal {\n   attribute redefines currentColor: TrafficLightColor [readOnly, default = TrafficLightColor::green];\n}",
    "package InformationClassificationPackage {\n    class InformationClassification {\n        attribute code: String;\n        attribute color: String;\n    }\n\n    individual unclassified: InformationClassification {\n        code = 'uncl';\n        color = 'green';\n    }\n\n    individual confidential: InformationClassification {\n        code = 'conf';\n        color = 'yellow';\n    }\n\n    individual secret: InformationClassification {\n        code = 'secr';\n        color = 'red';\n    }\n\n    enum GradeLevel {\n        A, B, C, D, F\n    }\n\n    class Grade {\n        attribute level: GradeLevel;\n        attribute score: Real;\n    }\n\n    individual gradeA: Grade {\n        level = GradeLevel::A;\n        score = 4.0;\n    }\n\n    individual gradeB: Grade {\n        level = GradeLevel::B;\n        score = 3.0;\n    }\n\n    individual gradeC: Grade {\n        level = GradeLevel::C;\n        score = 2.0;\n    }\n\n    individual gradeD: Grade {\n        level = GradeLevel::D;\n        score = 1.0;\n    }\n\n    individual gradeF: Grade {\n        level = GradeLevel::F;\n        score = 0.0;\n    }\n}",
    "package Vehicles {\n    part def Cylinder;\n\n    block Engine;\n\n    block SmallEngine :> Engine {\n        part cylinders : Cylinder[4];\n    }\n\n    block LargeEngine :> Engine {\n        part cylinders : Cylinder[6];\n    }\n\n    block Vehicle;\n\n    block SmallVehicle :> Vehicle {\n        part engine : SmallEngine;\n    }\n\n    block LargeVehicle :> Vehicle {\n        part engine : LargeEngine;\n    }\n}",
    "enum FuelType {\n    gasoline,\n    diesel,\n    electric\n}\n\npart Personnel {\n    attribute name: String;\n    attribute licenseID: String;\n    attribute experienceYears: Integer;\n}\n\npart FuelTank {\n    attribute capacity: Real;\n    attribute currentLevel: Real;\n    reference fuelType: FuelType[1];\n}\n\npart Vehicle {\n    attribute weight: Real;\n    attribute maxSpeed: Real;\n    attribute safetyRating: Integer;\n    part tank: FuelTank[1];\n    reference driver: Personnel[1];\n}",
    "partdef Bead;\npartdef Rim;\npartdef Hole;\npartdef Bolt;\npartdef Tire {\n    part innerBead: Bead;\n    part outerBead: Bead;\n}\npartdef WheelHub {\n    part innerRim: Rim;\n    part outerRim: Rim;\n    attribute mountingHoles: Hole[4..*];\n}\npartdef VehicleHub {\n    attribute threadedHoles: Hole[4..*];\n}\npartdef WheelBearingUnit {\n    part vehicleHub: VehicleHub;\n}\npartdef WheelAssembly {\n    part wheelHub: WheelHub;\n    part tire: Tire;\n    part wheelBearing: WheelBearingUnit;\n    part bolts: Bolt[4..*];\n    connection innerBeadToRim {\n        end1: tire.innerBead;\n        end2: wheelHub.innerRim;\n    }\n    connection outerBeadToRim {\n        end1: tire.outerBead;\n        end2: wheelHub.outerRim;\n    }\n    connection boltedConnection {\n        end1: wheelHub.mountingHoles;\n        end2: wheelBearing.vehicleHub.threadedHoles;\n        related: bolts;\n    }\n}",
    "package FuelFlowManagementSystem {\n    import SysML::*;\n\n    type Temperature: Real;\n    type FlowRate: Real;\n\n    flow item def Fuel;\n\n    interface def FuelInterface {\n        value temperature: Temperature;\n        value flowRate: FlowRate;\n    }\n\n    port def FuelPort : FuelInterface;\n\n    part def FuelTankAssembly {\n        port fuelSupply: out FuelPort;\n        port fuelReturn: in FuelPort;\n    }\n\n    part def Engine {\n        port fuelSupply: in FuelPort;\n        port fuelReturn: out FuelPort;\n    }\n\n    interface def UserInterface {\n        operation getSupplyFlowRate(): FlowRate;\n        operation getReturnFlowRate(): FlowRate;\n        operation getSupplyTemperature(): Temperature;\n        operation getReturnTemperature(): Temperature;\n    }\n\n    part def FuelFlowMonitor {\n        port provides: out UserInterface;\n        attribute supplyFlowRate: FlowRate;\n        attribute returnFlowRate: FlowRate;\n        attribute supplyTemperature: Temperature;\n        attribute returnTemperature: Temperature;\n    }\n\n    part tank: FuelTankAssembly;\n    part engine: Engine;\n    part monitor: FuelFlowMonitor;\n\n    connector fuelSupply between tank.fuelSupply, engine.fuelSupply;\n    connector fuelReturn between tank.fuelReturn, engine.fuelReturn;\n\n    binding monitor.supplyFlowRate = tank.fuelSupply.flowRate;\n    binding monitor.supplyTemperature = tank.fuelSupply.temperature;\n    binding monitor.returnFlowRate = tank.fuelReturn.flowRate;\n    binding monitor.returnTemperature = tank.fuelReturn.temperature;\n\n    port userAccess: out UserInterface;\n    connector userConn between monitor.provides, userAccess;\n}",
    "package VehicleConfiguration {\n    unit kg;\n    unit deg;\n\n    block Vehicle {\n        attribute mass: Real [kg] = 1750;\n        part frontAxle: FrontAxle[1];\n        part rearAxle: RearAxle[1];\n    }\n\n    block Axle {\n        attribute mass: Real [kg];\n        part tires: Tire[2] ordered;\n    }\n\n    block FrontAxle: Axle {\n    }\n\n    block RearAxle: Axle {\n    }\n\n    block SteeringFrontAxle: FrontAxle {\n        attribute steeringAngle: Real [deg];\n    }\n\n    block Tire {\n        attribute mass: Real [kg];\n    }\n\n    instance baseVehicle: Vehicle;\n\n    configuration vehicle1_c1 {\n        baseVehicle: Vehicle {\n            mass = 2000;\n            frontAxle = new SteeringFrontAxle {\n                name = \"vehicle1_c1_frontAxle\";\n            }\n        }\n    }\n}",
    "part def Ball {}\n\npart def Vehicle {\n    reference connector: Ball;\n}\n\npart def Trailer {\n    reference connector: Ball;\n}\n\npart def Hitch {\n    part ball: Ball;\n}\n\npart def CouplingSystem {\n    part vehicle: Vehicle;\n    part trailer: Trailer;\n    part hitch: Hitch;\n\n    bind vehicle.connector = hitch.ball;\n    bind trailer.connector = hitch.ball;\n}",
    "flow specification ControlSignal {\n    in fuelCommand: Real;\n}\n\nflow specification MechanicalPower {\n    out torque: Real;\n    out speed: Real;\n}\n\nblock Engine {\n    port fuelIn: in ControlSignal;\n    port powerOut: out MechanicalPower;\n    port clutchInterface: out MechanicalPower;\n}\n\nblock Transmission {\n    port clutchIn: in MechanicalPower;\n    port driveshaftOut: out MechanicalPower;\n}\n\nblock Clutch {\n    port engineSide: in MechanicalPower;\n    port transmissionSide: out MechanicalPower;\n}\n\nblock Driveshaft {\n    port transmissionEnd: in MechanicalPower;\n    port axleEnd: out MechanicalPower;\n}\n\nblock Differential {\n    port input: in MechanicalPower;\n    port leftOutput: out MechanicalPower;\n    port rightOutput: out MechanicalPower;\n}\n\nblock HalfShaft {\n    port input: in MechanicalPower;\n    port output: out MechanicalPower;\n}\n\nblock Wheel {\n    port shaftIn: in MechanicalPower;\n    port roadInterface: out MechanicalPower;\n}\n\nblock RearAxleAssembly {\n    part differential: Differential;\n    part leftHalfShaft: HalfShaft;\n    part rightHalfShaft: HalfShaft;\n\n    port driveshaftIn: in MechanicalPower;\n    port leftOutput: out MechanicalPower;\n    port rightOutput: out MechanicalPower;\n\n    connections {\n        driveshaftIn -> differential.input;\n        differential.leftOutput -> leftHalfShaft.input;\n        differential.rightOutput -> rightHalfShaft.input;\n        leftHalfShaft.output -> leftOutput;\n        rightHalfShaft.output -> rightOutput;\n    }\n}\n\nblock VehiclePowerTransmissionSystem {\n    part engine: Engine;\n    part clutch: Clutch;\n    part transmission: Transmission;\n    part driveshaft: Driveshaft;\n    part rearAxle: RearAxleAssembly;\n    part leftWheel: Wheel;\n    part rightWheel: Wheel;\n\n    port fuelCommand: in ControlSignal;\n    port leftRoadInterface: out MechanicalPower;\n    port rightRoadInterface: out MechanicalPower;\n\n    connections {\n        fuelCommand -> engine.fuelIn;\n        engine.powerOut -> clutch.engineSide;\n        clutch.transmissionSide -> transmission.clutchIn;\n        transmission.driveshaftOut -> driveshaft.transmissionEnd;\n        driveshaft.axleEnd -> rearAxle.driveshaftIn;\n        rearAxle.leftOutput -> leftWheel.shaftIn;\n        rearAxle.rightOutput -> rightWheel.shaftIn;\n        leftWheel.roadInterface -> leftRoadInterface;\n        rightWheel.roadInterface -> rightRoadInterface;\n    }\n}",
    "package SystemModel {\n    interface pe;\n    interface pf;\n    signal Sig;\n\n    part c1 {\n        port pb: pe;\n        port out: Sig;\n    }\n\n    part c2 {\n        port in: Sig;\n    }\n\n    part c3 {\n        port pd: pf;\n    }\n\n    part c4 {}\n\n    part Subsystem1 {\n        part comp1: c1;\n        part comp2: c2;\n        connection conn1: comp1.out -> comp2.in;\n        port exposed_pe: pe = comp1.pb;\n    }\n\n    part Subsystem2 {\n        part comp3: c3;\n        part comp4: c4;\n        port exposed_pf: pf = comp3.pd;\n    }\n\n    part SystemDecomposition1 {\n        part b11: Subsystem1;\n        part b12: Subsystem2;\n        connection sys_conn: b11.exposed_pe -> b12.exposed_pf;\n    }\n\n    part Module1 {\n        part comp1: c1;\n        part comp2: c2;\n        connection mod1_conn: comp1.out -> comp2.in;\n    }\n\n    part Module2 {\n        part comp3: c3;\n        part comp4: c4;\n    }\n\n    part SystemDecomposition2 {\n        part b21: Module1;\n        part b22: Module2;\n    }\n}",
    "package PowertrainModel {\n    value type Real;\n\n    signal FuelCommand {\n        value: Real;\n    }\n\n    signal StartCommand;\n    signal StopCommand;\n\n    interface PowertrainInterface {\n        reception start: StartCommand;\n        reception stop: StopCommand;\n        reception fuel: FuelCommand;\n    }\n\n    flow specification TorqueFlow {\n        flow property torque: Real;\n    }\n\n    block User {\n        port powertrainInterface: out PowertrainInterface;\n    }\n\n    block PowertrainSystem {\n        port userInterface: in PowertrainInterface;\n\n        part engine: Engine;\n        part transmission: Transmission;\n        part driveshaft: Driveshaft;\n        part leftWheel: Wheel;\n        part rightWheel: Wheel;\n\n        connector commandConnector: userInterface -> engine.controlInterface;\n        connector engineToTrans: engine.torqueOutput -> transmission.torqueInput;\n        connector transToDriveshaft: transmission.torqueOutput -> driveshaft.torqueInput;\n        connector toLeftWheel: driveshaft.leftOutput -> leftWheel.torqueInput;\n        connector toRightWheel: driveshaft.rightOutput -> rightWheel.torqueInput;\n    }\n\n    block Engine {\n        port controlInterface: in PowertrainInterface;\n        port torqueOutput: out TorqueFlow;\n\n        attribute lastFuelValue: Real = 0.0;\n        attribute currentTorque: Real {\n            derive: if (self.isInState(Running)) then lastFuelValue else 0.0;\n        }\n\n        state machine {\n            state Stopped;\n            state Running;\n\n            initial Stopped;\n\n            transition start: Stopped -[on controlInterface.start]-> Running;\n            transition stop: Running -[on controlInterface.stop]-> Stopped;\n            transition fuel: self -[on controlInterface.fuel]/ lastFuelValue = controlInterface.fuel.value -> self;\n        }\n\n        constraint {\n            torqueOutput.torque == currentTorque;\n        }\n    }\n\n    block Transmission {\n        port torqueInput: in TorqueFlow;\n        port torqueOutput: out TorqueFlow;\n\n        attribute gearRatio: Real = 2.0;\n\n        constraint {\n            torqueOutput.torque == torqueInput.torque * gearRatio;\n        }\n    }\n\n    block Driveshaft {\n        port torqueInput: in TorqueFlow;\n        port leftOutput: out TorqueFlow;\n        port rightOutput: out TorqueFlow;\n\n        constraint {\n            leftOutput.torque == torqueInput.torque / 2.0;\n            rightOutput.torque == torqueInput.torque / 2.0;\n        }\n    }\n\n    block Wheel {\n        port torqueInput: in TorqueFlow;\n    }\n}",
    "package PowertrainControl {\n  value type FuelCommand;\n  value type StallSignal;\n  value type Torque;\n\n  part def Engine {\n    operation start();\n    operation generateTorque() : Torque;\n  }\n\n  part def Transmission {\n    operation amplifyTorque(in t: Torque) : Torque;\n  }\n\n  part def DriveShaft {\n    operation transmitTorque(in t: Torque) : Torque;\n  }\n\n  part def Differential {\n    operation distributeTorque(in t: Torque) : Torque[4];\n  }\n\n  part def Wheel {\n    operation applyTorque(in t: Torque);\n  }\n\n  part def AutomotivePowertrainControlSystem {\n    feature fuelControlCommand: in FuelCommand;\n    feature stallSignal: in StallSignal;\n    \n    part engine: Engine;\n    part transmission: Transmission;\n    part driveShaft: DriveShaft;\n    part differential: Differential;\n    part wheels: Wheel[4];\n    \n    behavior PowertrainOperation;\n  }\n\n  activity PowertrainOperation {\n    initial -> fork;\n    fork -> normalFlow;\n    fork -> stallAccept;\n    \n    normalFlow: StructuredActivityNode {\n      callStartEngine: CallOperation = this.engine.start();\n      callGenerateTorque: CallOperation = this.engine.generateTorque() [result: torque1];\n      callAmplify: CallOperation = this.transmission.amplifyTorque(torque1) [result: torque2];\n      callTransmit: CallOperation = this.driveShaft.transmitTorque(torque2) [result: torque3];\n      callDistribute: CallOperation = this.differential.distributeTorque(torque3) [result: torques];\n      \n      expansionApply: ExpansionRegion {\n        input: torques -> inElement;\n        output: none;\n        node actionApply: CallOperation = this.wheels[inElement.index].applyTorque(inElement.value);\n      }\n      \n      callStartEngine -> callGenerateTorque;\n      callGenerateTorque -> callAmplify;\n      callAmplify -> callTransmit;\n      callTransmit -> callDistribute;\n      callDistribute -> expansionApply;\n    }\n    \n    normalFlow -> final;\n    \n    stallAccept: AcceptEventAction = AcceptEventAction(this.stallSignal);\n    stallAccept -> final;\n    \n    region: InterruptibleRegion {\n      interruptingEdge: stallAccept->final;\n      node: normalFlow;\n    }\n  }\n}",
    "event def EngineStartSignal : signal;\nevent def EngineShutdownSignal : signal;\n\naction def GenerateTorque;\naction def AmplifyAndTransmitTorque;\naction def DistributeTorque;\n\nactivity def ManagePower {\n    action generate : GenerateTorque;\n    action amplify : AmplifyAndTransmitTorque;\n    action distribute : DistributeTorque;\n    sequence {\n        generate;\n        amplify;\n        distribute;\n    } while true;\n}\n\nstate def VehiclePowertrainStateMachine {\n    initial: Off;\n    state Off {\n        transition on EngineStartSignal -> Running;\n    }\n    state Running {\n        do ManagePower;\n        transition on EngineShutdownSignal -> Off;\n    }\n}\n\npart def VehiclePowertrainSystem {\n    attribute fuelCommand : Real;\n    state behavior : VehiclePowertrainStateMachine;\n}\n\nrequirement def FunctionalReq {\n    id = 'FR1';\n    text = \"Achieve integrated management of vehicle powertrain system based on driver's fuel input command\";\n}\nrequirement def PerformanceReq {\n    id = 'NFR1';\n    text = \"Ensure accurate and efficient automatic control of power demand response, torque transmission, and power distribution\";\n}\nrequirement def EfficiencyReq {\n    id = 'NFR2';\n    text = \"Enhance driving experience and improve energy efficiency\";\n}\n\nsatisfy def FunctionalSatisfaction {\n    satisfiedRequirement = FunctionalReq;\n    satisfyingSubject = VehiclePowertrainSystem;\n}\nsatisfy def PerformanceSatisfaction {\n    satisfiedRequirement = PerformanceReq;\n    satisfyingSubject = VehiclePowertrainSystem::ManagePower;\n}\nsatisfy def EfficiencySatisfaction {\n    satisfiedRequirement = EfficiencyReq;\n    satisfyingSubject = VehiclePowertrainSystem;\n}",
    "package TowingSystem {\n    part def Frame {\n    }\n\n    part def HitchBall {\n    }\n\n    part def TrailerCoupler {\n    }\n\n    part def Vehicle {\n        part frame: Frame;\n        part hitchBall: HitchBall;\n    }\n\n    part def Trailer {\n        part frame: Frame;\n        part coupler: TrailerCoupler;\n    }\n\n    part def TowingSystem {\n        part vehicle: Vehicle;\n        part trailer: Trailer;\n        connector mechanicalConnection: vehicle.hitchBall <-> trailer.coupler;\n\n        state machine {\n            state disconnected;\n            state connected;\n            initial: disconnected;\n            transition connect: disconnected -> connected;\n            transition disconnect: connected -> disconnected;\n        }\n    }\n}",
    "package TrailerSystem {\n    block Vehicle {\n        part chassis: Chassis[1];\n        part towBall: TowBall[1];\n    }\n\n    block Trailer {\n        part coupler: Coupler[1];\n        part frame: TrailerFrame[1];\n    }\n\n    block Chassis {}\n\n    block TowBall {}\n\n    block Coupler {}\n\n    block TrailerFrame {}\n\n    block TrailerConnectionSystem {\n        part vehicle: Vehicle[1];\n        part trailer: Trailer[1];\n        operation connect(): Boolean;\n        operation disconnect(): Boolean;\n    }\n\n    association Connection {\n        end vehicleEnd: TowBall[0..1];\n        end trailerEnd: Coupler[0..1];\n    }\n\n    requirement SafetyReliability {\n        id = 'REQ-1';\n        text = \"Ensure safe and reliable coupling between vehicle and trailer\";\n    }\n\n    requirement Convenience {\n        id = 'REQ-2';\n        text = \"Provide convenient connection/disconnection operations\";\n    }\n\n    TrailerConnectionSystem satisfies SafetyReliability;\n    TrailerConnectionSystem satisfies Convenience;\n}",
    "package TowingSystem {\n   part def Vehicle {\n      part chassis: Chassis;\n      part towBall: TowBall;\n   }\n\n   part def Trailer {\n      part trailerChassis: TrailerChassis;\n      part coupler: Coupler;\n   }\n\n   part def TowingSystem {\n      part vehicle: Vehicle;\n      part trailer: Trailer;\n      state behavior: ConnectionStateMachine;\n   }\n\n   state def ConnectionStateMachine {\n      initial state Disengaged;\n      state Engaged {\n         constraint: \"Coupler must securely latch onto tow ball\";\n      }\n      transition hitch: Disengaged -> Engaged;\n      transition unhitch: Engaged -> Disengaged;\n   }\n\n   part def Chassis;\n   part def TowBall;\n   part def TrailerChassis;\n   part def Coupler;\n}",
    "block Fluid {\n    value temperature: Real;\n}\n\ninterface block FuelFlow {\n    flow fuel: Fluid;\n}\n\nblock FuelTank {\n    port fuelSupplyPort: out FuelFlow;\n    port fuelReturnPort: in FuelFlow;\n}\n\nblock Engine {\n    port fuelInletPort: in FuelFlow;\n    port fuelReturnPort: out FuelFlow;\n}\n\nblock FuelSystem {\n    part fuelTank: FuelTank;\n    part engine: Engine;\n\n    connect fuelTank.fuelSupplyPort -> engine.fuelInletPort;\n    connect engine.fuelReturnPort -> fuelTank.fuelReturnPort;\n}\n\nrequirement StabilityRequirement {\n    id = 'REQ1';\n    text = 'Ensure stable fuel supply during vehicle operation.';\n}\n\nrequirement ReliabilityRequirement {\n    id = 'REQ2';\n    text = 'Maintain reliable fuel circulation under all operating conditions.';\n}\n\nrequirement MonitoringRequirement {\n    id = 'REQ3';\n    text = 'Monitor fuel temperature for safety and efficiency.';\n}\n\nsatisfy StabilitySatisfaction {\n    satisfiedRequirement = StabilityRequirement;\n    satisfyingSubject = FuelSystem;\n}\n\nsatisfy ReliabilitySatisfaction {\n    satisfiedRequirement = ReliabilityRequirement;\n    satisfyingSubject = FuelSystem;\n}\n\nsatisfy MonitoringSatisfaction {\n    satisfiedRequirement = MonitoringRequirement;\n    satisfyingSubject = FuelSystem;\n}",
    "package FuelDeliverySystem {\n    value type FuelQuantity {\n        unit: 'liter';\n    }\n\n    requirement Efficient {\n        id: 'REQ1';\n        text: \"The system shall deliver fuel efficiently.\";\n    }\n\n    requirement Timely {\n        id: 'REQ2';\n        text: \"The system shall provide fuel in a timely manner.\";\n    }\n\n    requirement Safe {\n        id: 'REQ3';\n        text: \"The system shall operate safely during fuel delivery.\";\n    }\n\n    requirement Accurate {\n        id: 'REQ4';\n        text: \"The system shall accurately measure and deliver fuel quantities.\";\n    }\n\n    part def StorageTank {\n        port fuelOutlet: out FuelQuantity;\n    }\n\n    part def FuelPump {\n        port fuelInlet: in FuelQuantity;\n        port fuelOutlet: out FuelQuantity;\n    }\n\n    part def VehicleFuelTank {\n        attribute maxCapacity: FuelQuantity;\n        attribute currentLevel: FuelQuantity;\n        port fuelInlet: in FuelQuantity;\n\n        constraint CapacityConstraint {\n            currentLevel <= maxCapacity;\n        }\n    }\n\n    part def FuelDeliverySystem {\n        part storage: StorageTank;\n        part pump: FuelPump;\n        part vehicleTank: VehicleFuelTank;\n\n        connector tankToPump: storage.fuelOutlet -> pump.fuelInlet;\n        connector pumpToVehicle: pump.fuelOutlet -> vehicleTank.fuelInlet;\n\n        satisfy efficiencyReq: Efficient satisfied by this;\n        satisfy timelinessReq: Timely satisfied by this;\n        satisfy safetyReq: Safe satisfied by this;\n        satisfy accuracyReq: Accurate satisfied by this;\n    }\n}",
    "package AutomobileAssembly {\n    partdef VehicleAssembly\n\n    partdef Gearbox {\n        attribute functional: Boolean = true;\n    }\n\n    partdef Engine {\n        attribute functional: Boolean = true;\n    }\n\n    structure VehicleWithGearbox {\n        :base: VehicleAssembly;\n        :gearbox: Gearbox;\n    }\n\n    structure FullyAssembledVehicle {\n        :base: VehicleWithGearbox;\n        :engine: Engine;\n    }\n\n    action InstallGearbox {\n        :in vehicle: VehicleAssembly;\n        :in gearbox: Gearbox;\n        :out result: VehicleWithGearbox;\n    }\n\n    action InstallEngine {\n        :in vehicle: VehicleWithGearbox;\n        :in engine: Engine;\n        :out result: FullyAssembledVehicle;\n    }\n\n    activity AutomobileAssemblyProcess {\n        :in initialVehicle: VehicleAssembly;\n        :in gearboxPart: Gearbox;\n        :in enginePart: Engine;\n        :out finalVehicle: FullyAssembledVehicle;\n\n        action installGearbox: InstallGearbox {\n            :vehicle :> initialVehicle;\n            :gearbox :> gearboxPart;\n        };\n\n        action installEngine: InstallEngine {\n            :vehicle :> installGearbox.result;\n            :engine :> enginePart;\n        };\n\n        :finalVehicle :> installEngine.result;\n    }\n\n    requirement \"SequentialAssembly\" {\n        :text: \"Gearbox must be installed before engine\";\n    }\n\n    requirement \"ComponentIndependence\" {\n        :text: \"Fully assembled vehicle must have independent functional gearbox and engine\";\n    }\n\n    satisfy \"SatisfySequential\" {\n        :requirement :> \"SequentialAssembly\";\n        :subject :> AutomobileAssemblyProcess.installGearbox;\n        :subject :> AutomobileAssemblyProcess.installEngine;\n    }\n\n    satisfy \"SatisfyIndependence\" {\n        :requirement :> \"ComponentIndependence\";\n        :subject :> FullyAssembledVehicle.gearbox.functional;\n        :subject :> FullyAssembledVehicle.engine.functional;\n    }\n}",
    "package VehicleControlSystem {\n    signal overTemperatureSignal;\n    signal startSignal;\n    signal vehicleOnSignal;\n    signal shutdownSignal;\n    signal restoreNormalSignal;\n    signal maintenanceRequest;\n    signal maintenanceComplete;\n\n    part def VehicleSystem {\n        attribute temperature: Real;\n        attribute threshold: Real = 100.0;\n        attribute brakePressed: Boolean;\n\n        state machine {\n            initial state Off;\n            state Starting;\n            state Running;\n            state Degraded;\n            state Maintenance;\n\n            transition from Off to Starting: on startSignal when brakePressed;\n            transition from Starting to Running: on vehicleOnSignal;\n            transition from Running to Degraded: when temperature > threshold then / {\n                overTemperatureSignal.send();\n            }\n            transition from Running to Off: on shutdownSignal;\n            transition from Running to Maintenance: on maintenanceRequest;\n            transition from Degraded to Running: on restoreNormalSignal;\n            transition from Maintenance to Running: on maintenanceComplete;\n\n            Running: entry / {\n                performSelfChecks();\n                supplyPower();\n            }\n            Running: exit / {\n                applyParkingBrake();\n            }\n        }\n\n        operation performSelfChecks;\n        operation supplyPower;\n        operation applyParkingBrake;\n    }\n}",
    "package VehicleBehavior {\n    interface IVehicleCommands {\n        signal startSignal;\n        signal shutdownSignal;\n    }\n\n    interface IVehicleStatus {\n        signal warningSignal;\n    }\n\n    block VehicleController {\n        port commandPort: IVehicleCommands;   // provides\n        port statusPort: IVehicleStatus;       // requires\n    }\n\n    block Vehicle {\n        value property fuelLevel: Real;\n        value property maintenanceInterval: Integer;\n        value property temperatureThreshold: Real;\n        value property currentTemperature: Real;\n        value property brakePedalPressed: Boolean;\n\n        port commandPort: IVehicleCommands;   // requires\n        port statusPort: IVehicleStatus;       // provides\n\n        state machine {\n            initial state Shutdown;\n\n            state Starting {\n                entry / \"Perform self-inspection and power supply\"\n            }\n\n            state Running;\n\n            state Degraded;\n\n            state Maintenance {\n                entry / \"Execute maintenance procedures\"\n            }\n\n            transition from Shutdown to Starting: on commandPort.startSignal [brakePedalPressed];\n            transition from Starting to Running;\n            transition from Running to Degraded: on change (currentTemperature) [currentTemperature > temperatureThreshold] / {\n                statusPort.warningSignal();\n            }\n            transition from Degraded to Running: on change (currentTemperature) [currentTemperature <= temperatureThreshold];\n            event maintenanceDue;\n            transition from Running to Maintenance: on maintenanceDue;\n            transition from Maintenance to Running;\n            transition from Running to Shutdown: on commandPort.shutdownSignal;\n            transition from Degraded to Shutdown: on commandPort.shutdownSignal;\n            transition from Maintenance to Shutdown: on commandPort.shutdownSignal;\n        }\n    }\n\n    part controller: VehicleController;\n    part vehicle: Vehicle;\n\n    connector commandConn: controller.commandPort <-> vehicle.commandPort;\n    connector statusConn: vehicle.statusPort <-> controller.statusPort;\n}",
    "enum VehicleStateEnum {\n    Off,\n    On,\n    Driving\n}\n\nblock Vehicle {\n    attribute mass: Real;\n    attribute position: Real;\n    attribute velocity: Real;\n    attribute acceleration: Real;\n    attribute currentState: VehicleStateEnum;\n}\n\nstatemachine VehicleBehavior for Vehicle {\n    state Off;\n    state On;\n    state Driving;\n    transition t1: Off -> On;\n    transition t2: On -> Off;\n    transition t3: On -> Driving;\n    transition t4: Driving -> On;\n}\n\nblock Road {\n    attribute slope: Real;\n    attribute frictionCoefficient: Real;\n}\n\nblock Snapshot {\n    attribute time: Real;\n    attribute vehicleMass: Real;\n    attribute vehiclePosition: Real;\n    attribute vehicleVelocity: Real;\n    attribute vehicleAcceleration: Real;\n    attribute vehicleCurrentState: VehicleStateEnum;\n    attribute roadSlope: Real;\n    attribute roadFrictionCoefficient: Real;\n}\n\nblock Simulation {\n    part vehicle: Vehicle;\n    part road: Road;\n    attribute timeSeries: Real[*] ordered;\n    part snapshots: Snapshot[*] ordered by time;\n    operation run();\n}",
    "package AutomotiveConfiguration {\n    partdef Component1;\n    partdef Component2;\n    partdef Component3;\n    partdef Component4;\n    partdef Component5;\n    partdef Component6;\n\n    abstract partdef SubsystemA;\n    abstract partdef SubsystemB;\n\n    partdef SubsystemA_Option1: SubsystemA {\n        part comp1: Component1;\n        part comp2: Component2;\n    }\n\n    partdef SubsystemA_Option2: SubsystemA {\n        part comp2: Component2;\n        part comp3: Component3;\n    }\n\n    partdef SubsystemB_Option1: SubsystemB {\n        part comp4: Component4;\n        part comp5: Component5;\n    }\n\n    partdef SubsystemB_Option2: SubsystemB {\n        part comp5: Component5;\n        part comp6: Component6;\n    }\n\n    partdef Automobile {\n        part subsystemA: SubsystemA[1];\n        part subsystemB: SubsystemB[1];\n\n        invariant configurationConstraint: \n            not (subsystemA instanceof SubsystemA_Option2) or (subsystemB instanceof SubsystemB_Option1);\n    }\n\n    configuration ConfigurationA for Automobile {\n        subsystemA: SubsystemA_Option1;\n        subsystemB: SubsystemB_Option1;\n    }\n\n    configuration ConfigurationB for Automobile {\n        subsystemA: SubsystemA_Option2;\n        subsystemB: SubsystemB_Option1;\n    }\n}",
    "package ModularVehiclePlatform {\n    part part1;\n    part part2;\n    part part3 {\n        port p1;\n    }\n    part part4;\n    part part5 {\n        port p2;\n        behavior BaseBehavior;\n    }\n    behavior NewBehavior;\n    part VariantPart5 : part5 {\n        behavior NewBehavior redefines BaseBehavior;\n    }\n    part part6;\n\n    part SubsystemA {\n        port externalPort;\n        part comp1: part1[0..*];\n        part comp2: part2[0..*];\n        part comp3: part3[0..*];\n        part comp4: part4[0..*];\n        part comp5: part5[0..*];\n        part comp6: part6[0..*];\n    }\n\n    part SubsystemA_Variant1 : SubsystemA {\n        part comp1: part1[0] redefines comp1;\n        part comp2: part2[0] redefines comp2;\n        part comp3: part3[1] redefines comp3;\n        part comp4: part4[0] redefines comp4;\n        part comp5: VariantPart5[1] redefines comp5;\n        part comp6: part6[0] redefines comp6;\n        connection internalConn: comp3.p1 -> comp5.p2;\n        binding externalPort to comp3.p1;\n    }\n\n    part SubsystemB {\n        port externalPort;\n        part comp1: part1[0..*];\n        part comp2: part2[0..*];\n        part comp3: part3[0..*];\n        part comp4: part4[0..*];\n        part comp5: part5[0..*];\n        part comp6: part6[0..*];\n    }\n\n    part VehicleConfigA {\n        part subA: SubsystemA_Variant1;\n        part subB: SubsystemB;\n        connection conn: subA.externalPort -> subB.externalPort;\n    }\n\n    part VehicleConfigB {\n        part subA: SubsystemA;\n        part subB: SubsystemB;\n    }\n\n    requirement SystemConstraint;\n}",
    "package VehicleProductLine {\n   enum EngineVariant {\n      V6,\n      V4\n   }\n\n   enum TransmissionVariant {\n      automatic,\n      manual\n   }\n\n   enum WheelVariant {\n      wide,\n      narrow\n   }\n\n   enum PerformanceRequirement {\n      high,\n      standard\n   }\n\n   enum VehicleModel {\n      sedan,\n      suv,\n      truck\n   }\n\n   part def Engine {\n      variant: EngineVariant[1];\n   }\n\n   part def Transmission {\n      variant: TransmissionVariant[1];\n   }\n\n   part def Wheel {\n      variant: WheelVariant[1];\n   }\n\n   part def Vehicle {\n      model: VehicleModel[1];\n      performance: PerformanceRequirement[1];\n      engine: Engine[1];\n      transmission: Transmission[1];\n      wheel: Wheel[1];\n\n      constraint HighPerfConstraint {\n         (performance = PerformanceRequirement::high) <=>\n            (engine.variant = EngineVariant::V6 and\n             transmission.variant = TransmissionVariant::automatic and\n             wheel.variant = WheelVariant::wide)\n      }\n\n      constraint StandardPerfConstraint {\n         (performance = PerformanceRequirement::standard) <=>\n            (engine.variant = EngineVariant::V4 and\n             transmission.variant = TransmissionVariant::manual and\n             wheel.variant = WheelVariant::narrow)\n      }\n\n      constraint ValidPerformance {\n         performance = PerformanceRequirement::high or performance = PerformanceRequirement::standard\n      }\n   }\n}",
    "package AutomobileSystem {\n    value type kg {\n        unit: kilogram;\n    }\n\n    value type Nm {\n        unit: newton meter;\n    }\n\n    enum FuelState {\n        full,\n        empty\n    }\n\n    interface DriveInterface;\n\n    port definition DrivePort {\n        provided: DriveInterface;\n    }\n\n    part Engine {\n        ports: \n            drivePort: DrivePort;\n        attributes:\n            outputTorque: Nm;\n    }\n\n    part Transmission {\n        ports:\n            drivePort: DrivePort;\n    }\n\n    part Vehicle {\n        attributes:\n            actualMass: kg;\n            maxMass: kg;\n            fuelState: FuelState;\n            requiredFuelState: FuelState;\n        parts:\n            engine: Engine;\n            transmission: Transmission;\n        connections:\n            powertrain: engine.drivePort -> transmission.drivePort;\n    }\n\n    requirement MassGradeRequirement {\n        id: 'REQ-MassGrade';\n        text: 'Vehicle must comply with predefined mass grades';\n    }\n\n    requirement MassLimitRequirement {\n        id: 'REQ-MassLimit';\n        text: 'Actual mass must not exceed maximum mass';\n    }\n\n    requirement FuelConditionRequirement {\n        id: 'REQ-FuelCondition';\n        text: 'Mass measurement must comply with specified fuel state';\n    }\n\n    requirement PowertrainRequirement {\n        id: 'REQ-Powertrain';\n        text: 'Engine must output torque and connect to transmission';\n    }\n\n    requirement ReliabilityRequirement {\n        id: 'REQ-Reliability';\n        text: 'Vehicle must meet lifecycle performance and durability';\n    }\n\n    constant AllowedMasses: kg[*] = [2000, 2500];\n\n    constraint MassGradeConstraint for MassGradeRequirement {\n        parameters: \n            maxMass: kg;\n            allowedMasses: kg[*] = AllowedMasses;\n        expression: maxMass in allowedMasses;\n    }\n\n    constraint MassLimitConstraint for MassLimitRequirement {\n        parameters: \n            actualMass: kg;\n            maxMass: kg;\n        expression: actualMass <= maxMass;\n    }\n\n    constraint FuelConstraint for FuelConditionRequirement {\n        parameters: \n            fuelState: FuelState;\n            requiredFuelState: FuelState;\n        expression: fuelState == requiredFuelState;\n    }\n\n    satisfy MassGradeSatisfaction {\n        requirement: MassGradeRequirement;\n        satisfiedBy: Vehicle::maxMass;\n    }\n\n    satisfy MassLimitSatisfaction {\n        requirement: MassLimitRequirement;\n        satisfiedBy: Vehicle::actualMass, Vehicle::maxMass;\n    }\n\n    satisfy FuelSatisfaction {\n        requirement: FuelConditionRequirement;\n        satisfiedBy: Vehicle::fuelState, Vehicle::requiredFuelState;\n    }\n\n    satisfy PowertrainSatisfaction {\n        requirement: PowertrainRequirement;\n        satisfiedBy: Vehicle::engine, Vehicle::transmission, Vehicle::powertrain;\n    }\n\n    satisfy ReliabilitySatisfaction {\n        requirement: ReliabilityRequirement;\n        satisfiedBy: Vehicle;\n    }\n\n    constraint binding MassGradeBinding for Vehicle {\n        constraint: MassGradeConstraint;\n        bindings:\n            maxMass = this.maxMass;\n            allowedMasses = AutomobileSystem::AllowedMasses;\n    }\n\n    constraint binding MassLimitBinding for Vehicle {\n        constraint: MassLimitConstraint;\n        bindings:\n            actualMass = this.actualMass;\n            maxMass = this.maxMass;\n    }\n\n    constraint binding FuelBinding for Vehicle {\n        constraint: FuelConstraint;\n        bindings:\n            fuelState = this.fuelState;\n            requiredFuelState = this.requiredFuelState;\n    }\n}",
    "package VehicleMassComplianceSystem {\n   requirement MaximumPermissibleMassReq {\n      id: 'REQ-001'\n      text: \"Maximum permissible vehicle mass shall be 2500 kg\"\n   }\n\n   requirement ComplianceVerificationReq {\n      id: 'REQ-002'\n      text: \"System shall verify vehicle mass compliance against maximum permissible mass\"\n   }\n\n   requirement SequentialTestingReq {\n      id: 'REQ-003'\n      text: \"System shall support sequential testing of multiple vehicles\"\n   }\n\n   requirement ReliabilityReq {\n      id: 'REQ-004'\n      text: \"System shall provide reliable compliance determination\"\n   }\n\n   part def Vehicle {\n      attribute mass: Real\n   }\n\n   part def WeighingEquipment {\n      operation measureMass(in vehicle: Vehicle): Real\n   }\n\n   part def TestOperator {\n      operation operateScale(in equipment: WeighingEquipment, in vehicle: Vehicle): Real {\n         return equipment.measureMass(vehicle)\n      }\n   }\n\n   part def ComplianceVerificationSystem {\n      parts: \n         scale: WeighingEquipment,\n         operator: TestOperator\n      references:\n         testQueue: Vehicle[*]\n\n      attribute maxPermissibleMass: Real = 2500.0\n\n      operation verifyCompliance(in vehicle: Vehicle): Boolean {\n         let measuredMass = operator.operateScale(scale, vehicle)\n         vehicle.mass = measuredMass\n         return measuredMass <= maxPermissibleMass\n      }\n\n      operation processTestQueue(): Boolean[*] {\n         return for each v in testQueue collect verifyCompliance(v)\n      }\n   }\n\n   satisfy MassLimitSatisfaction {\n      satisfiedRequirement = MaximumPermissibleMassReq\n      satisfyingElement = ComplianceVerificationSystem::maxPermissibleMass\n   }\n\n   satisfy VerificationSatisfaction {\n      satisfiedRequirement = ComplianceVerificationReq\n      satisfyingElement = ComplianceVerificationSystem::verifyCompliance\n   }\n\n   satisfy SequentialTestingSatisfaction {\n      satisfiedRequirement = SequentialTestingReq\n      satisfyingElement = ComplianceVerificationSystem::processTestQueue\n   }\n\n   satisfy ReliabilitySatisfaction {\n      satisfiedRequirement = ReliabilityReq\n      satisfyingElement = ComplianceVerificationSystem\n   }\n}",
    "interface HotWaterInterface;\ninterface ColdWaterInterface;\n\npart SpigotBank {\n    port hotSpigot : HotWaterInterface[*];\n    port coldSpigot : ColdWaterInterface[*];\n}\n\npart Faucet {\n    port hotInlet : HotWaterInterface;\n    port coldInlet : ColdWaterInterface;\n}\n\npartdef WaterSupplySystem {\n    part spigotBank : SpigotBank {\n        port hotSpigot : [faucets.size()];\n        port coldSpigot : [faucets.size()];\n    }\n    part faucets : Faucet[1..*];\n    \n    for i in 1..faucets.size() {\n        connect spigotBank.hotSpigot[i] to faucets[i].hotInlet;\n        connect spigotBank.coldSpigot[i] to faucets[i].coldInlet;\n    }\n}",
    "package VehicleQualityModel {\n    import Systems;\n    import Requirements;\n    import UseCases;\n    import Activities;\n    import Plans;\n\n    part def Engine {\n        attribute mass: Real;\n    }\n\n    part def Transmission {\n        attribute mass: Real;\n    }\n\n    part def AxleAssembly {\n        attribute mass: Real;\n    }\n\n    part def Vehicle {\n        attribute totalMass: Real;\n        part engine: Engine;\n        part transmission: Transmission;\n        part frontAxle: AxleAssembly;\n        part rearAxle: AxleAssembly;\n\n        constraint TotalMassConstraint {\n            totalMass = engine.mass + transmission.mass + frontAxle.mass + rearAxle.mass\n        }\n    }\n\n    requirement def TotalMassRequirement {\n        id: \"REQ-001\";\n        text: \"Calculate total vehicle mass as sum of component masses\";\n    }\n\n    requirement def AnalysisAutomationRequirement {\n        id: \"REQ-002\";\n        text: \"Automatically generate analysis tasks and plans based on objectives\";\n    }\n\n    requirement def EfficiencyRequirement {\n        id: \"REQ-003\";\n        text: \"Improve development efficiency and product performance\";\n    }\n\n    satisfy MassCalculationSatisfaction {\n        requirement = TotalMassRequirement;\n        ownedFeature = Vehicle::TotalMassConstraint;\n    }\n\n    use case def InputQualityData {\n        description: \"Input quality data for vehicle components\";\n    }\n\n    use case def PerformMassAggregation {\n        description: \"Calculate total vehicle mass from components\";\n    }\n\n    use case def DefineAnalysisRequirements {\n        description: \"Define quality analysis requirements\";\n    }\n\n    use case def GenerateAnalysisPlan {\n        description: \"Generate analysis tasks and plans\";\n    }\n\n    use case def VehicleQualityAnalysis {\n        include InputQualityData;\n        include PerformMassAggregation;\n        include DefineAnalysisRequirements;\n        include GenerateAnalysisPlan;\n    }\n\n    action def AggregateMassAction {\n        input vehicle: Vehicle;\n        do: vehicle.totalMass = vehicle.engine.mass + vehicle.transmission.mass + \n                               vehicle.frontAxle.mass + vehicle.rearAxle.mass;\n    }\n\n    activity def MassAggregationActivity {\n        action = AggregateMassAction;\n    }\n\n    plan def QualityAnalysisPlan {\n        performedBehavior: VehicleQualityAnalysis;\n    }\n\n    satisfy AnalysisAutomationSatisfaction {\n        requirement = AnalysisAutomationRequirement;\n        ownedFeature = GenerateAnalysisPlan;\n    }\n\n    satisfy EfficiencySatisfaction {\n        requirement = EfficiencyRequirement;\n        ownedFeature = VehicleQualityAnalysis;\n    }\n\n    trace PlanTrace {\n        source = QualityAnalysisPlan;\n        target = AnalysisAutomationRequirement;\n    }\n}",
    "package PowertrainConfiguration {\n  part def Cylinder;\n  part def Piston;\n  part def ConnectingRod;\n  part def Crankshaft;\n\n  abstract part def Engine {\n    value property power: Real;\n    value property mass: Real;\n    value property efficiency: Real;\n    value property reliability: Real;\n    value property cost: Real;\n  }\n\n  part def FourCylinderEngine :> Engine {\n    parts: \n      cylinder: Cylinder[4],\n      piston: Piston[4],\n      rod: ConnectingRod[4],\n      crank: Crankshaft;\n  }\n\n  part def SixCylinderEngine :> Engine {\n    parts: \n      cylinder: Cylinder[6],\n      piston: Piston[6],\n      rod: ConnectingRod[6],\n      crank: Crankshaft;\n  }\n\n  constraint def EngineEvaluationModel {\n    parameters: \n      candidate: Engine,\n      score: Real;\n    constraint: \n      score = (0.2 * candidate.power) + \n              (0.2 * (1 - candidate.mass)) + \n              (0.2 * candidate.efficiency) + \n              (0.2 * candidate.reliability) + \n              (0.2 * (1 - candidate.cost));\n  }\n\n  requirement def SelectionTransparency {\n    id = \"REQ-001\";\n    text = \"System shall provide decision rationale for engine selection\";\n  }\n\n  part def TradeOffAnalyzer {\n    attribute selectedEngine: Engine;\n    attribute selectionRationale: String;\n    \n    action def EvaluateEngines {\n      in engineOptions: Engine[*];\n      out optimalEngine: Engine;\n      out explanation: String;\n    }\n  }\n\n  part def PowertrainConfigurationSystem {\n    parts: \n      analyzer: TradeOffAnalyzer;\n    \n    satisfy transparencyRequirement: SelectionTransparency {\n      satisfiedBy = analyzer.EvaluateEngines;\n    }\n    \n    constraint def AssemblyConstraint {\n      parameters: \n        engineType: Engine;\n      constraint: \n        engineType.power >= 150 and \n        engineType.mass <= 200 and \n        engineType.cost <= 15000;\n    }\n  }\n}",
    "package FuelEconomySystem {\n    unit usGallon: volume;\n    unit mpg = mile / usGallon;\n    unit lb: mass;\n\n    enum DrivingScenario {\n        urban,\n        highway\n    }\n\n    requirement UrbanFuelEconomyReq {\n        requirementId: \"REQ-1\";\n        text: \"Under urban driving conditions, the vehicle’s range per gallon must not be less than 25 miles.\";\n        constraint: urbanConstraint: FuelEconomyConstraint {\n            scenario: DrivingScenario::urban;\n            minMPG: 25;\n        }\n    }\n\n    requirement HighwayFuelEconomyReq {\n        requirementId: \"REQ-2\";\n        text: \"Under highway conditions, the vehicle’s range per gallon must not be less than 30 miles.\";\n        constraint: highwayConstraint: FuelEconomyConstraint {\n            scenario: DrivingScenario::highway;\n            minMPG: 30;\n        }\n    }\n\n    requirement SystemAnalysisReq {\n        requirementId: \"REQ-3\";\n        text: \"The system models and analyzes key parameters such as vehicle powertrain, load, and operating conditions to ensure regulatory fuel economy targets are met.\";\n    }\n\n    constraint FuelEconomyConstraint {\n        parameter scenario: DrivingScenario;\n        parameter minMPG: Real (unit mpg);\n        parameter testLoad: Real (unit lb) = 1000;\n        parameter actualMPG: Real (unit mpg);\n        constraint: actualMPG >= minMPG\n    }\n\n    block Vehicle {\n        attribute powertrain: String;\n        attribute operatingConditions: String;\n        constraint FuelConsumption {\n            parameter load: Real (unit lb);\n            parameter scenario: DrivingScenario;\n            result fuelEconomy: Real (unit mpg);\n        }\n    }\n\n    block FuelEconomyComplianceSystem {\n        part vehicle: Vehicle;\n        verify UrbanVerification for UrbanFuelEconomyReq {\n            bind: \n                UrbanFuelEconomyReq.urbanConstraint.actualMPG = \n                    vehicle.FuelConsumption(UrbanFuelEconomyReq.urbanConstraint.testLoad, DrivingScenario::urban).fuelEconomy;\n        }\n        verify HighwayVerification for HighwayFuelEconomyReq {\n            bind: \n                HighwayFuelEconomyReq.highwayConstraint.actualMPG = \n                    vehicle.FuelConsumption(HighwayFuelEconomyReq.highwayConstraint.testLoad, DrivingScenario::highway).fuelEconomy;\n        }\n    }\n}",
    "package VehicleLongitudinalDynamics {\n    part def VehicleDynamicsSimulator {\n        attribute mass: Real;\n        attribute initialPosition: Real;\n        attribute initialVelocity: Real;\n        attribute timeStep: Real;\n        part powerProfile: PowerProfile;\n        operation simulate(): (acceleration: Sequence<Real>, velocity: Sequence<Real>, position: Sequence<Real>);\n    }\n\n    part def PowerProfile {\n        attribute segments: set PowerSegment;\n    }\n\n    part def PowerSegment {\n        attribute startTime: Real;\n        attribute endTime: Real;\n        attribute powerValue: Real;\n    }\n\n    type SimulationResult: tuple (acceleration: Sequence<Real>, velocity: Sequence<Real>, position: Sequence<Real>);\n}",
    "block Vehicle {\n   value property totalMass: Real = 2500;\n   part frontAxle: FrontAxleAssembly[1];\n   part rearAxle: RearAxleAssembly[1];\n}\n\nblock FrontAxleAssembly {\n   value property mass: Real = 150;\n   part wheel: FrontWheel[2];\n   part axle: FrontAxle[1];\n}\n\nblock RearAxleAssembly {\n   value property mass: Real = 250;\n   part wheel: RearWheel[2];\n   part axle: RearAxle[1];\n}\n\nblock FrontWheel {}\n\nblock RearWheel {}\n\nblock FrontAxle {\n   value property mass: Real;\n   value property steeringAngle: Real;\n}\n\nblock RearAxle {\n   value property mass: Real;\n}",
    "package VehicleSafetySecurity {\n    enum FeatureCategory {\n        safety,\n        security\n    }\n\n    enum RequirementType {\n        mandatory,\n        optional\n    }\n\n    abstract part def VehicleFeature {\n        attribute category: FeatureCategory;\n    }\n\n    part def SafetyFeature specializes VehicleFeature {\n        attribute requirement: RequirementType;\n    }\n\n    part def SecurityFeature specializes VehicleFeature;\n\n    part def SeatBelts specializes SafetyFeature {\n        category = FeatureCategory::safety;\n        requirement = RequirementType::mandatory;\n    }\n\n    part def Bumpers specializes SafetyFeature {\n        category = FeatureCategory::safety;\n        requirement = RequirementType::mandatory;\n    }\n\n    part def Airbags specializes SafetyFeature {\n        category = FeatureCategory::safety;\n        requirement = RequirementType::optional;\n    }\n\n    part def AntiLockBrakingSystem specializes SafetyFeature {\n        category = FeatureCategory::safety;\n        requirement = RequirementType::optional;\n    }\n\n    part def Alarm specializes SecurityFeature {\n        category = FeatureCategory::security;\n    }\n\n    part def KeylessEntrySystem specializes SecurityFeature {\n        category = FeatureCategory::security;\n    }\n\n    part def Vehicle {\n        part seatBelts: SeatBelts;\n        part bumpers: Bumpers;\n        part airbags: Airbags;\n        part antiLockBraking: AntiLockBrakingSystem;\n        part alarm: Alarm;\n        part keylessEntry: KeylessEntrySystem;\n    }\n}",
    "package LayeredSystem {\n    part def System {\n        attribute x : Real;\n        attribute y : Real;\n        attribute z : Real {\n            isDerived = true\n        }\n        constraint {\n            constraint : \"z = f(x, y)\"\n        }\n        \n        part applicationLayer : ApplicationLayer;\n        part serviceLayer : ServiceLayer;\n        part dataLayer : DataLayer;\n        \n        dependency : applicationLayer -> serviceLayer;\n        dependency : serviceLayer -> dataLayer;\n    }\n    \n    part def ApplicationLayer {}\n    part def ServiceLayer {}\n    part def DataLayer {}\n}",
    "package Powertrain {\n    import Units::*;\n\n    value type Torque: Real [unit: newton * meter];\n\n    requirement TorqueRequirement {\n        requirement id: \"REQ-1\";\n        text: \"Torque output must exceed 0 N·m during operation\";\n    }\n\n    constraint PositiveTorque {\n        parameter torque: Torque;\n        constraint: torque > 0;\n    }\n\n    action GenerateTorque {\n        output torque: Torque;\n        constraint torqueConstraint: PositiveTorque {\n            torque = self.torque;\n        }\n    }\n\n    part def Engine {\n        attribute outputTorque: Torque;\n    }\n\n    part def PowertrainSystem {\n        part engine: Engine;\n        action torqueGenerator: GenerateTorque;\n\n        allocation functionalAllocation: engine to torqueGenerator;\n        satisfies torqueSatisfaction: TorqueRequirement;\n\n        constraint operationalConstraint: PositiveTorque {\n            torque = engine.outputTorque;\n        }\n    }\n}",
    "package VehicleSystem {\n    part def Powertrain {\n        part engine: Engine;\n    }\n\n    part def Engine {\n        action generateTorque;\n        perform = generateTorque;\n    }\n\n    part def VehicleSystem {\n        part powertrain: Powertrain;\n        action transmitPower;\n        action outputPower;\n        action providePower;\n        action generateTorque;\n        \n        allocate generateTorque to powertrain.engine.generateTorque;\n    }\n}",
    "package VehicleSafetyAndAntiTheftCatalogue {\n    enum FeatureType {\n        Safety,\n        AntiTheft\n    }\n\n    abstract partdef Component {\n        attribute features: FeatureType[*];\n        attribute isMandatory: Boolean;\n\n        constraint MandatoryOnlyForSafety {\n            if isMandatory then features->includes(FeatureType::Safety)\n        }\n    }\n\n    partdef Vehicle {\n        part frontSeatBelts: FrontSeatBelts[1];\n        part bumpers: Bumpers[1];\n        part? driverAirbag: DriversAirbag;\n        part? abs: AntiLockBrakingSystem;\n        part? alarm: AlarmSystem;\n        part? keylessEntry: KeylessEntrySystem;\n    }\n\n    partdef FrontSeatBelts :> Component {\n        features = FeatureType::Safety;\n        isMandatory = true;\n    }\n\n    partdef Bumpers :> Component {\n        features = FeatureType::Safety;\n        isMandatory = true;\n    }\n\n    partdef DriversAirbag :> Component {\n        features = FeatureType::Safety;\n        isMandatory = false;\n    }\n\n    partdef AntiLockBrakingSystem :> Component {\n        features = FeatureType::Safety;\n        isMandatory = false;\n    }\n\n    partdef AlarmSystem :> Component {\n        features = FeatureType::AntiTheft;\n        isMandatory = false;\n    }\n\n    partdef KeylessEntrySystem :> Component {\n        features = FeatureType::AntiTheft;\n        isMandatory = false;\n    }\n}",
    "package FuelSystem {\n    flow item Fuel;\n    value type Temperature: Real;\n\n    part def FuelTank {\n        port fuelSupply: out Fuel;\n        port returnInlet: in Fuel;\n        port tempData: out Temperature;\n        value currentTemp: Temperature;\n        bind currentTemp -> tempData;\n    }\n\n    part def FuelPump {\n        port inlet: in Fuel;\n        port outlet: out Fuel;\n    }\n\n    part def FuelTankAssembly {\n        part tank: FuelTank;\n        part pump: FuelPump;\n        port delivery: out Fuel;\n        port return: in Fuel;\n        port tempData: out Temperature;\n        \n        connect tank.fuelSupply -> pump.inlet;\n        connect pump.outlet -> delivery;\n        connect return -> tank.returnInlet;\n        connect tank.tempData -> tempData;\n    }\n\n    part def FuelSystem {\n        part assembly: FuelTankAssembly;\n        port fuelDelivery: out Fuel;\n        port fuelReturn: in Fuel;\n        port tempOutput: out Temperature;\n        \n        connect assembly.delivery -> fuelDelivery;\n        connect fuelReturn -> assembly.return;\n        connect assembly.tempData -> tempOutput;\n    }\n}",
    "enum RequirementType {\n   safety,\n   security\n}\n\nrequirement ComplianceManagement {\n   id: \"REQ-0\"\n   text: \"All safety and security components must undergo identification and classification management to ensure regulatory compliance and enhance vehicle safety and security features.\"\n}\n\nrequirement SeatBeltsRequirement {\n   id: \"REQ-1\"\n   text: \"Vehicle interior must contain two seat belts as mandatory safety features.\"\n   type: RequirementType::safety\n   mandatory: true\n}\n\nrequirement AirbagRequirement {\n   id: \"REQ-2\"\n   text: \"Airbag should be installed in the cockpit as a safety feature.\"\n   type: RequirementType::safety\n   mandatory: false\n}\n\nrequirement AntiTheftAlarmRequirement {\n   id: \"REQ-3\"\n   text: \"Anti-theft alarm device must be installed inside the vehicle for security protection.\"\n   type: RequirementType::security\n   mandatory: true\n}\n\nrequirement BumperRequirement {\n   id: \"REQ-4\"\n   text: \"Vehicle body must include a bumper as a mandatory safety component.\"\n   type: RequirementType::safety\n   mandatory: true\n}\n\nrequirement KeylessEntryRequirement {\n   id: \"REQ-5\"\n   text: \"Keyless entry system must be equipped on the vehicle body to improve security.\"\n   type: RequirementType::security\n   mandatory: true\n}\n\nrequirement WheelsRequirement {\n   id: \"REQ-6\"\n   text: \"Chassis structure must be fitted with two wheels.\"\n   type: RequirementType::safety\n   mandatory: true\n}\n\nrequirement ABSRequirement {\n   id: \"REQ-7\"\n   text: \"Two sets of anti-lock braking systems should be equipped on the chassis structure.\"\n   type: RequirementType::safety\n   mandatory: false\n}\n\nComplianceManagement -> decompose: \n   SeatBeltsRequirement, \n   AirbagRequirement, \n   AntiTheftAlarmRequirement, \n   BumperRequirement, \n   KeylessEntryRequirement, \n   WheelsRequirement, \n   ABSRequirement\n\npart def SeatBelt {}\npart def Airbag {}\npart def AntiTheftAlarm {}\npart def Bumper {}\npart def KeylessEntry {}\npart def Wheel {}\npart def AntiLockBrakingSystem {}\n\npart def Interior {\n   part seatBelts: SeatBelt[2] {\n      satisfy SeatBeltsRequirement\n   }\n   part antiTheftAlarm: AntiTheftAlarm[1] {\n      satisfy AntiTheftAlarmRequirement\n   }\n}\n\npart def Cockpit {\n   part airbag: Airbag[0..1] {\n      satisfy AirbagRequirement\n   }\n}\n\npart def Body {\n   part bumper: Bumper[1] {\n      satisfy BumperRequirement\n   }\n   part keylessEntry: KeylessEntry[1] {\n      satisfy KeylessEntryRequirement\n   }\n}\n\npart def Chassis {\n   part wheels: Wheel[2] {\n      satisfy WheelsRequirement\n   }\n   part abs: AntiLockBrakingSystem[0..2] {\n      satisfy ABSRequirement\n   }\n}\n\npart def Vehicle {\n   part interior: Interior\n   part cockpit: Cockpit\n   part body: Body\n   part chassis: Chassis\n   satisfy ComplianceManagement\n}",
    "package VehicleSafetyAndSecurity {\n    part def VehicleSafetyAndSecuritySystem {\n        part interior : Interior;\n        part bodyAssembly : BodyAssembly;\n    }\n\n    part def Interior {\n        part alarmSystem : AlarmSystem;\n        part seatBelts : SeatBelts;\n        part frontRowSeats : FrontRowSeats;\n        part driversAirbag : Airbag;\n    }\n\n    part def BodyAssembly {\n        part vehicleBody : VehicleBody;\n        part bumper : Bumper;\n        part keylessEntrySystem : KeylessEntrySystem;\n    }\n\n    part def AlarmSystem;\n    part def SeatBelts;\n    part def FrontRowSeats;\n    part def Airbag;\n    part def VehicleBody;\n    part def Bumper;\n    part def KeylessEntrySystem;\n\n    requirement SafetyRequirement {\n        reqId = 'SAFETY_REQ';\n        text = 'Protect driver and passengers during driving';\n    }\n\n    requirement SecurityRequirement {\n        reqId = 'SECURITY_REQ';\n        text = 'Provide anti-theft protection and convenient access';\n    }\n\n    satisfy SafetySatisfaction {\n        requirement = SafetyRequirement;\n        satisfiedBy = [\n            VehicleSafetyAndSecuritySystem::interior.seatBelts,\n            VehicleSafetyAndSecuritySystem::interior.driversAirbag,\n            VehicleSafetyAndSecuritySystem::bodyAssembly.bumper\n        ];\n    }\n\n    satisfy SecuritySatisfaction {\n        requirement = SecurityRequirement;\n        satisfiedBy = [\n            VehicleSafetyAndSecuritySystem::interior.alarmSystem,\n            VehicleSafetyAndSecuritySystem::bodyAssembly.keylessEntrySystem\n        ];\n    }\n}",
    "enum SecurityClassification {\n   Unclassified;\n   Confidential;\n   Secret;\n}\n\nblock Component {\n   classification: SecurityClassification = SecurityClassification::Unclassified;\n}",
    "package AutomotiveECUModel {\n    abstract signal CANMessage;\n    signal VehicleStatus : CANMessage;\n    signal EngineStatus : CANMessage;\n    signal ControlCommand : CANMessage;\n    signal SensorData : CANMessage;\n\n    port def CANBusPort {\n        in flow received : CANMessage;\n        out flow transmitted : CANMessage;\n    }\n\n    port def CANDevicePort conjugate CANBusPort;\n\n    part def BusIF {\n        port deviceSide : CANDevicePort;\n        port busConnection : CANBusPort;\n        connect deviceSide to busConnection;\n    }\n\n    part def VCU {\n        port vcuBusPort : CANDevicePort;\n        part busIF : BusIF;\n        connect vcuBusPort to busIF.deviceSide;\n        port sensorInterface : in SensorData;\n    }\n\n    part def ECU {\n        port ecuBusPort : CANDevicePort;\n        part busIF : BusIF;\n        connect ecuBusPort to busIF.deviceSide;\n        port sensorInterface : out SensorData;\n    }\n\n    part def CANBus {\n        port nodes : CANBusPort[*];\n    }\n\n    part def AutomotiveSystem {\n        part vcu : VCU;\n        part ecu : ECU;\n        part canBus : CANBus;\n\n        connect vcu.busIF.busConnection to canBus.nodes;\n        connect ecu.busIF.busConnection to canBus.nodes;\n    }\n\n    requirement \"Reliable Collaboration\" {\n        requirementId: \"REQ-001\";\n        text: \"Ensure reliable collaboration between vehicle subsystems\";\n    }\n\n    requirement \"Performance\" {\n        requirementId: \"REQ-002\";\n        text: \"Meet vehicle-level performance requirements\";\n    }\n\n    requirement \"Safety\" {\n        requirementId: \"REQ-003\";\n        text: \"Satisfy comprehensive safety standards\";\n    }\n\n    satisfy [\n        AutomotiveSystem satisfies \"Reliable Collaboration\",\n        AutomotiveSystem satisfies \"Performance\",\n        AutomotiveSystem satisfies \"Safety\"\n    ]\n}",
    "package BloodGlucoseMeter {\n    requirement HighReliability {\n        id = \"REQ-1\"\n        text = \"Ensure high reliability and safety during use\"\n    }\n\n    requirement BatteryDetection {\n        id = \"REQ-2\"\n        text = \"Automatically detect battery status (depleted/unchargeable)\"\n    }\n\n    requirement UserAlert {\n        id = \"REQ-3\"\n        text = \"Promptly alert user during critical battery conditions\"\n    }\n\n    requirement FailurePrevention {\n        id = \"REQ-4\"\n        text = \"Prevent measurement failure due to battery issues\"\n    }\n\n    requirement TreatmentContinuity {\n        id = \"REQ-5\"\n        text = \"Avoid treatment delays from measurement failures\"\n    }\n\n    requirement AlarmMechanism {\n        id = \"REQ-6\"\n        text = \"Implement alarm mechanism for measurement abnormalities\"\n    }\n\n    requirement EmergencyResponse {\n        id = \"REQ-7\"\n        text = \"Implement emergency response for measurement abnormalities\"\n    }\n\n    requirement RiskManagement {\n        id = \"REQ-8\"\n        text = \"Establish management measures for key risk scenarios\"\n    }\n\n    requirement TimelySupport {\n        id = \"REQ-9\"\n        text = \"Ensure timely, continuous, and safe therapeutic support\"\n    }\n\n    part Meter {\n        part PowerSystem {\n            part Battery {\n                attribute status : String\n            }\n        }\n\n        part AlertSystem {\n            operation notifyUser(in message : String)\n        }\n\n        part MeasurementModule {\n            attribute status : String\n        }\n    }\n\n    stateMachine OperationalStates {\n        state NormalOperation {\n            entry / \"Measure glucose levels\"\n        }\n\n        state LowBattery {\n            entry / \"Meter.AlertSystem.notifyUser('Low battery')\"\n        }\n\n        state CriticalBattery {\n            entry / [\n                \"Meter.AlertSystem.notifyUser('Replace battery immediately')\",\n                \"Disable measurement functions\"\n            ]\n        }\n\n        state MeasurementFault {\n            entry / [\n                \"Meter.AlertSystem.notifyUser('Measurement error')\",\n                \"Activate emergency protocols\"\n            ]\n        }\n\n        transition NormalToLow : NormalOperation -> LowBattery on \"Battery.level < 20%\"\n        transition LowToCritical : LowBattery -> CriticalBattery on \"Battery.level < 5%\"\n        transition AnyToFault : [NormalOperation, LowBattery, CriticalBattery] -> MeasurementFault on \"MeasurementModule.status == 'Fault'\"\n    }\n\n    constraint SafetyConstraints {\n        constraint reliability : String = \"System must maintain >99.9% uptime\"\n        constraint responseTime : String = \"Alerts must trigger within 2 seconds of detection\"\n    }\n\n    scenario BatteryFailureScenario {\n        step \"Battery depletion detected\" {\n            verify \"REQ-2\"\n        }\n        step \"User notification activated\" {\n            verify \"REQ-3\"\n        }\n        step \"Measurement functions disabled\" {\n            verify \"REQ-4\"\n        }\n        step \"Emergency protocols engaged\" {\n            verify \"REQ-7\"\n        }\n    }\n\n    HighReliability -> refine -> [BatteryDetection, UserAlert, AlarmMechanism]\n    FailurePrevention -> satisfy -> RiskManagement\n    TreatmentContinuity -> satisfy -> TimelySupport\n    OperationalStates -> verify -> [FailurePrevention, TreatmentContinuity]\n    BatteryFailureScenario -> validate -> [REQ-2, REQ-3, REQ-4, REQ-7]\n}",
    "package ScientificConstants {\n   value type MathematicalConstants {\n      value property e: Real [1] = 2.71828182845904523536;\n      value property pi: Real [1] = 3.14159265358979323846;\n   }\n\n   value type PhysicalConstants {\n      value property speedOfLight: Real (m/s) [1] = 299792458.0;\n      value property fineStructureConstant: Real [1] = 0.0072973525693;\n      value property electronProtonMassRatio: Real [1] = 0.000544617021;\n   }\n\n   value type ContextualConstants {\n      value property earthGravitationalAcceleration: Real (m/s^2) [1] = 9.80665;\n      value property modelXAmplifierGain: Real [1] = 100.0;\n   }\n\n   part def ConstantsSet {\n      value property math: MathematicalConstants [1];\n      value property physics: PhysicalConstants [1];\n      value property context: ContextualConstants [1];\n   }\n}",
    "part def Tire {\n   attribute manufacturer: String;\n   attribute rimDiameter: Real;\n   attribute width: Integer;\n}\n\npart michelinTire: Tire {\n   manufacturer: 'Michelin';\n   rimDiameter: 18.0;\n   width: 245;\n}",
    "package AutomotiveComponentModel {\n    import sysml::SIUnits;\n    import sysml::ImperialUnits;\n\n    part def Vehicle {\n        property mass: Real [unit = SIUnits::kg] = 1200;\n        property length: Real [unit = SIUnits::m] = 4.82;\n        part leftFrontWheel: Wheel;\n        part rightFrontWheel: Wheel;\n    }\n\n    part def Wheel {\n        property hubDiameter: Real [unit = ImperialUnits::in] = 18;\n        property width: Real [unit = SIUnits::mm] = 245;\n        part tire: Tire;\n        constant mmPerInch: Real = 25.4;\n        property outerDiameter: Real [unit = ImperialUnits::in] {\n            = hubDiameter + 2 * (tire.sidewallHeight / mmPerInch);\n        }\n    }\n\n    part def Tire {\n        property sidewallHeight: Real [unit = SIUnits::mm];\n    }\n}",
    "enum EngineType {\n   FourCylinder,\n   SixCylinder\n}\n\nenum TransmissionType {\n   Manual,\n   Automatic\n}\n\npart def Vehicle {\n   attribute isHighPerformance: Boolean;\n   attribute engineType: EngineType;\n   attribute transmissionType: TransmissionType;\n\n   constraint EngineRequirement {\n      engineType = if isHighPerformance then EngineType::SixCylinder else EngineType::FourCylinder endif\n   }\n\n   constraint PowertrainCombination {\n      (engineType = EngineType::FourCylinder and transmissionType = TransmissionType::Manual) or \n      (engineType = EngineType::SixCylinder and transmissionType = TransmissionType::Automatic)\n   }\n}",
    "package AutomotiveSystem {\n  part def Vehicle {\n    attribute totalMass: Real (unit: kg) = 1200;\n    attribute length: Real (unit: m) = 4.82;\n    part wheelAssemblies: WheelAssembly[*];\n  }\n\n  part def WheelAssembly {\n    part wheel: Wheel[1];\n    part brakeDisc: BrakeDisc[1];\n    constraint BrakeDiscFit {\n      brakeDisc.radius * 2 < wheel.outerDiameter\n    }\n  }\n\n  part def Wheel {\n    part rim: Rim[1];\n    part tire: Tire[1];\n    derived attribute outerDiameter: Real (unit: mm) = rim.diameter * 25.4 + 2 * tire.height;\n  }\n\n  part def Rim {\n    attribute diameter: Real (unit: inch) = 18;\n  }\n\n  part def Tire {\n    attribute width: Real (unit: mm) = 245;\n    attribute height: Real (unit: mm) = 45;\n    attribute treadDepth: Real (unit: mm) = 6.0;\n    attribute minTreadDepth: Real (unit: mm) = 3.5;\n    constraint TreadDepthSafety {\n      treadDepth >= minTreadDepth\n    }\n  }\n\n  part def BrakeDisc {\n    attribute radius: Real (unit: mm) = 95;\n  }\n}",
    "package AutomotiveFuelSystem {\n    value type Fuel;\n    signal TemperatureSignal {\n        value: Real;\n    }\n\n    requirement \"REQ1\" {\n        id: 'REQ1';\n        text: \"Monitor and transmit fuel temperature information.\";\n    }\n    requirement \"REQ2\" {\n        id: 'REQ2';\n        text: \"Enable efficient and safe fuel circulation among components.\";\n    }\n    requirement \"REQ3\" {\n        id: 'REQ3';\n        text: \"Meet vehicle requirements for fuel supply and return functions.\";\n    }\n    requirement \"REQ4\" {\n        id: 'REQ4';\n        text: \"Ensure normal fuel supply to engine.\";\n    }\n\n    block FuelTank {\n        port fuelOutlet: out Fuel;\n    }\n\n    block TemperatureSensor {\n        port temperatureOutput: out TemperatureSignal;\n    }\n\n    block FuelPump {\n        port fuelInlet: in Fuel;\n        port fuelSupplyOutlet: out Fuel;\n        port fuelReturnInlet: in Fuel;\n    }\n\n    block FuelTankAssembly {\n        part pump: FuelPump;\n        part tank: FuelTank;\n        part tempSensor: TemperatureSensor;\n        port fuelSupply: out Fuel;\n        port fuelReturn: in Fuel;\n        port temperatureOutput: out TemperatureSignal;\n\n        connections {\n            tank.fuelOutlet -> pump.fuelInlet;\n            pump.fuelSupplyOutlet -> fuelSupply;\n            fuelReturn -> pump.fuelReturnInlet;\n            tempSensor.temperatureOutput -> temperatureOutput;\n        }\n    }\n\n    block AutomotiveFuelSystem {\n        part fuelTankAssembly: FuelTankAssembly;\n        port fuelSupplyToEngine: out Fuel;\n        port fuelReturnFromEngine: in Fuel;\n        port temperatureOutput: out TemperatureSignal;\n\n        connections {\n            fuelTankAssembly.fuelSupply -> fuelSupplyToEngine;\n            fuelReturnFromEngine -> fuelTankAssembly.fuelReturn;\n            fuelTankAssembly.temperatureOutput -> temperatureOutput;\n        }\n\n        satisfy 'REQ1' by self;\n        satisfy 'REQ2' by self;\n        satisfy 'REQ3' by self;\n        satisfy 'REQ4' by self;\n    }\n}",
    "package PhysicalQuantitySystem {\n   quantity Length;\n   quantity Mass;\n   quantity Time;\n   quantity ElectricCurrent;\n   quantity ThermodynamicTemperature;\n   quantity AmountOfSubstance;\n   quantity LuminousIntensity;\n\n   unit m: Length;\n   unit kg: Mass;\n   unit s: Time;\n   unit A: ElectricCurrent;\n   unit K: ThermodynamicTemperature;\n   unit mol: AmountOfSubstance;\n   unit cd: LuminousIntensity;\n\n   unit cm: Length;\n   conversion cm to m: 0.01;\n   unit km: Length;\n   conversion km to m: 1000;\n   unit g: Mass;\n   conversion g to kg: 0.001;\n   unit min: Time;\n   conversion min to s: 60;\n   unit h: Time;\n   conversion h to s: 3600;\n\n   quantity Speed = Length / Time;\n   unit mps: Speed = m / s;\n   unit kmph: Speed = km / h;\n\n   quantity Force = Mass * Length / (Time ^ 2);\n   unit N: Force = kg * m / (s ^ 2);\n\n   part interface UnitConversionService {\n      operation convert(in value: Real, in fromUnit: Unit, in toUnit: Unit) : Real;\n   }\n\n   part interface QuantityValidation {\n      operation validateUnitConsistency(in quantityValue: Value, in expectedQuantity: Quantity) : Boolean;\n   }\n\n   part interface SystemExtension {\n      operation importQuantity(in newQuantity: Quantity);\n      operation importUnit(in newUnit: Unit, in forQuantity: Quantity);\n   }\n}",
    "package UnitSystemLibrary {\n    quantity kind Length;\n    quantity kind Mass;\n    quantity kind Time;\n    quantity kind Force;\n\n    unit system ISQ {\n        unit m: Length;\n        unit kg: Mass;\n        unit s: Time;\n        unit N: Force = (kg * m) / (s^2);\n    }\n\n    unit system USCustomaryUnits {\n        unit ft: Length;\n        unit lb: Mass;\n        unit s: Time;\n        unit lbf: Force;\n    }\n\n    conversion ft2m: USCustomaryUnits::ft -> ISQ::m {\n        factor: 0.3048;\n    }\n\n    conversion lb2kg: USCustomaryUnits::lb -> ISQ::kg {\n        factor: 0.45359237;\n    }\n\n    conversion s2s: USCustomaryUnits::s -> ISQ::s {\n        factor: 1.0;\n    }\n\n    conversion lbf2N: USCustomaryUnits::lbf -> ISQ::N {\n        factor: 4.4482216152605;\n    }\n}",
    "package HeadlampSystem {\n    unit deg;\n\n    part def HeadlampSystem {\n        attribute tiltAngle: Real[deg];\n    }\n\n    requirement def TiltAngleRequirement {\n        id: \"REQ1\";\n        text: \"Headlamp beam tilt angle must be between 50 and 80 degrees.\";\n    }\n\n    constraint def TiltAngleConstraint {\n        parameter angle: Real[deg];\n        constraint: angle >= 50.0 and angle <= 80.0;\n    }\n\n    verification def TiltAngleVerification {\n        verifiedRequirement: TiltAngleRequirement;\n        subject: HeadlampSystem;\n        verify {\n            constraint: TiltAngleConstraint(angle: subject.tiltAngle);\n        }\n    }\n}",
    "model DataTypesModel {\n    type UnsignedInteger: Integer {\n        constraint non_negative { this >= 0 }\n    }\n\n    type UnsignedReal: Real {\n        constraint non_negative { this >= 0.0 }\n    }\n\n    type DateTime: String\n\n    enum StatusLevel {\n        critical,\n        warning,\n        normal\n    }\n\n    type Status {\n        level: StatusLevel;\n        color: String {\n            derive {\n                if level == StatusLevel::critical then 'red'\n                else if level == StatusLevel::warning then 'yellow'\n                else 'green'\n            }\n        }\n    }\n\n    enum DiameterOption {\n        Small,\n        Medium,\n        Large\n    }\n\n    type Diameter {\n        option: DiameterOption = DiameterOption::Small;\n        value: Integer {\n            derive {\n                if option == DiameterOption::Small then 60\n                else if option == DiameterOption::Medium then 70\n                else 80\n            }\n        }\n    }\n}",
    "package CollectionManagement {\n    import SysML::PrimitiveValueTypes::*;\n\n    partdef SparePart {}\n\n    partdef Person {}\n\n    partdef CollectionManagerSystem {\n        attribute spareParts: Bag<SparePart>;\n        attribute integerList: List<Integer>;\n        attribute stringSet: Set<String>;\n        attribute personnel: OrderedSet<Person>;\n        attribute nestedPersonnel: List<Set<Person>>;\n        attribute realArray: Real[4];\n    }\n}",
    "package TireSystem {\n   unit inch;\n\n   block Position {\n      attribute x: Real;\n      attribute y: Real;\n      attribute z: Real;\n   }\n\n   block Tire {\n      attribute manufacturer: String;\n      attribute rimDiameter: Real[1] {\n         unit inch;\n      }\n      attribute width: Integer;\n      part installationPosition: Position[0..1];\n   }\n}",
    "package AscentTrajectoryRecording {\n    import Units::* from SysML;\n\n    value type Time redefines Real {\n        unit: s;\n    }\n\n    value type Position redefines Real[3] {\n        unit: m;\n    }\n\n    value type Velocity redefines Real[3] {\n        unit: m_per_s;\n    }\n\n    value type TrajectorySample {\n        time: Time;\n        position: Position;\n        velocity: Velocity;\n    }\n\n    block AscentTrajectoryRecorder {\n        value liftoffUTC: String;\n        value samples: TrajectorySample[*];\n    }\n}",
    "package MaterialScience {\n    unit u;\n    unit N;\n    unit mm;\n    derived unit N_per_mm2 = N / (mm^2);\n\n    abstract type Substance;\n\n    type Metal : Substance {\n        attribute atomicMass: value u;\n    }\n\n    part def Composition {\n        attribute material: Substance;\n        attribute massFraction: Real;\n    }\n\n    type Alloy : Substance {\n        part components: Composition[*];\n        attribute tensileStrength: value N_per_mm2;\n    }\n\n    individual iron: Metal {\n        atomicMass: 55.845 u\n    }\n\n    individual carbon: Metal {\n        atomicMass: 12.011 u\n    }\n\n    individual manganese: Metal {\n        atomicMass: 54.938 u\n    }\n\n    individual steel980: Alloy {\n        part components: [\n            Composition {\n                material: iron\n                massFraction: 0.98\n            },\n            Composition {\n                material: carbon\n                massFraction: 0.02\n            }\n        ],\n        tensileStrength: 980 N_per_mm2\n    }\n}",
    "package EngineeringMaterialsDatabase {\n    import SIUnits::*;\n\n    value type TensileStrength {\n        value: Real[1];\n        unit: MPa;\n    }\n\n    block Material {\n        attribute name: String[1];\n    }\n\n    block Element: Material {\n        attribute atomicMass: Real[1];\n    }\n\n    part def Constituent {\n        attribute massFraction: Real[1];\n        ref element: Element[1];\n    }\n\n    block Alloy: Material {\n        part composition: Constituent[*];\n        attribute tensileStrength: TensileStrength[0..1];\n    }\n}",
    "package PubSubSystem {\n  import SysML::Blocks::Interfaces;\n\n  type Topic;\n  type Message;\n\n  interface PublishingInterface {\n    in publish(topic: Topic, message: Message);\n  }\n\n  interface SubscriptionInterface {\n    in subscribe(topic: Topic);\n  }\n\n  interface DeliveryInterface {\n    in notify(topic: Topic, message: Message);\n  }\n\n  part def Producer {\n    port pubPort: <- PublishingInterface;\n  }\n\n  part def Consumer {\n    port subPort: <- SubscriptionInterface;\n    port deliveryPort: -> DeliveryInterface;\n  }\n\n  part def Server {\n    port pubPort: -> PublishingInterface;\n    port subPort: -> SubscriptionInterface;\n    port deliveryPort: <- DeliveryInterface[*];\n  }\n\n  part def PubSubSystem {\n    part server: Server;\n    part producers: Producer[*];\n    part consumers: Consumer[*];\n\n    connection pubConn: producers.pubPort to server.pubPort;\n    connection subConn: consumers.subPort to server.subPort;\n    connection deliveryConn: server.deliveryPort to consumers.deliveryPort;\n  }\n}",
    "package VehicleFuelSystem {\n    value type Temperature: Real;\n\n    block Fuel {\n        property temperature: Temperature;\n    }\n\n    block FuelTankAssembly {\n        port fuelSupply: out Fuel;\n        port fuelReturn: in Fuel;\n    }\n\n    block Engine {\n        port fuelInlet: in Fuel;\n        port fuelReturn: out Fuel;\n    }\n\n    block FuelLine {\n        port inlet: in Fuel;\n        port outlet: out Fuel;\n        port tempPort: out Temperature;\n        property currentTemperature: Temperature;\n    }\n\n    block TemperatureSensor {\n        port sensePort: in Temperature;\n    }\n\n    block Vehicle {\n        part fuelTank: FuelTankAssembly;\n        part engine: Engine;\n        part supplyLine: FuelLine;\n        part returnLine: FuelLine;\n        part supplyTempSensor: TemperatureSensor;\n        part returnTempSensor: TemperatureSensor;\n\n        connection supplyFlow: fuelTank.fuelSupply -> supplyLine.inlet :> Fuel;\n        connection engineSupply: supplyLine.outlet -> engine.fuelInlet :> Fuel;\n        connection returnFlow: engine.fuelReturn -> returnLine.inlet :> Fuel;\n        connection tankReturn: returnLine.outlet -> fuelTank.fuelReturn :> Fuel;\n\n        connection supplyTempMonitoring: supplyLine.tempPort -> supplyTempSensor.sensePort :> Temperature;\n        connection returnTempMonitoring: returnLine.tempPort -> returnTempSensor.sensePort :> Temperature;\n    }\n}",
    "package PublishSubscribeSystem {\n    type Message {\n        attribute topic: String;\n        attribute content: String;\n    }\n\n    type SubscriptionRequest {\n        attribute topic: String;\n    }\n\n    port type ProducerPort {\n        output publication: Message;\n    }\n\n    port type ConsumerPort {\n        output subscription: SubscriptionRequest;\n        input delivery: Message;\n    }\n\n    port type ServerInput {\n        input publication: Message;\n        input subscription: SubscriptionRequest;\n    }\n\n    port type ServerOutput {\n        output delivery: Message;\n    }\n\n    part def Producer {\n        port out: ProducerPort;\n    }\n\n    part def Consumer {\n        port server: ConsumerPort;\n    }\n\n    part def Server {\n        port in: ServerInput;\n        port out: ServerOutput;\n    }\n\n    requirement Reliability {\n        id: 'REQ1';\n        text: \"Ensure reliable message publishing and distribution\";\n    }\n\n    requirement Efficiency {\n        id: 'REQ2';\n        text: \"Enable efficient information exchange between participants\";\n    }\n\n    part def PubSubSystem {\n        part producers: Producer[1..*];\n        part server: Server;\n        part consumers: Consumer[1..*];\n\n        satisfy msgReliability: Reliability;\n        satisfy exchangeEfficiency: Efficiency;\n\n        connections {\n            connect producers.out -> server.in [publication];\n            connect consumers.server -> server.in [subscription];\n            connect server.out -> consumers.server [delivery];\n        }\n    }\n}",
    "package TransportationService {\n    part def Vehicle {\n        attribute fuelLevel: Real;\n        attribute maxFuelCapacity: Real;\n        constraint fuelLow: fuelLevel < 0.1 * maxFuelCapacity;\n    }\n\n    part def Driver;\n    part def Passenger [0..4];\n    part def GasStation;\n\n    use case ProvideTransportation {\n        satisfy requirement EfficientTravel;\n        satisfy requirement SafeExperience;\n    }\n\n    use case BoardVehicle {\n        performer Driver;\n        performer Passenger;\n    }\n\n    use case OperateVehicle {\n        performer Driver;\n        include MonitorEnvironment;\n    }\n\n    use case RefuelVehicle {\n        performer Driver;\n        part GasStation;\n        condition Vehicle::fuelLow;\n    }\n\n    use case ExitVehicle {\n        performer Driver;\n        performer Passenger;\n    }\n\n    use case MonitorEnvironment;\n\n    requirement EfficientTravel: \"Ensure efficient travel experience\";\n    requirement SafeExperience: \"Ensure safe boarding/alighting\";\n\n    state machine VehicleStates for Vehicle {\n        state Empty;\n        state Boarding: entry / BoardVehicle;\n        state Travelling: do / OperateVehicle;\n        state Refueling: entry / RefuelVehicle;\n        state Exiting: entry / ExitVehicle;\n\n        initial -> Empty;\n        Empty -> Boarding: on BoardVehicle;\n        Boarding -> Travelling: after all boarded;\n        Travelling -> Refueling: when fuelLow;\n        Refueling -> Travelling: after refueled;\n        Travelling -> Exiting: after travelComplete;\n        Exiting -> Empty: after all exited;\n    }\n\n    scenario NormalJourney {\n        step 1: BoardVehicle;\n        step 2: OperateVehicle;\n        step 3: [Vehicle::fuelLow] RefuelVehicle;\n        step 4: OperateVehicle;\n        step 5: ExitVehicle;\n    }\n}",
    "package FuelManagementSystem {\n    requirement def FunctionalReq {\n        requirement id: 'REQ1';\n        text: \"Provide fuel supply and return management for vehicle engine operation.\";\n    }\n    requirement def MonitoringReq {\n        requirement id: 'REQ2';\n        text: \"Monitor real-time fuel parameters including temperature during supply/return processes.\";\n    }\n    requirement def ReliabilityReq {\n        requirement id: 'REQ3';\n        text: \"Ensure continuous and reliable fuel supply to support engine requirements.\";\n    }\n    requirement def SafetyReq {\n        requirement id: 'REQ4';\n        text: \"Improve overall vehicle fuel management safety through return processing.\";\n    }\n\n    interface def FuelInterface {\n        attribute fuelTemperature: Real;\n    }\n\n    part def FuelTankAssembly {\n        port fuelOutlet: out FuelInterface;\n        port fuelReturn: in FuelInterface;\n    }\n\n    part def EngineUnit {\n        port fuelInlet: in FuelInterface;\n        port fuelReturnOutlet: out FuelInterface;\n    }\n\n    part def VehicleFuelSystem {\n        part tank: FuelTankAssembly;\n        part engine: EngineUnit;\n\n        connection supplyFlow: tank.fuelOutlet -> engine.fuelInlet;\n        connection returnFlow: engine.fuelReturnOutlet -> tank.fuelReturn;\n\n        satisfy supplySatisfaction {\n            satisfiedBy: supplyFlow;\n            satisfies: FunctionalReq, ReliabilityReq;\n        }\n        satisfy returnSatisfaction {\n            satisfiedBy: returnFlow;\n            satisfies: FunctionalReq, SafetyReq;\n        }\n        satisfy monitoringSatisfaction {\n            satisfiedBy: FuelInterface;\n            satisfies: MonitoringReq;\n        }\n    }\n}",
    "package VehicleFuelSystem {\n    import SI;\n\n    item Fuel;\n\n    interface block FuelSupplyInterface {\n        flow fuelFlow: out ItemFlow<Fuel>;\n        value temperature: Real[1];\n    }\n\n    interface block FuelReturnInterface {\n        flow fuelFlow: out ItemFlow<Fuel>;\n        value temperature: Real[1];\n    }\n\n    part def FuelTankAssembly {\n        port supplyPort: FuelSupplyInterface;\n        port returnPort: conjugate FuelReturnInterface;\n    }\n\n    part def Engine {\n        port supplyPort: conjugate FuelSupplyInterface;\n        port returnPort: FuelReturnInterface;\n    }\n\n    part def VehicleFuelSystem {\n        part tank: FuelTankAssembly;\n        part engine: Engine;\n\n        connection supplyLine: tank.supplyPort <-> engine.supplyPort;\n        connection returnLine: engine.returnPort <-> tank.returnPort;\n    }\n\n    requirement \"Reliability\" {\n        requirementId: \"REQ-1\";\n        text: \"System shall maintain fuel delivery reliability during normal operation\";\n    }\n\n    requirement \"Safety\" {\n        requirementId: \"REQ-2\";\n        text: \"System shall ensure safe fuel handling and temperature monitoring\";\n    }\n\n    requirement \"Monitoring\" {\n        requirementId: \"REQ-3\";\n        text: \"System shall provide real-time fuel temperature tracking at all interfaces\";\n    }\n\n    requirement \"Efficiency\" {\n        requirementId: \"REQ-4\";\n        text: \"System shall optimize fuel flow efficiency in supply and return processes\";\n    }\n}",
    "package PhotoCaptureSystem {\n    part def User {\n        attribute sceneSelection: SceneSelection;\n    }\n\n    part def PhotoCaptureSystem {\n        part focusModule: FocusModule;\n        part captureModule: CaptureModule;\n\n        operation capturePhoto(in sceneSelection: SceneSelection): FinalPhoto {\n            activity {\n                val focusedImage = focusModule.performFocusing(sceneSelection);\n                val finalPhoto = captureModule.capturePhoto(focusedImage);\n                return finalPhoto;\n            }\n        }\n    }\n\n    part def FocusModule {\n        operation performFocusing(in sceneSelection: SceneSelection): FocusedImage;\n    }\n\n    part def CaptureModule {\n        operation capturePhoto(in focusedImage: FocusedImage): FinalPhoto;\n    }\n\n    type SceneSelection;\n    type FocusedImage;\n    type FinalPhoto;\n\n    use case CapturePhoto {\n        performer: User;\n        subject: PhotoCaptureSystem;\n    }\n}",
    "package PhotographyWorkflow {\n    part def PhotographySystem {\n        behavior: PhotographyWorkflow;\n    }\n\n    activity def PhotographyWorkflow {\n        in parameter selectedScene: Scene;\n        out parameter finalPhotograph: Photograph;\n\n        action focusing: {\n            in parameter scene: Scene;\n            out parameter focusedImage: FocusedImage;\n        }\n\n        action shooting: {\n            in parameter image: FocusedImage;\n            out parameter photograph: Photograph;\n        }\n\n        edge selectedScene -> focusing.scene;\n        edge focusing.focusedImage -> shooting.image;\n        edge shooting.photograph -> finalPhotograph;\n    }\n\n    item def Scene;\n    item def FocusedImage;\n    item def Photograph;\n\n    requirement 'Efficiency' {\n        id: 'NF1',\n        text: 'System operation process is concise and coherent enabling efficient photography'\n    }\n\n    requirement 'Quality' {\n        id: 'NF2',\n        text: 'Output photographs must meet high-quality standards'\n    }\n\n    satisfy 'SatisfyEfficiency' {\n        requirement = 'Efficiency',\n        satisfiedBy = PhotographyWorkflow\n    }\n\n    satisfy 'SatisfyQuality' {\n        requirement = 'Quality',\n        satisfiedBy = PhotographyWorkflow\n    }\n}",
    "package PhotographyWorkflow {\n    item def Scene;\n    item def Image;\n    item def Photograph;\n\n    action def Focusing {\n        in selectedScene: Scene;\n        out focusedImage: Image;\n    }\n\n    action def Shooting {\n        in inputImage: Image;\n        out finalPhotograph: Photograph;\n    }\n\n    activity PhotographyWorkflow {\n        in sceneSelection: Scene;\n        out resultPhoto: Photograph;\n\n        action focus: Focusing;\n        action shoot: Shooting;\n\n        sequence {\n            focus;\n            shoot;\n        }\n\n        binding sceneSelection to focus.selectedScene;\n        binding focus.focusedImage to shoot.inputImage;\n        binding shoot.finalPhotograph to resultPhoto;\n    }\n\n    part def PhotographySystem {\n        ownedBehavior: PhotographyWorkflow;\n    }\n\n    requirement def AutoCompletionReq {\n        reqId: \"R1\";\n        text: \"Automatically complete focusing and shooting steps without manual intervention\";\n    }\n\n    requirement def QualityReq {\n        reqId: \"R2\";\n        text: \"Produce high-quality photographs from selected scenes\";\n    }\n\n    satisfy {\n        PhotographySystem satisfies AutoCompletionReq;\n        PhotographySystem satisfies QualityReq;\n    }\n}",
    "part def Scene;\npart def Image;\npart def Photograph;\nrequirement 'AutomatedFocus' {\n   id: 'R1';\n   text: 'Perform focus processing on input scene to generate suitable image.';\n}\nrequirement 'AutomatedShooting' {\n   id: 'R2';\n   text: 'Convert focused image into photograph through shooting operation.';\n}\nrequirement 'SeamlessIntegration' {\n   id: 'R3';\n   text: 'Integrate focusing and shooting without user intervention.';\n}\nrequirement 'Efficiency' {\n   id: 'R4';\n   text: 'Simplify workflow for easy and efficient photograph acquisition.';\n}\nactivity AutomatedPhotographyProcess {\n   input scene: Scene;\n   output photo: Photograph;\n   action focusProcessing: {\n      input scene: Scene;\n      output focusedImage: Image;\n   }\n   action shootingOperation: {\n      input focusedImage: Image;\n      output photo: Photograph;\n   }\n   edge scene -> focusProcessing.scene;\n   edge focusProcessing.focusedImage -> shootingOperation.focusedImage;\n   edge shootingOperation.photo -> photo;\n}\npart AutomatedPhotographySystem {\n   satisfy: {\n      'R1',\n      'R2',\n      'R3',\n      'R4'\n   }\n   behavior: AutomatedPhotographyProcess;\n}",
    "package PhotographyWorkflow {\n    value type Scene;\n    value type Image;\n    value type Picture;\n\n    activity Focus {\n        input inScene: Scene;\n        output outImage: Image;\n    }\n\n    activity Shoot {\n        input inImage: Image;\n        output outPicture: Picture;\n    }\n\n    activity PhotographyActivity {\n        input scene: Scene;\n        output picture: Picture;\n\n        action focus: Focus;\n        action shoot: Shoot;\n\n        edge scene -> focus.inScene;\n        edge focus.outImage -> shoot.inImage;\n        edge shoot.outPicture -> picture;\n    }\n\n    part def PhotographySystem {\n        ownedBehavior: PhotographyActivity;\n    }\n}",
    "package PhotographySystem {\n    value type Scene;\n    value type Image;\n\n    activity def PhotographyWorkflow {\n        in selectedScene: Scene;\n        out photograph: Image;\n\n        action focus: {\n            in scene: Scene;\n            out focusStatus: Boolean;\n        }\n\n        action capture: {\n            in scene: Scene;\n            out image: Image;\n        }\n\n        initial node start;\n        final node end;\n\n        edge selectedScene -> focus.scene;\n        edge selectedScene -> capture.scene;\n        edge start -> focus;\n        edge focus -> capture when {focus.focusStatus == true};\n        edge capture.image -> photograph;\n        edge capture -> end;\n    }\n}",
    "part def Scene;\npart def Image;\npart def Photo;\nactivity Focus in (scene: Scene) out (image: Image);\nactivity EvaluateFocus in (image: Image) out (isWellFocused: Boolean);\nactivity Shoot in (image: Image) out (photo: Photo);\nactivity CaptureHighQualityPhotograph in (selectedScene: Scene) out (finalPhoto: Photo) {\n    action focus: Focus;\n    action evaluate: EvaluateFocus;\n    action shoot: Shoot;\n    edge start -> focus;\n    edge focus -> evaluate;\n    edge evaluate -> decision: Decision;\n    edge decision -> shoot when evaluate.isWellFocused;\n    edge decision -> focus when not evaluate.isWellFocused;\n    edge shoot -> end;\n    object flow selectedScene -> focus.scene;\n    object flow shoot.photo -> finalPhoto;\n}",
    "model PhotographyWorkflowModel;\n\ntype Scene;\ntype FocusedImage;\ntype Photograph;\n\nactivity PhotographyWorkflow {\n    action acquireScene {\n        output: scene [Scene];\n    }\n    action focus {\n        input: scene [Scene];\n        output: focusedImage [FocusedImage];\n    }\n    action shoot {\n        input: focusedImage [FocusedImage];\n        output: photo [Photograph];\n    }\n    action display {\n        input: photo [Photograph];\n    }\n    edge acquireScene.scene -> focus.scene;\n    edge focus.focusedImage -> shoot.focusedImage;\n    edge shoot.photo -> display.photo;\n    sequence {\n        acquireScene;\n        focus;\n        shoot;\n        display;\n    }\n}\n\nblock PhotographySystem {\n    operation take_photo {\n        method: PhotographyWorkflow;\n    }\n}\n\nrequirement AutoComplete: \"Automatically complete all steps after single trigger\";\nrequirement SeamlessIntegration: \"Seamlessly integrate process without manual intervention\";\nrequirement ImmediateDisplay: \"Immediately display photo after shooting\";\n\nsatisfy {\n    PhotographySystem satisfies AutoComplete;\n    PhotographySystem satisfies SeamlessIntegration;\n    PhotographySystem satisfies ImmediateDisplay;\n}",
    "package AutomaticBrakingControlSystem {\n    part def Vehicle {\n        port brakePedal: BrakePedal;\n        port tractionSensor: TractionSensor;\n    }\n\n    part def BrakePedal {\n        attribute pressure: Real;\n    }\n\n    part def TractionSensor {\n        attribute roadAdhesion: Real;\n    }\n\n    part def BrakingController {\n        port input brakeInput: BrakePedal;\n        port input tractionInput: TractionSensor;\n        port output brakeOutput: BrakeActuator;\n    }\n\n    part def BrakeActuator {\n        operation adjustPressure(in pressure: Real);\n        operation adjustFrequency(in frequency: Real);\n    }\n\n    requirement Functional {\n        :> 'Activate system when vehicle key turns to start position';\n        :> 'Continuously monitor brake pedal status';\n        :> 'Continuously monitor traction information (road adhesion)';\n        :> 'Detect brake pressure during pedal press';\n        :> 'Evaluate traction variations across road conditions';\n        :> 'Adjust brake pressure during braking';\n        :> 'Adjust modulation frequency during braking';\n    }\n\n    requirement NonFunctional {\n        :> 'Ensure safe braking performance under all conditions';\n        :> 'Ensure reliable braking performance under all conditions';\n        :> 'Enhance driving safety';\n        :> 'Enhance driving comfort';\n        :> 'Operate without user intervention';\n        :> 'Maintain optimal braking system state';\n    }\n\n    activity AutomaticBrakingControl {\n        param vehicle: Vehicle;\n        param controller: BrakingController;\n\n        start;\n        loop {\n            action MonitorInputs {\n                :> 'Read brake pedal pressure';\n                :> 'Read road adhesion data';\n            }\n\n            action EvaluateConditions {\n                :> 'Detect brake pressure changes';\n                :> 'Analyze traction variations';\n            }\n\n            decision [brakeEngaged] {\n                if (brakeEngaged) {\n                    action AdjustBraking {\n                        :> 'Calculate optimal pressure';\n                        :> 'Calculate optimal frequency';\n                        :> 'Send adjustment commands';\n                    }\n                }\n            }\n        }\n    }\n\n    Vehicle satisfies Functional::'Continuously monitor brake pedal status';\n    Vehicle satisfies Functional::'Continuously monitor traction information (road adhesion)';\n    BrakingController satisfies Functional::'Detect brake pressure during pedal press';\n    BrakingController satisfies Functional::'Evaluate traction variations across road conditions';\n    BrakeActuator satisfies Functional::'Adjust brake pressure during braking';\n    BrakeActuator satisfies Functional::'Adjust modulation frequency during braking';\n    AutomaticBrakingControl satisfies Functional::'Activate system when vehicle key turns to start position';\n    AutomaticBrakingControl satisfies NonFunctional::'Operate without user intervention';\n    AutomaticBrakingControl satisfies NonFunctional::'Maintain optimal braking system state';\n    AutomaticBrakingControl satisfies NonFunctional::'Ensure safe braking performance under all conditions';\n    AutomaticBrakingControl satisfies NonFunctional::'Ensure reliable braking performance under all conditions';\n    AutomaticBrakingControl satisfies NonFunctional::'Enhance driving safety';\n    AutomaticBrakingControl satisfies NonFunctional::'Enhance driving comfort';\n}",
    "package BatteryChargingSystem {\n    block BatteryChargingControlSystem {\n        attribute batteryLevel: Real; // Represents current charge percentage\n        \n        part charger: Charger;\n        part monitor: BatteryMonitor;\n        \n        requirement \"AutoCharge\":\n            \"Automatically supply charge when battery level < 100%\";\n        requirement \"TerminateCharge\":\n            \"Terminate charging when battery level >= 100%\";\n        requirement \"NoManualIntervention\":\n            \"Operate without manual intervention\";\n        \n        state machine {\n            initial -> Checking;\n            \n            state Checking {\n                on batteryLevelUpdated [\n                    batteryLevel < 100\n                ] -> Charging;\n                on batteryLevelUpdated [\n                    batteryLevel >= 100\n                ] -> NotCharging;\n            }\n            \n            state Charging {\n                entry / { charger.start(); }\n                exit / { charger.stop(); }\n                on batteryLevelUpdated [\n                    batteryLevel >= 100\n                ] -> NotCharging;\n            }\n            \n            state NotCharging {\n                on batteryLevelUpdated [\n                    batteryLevel < 100\n                ] -> Charging;\n            }\n        }\n    }\n    \n    block Charger {\n        operation start();\n        operation stop();\n    }\n    \n    block BatteryMonitor {\n        event batteryLevelUpdated: Real; // Triggers on level change\n        attribute measurementAccuracy: Real; // Non-functional: precision\n    }\n    \n    association ChargingControl {\n        BatteryChargingControlSystem.charger to Charger;\n        BatteryChargingControlSystem.monitor to BatteryMonitor;\n    }\n}",
    "package BatteryChargingSystem {\n    import SysML::Activities;\n    import SysML::Blocks;\n    import SysML::StateMachines;\n\n    block Battery {\n        attribute level: Real; // Represents charge percentage\n    }\n\n    block ChargingController {\n        part battery: Battery;\n\n        state machine ChargingStateMachine {\n            state Idle;\n            state Charging {\n                state Monitoring;\n                state Replenishing;\n            };\n\n            initial => Idle;\n            transition startCharging: Idle -> Charging [battery.level < 100.0];\n            transition monitor: Charging -> Monitoring;\n            transition replenish: Monitoring -> Replenishing [battery.level < 100.0];\n            transition complete: Monitoring -> Idle [battery.level >= 100.0];\n            transition continue: Replenishing -> Monitoring;\n        }\n\n        activity ChargeBattery {\n            inout battery: Battery;\n            action start: battery.level = battery.level; // Placeholder for charging initiation\n            loop {\n                action monitor: currentLevel = battery.level;\n                if currentLevel < 100.0 {\n                    action replenish: battery.level = battery.level; // Placeholder for charging action\n                } else {\n                    break;\n                }\n            }\n        }\n    }\n\n    requirement Requirements {\n        functional: \"Monitor battery level continuously during charging\";\n        functional: \"Replenish battery when level < 100%\";\n        functional: \"Terminate charging when level >= 100%\";\n        non-functional: \"Fully automated operation\";\n        non-functional: \"Prevent overcharging\";\n        non-functional: \"Ensure safe and reliable charging\";\n    }\n\n    constraint SafetyConstraint {\n        \"Battery level shall never exceed 100% during charging\": \n            ChargingController.ChargingStateMachine implies battery.level <= 100.0;\n    }\n}",
    "package CameraSystem {\n   part def Camera {\n      part autofocus: AutofocusSubsystem;\n      part imaging: ImagingSubsystem;\n      attribute photos: Photo[*];\n\n      action def takePhoto {\n         in scene: Scene;\n         out photo: Photo;\n\n         sequence {\n            autofocus.focus(in scene, out clearImage);\n            imaging.capture(in clearImage, out photo);\n            photos = photos->append(photo);\n         }\n      }\n   }\n\n   part def AutofocusSubsystem {\n      action def focus {\n         in scene: Scene;\n         out clearImage: ClearImage;\n      }\n   }\n\n   part def ImagingSubsystem {\n      action def capture {\n         in clearImage: ClearImage;\n         out photo: Photo;\n      }\n   }\n\n   item def Scene;\n   item def ClearImage;\n   item def Photo;\n\n   requirement def PhotoQuality {\n      id: \"RQ1\";\n      text: \"Produce clear, realistic high-quality photos\";\n   }\n\n   requirement def Automation {\n      id: \"RQ2\";\n      text: \"Automatically complete focusing and imaging without user intervention\";\n   }\n\n   satisfy PhotoQualitySatisfaction {\n      requirement = PhotoQuality;\n      satisfiedBy = Camera::takePhoto;\n   }\n\n   satisfy AutomationSatisfaction {\n      requirement = Automation;\n      satisfiedBy = Camera::takePhoto;\n   }\n}",
    "package DigitalCameraSystem {\n    part def DigitalCamera {\n        part viewfinder: Viewfinder;\n        part autofocus: AutoFocus;\n        part imaging: Imaging;\n    }\n\n    part def Viewfinder {\n        action selectScene: SelectScene;\n    }\n\n    part def AutoFocus {\n        action focus: Focus;\n    }\n\n    part def Imaging {\n        action capture: Capture;\n        action producePhoto: ProducePhoto;\n    }\n\n    action def SelectScene {\n        in sceneSelection: Selection;\n    }\n\n    action def Focus {\n        in targetScene: Scene;\n        out focusStatus: Status;\n    }\n\n    action def Capture {\n        in scene: Scene;\n        out rawImage: Image;\n    }\n\n    action def ProducePhoto {\n        in rawImage: Image;\n        out finalPhoto: Photo;\n    }\n\n    requirement \"Automated Shooting Process\" {\n        requirementId: \"R1\";\n        text: \"Fully automate viewfinding, focusing, and imaging without manual intervention\";\n    }\n\n    requirement \"High-Quality Output\" {\n        requirementId: \"R2\";\n        text: \"Produce high-quality photos meeting user requirements\";\n    }\n\n    requirement \"User Efficiency\" {\n        requirementId: \"R3\";\n        text: \"Provide efficient and convenient shooting experience\";\n    }\n\n    activity ShootingProcess {\n        in sceneSelection: Selection;\n        out finalPhoto: Photo;\n\n        node start: InitialNode;\n        node select: Action = Viewfinder.selectScene(sceneSelection);\n        node focus: Action = AutoFocus.focus(select.targetScene);\n        node capture: Action = Imaging.capture(focus.targetScene);\n        node produce: Action = Imaging.producePhoto(capture.rawImage);\n        node end: ActivityFinalNode;\n\n        edge start -> select;\n        edge select -> focus;\n        edge focus -> capture;\n        edge capture -> produce;\n        edge produce -> end;\n    }\n\n    satisfy \"R1_Satisfaction\" {\n        requirement = \"R1\";\n        subject = ShootingProcess;\n    }\n\n    satisfy \"R2_Satisfaction\" {\n        requirement = \"R2\";\n        subject = Imaging.producePhoto;\n    }\n\n    satisfy \"R3_Satisfaction\" {\n        requirement = \"R3\";\n        subject = ShootingProcess;\n    }\n}",
    "part def VehicleSimulator {\n    attribute mass: Real;\n    attribute initialPosition: Real;\n    attribute initialVelocity: Real;\n    attribute timeStep: Real;\n    attribute powerSequence: Real[*];\n    attribute trajectory: Real[*];\n    \n    operation runSimulation() {\n        method: language = \"pseudo\",\n        body = \"\n            n = size(powerSequence);\n            trajectory = new Real[n+1];\n            trajectory[0] = initialPosition;\n            v = initialVelocity;\n            x = initialPosition;\n            epsilon = 1e-10;\n            for (i = 0; i < n; i++) {\n                P = powerSequence[i];\n                if (abs(v) < epsilon && abs(P) < epsilon) {\n                    a = 0;\n                } else if (abs(v) < epsilon) {\n                    a = (P >= 0 ? 1 : -1) * sqrt(2 * abs(P) / (mass * timeStep));\n                } else {\n                    a = P / (mass * v);\n                }\n                v_next = v + a * timeStep;\n                x_next = x + v * timeStep + 0.5 * a * timeStep^2;\n                trajectory[i+1] = x_next;\n                v = v_next;\n                x = x_next;\n            }\n        \";\n    }\n}",
    "value type Scene;\nvalue type Image;\nvalue type Photo;\n\nactivity FocusingActivity {\n    in scene: Scene;\n    out image: Image;\n}\n\nactivity CapturingActivity {\n    in image: Image;\n    out photo: Photo;\n}\n\nactivity DisplayActivity {\n    in photo: Photo;\n}\n\npart def FocusingMechanism {\n    behavior focusing: FocusingActivity;\n}\n\npart def CapturingMechanism {\n    behavior capturing: CapturingActivity;\n}\n\npart def Display {\n    behavior displaying: DisplayActivity;\n}\n\nblock CameraSystem {\n    part focus: FocusingMechanism;\n    part capture: CapturingMechanism;\n    part display: Display;\n\n    activity ShootingProcess {\n        in scene: Scene;\n        \n        action focusAction: focus.focusing;\n        action captureAction: capture.capturing;\n        action displayAction: display.displaying;\n        \n        flow from scene to focusAction.scene;\n        flow from focusAction.image to captureAction.image;\n        flow from captureAction.photo to displayAction.photo;\n    }\n    \n    behavior shooting: ShootingProcess;\n}",
    "value type Scene;\nvalue type Image;\nvalue type Picture;\n\npart def CameraSystem {\n    port viewPort: in EventPort<Scene>;\n    port displayPort: out EventPort<Picture>;\n\n    action receiveScene {\n        port: viewPort;\n        output: scene: Scene;\n    }\n\n    action sendPicture {\n        port: displayPort;\n        input: pic: Picture;\n    }\n\n    action focus {\n        input: scene: Scene;\n        output: img: Image;\n    }\n\n    action capture {\n        input: img: Image;\n        output: pic: Picture;\n    }\n\n    activity SystemWorkflow {\n        while true {\n            action receiveScene;\n            action focus {\n                input: scene = receiveScene.scene;\n            }\n            action capture {\n                input: img = focus.img;\n            }\n            action sendPicture {\n                input: pic = capture.pic;\n            }\n        }\n    }\n\n    behavior: SystemWorkflow;\n}\n\nactor User;\n\nuse case def TakePicture {\n    actor: User;\n    subject: CameraSystem;\n}",
    "package SensorSystem {\n    enum StatusKind {\n        ready,\n        updating,\n        offline\n    }\n\n    part def Sensor {\n        attribute status: StatusKind;\n        operation update();\n    }\n\n    part def SensorManagementSystem {\n        part sensors: Sensor[*];\n        operation monitorAndUpdate();\n    }\n\n    activity SensorManagementSystem::monitorAndUpdate() {\n        for sensor in self.sensors {\n            if sensor.status == StatusKind::ready {\n                sensor.update();\n            }\n        }\n    }\n}",
    "package VehiclePowerManagement {\n    signal startSignal\n    signal powerOnSignal\n    signal shutdownSignal\n\n    state machine VehicleStateMachine {\n        state off {\n            transition on startSignal -> starting\n            internal transition on shutdownSignal\n        }\n\n        state starting {\n            transition on powerOnSignal -> on\n            transition on shutdownSignal -> off\n        }\n\n        state on {\n            transition on shutdownSignal -> off\n        }\n\n        initial -> off\n    }\n}",
    "event VehicleStartSignal;\nevent VehicleOnSignal;\nevent VehicleOffSignal;\n\nstate machine VehicleStateManager {\n    initial state off;\n    state starting;\n    state on;\n\n    transition from off to starting on VehicleStartSignal;\n    transition from starting to on on VehicleOnSignal;\n    transition from on to off on VehicleOffSignal;\n}",
    "package VehiclePowerManagement {\n    event vehicleStartCommand;\n    event vehicleStartedSignal;\n    event vehicleShutdownCommand;\n\n    behavior performSelfDiagnosis;\n    behavior supplyPowerToFunctionalUnits;\n    behavior executeSafetyOperations;\n\n    block VehiclePowerManager {\n        state machine PowerStateBehavior {\n            initial default offState: Off;\n            state Off;\n            state StartPhase;\n            state PoweredOn {\n                do performSelfDiagnosis;\n                do supplyPowerToFunctionalUnits;\n            }\n            transition t1: Off -> StartPhase on vehicleStartCommand;\n            transition t2: StartPhase -> PoweredOn on vehicleStartedSignal;\n            transition t3: PoweredOn -> Off on vehicleShutdownCommand then executeSafetyOperations;\n        }\n        classifierBehavior PowerStateBehavior;\n    }\n}",
    "package VehicleStateManagement {\n    event vehicleStartSignal;\n    event vehicleStartedSignal;\n    event vehicleShutdownSignal;\n\n    state machine VehicleStateMachine {\n        initial state shutdown;\n        state start_up;\n        state running;\n\n        transition t1: shutdown -> start_up on vehicleStartSignal;\n        transition t2: start_up -> running on vehicleStartedSignal;\n        transition t3: running -> shutdown on vehicleShutdownSignal;\n    }\n\n    block VehicleSystem {\n        state behavior: VehicleStateMachine;\n    }\n}",
    "package PowerManagement {\n    signal startSignal;\n    signal onSignal;\n    signal offSignal;\n\n    requirement FunctionalReq {\n        text: \"The system shall transition from Off to Start state upon startSignal, from Start to On state upon onSignal after startup completion, and from On to Off state upon offSignal.\";\n    }\n    requirement NonFunctionalReq {\n        text: \"The system shall ensure accurate and prompt state transitions in response to user control signals.\";\n    }\n    requirement HealthReq {\n        text: \"The system shall reserve functionality for future health state management expansion.\";\n    }\n\n    state machine VehiclePowerManagement {\n        satisfy FunctionalReq;\n        satisfy NonFunctionalReq;\n        satisfy HealthReq;\n\n        region operating {\n            initial -> Off;\n            state Off {\n                transition -> Start on startSignal\n            }\n            state Start {\n                transition -> On on onSignal\n            }\n            state On {\n                transition -> Off on offSignal\n            }\n        }\n        region health {\n            state Normal;\n        }\n    }\n}",
    "package VehicleHealthMonitoring {\n    enum HealthStatusMode {\n        normal,\n        degraded,\n        maintenance\n    }\n\n    event maintenanceCompleted\n\n    part def VehicleController\n\n    block VehicleHealthMonitoringSystem {\n        attribute currentTemperature: Real;\n        attribute maxAllowableTemperature: Real = 100.0;\n        attribute healthStatus: HealthStatusMode;\n        attribute nextMaintenanceTime: Time;\n        attribute maintenanceInterval: Duration = 5184000.0; // 60 days in seconds\n\n        operation sendWarning() {\n            // Sends warning to VehicleController\n        }\n        operation updateNextMaintenanceTime() {\n            // Updates nextMaintenanceTime\n        }\n\n        part controller: VehicleController;\n\n        state behavior HealthStatusStateMachine {\n            state normal {\n                entry: { healthStatus = HealthStatusMode::normal; }\n                transition -> maintenance at nextMaintenanceTime\n                transition -> degraded when currentTemperature > maxAllowableTemperature {\n                    effect: sendWarning()\n                }\n            }\n\n            state degraded {\n                entry: { healthStatus = HealthStatusMode::degraded; }\n                transition -> normal when currentTemperature <= maxAllowableTemperature\n            }\n\n            state maintenance {\n                entry: { healthStatus = HealthStatusMode::maintenance; }\n                internal transition on maintenanceCompleted {\n                    effect: updateNextMaintenanceTime()\n                }\n                transition -> normal after 48 hr\n            }\n        }\n    }\n}",
    "package ServerSystem {\n    event def StartEvent\n    event def RequestEvent\n\n    port def RequestPort {\n        received event StartEvent\n        received event RequestEvent\n    }\n\n    state machine ServerBehavior {\n        initial off\n        state off\n        state waiting\n        state response\n\n        transition off -> waiting on StartEvent\n        transition waiting -> response on RequestEvent\n        transition response -> waiting after 5 min\n        transition * -> off at '11:59:00'\n    }\n\n    part def Server {\n        port requestPort: RequestPort\n        behavior: ServerBehavior\n    }\n}",
    "package VehicleStartStopSystem {\n    signal UserStartSignal;\n    signal PowerOnSignal;\n    signal StopSignal;\n    signal ControllerStartSignal;\n\n    block Controller {\n        reception startSignal: ControllerStartSignal;\n    }\n\n    block VehicleStartStopSystem {\n        part controller: Controller;\n        value brakePedalDepressed: Boolean;\n\n        state machine {\n            state Off;\n            state StartProcess;\n            state Operating {\n                entry / selfCheck();\n                do / supplyPower();\n                exit / applyParkingBrake();\n            }\n\n            initial => Off;\n            Off -> StartProcess on UserStartSignal;\n            StartProcess -> Operating on PowerOnSignal [brakePedalDepressed] / {\n                send ControllerStartSignal to controller;\n            }\n            Operating -> Off on StopSignal;\n        }\n\n        operation selfCheck();\n        operation supplyPower();\n        operation applyParkingBrake();\n    }\n\n    requirement SafetyReq {\n        id: 'REQ1';\n        text: \"Ensure safety during start-stop process.\";\n    }\n    requirement ReliabilityReq {\n        id: 'REQ2';\n        text: \"Ensure reliable start-stop control.\";\n    }\n    requirement CoordinatedControlReq {\n        id: 'REQ3';\n        text: \"Coordinate control with controller.\";\n    }\n\n    satisfy SafetyReq by VehicleStartStopSystem;\n    satisfy ReliabilityReq by VehicleStartStopSystem;\n    satisfy CoordinatedControlReq by VehicleStartStopSystem::state machine::StartProcess->Operating;\n}",
    "package StartStopSystem {\n    part sys : StartStopController;\n\n    block StartStopController {\n        attribute brakePedalDepressed: Boolean;\n        attribute parkingBrakeApplied: Boolean;\n        signal vehicleStartSignal;\n        signal vehicleOnSignal;\n        signal shutdownSignal;\n        signal startControlSignal;\n\n        state machine Behavior {\n            initial -> Off;\n            state Off {\n                transition -> Starting on vehicleStartSignal\n            }\n            state Starting {\n                transition -> Started when (brakePedalDepressed and vehicleOnSignal) / {\n                    startControlSignal\n                }\n            }\n            state Started {\n                entry / {\n                    performSelfCheck();\n                    continuouslySupplyPower();\n                }\n                transition -> ShuttingDown on shutdownSignal\n            }\n            state ShuttingDown {\n                entry / {\n                    if not parkingBrakeApplied {\n                        applyParkingBrake()\n                    }\n                }\n                transition -> Off when (parkingBrakeApplied)\n            }\n        }\n\n        operation performSelfCheck();\n        operation continuouslySupplyPower();\n        operation applyParkingBrake();\n    }\n}",
    "package CruiseControlSystem {\n    event SetSpeedCommand {\n        desiredSpeed: Real;\n    }\n\n    event ActualSpeed {\n        currentSpeed: Real;\n    }\n\n    event FuelControlCommand {\n        fuelAmount: Real;\n    }\n\n    block Driver {\n        port {\n            out setSpeed: SetSpeedCommand;\n        }\n    }\n\n    block CruiseController {\n        port {\n            in setSpeed: SetSpeedCommand;\n            in actualSpeed: ActualSpeed;\n            out getSpeed: ;\n            out fuelControl: FuelControlCommand;\n        }\n    }\n\n    block Speedometer {\n        port {\n            in getSpeed: ;\n            out actualSpeed: ActualSpeed;\n        }\n    }\n\n    block Engine {\n        port {\n            in fuelControl: FuelControlCommand;\n        }\n    }\n\n    block Vehicle {\n        part {\n            controller: CruiseController;\n            speedSensor: Speedometer;\n            engine: Engine;\n        }\n        port {\n            in setSpeed: SetSpeedCommand;\n        }\n        connect {\n            setSpeed -> controller.setSpeed;\n            controller.getSpeed -> speedSensor.getSpeed;\n            speedSensor.actualSpeed -> controller.actualSpeed;\n            controller.fuelControl -> engine.fuelControl;\n        }\n    }\n\n    block CruiseControlSystem {\n        part {\n            driver: Driver;\n            vehicle: Vehicle;\n        }\n        connect {\n            driver.setSpeed -> vehicle.setSpeed;\n        }\n    }\n}",
    "package CruiseControlSystem {\n    requirement autoControl {\n        id = 'REQ1';\n        text = 'Automatically control vehicle speed to set speed.';\n    }\n    requirement improveComfort {\n        id = 'REQ2';\n        text = 'Improve driving comfort.';\n    }\n    requirement improveSafety {\n        id = 'REQ3';\n        text = 'Improve driving safety.';\n    }\n\n    interface SetSpeedIf {\n        operation setSpeed {\n            in speed: Real;\n        }\n    }\n\n    interface SpeedDataIf {\n        flow property currentSpeed: Real;\n    }\n\n    interface ThrottleControlIf {\n        flow property throttleCommand: Real;\n    }\n\n    part def Driver {\n        port setSpeedPort: out SetSpeedIf;\n    }\n\n    part def CruiseController {\n        port setSpeedPort: in SetSpeedIf;\n        port speedIn: in SpeedDataIf;\n        port throttleOut: out ThrottleControlIf;\n        attribute targetSpeed: Real;\n\n        operation setSpeed {\n            in speed: Real;\n        } {\n            targetSpeed = speed;\n        }\n\n        activity controlSpeed {\n            while true {\n                actualSpeed: Real = speedIn.currentSpeed;\n                error: Real = targetSpeed - actualSpeed;\n                throttle: Real = error * 0.5; // Proportional control\n                throttleOut.throttleCommand = throttle;\n            }\n        }\n    }\n\n    part def Speedometer {\n        port speedOut: out SpeedDataIf;\n        attribute measuredSpeed: Real;\n        binding speedOut.currentSpeed to measuredSpeed;\n    }\n\n    part def Engine {\n        port throttleIn: in ThrottleControlIf;\n        attribute throttleSetting: Real;\n        binding throttleIn.throttleCommand to throttleSetting;\n    }\n\n    part def VehicleSystem {\n        part driver: Driver;\n        part cruiseController: CruiseController;\n        part speedometer: Speedometer;\n        part engine: Engine;\n\n        connection setSpeedLink {\n            from driver.setSpeedPort;\n            to cruiseController.setSpeedPort;\n        }\n        connection speedDataLink {\n            from speedometer.speedOut;\n            to cruiseController.speedIn;\n        }\n        connection throttleLink {\n            from cruiseController.throttleOut;\n            to engine.throttleIn;\n        }\n    }\n\n    satisfy autoControlSat {\n        requirement = autoControl;\n        satisfiedBy = VehicleSystem.cruiseController.controlSpeed;\n    }\n    satisfy comfortSat {\n        requirement = improveComfort;\n        satisfiedBy = VehicleSystem;\n    }\n    satisfy safetySat {\n        requirement = improveSafety;\n        satisfiedBy = VehicleSystem;\n    }\n}",
    "package AutomotiveCruiseControl {\n    block Driver {\n        part vehicleInterface: VehicleControlInterface;\n    }\n\n    block VehicleControlInterface {\n        attribute setSpeedRequest: Real;\n    }\n\n    block CruiseController {\n        attribute targetSpeed: Real;\n        attribute currentSpeed: Real;\n        attribute throttleCommand: Real;\n        \n        part speedInput: SpeedSensor;\n        part engineOutput: Engine;\n    }\n\n    block SpeedSensor {\n        attribute measuredSpeed: Real;\n    }\n\n    block Engine {\n        attribute throttleSetting: Real;\n    }\n\n    interaction CruiseControlScenario {\n        lifeline driver: Driver;\n        lifeline controller: CruiseController;\n        lifeline speedometer: SpeedSensor;\n        lifeline engine: Engine;\n\n        occurrence setCommand = driver -> controller: setSpeed(target);\n        occurrence requestSpeed = controller -> speedometer: getCurrentSpeed();\n        occurrence reportSpeed = speedometer -> controller: currentSpeed(measured);\n        occurrence sendThrottle = controller -> engine: adjustThrottle(command);\n    }\n}",
    "package AutomotiveCruiseControl {\n    interface SpeedSetting {\n        in desiredSpeed: Real;\n    }\n\n    interface SpeedFeedback {\n        out currentSpeed: Real;\n    }\n\n    interface ThrottleControl {\n        out throttleCommand: Real;\n    }\n\n    requirement MaintainComfort {\n        id: 'R1';\n        text: \"Maintain set speed with accuracy and smoothness for driver comfort\";\n    }\n\n    block CruiseController {\n        port setSpeed: in SpeedSetting;\n        port speedInput: in SpeedFeedback;\n        port throttleOutput: out ThrottleControl;\n    }\n\n    block Speedometer {\n        port output: out SpeedFeedback;\n    }\n\n    block Engine {\n        port throttleInput: in ThrottleControl;\n    }\n\n    block AutomotiveCruiseControlSystem {\n        port driverCommand: in SpeedSetting;\n        part controller: CruiseController;\n        part speedSensor: Speedometer;\n        part engineControl: Engine;\n\n        driverCommand -> controller.setSpeed;\n        speedSensor.output -> controller.speedInput;\n        controller.throttleOutput -> engineControl.throttleInput;\n\n        satisfy 'SR1': MaintainComfort;\n    }\n}",
    "package CruiseControlSystem {\n    import SysML::blocks;\n    import SysML::ports;\n\n    actor Driver;\n\n    block CruiseControlInterface {\n        port driverInput: inout; // Bidirectional for driver interaction\n    }\n\n    block SpeedSensor {\n        port speedOutput: out Real; // Outputs detected speed\n    }\n\n    block CruiseController {\n        port setSpeedInput: in Real; // Receives target speed\n        port actualSpeedInput: in Real; // Receives current speed\n        port fuelCommand: out Real; // Outputs fuel adjustment command\n\n        activity ControlSpeed {\n            in setSpeed: Real; // Target speed parameter\n            in actualSpeed: Real; // Current speed parameter\n            out fuelAdjustment: Real; // Output command\n            \n            action CompareSpeeds {\n                in target: Real;\n                in current: Real;\n                out error: Real;\n            }\n            \n            action ComputeFuelCommand {\n                in error: Real;\n                out command: Real;\n            }\n            \n            edge setSpeed -> CompareSpeeds.target;\n            edge actualSpeed -> CompareSpeeds.current;\n            edge CompareSpeeds.error -> ComputeFuelCommand.error;\n            edge ComputeFuelCommand.command -> fuelAdjustment;\n        }\n    }\n\n    block Engine {\n        port fuelInput: in Real; // Receives fuel control commands\n    }\n\n    block Vehicle {\n        part interface: CruiseControlInterface;\n        part sensor: SpeedSensor;\n        part controller: CruiseController;\n        part engine: Engine;\n        \n        connector driverInterface: externalDriver -> interface.driverInput; // External driver interaction\n        connector setSpeedFlow: interface.driverInput -> controller.setSpeedInput; // Set speed data flow\n        connector speedFeedback: sensor.speedOutput -> controller.actualSpeedInput; // Speed feedback\n        connector fuelControl: controller.fuelCommand -> engine.fuelInput; // Fuel command flow\n    }\n}",
    "package CruiseControlSystem {\n    interface SetSpeedCommand {\n        attribute targetSpeed: Real;\n    }\n\n    interface SpeedData {\n        attribute currentSpeed: Real;\n    }\n\n    interface FuelControlCommand {\n        attribute adjustment: Real;\n    }\n\n    interface EngineCommand {\n        attribute fuelRate: Real;\n    }\n\n    requirement Reliability {\n        id: 'REQ-1'\n        text: 'Ensure reliable operation of cruise control functionality.'\n    }\n\n    requirement Efficiency {\n        id: 'REQ-2'\n        text: 'Maintain efficient message processing and fuel control.'\n    }\n\n    requirement Safety {\n        id: 'REQ-3'\n        text: 'Guarantee safe speed adjustment and system operation.'\n    }\n\n    block Driver {\n        port setSpeed: out SetSpeedCommand;\n    }\n\n    block CruiseController {\n        port commandIn: in SetSpeedCommand;\n        port speedIn: in SpeedData;\n        port fuelOut: out FuelControlCommand;\n        \n        action calculateAdjustment {\n            in targetSpeed: Real;\n            in currentSpeed: Real;\n            out adjustment: Real;\n        }\n        \n        satisfy :> Reliability, Efficiency, Safety;\n    }\n\n    block SpeedSensor {\n        port speedOut: out SpeedData;\n    }\n\n    block EngineController {\n        port fuelIn: in FuelControlCommand;\n        port engineOut: out EngineCommand;\n    }\n\n    block Engine {\n        port commandIn: in EngineCommand;\n    }\n\n    block VehicleSystem {\n        part driver: Driver;\n        part cruiseController: CruiseController;\n        part speedSensor: SpeedSensor;\n        part engineController: EngineController;\n        part engine: Engine;\n        \n        connector cmdLink: driver.setSpeed -> cruiseController.commandIn;\n        connector speedLink: speedSensor.speedOut -> cruiseController.speedIn;\n        connector fuelLink: cruiseController.fuelOut -> engineController.fuelIn;\n        connector engineLink: engineController.engineOut -> engine.commandIn;\n        \n        satisfy :> Reliability, Efficiency, Safety;\n    }\n}",
    "package VehicleLifecycle {\n    type Date: string;\n    type DateTime: string;\n\n    part Vehicle {\n        attribute vin: string;\n        reference delivery: Delivery[1];\n        reference ownerships: Ownership[*] ordered;\n        reference scrapping: Scrapping[0..1];\n    }\n\n    part Delivery {\n        attribute deliveryDate: Date;\n        reference vehicle: Vehicle[1];\n    }\n\n    part Ownership {\n        attribute ownerName: string;\n        attribute ownerAddress: string;\n        attribute startDate: Date;\n        attribute endDate: Date[0..1];\n        reference vehicle: Vehicle[1];\n        reference drivingOperations: DrivingOperation[*];\n    }\n\n    part DrivingOperation {\n        attribute operationTime: DateTime;\n        reference driver: Driver[1];\n        reference ownership: Ownership[1];\n    }\n\n    part Driver {\n        attribute name: string;\n    }\n\n    part Scrapping {\n        attribute deRegistrationDate: Date;\n        reference vehicle: Vehicle[1];\n    }\n}",
    "package VehicleSystem {\n    part def OperationalStatus {\n        attribute gear: String;\n        attribute accelerator: Real;\n    }\n\n    part def Wheel {\n        attribute rotationSpeed: Real;\n    }\n\n    part def Engine {\n        attribute powerOutput: Real;\n    }\n\n    reference def Driver {\n        attribute drivingLicense: String;\n    }\n\n    part def Vehicle {\n        attribute mass: Real;\n        part status: OperationalStatus[1];\n        part powertrain: Engine[1];\n        reference operator: Driver[1];\n        part leftFront: Wheel[1];\n        part rightFront: Wheel[1];\n    }\n\n    instance vehicle_1: Vehicle {\n        mass = 1500.0,\n        status = (gear = \"P\", accelerator = 0.0),\n        powertrain = (powerOutput = 0.0),\n        operator = (drivingLicense = \"DL12345\"),\n        leftFront = (rotationSpeed = 0.0),\n        rightFront = (rotationSpeed = 0.0)\n    }\n}",
    "package VehicleSystem {\n    part def VehicleSystem {\n        part vehicles: Vehicle[*];\n        part engines: Engine[*];\n        part drivers: Driver[*];\n    }\n\n    block Vehicle {\n        attribute mass: Real (unit: kilogram);\n        attribute state: VehicleState;\n    }\n\n    block VehicleState {\n        attribute gear: Integer;\n        attribute acceleratorPosition: Real;\n    }\n\n    block Engine { }\n\n    block Driver { }\n\n    instance vehicle1: Vehicle {\n        mass = 2000.0;\n        state = new VehicleState {\n            gear = 0;\n            acceleratorPosition = 0.0;\n        };\n    }\n\n    occurrence stateChange: Occurrence {\n        start = 0;\n        end = 1;\n        subject = vehicle1;\n        effect = [\n            vehicle1.mass = 1500.0,\n            vehicle1.state.gear = 2,\n            vehicle1.state.acceleratorPosition = 0.5\n        ];\n    }\n}",
    "block Engine;\nblock Driver;\nblock Vehicle {\n    attribute mass: Real;\n    attribute gearPosition: String;\n    attribute throttlePedalPosition: Real;\n    part engine: Engine;\n    reference driver: Driver;\n    \n    state group VehicleState;\n    \n    state InitialState for VehicleState {\n        mass = 2000;\n        gearPosition = \"neutral\";\n        throttlePedalPosition = 0.0;\n        driver = ^Alice;\n    }\n    \n    state SecondState for VehicleState {\n        mass = 1500;\n        gearPosition = \"second\";\n        throttlePedalPosition = 0.5;\n        driver = ^Bob;\n    }\n}\nAlice: Driver;\nBob: Driver;\nmyVehicle: Vehicle;\nsnapshot initial: myVehicle in Vehicle::InitialState;\nsnapshot second: myVehicle in Vehicle::SecondState;",
    "package VehicleMassModel {\n    type Mass is Real;\n\n    part def VehicleComponent {\n        attribute partNumber: String;\n        attribute ownMass: Mass;\n        derived attribute totalMass: Mass;\n        constraint {\n            totalMass = ownMass + subcomponent->collect(part | part.totalMass)->sum();\n        }\n        part subcomponent[*]: VehicleComponent;\n    }\n\n    part def Engine specializes VehicleComponent;\n    part def Transmission specializes VehicleComponent;\n    part def Wheel specializes VehicleComponent;\n\n    part def Vehicle specializes VehicleComponent {\n        part engine: Engine subsets subcomponent;\n        part transmission: Transmission subsets subcomponent;\n        part wheels: Wheel[4] subsets subcomponent;\n    }\n}",
    "abstract partdef Part {\n    attribute mass: Float;\n    operation totalMass(threshold: Float): Float;\n}\n\npartdef Vehicle specializes Part {\n    attribute vin: String;\n    attribute parts: Composition of Component[*];\n\n    operation totalMass(threshold: Float): Float {\n        expression: \"self.mass + self.parts->select(p | p.mass >= threshold)->collect(p | p.totalMass(threshold))->sum()\"\n    }\n}\n\npartdef Component specializes Part {\n    attribute serialNumber: String;\n    attribute parts: Composition of Component[*];\n\n    operation totalMass(threshold: Float): Float {\n        expression: \"self.mass + self.parts->select(p | p.mass >= threshold)->collect(p | p.totalMass(threshold))->sum()\"\n    }\n}\n\npartdef Engine specializes Component;\npartdef Transmission specializes Component;",
    "package MassAggregation {\n   abstract block Thing {\n      value simpleMass: Real;\n      derived value totalMass: Real;\n   }\n\n   block SimpleThing specializes Thing {\n      derived value totalMass: Real = simpleMass;\n   }\n\n   block CompositeThing specializes Thing {\n      part subcomponent[*]: Thing;\n      derived value totalMass: Real = simpleMass + subcomponent.totalMass->sum();\n   }\n}",
    "part def MassObject {\n    attribute basicMass: Real;\n    attribute subcomponents: composition MassObject[*];\n    derived attribute totalMass: Real = basicMass + (subcomponents.totalMass->sum());\n    operation totalMassWithThreshold(minThreshold: Real): Real {\n        = basicMass + (subcomponents->collect(subcomponent | \n            let subMass: Real = subcomponent.totalMassWithThreshold(minThreshold) in \n            if subMass >= minThreshold then subMass else 0\n        )->sum());\n    }\n}",
    "package VehicleDynamics {\n    part def g {\n        value: Real = 9.81;\n    }\n\n    constraint def DragForce {\n        subjectOf dragCoefficient: Real;\n        subjectOf initialSpeed: Real;\n        subjectOf dragForce: Real;\n        constraint {dragForce = dragCoefficient * initialSpeed^2;}\n    }\n\n    constraint def FrictionForce {\n        subjectOf frictionCoefficient: Real;\n        subjectOf vehicleMass: Real;\n        subjectOf g: Real;\n        subjectOf frictionForce: Real;\n        constraint {frictionForce = frictionCoefficient * vehicleMass * g;}\n    }\n\n    constraint def AvailablePower {\n        subjectOf wheelPower: Real;\n        subjectOf dragForce: Real;\n        subjectOf frictionForce: Real;\n        subjectOf initialSpeed: Real;\n        subjectOf availablePower: Real;\n        constraint {availablePower = wheelPower - (dragForce + frictionForce) * initialSpeed;}\n    }\n\n    constraint def Acceleration {\n        subjectOf availablePower: Real;\n        subjectOf initialSpeed: Real;\n        subjectOf vehicleMass: Real;\n        subjectOf acceleration: Real;\n        constraint {\n            if initialSpeed > 0 then\n                acceleration = (availablePower / initialSpeed) / vehicleMass\n            else\n                acceleration = 0\n        }\n    }\n\n    constraint def Speed {\n        subjectOf initialSpeed: Real;\n        subjectOf acceleration: Real;\n        subjectOf time: Real;\n        subjectOf currentSpeed: Real;\n        constraint {currentSpeed = initialSpeed + acceleration * time;}\n    }\n\n    constraint def Displacement {\n        subjectOf initialSpeed: Real;\n        subjectOf currentSpeed: Real;\n        subjectOf time: Real;\n        subjectOf displacement: Real;\n        constraint {displacement = (initialSpeed + currentSpeed) * time / 2;}\n    }\n\n    part VehicleDynamicsCalculator {\n        attribute wheelPower: Real;\n        attribute dragCoefficient: Real;\n        attribute frictionCoefficient: Real;\n        attribute vehicleMass: Real;\n        attribute initialSpeed: Real;\n        attribute time: Real;\n        attribute availablePower: Real;\n        attribute acceleration: Real;\n        attribute currentSpeed: Real;\n        attribute displacement: Real;\n\n        constraint dragForce: DragForce {\n            dragCoefficient :> this.dragCoefficient;\n            initialSpeed :> this.initialSpeed;\n            dragForce :> this.dragForce;\n        }\n\n        constraint frictionForce: FrictionForce {\n            frictionCoefficient :> this.frictionCoefficient;\n            vehicleMass :> this.vehicleMass;\n            g :> VehicleDynamics::g.value;\n            frictionForce :> this.frictionForce;\n        }\n\n        constraint availablePower: AvailablePower {\n            wheelPower :> this.wheelPower;\n            dragForce :> this.dragForce;\n            frictionForce :> this.frictionForce;\n            initialSpeed :> this.initialSpeed;\n            availablePower :> this.availablePower;\n        }\n\n        constraint acceleration: Acceleration {\n            availablePower :> this.availablePower;\n            initialSpeed :> this.initialSpeed;\n            vehicleMass :> this.vehicleMass;\n            acceleration :> this.acceleration;\n        }\n\n        constraint speed: Speed {\n            initialSpeed :> this.initialSpeed;\n            acceleration :> this.acceleration;\n            time :> this.time;\n            currentSpeed :> this.currentSpeed;\n        }\n\n        constraint displacement: Displacement {\n            initialSpeed :> this.initialSpeed;\n            currentSpeed :> this.currentSpeed;\n            time :> this.time;\n            displacement :> this.displacement;\n        }\n    }\n}",
    "package VehicleDynamics {\n  import ScalarValues::Scalars;\n  import BaseUnits::SIBaseUnits;\n  import DerivedUnits::SIDerivedUnits;\n\n  quantityKind Length;\n  quantityKind Time;\n  quantityKind Speed;\n  quantityKind Acceleration;\n  quantityKind Mass;\n  quantityKind Power;\n  quantityKind Force;\n\n  unit m (altLabel: \"meter\") for Length;\n  unit s (altLabel: \"second\") for Time;\n  unit m_per_s for Speed = m / s;\n  unit m_per_s2 for Acceleration = m_per_s / s;\n  unit kg for Mass;\n  unit W for Power = kg * m^2 / s^3;\n  unit N for Force = kg * m_per_s2;\n\n  part def VehicleState {\n    property speed: Speed [1];\n    property position: Length [1];\n  }\n\n  block VehicleDynamics {\n    property mass: Mass [1];\n    property dragCoefficient: Real [1];\n    property rollingResistanceCoefficient: Real [1];\n    property timeStep: Time [1];\n    property state: VehicleState [1];\n\n    const g: Acceleration = 9.81 m_per_s2;\n    const epsilon: Speed = 0.1 m_per_s;\n\n    operation step(in power: Power) {\n      out updatedState: VehicleState;\n    }\n\n    constraint DrivingForceEquation {\n      drivingForce = power / max(state.speed, epsilon);\n    }\n\n    constraint ResistanceForceEquation {\n      rollingResistance = rollingResistanceCoefficient * mass * g;\n      aerodynamicDrag = dragCoefficient * (state.speed)^2;\n      totalResistance = rollingResistance + aerodynamicDrag;\n    }\n\n    constraint AccelerationEquation {\n      netForce = drivingForce - totalResistance;\n      acceleration = netForce / mass;\n    }\n\n    constraint MotionUpdate {\n      newSpeed = state.speed + acceleration * timeStep;\n      averageSpeed = (state.speed + newSpeed) * 0.5;\n      newPosition = state.position + averageSpeed * timeStep;\n      updatedState = new VehicleState(speed = newSpeed, position = newPosition);\n    }\n  }\n}",
    "part def State {\n    value properties {\n        time: Real;\n        speed: Real;\n        position: Real;\n        acceleration: Real;\n    }\n}\n\nconstraint def DynamicsStep {\n    parameters {\n        prev: State;\n        next: State;\n        m: Real;\n        P: Real;\n        Cd: Real;\n        Cr: Real;\n        dt: Real;\n    }\n    constraints {\n        g: Real = 9.81;\n        F_drive: Real = if (prev.speed > 0.0) then (P / prev.speed) else 0.0;\n        F_air: Real = Cd * prev.speed * prev.speed;\n        F_roll: Real = Cr * m * g;\n        a_prev: Real = (F_drive - F_air - F_roll) / m;\n        next.time == prev.time + dt;\n        next.speed == prev.speed + a_prev * dt;\n        next.position == prev.position + prev.speed * dt;\n        next.acceleration == a_prev;\n    }\n}\n\npart def VehicleDynamicsSimulator {\n    value properties {\n        m: Real;\n        P: Real;\n        Cd: Real;\n        Cr: Real;\n        v0: Real;\n        s0: Real;\n        dt: Real;\n        totalTime: Real;\n        trajectory: State[*] { ordered, unique };\n    }\n    constraints {\n        trajectory[0].time == 0.0;\n        trajectory[0].speed == v0;\n        trajectory[0].position == s0;\n        trajectory[0].acceleration == \n            let g0: Real = 9.81,\n                F_drive0: Real = if (v0 > 0.0) then (P / v0) else 0.0,\n                F_air0: Real = Cd * v0 * v0,\n                F_roll0: Real = Cr * m * g0,\n                F_net0: Real = F_drive0 - F_air0 - F_roll0\n            in F_net0 / m;\n        for i in 0..(trajectory->size()-2) {\n            DynamicsStep(\n                prev: trajectory[i],\n                next: trajectory[i+1],\n                m: m,\n                P: P,\n                Cd: Cd,\n                Cr: Cr,\n                dt: dt\n            );\n        }\n        trajectory[trajectory->size()-1].time <= totalTime;\n        trajectory[trajectory->size()-1].time + dt > totalTime;\n    }\n}",
    "package VehicleDynamics {\n    block VehicleLongitudinalDynamics {\n        initialPosition: Real;\n        initialVelocity: Real;\n        mass: Real;\n        power: Real;\n        timeInterval: Real;\n        dragCoefficient: Real;\n        frictionCoefficient: Real;\n        gravity: Real = 9.81;\n\n        derived acceleration: Real = \n            let effectiveInitialVelocity: Real = if initialVelocity == 0.0 then 0.001 else initialVelocity;\n            let drivingForce: Real = power / effectiveInitialVelocity;\n            let airResistanceForce: Real = dragCoefficient * initialVelocity * initialVelocity;\n            let rollingResistanceForce: Real = frictionCoefficient * mass * gravity;\n            in (drivingForce - airResistanceForce - rollingResistanceForce) / mass;\n\n        derived finalVelocity: Real = initialVelocity + acceleration * timeInterval;\n        derived finalPosition: Real = initialPosition + initialVelocity * timeInterval + 0.5 * acceleration * timeInterval * timeInterval;\n    }\n}",
    "package VehicleSystem {\n    part def Chassis {\n        value mass: Real;\n    }\n\n    part def Engine {\n        value mass: Real;\n    }\n\n    part def Gearbox {\n        value mass: Real;\n    }\n\n    part def Vehicle {\n        part chassis: Chassis;\n        part engine: Engine;\n        part gearbox: Gearbox;\n        \n        value totalMass: Real;\n        value overweightWarning: Boolean;\n        \n        constraint {\n            totalMass = chassis.mass + engine.mass + gearbox.mass;\n            overweightWarning = totalMass > 2500.0;\n        }\n    }\n\n    requirement def MassRequirement {\n        reqId: \"REQ1\";\n        text: \"The total mass of the vehicle must not exceed 2500 kg.\";\n    }\n\n    satisfy VehicleSatisfaction {\n        source: Vehicle;\n        target: MassRequirement;\n    }\n}",
    "package VehicleMassBudgeting {\n    value type Mass: Real\n        unit kg;\n\n    requirement MassLimitRequirement {\n        id: 'REQ1';\n        text: \"Total vehicle mass including chassis, engine, and transmission must not exceed 2500 kg.\";\n    }\n\n    block Chassis {\n        attribute mass: Mass;\n    }\n\n    block Engine {\n        attribute mass: Mass;\n    }\n\n    block Transmission {\n        attribute mass: Mass;\n    }\n\n    constraintblock TotalMassConstraint {\n        massLimit: Mass;\n        chassisMass: Mass;\n        engineMass: Mass;\n        transmissionMass: Mass;\n        total: Mass;\n\n        constraints {\n            total == chassisMass + engineMass + transmissionMass;\n            total <= massLimit;\n        }\n    }\n\n    block Vehicle satisfies MassLimitRequirement {\n        part chassis: Chassis;\n        part engine: Engine;\n        part transmission: Transmission;\n\n        constraint totalMass: TotalMassConstraint {\n            massLimit = 2500;\n            chassisMass = chassis.mass;\n            engineMass = engine.mass;\n            transmissionMass = transmission.mass;\n        }\n    }\n}",
    "package VehicleMassManagement {\n    part def Chassis {\n        attribute mass: Real {\n            unit: 'kg';\n        }\n    }\n\n    part def Engine {\n        attribute mass: Real {\n            unit: 'kg';\n        }\n    }\n\n    part def Transmission {\n        attribute mass: Real {\n            unit: 'kg';\n        }\n    }\n\n    constraint def TotalMassLimit {\n        parameter total: Real;\n        parameter limit: Real;\n        constraint total <= limit;\n    }\n\n    requirement def MassComplianceReq {\n        id: 'REQ1';\n        text: \"Total vehicle mass must not exceed 2500 kg\";\n    }\n\n    part def Vehicle {\n        part chassis: Chassis;\n        part engine: Engine;\n        part transmission: Transmission;\n\n        attribute totalMass: Real {\n            unit: 'kg';\n            = chassis.mass + engine.mass + transmission.mass;\n        }\n\n        constraint massConstraint: TotalMassLimit {\n            bind total: totalMass;\n            bind limit: 2500;\n        }\n\n        satisfy MassComplianceReq;\n    }\n}",
    "package VehicleWeightManagement {\n  requirement WeightRequirement {\n    text: \"The combined weight of the main vehicle components (chassis, engine, transmission) must not exceed 2500 kg.\"\n  }\n\n  constraint block WeightLimitConstraint {\n    parameters: totalWeight: Real\n    constraint: totalWeight <= 2500.0\n  }\n\n  part def Chassis {\n    attributes: weight: Real\n  }\n\n  part def Engine {\n    attributes: weight: Real\n  }\n\n  part def Transmission {\n    attributes: weight: Real\n  }\n\n  part def WeightMonitorSystem {\n    references:\n      chassisRef: Chassis,\n      engineRef: Engine,\n      transRef: Transmission\n\n    attributes:\n      totalWeight: Real {\n        = chassisRef.weight + engineRef.weight + transRef.weight\n      }\n\n    constraint weightCheck: WeightLimitConstraint {\n      totalWeight => totalWeight\n    }\n\n    ports:\n      out warning: OutPort<Boolean>\n\n    actions:\n      validateWeight: {\n        if totalWeight > 2500.0 then\n          warning.write(true)\n        else\n          warning.write(false)\n      }\n  }\n\n  part def Vehicle {\n    parts:\n      chassis: Chassis,\n      engine: Engine,\n      transmission: Transmission,\n      weightMonitor: WeightMonitorSystem\n\n    bindings:\n      weightMonitor.chassisRef = chassis,\n      weightMonitor.engineRef = engine,\n      weightMonitor.transRef = transmission\n  }\n\n  verification CheckWeightLimit: Verify {\n    requirement = WeightRequirement\n    constrainedBy = :>WeightMonitorSystem::weightCheck\n  }\n}",
    "package VehicleSystem {\n    block Chassis {\n        attribute mass: Real;\n    }\n\n    block Engine {\n        attribute mass: Real;\n    }\n\n    block Transmission {\n        attribute mass: Real;\n    }\n\n    constraint block TotalMassConstraint {\n        parameters:\n            totalMass: Real;\n        constraints:\n            maxMass: totalMass <= 2500.0;\n    }\n\n    constraint block DynamicsConstraint {\n        parameters:\n            initialVelocity: Real;\n            finalVelocity: Real;\n            mass: Real;\n            force: Real;\n            time: Real;\n        constraints:\n            positiveMass: mass > 0.0;\n            newtonLaw: force = mass * (finalVelocity - initialVelocity) / time;\n    }\n\n    block Vehicle {\n        parts:\n            chassis: Chassis;\n            engine: Engine;\n            transmission: Transmission;\n        attributes:\n            totalMass: Real = chassis.mass + engine.mass + transmission.mass;\n        constraints:\n            massRequirement: TotalMassConstraint {\n                totalMass = ^totalMass;\n            };\n    }\n}",
    "package MaintenanceManagementSystem {\n    value type Time: Real;\n    value type Duration: Real;\n\n    enum VehicleStatus {\n        healthy,\n        under_maintenance\n    }\n\n    block Vehicle {\n        attribute nextMaintenanceTime: Time;\n        attribute maintenanceInterval: Duration;\n        attribute maxAllowedTemperature: Real;\n        attribute status: VehicleStatus = VehicleStatus::healthy;\n        attribute maintenanceStartTime: Time[0..1];\n        attribute maintenanceEndTime: Time[0..1];\n\n        constraint MaintenanceTriggerTiming {\n            if currentTime >= nextMaintenanceTime then\n                status = VehicleStatus::under_maintenance\n                and maintenanceStartTime > nextMaintenanceTime\n                and maintenanceStartTime <= nextMaintenanceTime + 2.0\n        }\n\n        constraint MaintenanceDurationLimit {\n            if status = VehicleStatus::under_maintenance then\n                maintenanceEndTime > maintenanceStartTime\n                and maintenanceEndTime <= maintenanceStartTime + 172800.0\n        }\n\n        operation completeMaintenance() {\n            precondition: status = VehicleStatus::under_maintenance;\n            effect: \n                nextMaintenanceTime = maintenanceStartTime + maintenanceInterval,\n                status = VehicleStatus::healthy,\n                maintenanceStartTime = null,\n                maintenanceEndTime = null\n        }\n    }\n}",
    "package VehicleSystem {\n   unit kg;\n   unit Nm;\n\n   value type Mass {\n      unit: kg;\n   }\n\n   value type Torque {\n      unit: Nm;\n   }\n\n   interface block ClutchInterface {\n      flow torque: Torque;\n   }\n\n   part def Engine {\n      port clutchOutput: ClutchInterface {\n         direction: out;\n      }\n   }\n\n   part def Transmission {\n      port clutchInput: ClutchInterface {\n         direction: in;\n      }\n   }\n\n   part def Vehicle {\n      property curbWeight: Mass;\n      property fuelMass: Mass;\n      property maxMassLimit: Mass;\n\n      part engine: Engine;\n      part transmission: Transmission;\n\n      connector powertrain: engine.clutchOutput -> transmission.clutchInput;\n\n      constraint totalMassConstraint {\n         constraint: curbWeight + fuelMass <= maxMassLimit;\n      }\n\n      constraint fuelPositive {\n         constraint: fuelMass > 0;\n      }\n   }\n\n   requirement req1 {\n      id: \"REQ-1\";\n      text: \"Total vehicle mass (curb weight + fuel) must not exceed max mass limit\";\n   }\n\n   requirement req2 {\n      id: \"REQ-2\";\n      text: \"Fuel mass must be positive\";\n   }\n\n   requirement req3 {\n      id: \"REQ-3\";\n      text: \"Engine must generate torque according to speed curve\";\n   }\n\n   requirement req4 {\n      id: \"REQ-4\";\n      text: \"Engine torque must transmit to transmission via clutch interface\";\n   }\n\n   requirement req5 {\n      id: \"REQ-5\";\n      text: \"Power must be smoothly delivered to drive system\";\n   }\n\n   satisfy massLimitSatisfaction: req1 <- Vehicle::totalMassConstraint;\n   satisfy fuelPositiveSatisfaction: req2 <- Vehicle::fuelPositive;\n   satisfy torqueTransmissionSatisfaction: req4 <- Vehicle::powertrain;\n}",
    "package VehicleSystem {\n   unit kg;\n\n   value type Mass {\n      unit kg;\n   }\n\n   interface block ClutchInterface;\n\n   block FuelTank {\n      property maxCapacity: Mass;\n   }\n\n   block Engine {\n      port clutchPort: ClutchInterface;\n   }\n\n   block Transmission {\n      port clutchPort: ClutchInterface;\n   }\n\n   block Vehicle {\n      part engine: Engine;\n      part transmission: Transmission;\n      part fuelTank: FuelTank;\n\n      property dryMass: Mass;\n      property fuelMass: Mass;\n      property totalMass: Mass = dryMass + fuelMass;\n\n      connection clutchConnection between engine.clutchPort, transmission.clutchPort;\n\n      constraint FullTankMass {\n         (dryMass + fuelTank.maxCapacity) <= 2000kg\n      }\n\n      constraint EmptyTankMass {\n         dryMass <= 1500kg\n      }\n   }\n\n   requirement R1 {\n      id = 'R1'\n      text = 'With a full fuel tank, the vehicle’s total mass must not exceed 2000 kg.'\n   }\n\n   requirement R2 {\n      id = 'R2'\n      text = 'With an empty fuel tank, the vehicle’s total mass must not exceed 1500 kg.'\n   }\n\n   requirement R3 {\n      id = 'R3'\n      text = 'The engine must transmit generated torque to the transmission via the clutch interface.'\n   }\n\n   requirement R4 {\n      id = 'R4'\n      text = 'The engine must deliver torque according to the speed-torque curve (Table 1).'\n   }\n}",
    "package VehicleProject {\n    unit kg;\n    unit Nm;\n    unit rpm;\n\n    requirement VehicleMassReq {\n        id = \"R1\";\n        text = \"Vehicle total mass must not exceed 2000 kg when fully fueled and 1500 kg when empty.\";\n    }\n\n    requirement EngineTorqueReq {\n        id = \"R2\";\n        text = \"Engine must transmit generated torque to transmission through clutch interface.\";\n    }\n\n    requirement TorqueSpeedReq {\n        id = \"R3\";\n        text = \"Engine torque must vary with speed per performance table specifications.\";\n    }\n\n    constraint MassConstraint {\n        param fueledMass: Real[kg];\n        param emptyMass: Real[kg];\n        expression: fueledMass <= 2000 and emptyMass <= 1500;\n    }\n\n    constraint TorqueSpeedConstraint {\n        param torque: Real[Nm];\n        param speed: Real[rpm];\n        expression: /* Lookup from performance table */;\n    }\n\n    interface block Clutch {\n        flow torque: Real[Nm];\n    }\n\n    block Engine {\n        port clutch: Clutch;\n        attribute speed: Real[rpm];\n        attribute generatedTorque: Real[Nm];\n        \n        constraint torqueBehavior: TorqueSpeedConstraint {\n            torque => this::generatedTorque;\n            speed => this::speed;\n        }\n        \n        flow torqueOut: Real[Nm] -> clutch::torque;\n    }\n\n    block Vehicle {\n        part engine: Engine;\n        attribute emptyMass: Real[kg];\n        attribute fueledMass: Real[kg];\n        \n        constraint massReq: MassConstraint {\n            fueledMass => this::fueledMass;\n            emptyMass => this::emptyMass;\n        }\n    }\n\n    satisfy MassSatisfaction {\n        requirement = VehicleMassReq;\n        design = Vehicle::massReq;\n    }\n\n    satisfy TorqueTransmissionSatisfaction {\n        requirement = EngineTorqueReq;\n        design = Engine::clutch;\n    }\n\n    satisfy TorqueSpeedSatisfaction {\n        requirement = TorqueSpeedReq;\n        design = Engine::torqueBehavior;\n    }\n}",
    "package VehicleSystem {\n    requirement MassFull {\n        id: 'req1'\n        text: \"When the fuel tank is full, the total vehicle mass must not exceed 2000 kg.\"\n    }\n    requirement MassEmpty {\n        id: 'req2'\n        text: \"When the fuel tank is empty, the total vehicle mass must not exceed 1500 kg.\"\n    }\n    requirement TorqueGeneration {\n        id: 'req3'\n        text: \"The engine must be capable of generating the specified torque characteristics at various speeds.\"\n    }\n    requirement TorqueTransmission {\n        id: 'req4'\n        text: \"The generated torque must be effectively transmitted to the gearbox through the clutch interface to ensure smooth power delivery.\"\n    }\n    interface Torque;\n    part def Engine {\n        port output: Torque\n    }\n    part def Clutch {\n        port input: Torque;\n        port output: Torque\n    }\n    part def Gearbox {\n        port input: Torque\n    }\n    part def Vehicle {\n        value curbMass: Real;\n        value fuelMass: Real;\n        constraint totalMass: curbMass + fuelMass;\n        constraint fullTank: totalMass <= 2000;\n        constraint emptyTank: totalMass <= 1500;\n        part engine: Engine;\n        part clutch: Clutch;\n        part gearbox: Gearbox;\n        connection torquePath1: engine.output -> clutch.input;\n        connection torquePath2: clutch.output -> gearbox.input;\n        satisfy massFullReq: MassFull;\n        satisfy massEmptyReq: MassEmpty;\n        satisfy torqueGenReq: TorqueGeneration = engine;\n        satisfy torqueTransReq: TorqueTransmission = clutch\n    }\n}",
    "package VehiclePerformanceAnalysis {\n    import ScalarValues::Scalars;\n    import SIUnits::SI;\n\n    block Vehicle {\n        part curbWeight: Real; // kg\n        part payload: Real; // kg\n        part wheelDiameter: Real; // m\n        part transmissionEfficiency: Real; // dimensionless (0-1)\n        part fuelEconomyUrban: Real; // km/L\n        part fuelEconomyHighway: Real; // km/L\n        part rollingResistanceCoefficient: Real; // dimensionless\n        part dragCoefficient: Real; // dimensionless\n        part frontalArea: Real; // m²\n    }\n\n    block DrivingPoint {\n        part time: Real; // s\n        part position: Real; // m\n        part speed: Real; // m/s\n    }\n\n    block DrivingCycle {\n        part points: DrivingPoint[*];\n    }\n\n    constraint block DynamicEquations {\n        part vehicle: Vehicle;\n        part drivingCycle: DrivingCycle;\n        attribute totalMass: Real; // kg\n        attribute accelerations: Real[*]; // m/s²\n        attribute powerDemands: Real[*]; // W\n        attribute totalFuelConsumed: Real; // L\n        attribute overallFuelEconomy: Real; // km/L\n\n        constraint {\n            totalMass = vehicle.curbWeight + vehicle.payload;\n            accelerations = new Real[drivingCycle.points->size()-1];\n            powerDemands = new Real[drivingCycle.points->size()-1];\n            totalFuelConsumed = 0;\n            overallFuelEconomy = 0;\n\n            for (i in 1..drivingCycle.points->size()-1) {\n                dt = drivingCycle.points[i].time - drivingCycle.points[i-1].time;\n                dv = drivingCycle.points[i].speed - drivingCycle.points[i-1].speed;\n                acceleration = dv / dt;\n                accelerations[i-1] = acceleration;\n\n                F_roll = totalMass * 9.81 * vehicle.rollingResistanceCoefficient;\n                F_drag = 0.5 * 1.225 * vehicle.dragCoefficient * vehicle.frontalArea * drivingCycle.points[i].speed^2;\n                F_acc = totalMass * acceleration;\n                F_total = F_roll + F_drag + F_acc;\n                power = F_total * drivingCycle.points[i].speed / vehicle.transmissionEfficiency;\n                powerDemands[i-1] = power;\n            }\n\n            totalDistance = drivingCycle.points[drivingCycle.points->size()-1].position - drivingCycle.points[0].position;\n            urbanThreshold = 13.89; // 50 km/h in m/s\n            urbanDistance = 0;\n            highwayDistance = 0;\n\n            for (i in 1..drivingCycle.points->size()-1) {\n                segmentDistance = drivingCycle.points[i].position - drivingCycle.points[i-1].position;\n                avgSpeed = (drivingCycle.points[i].speed + drivingCycle.points[i-1].speed) / 2;\n                if (avgSpeed < urbanThreshold) {\n                    urbanDistance += segmentDistance;\n                } else {\n                    highwayDistance += segmentDistance;\n                }\n            }\n\n            totalFuelConsumed = (urbanDistance / 1000) / vehicle.fuelEconomyUrban + (highwayDistance / 1000) / vehicle.fuelEconomyHighway;\n            overallFuelEconomy = totalDistance / 1000 / totalFuelConsumed;\n        }\n    }\n\n    requirement EnergyConsumptionTarget {\n        requirement id: \"REQ_ENERGY\";\n        requirement text: \"Fuel economy must meet specified target\";\n        constraint: constraint FuelEconomyConstraint;\n    }\n\n    constraint block FuelEconomyConstraint {\n        parameter target: Real; // km/L\n        parameter actual: Real; // km/L\n        constraint: actual >= target;\n    }\n\n    block PerformanceAnalysis {\n        part vehicle: Vehicle;\n        part drivingCycle: DrivingCycle;\n        part targetFuelEconomy: Real; // km/L\n        attribute overallFuelEconomy: Real; // km/L\n        constraint dynamics: DynamicEquations;\n        bind dynamics.vehicle = vehicle;\n        bind dynamics.drivingCycle = drivingCycle;\n        bind overallFuelEconomy = dynamics.overallFuelEconomy;\n    }\n\n    verify EnergyConsumptionVerification {\n        requirement = EnergyConsumptionTarget;\n        bind EnergyConsumptionTarget.FuelEconomyConstraint.target = targetFuelEconomy;\n        bind EnergyConsumptionTarget.FuelEconomyConstraint.actual = overallFuelEconomy;\n    }\n\n    block VehiclePerformanceAnalysisSystem {\n        part config: PerformanceAnalysis;\n        verify verification: EnergyConsumptionVerification {\n            bind targetFuelEconomy = config.targetFuelEconomy;\n            bind overallFuelEconomy = config.overallFuelEconomy;\n        }\n    }\n}",
    "package VehicleFuelEconomyModel {\n   requirement FuelEconomyRequirement {\n      id: 'REQ1';\n      text: 'Vehicle must exceed 30 miles per gallon under specified driving scenarios';\n   }\n\n   part def Vehicle {\n      attribute curbWeight: Real;\n      attribute load: Real;\n      attribute wheelDiameter: Real;\n      attribute transmissionEfficiency: Real;\n   }\n\n   scenario def DrivingScenario {\n      attribute speedProfile: Real[*];\n      attribute drivingTrajectory: Real[*];\n   }\n\n   scenario def UrbanDrivingScenario :> DrivingScenario;\n   scenario def HighwayDrivingScenario :> DrivingScenario;\n\n   action def CalculateWheelPower {\n      in vehicle: Vehicle[1];\n      in scenario: DrivingScenario[1];\n      out wheelPower: Real[1];\n   }\n\n   action def ComputeEnergyConsumption {\n      in wheelPower: Real[1];\n      in vehicle: Vehicle[1];\n      out energyUsed: Real[1];\n   }\n\n   action def EstimateEnginePower {\n      in wheelPower: Real[1];\n      in transmissionEfficiency: Real[1];\n      out enginePower: Real[1];\n   }\n\n   action def DetermineFuelEconomy {\n      in energyUsed: Real[1];\n      out fuelEconomyMPG: Real[1];\n      out fuelConsumptionLPer100km: Real[1];\n   }\n\n   action def FuelEconomySimulation {\n      part vehicle: Vehicle[1];\n      part scenario: DrivingScenario[1];\n      action wheelPowerCalc: CalculateWheelPower {\n         in vehicle: vehicle;\n         in scenario: scenario;\n      }\n      action energyCalc: ComputeEnergyConsumption {\n         in wheelPower: wheelPowerCalc.wheelPower;\n         in vehicle: vehicle;\n      }\n      action enginePowerCalc: EstimateEnginePower {\n         in wheelPower: wheelPowerCalc.wheelPower;\n         in transmissionEfficiency: vehicle.transmissionEfficiency;\n      }\n      action fuelEconCalc: DetermineFuelEconomy {\n         in energyUsed: energyCalc.energyUsed;\n      }\n      out fuelEconomyMPG: fuelEconCalc.fuelEconomyMPG;\n      out fuelConsumptionLPer100km: fuelEconCalc.fuelConsumptionLPer100km;\n   }\n\n   case def VerifyFuelEconomy {\n      ref requirement: FuelEconomyRequirement[1];\n      part testVehicle: Vehicle[1];\n      part urbanTest: UrbanDrivingScenario[1];\n      part highwayTest: HighwayDrivingScenario[1];\n      action urbanSim: FuelEconomySimulation {\n         part vehicle: testVehicle;\n         part scenario: urbanTest;\n      }\n      action highwaySim: FuelEconomySimulation {\n         part vehicle: testVehicle;\n         part scenario: highwayTest;\n      }\n      check urbanPass: urbanSim.fuelEconomyMPG > 30;\n      check highwayPass: highwaySim.fuelEconomyMPG > 30;\n      satisfy requirement with (urbanPass and highwayPass);\n   }\n}",
    "package EngineSelectionModel {\n    unit kW;\n    unit kg;\n    unit USD;\n    unit Percent;\n\n    value type Power: Real {\n        unit = kW;\n    }\n    value type Mass: Real {\n        unit = kg;\n    }\n    value type Efficiency: Real {\n        unit = Percent;\n    }\n    value type Cost: Real {\n        unit = USD;\n    }\n\n    block Engine {\n        cylinderType: String; \n        power: Power; \n        mass: Mass; \n        efficiency: Efficiency; \n        cost: Cost;\n    }\n\n    block EngineEvaluationSystem {\n        part candidate: Engine[*];\n        attribute powerWeight: Real = 0.3;\n        attribute efficiencyWeight: Real = 0.3;\n        attribute costWeight: Real = 0.2;\n        attribute massWeight: Real = 0.2;\n\n        operation evaluateEngine(e: Engine): Real {\n            return e.power * .powerWeight + \n                   e.efficiency * .efficiencyWeight - \n                   e.cost * .costWeight - \n                   e.mass * .massWeight;\n        }\n\n        operation selectOptimalEngine(): Engine {\n            return candidate->maxBy(e | evaluateEngine(e));\n        }\n    }\n}",
    "package VehicleQualityCheck {\n    part VehicleQualityCheckSystem {\n        behavior: VehicleWeightCheckActivity;\n    }\n\n    activity VehicleWeightCheckActivity {\n        action collectWeightData {\n            output collectedData: Real;\n        }\n\n        action processWeightData {\n            input collectedData: Real;\n            output processedData: Real;\n        }\n\n        action evaluateWeight {\n            input processedData: Real;\n            output evaluationResult: EvaluationResult;\n            constraint: {\n                evaluationResult = \n                    if processedData <= 2500.0 \n                    then EvaluationResult::qualified \n                    else EvaluationResult::unqualified;\n            }\n        }\n\n        edge collectWeightData.collectedData -> processWeightData.collectedData;\n        edge processWeightData.processedData -> evaluateWeight.processedData;\n    }\n\n    enum EvaluationResult {\n        qualified,\n        unqualified\n    }\n\n    requirement CurbWeightRequirement {\n        id = \"REQ1\";\n        text = \"Curb weight must be ≤ 2500 kg\";\n    }\n\n    requirement ProcessRequirement {\n        id = \"REQ2\";\n        text = \"Process must include data collection, processing, and evaluation steps\";\n    }\n\n    VehicleWeightCheckActivity satisfies ProcessRequirement;\n    verify VehicleWeightVerification {\n        verifiedRequirement = CurbWeightRequirement;\n        verifyingCase: VehicleWeightCheckActivity;\n    }\n}",
    "package MassVerificationSystem {\n    requirement MassLimit {\n        id: 'REQ1';\n        text: \"Vehicle mass shall not exceed 2500 kg\";\n    }\n\n    quantitykind Mass;\n    unit kg in Mass;\n\n    enum QualificationStatus {\n        qualified,\n        unqualified\n    }\n\n    part def Vehicle {\n        attribute mass: Mass;\n    }\n\n    part def WeighingEquipment {\n        operation measure(in vehicle: Vehicle): Mass;\n    }\n\n    part def MassVerificationUnit {\n        operation evaluate(in mass: Mass): QualificationStatus {\n            constraint {\n                if mass <= 2500 then\n                    result = QualificationStatus::qualified\n                else\n                    result = QualificationStatus::unqualified\n            }\n        }\n    }\n\n    part def MassVerificationSystem {\n        part scale: WeighingEquipment[1];\n        part verifier: MassVerificationUnit[1];\n        \n        satisfy massLimit: MassLimit;\n        \n        operation verify(in vehicle: Vehicle): QualificationStatus;\n    }\n\n    activity MassVerificationActivity (in vehicle: Vehicle, out status: QualificationStatus) {\n        action measure: {\n            call operation: WeighingEquipment::measure on self.scale;\n            argument vehicle: vehicle;\n            result massValue: Mass;\n        }\n        \n        action evaluate: {\n            call operation: MassVerificationUnit::evaluate on self.verifier;\n            argument mass: massValue;\n            result status: QualificationStatus;\n        }\n        \n        control flow: measure -> evaluate;\n        edge evaluate.status -> status;\n    }\n    \n    MassVerificationSystem::verify = MassVerificationActivity;\n}",
    "package TransportationSystem {\n    block Vehicle {\n        part driver: Driver[1];\n        part passengers: Passenger[0..4];\n        reference environment: Environment[1];\n        reference infrastructure: Infrastructure[*];\n        \n        action boarding: Boarding;\n        action alighting: Alighting;\n        action transport: Transport;\n    }\n\n    block User {\n        attribute name: String;\n    }\n\n    block Driver specializes User {}\n    block Passenger specializes User {}\n\n    block Environment {\n        attribute weatherConditions: String;\n        attribute trafficDensity: Integer;\n    }\n\n    block Infrastructure {\n        attribute location: String;\n    }\n\n    block GasStation specializes Infrastructure {\n        attribute fuelType: String;\n    }\n\n    activity Boarding {\n        in user: User;\n        in vehicle: Vehicle;\n    }\n\n    activity Alighting {\n        in user: User;\n        in vehicle: Vehicle;\n    }\n\n    activity Transport {\n        in start: String;\n        in destination: String;\n        out duration: Float;\n    }\n\n    requirement Safety {\n        id: 'REQ-1';\n        text: \"Ensure safe travel for all occupants\";\n    }\n\n    requirement Comfort {\n        id: 'REQ-2';\n        text: \"Provide comfortable ride experience\";\n    }\n\n    requirement Convenience {\n        id: 'REQ-3';\n        text: \"Enable simple and smooth boarding/alighting\";\n    }\n\n    requirement Sustainability {\n        id: 'REQ-4';\n        text: \"Maintain environmental sustainability\";\n    }\n\n    requirement Compatibility {\n        id: 'REQ-5';\n        text: \"Ensure compatibility with infrastructure\";\n    }\n\n    Vehicle.satisfiedRequirement = {\n        Safety,\n        Comfort,\n        Convenience,\n        Sustainability,\n        Compatibility\n    }\n}",
    "package TransportationSystem {\n    actor Driver;\n    actor Passenger[0..4];\n    actor Environment;\n    actor GasStation;\n\n    part Vehicle {\n        attribute fuelLevel: Real;\n    }\n\n    case Transport {\n        subject: v: Vehicle;\n        actor: d: Driver;\n        actor: p: Passenger;\n        actor: e: Environment;\n        actor: g: GasStation;\n\n        scenario main {\n            action EnterVehicle {\n                description: \"Driver and passengers enter the vehicle\";\n            }\n            action OperateVehicle {\n                description: \"Driver operates vehicle under environmental conditions\";\n            }\n            action Refuel {\n                description: \"Refuel at gas station if needed\";\n                constraint: \"fuelLevel < threshold\" then perform;\n            }\n            action ArriveAtDestination {\n                description: \"Vehicle reaches destination\";\n            }\n            action ExitVehicle {\n                description: \"Driver and passengers exit safely\";\n            }\n\n            sequence {\n                EnterVehicle;\n                OperateVehicle {\n                    during: {\n                        if Refuel then continue OperateVehicle;\n                    }\n                };\n                ArriveAtDestination;\n                ExitVehicle;\n            }\n        }\n    }\n\n    requirement Safety {\n        id = \"REQ-SAFETY\";\n        text = \"Ensure safe transportation and exit of all occupants\";\n    }\n\n    requirement Usability {\n        id = \"REQ-USABILITY\";\n        text = \"Provide simple and convenient interactions\";\n    }\n\n    satisfy {\n        Transport satisfies Safety;\n        Transport satisfies Usability;\n    }\n}",
    "package VehicleProductLine {\n  enum DiameterOption {\n    small,\n    large\n  }\n\n  abstract part def Engine {\n    cylinderDiameter: DiameterOption;\n  }\n\n  part def FourCylinderEngine: Engine {\n    cylinderCount: 4;\n  }\n\n  part def SixCylinderEngine: Engine {\n    cylinderCount: 6;\n  }\n\n  abstract part def Transmission;\n\n  part def ManualTransmission: Transmission;\n\n  part def AutomaticTransmission: Transmission;\n\n  part def Vehicle {\n    parts: \n      engine: Engine[1];\n      transmission: Transmission[1];\n\n    constraint ManualWithFourCylinder {\n      specification: \n        transmission.oclIsKindOf(ManualTransmission) implies engine.oclIsKindOf(FourCylinderEngine);\n    }\n\n    constraint SixCylinderWithAutomatic {\n      specification: \n        engine.oclIsKindOf(SixCylinderEngine) implies transmission.oclIsKindOf(AutomaticTransmission);\n    }\n  }\n}",
    "package EngineSystem {\n    value type Diameter: Real;\n    unit mm;\n\n    part def Cylinder {\n        attribute diameter: Diameter;\n    }\n\n    abstract part def Engine {\n        attribute cylinderDiameter: Diameter;\n        constraint validDiameter {\n            cylinderDiameter == 70 mm or cylinderDiameter == 100 mm;\n        }\n    }\n\n    part def FourCylinderEngine:> Engine {\n        part cylinders: Cylinder[4] {\n            :> diameter = cylinderDiameter;\n        }\n    }\n\n    part def SixCylinderEngine:> Engine {\n        part cylinders: Cylinder[6] {\n            :> diameter = cylinderDiameter;\n        }\n    }\n}",
    "package AutomotiveConfiguration {\n   import Systems;\n\n   unit mm: Unit;\n\n   value type DiameterValue: Real (unit mm);\n\n   value Diameter70: DiameterValue = 70 mm;\n   value Diameter100: DiameterValue = 100 mm;\n\n   abstract block Transmission;\n\n   block ManualTransmission: Transmission;\n   block AutomaticTransmission: Transmission;\n\n   abstract block Engine {\n      value cylinderDiameter: DiameterValue;\n      value numberOfCylinders: Integer;\n   }\n\n   constraint DiameterChoice on Engine {\n      cylinderDiameter == Diameter70 or cylinderDiameter == Diameter100\n   }\n\n   block FourCylinderEngine: Engine {\n      numberOfCylinders = 4;\n   }\n\n   block SixCylinderEngine: Engine {\n      numberOfCylinders = 6;\n   }\n\n   block Vehicle {\n      part engine: Engine[1];\n      part transmission: Transmission[1];\n\n      constraint FourCylinderRequiresManual {\n         if engine instanceof FourCylinderEngine then\n            transmission instanceof ManualTransmission\n      }\n\n      constraint SixCylinderRequiresAutomatic {\n         if engine instanceof SixCylinderEngine then\n            transmission instanceof AutomaticTransmission\n      }\n   }\n}",
    "package SystemModel {\n    package SoftwareDesign {\n        structure MessageFormat {}\n        structure DataFormat {}\n    }\n\n    part def ComputerSubsystem {\n        attribute softwareDesign: SoftwareDesign;\n        operation processData {\n            in input: SoftwareDesign::DataFormat;\n            out output: SoftwareDesign::MessageFormat;\n        }\n    }\n\n    part def StorageSubsystem {\n        attribute softwareDesign: SoftwareDesign;\n        operation store {\n            in data: SoftwareDesign::DataFormat;\n        }\n        operation retrieve {\n            out data: SoftwareDesign::DataFormat;\n        }\n        operation handleMessage {\n            in msg: SoftwareDesign::MessageFormat;\n        }\n    }\n\n    part def SystemAssembly {\n        part computer: ComputerSubsystem;\n        part storage: StorageSubsystem;\n\n        requirement EfficiencyReq {\n            id: 'NF1';\n            text: \"Information processing must be efficient\";\n        }\n        requirement ReliabilityReq {\n            id: 'NF2';\n            text: \"Information storage and transmission must be reliable\";\n        }\n        requirement ComplianceReq {\n            id: 'NF3';\n            text: \"Data structures must comply with specified formats\";\n        }\n\n        satisfy efficiencySatisfaction: EfficiencyReq;\n        satisfy reliabilitySatisfaction: ReliabilityReq;\n        satisfy complianceSatisfaction: ComplianceReq;\n    }\n}",
    "package PowertrainSystem {\n    block PowertrainSystem {\n        part logicalLayer : LogicalLayer;\n        part physicalLayer : PhysicalLayer;\n        allocate logicalLayer.torqueGenerator to physicalLayer.powerUnit;\n    }\n\n    block LogicalLayer {\n        part torqueGenerator : TorqueGenerator;\n    }\n\n    block PhysicalLayer {\n        part powerUnit : PowerUnit;\n    }\n\n    block TorqueGenerator {\n        // Converts power to torque\n    }\n\n    block PowerUnit {\n        // Provides power output and torque generation\n    }\n}",
    "package PowerTransmissionSystem {\n    part powerTransmissionSystem: PowerTransmission;\n\n    block PowerTransmission {\n        capability providePower: \"Deliver power and generate torque\";\n        part torqueGenerator: TorqueGenerator;\n        part powertrain: Powertrain;\n\n        allocate torqueGenerator to powertrain;\n        satisfy providePower with torqueGenerator.generateTorque;\n    }\n\n    block TorqueGenerator {\n        action generateTorque: \"Transfer and convert power to generate torque\";\n    }\n\n    block Powertrain {\n        part engine: Engine;\n        allocate torqueGenerator.generateTorque to engine.generateTorque;\n    }\n\n    block Engine {\n        action generateTorque: \"Physically produce rotational force\";\n    }\n}",
    "package VehicleFeatureAnnotation {\n    enum FunctionType {\n        Safety,\n        Security\n    }\n\n    part def Vehicle {\n        part interior: Interior;\n        part body: BodyAssembly;\n    }\n\n    part def Interior {\n        part seatBelts: SeatBelts;\n        part frontSeats: FrontSeats;\n        part driverAirbag: DriverAirbag;\n        part alarmSystem: AlarmSystem;\n    }\n\n    part def BodyAssembly {\n        part bodyShell: BodyShell;\n        part bumpers: Bumpers;\n        part keylessEntry: KeylessEntryDevice;\n    }\n\n    part def SeatBelts {\n        :functionType: FunctionType = FunctionType::Safety;\n    }\n\n    part def DriverAirbag {\n        :functionType: FunctionType = FunctionType::Safety;\n    }\n\n    part def Bumpers {\n        :functionType: FunctionType = FunctionType::Safety;\n    }\n\n    part def AlarmSystem {\n        :functionType: FunctionType = FunctionType::Security;\n    }\n\n    part def KeylessEntryDevice {\n        :functionType: FunctionType = FunctionType::Security;\n    }\n\n    part def FrontSeats {}\n    part def BodyShell {}\n}",
    "requirement InputRequirement {\n    id = \"REQ-1\";\n    text = \"The system shall be capable of performing automated simulation and analysis of vehicle dynamic behavior. Users should be able to input the vehicle’s initial velocity, initial position, acceleration at a specific moment, and the time step. Through integration with the ModelCenter analysis tool, the system shall automatically calculate and output the vehicle’s velocity and position after the specified time step based on the given physical model. The system must ensure accurate data transfer and reliable output of simulation results, enabling users to conveniently obtain key dynamic parameters to support vehicle performance analysis and design optimization.\";\n}\n\nblock ModelCenter {\n    operation computeDynamics {\n        in initialVelocity: Real;\n        in initialPosition: Real;\n        in acceleration: Real;\n        in timeStep: Real;\n        out finalVelocity: Real;\n        out finalPosition: Real;\n    }\n}\n\nblock VehicleDynamicSimulator {\n    part modelCenter: ModelCenter [1];\n    \n    operation performSimulation {\n        in initialVelocity: Real;\n        in initialPosition: Real;\n        in acceleration: Real;\n        in timeStep: Real;\n        out finalVelocity: Real;\n        out finalPosition: Real;\n    } = activity VehicleSimulation;\n    \n    satisfy InputRequirement;\n}\n\nactivity VehicleSimulation for VehicleDynamicSimulator::performSimulation {\n    call compute: modelCenter.computeDynamics {\n        in initialVelocity = initialVelocity;\n        in initialPosition = initialPosition;\n        in acceleration = acceleration;\n        in timeStep = timeStep;\n        out finalVelocity = finalVelocity;\n        out finalPosition = finalPosition;\n    }\n}",
    "package CarSafety {\n    import ScalarValues::Boolean;\n    import ScalarValues::Integer;\n\n    part Car {\n        interior: Interior[1];\n        body: Body[1];\n        wheelAssembly: WheelAssembly[1];\n    }\n\n    part Interior {\n        seatBelt: SeatBelt[2];\n        airbag: Airbag[0..1];\n    }\n\n    part Body {\n        bumper: Bumper[1];\n        keylessEntry: KeylessEntry[0..1];\n    }\n\n    part WheelAssembly {\n        wheel: Wheel[2];\n        abs: ABS[0..1];\n    }\n\n    part SeatBelt;\n    part Airbag;\n    part Bumper;\n    part KeylessEntry;\n    part Wheel;\n    part ABS;\n\n    stereotype Safety {\n        isMandatory: Boolean;\n    }\n\n    @Safety(isMandatory = true) SeatBelt;\n    @Safety(isMandatory = false) Airbag;\n    @Safety(isMandatory = true) Bumper;\n    @Safety(isMandatory = false) ABS;\n\n    view SafetyFeatures {\n        viewpoint SafetyFeaturesVP;\n        include *[hasStereotype(Safety)];\n    }\n\n    view MandatorySafetyFeatures {\n        viewpoint MandatorySafetyFeaturesVP;\n        include *[hasStereotype(Safety) and getStereotypeProperty(Safety, isMandatory) == true];\n    }\n\n    viewpoint SafetyFeaturesVP;\n    viewpoint MandatorySafetyFeaturesVP;\n}",
    "package VehicleSafetyCompliance {\n    abstract part def SafetyFeature;\n\n    part def MandatorySafetyFeature extends SafetyFeature;\n    part def OptionalSafetyFeature extends SafetyFeature;\n\n    part def SeatBelt extends MandatorySafetyFeature;\n    part def DriverAirbag extends OptionalSafetyFeature;\n    part def Bumper extends MandatorySafetyFeature;\n    part def KeylessEntry extends OptionalSafetyFeature;\n    part def Tire extends MandatorySafetyFeature;\n    part def AntiLockBrakingSystem extends OptionalSafetyFeature;\n\n    part def Interior {\n        parts: \n            seatBelt: SeatBelt[2];\n            driverAirbag: DriverAirbag[0..1];\n    }\n\n    part def Body {\n        parts: \n            bumper: Bumper[1];\n            keylessEntry: KeylessEntry[0..1];\n    }\n\n    part def Chassis {\n        parts: \n            tire: Tire[4];\n            abs: AntiLockBrakingSystem[0..1];\n    }\n\n    part def Vehicle {\n        parts: \n            interior: Interior[1];\n            body: Body[1];\n            chassis: Chassis[1];\n    }\n}",
    "package RiskManagement {\n    part def Cause {\n        attr probability: Real;\n    }\n\n    part def Situation;\n\n    part def Failure: Situation {\n        attr severity: Integer;\n    }\n\n    association def LeadsTo {\n        source: (Cause | Situation)[1];\n        target: Situation[1];\n    }\n\n    part def RiskScenario {\n        part causes: Cause[*];\n        part situations: Situation[*];\n        part failures: Failure[*] :> situations;\n        part relationships: LeadsTo[*] {\n            source: (causes | situations)[1];\n            target: situations[1];\n        }\n    }\n}",
    "package RiskMetadataModel {\n   partdef Cause {\n      attribute description: String;\n      attribute probability: Float;\n   }\n\n   partdef Failure {\n      attribute description: String;\n      attribute severity: String;\n   }\n\n   partdef Scenario {\n      attribute description: String;\n      association cause: Cause[*];\n      association failure: Failure[*];\n      association leadsTo: Scenario[*];\n   }\n\n   partdef RiskScenario {\n      attribute name: String;\n      association scenario: Scenario[*];\n      association cause: Cause[*];\n      association failure: Failure[*];\n   }\n}",
    "package RiskAnalysisSystem {\n   part def Equipment {\n      part battery : Battery;\n      attribute minBatteryThreshold : Real;\n   }\n\n   part def Battery {\n      attribute level : Real;\n      attribute age : Real;\n   }\n\n   state def OperationalState {\n      state Normal;\n      state LowBattery {\n         constraint lowBatteryCondition : battery.level < equipment.minBatteryThreshold;\n      };\n      state DeviceShutdown;\n\n      transition from Normal to LowBattery on BatteryLow;\n      transition from LowBattery to DeviceShutdown on ProlongedLowBattery;\n   }\n\n   event def BatteryLow {\n      condition : equipment.battery.level < equipment.minBatteryThreshold;\n   }\n\n   event def ProlongedLowBattery {\n      constraint durationThreshold : Time;\n      condition : duration(OperationalState::LowBattery) > durationThreshold;\n   }\n\n   requirement id R1 {\n      text : \"Monitor battery level continuously during operation\";\n   }\n\n   requirement id R2 {\n      text : \"Detect increased failure probability due to aging\";\n   }\n\n   requirement id R3 {\n      text : \"Identify risk: 'battery aging' leads to 'low battery level'\";\n   }\n\n   requirement id R4 {\n      text : \"Determine 'low battery' state when below threshold\";\n   }\n\n   requirement id R5 {\n      text : \"Predict device shutdown if low battery persists\";\n   }\n\n   requirement id R6 {\n      text : \"Assign severity levels for critical failures\";\n   }\n\n   risk def BatteryAgingRisk {\n      cause : equipment.battery.age;\n      effect : OperationalState::LowBattery;\n      requirement = [R3];\n   }\n\n   failure def DeviceShutdownFailure {\n      effect : OperationalState::DeviceShutdown;\n      severity : Integer;\n      requirement = [R5, R6];\n   }\n\n   activity def MonitorBattery {\n      input : equipment.battery.level;\n      output : batteryStatus : OperationalState;\n      requirement = [R1, R2, R4];\n   }\n\n   activity def RiskAssessment {\n      input : batteryStatus : OperationalState;\n      output : riskLevel : Real;\n      output : severity : Integer;\n      requirement = [R6];\n   }\n\n   constraint def AgingImpact {\n      subject : equipment.battery;\n      expression : battery.failureProbability = f(battery.age);\n   }\n\n   constraint def ShutdownSeverity {\n      subject : DeviceShutdownFailure;\n      expression : severity = 10; // Highest severity level\n   }\n}",
    "package StructuralDecomposition {\n    part def System {\n        part subsystem1 : Subsystem1;\n        part subsystem2 : Subsystem2;\n        \n        port powerIn : PowerInterface;\n        port dataOut : DataInterface;\n        \n        connector powerSub1 : powerIn -> subsystem1.powerReq;\n        connector dataSub2 : subsystem2.dataProv -> dataOut;\n    }\n\n    part def Subsystem1 {\n        part compA : ComponentA;\n        port powerReq : PowerInterface;\n        port dataExchange : DataInterface;\n        \n        connector powerComp : powerReq -> compA.powerInput;\n        connector dataComp : compA.dataPort <-> dataExchange;\n    }\n\n    part def Subsystem2 {\n        part compB : ComponentB;\n        port dataProv : DataInterface;\n        \n        connector dataConn : compB.dataOutput -> dataProv;\n    }\n\n    part def ComponentA {\n        port powerInput : PowerInterface;\n        port dataPort : DataInterface;\n    }\n\n    part def ComponentB {\n        port dataOutput : DataInterface;\n    }\n\n    interface def PowerInterface {\n        property voltage : Real;\n        property maxCurrent : Real;\n    }\n\n    interface def DataInterface {\n        property protocol : String;\n        property bandwidth : Real;\n    }\n\n    requirement def SystemRequirements {\n        req structuralDecomp : \"Enable hierarchical decomposition into subsystems/components\";\n        req interfaceDefinition : \"Define explicit interfaces between components\";\n        req independentVerifiability : \"Support IV&V through structural analysis\";\n    }\n\n    satisfy SystemSatisfaction {\n        satisfy topLevelReq : SystemRequirements.structuralDecomp -> System;\n        satisfy interfaceReq : SystemRequirements.interfaceDefinition -> \n            [System.subsystem1, System.subsystem2, Subsystem1.compA, Subsystem2.compB];\n        satisfy ivvReq : SystemRequirements.independentVerifiability -> \n            [System, Subsystem1, Subsystem2, ComponentA, ComponentB];\n    }\n}",
    "package AutomotiveSystem {\n    part def AutomotiveSystem {\n        part body: Body;\n        part chassis: Chassis;\n        part powertrain: Powertrain;\n    }\n\n    part def Body {\n        part seatBelt: SeatBelt;\n        part driverAirbag: DriverAirbag?;\n        part interiorLighting: InteriorLighting;\n    }\n\n    part def Chassis {\n        part bumper: Bumper;\n        part abs: AntiLockBrakingSystem?;\n        part suspension: Suspension;\n    }\n\n    part def Powertrain {\n        part engine: Engine;\n        part transmission: Transmission;\n    }\n\n    part def SeatBelt {\n        :> SafetyAspect (isMandatory = true);\n    }\n\n    part def Bumper {\n        :> SafetyAspect (isMandatory = true);\n    }\n\n    part def DriverAirbag {\n        :> SafetyAspect (isMandatory = false);\n    }\n\n    part def AntiLockBrakingSystem {\n        :> SafetyAspect (isMandatory = false);\n    }\n\n    part def InteriorLighting;\n    part def Suspension;\n    part def Engine;\n    part def Transmission;\n\n    stereotype SafetyAspect {\n        isMandatory: Boolean;\n    }\n\n    interface VehicleInterface;\n    port vehiclePort: out VehicleInterface;\n}",
    "package AutomotiveDomain {\n   /*\n      This package provides standardized definitions and annotations for fundamental concepts and elements in the automotive domain.\n      It emphasizes clarity and extensibility for development, integration, and maintenance of automotive-related systems.\n   */\n\n   value type 扭矩 {\n      unit N⋅m; // Newton meter (SI unit for torque)\n      value: Real; // Physical quantity value\n      comment = \"物理量，表示旋转力，用于描述汽车发动机或传动系统的性能\"\n   }\n   alias 扭矩 as Torque; // English alias for international usage\n\n   /*\n      汽车 (Automobile) is the core component of the automotive domain.\n      It includes key characteristics and can be extended for specific vehicle types.\n   */\n   block 汽车 {\n      alias 汽车 as Car; // Standardized English alias\n      comment = \"核心组件，代表具有动力传动系统的道路车辆\"\n\n      /*\n         Associated physical quantities defining automotive characteristics.\n         Extensible for additional attributes like horsepower or fuel efficiency.\n      */\n      engineTorque: 扭矩; // Standardized torque expression\n   }\n}",
    "package DocumentManagementPlatform {\n   import Kernel::*;\n   import SysML::ValueTypes::*;\n   import SysML::Blocks::*;\n\n   block Automobile;\n\n   alias Car = Automobile;\n\n   block Document {\n      attribute title: String;\n      attribute content: String;\n   }\n\n   value type TorqueValue: Real; // Conforms to ISQ standard\n\n   association DocumentAnnotation {\n      subject: Element[*] {\n         -> document: Document[*];\n      }\n   }\n}",
    "package AutomobileSystem {\n    import SI;\n\n    value type TorqueValue: SI::Torque {\n        unit = SI::NewtonMetre;\n    }\n\n    alias Torque is TorqueValue;\n\n    part def Automobile {\n        attribute maxTorque: TorqueValue;\n        attribute peakTorqueRPM: Real;\n    }\n\n    alias Car is Automobile;\n}",
    "model VehicleSystem {\n   block Cylinder\n\n   block Engine {\n      parts\n         cylinder: Cylinder[4..6];\n   }\n\n   block FourCylinderEngine: Engine {\n      parts\n         cylinder: Cylinder[4] redefines Engine::cylinder;\n   }\n\n   block SixCylinderEngine: Engine {\n      parts\n         cylinder: Cylinder[6] redefines Engine::cylinder;\n   }\n\n   block Vehicle {\n      parts\n         engine: Engine[1];\n   }\n\n   block SmallVehicle: Vehicle {\n      parts\n         engine: FourCylinderEngine[1] redefines Vehicle::engine;\n   }\n\n   block LargeVehicle: Vehicle {\n      parts\n         engine: SixCylinderEngine[1] redefines Vehicle::engine;\n   }\n}",
    "package FuelSystem {\n    requirement req1 {\n        id = \"REQ1\"\n        text = \"The system shall be capable of managing fuel flow, ensuring that fuel can be delivered from the fuel tank to the engine and supporting fuel return.\"\n    }\n    \n    requirement req2 {\n        id = \"REQ2\"\n        text = \"During operation, the system shall monitor and manage the temperature of the fuel.\"\n    }\n    \n    requirement req3 {\n        id = \"REQ3\"\n        text = \"The system shall realize fuel supply and return through fuel interfaces.\"\n    }\n    \n    requirement req4 {\n        id = \"REQ4\"\n        text = \"The fuel tank and the engine shall be connected via standardized fuel interfaces to ensure the reliability and safety of fuel flow.\"\n    }\n    \n    flow specification FuelFlow {\n        in temperature: Temperature\n    }\n    \n    value type Temperature {\n        unit = \"°C\"\n    }\n    \n    interface FuelInterface {\n        port fuelPort: FuelFlow\n    }\n    \n    block FuelTank {\n        port supply: out FuelFlow\n        port return: in FuelFlow\n    }\n    \n    block Engine {\n        port supply: in FuelFlow\n        port return: out FuelFlow\n    }\n    \n    block FuelManagementSystem {\n        part tank: FuelTank\n        part engine: Engine\n        \n        connection fuelSupply {\n            from tank.supply\n            to engine.supply\n        }\n        \n        connection fuelReturn {\n            from engine.return\n            to tank.return\n        }\n        \n        satisfy {\n            req1 satisfiedBy fuelSupply, fuelReturn\n            req2 satisfiedBy FuelFlow::temperature\n            req3 satisfiedBy [tank.supply, tank.return, engine.supply, engine.return]\n            req4 satisfiedBy fuelSupply, fuelReturn\n        }\n    }\n}",
    "unit kg;\n\nvalue type Mass [kg];\n\nblock Wheel;\n\nblock Axle;\n\nblock AxleAssembly {\n    parts:\n        axle: Axle;\n        leftWheel: Wheel;\n        rightWheel: Wheel;\n}\n\nblock FrontAxleAssembly specializes AxleAssembly {\n    attributes:\n        steeringAngle: Real[0..1];\n}\n\nblock Vehicle {\n    attributes:\n        mass: Mass;\n    parts:\n        frontAxle: FrontAxleAssembly;\n        rearAxle: AxleAssembly;\n}"
]