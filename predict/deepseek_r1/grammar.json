[
    "package VehicleSystem {\n    block Vehicle {\n        attribute mass: Real;\n        part status: VehicleStatus[1];\n        part engine: Engine[1];\n        reference driver: Driver[0..1];\n    }\n\n    block VehicleStatus {\n        attribute gear: Integer;\n        attribute acceleratorPosition: Real;\n    }\n\n    block Engine {\n        // Engine characteristics and behaviors\n    }\n\n    block Driver {\n        // Driver attributes and operations\n    }\n}",
    "package Vehicles {\n    block Vehicle {\n        abstract; // Abstract base for all vehicles\n    }\n\n    block ManuallyOperatedVehicle extends Vehicle {\n        ref driver: Personnel[1]; // Single driver per vehicle\n    }\n\n    block PoweredVehicle extends Vehicle {\n        ref engine: Engine[1]; // Single engine per vehicle\n    }\n\n    block ManuallyOperatedPoweredVehicle extends ManuallyOperatedVehicle, PoweredVehicle {\n        // Inherits both driver and engine references\n    }\n\n    block Personnel; // Entity representing drivers\n\n    block Engine; // Entity representing power devices\n}",
    "package VehicleStructure {\n   abstract block VehicleComponent;\n\n   block Engine :> VehicleComponent;\n\n   block Transmission :> VehicleComponent;\n\n   block Wheel :> VehicleComponent;\n\n   block Vehicle {\n      part engine : Engine[1];\n      part transmission : Transmission[1];\n      part wheels : Wheel[4];\n   }\n}",
    "part def Cylinder;\n\nblock Engine {\n    part cylinders : Cylinder [*];\n}\n\nblock SmallEngine: Engine {\n    redefines cylinders : Cylinder [4];\n}\n\nblock LargeEngine: Engine {\n    redefines cylinders : Cylinder [6];\n}\n\nblock Vehicle {\n    part engine : Engine [1];\n}\n\nblock SmallVehicle: Vehicle {\n    redefines engine : SmallEngine;\n}\n\nblock LargeVehicle: Vehicle {\n    redefines engine : LargeEngine;\n}",
    "package TrafficSignalSystem {\n   enum LightColor {\n      green;\n      yellow;\n      red;\n   }\n\n   block TrafficSignal {\n      currentColor: LightColor;\n   }\n\n   block AlwaysGreenSignal: TrafficSignal {\n      constraint alwaysGreen: currentColor = LightColor::green;\n   }\n\n   block TrafficSignalSystem {\n      part trafficSignal: TrafficSignal;\n      part specificGreenSignal: AlwaysGreenSignal;\n   }\n}",
    "package InformationManagement {\n   part def InformationClassification {\n      attribute level: String;\n      attribute code: String;\n      attribute color: String;\n   }\n\n   instance Unclassified: InformationClassification {\n      level: 'Unclassified';\n      code: 'uncl';\n      color: 'green';\n   }\n\n   instance Confidential: InformationClassification {\n      level: 'Confidential';\n      code: 'conf';\n      color: 'yellow';\n   }\n\n   instance Secret: InformationClassification {\n      level: 'Secret';\n      code: 'secr';\n      color: 'red';\n   }\n\n   part def GradeClassification {\n      attribute level: String;\n      attribute points: Real;\n   }\n\n   instance GradeA: GradeClassification {\n      level: 'A';\n      points: 4.0;\n   }\n\n   instance GradeB: GradeClassification {\n      level: 'B';\n      points: 3.0;\n   }\n\n   instance GradeC: GradeClassification {\n      level: 'C';\n      points: 2.0;\n   }\n\n   instance GradeD: GradeClassification {\n      level: 'D';\n      points: 1.0;\n   }\n\n   instance GradeF: GradeClassification {\n      level: 'F';\n      points: 0.0;\n   }\n}",
    "part def Cylinder {}\n\npart def SmallEngine {\n    part cylinder : Cylinder[4];\n}\n\npart def LargeEngine {\n    part cylinder : Cylinder[6];\n}\n\npart def SmallVehicle {\n    part engine : SmallEngine;\n}\n\npart def LargeVehicle {\n    part engine : LargeEngine;\n}",
    "package VehicleModel {\n    enum FuelType {\n        Gasoline,\n        Diesel,\n        Electric\n    }\n\n    part FuelTank {\n        attr fuelType: FuelType;\n    }\n\n    class Personnel {\n        attr name: string;\n    }\n\n    class Driver extends Personnel {\n        attr licenseNumber: string;\n    }\n\n    part Vehicle {\n        attr qualityAttributes: string;\n        part fuelTank: FuelTank;\n        ref driver: Driver;\n    }\n\n    part System {\n        part vehicles: Vehicle[*];\n        part personnel: Personnel[*];\n        part fuelTypes: FuelType[*];\n    }\n}",
    "part def AutomobileWheelAssembly {\n    part wheelBearingUnit : WheelBearingUnit;\n    part tire : Tire;\n    part hub : Hub;\n    part bolts : Bolt[5];\n    connector bead1Rim : PressFit between tire.bead1, hub.rim1;\n    connector bead2Rim : PressFit between tire.bead2, hub.rim2;\n    connector bolt1 : BoltConnection between hub.boltMountingHoles[1], hub.threadedHoles[1], bolts[1];\n    connector bolt2 : BoltConnection between hub.boltMountingHoles[2], hub.threadedHoles[2], bolts[2];\n    connector bolt3 : BoltConnection between hub.boltMountingHoles[3], hub.threadedHoles[3], bolts[3];\n    connector bolt4 : BoltConnection between hub.boltMountingHoles[4], hub.threadedHoles[4], bolts[4];\n    connector bolt5 : BoltConnection between hub.boltMountingHoles[5], hub.threadedHoles[5], bolts[5];\n}\n\npart def Tire {\n    part bead1 : Bead;\n    part bead2 : Bead;\n}\n\npart def Hub {\n    part rim1 : Rim;\n    part rim2 : Rim;\n    part boltMountingHoles : BoltMountingHole[5];\n    part threadedHoles : ThreadedHole[5];\n}\n\npart def WheelBearingUnit;\npart def Bead;\npart def Rim;\npart def BoltMountingHole;\npart def ThreadedHole;\npart def Bolt;\nconnector def PressFit;\nconnector def BoltConnection;",
    "interface def FuelFlow {\n   in flowRate: Real;\n   in temperature: Real;\n}\n\nport def FuelPort: FuelFlow;\n\ninterface def MonitoringData {\n   in supplyFlow: Real;\n   in returnFlow: Real;\n   in supplyTemp: Real;\n   in returnTemp: Real;\n}\n\nport def MonitorPort: MonitoringData;\n\nblock FuelTankAssembly {\n   port supplyOut: out FuelPort;\n   port returnIn: in FuelPort;\n}\n\nblock Engine {\n   port supplyIn: in FuelPort;\n   port returnOut: out FuelPort;\n}\n\nblock FuelSystem {\n   part fuelTank: FuelTankAssembly;\n   part engine: Engine;\n   port monitor: out MonitorPort;\n\n   connector supplyLine: fuelTank.supplyOut -> engine.supplyIn;\n   connector returnLine: engine.returnOut -> fuelTank.returnIn;\n}",
    "package VehicleModel {\n    block Vehicle {\n        attribute mass : Real = 1750.0;\n        part frontAxle : FrontAxle[1];\n        part rearAxle : RearAxle[1];\n    }\n\n    block Axle {\n        attribute mass : Real;\n        part tire : Tire[2] ordered;\n    }\n\n    block FrontAxle: Axle;\n    block RearAxle: Axle;\n\n    block SteeringFrontAxle: FrontAxle {\n        attribute steeringAngle : Real;\n    }\n\n    block Tire {\n        attribute mass : Real;\n    }\n}\n\nconfiguration vehicle1_c1 {\n    vehicle1: VehicleModel!Vehicle {\n        mass = 2000.0;\n        frontAxle as steeringFront: VehicleModel!SteeringFrontAxle;\n    }\n}",
    "package CouplingSystemModel {\n   interface HitchMount;\n   interface BallCoupling;\n\n   part Vehicle {\n      port hitchMount : HitchMount;\n   }\n\n   part Hitch {\n      port vehicleSide : HitchMount;\n      part ball : BallConnector;\n   }\n\n   part BallConnector {\n      port couplingSurface : BallCoupling;\n   }\n\n   part Trailer {\n      port couplingHead : BallCoupling;\n   }\n\n   partdef CouplingSystem {\n      part vehicle : Vehicle;\n      part trailer : Trailer;\n      part hitch : Hitch;\n\n      connector vehicleHitchConnection : HitchMount {\n         end vehicle.hitchMount;\n         end hitch.vehicleSide;\n      }\n\n      connector trailerBallConnection : BallCoupling {\n         end trailer.couplingHead;\n         end hitch.ball.couplingSurface;\n      }\n   }\n}",
    "part VehiclePowerTransmissionSystem {\n    port fuelCommand: in;\n    port roadInterface: out;\n\n    part engine: Engine;\n    part transmission: Transmission;\n    part clutch: Clutch;\n    part driveshaft: DriveShaft;\n    part rearAxle: RearAxleAssembly;\n    part leftWheel: Wheel;\n    part rightWheel: Wheel;\n\n    connector fuelCmd: fuelCommand -> engine.fuelCommand;\n    connector engToClutch: engine.powerOutput -> clutch.engineSide;\n    connector engClutchCtrl: engine.clutchControl -> clutch.control;\n    connector clutchToTrans: clutch.transmissionSide -> transmission.input;\n    connector transToDriveshaft: transmission.output -> driveshaft.input;\n    connector driveshaftToAxle: driveshaft.output -> rearAxle.input;\n    connector axleToLeftWheel: rearAxle.leftOutput -> leftWheel.axleInterface;\n    connector axleToRightWheel: rearAxle.rightOutput -> rightWheel.axleInterface;\n    connector leftWheelToRoad: leftWheel.roadInterface -> roadInterface;\n    connector rightWheelToRoad: rightWheel.roadInterface -> roadInterface;\n}\n\npart Engine {\n    port fuelCommand: in;\n    port powerOutput: out;\n    port clutchControl: out;\n}\n\npart Transmission {\n    port input: in;\n    port output: out;\n}\n\npart Clutch {\n    port engineSide: in;\n    port transmissionSide: out;\n    port control: in;\n}\n\npart DriveShaft {\n    port input: in;\n    port output: out;\n}\n\npart RearAxleAssembly {\n    port input: in;\n    port leftOutput: out;\n    port rightOutput: out;\n\n    part differential: Differential;\n    part leftHalfShaft: HalfShaft;\n    part rightHalfShaft: HalfShaft;\n\n    connector diffInput: input -> differential.input;\n    connector diffToLeft: differential.leftOutput -> leftHalfShaft.input;\n    connector diffToRight: differential.rightOutput -> rightHalfShaft.input;\n    connector leftShaftToPort: leftHalfShaft.output -> leftOutput;\n    connector rightShaftToPort: rightHalfShaft.output -> rightOutput;\n}\n\npart Differential {\n    port input: in;\n    port leftOutput: out;\n    port rightOutput: out;\n}\n\npart HalfShaft {\n    port input: in;\n    port output: out;\n}\n\npart Wheel {\n    port axleInterface: in;\n    port roadInterface: out;\n}",
    "interface def pe;\ninterface def pf;\ninterface def internal_signal : Signal;\n\npart def c1 {\n    port pb: pe;\n    port internal_port: internal_signal;\n}\n\npart def c2 {\n    port internal_port: internal_signal;\n}\n\npart def c3 {\n    port pd: pf;\n    port internal_port: internal_signal;\n}\n\npart def c4 {\n    port internal_port: internal_signal;\n}\n\npart def SubsystemB11 {\n    part comp1: c1;\n    part comp2: c2;\n    connect comp1.internal_port to comp2.internal_port;\n    port pePort: pe = comp1.pb;\n}\n\npart def SubsystemB12 {\n    part comp3: c3;\n    part comp4: c4;\n    connect comp3.internal_port to comp4.internal_port;\n    port pfPort: pf = comp3.pd;\n}\n\npart def ModuleB21 {\n    part comp1: c1;\n    part comp2: c2;\n}\n\npart def ModuleB22 {\n    part comp3: c3;\n    part comp4: c4;\n}\n\npart def System;\n\npart FirstDecomposition: System {\n    part b11: SubsystemB11;\n    part b12: SubsystemB12;\n    connect b11.pePort to b12.pfPort;\n}\n\npart SecondDecomposition: System {\n    part b21: ModuleB21;\n    part b22: ModuleB22;\n}",
    "package AutomotivePowertrain {\n    value type FuelCommand;\n    value type StartStopCommand;\n    value type Torque;\n\n    block Engine {\n        port fuelIn: in FuelCommand;\n        port controlIn: in StartStopCommand;\n        port torqueOut: out Torque;\n    }\n\n    block Transmission {\n        port torqueIn: in Torque;\n        port torqueOut: out Torque;\n    }\n\n    block Driveshaft {\n        port torqueIn: in Torque;\n        port leftOut: out Torque;\n        port rightOut: out Torque;\n    }\n\n    block Wheel {\n        port torqueIn: in Torque;\n    }\n\n    block PowertrainSystem {\n        part engine: Engine;\n        part transmission: Transmission;\n        part driveshaft: Driveshaft;\n        part leftWheel: Wheel;\n        part rightWheel: Wheel;\n\n        port fuelCommand: in FuelCommand;\n        port startStop: in StartStopCommand;\n\n        connector fuelFlow: fuelCommand -> engine.fuelIn;\n        connector controlFlow: startStop -> engine.controlIn;\n        connector engineToTrans: engine.torqueOut -> transmission.torqueIn;\n        connector transToDrive: transmission.torqueOut -> driveshaft.torqueIn;\n        connector driveToLeft: driveshaft.leftOut -> leftWheel.torqueIn;\n        connector driveToRight: driveshaft.rightOut -> rightWheel.torqueIn;\n    }\n}",
    "value type FuelCommand;\nvalue type StallSignal;\nvalue type Torque;\nevent stallSignal: StallSignal;\n\npart def AutomotivePowertrainControlSystem {\n    port fuelControlCommand: in FuelCommand;\n    port stallSignal: in StallSignal;\n    port outputTorque: out Torque;\n\n    activity PowerTransmissionProcess {\n        input: fuelControlCommand: FuelCommand;\n        output: outputTorque: Torque;\n\n        object node generatedTorque: Torque;\n        object node amplifiedTorque: Torque;\n        object node transmittedTorque: Torque;\n        object node distributedTorque: Torque;\n\n        action startEngine {\n            input: cmd: FuelCommand;\n        }\n        action generateTorque {\n            output: torque: Torque;\n        }\n        action amplifyTorque {\n            input: inTorque: Torque;\n            output: outTorque: Torque;\n        }\n        action transmitTorque {\n            input: inTorque: Torque;\n            output: outTorque: Torque;\n        }\n        action distributeTorque {\n            input: inTorque: Torque;\n            output: outTorque: Torque;\n        }\n        action deliverToWheels {\n            input: inTorque: Torque;\n            output: outTorque: Torque;\n        }\n        action acceptStall: AcceptEventAction { event: stallSignal; }\n\n        initial: initial;\n        final: final;\n        fork: fork;\n\n        edge initial -> fork;\n        edge fork -> startEngine;\n        edge fork -> acceptStall;\n        edge startEngine -> generateTorque;\n        edge generateTorque -> amplifyTorque;\n        edge amplifyTorque -> transmitTorque;\n        edge transmitTorque -> distributeTorque;\n        edge distributeTorque -> deliverToWheels;\n        edge deliverToWheels -> final;\n        edge acceptStall -> final;\n\n        edge fuelControlCommand -> startEngine.cmd;\n        edge generateTorque.torque -> generatedTorque;\n        edge generatedTorque -> amplifyTorque.inTorque;\n        edge amplifyTorque.outTorque -> amplifiedTorque;\n        edge amplifiedTorque -> transmitTorque.inTorque;\n        edge transmitTorque.outTorque -> transmittedTorque;\n        edge transmittedTorque -> distributeTorque.inTorque;\n        edge distributeTorque.outTorque -> distributedTorque;\n        edge distributedTorque -> deliverToWheels.inTorque;\n        edge deliverToWheels.outTorque -> outputTorque;\n    }\n}",
    "part VehiclePowertrainSystem {\n   behavior PowertrainManagementActivity;\n}\n\nevent EngineStartSignal;\nevent EngineShutdownSignal;\n\ntype FuelCommand;\ntype Torque;\n\naction GenerateEngineTorque {\n   in fuelCommand: FuelCommand;\n   out torque: Torque;\n}\n\naction AmplifyTorque {\n   in inputTorque: Torque;\n   out amplifiedTorque: Torque;\n}\n\naction DistributeTorque {\n   in torque: Torque;\n   out wheelTorque: Torque[4];\n}\n\nactivity PowertrainManagementActivity {\n   in fuelCommand: FuelCommand;\n   node acceptStart: AcceptEventAction {\n      event: EngineStartSignal;\n   }\n   node generate: GenerateEngineTorque;\n   node amplify: AmplifyTorque;\n   node distribute: DistributeTorque;\n   node acceptShutdown: AcceptEventAction {\n      event: EngineShutdownSignal;\n   }\n   region interruptible: InterruptibleRegion {\n      node generate;\n      node amplify;\n      node distribute;\n      node acceptShutdown;\n      edge from generate to amplify;\n      edge from amplify to distribute;\n      interruptingEdge from acceptShutdown;\n   }\n   edge from acceptStart to interruptible;\n   edge from activityParameter fuelCommand to generate.fuelCommand;\n}",
    "block HitchBall\nblock TrailerCoupler\n\nblock VehicleFrame {\n    part hitchBall: HitchBall\n}\n\nblock TrailerFrame {\n    part trailerCoupler: TrailerCoupler\n}\n\nblock Vehicle {\n    part frame: VehicleFrame\n}\n\nblock Trailer {\n    part frame: TrailerFrame\n}\n\nblock VehicleTrailerHitchingSystem {\n    ref vehicle: Vehicle\n    ref trailer: Trailer\n    connector hitchConnection: connect vehicle.frame.hitchBall, trailer.frame.trailerCoupler\n}",
    "package TrailerSystem {\n   part def Vehicle {\n      part chassis : Chassis[1];\n   }\n\n   part def Chassis {\n      part towBall : TowBall[1];\n   }\n\n   part def TowBall;\n\n   part def Trailer {\n      part frame : TrailerFrame[1];\n   }\n\n   part def TrailerFrame {\n      part coupler : Coupler[1];\n   }\n\n   part def Coupler;\n\n   association Hitch {\n      end1 : TowBall[0..1];\n      end2 : Coupler[0..1];\n   }\n\n   part def TrailerManagementSystem {\n      part vehicle : Vehicle[1];\n      part trailer : Trailer[1];\n   }\n}",
    "package DynamicConnectionModel {\n    block Vehicle {\n        part chassis: Chassis;\n        operation hitch(trailer: Trailer);\n        operation unhitch();\n    }\n\n    block Chassis {\n        part towBall: TowBall;\n    }\n\n    block TowBall;\n\n    block Trailer {\n        part trailerChassis: TrailerChassis;\n        part coupler: Coupler;\n        operation hitch(vehicle: Vehicle);\n        operation unhitch();\n    }\n\n    block TrailerChassis;\n\n    block Coupler {\n        reference connectedTo: TowBall[0..1];\n        operation engage(ball: TowBall);\n        operation disengage();\n    }\n\n    association HitchConnection {\n        end coupler: Coupler[0..1];\n        end towBall: TowBall[0..1];\n    }\n}",
    "package FuelSystem {\n    flow specification FuelFlow {\n        temperature: Real;\n    }\n\n    interface FuelSupplyInterface {\n        ports {\n            fuelOut: out FuelFlow;\n        }\n    }\n\n    interface FuelReturnInterface {\n        ports {\n            fuelIn: in FuelFlow;\n        }\n    }\n\n    part def FuelTank {\n        ports {\n            supplyPort: FuelSupplyInterface;\n            returnPort: FuelReturnInterface;\n        }\n    }\n\n    part def Engine {\n        ports {\n            supplyPort: FuelReturnInterface;\n            returnPort: FuelSupplyInterface;\n        }\n    }\n\n    part def FuelSystem {\n        parts {\n            tank: FuelTank;\n            engine: Engine;\n        }\n        connectors {\n            supplyLine: tank.supplyPort.fuelOut -> engine.supplyPort.fuelIn;\n            returnLine: engine.returnPort.fuelOut -> tank.returnPort.fuelIn;\n        }\n        constraints {\n            monitorTemperature: FuelFlow.temperature <> null;\n        }\n    }\n}",
    "value type Fuel;\nvalue type Real;\n\npart def StorageTank;\n\npart def FuelPump;\n\npart def VehicleFuelTank {\n    value maxCapacity: Real;\n    value currentFuelLevel: Real;\n}\n\nblock FuelDeliverySystem {\n    part storageTank: StorageTank;\n    part fuelPump: FuelPump;\n    ref vehicleFuelTank: VehicleFuelTank;\n\n    connector from storageTank to fuelPump;\n    connector from fuelPump to vehicleFuelTank;\n\n    item flow fuel: Fuel along storageTank->fuelPump, fuelPump->vehicleFuelTank;\n}",
    "package AutomobileAssembly {\n    block VehicleAssembly {\n        // Represents the initial vehicle without gearbox and engine\n    }\n\n    block Gearbox {\n        // Independent functional unit for power transmission\n    }\n\n    block Engine {\n        // Independent functional unit for power generation\n    }\n\n    block AssemblyWithoutEngine {\n        part gearbox : Gearbox; // Gearbox installed\n        // Engine not yet installed\n    }\n\n    block FullyAssembledVehicle {\n        part gearbox : Gearbox; // Functional gearbox unit\n        part engine : Engine;   // Functional engine unit\n    }\n\n    action InstallGearbox {\n        in inputVehicle : VehicleAssembly;\n        in inputGearbox : Gearbox;\n        out outputVehicle : AssemblyWithoutEngine;\n    }\n\n    action InstallEngine {\n        in inputVehicle : AssemblyWithoutEngine;\n        in inputEngine : Engine;\n        out outputVehicle : FullyAssembledVehicle;\n    }\n\n    activity FinalAssemblyLine {\n        in initialVehicle : VehicleAssembly;\n        in gearbox : Gearbox;\n        in engine : Engine;\n        out finalVehicle : FullyAssembledVehicle;\n\n        step gearboxStep : InstallGearbox {\n            inVehicle: initialVehicle,\n            inGearbox: gearbox\n        } -> outVehicle: intermediate;\n\n        step engineStep : InstallEngine {\n            inVehicle: intermediate,\n            inEngine: engine\n        } -> outVehicle: finalVehicle;\n    }\n}",
    "package VehicleSystem {\n    import SysML::StateMachines::*;\n    import SysML::Activities::*;\n\n    part def VehicleA {\n        state machine VehicleStateMachine {\n            initial state Off;\n            state Off;\n            state Starting;\n            state Running {\n                entry {\n                    performSelfChecks();\n                    supplyPower();\n                }\n                exit {\n                    applyParkingBrake();\n                }\n            }\n            state HealthManagement;\n            state Degraded;\n            state Maintenance;\n            state Normal;\n\n            transition from Off to Starting: on startSignal when brakePedalPressed;\n            transition from Starting to Running: on vehicleOnSignal;\n            transition from Running to Degraded: on overTemperature {\n                effect {\n                    send(overTemperatureSignal);\n                }\n            }\n            transition from Degraded to Normal: on restoreToNormalSignal;\n        }\n    }\n\n    signal startSignal;\n    signal vehicleOnSignal;\n    signal shutdownSignal;\n    signal overTemperature;\n    signal restoreToNormalSignal;\n    signal overTemperatureSignal;\n\n    action performSelfChecks;\n    action supplyPower;\n    action applyParkingBrake;\n    action send;\n\n    property brakePedalPressed: Boolean;\n}",
    "package VehicleSystem {\n    import SysML::libraries::*;\n\n    signal StartSignal {}\n    signal BrakePedalPressed {}\n    signal OverheatingWarning {}\n\n    enum VehicleStatus {\n        SHUTDOWN;\n        STARTING;\n        NORMAL;\n        DEGRADED;\n    }\n\n    block Vehicle {\n        attribute fuel: Real;\n        attribute maintenanceInterval: Time;\n        attribute temperatureThreshold: Real;\n        attribute currentTemperature: Real;\n        attribute status: VehicleStatus = VehicleStatus::SHUTDOWN;\n        reference controller: VehicleController;\n\n        event brakePressed: BrakePedalPressed;\n        event startReceived: StartSignal;\n        event overheat: ChangeEvent { changeExpression: 'currentTemperature > temperatureThreshold' }\n\n        operation selfInspection();\n        operation powerSupply();\n        operation enterDegradedMode();\n        operation sendWarning() {\n            controller.handleWarning(OverheatingWarning);\n        }\n        operation performMaintenance();\n        operation recoverFault();\n\n        state machine {\n            initial -> Shutdown;\n            state Shutdown {\n                on startReceived [brakePressed] -> Starting;\n            }\n            state Starting {\n                entry / selfInspection();\n                entry / powerSupply();\n                -> Normal;\n            }\n            state Normal {\n                on overheat -> Degraded {\n                    effect / sendWarning();\n                    effect / enterDegradedMode();\n                }\n            }\n            state Degraded {\n                on recoverFault -> Normal;\n            }\n        }\n\n        part healthManager: PeriodicActivity {\n            period: maintenanceInterval;\n            on timeout -> / performMaintenance();\n        }\n    }\n\n    block VehicleController {\n        reference vehicle: Vehicle;\n\n        operation handleWarning(warning: OverheatingWarning);\n        operation automaticStart() {\n            vehicle.startReceived.occur();\n        }\n        operation automaticShutdown();\n    }\n\n    block VehicleManagementSystem {\n        part vehicle: Vehicle;\n        part controller: VehicleController;\n\n        connector controlLink: vehicle.controller = controller;\n        connector monitorLink: controller.vehicle = vehicle;\n    }\n}",
    "package VehicleSimulation {\n    enum VehicleState {\n        Off,\n        On,\n        Driving\n    }\n\n    state machine VehicleStateMachine {\n        state Off: VehicleState::Off;\n        state On: VehicleState::On;\n        state Driving: VehicleState::Driving;\n\n        transition from Off to On on startUp;\n        transition from On to Driving on beginDriving;\n        transition from Driving to On on endDriving;\n        transition from On to Off on shutdown;\n    }\n\n    block Vehicle {\n        attribute mass: Real;\n        attribute position: Real;\n        attribute velocity: Real;\n        attribute acceleration: Real;\n        attribute operationalState: VehicleState;\n\n        state behavior: VehicleStateMachine;\n    }\n\n    block Road {\n        attribute slope: Real;\n        attribute friction: Real;\n    }\n\n    block Snapshot {\n        attribute time: Real;\n        attribute vehiclePosition: Real;\n        attribute vehicleVelocity: Real;\n        attribute vehicleAcceleration: Real;\n        attribute vehicleOperationalState: VehicleState;\n        attribute roadSlope: Real;\n        attribute roadFriction: Real;\n    }\n\n    block VehicleSimulationSystem {\n        part vehicle: Vehicle;\n        part road: Road;\n        part snapshots: Snapshot[*];\n    }\n}",
    "part def Automobile {\n    part subsystemA: SubsystemA;\n    part subsystemB: SubsystemB;\n    constraint {\n        (not subsystemA :> ConfigA2) or (subsystemB :> ConfigB1)\n    }\n}\n\nabstract part def SubsystemA\npart def ConfigA1: SubsystemA {\n    part comp1: Component1;\n    part comp2: Component2;\n}\npart def ConfigA2: SubsystemA {\n    part comp2: Component2;\n    part comp3: Component3;\n}\n\nabstract part def SubsystemB\npart def ConfigB1: SubsystemB {\n    part comp4: Component4;\n    part comp5: Component5;\n}\npart def ConfigB2: SubsystemB {\n    part comp5: Component5;\n    part comp6: Component6;\n}\n\npart def Component1\npart def Component2\npart def Component3\npart def Component4\npart def Component5\npart def Component6\n\nconfiguration ConfigurationA {\n    Automobile auto {\n        subsystemA: ConfigA1;\n        subsystemB: ConfigB1;\n    }\n}\n\nconfiguration ConfigurationB {\n    Automobile auto {\n        subsystemA: ConfigA2;\n        subsystemB: ConfigB1;\n    }\n}",
    "interface def VehicleInterface;\n\nabstract block Part;\n\nblock Part1 extends Part;\nblock Part2 extends Part;\nblock Part3 extends Part {\n   port p1 : VehicleInterface;\n}\nblock Part4 extends Part;\nabstract block Part5 extends Part {\n   port p2 : VehicleInterface;\n}\nblock Part5Variant1 extends Part5;\nblock Part5Variant2 extends Part5;\nblock Part6 extends Part;\n\nblock Subsystem {\n   port subsystemPort : VehicleInterface;\n   part components : Part[0..*];\n}\n\nblock SubsystemA extends Subsystem;\nblock SubsystemB extends Subsystem;\n\nblock VehicleConfigA {\n   part subA : SubsystemA;\n   part subB : SubsystemB;\n   connector connectAB: subA.subsystemPort <-> subB.subsystemPort;\n}\n\nblock VehicleConfigB {\n   part subA : SubsystemA;\n   part subB : SubsystemB;\n   connector connectAB: subA.subsystemPort <-> subB.subsystemPort;\n}",
    "package VehicleConfiguration {\n  enum PerformanceRequirement {\n    high;\n    standard;\n  }\n\n  part def Vehicle {\n    attribute performanceReq: PerformanceRequirement;\n    part engine: Engine;\n    part transmission: Transmission;\n    part wheels: Wheel;\n  }\n\n  abstract part def Engine {\n    attribute cylinderCount: Integer;\n  }\n\n  part def HighPerfEngine:> Engine {\n    cylinderCount = 6;\n  }\n\n  part def StandardEngine:> Engine {\n    cylinderCount = 4;\n  }\n\n  abstract part def Transmission {}\n\n  part def AutomaticTransmission:> Transmission {}\n\n  part def ManualTransmission:> Transmission {}\n\n  abstract part def Wheel {\n    attribute rimType: String;\n  }\n\n  part def WideRimWheel:> Wheel {\n    rimType = \"wide\";\n  }\n\n  part def NarrowRimWheel:> Wheel {\n    rimType = \"narrow\";\n  }\n\n  constraint HighPerfCompatibility for Vehicle {\n    (performanceReq = PerformanceRequirement::high) implies\n      (engine instanceof HighPerfEngine and\n       transmission instanceof AutomaticTransmission and\n       wheels instanceof WideRimWheel)\n  }\n\n  constraint StandardPerfCompatibility for Vehicle {\n    (performanceReq = PerformanceRequirement::standard) implies\n      (engine instanceof StandardEngine and\n       transmission instanceof ManualTransmission and\n       wheels instanceof NarrowRimWheel)\n  }\n}",
    "package AutomobileSystem {\n    requirement def AutomobileRequirements {\n        requirement MassGrade: \"Support definition and management of vehicles with different mass grades (e.g., 2000kg, 2500kg).\"\n        requirement MassCompliance: \"Ensure actual vehicle mass complies with maximum mass limitations.\"\n        requirement FuelStatus: \"Regulate fuel status requirements (fully fueled or empty) for mass compliance.\"\n        requirement PowertrainFunction: \"Provide power delivery via engine torque output connected to transmission.\"\n        requirement ReliabilityTracking: \"Track and fulfill reliability for performance and durability.\"\n    }\n\n    enum FuelState {\n        full,\n        empty\n    }\n\n    part def Vehicle {\n        attribute massGrade: Real [1];\n        attribute actualMass: Real [1];\n        attribute maxMass: Real [1];\n        attribute fuelState: FuelState [1];\n        \n        constraint MassLimit {\n            actualMass <= maxMass\n        }\n    }\n\n    part def Engine {\n        attribute outputTorque: Real [1];\n        port drive: DriveInterface [1];\n    }\n\n    part def Transmission {\n        port input: DriveInterface [1];\n    }\n\n    interface def DriveInterface {}\n\n    part def Powertrain {\n        part engine: Engine [1];\n        part transmission: Transmission [1];\n        \n        connector driveline: engine.drive -> transmission.input;\n    }\n\n    satisfy MassGradeSatisfaction {\n        satisfiedBy: Vehicle.massGrade;\n        requirement: AutomobileRequirements.MassGrade;\n    }\n\n    satisfy MassComplianceSatisfaction {\n        satisfiedBy: Vehicle.MassLimit;\n        requirement: AutomobileRequirements.MassCompliance;\n    }\n\n    satisfy FuelStatusSatisfaction {\n        satisfiedBy: Vehicle.fuelState;\n        requirement: AutomobileRequirements.FuelStatus;\n    }\n\n    satisfy PowertrainSatisfaction {\n        satisfiedBy: Powertrain.driveline;\n        requirement: AutomobileRequirements.PowertrainFunction;\n    }\n\n    satisfy ReliabilitySatisfaction {\n        satisfiedBy: Vehicle;\n        requirement: AutomobileRequirements.ReliabilityTracking;\n    }\n}",
    "package VehicleMassCompliance {\n  value type Mass {\n    unit = 'kg';\n  }\n\n  enum ComplianceStatus {\n    Compliant,\n    NonCompliant\n  }\n\n  block Vehicle {\n    attribute mass : Mass;\n  }\n\n  block WeighingEquipment {\n    operation measureMass(in vehicle : Vehicle) : Mass;\n  }\n\n  block TestOperator {\n    association equipment : WeighingEquipment;\n  }\n\n  block VehicleMassComplianceSystem {\n    part scale : WeighingEquipment;\n    part operator : TestOperator;\n    property maxPermissibleMass : Mass = 2500.0;\n\n    activity CheckVehicleCompliance(in vehicle : Vehicle) : ComplianceStatus {\n      action getMass : scale.measureMass(vehicle);\n      action evaluate : if getMass.result <= maxPermissibleMass\n        then ComplianceStatus::Compliant\n        else ComplianceStatus::NonCompliant;\n      result : evaluate.result;\n    }\n\n    activity BatchComplianceCheck(in vehicles : Vehicle[*]) : ComplianceStatus[*] {\n      action checkEach : for vehicle in vehicles {\n        do CheckVehicleCompliance(vehicle);\n      };\n      result : checkEach.results;\n    }\n  }\n}",
    "block Spigot;\nblock FaucetInlet;\nblock SpigotBank {\n   part hotOutlet : Spigot;\n   part coldOutlet : Spigot;\n}\nblock Faucet {\n   part hotInlet : FaucetInlet;\n   part coldInlet : FaucetInlet;\n}\nblock WaterSupplySystem {\n   part mainSupply : SpigotBank;\n   part usagePoints : Faucet[1..*];\n   connector hotWaterDelivery = mainSupply.hotOutlet -> usagePoints:*.hotInlet;\n   connector coldWaterDelivery = mainSupply.coldOutlet -> usagePoints:*.coldInlet;\n}",
    "package VehicleQualityAnalysisSystem {\n   import SystemsEngineering::*;\n\n   part Vehicle {\n      attribute totalMass: Real;\n      reference components: Component[*];\n   }\n\n   abstract part Component {\n      attribute mass: Real;\n   }\n\n   part Engine: Component;\n   part Transmission: Component;\n   part FrontAxleAssembly: Component;\n   part RearAxleAssembly: Component;\n\n   association VehicleComposition {\n      Vehicle.components: Component[*];\n      Component.vehicle: Vehicle[0..1];\n   }\n\n   action InputQualityData {\n      in target: Component;\n      in massValue: Real;\n   }\n\n   action CalculateTotalMass {\n      inout vehicle: Vehicle;\n   }\n\n   requirement QualityAnalysisRequirement {\n      attribute description: String;\n   }\n\n   requirement AnalysisUseCase {\n      attribute objective: String;\n   }\n\n   action DefineAnalysisRequirement {\n      in description: String;\n      out requirement: QualityAnalysisRequirement;\n   }\n\n   action DefineAnalysisUseCase {\n      in objective: String;\n      out useCase: AnalysisUseCase;\n   }\n\n   part AnalysisTask {\n      attribute goal: String;\n   }\n\n   part AnalysisPlan {\n      attribute tasks: AnalysisTask[*];\n   }\n\n   action GenerateAnalysisTasks {\n      in useCase: AnalysisUseCase;\n      out tasks: AnalysisTask[*];\n   }\n\n   action CreateAnalysisPlan {\n      in tasks: AnalysisTask[*];\n      out plan: AnalysisPlan;\n   }\n\n   action PerformQualityEvaluation {\n      in plan: AnalysisPlan;\n      out evaluationResult: String;\n   }\n\n   action TrackRequirements {\n      in requirement: QualityAnalysisRequirement;\n      in evaluationResult: String;\n   }\n\n   action OptimizeDesign {\n      in evaluationResult: String;\n      out recommendations: String;\n   }\n}",
    "package VehiclePowertrainConfiguration {\n    requirement \"Optimal powertrain solution\" {\n        requirementId = 'REQ1'\n        text = \"Provide optimal solutions for vehicle powertrain configuration focusing on engine type trade-off analysis\"\n    }\n    \n    requirement \"Engine modeling\" {\n        requirementId = 'REQ2'\n        text = \"Support modeling of various engine structures (e.g., four-cylinder, six-cylinder)\"\n    }\n    \n    requirement \"Component assembly\" {\n        requirementId = 'REQ3'\n        text = \"Automatically assemble related components: cylinders, pistons, connecting rods, crankshafts\"\n    }\n    \n    requirement \"Trade-off analysis\" {\n        requirementId = 'REQ4'\n        text = \"Perform multi-attribute trade-off analysis across power, mass, efficiency, reliability, cost\"\n    }\n    \n    requirement \"Optimal recommendation\" {\n        requirementId = 'REQ5'\n        text = \"Recommend optimal engine solution based on evaluation results\"\n    }\n    \n    requirement \"Decision transparency\" {\n        requirementId = 'REQ6'\n        text = \"Provide explanations for engine selection rationality ensuring transparency and traceability\"\n    }\n    \n    valueType Power: Real (unit: kW)\n    valueType Mass: Real (unit: kg)\n    valueType Efficiency: Real (unit: percentage)\n    valueType Reliability: Real (unit: MTBF)\n    valueType Cost: Real (unit: USD)\n    \n    part Cylinder\n    part Piston\n    part ConnectingRod\n    part Crankshaft\n    \n    block Engine {\n        part cylinders: Cylinder[4..12]\n        part pistons: Piston[4..12]\n        part rods: ConnectingRod[4..12]\n        part crankshaft: Crankshaft\n        \n        attribute power: Power\n        attribute mass: Mass\n        attribute efficiency: Efficiency\n        attribute reliability: Reliability\n        attribute cost: Cost\n    }\n    \n    block FourCylinderEngine: Engine {\n        part cylinders: Cylinder[4]\n        part pistons: Piston[4]\n        part rods: ConnectingRod[4]\n    }\n    \n    block SixCylinderEngine: Engine {\n        part cylinders: Cylinder[6]\n        part pistons: Piston[6]\n        part rods: ConnectingRod[6]\n    }\n    \n    constraintblock TradeOffAnalysis {\n        param power: Power\n        param mass: Mass\n        param efficiency: Efficiency\n        param reliability: Reliability\n        param cost: Cost\n        \n        constraint score = \n            (0.3 * normalize(power)) + \n            (0.2 * (1 - normalize(mass))) + \n            (0.2 * normalize(efficiency)) + \n            (0.2 * normalize(reliability)) + \n            (0.1 * (1 - normalize(cost)))\n    }\n    \n    block VehiclePowertrainConfigurationSystem {\n        part candidateEngines: Engine[*]\n        \n        attribute optimalEngine: Engine\n        attribute selectionRationale: String\n        \n        constraint evaluation: TradeOffAnalysis {\n            power = candidateEngines.power,\n            mass = candidateEngines.mass,\n            efficiency = candidateEngines.efficiency,\n            reliability = candidateEngines.reliability,\n            cost = candidateEngines.cost\n        }\n        \n        action RecommendOptimalEngine {\n            output optimalEngine: Engine\n            output selectionRationale: String\n        }\n        \n        satisfy 'REQ1' with RecommendOptimalEngine\n        satisfy 'REQ2' with candidateEngines\n        satisfy 'REQ3' with Engine::parts\n        satisfy 'REQ4' with evaluation\n        satisfy 'REQ5' with RecommendOptimalEngine\n        satisfy 'REQ6' with selectionRationale\n    }\n}",
    "package FuelEconomySystem {\n    requirement UrbanFuelEconomy {\n        id = \"REQ-URBAN\"\n        text = \"Under urban driving conditions, the vehicle’s range per gallon must not be less than 25 miles.\"\n    }\n\n    requirement HighwayFuelEconomy {\n        id = \"REQ-HIGHWAY\"\n        text = \"Under highway conditions, the vehicle’s range per gallon must not be less than 30 miles.\"\n    }\n\n    requirement FuelEconomyUnit {\n        id = \"REQ-UNIT\"\n        text = \"Fuel economy is measured in miles per gallon based on the US customary gallon (231 cubic inches).\"\n    }\n\n    requirement TestCondition {\n        id = \"REQ-TEST\"\n        text = \"Fuel economy tests are conducted with the vehicle assuming an additional load of 1,000 pounds under standard urban and highway driving scenarios.\"\n    }\n\n    requirement ComplianceRequirement {\n        id = \"REQ-COMPLY\"\n        text = \"The measured fuel economy must meet the minimum requirements for urban and highway scenarios.\"\n    }\n\n    requirement SystemFunction {\n        id = \"REQ-SYS\"\n        text = \"The system models and analyzes key parameters such as vehicle powertrain, load, and operating conditions to ensure regulatory fuel economy targets are achieved.\"\n    }\n\n    part def Vehicle {\n        attribute fuelEconomy : Real[2];\n        constraint FuelEconomyConstraint {\n            urban : fuelEconomy[0] >= 25;\n            highway : fuelEconomy[1] >= 30;\n        }\n    }\n\n    constraint def LoadCondition {\n        parameter testLoad : Real = 1000;\n    }\n\n    scenario def UrbanDrivingScenario {\n        constraint LoadCondition;\n        constraint Vehicle.FuelEconomyConstraint.urban;\n    }\n\n    scenario def HighwayDrivingScenario {\n        constraint LoadCondition;\n        constraint Vehicle.FuelEconomyConstraint.highway;\n    }\n}",
    "value type PowerSegment {\n   startTime: Real;\n   endTime: Real;\n   powerValue: Real;\n}\n\nblock VehicleSimulationSystem {\n   value mass: Real;\n   value initialPosition: Real;\n   value initialVelocity: Real;\n   value powerSegments: PowerSegment[*];\n   value timeStep: Real;\n   \n   value accelerationSequence: Real[*] {\n      derive deriveAcceleration();\n   }\n   value velocitySequence: Real[*] {\n      derive deriveVelocity();\n   }\n   value positionSequence: Real[*] {\n      derive derivePosition();\n   }\n   \n   constraint deriveAcceleration {\n      \\[FORALL (i: Integer) | \n         0 <= i < accelerationSequence->size() =>\n         accelerationSequence[i] = \n            (powerSegments->select(seg | \n               seg.startTime <= i*timeStep AND i*timeStep < seg.endTime\n            )->first().powerValue) / mass\\]\n   }\n   \n   constraint deriveVelocity {\n      \\[velocitySequence[0] = initialVelocity;\n       FORALL (i: Integer) | \n          1 <= i < velocitySequence->size() =>\n          velocitySequence[i] = \n             velocitySequence[i-1] + accelerationSequence[i-1]*timeStep\\]\n   }\n   \n   constraint derivePosition {\n      \\[positionSequence[0] = initialPosition;\n       FORALL (i: Integer) | \n          1 <= i < positionSequence->size() =>\n          positionSequence[i] = \n             positionSequence[i-1] + velocitySequence[i-1]*timeStep\\]\n   }\n}",
    "package VehicleSystemModel {\n   part def Car {\n      attribute totalMass: Real = 2500;\n      part frontAxle: FrontAxleAssembly[1];\n      part rearAxle: RearAxleAssembly[1];\n   }\n\n   part def FrontAxleAssembly {\n      attribute mass: Real = 150;\n      part leftWheel: Wheel[1];\n      part rightWheel: Wheel[1];\n      part axle: FrontAxle[1];\n   }\n\n   part def RearAxleAssembly {\n      attribute mass: Real = 250;\n      part leftWheel: Wheel[1];\n      part rightWheel: Wheel[1];\n      part axle: RearAxle[1];\n   }\n\n   part def Wheel {}\n\n   part def FrontAxle {\n      attribute mass: Real;\n      attribute steeringAngle: Real;\n   }\n\n   part def RearAxle {\n      attribute mass: Real;\n   }\n}",
    "package VehicleSafetySecurity {\n  abstract def Feature;\n  def SafetyFeature :> Feature;\n  def SecurityFeature :> Feature;\n  def MandatorySafetyFeature :> SafetyFeature;\n  def OptionalSafetyFeature :> SafetyFeature;\n\n  def SeatBelt;\n  classification SeatBelt MandatorySafetyFeature;\n\n  def Bumper;\n  classification Bumper MandatorySafetyFeature;\n\n  def Airbag;\n  classification Airbag OptionalSafetyFeature;\n\n  def AntiLockBrakingSystem;\n  classification AntiLockBrakingSystem OptionalSafetyFeature;\n\n  def Alarm;\n  classification Alarm SecurityFeature;\n\n  def KeylessEntrySystem;\n  classification KeylessEntrySystem SecurityFeature;\n\n  def Vehicle {\n    part seatBelt: SeatBelt;\n    part airbag: Airbag;\n    part bumper: Bumper;\n    part abs: AntiLockBrakingSystem;\n    part alarm: Alarm;\n    part keylessEntry: KeylessEntrySystem;\n  }\n\n  def VehicleSafetySecurityManagementSystem {\n    part vehicle: Vehicle;\n    attribute visualizationForm: String;\n    attribute componentFilter: String;\n  }\n}",
    "package SystemModel {\n    part def ApplicationLayer {\n        reference usesServiceLayer : ServiceLayer;\n    }\n\n    part def ServiceLayer {\n        reference usesDataLayer : DataLayer;\n    }\n\n    part def DataLayer {}\n\n    part def LayeredSystem {\n        attribute x : Real;\n        attribute y : Real;\n        attribute z : Real;\n\n        part appLayer : ApplicationLayer;\n        part serviceLayer : ServiceLayer;\n        part dataLayer : DataLayer;\n\n        constraint {\n            z = f(x, y);\n        }\n\n        appLayer.usesServiceLayer = serviceLayer;\n        serviceLayer.usesDataLayer = dataLayer;\n    }\n}",
    "part def PowertrainSystem {\n    part engine : Engine;\n    function GenerateTorque {\n        output torque : Nm;\n    }\n    requirement TorqueRequirement {\n        text: \"Torque produced must be greater than zero newton-meters\";\n        constraint: GenerateTorque.torque > 0;\n    }\n    satisfy TorqueRequirement by GenerateTorque;\n    allocate GenerateTorque to engine;\n}\n\npart def Engine;\n\nvalue type Nm {\n    unit newtonMeter = SI::newton * SI::meter;\n}",
    "part def PowerSystem {\n   action generateTorque;\n   action providePower;\n   action transmitPower;\n   action outputPower;\n   part torqueGenerator: TorqueGenerator;\n   part powertrain: Powertrain;\n}\n\npart def TorqueGenerator {\n   action generateTorque;\n}\n\npart def Powertrain {\n   part engine: Engine;\n}\n\npart def Engine {\n   action generateTorque;\n}\n\nallocate TorqueGenerator::generateTorque to Engine::generateTorque;\n\nThis model:\n1. Defines the `PowerSystem` with required actions (generateTorque, providePower, transmitPower, outputPower)\n2. Includes logical `TorqueGenerator` component with torque generation capability\n3. Includes physical `Powertrain` containing an `Engine`\n4. Maps the logical torque generation function to the physical engine implementation via allocation\n5. Maintains traceability between logical and physical components through explicit action allocation\n\nThe allocation relationship ensures the logical function (torque generation) is properly implemented by the physical engine component within the powertrain, satisfying the requirement for effective correspondence between functional and physical domains.",
    "package VehicleSafetyAntiTheftCatalogue {\n    abstract part def VehicleComponent;\n\n    part def SafetyComponent :> VehicleComponent;\n    part def AntiTheftComponent :> VehicleComponent;\n    part def MandatorySafetyComponent :> SafetyComponent;\n\n    part FrontSeatBelts : MandatorySafetyComponent;\n    part Bumpers : MandatorySafetyComponent;\n    part DriversAirbag : SafetyComponent;\n    part AntiLockBrakingSystem : SafetyComponent;\n    part AlarmSystem : AntiTheftComponent;\n    part KeylessEntrySystem : AntiTheftComponent;\n\n    part def Vehicle {\n        part safety: SafetyComponent[*];\n        part security: AntiTheftComponent[*];\n        part mandatory: MandatorySafetyComponent[*];\n    }\n}",
    "flow item Fuel;\nflow item TemperatureData;\n\nblock FuelTank {\n   in returnFuel: Fuel;\n   out fuelSupply: Fuel;\n   part temperatureSensor: TemperatureSensor;\n   out tempData: TemperatureData;\n   connections {\n      temperatureSensor.tempOut -> tempData;\n   }\n}\n\nblock TemperatureSensor {\n   out tempOut: TemperatureData;\n}\n\nblock FuelPump {\n   in fuelIn: Fuel;\n   out pressurizedFuel: Fuel;\n}\n\nblock FuelConsumingUnit {\n   in fuelSupply: Fuel;\n   out unusedFuel: Fuel;\n}\n\nblock FuelMonitoringSystem {\n   in tempInput: TemperatureData;\n}\n\nblock FuelTankAssembly {\n   part tank: FuelTank;\n   part pump: FuelPump;\n   in returnLine: Fuel;\n   out fuelToPump: Fuel;\n   out pressurizedOutput: Fuel;\n   out tempOutput: TemperatureData;\n   connections {\n      returnLine -> tank.returnFuel;\n      tank.fuelSupply -> fuelToPump;\n      fuelToPump -> pump.fuelIn;\n      pump.pressurizedFuel -> pressurizedOutput;\n      tank.tempData -> tempOutput;\n   }\n}\n\nblock VehicleFuelSystem {\n   part tankAssembly: FuelTankAssembly;\n   part consumingUnits: FuelConsumingUnit[1..*];\n   part monitor: FuelMonitoringSystem;\n   connections {\n      tankAssembly.pressurizedOutput -> consumingUnits.fuelSupply;\n      consumingUnits.unusedFuel -> tankAssembly.returnLine;\n      tankAssembly.tempOutput -> monitor.tempInput;\n   }\n}",
    "package VehicleSystem {\n   part def Vehicle {\n      part interior : VehicleInterior;\n      part body : VehicleBody;\n      part chassis : Chassis;\n   }\n\n   part def VehicleInterior {\n      part seatBelt : SeatBelt[2];\n      part airbag : Airbag[0..1];\n      part antiTheftAlarm : AntiTheftAlarm[0..1];\n   }\n\n   part def VehicleBody {\n      part bumper : Bumper;\n      part keylessEntry : KeylessEntry;\n   }\n\n   part def Chassis {\n      part wheel : Wheel[2];\n      part antiLockBraking : AntiLockBraking[0..2];\n   }\n\n   part def SeatBelt { }\n   part def Airbag { }\n   part def AntiTheftAlarm { }\n   part def Bumper { }\n   part def KeylessEntry { }\n   part def Wheel { }\n   part def AntiLockBraking { }\n\n   requirement def SafetySecurityRequirement {\n      attribute id : string;\n      attribute description : string;\n      attribute category : ComplianceCategory;\n      attribute obligation : ObligationType;\n   }\n\n   enum ComplianceCategory {\n      safety;\n      security;\n   }\n\n   enum ObligationType {\n      mandatory;\n      optional;\n   }\n\n   SafetySecurityRequirement req1 {\n      id = \"REQ-1\";\n      description = \"Vehicle interior must have two seat belts\";\n      category = ComplianceCategory::safety;\n      obligation = ObligationType::mandatory;\n   }\n\n   SafetySecurityRequirement req2 {\n      id = \"REQ-2\";\n      description = \"Airbag should be installed in cockpit\";\n      category = ComplianceCategory::safety;\n      obligation = ObligationType::optional;\n   }\n\n   SafetySecurityRequirement req3 {\n      id = \"REQ-3\";\n      description = \"Anti-theft alarm should be installed\";\n      category = ComplianceCategory::security;\n      obligation = ObligationType::optional;\n   }\n\n   SafetySecurityRequirement req4 {\n      id = \"REQ-4\";\n      description = \"Vehicle body must have bumper\";\n      category = ComplianceCategory::safety;\n      obligation = ObligationType::mandatory;\n   }\n\n   SafetySecurityRequirement req5 {\n      id = \"REQ-5\";\n      description = \"Vehicle body must have keyless entry\";\n      category = ComplianceCategory::security;\n      obligation = ObligationType::mandatory;\n   }\n\n   SafetySecurityRequirement req6 {\n      id = \"REQ-6\";\n      description = \"Chassis must have two wheels\";\n      category = ComplianceCategory::safety;\n      obligation = ObligationType::mandatory;\n   }\n\n   SafetySecurityRequirement req7 {\n      id = \"REQ-7\";\n      description = \"Chassis should have two anti-lock braking systems\";\n      category = ComplianceCategory::safety;\n      obligation = ObligationType::optional;\n   }\n\n   satisfy seatBeltReq {\n      requirement = req1;\n      satisfiedBy = Vehicle.interior.seatBelt;\n   }\n\n   satisfy airbagReq {\n      requirement = req2;\n      satisfiedBy = Vehicle.interior.airbag;\n   }\n\n   satisfy alarmReq {\n      requirement = req3;\n      satisfiedBy = Vehicle.interior.antiTheftAlarm;\n   }\n\n   satisfy bumperReq {\n      requirement = req4;\n      satisfiedBy = Vehicle.body.bumper;\n   }\n\n   satisfy keylessEntryReq {\n      requirement = req5;\n      satisfiedBy = Vehicle.body.keylessEntry;\n   }\n\n   satisfy wheelReq {\n      requirement = req6;\n      satisfiedBy = Vehicle.chassis.wheel;\n   }\n\n   satisfy brakingReq {\n      requirement = req7;\n      satisfiedBy = Vehicle.chassis.antiLockBraking;\n   }\n}",
    "part def VehicleSafetyAndSecuritySystem {\n   part interior: Interior;\n   part bodyAssembly: BodyAssembly;\n}\n\npart def Interior {\n   part alarmSystem: AlarmSystem;\n   part seatBelts: SeatBelts;\n   part frontRowSeats: FrontRowSeats;\n   part driversAirbag: DriversAirbag;\n}\n\npart def BodyAssembly {\n   part vehicleBody: VehicleBody;\n   part bumper: Bumper;\n   part keylessEntrySystem: KeylessEntrySystem;\n}\n\npart def AlarmSystem;\npart def SeatBelts;\npart def FrontRowSeats;\npart def DriversAirbag;\npart def VehicleBody;\npart def Bumper;\npart def KeylessEntrySystem;",
    "enum SecurityClassificationEnum {\n   Unclassified;\n   Confidential;\n   Secret;\n}\n\nblock Component {\n   attribute securityClassification: SecurityClassificationEnum;\n}\n\nblock System {\n   part components: Component[*];\n}",
    "package AutomotiveSystem {\n    interface block CommInterface {}\n\n    interface block SensorDataInterface {}\n\n    block BusIF {\n        port busPort : inout BusCommInterface;\n        port devicePort : inout CommInterface;\n    }\n\n    block CANBus {\n        port port1 : inout BusCommInterface;\n        port port2 : inout BusCommInterface;\n    }\n\n    block ECU {\n        port busPort : inout CommInterface;\n        port sensorData : inout SensorDataInterface;\n    }\n\n    block VCU {\n        port busPort : inout CommInterface;\n        port sensorData : inout SensorDataInterface;\n    }\n\n    block VehicleSystem {\n        part vcu : VCU;\n        part ecu : ECU;\n        part canBus : CANBus;\n        part vcuBusIF : BusIF;\n        part ecuBusIF : BusIF;\n\n        connector vcuConnection : vcu.busPort <-> vcuBusIF.devicePort;\n        connector ecuConnection : ecu.busPort <-> ecuBusIF.devicePort;\n        connector vcuBusConnection : vcuBusIF.busPort <-> canBus.port1;\n        connector ecuBusConnection : ecuBusIF.busPort <-> canBus.port2;\n    }\n\n    interface block BusCommInterface {}\n}",
    "package BloodGlucoseMeterSystem {\n    requirement HighReliabilitySafety {\n        id = \"R1\"\n        text = \"Ensure high reliability and safety during use\"\n    }\n    \n    requirement BatteryStatusDetection {\n        id = \"R2\"\n        text = \"Automatically detect battery depletion or charging failure\"\n    }\n    \n    requirement UserAlerting {\n        id = \"R3\"\n        text = \"Promptly alert user to prevent measurement failures and treatment delays\"\n    }\n    \n    requirement PreventiveMeasures {\n        id = \"R4\"\n        text = \"Implement preventive measures for battery status\"\n    }\n    \n    requirement AlarmEmergencyResponse {\n        id = \"R5\"\n        text = \"Provide alarm and emergency response mechanisms for measurement abnormalities\"\n    }\n    \n    requirement RiskManagement {\n        id = \"R6\"\n        text = \"Establish management measures for key risk scenarios\"\n    }\n    \n    requirement ContinuousSupport {\n        id = \"R7\"\n        text = \"Ensure timely, continuous, and safe therapeutic support under all circumstances\"\n    }\n    \n    part BloodGlucoseMeter {\n        :> battery: PowerSystem;\n        :> measurement: GlucoseMeasurement;\n        :> alert: UserAlertSystem;\n        \n        satisfy R1, R2, R3, R4, R5, R6, R7\n    }\n    \n    part def PowerSystem {\n        attribute status: string;\n        \n        statemachine BatteryBehavior {\n            state Nominal;\n            state Depleted;\n            state ChargingFailure;\n            \n            transition from Nominal to Depleted on powerLoss;\n            transition from Nominal to ChargingFailure on chargeFailure;\n        }\n    }\n    \n    part def GlucoseMeasurement {\n        statemachine MeasurementBehavior {\n            state Operational;\n            state Abnormal;\n            \n            transition from Operational to Abnormal on measurementFault;\n        }\n    }\n    \n    part def UserAlertSystem {\n        operation notifyBatteryCritical();\n        operation triggerMeasurementAlarm();\n    }\n    \n    statemachine SystemBehavior {\n        state NormalOperation;\n        state BatteryAlert;\n        state MeasurementEmergency;\n        \n        transition from NormalOperation to BatteryAlert \n            on BloodGlucoseMeter.battery.status == 'Depleted' \n                or BloodGlucoseMeter.battery.status == 'ChargingFailure' \n            do BloodGlucoseMeter.alert.notifyBatteryCritical();\n        \n        transition from NormalOperation to MeasurementEmergency \n            on BloodGlucoseMeter.measurement.status == 'Abnormal' \n            do BloodGlucoseMeter.alert.triggerMeasurementAlarm();\n    }\n}",
    "package ScientificConstants {\n   package Mathematical {\n      const e: Real = 2.71828182845904523536;\n      const pi: Real = 3.14159265358979323846;\n   }\n\n   package Physical {\n      import SI::*;\n      const speedOfLight: Real = 299792458.0 * (m/s);\n      const fineStructureConstant: Real = 0.0072973525693;\n      const electronProtonMassRatio: Real = 0.000544617021487;\n   }\n\n   package ContextSpecific {\n      import SI::*;\n      const gravitationalAccelerationEarth: Real = 9.80665 * (m/s^2);\n      const amplifierGainModelX: Real = 10.0;\n   }\n}\n\npackage SI {\n   base unit m;\n   base unit s;\n   base unit kg;\n   base unit A;\n   base unit K;\n   base unit mol;\n   base unit cd;\n}",
    "block Tire {\n   manufacturer: String;\n   rimDiameter: Real;\n   width: Integer;\n}\n\npart michelinTire :> Tire {\n   manufacturer = \"Michelin\";\n   rimDiameter = 18.0;\n   width = 245;\n}",
    "package AutomotiveComponentModel {\n    part Vehicle {\n        attribute mass: Real[kg] = 1200;\n        attribute length: Real[m] = 4.82;\n        part leftFront: Wheel;\n        part rightFront: Wheel;\n    }\n\n    part Wheel {\n        attribute hubDiameter: Real[in] = 18;\n        attribute width: Real[mm] = 245;\n        part tire: Tire;\n        derived attribute outerDiameter: Real[in] = hubDiameter + 2 * tire.sidewallHeight;\n    }\n\n    part Tire {\n        attribute sidewallHeight: Real[in];\n    }\n}",
    "package PowertrainConfiguration {\n   abstract block Engine {}\n   block FourCylinderEngine :> Engine {}\n   block SixCylinderEngine :> Engine {}\n\n   abstract block Transmission {}\n   block ManualTransmission :> Transmission {}\n   block AutomaticTransmission :> Transmission {}\n\n   block Vehicle {\n      part engine: Engine[1];\n      part transmission: Transmission[1];\n      attribute isHighPerformance: Boolean;\n\n      constraint {\n         if isHighPerformance then\n            engine : SixCylinderEngine\n         else\n            engine : FourCylinderEngine\n         endif;\n         (engine : FourCylinderEngine and transmission : ManualTransmission) or\n         (engine : SixCylinderEngine and transmission : AutomaticTransmission);\n      }\n   }\n}",
    "package AutomotiveSystem {\n    part def Car {\n        property totalMass: Real = 1200 'kg';\n        property length: Real = 4.82 'm';\n        part wheelAssemblies: WheelAssembly[*];\n    }\n\n    part def WheelAssembly {\n        part wheel: Wheel;\n        part brakeDisc: BrakeDisc;\n        constraint brakeDiscFit {\n            brakeDisc.diameter < wheel.outerDiameter\n        }\n    }\n\n    part def Wheel {\n        part rim: Rim;\n        part tire: Tire;\n        property outerDiameter: Real {\n            rim.diameter * 25.4 + 2 * tire.height\n        }\n    }\n\n    part def Rim {\n        property diameter: Real = 18 'in';\n    }\n\n    part def Tire {\n        property width: Real = 245 'mm';\n        property height: Real = 45 'mm';\n        property defaultTreadDepth: Real = 6.0 'mm';\n        property minTreadDepth: Real = 3.5 'mm';\n        constraint treadDepthSafety {\n            defaultTreadDepth >= minTreadDepth\n        }\n    }\n\n    part def BrakeDisc {\n        property radius: Real = 95 'mm';\n        property diameter: Real {\n            2 * radius\n        }\n    }\n}",
    "package AutomotiveFuelSystem {\n    part def FuelTank {\n        port fuelOutlet: out Fuel;\n        port fuelInlet: in Fuel;\n    }\n\n    part def FuelPump {\n        port fuelIn: in Fuel;\n        port fuelOut: out Fuel;\n        port returnIn: in Fuel;\n        port returnOut: out Fuel;\n    }\n\n    part def FuelTankAssembly {\n        port fuelDelivery: out Fuel;\n        port fuelReturn: in Fuel;\n        part fuelPump: FuelPump;\n        part fuelTank: FuelTank;\n        connect fuelTank.fuelOutlet -> fuelPump.fuelIn;\n        connect fuelPump.fuelOut -> fuelDelivery;\n        connect fuelReturn -> fuelPump.returnIn;\n        connect fuelPump.returnOut -> fuelTank.fuelInlet;\n    }\n\n    system def AutomotiveFuelSystem {\n        port temperatureOut: out Temperature;\n        part fuelTankAssembly: FuelTankAssembly;\n        port fuelDelivery: out Fuel;\n        port fuelReturn: in Fuel;\n        connect fuelDelivery -> fuelTankAssembly.fuelDelivery;\n        connect fuelReturn -> fuelTankAssembly.fuelReturn;\n    }\n\n    requirement def MonitorFuelTemperature {\n        text: \"The system shall monitor and transmit fuel temperature information.\"\n    }\n\n    requirement def EfficientAndSafeCirculation {\n        text: \"Fuel shall circulate efficiently and safely among all components.\"\n    }\n\n    requirement def MeetVehicleRequirements {\n        text: \"The system shall meet the vehicle's overall requirements for fuel supply and return functions.\"\n    }\n\n    requirement def EnsureNormalSupply {\n        text: \"The system shall ensure normal fuel supply to the engine.\"\n    }\n}",
    "package PhysicalQuantitySystem {\n   part unitManager: UnitManager;\n\n   block UnitManager {\n      attribute baseQuantities: BaseQuantity[*];\n      operation importExtension();\n      operation ensureConsistency();\n      operation processData();\n      operation convertUnits();\n   }\n\n   enum BaseQuantity {\n      length,\n      mass,\n      time,\n      electricCurrent,\n      temperature,\n      amountOfSubstance,\n      luminousIntensity\n   }\n\n   value type Length {\n      unit: SIUnits::m;\n   }\n\n   value type Mass {\n      unit: SIUnits::kg;\n   }\n\n   value type Time {\n      unit: SIUnits::s;\n   }\n\n   value type ElectricCurrent {\n      unit: SIUnits::A;\n   }\n\n   value type Temperature {\n      unit: SIUnits::K;\n   }\n\n   value type AmountOfSubstance {\n      unit: SIUnits::mol;\n   }\n\n   value type LuminousIntensity {\n      unit: SIUnits::cd;\n   }\n\n   package SIUnits {\n      unit m;\n      unit kg;\n      unit s;\n      unit A;\n      unit K;\n      unit mol;\n      unit cd;\n   }\n}",
    "package UnitSystemLibrary {\n    unit system ISQ;\n    unit system USCustomaryUnits;\n\n    quantity kind Length;\n    quantity kind Mass;\n    quantity kind Time;\n    quantity kind Force = Mass * Length / (Time ^ 2);\n\n    unit m: Length in ISQ;\n    unit kg: Mass in ISQ;\n    unit s: Time in ISQ, USCustomaryUnits;\n    unit N: Force in ISQ = kg * m / (s ^ 2);\n\n    unit ft: Length in USCustomaryUnits = 0.3048 m;\n    unit lb: Mass in USCustomaryUnits = 0.45359237 kg;\n    unit lbf: Force in USCustomaryUnits = 4.4482216152605 N;\n}",
    "package HeadlampTiltVerification {\n   unit deg;\n\n   value type Angle {\n      value: Real;\n      unit: deg;\n   }\n\n   requirement TiltAngleRequirement {\n      id: \"REQ1\";\n      text: \"The tilt angle of the headlamp beam must be between 50 degrees and 80 degrees\";\n   }\n\n   constraint block TiltAngleConstraint {\n      parameter angle: Angle;\n      constraint: angle.value >= 50.0 and angle.value <= 80.0;\n   }\n\n   block HeadlampTiltVerificationSystem {\n      satisfy: TiltAngleRequirement {\n         with TiltAngleConstraint;\n      }\n   }\n}",
    "value type UnsignedInteger: Integer {\n    constraint { self >= 0 }\n}\n\nvalue type UnsignedFloat: Real {\n    constraint { self >= 0 }\n}\n\nvalue type DateTime: String\n\nenum ColorEnum {\n    red, yellow, green\n}\n\nenum StatusLevelEnum {\n    critical, warning, normal\n}\n\nvalue type StatusCondition {\n    level: StatusLevelEnum;\n    color: ColorEnum;\n    constraint {\n        (level == StatusLevelEnum::critical implies color == ColorEnum::red) and\n        (level == StatusLevelEnum::warning implies color == ColorEnum::yellow) and\n        (level == StatusLevelEnum::normal implies color == ColorEnum::green)\n    }\n}\n\nenum DiameterSizeEnum {\n    Small, Medium, Large\n}\n\nvalue type Diameter {\n    size: DiameterSizeEnum = DiameterSizeEnum::Small;\n    value: Real;\n    constraint {\n        (size == DiameterSizeEnum::Small implies value == 60.0) and\n        (size == DiameterSizeEnum::Medium implies value == 70.0) and\n        (size == DiameterSizeEnum::Large implies value == 80.0)\n    }\n}",
    "part def SparePart;\npart def Person;\npart def System {\n    spareParts: Bag<SparePart>;\n    integerList: List<Integer>;\n    stringSet: Set<String>;\n    personnel: OrderedSet<Person>;\n    nestedPersonnel: List<Set<Person>>;\n    realArray: Array<Real,4>;\n}",
    "block Position {\n    attribute x: Real;\n    attribute y: Real;\n    attribute z: Real;\n}\n\nblock Tire {\n    attribute manufacturer: String;\n    attribute rimDiameter: Real;\n    attribute width: Real;\n    attribute installationPosition: Position[0..1];\n}",
    "package TrajectoryRecording {\n    value type TimeValue {\n        unit = 's';\n        value: Real;\n    }\n\n    value type Length {\n        unit = 'm';\n        value: Real;\n    }\n\n    value type VelocityValue {\n        unit = 'm/s';\n        value: Real;\n    }\n\n    structure PositionVector {\n        x: Length;\n        y: Length;\n        z: Length;\n    }\n\n    structure VelocityVector {\n        x: VelocityValue;\n        y: VelocityValue;\n        z: VelocityValue;\n    }\n\n    block SamplingPoint {\n        time: TimeValue;\n        position: PositionVector;\n        velocity: VelocityVector;\n    }\n\n    block Trajectory {\n        liftoffUTC: String;\n        points: part SamplingPoint[*] ordered;\n    }\n}",
    "package MaterialScience {\n   unit g;\n   unit mol;\n   unit N;\n   unit mm;\n   unit N_per_mm2 = N/(mm^2);\n\n   quantityKind AtomicMass;\n   quantityKind TensileStrength;\n\n   UnitQuantity AtomicMassQuantity {\n      unit = g/mol;\n      quantityKind = AtomicMass;\n   }\n\n   UnitQuantity TensileStrengthQuantity {\n      unit = N_per_mm2;\n      quantityKind = TensileStrength;\n   }\n\n   part Material {\n      attribute atomicMass: Real[AtomicMass]?;\n   }\n\n   part Alloy {\n      attribute tensileStrength: Real[TensileStrength];\n\n      part usage Constituent for Material {\n         attribute massFraction: Real;\n      }\n\n      part constituents: Constituent[2..*];\n   }\n\n   part Iron: Material {\n      atomicMass = 55.845;\n   }\n\n   part Carbon: Material {\n      atomicMass = 12.011;\n   }\n\n   part Manganese: Material {\n      atomicMass = 54.938;\n   }\n\n   part Steel980: Alloy {\n      tensileStrength = 980.0;\n\n      part constituents: {\n         :Iron { massFraction = 0.98 },\n         :Carbon { massFraction = 0.01 },\n         :Manganese { massFraction = 0.01 }\n      }\n   }\n}",
    "enum PressureUnit {\n    MPa,\n    kPa,\n    GPa,\n    psi\n}\n\nvalue type TensileStrength {\n    value: Real;\n    unit: PressureUnit;\n}\n\npart def EngineeringMaterial {\n    attribute name: String;\n    attribute tensileStrength: TensileStrength[0..1];\n}\n\npart def Element:> EngineeringMaterial {\n    attribute atomicMass: Real;\n}\n\npart def Alloy:> EngineeringMaterial {\n    part usage constituents: Composition[1..*];\n}\n\npart def Composition {\n    attribute massFraction: Real;\n    ref constituent: Element;\n}\n\ninstance iron: Element {\n    name: \"Iron\";\n    atomicMass: 55.845;\n}\n\ninstance carbon: Element {\n    name: \"Carbon\";\n    atomicMass: 12.011;\n}\n\ninstance manganese: Element {\n    name: \"Manganese\";\n    atomicMass: 54.938;\n}\n\ninstance Steel_980: Alloy {\n    name: \"Steel_980\";\n    tensileStrength: {\n        value: 980.0;\n        unit: PressureUnit::MPa;\n    };\n    constituents: {\n        comp1: Composition {\n            massFraction: 0.98;\n            constituent: iron;\n        };\n        comp2: Composition {\n            massFraction: 0.01;\n            constituent: carbon;\n        };\n        comp3: Composition {\n            massFraction: 0.01;\n            constituent: manganese;\n        };\n    };\n}",
    "package PubSubSystem {\n  import Base;\n\n  type Topic: String;\n\n  type Message {\n    topic: Topic;\n    content: String;\n  }\n\n  interface PublisherInterface {\n    operation publish(topic: Topic, content: String);\n  }\n\n  interface SubscriberInterface {\n    operation subscribe(topic: Topic);\n    operation deliver(message: Message);\n  }\n\n  part Server {\n    port {\n      provided pubPort: PublisherInterface;\n      required subPort: SubscriberInterface [*];\n    }\n  }\n\n  part Publisher {\n    port {\n      required serverPort: PublisherInterface;\n    }\n  }\n\n  part Subscriber {\n    port {\n      provided serverPort: SubscriberInterface;\n    }\n  }\n\n  part sys: System {\n    part server: Server;\n    part publishers: Publisher [*];\n    part subscribers: Subscriber [*];\n\n    connector pubConnector: bind publishers.serverPort to server.pubPort;\n    connector subConnector: bind server.subPort to subscribers.serverPort;\n  }\n}",
    "package FuelSystem {\n    item Fuel {\n        temperature: Real;\n    }\n\n    block FuelTankAssembly {\n        port supply: out Fuel;\n        port return: in Fuel;\n    }\n\n    block Engine {\n        port fuelIn: in Fuel;\n        port fuelReturn: out Fuel;\n    }\n\n    block FuelLine {\n        port inlet: in Fuel;\n        port outlet: out Fuel;\n    }\n\n    block Vehicle {\n        part fuelTank: FuelTankAssembly;\n        part engine: Engine;\n        part supplyLine: FuelLine;\n        part returnLine: FuelLine;\n\n        connector supplyFlow: \n            from fuelTank.supply \n            to supplyLine.inlet;\n        connector engineSupply: \n            from supplyLine.outlet \n            to engine.fuelIn;\n        connector returnFlow: \n            from engine.fuelReturn \n            to returnLine.inlet;\n        connector tankReturn: \n            from returnLine.outlet \n            to fuelTank.return;\n    }\n}",
    "package PublishSubscribeSystem {\n    value type Topic {\n        name: String;\n    }\n\n    value type Message {\n        content: String;\n    }\n\n    interface ProducerInterface {\n        out publish(topic: Topic, message: Message);\n    }\n\n    interface ConsumerInterface {\n        out subscribe(topic: Topic);\n        in deliver(topic: Topic, message: Message);\n    }\n\n    block Producer {\n        port output: ProducerInterface;\n    }\n\n    block Consumer {\n        port input: ConsumerInterface;\n    }\n\n    block Server {\n        port producerInput: in ProducerInterface;\n        port consumerInput: in ConsumerInterface;\n        port consumerOutput: out ConsumerInterface[*];\n\n        part topicRegistry: TopicRegistry;\n        part messageDistributor: MessageDistributor;\n\n        connector routeSubscription: consumerInput.subscribe -> topicRegistry.register;\n        connector routePublication: producerInput.publish -> messageDistributor.process;\n        connector routeDistribution: messageDistributor.distribute -> consumerOutput.deliver;\n    }\n\n    block TopicRegistry {\n        in register(topic: Topic);\n    }\n\n    block MessageDistributor {\n        in process(topic: Topic, message: Message);\n        out distribute(topic: Topic, message: Message);\n    }\n\n    block PubSubSystem {\n        part producer: Producer;\n        part server: Server;\n        part consumer1: Consumer;\n        part consumer2: Consumer;\n\n        connector pubConn: producer.output -> server.producerInput;\n        connector subConn1: consumer1.input.subscribe -> server.consumerInput.subscribe;\n        connector subConn2: consumer2.input.subscribe -> server.consumerInput.subscribe;\n        connector delivConn1: server.consumerOutput -> consumer1.input.deliver;\n        connector delivConn2: server.consumerOutput -> consumer2.input.deliver;\n    }\n}",
    "package TransportationSystem {\n    part driver : Driver;\n    part passengers : Passenger[0..4];\n    part vehicle : Vehicle;\n    part environment : Environment;\n\n    block Driver {\n        action operateVehicle : OperateVehicle;\n        action refuel : Refuel;\n    }\n\n    block Passenger {}\n\n    block Vehicle {\n        attribute maxTankCapacity : Real;\n        attribute currentFuel : Real;\n        constraint fuelConstraint : currentFuel >= 0 and currentFuel <= maxTankCapacity;\n        constraint lowFuel : currentFuel < 0.1 * maxTankCapacity;\n    }\n\n    block Environment {}\n\n    action OperateVehicle {\n        in driver : Driver;\n        in vehicle : Vehicle;\n        in environment : Environment;\n    }\n\n    action Refuel {\n        in driver : Driver;\n        inout vehicle : Vehicle;\n        out newFuelLevel : Real;\n        constraint refuelComplete : newFuelLevel == vehicle.maxTankCapacity;\n    }\n\n    action EnterVehicle {\n        in user : Driver, Passenger;\n        inout vehicle : Vehicle;\n    }\n\n    action ExitVehicle {\n        in user : Driver, Passenger;\n        inout vehicle : Vehicle;\n    }\n\n    activity TransportationProcess {\n        start {\n            EnterVehicle(user = driver, vehicle = vehicle);\n            loop for passenger in passengers {\n                EnterVehicle(user = passenger, vehicle = vehicle);\n            }\n        }\n\n        node travel : OperateVehicle(driver = driver, vehicle = vehicle, environment = environment);\n\n        decision fuelCheck {\n            when vehicle.lowFuel {\n                Refuel(driver = driver, vehicle = vehicle);\n            }\n            else {}\n        }\n\n        end {\n            loop for passenger in passengers {\n                ExitVehicle(user = passenger, vehicle = vehicle);\n            }\n            ExitVehicle(user = driver, vehicle = vehicle);\n        }\n\n        edge start->travel;\n        edge travel->fuelCheck;\n        edge fuelCheck->travel [guard = not vehicle.lowFuel];\n        edge fuelCheck->end [guard = not vehicle.lowFuel];\n        edge fuelCheck->travel after Refuel;\n    }\n}",
    "package VehicleFuelSystem {\n    interface block FuelFlow {\n        fuelTemperature: Real;\n    }\n\n    block FuelTank {\n        out fuelOutlet: FuelFlow;\n        in fuelReturnInlet: FuelFlow;\n    }\n\n    block Engine {\n        in fuelInlet: FuelFlow;\n        out fuelReturnOutlet: FuelFlow;\n    }\n\n    block VehicleFuelManagementSystem {\n        part fuelTank: FuelTank;\n        part engine: Engine;\n\n        connector supplyFlow = fuelTank.fuelOutlet -> engine.fuelInlet;\n        connector returnFlow = engine.fuelReturnOutlet -> fuelTank.fuelReturnInlet;\n    }\n}",
    "package VehicleFuelSystem {\n    interface block FuelInterface {\n        out temperature: Real;\n        in out fuelFlow: Real;\n    }\n\n    block FuelTankAssembly {\n        port supply: FuelInterface;\n        port return: FuelInterface;\n    }\n\n    block Engine {\n        port supply: FuelInterface;\n        port return: FuelInterface;\n    }\n\n    part def VehicleFuelSystem {\n        part fuelTank: FuelTankAssembly;\n        part engine: Engine;\n\n        connection supplyLine: fuelTank.supply <-> engine.supply;\n        connection returnLine: engine.return <-> fuelTank.return;\n    }\n}",
    "package PhotoCaptureSystem {\n    item type SelectedScene;\n    item type FocusedImage;\n    item type FinalPhoto;\n\n    part def User;\n    part def PhotoCaptureSystem;\n\n    activity CapturePhotoProcess {\n        part user: User;\n        part system: PhotoCaptureSystem;\n\n        action selectScene {\n            output selectedScene: SelectedScene;\n        } in user\n\n        action autoFocus {\n            input selectedScene: SelectedScene;\n            output focusedImage: FocusedImage;\n        } in system\n\n        action capturePhoto {\n            input focusedImage: FocusedImage;\n            output finalPhoto: FinalPhoto;\n        } in system\n\n        edge selectScene.selectedScene -> autoFocus.selectedScene;\n        edge autoFocus.focusedImage -> capturePhoto.focusedImage;\n        output finalPhoto: FinalPhoto = capturePhoto.finalPhoto;\n    }\n}",
    "item def Scene;\nitem def Image;\nitem def Photograph;\naction def Focusing {\n    in sceneIn: Scene;\n    out focusedImage: Image;\n}\naction def Shooting {\n    in imageIn: Image;\n    out photoOut: Photograph;\n}\nactivity PhotographyWorkflow {\n    in scene: Scene;\n    out finalPhoto: Photograph;\n    action focusing: Focusing;\n    action shooting: Shooting;\n    edge scene -> focusing.sceneIn;\n    edge focusing.focusedImage -> shooting.imageIn;\n    edge shooting.photoOut -> finalPhoto;\n    edge focusing -> shooting;\n}\npart def PhotographySystem {\n    activity workflow: PhotographyWorkflow;\n}",
    "package PhotographyWorkflow {\n   type Scene;\n   type Image;\n   type Photograph;\n\n   part def PhotographySystem {\n      ownedBehavior: CaptureWorkflow;\n   }\n\n   activity CaptureWorkflow {\n      in selectedScene: Scene;\n      out finalPhotograph: Photograph;\n\n      action focus {\n         in scene: Scene;\n         out capturedImage: Image;\n      }\n\n      action shoot {\n         in image: Image;\n         out photograph: Photograph;\n      }\n\n      flow from selectedScene -> focus.scene;\n      flow from focus.capturedImage -> shoot.image;\n      flow from shoot.photograph -> finalPhotograph;\n   }\n}",
    "package AutomatedPhotography {\n    item ShootingScene;\n    item FocusedImage;\n    item Photograph;\n\n    activity FocusProcessing {\n        in scene : ShootingScene;\n        out image : FocusedImage;\n    }\n\n    activity ShootingOperation {\n        in image : FocusedImage;\n        out photo : Photograph;\n    }\n\n    activity AutomatedPhotographyProcess {\n        in scene : ShootingScene;\n        out photo : Photograph;\n\n        action focus : FocusProcessing;\n        action shoot : ShootingOperation;\n\n        flow {\n            scene -> focus.scene;\n            focus.image -> shoot.image;\n            shoot.photo -> photo;\n        }\n\n        sequence {\n            focus -> shoot;\n        }\n    }\n\n    part def PhotographySystem {\n        ownedBehavior: AutomatedPhotographyProcess;\n    }\n}",
    "package PhotographyWorkflow {\n    type Scene;\n    type Image;\n    type Picture;\n\n    activity PhotographyProcess {\n        in scene: Scene;\n        out photograph: Picture;\n\n        action Focus {\n            in target: Scene;\n            out result: Image;\n        }\n\n        action Shoot {\n            in source: Image;\n            out output: Picture;\n        }\n\n        sequence {\n            Focus -> Shoot;\n        }\n\n        object flow from scene to Focus.target;\n        object flow from Focus.result to Shoot.source;\n        object flow from Shoot.output to photograph;\n    }\n\n    part def PhotographyWorkflow {\n        behavior: PhotographyProcess;\n    }\n}",
    "package PhotographySystem {\n  enum FocusStatus {\n    CLEAR,\n    NOT_CLEAR\n  }\n\n  part def Scene {}\n\n  part def Photograph {}\n\n  part def CameraSystem {\n    operation def FocusScene (in scene: Scene) : FocusStatus;\n    operation def TakePhoto (in scene: Scene) : Photograph;\n\n    activity def PhotographyWorkflow {\n      in scene: Scene;\n      out photograph: Photograph;\n\n      action focus: {\n        in sceneIn: Scene;\n        out status: FocusStatus;\n      } = FocusScene;\n\n      action capture: {\n        in sceneIn: Scene;\n        out result: Photograph;\n      } = TakePhoto;\n\n      node initial: initial;\n      node final: final;\n\n      edge scene -> focus.sceneIn;\n      edge scene -> capture.sceneIn;\n      edge initial -> focus;\n      edge focus -> capture [guard (focus.status = FocusStatus::CLEAR)];\n      edge focus -> final [guard (focus.status <> FocusStatus::CLEAR)];\n      edge capture -> final;\n      edge capture.result -> photograph;\n    }\n  }\n}",
    "part def Scene\npart def Image\npart def Photograph\n\nactivity PhotographyWorkflow {\n   in scene: Scene\n   out finalPhoto: Photograph [0..1]\n\n   action selectScene\n   action focusAndGenerateImage {\n      in scene: Scene\n      out image: Image\n   }\n   action evaluateFocus {\n      in image: Image\n      out isWellFocused: Boolean\n   }\n   action shootPhoto {\n      in image: Image\n      out photo: Photograph\n   }\n\n   start\n   end\n   decision focusDecision\n\n   edge start -> selectScene\n   edge selectScene -> focusAndGenerateImage\n   edge focusAndGenerateImage -> evaluateFocus\n   edge evaluateFocus -> focusDecision\n   edge focusDecision -> shootPhoto [guard: 'isWellFocused']\n   edge focusDecision -> end [guard: 'not isWellFocused']\n   edge shootPhoto -> end\n\n   objectFlow scene -> focusAndGenerateImage.scene\n   objectFlow focusAndGenerateImage.image -> evaluateFocus.image\n   objectFlow focusAndGenerateImage.image -> shootPhoto.image\n   objectFlow evaluateFocus.isWellFocused -> focusDecision.decisionInput\n   objectFlow shootPhoto.photo -> finalPhoto\n}",
    "package PhotographyWorkflow {\n   type Scene;\n   type FocusedImage;\n   type Photograph;\n\n   action AcquireScene {\n      output scene: Scene;\n   }\n\n   action Focus {\n      input scene: Scene;\n      output focusedImage: FocusedImage;\n   }\n\n   action Shoot {\n      input focusedImage: FocusedImage;\n      output photograph: Photograph;\n   }\n\n   action Display {\n      input photograph: Photograph;\n   }\n\n   activity PhotographyWorkflowActivity {\n      part acquire: AcquireScene;\n      part focus: Focus;\n      part shoot: Shoot;\n      part display: Display;\n\n      edge acquire.scene -> focus.scene;\n      edge focus.focusedImage -> shoot.focusedImage;\n      edge shoot.photograph -> display.photograph;\n   }\n\n   block PhotographySystem {\n      operation takePhoto {\n         method: PhotographyWorkflowActivity;\n      }\n   }\n}",
    "part def AutomaticBrakingSystem {\n    activity BrakingControl {\n        action MonitorBrakePedal {\n            output brakePressure: Real;\n        }\n        action MonitorTraction {\n            output roadAdhesion: Real;\n        }\n        action AdjustBraking {\n            input pressure: Real;\n            input adhesion: Real;\n            output adjustedPressure: Real;\n            output modulationFrequency: Real;\n        }\n        edge MonitorBrakePedal.brakePressure -> AdjustBraking.pressure;\n        edge MonitorTraction.roadAdhesion -> AdjustBraking.adhesion;\n        edge MonitorBrakePedal -> MonitorTraction;\n        edge MonitorTraction -> AdjustBraking;\n        edge AdjustBraking -> MonitorBrakePedal;\n    }\n    state def OperationalState {\n        state Inactive;\n        state Active {\n            do BrakingControl;\n        }\n        transition from Inactive to Active on SystemActivation;\n    }\n    event SystemActivation;\n}",
    "package BatteryChargingControl {\n   part def BatteryChargingControlSystem {\n      attribute batteryLevel: Real;\n\n      state def ChargingStateMachine {\n         initial -> Charging: when [batteryLevel < 100];\n         initial -> Terminated: when [batteryLevel >= 100];\n         state Charging {\n            transition to Terminated: when [batteryLevel >= 100];\n         }\n         state Terminated {\n            transition to Charging: when [batteryLevel < 100];\n         }\n      }\n\n      requirement req1: Requirement {\n         id: 'R1'\n         text: \"Monitor current battery level in real time\"\n      }\n      requirement req2: Requirement {\n         id: 'R2'\n         text: \"Automatically supply charge when battery level < 100%\"\n      }\n      requirement req3: Requirement {\n         id: 'R3'\n         text: \"Automatically terminate charging when battery level >= 100%\"\n      }\n      requirement req4: Requirement {\n         id: 'R4'\n         text: \"Operate without manual intervention\"\n      }\n\n      satisfy req1\n      satisfy req2\n      satisfy req3\n      satisfy req4\n   }\n}",
    "package BatteryChargingSystem {\n    part def ChargingController {\n        attribute batteryLevel: Real; // Represents percentage\n\n        state behavior: state machine {\n            initial: state Idle;\n            state Idle;\n            state Charging {\n                do: monitorAndReplenish();\n            };\n            state FullyCharged;\n\n            transition t1: Idle -> Charging on chargeInitiated;\n            transition t2: Charging -> FullyCharged when batteryLevel >= 100;\n        }\n\n        event chargeInitiated;\n        activity monitorAndReplenish() {\n            action: {\n                if batteryLevel < 100 {\n                    replenishBattery();\n                }\n            }\n        }\n        activity replenishBattery();\n    }\n}",
    "package CameraSystem {\n   part def Camera {\n      attribute photos : sequence(Photo);\n      part autofocus : AutofocusSubsystem;\n      part imaging : ImagingSubsystem;\n      \n      action def CapturePhoto {\n         input scene : Scene;\n         output result : Photo;\n         step focus : autofocus->focus(scene);\n         step capture : imaging->capture(focus->focusedImage);\n         step save : this->savePhoto(capture->capturedPhoto);\n         order focus before capture before save;\n      }\n      \n      action def savePhoto {\n         input photo : Photo;\n         attribute newPhotos : sequence(Photo) = photos->append(photo);\n      }\n   }\n   \n   part def AutofocusSubsystem {\n      action def focus {\n         input scene : Scene;\n         output focusedImage : Image;\n      }\n   }\n   \n   part def ImagingSubsystem {\n      action def capture {\n         input image : Image;\n         output capturedPhoto : Photo;\n      }\n   }\n   \n   item def Photo;\n   item def Image;\n   item def Scene;\n}",
    "package DigitalCamera {\n   part def Viewfinder;\n   part def AutoFocus;\n   part def ImagingModule;\n\n   block DigitalCamera {\n      part viewfinder: Viewfinder;\n      part autoFocus: AutoFocus;\n      part imagingModule: ImagingModule;\n\n      activity ShootingProcess {\n         input selectedScene: Scene;\n         action focus = autoFocus.focusOn(selectedScene);\n         action capture = imagingModule.capture();\n         edge selectedScene -> focus.target;\n         edge focus -> capture;\n      }\n   }\n\n   requirement AutomatedShooting {\n      id: 'REQ-1';\n      text: \"The system shall implement the shooting process enabling users to complete viewfinding, focusing, and imaging with a single operation.\";\n   }\n   requirement SceneSelection {\n      id: 'REQ-2';\n      text: \"Users only need to select the shooting scene.\";\n   }\n   requirement AutoFocusing {\n      id: 'REQ-3';\n      text: \"The camera shall automatically focus on the selected scene.\";\n   }\n   requirement ImageCapture {\n      id: 'REQ-4';\n      text: \"The imaging module shall capture and produce the final photo.\";\n   }\n   requirement FullAutomation {\n      id: 'REQ-5';\n      text: \"The entire shooting process shall be fully automated without manual focus or imaging initiation.\";\n   }\n   requirement Collaboration {\n      id: 'REQ-6';\n      text: \"All functional modules shall collaborate to complete shooting and image acquisition.\";\n   }\n   requirement UserExperience {\n      id: 'REQ-7';\n      text: \"The system shall ensure an efficient and convenient shooting experience.\";\n   }\n   requirement PhotoQuality {\n      id: 'REQ-8';\n      text: \"The system shall output high-quality photos.\";\n   }\n\n   satisfy REQ-1 by DigitalCamera::ShootingProcess;\n   satisfy REQ-2 by DigitalCamera.viewfinder;\n   satisfy REQ-3 by DigitalCamera.autoFocus;\n   satisfy REQ-4 by DigitalCamera.imagingModule;\n   satisfy REQ-5 by DigitalCamera::ShootingProcess;\n   satisfy REQ-6 by DigitalCamera;\n   satisfy REQ-7 by DigitalCamera::ShootingProcess;\n   satisfy REQ-8 by DigitalCamera.imagingModule;\n}",
    "package VehicleSimulation {\n    part def Vehicle {\n        attribute mass: Real;\n        attribute initialPosition: Real;\n        attribute initialVelocity: Real;\n        attribute timeStep: Real;\n        attribute powerSequence: Sequence<Real>;\n        attribute trajectory: Sequence<Real>;\n\n        operation runSimulation() {\n            var currentPosition: Real = initialPosition;\n            var currentVelocity: Real = initialVelocity;\n            trajectory = Sequence{currentPosition};\n            \n            for power in powerSequence {\n                var newVelocity: Real;\n                if currentVelocity == 0.0 {\n                    if power > 0.0 {\n                        newVelocity = (2 * power * timeStep / mass).sqrt();\n                    } else if power < 0.0 {\n                        newVelocity = -(2 * -power * timeStep / mass).sqrt();\n                    } else {\n                        newVelocity = 0.0;\n                    }\n                } else {\n                    var currentKE: Real = 0.5 * mass * currentVelocity^2;\n                    var newKE: Real = currentKE + power * timeStep;\n                    if newKE <= 0.0 {\n                        newVelocity = 0.0;\n                    } else {\n                        var sign: Integer = currentVelocity > 0.0 ? 1 : -1;\n                        newVelocity = sign * (2 * newKE / mass).sqrt();\n                    }\n                }\n                \n                var newPosition: Real = currentPosition + currentVelocity * timeStep;\n                trajectory = trajectory->append(newPosition);\n                currentPosition = newPosition;\n                currentVelocity = newVelocity;\n            }\n        }\n    }\n}",
    "package CameraSystem {\n    part def CameraSystem {\n        activity def ShootingWorkflow {\n            action def Focus {\n                in scene : Scene;\n                out focusedImage : Image;\n            }\n            action def Capture {\n                in image : Image;\n                out photo : Photo;\n            }\n            action def Display {\n                in photo : Photo;\n            }\n            sequence {\n                Focus -> Capture: Focus.focusedImage -> Capture.image;\n                Capture -> Display: Capture.photo -> Display.photo;\n            }\n        }\n    }\n    item def Scene;\n    item def Image;\n    item def Photo;\n}",
    "package CameraSystem {\n    value type Scene;\n    value type Image;\n    value type Picture;\n\n    block ViewPort;\n    block FocusModule {\n        operation focus(in scene: Scene) : Image;\n    }\n    block CaptureModule {\n        operation capture(in image: Image) : Picture;\n    }\n    block DisplayPort {\n        operation display(in picture: Picture);\n    }\n\n    block CameraSystem {\n        parts: \n            viewPort: ViewPort;\n            focusModule: FocusModule;\n            captureModule: CaptureModule;\n            displayPort: DisplayPort;\n    }\n\n    activity CameraWorkflow {\n        input: selectedScene: Scene;\n        input: sys: CameraSystem;\n\n        action focusAction = sys.focusModule.focus(selectedScene) -> [focusedImage: Image];\n        action captureAction = sys.captureModule.capture(focusAction.focusedImage) -> [photo: Picture];\n        action displayAction = sys.displayPort.display(captureAction.photo);\n    }\n}",
    "package SensorManagement {\n   enum SensorState {\n      ready;\n      updating;\n      idle;\n   }\n\n   part def Sensor {\n      value state: SensorState;\n      action update;\n   }\n\n   part def System {\n      part sensors: Sensor[*];\n      action monitorSensors {\n         do {\n            for sensor in sensors {\n               if sensor.state == SensorState::ready {\n                  sensor.update();\n               }\n            }\n         }\n      }\n   }\n}",
    "part def Vehicle {\n    state machine {\n        event vehicleStartSignal;\n        event vehiclePowerOnSignal;\n        event vehicleShutdownSignal;\n        \n        initial state off;\n        state starting;\n        state on;\n        \n        transition from off to starting on vehicleStartSignal;\n        transition from starting to on on vehiclePowerOnSignal;\n        transition from off to off on vehicleShutdownSignal;\n        transition from starting to off on vehicleShutdownSignal;\n        transition from on to off on vehicleShutdownSignal;\n    }\n}",
    "package VehicleStateManagement {\n    event VehicleStartSignal;\n    event VehicleOnSignal;\n    event VehicleOffSignal;\n\n    block VehicleStateManager {\n        state machine {\n            off: State;\n            starting: State;\n            on: State;\n\n            initial: off;\n\n            off -> starting on VehicleStartSignal;\n            starting -> on on VehicleOnSignal;\n            on -> off on VehicleOffSignal;\n        }\n    }\n}",
    "package VehiclePowerManagement {\n    signal vehicleStartCommand\n    signal vehicleStartedSignal\n    signal vehicleShutdownCommand\n\n    stateMachine PowerStateManagement {\n        state Off\n        state StartPhase\n        state PoweredOn {\n            do: selfDiagnosisAndPowerSupply\n        }\n        state ShuttingDown {\n            entry: performSafetyOperations\n        }\n\n        transition t1: Off -> StartPhase on vehicleStartCommand\n        transition t2: StartPhase -> PoweredOn on vehicleStartedSignal\n        transition t3: PoweredOn -> ShuttingDown on vehicleShutdownCommand\n        transition t4: ShuttingDown -> Off\n    }\n\n    activity selfDiagnosisAndPowerSupply\n    activity performSafetyOperations\n}",
    "signal VehicleStartSignal;\nsignal VehicleStartedSignal;\nsignal VehicleShutdownSignal;\n\npart def VehicleSystem {\n    state machine VehicleStateMachine {\n        initial state Shutdown;\n        state StartUp;\n        state Running;\n        \n        transition from Shutdown to StartUp on VehicleStartSignal;\n        transition from StartUp to Running on VehicleStartedSignal;\n        transition from Running to Shutdown on VehicleShutdownSignal;\n    }\n}",
    "package PowerManagement {\n    event offSignal;\n    event startSignal;\n    event onSignal;\n\n    block Vehicle {\n        state machine OperatingState {\n            state Off {\n                initial\n            }\n            state Start;\n            state On;\n\n            transition from Off to Start on startSignal;\n            transition from Start to On on onSignal;\n            transition from On to Off on offSignal;\n        }\n    }\n\n    block HealthStateManager {\n        // Reserved for future health state management expansion\n    }\n}",
    "package VehicleHealthSystem {\n    part VehicleController {\n        operation receiveWarning(in message: String);\n    }\n\n    part VehicleHealthMonitoringSystem {\n        attribute maxAllowableTemperature: Real;\n        attribute currentTemperature: Real;\n        attribute status: String = \"normal\";\n        attribute nextMaintenanceTime: Time;\n        attribute maintenanceInterval: Duration;\n        reference controller: VehicleController;\n\n        state machine HealthStateMachine {\n            initial -> Normal;\n\n            state Normal {\n                transition on temperatureExceeded -> Degraded do {\n                    sendOverTemperatureWarning();\n                    setStatus(\"degraded\");\n                }\n                transition on maintenanceDue -> Maintenance do {\n                    setStatus(\"maintenance\");\n                }\n            }\n\n            state Degraded {\n                transition on temperatureSafe -> Normal do {\n                    setStatus(\"normal\");\n                }\n            }\n\n            state Maintenance {\n                internal transition on maintenanceCompleted do {\n                    updateNextMaintenanceCycle();\n                }\n                transition after 48h -> Normal do {\n                    setStatus(\"normal\");\n                }\n            }\n        }\n\n        action sendOverTemperatureWarning() {\n            controller.receiveWarning(\"OverTemperatureWarning\");\n        }\n\n        action setStatus(in newStatus: String) {\n            status = newStatus;\n        }\n\n        action updateNextMaintenanceCycle() {\n            nextMaintenanceTime = nextMaintenanceTime + maintenanceInterval;\n        }\n    }\n}",
    "package ServerSystem {\n    interface RequestPort {\n        in start;\n        in request;\n    }\n\n    part def Server {\n        port request : RequestPort;\n        behavior :> ServerBehavior;\n    }\n\n    state machine ServerBehavior {\n        state off;\n        state waiting;\n        state response;\n\n        initial: -> off;\n\n        transition from off to waiting on request.start;\n        transition from waiting to response on request.request;\n        transition from response to waiting after 5 min;\n        transition from * to off at('11:59:00');\n    }\n}",
    "package VehicleStartStopSystem {\n    signal startSignal;\n    signal powerOnSignal;\n    signal stopSignal;\n    signal startSignalToController;\n\n    block VehicleControlSystem {\n        part controller: Controller;\n        value brakePedalDepressed: Boolean = false;\n\n        operation selfCheck();\n        operation supplyPower();\n        operation applyParkingBrake();\n\n        state machine {\n            initial: off;\n            state off;\n            state startProcess;\n            state operating {\n                entry / {\n                    selfCheck();\n                }\n                do / {\n                    supplyPower();\n                }\n                exit / {\n                    applyParkingBrake();\n                }\n            }\n\n            transition from off to startProcess on startSignal;\n            transition from startProcess to operating on powerOnSignal [brakePedalDepressed] / {\n                send startSignalToController to controller;\n            };\n            transition from operating to off on stopSignal;\n        }\n    }\n\n    block Controller {\n        reception startSignalToController;\n    }\n}",
    "part def VehicleControlSystem {\n    state machine {\n        initial state Off;\n        state Starting;\n        state Started;\n\n        Off -> Starting on vehicleStartSignal;\n        Starting -> Started on vehicleOnSignal [brakePedalDepressed] {\n            effect: startControlSignal.send()\n        };\n        Started -> Off on shutdownSignal [parkingBrakeApplied];\n\n        state Started {\n            do: {\n                performSelfCheck();\n                supplyPower();\n            }\n        }\n    }\n}",
    "package CruiseControlSystem {\n    part def Vehicle {\n        part driver: Driver;\n        part cruiseController: CruiseController;\n        part speedometer: Speedometer;\n        part engine: Engine;\n        \n        connector driverToController: driver.setSpeedCommand -> cruiseController.setSpeedIn;\n        connector controllerToSpeedometer: cruiseController.speedRequest -> speedometer.speedRequestIn;\n        connector speedometerToController: speedometer.actualSpeedOut -> cruiseController.actualSpeedIn;\n        connector controllerToEngine: cruiseController.fuelCommand -> engine.fuelCommandIn;\n    }\n    \n    part def Driver {\n        out port setSpeedCommand: SetSpeedCommand;\n    }\n    \n    part def CruiseController {\n        in port setSpeedIn: SetSpeedCommand;\n        out port speedRequest: SpeedRequest;\n        in port actualSpeedIn: ActualSpeed;\n        out port fuelCommand: FuelControlCommand;\n    }\n    \n    part def Speedometer {\n        in port speedRequestIn: SpeedRequest;\n        out port actualSpeedOut: ActualSpeed;\n    }\n    \n    part def Engine {\n        in port fuelCommandIn: FuelControlCommand;\n    }\n    \n    event SetSpeedCommand {\n        attribute targetSpeed: Real;\n    }\n    \n    event SpeedRequest {}\n    \n    event ActualSpeed {\n        attribute currentSpeed: Real;\n    }\n    \n    event FuelControlCommand {\n        attribute throttleLevel: Real;\n    }\n    \n    interaction CruiseControlInteraction {\n        occurrence driverSendsSet: Driver::setSpeedCommand -> CruiseController::setSpeedIn;\n        occurrence controllerRequestsSpeed: CruiseController::speedRequest -> Speedometer::speedRequestIn;\n        occurrence speedometerSendsSpeed: Speedometer::actualSpeedOut -> CruiseController::actualSpeedIn;\n        occurrence controllerSendsCommand: CruiseController::fuelCommand -> Engine::fuelCommandIn;\n    }\n}",
    "package CruiseControlSystem {\n    signal SetSpeedCommand {\n        setSpeed: Real;\n    }\n\n    signal ThrottleControlCommand {\n        throttleValue: Real;\n    }\n\n    block Speedometer {\n        attribute currentSpeed: Real;\n    }\n\n    block EngineSystem {\n        input port throttleInput: ThrottleControlCommand;\n    }\n\n    block Driver {\n        output port setSpeedPort: SetSpeedCommand;\n    }\n\n    block CruiseController {\n        input port setSpeedIn: SetSpeedCommand;\n        output port throttleOut: ThrottleControlCommand;\n        reference speedometerRef: Speedometer;\n\n        operation computeThrottle(setSpeed: Real, currentSpeed: Real): Real {\n            // Calculates throttle based on speed difference\n        }\n    }\n\n    block Vehicle {\n        part driver: Driver;\n        part cruiseController: CruiseController;\n        part speedometer: Speedometer;\n        part engine: EngineSystem;\n\n        connector setSpeedConn: driver.setSpeedPort -> cruiseController.setSpeedIn;\n        connector throttleConn: cruiseController.throttleOut -> engine.throttleInput;\n        association speedometerAssoc: cruiseController.speedometerRef -> speedometer;\n    }\n}",
    "package CruiseControlSystem {\n    block Driver {\n        operation setSpeed(speed: Real);\n    }\n\n    block CruiseController {\n        operation getCurrentSpeed(): Real;\n        operation calculateThrottle(setSpeed: Real, currentSpeed: Real): Real;\n    }\n\n    block SpeedSensor {\n        operation readSpeed(): Real;\n    }\n\n    block Engine {\n        operation adjustThrottle(command: Real);\n    }\n\n    block AutomotiveCruiseControl {\n        part driver: Driver;\n        part controller: CruiseController;\n        part sensor: SpeedSensor;\n        part engine: Engine;\n\n        interaction CruiseControlInteraction {\n            participant d: Driver;\n            participant cc: CruiseController;\n            participant ss: SpeedSensor;\n            participant e: Engine;\n\n            occurrence setSpeedOccurrence: d -> cc setSpeed(setSpeedValue);\n            occurrence getSpeedOccurrence: cc -> ss getCurrentSpeed();\n            occurrence returnSpeedOccurrence: ss -> cc currentSpeedValue;\n            occurrence calculateThrottleOccurrence: cc calculateThrottle(setSpeedValue, currentSpeedValue);\n            occurrence throttleCommandOccurrence: cc -> e adjustThrottle(throttleCommand);\n        }\n    }\n}",
    "part def CruiseControlSystem {\n    part driver : Driver;\n    part cruiseController : CruiseController;\n    part speedometer : Speedometer;\n    part engine : Engine;\n\n    connector driver.speedSetting to cruiseController.speedCommand;\n    connector speedometer.currentSpeed to cruiseController.speedFeedback;\n    connector cruiseController.throttleSignal to engine.throttleControl;\n}\n\npart def Driver {\n    port speedSetting : out Real;\n}\n\npart def CruiseController {\n    port speedCommand : in Real;\n    port speedFeedback : in Real;\n    port throttleSignal : out Real;\n}\n\npart def Speedometer {\n    port currentSpeed : out Real;\n}\n\npart def Engine {\n    port throttleControl : in Real;\n}\n\nactivity CruiseControllerBehavior {\n    in desiredSpeed : Real;\n    in actualSpeed : Real;\n    out throttleCommand : Real;\n\n    action CalculateThrottle {\n        in target : Real;\n        in current : Real;\n        out throttle : Real;\n        opaqueAction {\n            language = \"text/plain\"\n            body = \"throttle = ...\" // Throttle calculation logic\n        }\n    }\n\n    edge desiredSpeed -> CalculateThrottle.target;\n    edge actualSpeed -> CalculateThrottle.current;\n    edge CalculateThrottle.throttle -> throttleCommand;\n}\n\nbind CruiseController {\n    behavior : CruiseControllerBehavior;\n    bind speedCommand to behavior.desiredSpeed;\n    bind speedFeedback to behavior.actualSpeed;\n    bind throttleSignal to behavior.throttleCommand;\n}",
    "package AutomotiveCruiseControl {\n    type SpeedValue: Real;\n    type FuelCommand: Real;\n\n    block CruiseControlInterface {\n        out port setSpeed: SpeedValue;\n    }\n\n    block SpeedSensor {\n        out port detectedSpeed: SpeedValue;\n    }\n\n    block CruiseController {\n        in port targetSpeed: SpeedValue;\n        in port currentSpeed: SpeedValue;\n        out port fuelAdjustment: FuelCommand;\n    }\n\n    block Engine {\n        in port throttleCommand: FuelCommand;\n    }\n\n    block AutomotiveCruiseControlSystem {\n        part controlInterface: CruiseControlInterface;\n        part speedSensor: SpeedSensor;\n        part cruiseController: CruiseController;\n        part engine: Engine;\n\n        connector setSpeedLink: controlInterface.setSpeed -> cruiseController.targetSpeed;\n        connector speedFeedback: speedSensor.detectedSpeed -> cruiseController.currentSpeed;\n        connector fuelControl: cruiseController.fuelAdjustment -> engine.throttleCommand;\n    }\n}",
    "signal SetSpeed {\n    value: Real;\n}\n\nsignal SpeedReading {\n    value: Real;\n}\n\nsignal FuelControl {\n    command: Real;\n}\n\nsignal EngineCommand {\n    throttle: Real;\n}\n\nblock Driver {\n    port setSpeedPort: out SetSpeed;\n}\n\nblock CruiseController {\n    port setSpeedPort: in SetSpeed;\n    port speedReadingPort: in SpeedReading;\n    port fuelControlPort: out FuelControl;\n}\n\nblock SpeedSensor {\n    port speedOutputPort: out SpeedReading;\n}\n\nblock EngineController {\n    port fuelControlPort: in FuelControl;\n    port engineCommandPort: out EngineCommand;\n}\n\nblock Engine {\n    port commandPort: in EngineCommand;\n}\n\nblock CruiseControlSystem {\n    part driver: Driver;\n    part cruiseController: CruiseController;\n    part speedSensor: SpeedSensor;\n    part engineController: EngineController;\n    part engine: Engine;\n    \n    connector setSpeedConn: driver.setSpeedPort -> cruiseController.setSpeedPort;\n    connector speedConn: speedSensor.speedOutputPort -> cruiseController.speedReadingPort;\n    connector fuelControlConn: cruiseController.fuelControlPort -> engineController.fuelControlPort;\n    connector engineCommandConn: engineController.engineCommandPort -> engine.commandPort;\n}",
    "class Vehicle {\n   part lifecycle : Lifecycle;\n}\n\nclass Lifecycle {\n   part events : LifecycleEvent[*] ordered;\n}\n\nabstract class LifecycleEvent {\n   attribute eventDate : Date;\n}\n\nclass AssemblyEvent :> LifecycleEvent;\n\nclass DeliveryEvent :> LifecycleEvent;\n\nclass OwnershipTransferEvent :> LifecycleEvent {\n   attribute owner : Owner;\n}\n\nclass DrivingEvent :> LifecycleEvent {\n   attribute driver : Driver;\n}\n\nclass ScrappingEvent :> LifecycleEvent;\n\nclass Owner {\n   attribute name : String;\n}\n\nclass Driver {\n   attribute name : String;\n}",
    "block Driver;\n\nblock Engine;\n\npart def OperationalStatus {\n    attribute gearSetting: String;\n    attribute acceleratorPedalPosition: Real;\n}\n\npart def Wheel {\n    attribute position: String;\n    attribute rotationSpeed: Real;\n}\n\nblock Vehicle {\n    attribute mass: Real;\n    attribute operationalStatus: OperationalStatus;\n    \n    part engine: Engine;\n    part wheels: Wheel[*];\n    \n    ref driver: Driver;\n}\n\npart def VehicleSnapshot {\n    attribute time: Real;\n    ref vehicle: Vehicle;\n    attribute vehicleOperationalStatus: OperationalStatus;\n    attribute leftFrontWheelSpeed: Real;\n    attribute rightFrontWheelSpeed: Real;\n}\n\ninstance driver_1: Driver;\n\ninstance vehicle_1: Vehicle {\n    mass: 1500.0;\n    operationalStatus: OperationalStatus {\n        gearSetting: \"P\";\n        acceleratorPedalPosition: 0.0;\n    };\n    parts: {\n        engine: Engine;\n        wheels: [\n            Wheel {position: \"left front\"; rotationSpeed: 0.0},\n            Wheel {position: \"right front\"; rotationSpeed: 0.0},\n            Wheel {position: \"left rear\"; rotationSpeed: 0.0},\n            Wheel {position: \"right rear\"; rotationSpeed: 0.0}\n        ];\n    };\n    references: {\n        driver: driver_1;\n    };\n}\n\ninstance snapshot_0: VehicleSnapshot {\n    time: 0.0;\n    vehicle: vehicle_1;\n    vehicleOperationalStatus: OperationalStatus {\n        gearSetting: \"P\";\n        acceleratorPedalPosition: 0.0;\n    };\n    leftFrontWheelSpeed: 0.0;\n    rightFrontWheelSpeed: 0.0;\n}\n\ninstance snapshot_1: VehicleSnapshot {\n    time: 5.0;\n    vehicle: vehicle_1;\n    vehicleOperationalStatus: OperationalStatus {\n        gearSetting: \"D\";\n        acceleratorPedalPosition: 30.0;\n    };\n    leftFrontWheelSpeed: 10.5;\n    rightFrontWheelSpeed: 10.3;\n}",
    "package CompositeSystemModel {\n    import Systems;\n\n    part def VehicleState {\n        attribute gearSetting: Integer;\n        attribute acceleratorPedalPosition: Real;\n    }\n\n    part def Vehicle {\n        attribute mass: Real [kg];\n        attribute state: VehicleState;\n    }\n\n    part def Engine { }\n    part def Driver { }\n\n    part def CompositeSystem {\n        part vehicles: Vehicle[1..*];\n        part engines: Engine[1..*];\n        part drivers: Driver[1..*];\n    }\n\n    instance mySystem: CompositeSystem;\n\n    instance Vehicle_1: Vehicle;\n    instance Engine_1: Engine;\n    instance Driver_1: Driver;\n\n    mySystem.vehicles += Vehicle_1;\n    mySystem.engines += Engine_1;\n    mySystem.drivers += Driver_1;\n\n    time def t0: Time;\n    time def t1: Time;\n\n    state def FullVehicleState for Vehicle {\n        attribute mass: Real;\n        attribute state: VehicleState;\n    }\n\n    instance initialState: FullVehicleState for Vehicle_1 {\n        mass = 2000;\n        state.gearSetting = 0;\n        state.acceleratorPedalPosition = 0.0;\n    } at t0;\n\n    instance nextState: FullVehicleState for Vehicle_1 {\n        mass = 1500;\n        state.gearSetting = 2;\n        state.acceleratorPedalPosition = 0.5;\n    } at t1;\n}",
    "package VehicleModel {\n    enum GearPosition {\n        neutral,\n        second\n    }\n\n    block Driver {\n    }\n\n    block Engine {\n    }\n\n    block Vehicle {\n        attribute mass: Real;\n        attribute gear: GearPosition;\n        attribute throttle: Real;\n        part engine: Engine;\n        reference driver: Driver;\n    }\n\n    instance Alice : Driver;\n    instance Bob : Driver;\n    instance myEngine : Engine;\n\n    instance initialVehicleState : Vehicle {\n        mass = 2000.0;\n        gear = GearPosition::neutral;\n        throttle = 0.0;\n        engine = myEngine;\n        driver = Alice;\n    }\n\n    instance secondVehicleState : Vehicle {\n        mass = 1500.0;\n        gear = GearPosition::second;\n        throttle = 0.5;\n        engine = myEngine;\n        driver = Bob;\n    }\n}",
    "package VehicleMassModel {\n   value type Mass real [1,1] {\n      unit kg\n   }\n\n   abstract block Component {\n      value property id : String;\n      value property ownMass : Mass;\n      derived value property totalMass : Mass;\n   }\n\n   block LeafComponent extends Component {\n      constraint {\n         totalMass = ownMass\n      }\n   }\n\n   block CompositeComponent extends Component {\n      part subcomponent : Component[0..*];\n\n      constraint {\n         totalMass = ownMass + subcomponent->collect(totalMass)->sum()\n      }\n   }\n\n   block Vehicle extends CompositeComponent {\n      part body : Body in subcomponent;\n      part engine : Engine in subcomponent;\n      part transmission : Transmission in subcomponent;\n   }\n\n   block Body extends LeafComponent;\n   block Engine extends LeafComponent;\n   block Transmission extends LeafComponent;\n}",
    "package VehicleMassManagement {\n  import ScalarValues::Real;\n  import ScalarValues::String;\n\n  block Component {\n    attribute mass: Real;\n    attribute serialNumber: String;\n    part subcomponent: Component[*];\n    operation totalMassWithThreshold(threshold: Real): Real {\n      = (if mass >= threshold then mass else 0.0) + \n        subcomponent->sum(s | s.totalMassWithThreshold(threshold))\n    }\n  }\n\n  block Engine: Component;\n  block Transmission: Component;\n\n  block Vehicle {\n    attribute VIN: String;\n    attribute mass: Real;\n    part engine: Engine[0..1];\n    part transmission: Transmission[0..1];\n    part otherComponent: Component[*];\n    ref allComponents: Component[*] = \n      (if engine <> null then set{engine} else set{}) + \n      (if transmission <> null then set{transmission} else set{}) + \n      otherComponent;\n    operation totalMass(threshold: Real=0.0): Real {\n      = mass + allComponents->sum(c | c.totalMassWithThreshold(threshold))\n    }\n  }\n}",
    "package MassAggregation {\n    block MassObject {\n        simpleMass: Real;\n        totalMass: Real;\n    }\n\n    block SimpleThing :> MassObject {\n        constraint {\n            totalMass = simpleMass;\n        }\n    }\n\n    block CompositeThing :> MassObject {\n        part subcomponents: MassObject [0..*];\n\n        constraint {\n            totalMass = simpleMass + (subcomponents.totalMass->sum());\n        }\n    }\n}",
    "package MassManagement {\n    unit kg;\n    quantity kind Mass;\n    value type Mass: Real<kg>;\n\n    part Component {\n        attribute basicMass: Mass;\n        reference subcomponents: Component[*] {\n            composite;\n        }\n\n        operation getTotalMass(minThreshold: Mass = null): Mass {\n            constraint {\n                if minThreshold == null then\n                    result = basicMass + (subcomponents->collect(c | c.getTotalMass(null))->sum()\n                else\n                    result = basicMass + (subcomponents->select(c | c.basicMass >= minThreshold)->collect(c | c.getTotalMass(null))->sum()\n                endif\n            }\n        }\n    }\n}",
    "package VehicleDynamics {\n    import SysML::*;\n\n    block VehicleDynamicsSystem {\n        part vehicle : Vehicle;\n        part conditions : OperatingConditions;\n        part state : VehicleState;\n\n        constraint PowerCalculation {\n            state.availablePower = state.wheelPower - \n                (0.5 * conditions.airDensity * vehicle.dragCoefficient * state.initialSpeed^3) - \n                (vehicle.frictionCoefficient * vehicle.mass * conditions.gravity * state.initialSpeed)\n        }\n\n        constraint AccelerationCalculation {\n            state.acceleration = state.availablePower / (vehicle.mass * state.initialSpeed)\n        }\n\n        constraint SpeedCalculation {\n            state.finalSpeed = state.initialSpeed + state.acceleration * state.time\n        }\n\n        constraint DisplacementCalculation {\n            state.displacement = (state.initialSpeed + state.finalSpeed) * state.time / 2\n        }\n    }\n\n    block Vehicle {\n        attribute mass: Real;\n        attribute dragCoefficient: Real;\n        attribute frictionCoefficient: Real;\n    }\n\n    block OperatingConditions {\n        attribute airDensity: Real;\n        attribute gravity: Real;\n    }\n\n    block VehicleState {\n        attribute initialSpeed: Real;\n        attribute time: Real;\n        attribute wheelPower: Real;\n        attribute availablePower: Real;\n        attribute acceleration: Real;\n        attribute finalSpeed: Real;\n        attribute displacement: Real;\n    }\n}",
    "value type Length real;\nvalue type Speed real;\nvalue type Acceleration real;\nvalue type Force real;\nvalue type Power real;\nvalue type Time real;\nvalue type Mass real;\nvalue type DragCoefficient real;\nvalue type RollingResistanceCoefficient real;\nvalue type Area real;\nvalue type Density real;\n\nblock Vehicle {\n   attribute mass: Mass;\n   attribute drag_coeff: DragCoefficient;\n   attribute roll_resist_coeff: RollingResistanceCoefficient;\n   attribute frontal_area: Area;\n   attribute air_density: Density;\n   attribute g: Acceleration = 9.81;\n\n   operation getDragForce(speed: Speed): Force {\n      body {\n         return 0.5 * drag_coeff * air_density * frontal_area * speed * speed;\n      }\n   }\n\n   operation getRollingResistanceForce(): Force {\n      body {\n         return roll_resist_coeff * mass * g;\n      }\n   }\n}\n\nblock VehicleDynamicsSimulator {\n   part vehicle: Vehicle;\n\n   activity Simulate {\n      in initialSpeed: Speed;\n      in initialPosition: Length;\n      in timeStep: Time;\n      in totalTime: Time;\n      in power: Power[*];\n      out time: Time[*];\n      out position: Length[*];\n      out speed: Speed[*];\n      out acceleration: Acceleration[*];\n\n      var currentTime: Time = 0.0;\n      var currentSpeed: Speed = initialSpeed;\n      var currentPosition: Length = initialPosition;\n      var currentAcceleration: Acceleration;\n      var step: Integer = 0;\n      var nSteps: Integer = floor(totalTime / timeStep) + 1;\n\n      time = new Time[nSteps];\n      position = new Length[nSteps];\n      speed = new Speed[nSteps];\n      acceleration = new Acceleration[nSteps];\n\n      time[0] = currentTime;\n      position[0] = currentPosition;\n      speed[0] = currentSpeed;\n\n      var F_drag: Force = vehicle.getDragForce(currentSpeed);\n      var F_roll: Force = vehicle.getRollingResistanceForce();\n      var F_drive: Force;\n      if currentSpeed == 0.0 {\n         F_drive = 0.0;\n      } else {\n         F_drive = power[0] / currentSpeed;\n      }\n      var F_net: Force = F_drive - F_drag - F_roll;\n      currentAcceleration = F_net / vehicle.mass;\n      acceleration[0] = currentAcceleration;\n\n      step = 1;\n      while step < nSteps {\n         currentTime = step * timeStep;\n         currentSpeed = speed[step-1] + acceleration[step-1] * timeStep;\n         currentPosition = position[step-1] + speed[step-1] * timeStep + 0.5 * acceleration[step-1] * timeStep * timeStep;\n\n         F_drag = vehicle.getDragForce(currentSpeed);\n         F_roll = vehicle.getRollingResistanceForce();\n         if currentSpeed == 0.0 {\n            F_drive = 0.0;\n         } else {\n            F_drive = power[step] / currentSpeed;\n         }\n         F_net = F_drive - F_drag - F_roll;\n         currentAcceleration = F_net / vehicle.mass;\n\n         time[step] = currentTime;\n         position[step] = currentPosition;\n         speed[step] = currentSpeed;\n         acceleration[step] = currentAcceleration;\n\n         step = step + 1;\n      }\n   }\n}",
    "block VehicleDynamicsSystem {\n    property mass: Real;\n    property wheelPower: Real;\n    property dragCoefficient: Real;\n    property rollingResistanceCoefficient: Real;\n    property initialSpeed: Real;\n    property initialPosition: Real;\n    property currentSpeed: Real = initialSpeed;\n    property currentPosition: Real = initialPosition;\n    property acceleration: Real;\n    property timeStep: Real;\n\n    part dynamics: DynamicsEquations;\n\n    bind\n        dynamics.mass = mass,\n        dynamics.wheelPower = wheelPower,\n        dynamics.dragCoefficient = dragCoefficient,\n        dynamics.rollingResistanceCoefficient = rollingResistanceCoefficient,\n        dynamics.speed = currentSpeed;\n\n    constraint {\n        acceleration == (dynamics.drivingForce - dynamics.dragForce - dynamics.rollingForce) / mass;\n    }\n}\n\nconstraint block DynamicsEquations {\n    property mass: Real;\n    property wheelPower: Real;\n    property dragCoefficient: Real;\n    property rollingResistanceCoefficient: Real;\n    property speed: Real;\n\n    property dragForce: Real;\n    property rollingForce: Real;\n    property drivingForce: Real;\n\n    constraint {\n        dragForce == 0.5 * dragCoefficient * speed^2;\n        rollingForce == rollingResistanceCoefficient * mass * 9.81;\n        drivingForce == (speed > 0) ? (wheelPower / speed) : 0.0;\n    }\n}",
    "constraint Dynamics {\n   m: Real;\n   P: Real;\n   drag_coeff: Real;\n   friction_coeff: Real;\n   g: Real = 9.81;\n   s0: Real;\n   v0: Real;\n   Δt: Real;\n   a0: Real;\n   v1: Real;\n   s1: Real;\n   F_drive: Real;\n   F_air: Real;\n   F_roll: Real;\n   F_net: Real;\n   F_drive = P / v0;\n   F_air = drag_coeff * v0^2;\n   F_roll = friction_coeff * m * g;\n   F_net = F_drive - F_air - F_roll;\n   a0 = F_net / m;\n   v1 = v0 + a0 * Δt;\n   s1 = s0 + v0 * Δt + 0.5 * a0 * Δt^2;\n}\n\nblock VehicleDynamicsSystem {\n   mass: Real;\n   drag_coeff: Real;\n   friction_coeff: Real;\n   initial_position: Real;\n   initial_velocity: Real;\n   power: Real;\n   time_interval: Real;\n   acceleration: Real;\n   final_velocity: Real;\n   final_position: Real;\n   constraint dynamics: Dynamics {\n      m = mass;\n      P = power;\n      drag_coeff = drag_coeff;\n      friction_coeff = friction_coeff;\n      s0 = initial_position;\n      v0 = initial_velocity;\n      Δt = time_interval;\n   }\n   acceleration = dynamics.a0;\n   final_velocity = dynamics.v1;\n   final_position = dynamics.s1;\n}",
    "package VehicleMassManagement {\n    value type Mass {\n        unit: 'kg';\n    }\n\n    block Chassis {\n        property mass: Mass;\n    }\n\n    block Engine {\n        property mass: Mass;\n    }\n\n    block Gearbox {\n        property mass: Mass;\n    }\n\n    block Vehicle {\n        part chassis: Chassis;\n        part engine: Engine;\n        part gearbox: Gearbox;\n\n        property totalMass: Mass {\n            = chassis.mass + engine.mass + gearbox.mass\n        }\n\n        property overweightWarning: Boolean {\n            = totalMass > 2500\n        }\n\n        constraint MassLimit {\n            { totalMass <= 2500 }\n        }\n\n        requirement WeightRequirement {\n            id: \"REQ-Weight\";\n            text: \"The overall vehicle weight must not exceed 2500 kg.\";\n        }\n\n        requirement WarningRequirement {\n            id: \"REQ-Warning\";\n            text: \"Issue overweight warning if total mass exceeds limit.\";\n        }\n\n        satisfy WeightSatisfaction {\n            requirement = WeightRequirement;\n            assertedBy = MassLimit;\n        }\n\n        satisfy WarningSatisfaction {\n            requirement = WarningRequirement;\n            assertedBy = overweightWarning;\n        }\n    }\n}",
    "package VehicleMassBudgeting {\n  import SI::*;  // For SI units including kg\n\n  value type kg {\n    unit = SI::kg;\n  }\n\n  block Chassis {\n    attribute mass: kg;\n  }\n\n  block Engine {\n    attribute mass: kg;\n  }\n\n  block Transmission {\n    attribute mass: kg;\n  }\n\n  block Vehicle {\n    part chassis: Chassis[1];\n    part engine: Engine[1];\n    part transmission: Transmission[1];\n\n    attribute massLimit: kg = 2500;\n\n    constraint MassBudget {\n      parameters: [\n        totalMass: kg,\n        limit: kg\n      ],\n      expression: totalMass <= limit\n    }\n\n    parametric {\n      constraint MassBudget massBudget {\n        totalMass = chassis.mass + engine.mass + transmission.mass,\n        limit = massLimit\n      }\n    }\n  }\n\n  requirement \"Total Mass Constraint\" {\n    id = \"REQ_Mass\",\n    text = \"Total vehicle mass including chassis, engine, and transmission shall not exceed 2500 kg\",\n    verifiedBy = Vehicle::massBudget\n  }\n\n  requirement \"Component Mass Tracking\" {\n    id = \"REQ_ComponentMass\",\n    text = \"Engine and transmission masses shall be separately recorded and managed\"\n  }\n}",
    "package VehicleMassManagement {\n   value type Mass {\n      value: Real;\n      unit: String = 'kg';\n   }\n\n   part def Chassis {\n      mass: Mass;\n   }\n\n   part def Engine {\n      mass: Mass;\n   }\n\n   part def Transmission {\n      mass: Mass;\n   }\n\n   constraint def TotalMassConstraint {\n      parameters: {\n         chassisMass: Real;\n         engineMass: Real;\n         transMass: Real;\n         maxMass: Real;\n      }\n      constraint: chassisMass + engineMass + transMass <= maxMass;\n   }\n\n   requirement VehicleMassCompliance {\n      id = \"REQ1\";\n      text = \"Total vehicle mass must not exceed 2500 kg\";\n   }\n\n   part def Vehicle {\n      parts: {\n         chassis: Chassis;\n         engine: Engine;\n         transmission: Transmission;\n      }\n\n      constraint massLimit: TotalMassConstraint {\n         chassisMass = chassis.mass.value;\n         engineMass = engine.mass.value;\n         transMass = transmission.mass.value;\n         maxMass = 2500.0;\n      }\n\n      satisfy massCompliance: VehicleMassCompliance {\n         satisfiedBy = massLimit;\n      }\n   }\n}",
    "package VehicleWeightManagement {\n    requirement WeightRequirement [\n        \"Combined weight of chassis, engine, and transmission must not exceed 2500 kg\"\n        id = \"REQ_WeightLimit\"\n    ]\n\n    block VehicleSystem {\n        parts: \n            chassis: Chassis;\n            engine: Engine;\n            transmission: Transmission;\n        \n        totalWeight: Real {\n            derive chassis.weight + engine.weight + transmission.weight;\n        }\n        \n        constraint WeightConstraint [\n            totalWeight <= 2500\n        ]\n    }\n\n    block Chassis {\n        weight: Real;\n    }\n\n    block Engine {\n        weight: Real;\n    }\n\n    block Transmission {\n        weight: Real;\n    }\n\n    WeightRequirement.satisfiedBy = VehicleSystem::WeightConstraint;\n}",
    "package VehicleSystem {\n  import SIUnits::*;\n\n  part def Chassis {\n    attribute mass: Real[kg];\n  }\n\n  part def Engine {\n    attribute mass: Real[kg];\n  }\n\n  part def Transmission {\n    attribute mass: Real[kg];\n  }\n\n  constraint def DynamicConstraint {\n    parameter initialVelocity: Real[m/s];\n    parameter finalVelocity: Real[m/s];\n    parameter mass: Real[kg];\n    parameter appliedForce: Real[N];\n    parameter time: Real[s];\n\n    constraint massPositive: mass > 0;\n    constraint forceRelation: appliedForce * time = mass * (finalVelocity - initialVelocity);\n  }\n\n  part def Vehicle {\n    part chassis: Chassis;\n    part engine: Engine;\n    part transmission: Transmission;\n\n    constraint totalMass: chassis.mass + engine.mass + transmission.mass <= 2500[kg];\n    constraint dynamics: DynamicConstraint {\n      bind mass: chassis.mass + engine.mass + transmission.mass;\n    }\n  }\n}",
    "package VehicleMaintenanceSystem {\n   part def Vehicle {\n      attribute nextMaintenanceTime : Time;\n      attribute maintenanceInterval : Duration;\n      attribute maxAllowedTemperature : Temperature;\n      attribute status : VehicleStatus;\n\n      state machine {\n         initial state Healthy;\n         state UnderMaintenance;\n\n         transition from Healthy to UnderMaintenance on maintenanceDue {\n            trigger when currentTime() >= nextMaintenanceTime;\n         }\n         transition from UnderMaintenance to Healthy on maintenanceComplete {\n            effect {\n               nextMaintenanceTime = currentTime() + maintenanceInterval;\n               status = VehicleStatus::normal;\n            }\n         }\n      }\n\n      requirement R5: \"Actual start time after scheduled\" {\n         constraint maintenanceStartTime > nextMaintenanceTime;\n      }\n      requirement R6: \"Maintenance initiation within 2 seconds\" {\n         constraint maintenanceStartTime - nextMaintenanceTime <= 2s;\n      }\n      requirement R7: \"Maintenance duration <= 48 hours\" {\n         constraint maintenanceEndTime - maintenanceStartTime <= 48h;\n      }\n   }\n\n   enum VehicleStatus {\n      normal,\n      underMaintenance\n   }\n\n   part def MaintenanceSystem {\n      part vehicles : Vehicle[*];\n      operation monitorMaintenance();\n      operation updateMaintenanceSchedule();\n   }\n}",
    "package VehicleSystem {\n   block Vehicle {\n      property curbWeight: Real;\n      property fuelMass: Real;\n      property maxMassLimit: Real;\n      property totalMass: Real = curbWeight + fuelMass;\n      constraint MassLimit: totalMass <= maxMassLimit;\n      constraint PositiveFuel: fuelMass > 0.0;\n   }\n\n   block Engine {\n      operation generateTorque(speed: Real): Real;\n   }\n\n   block Transmission {\n      property torqueInput: Real;\n   }\n\n   interface ClutchInterface {\n   }\n\n   part engine: Engine;\n   part transmission: Transmission;\n   connector clutchConnection: ClutchInterface {\n      source: engine;\n      target: transmission;\n   }\n\n   constraint TorqueTransmission {\n      engine.generateTorque(speed) = transmission.torqueInput;\n   }\n}",
    "package VehicleSystem {\n   value type kg;\n   value type Nm;\n\n   block FuelTank {\n      value capacity: kg;\n      value currentMass: kg;\n   }\n\n   block Engine {\n      value outputTorque: Nm;\n      constraint TorquePerformance {\n         equation: \"Conforms to speed-torque curve (Table 1)\";\n      }\n   }\n\n   block Transmission {\n      value inputTorque: Nm;\n   }\n\n   interface ClutchInterface {\n   }\n\n   block Vehicle {\n      part fuelTank: FuelTank;\n      part engine: Engine;\n      part transmission: Transmission;\n      part clutch: ClutchInterface;\n\n      value dryMass: kg;\n      value totalMass: kg = dryMass + fuelTank.currentMass;\n\n      connector powertrain: engine -> clutch -> transmission;\n\n      constraint FullTankMass {\n         equation: \"fuelTank.currentMass == fuelTank.capacity implies totalMass <= 2000\";\n      }\n\n      constraint EmptyTankMass {\n         equation: \"fuelTank.currentMass == 0 implies totalMass <= 1500\";\n      }\n\n      constraint TorqueTransmission {\n         equation: \"engine.outputTorque == transmission.inputTorque\";\n      }\n   }\n\n   requirement \"MassRequirement\" {\n      id: \"REQ1\";\n      text: \"With full fuel tank, total mass <= 2000 kg; with empty tank, total mass <= 1500 kg\";\n   }\n\n   requirement \"PowertrainRequirement\" {\n      id: \"REQ2\";\n      text: \"Engine transmits torque to transmission via clutch interface\";\n   }\n\n   requirement \"EnginePerformance\" {\n      id: \"REQ3\";\n      text: \"Engine delivers torque per speed-torque curve (Table 1)\";\n   }\n\n   satisfy MassSatisfaction {\n      requirement = \"REQ1\";\n      satisfiedBy = Vehicle::FullTankMass, Vehicle::EmptyTankMass;\n   }\n\n   satisfy TorqueSatisfaction {\n      requirement = \"REQ2\";\n      satisfiedBy = Vehicle::TorqueTransmission;\n   }\n\n   satisfy PerformanceSatisfaction {\n      requirement = \"REQ3\";\n      satisfiedBy = Engine::TorquePerformance;\n   }\n}",
    "package VehicleSystem {\n    interface def Clutch {\n        flow torque: Real;\n    }\n\n    requirement def VehicleMassReq {\n        id: 'R1';\n        text: \"The vehicle's total mass must not exceed 2000 kg when fully fueled and 1500 kg when empty.\";\n    }\n\n    requirement def EngineTorqueReq {\n        id: 'R2';\n        text: \"The engine must transmit generated torque to the transmission system through a clutch interface.\";\n    }\n\n    requirement def TorqueCurveReq {\n        id: 'R3';\n        text: \"Engine torque must vary with speed per performance table specifications.\";\n    }\n\n    block def Engine {\n        value property speed: Real { unit: 'rpm'; }\n        value property torque: Real { unit: 'N*m'; }\n        port def clutchPort: output Clutch {\n            flow torque: Real = ..torque;\n        }\n        constraint def TorqueVariation {\n            : 'Torque varies with speed per performance table';\n        }\n        satisfy TorqueCurveReq: TorqueVariation;\n    }\n\n    block def Transmission {\n        port def clutchPort: input Clutch;\n    }\n\n    block def Vehicle {\n        value property massEmpty: Real { unit: 'kg'; }\n        value property massFull: Real { unit: 'kg'; }\n        constraint def MassLimit {\n            : massEmpty <= 1500;\n            : massFull <= 2000;\n        }\n        part def engine: Engine;\n        part def transmission: Transmission;\n        connector def powertrain: engine.clutchPort -> transmission.clutchPort;\n        satisfy VehicleMassReq: MassLimit;\n        satisfy EngineTorqueReq: powertrain;\n    }\n}",
    "part def Vehicle [block] {\n    part fuelTank: FuelTank;\n    attribute curbMass: Real;\n    attribute fuelMass: Real;\n    derived attribute totalMass: Real = curbMass + fuelMass;\n    \n    constraint FullTankMass {\n        expr: fuelMass == fuelTank.capacity implies totalMass <= 2000.0\n    }\n    constraint EmptyTankMass {\n        expr: fuelMass == 0.0 implies totalMass <= 1500.0\n    }\n}\n\npart def FuelTank [block] {\n    attribute capacity: Real;\n}\n\npart def Engine [block] {\n    port torqueOutput: TorqueOutput;\n}\n\npart def Clutch [block] {\n    port torqueInput: TorqueInput;\n    port torqueOutput: TorqueOutput;\n}\n\npart def Gearbox [block] {\n    port torqueInput: TorqueInput;\n}\n\ninterface def TorqueOutput [interface] {}\n\ninterface def TorqueInput [interface] {}\n\npart def PowerSystem [block] {\n    part engine: Engine;\n    part clutch: Clutch;\n    part gearbox: Gearbox;\n    \n    connector engClutch: engine.torqueOutput -> clutch.torqueInput;\n    connector clutchGear: clutch.torqueOutput -> gearbox.torqueInput;\n}",
    "package VehiclePerformanceAnalysis {\n    block Vehicle {\n        attribute curbWeight: Real;\n        attribute payload: Real;\n        attribute wheelDiameter: Real;\n        attribute transmissionEfficiency: Real;\n        attribute urbanFuelEconomy: Real;\n        attribute highwayFuelEconomy: Real;\n    }\n\n    block DrivingCycle {\n        attribute time: Real[0..*];\n        attribute position: Real[0..*];\n        attribute speed: Real[0..*];\n    }\n\n    block PerformanceAnalysis {\n        reference vehicle: Vehicle;\n        reference drivingCycle: DrivingCycle;\n        attribute powerDemand: Real[0..*];\n        attribute acceleration: Real[0..*];\n        attribute fuelEconomy: Real;\n\n        constraint {\n            // Calculate dynamic parameters and fuel economy based on vehicle attributes and driving cycle\n        }\n    }\n\n    requirement EnergyConsumptionTarget {\n        attribute targetValue: Real;\n        attribute unit: String;\n    }\n\n    verify FuelEconomyCompliance {\n        requirement: EnergyConsumptionTarget;\n        reference analysis: PerformanceAnalysis;\n        constraint {\n            // Verify fuel economy meets specified target\n        }\n    }\n\n    block VehicleAnalysisSystem {\n        part vehicleConfig: Vehicle;\n        part driveCycle: DrivingCycle;\n        part performanceAnalysis: PerformanceAnalysis;\n        part consumptionTarget: EnergyConsumptionTarget;\n        part complianceCheck: FuelEconomyCompliance;\n\n        constraint {\n            performanceAnalysis.vehicle = vehicleConfig;\n            performanceAnalysis.drivingCycle = driveCycle;\n            complianceCheck.analysis = performanceAnalysis;\n            complianceCheck.requirement = consumptionTarget;\n        }\n    }\n}",
    "package FuelEconomySimulation {\n    requirement FuelEconomyRequirement {\n        id = \"REQ-1\";\n        text = \"Vehicle fuel economy shall exceed 30 miles per gallon under specified driving scenarios\";\n    }\n\n    block Vehicle {\n        attribute curbWeight: Real;\n        attribute load: Real;\n        attribute wheelDiameter: Real;\n        attribute transmissionEfficiency: Real;\n    }\n\n    block DrivingScenario {\n        attribute scenarioType: String;\n        attribute trajectory: Real[0..*];\n        attribute speedVariation: Real[0..*];\n    }\n\n    block FuelEconomySimulator {\n        part vehicle: Vehicle;\n        part urbanScenario: DrivingScenario;\n        part highwayScenario: DrivingScenario;\n\n        attribute wheelPower: Real;\n        attribute acceleration: Real;\n        attribute energyConsumption: Real;\n        attribute enginePowerDemand: Real;\n        attribute fuelConsumption: Real; // liters per 100km\n        attribute fuelEconomy: Real; // miles per gallon\n\n        action CalculateWheelPower {\n            in scenario: DrivingScenario;\n            out power: Real;\n        }\n\n        action ApplyVehicleDynamics {\n            in wheelPower: Real;\n            out acceleration: Real;\n            out energy: Real;\n        }\n\n        action EstimateEnginePower {\n            in energy: Real;\n            out enginePower: Real;\n        }\n\n        action DetermineFuelConsumption {\n            in enginePower: Real;\n            out consumption: Real; // liters per 100km\n            out economy: Real; // miles per gallon\n        }\n\n        action VerifyRequirement {\n            in actualEconomy: Real;\n            out requirementMet: Boolean;\n        }\n    }\n\n    satisfy FuelEconomySatisfaction {\n        requirement = FuelEconomyRequirement;\n        satisfiedBy = FuelEconomySimulator.VerifyRequirement(requirementMet: true);\n    }\n}",
    "package EngineSelectionModel {\n   unit kW;\n   unit kg;\n   unit percent;\n   unit USD;\n\n   value type Power {\n      value : Real[?];\n      unit = kW;\n   }\n\n   value type Mass {\n      value : Real[?];\n      unit = kg;\n   }\n\n   value type Efficiency {\n      value : Real[?];\n      unit = percent;\n   }\n\n   value type Cost {\n      value : Real[?];\n      unit = USD;\n   }\n\n   block Engine {\n      power : Power;\n      mass : Mass;\n      efficiency : Efficiency;\n      cost : Cost;\n   }\n\n   block FourCylinderEngine :> Engine {}\n   block SixCylinderEngine :> Engine {}\n\n   constraint block EvaluationFunction {\n      param power : Power;\n      param mass : Mass;\n      param efficiency : Efficiency;\n      param cost : Cost;\n      result : Real;\n\n      constraint {\n         expression = \"result = ...\"; // Placeholder for evaluation equation\n      }\n   }\n\n   block EngineSelectionSystem {\n      part candidateEngines : Engine[*];\n      part evaluator : EvaluationFunction;\n\n      operation recommendOptimal() : Engine {\n         // Implementation logic to select best engine\n      }\n   }\n}",
    "package VehicleQualityControl {\n   requirement CurbWeightRequirement {\n      id = \"REQ-1\";\n      text = \"The curb weight of each vehicle must be less than or equal to 2,500 kilograms.\";\n   }\n\n   enum QualificationResult {\n      qualified;\n      unqualified;\n   }\n\n   activity CheckCurbWeight {\n      action CollectWeightData {\n         output rawWeight: real;\n      }\n\n      action ProcessWeightData {\n         input inWeight: real;\n         output processedWeight: real;\n      }\n\n      action EvaluateWeight {\n         input inWeight: real;\n         output result: QualificationResult;\n      }\n\n      edge [source: CollectWeightData::rawWeight, target: ProcessWeightData::inWeight];\n      edge [source: ProcessWeightData::processedWeight, target: EvaluateWeight::inWeight];\n      output [EvaluateWeight::result];\n   }\n\n   verify {\n      verifiedRequirement = CurbWeightRequirement;\n      verifyingSubject = CheckCurbWeight;\n   }\n}",
    "package MassVerificationSystem {\n    requirement MassLimit {\n        id = \"REQ1\";\n        text = \"The actual mass of each vehicle must not exceed 2,500 kilograms.\";\n    }\n\n    block Vehicle {\n        value property mass: Real { unit: 'kg'; }\n    }\n\n    block WeighingEquipment {\n        operation measureMass(in target: Vehicle) : Real;\n    }\n\n    block MassVerificationUnit {\n        operation evaluateMass(in mass: Real) : Boolean;\n    }\n\n    block MassVerificationSystem {\n        part weighingEquipment: WeighingEquipment;\n        part massVerificationUnit: MassVerificationUnit;\n\n        constraint MassConstraint {\n            requirement = MassLimit;\n            expression = 'vehicle.mass <= 2500';\n        }\n\n        activity VerifyMass {\n            input: in vehicle: Vehicle;\n            output: out qualified: Boolean;\n\n            action measure: CallOperationAction {\n                operation = weighingEquipment.measureMass;\n                argument: vehicle -> target;\n                result: massValue: Real;\n            }\n\n            action evaluate: CallOperationAction {\n                operation = massVerificationUnit.evaluateMass;\n                argument: massValue -> mass;\n                result: qualified;\n            }\n\n            edge vehicle -> measure.target;\n            edge measure.massValue -> evaluate.mass;\n            edge evaluate.qualified -> qualified;\n        }\n    }\n}",
    "package TransportationSystem {\n    part Vehicle {\n        attribute capacity: Integer[1] = 5; // Driver + 4 passengers\n        operation enter();\n        operation exit();\n    }\n\n    part Driver {\n        association vehicle: Vehicle[0..1];\n    }\n\n    part Passenger {\n        association vehicle: Vehicle[0..1];\n    }\n\n    part Environment {\n        attribute factors: String[*];\n    }\n\n    part Infrastructure {\n        part GasStation;\n    }\n\n    part TransportationSystem {\n        part vehicle: Vehicle[1];\n        part driver: Driver[1];\n        part passengers: Passenger[0..4];\n        reference environment: Environment[1];\n        reference infrastructure: Infrastructure[*];\n\n        requirement \"Convenience\" {\n            id: 'R1'\n            text: \"Provide convenient transportation experience\"\n        }\n\n        requirement \"Efficiency\" {\n            id: 'R2'\n            text: \"Enable efficient travel between locations\"\n        }\n\n        requirement \"Safety\" {\n            id: 'R3'\n            text: \"Ensure safe journey for all occupants\"\n        }\n\n        requirement \"Comfort\" {\n            id: 'R4'\n            text: \"Maintain comfortable travel conditions\"\n        }\n\n        requirement \"Accessibility\" {\n            id: 'R5'\n            text: \"Allow free and smooth entry/exit from vehicle\"\n        }\n\n        requirement \"Sustainability\" {\n            id: 'R6'\n            text: \"Integrate environmental sustainability considerations\"\n        }\n\n        requirement \"Compatibility\" {\n            id: 'R7'\n            text: \"Maintain compatibility with external infrastructure\"\n        }\n\n        requirement \"UserCentric\" {\n            id: 'R8'\n            text: \"Center operation around human needs and experiences\"\n        }\n\n        satisfies 'R1' 'R2' 'R3' 'R4' 'R5' 'R6' 'R7' 'R8'\n    }\n\n    association Vehicle_Driver {\n        end vehicle: Vehicle[1];\n        end driver: Driver[1];\n    }\n\n    association Vehicle_Passenger {\n        end vehicle: Vehicle[1];\n        end passenger: Passenger[0..4];\n    }\n}",
    "activity TransportationProcess {\n    partition driver: Driver;\n    partition passengers: Passengers[0..4];\n    partition vehicle: Vehicle;\n    partition environment: Environment;\n    partition gasStation: GasStation;\n\n    driver: {\n        action enter: EnterVehicle;\n        action operate: OperateVehicle;\n        action refuel: Refuel;\n        action exit: ExitVehicle;\n    }\n\n    passengers: {\n        action enter: EnterVehicle;\n        action exit: ExitVehicle;\n    }\n\n    vehicle: {\n        action transport: Transport;\n    }\n\n    environment: {\n        action influence: AffectDriving;\n    }\n\n    gasStation: {\n        action provideFuel: DispenseFuel;\n    }\n\n    start -> driver.enter;\n    start -> passengers.enter;\n    driver.enter -> operate;\n    passengers.enter -> operate;\n    operate -> vehicle.transport;\n    environment.influence -> operate;\n    operate -[guard=\"needsFuel\"]-> refuel;\n    refuel -> gasStation.provideFuel;\n    gasStation.provideFuel -> refuel;\n    refuel -> operate;\n    operate -[guard=\"destinationReached\"]-> driver.exit;\n    operate -[guard=\"destinationReached\"]-> passengers.exit;\n    driver.exit -> end;\n    passengers.exit -> end;\n}",
    "package VehicleProductLine {\n  enum TransmissionKind {\n    manual,\n    automatic\n  }\n\n  enum DiameterEnum {\n    small,\n    large\n  }\n\n  block Engine {\n    attribute cylinderCount: Integer;\n    attribute cylinderDiameter: DiameterEnum;\n\n    constraint CylinderCountConstraint {\n      cylinderCount = 4 or cylinderCount = 6\n    }\n  }\n\n  block Transmission {\n    attribute kind: TransmissionKind;\n  }\n\n  block Vehicle {\n    parts: \n      engine: Engine[1];\n      transmission: Transmission[1];\n\n    constraint CombinationConstraint {\n      (engine.cylinderCount = 4 and transmission.kind = TransmissionKind::manual) \n      or \n      (engine.cylinderCount = 6 and transmission.kind = TransmissionKind::automatic)\n    }\n  }\n}",
    "package EngineSystem {\n    value type Diameter: Real;\n\n    part Cylinder {\n        attribute diameter: Diameter;\n    }\n\n    part Engine {\n        attribute cylinderDiameter: Diameter;\n        part cylinder[4..6]: Cylinder {\n            diameter = cylinderDiameter;\n        }\n    }\n\n    variation engineVariation for Engine {\n        variationPoint cylinderCount;\n        variationPoint cylinderSize;\n    }\n\n    variant fourCylinder for cylinderCount {\n        redefinition cylinder: Cylinder[4];\n    }\n\n    variant sixCylinder for cylinderCount {\n        redefinition cylinder: Cylinder[6];\n    }\n\n    variant smallDiameter for cylinderSize {\n        redefinition cylinderDiameter: Diameter = 70.0;\n    }\n\n    variant largeDiameter for cylinderSize {\n        redefinition cylinderDiameter: Diameter = 100.0;\n    }\n}",
    "package AutomotiveConfiguration {\n    part def Engine {\n        attribute cylinderDiameter: Real[2];\n    }\n\n    part def FourCylinderEngine :> Engine {\n        attribute numberOfCylinders: Integer = 4;\n    }\n\n    part def SixCylinderEngine :> Engine {\n        attribute numberOfCylinders: Integer = 6;\n    }\n\n    part def Transmission;\n\n    part def ManualTransmission :> Transmission;\n\n    part def AutomaticTransmission :> Transmission;\n\n    part def Vehicle {\n        part engine: Engine[1];\n        part transmission: Transmission[1];\n\n        constraint EngineTransmissionCompatibility {\n            (engine instanceof FourCylinderEngine) => (transmission instanceof ManualTransmission);\n            (engine instanceof SixCylinderEngine) => (transmission instanceof AutomaticTransmission);\n        }\n    }\n}",
    "package SystemModel {\n   part def SystemAssembly {\n      part computer: ComputerSubsystem;\n      part storage: StorageSubsystem;\n   }\n\n   part def ComputerSubsystem {\n      part software: SoftwareDesign;\n   }\n\n   part def StorageSubsystem {\n      ref messageFormat: SoftwareDesign::MessageFormat;\n      ref dataFormat: SoftwareDesign::DataFormat;\n   }\n\n   part def SoftwareDesign {\n      part messageFormat: MessageFormat;\n      part dataFormat: DataFormat;\n   }\n\n   part def MessageFormat;\n   part def DataFormat;\n\n   requirement \"Seamless Integration\" {\n      id: 'REQ-1'\n      text: \"Software and hardware must work together seamlessly to ensure efficient, reliable, and compliant information storage, transmission, and processing\"\n   }\n\n   satisfy SystemAssembly satisfies 'REQ-1';\n}",
    "value type Power;\nvalue type Torque;\n\npart def TorqueGenerator {\n    port in powerIn: Power;\n    port out torqueOut: Torque;\n}\n\npart def PowerUnit {\n    port out powerOut: Power;\n    port out torqueOut: Torque;\n}\n\npart def LogicalLayer {\n    part tg: TorqueGenerator;\n}\n\npart def PhysicalLayer {\n    part pu: PowerUnit;\n}\n\npart def PowertrainSystem {\n    part logical: LogicalLayer;\n    part physical: PhysicalLayer;\n    \n    allocate logical.tg to physical.pu;\n}",
    "part System {\n   capability DeliverPowerAndGenerateTorque\n\n   part torqueGenerator: TorqueGenerator\n   part powertrain: Powertrain\n\n   satisfy DeliverPowerAndGenerateTorque by torqueGenerator.GeneratingTorqueAction\n   allocate torqueGenerator to powertrain\n   allocate torqueGenerator.GeneratingTorqueAction to powertrain.engine.GenerateTorqueFunction\n}\n\npart TorqueGenerator {\n   behavior GeneratingTorqueAction\n}\n\npart Powertrain {\n   part engine: Engine\n}\n\npart Engine {\n   behavior GenerateTorqueFunction\n}",
    "package VehicleFeatureAnnotationSystem {\n    enum FeatureType {\n        Safety,\n        Protection\n    }\n\n    part def SeatBelts {\n        value: FeatureType = FeatureType::Safety;\n    }\n\n    part def DriverAirbag {\n        value: FeatureType = FeatureType::Safety;\n    }\n\n    part def Bumper {\n        value: FeatureType = FeatureType::Safety;\n    }\n\n    part def AntiTheftAlarm {\n        value: FeatureType = FeatureType::Protection;\n    }\n\n    part def KeylessEntry {\n        value: FeatureType = FeatureType::Protection;\n    }\n\n    part def FrontSeats {}\n\n    part def BodyShell {}\n\n    part def InteriorAssembly {\n        seatBelts: SeatBelts;\n        frontSeats: FrontSeats;\n        driverAirbag: DriverAirbag;\n        alarmSystem: AntiTheftAlarm;\n    }\n\n    part def BodyAssembly {\n        bodyShell: BodyShell;\n        bumpers: Bumper;\n        keylessEntry: KeylessEntry;\n    }\n\n    part def VehicleFeatureAnnotationSystem {\n        interior: InteriorAssembly;\n        body: BodyAssembly;\n    }\n}",
    "part def VehicleDynamicsSimulator {\n    part modelCenter: ModelCenter;\n    \n    in flow userInput: {\n        initialVelocity: Real;\n        initialPosition: Real;\n        acceleration: Real;\n        timeStep: Real;\n    }\n    \n    out flow simulationResults: {\n        finalVelocity: Real;\n        finalPosition: Real;\n    }\n}\n\npart def ModelCenter {\n    operation calculateDynamics(\n        in initialVelocity: Real,\n        in initialPosition: Real,\n        in acceleration: Real,\n        in timeStep: Real,\n        out finalVelocity: Real,\n        out finalPosition: Real\n    );\n}\n\nrequirement req {\n    id = \"REQ1\";\n    text = \"The system shall be capable of performing automated simulation and analysis of vehicle dynamic behavior. Users should be able to input the vehicle’s initial velocity, initial position, acceleration at a specific moment, and the time step. Through integration with the ModelCenter analysis tool, the system shall automatically calculate and output the vehicle’s velocity and position after the specified time step based on the given physical model. The system must ensure accurate data transfer and reliable output of simulation results, enabling users to conveniently obtain key dynamic parameters to support vehicle performance analysis and design optimization.\";\n}\n\nsatisfy sat {\n    requirement = req;\n    satisfiedBy = [\n        VehicleDynamicsSimulator,\n        ModelCenter\n    ];\n}",
    "model CarSafetyCompliance;\n\nstereotype Safety {\n    isMandatory: Boolean;\n}\n\npart def SeatBelt;\nSeatBelt: Safety { isMandatory = true; }\n\npart def Airbag;\nAirbag: Safety { isMandatory = false; }\n\npart def Bumper;\nBumper: Safety { isMandatory = true; }\n\npart def ABS;\nABS: Safety { isMandatory = false; }\n\npart def KeylessEntry;\npart def Wheel;\n\npart def Interior {\n    part seatBelt: SeatBelt[2];\n    part driverAirbag: Airbag[0..1];\n}\n\npart def Body {\n    part bumper: Bumper;\n    part keylessEntry: KeylessEntry[0..1];\n}\n\npart def WheelAssembly {\n    part wheel: Wheel[2];\n    part abs: ABS[0..1];\n}\n\npart def Car {\n    part interior: Interior;\n    part body: Body;\n    part wheelAssembly: WheelAssembly;\n}\n\npackage SafetyFeatures {\n    SeatBelt;\n    Airbag;\n    Bumper;\n    ABS;\n}\n\npackage MandatorySafetyFeatures {\n    SeatBelt;\n    Bumper;\n}",
    "package VehicleSafetyComplianceSystem {\n    abstract type SafetyFeature {\n        attribute isMandatory: Boolean;\n    }\n\n    type MandatorySafetyFeature :> SafetyFeature {\n        isMandatory = true;\n    }\n\n    type OptionalSafetyFeature :> SafetyFeature {\n        isMandatory = false;\n    }\n\n    part def VehicleInterior {\n        part seatBelt: SeatBelt[2];\n    }\n\n    part def VehicleBody {\n        part bumper: Bumper;\n        part keylessEntry: KeylessEntrySystem;\n    }\n\n    part def ChassisSystem {\n        part tire: Tire[4];\n        part abs: AntiLockBrakingSystem;\n    }\n\n    part def VehicleSafetyComplianceSystem {\n        part interior: VehicleInterior;\n        part body: VehicleBody;\n        part chassis: ChassisSystem;\n    }\n\n    type SeatBelt :> MandatorySafetyFeature;\n    type DriverAirbag :> OptionalSafetyFeature;\n    type Bumper :> MandatorySafetyFeature;\n    type KeylessEntrySystem :> OptionalSafetyFeature;\n    type AntiLockBrakingSystem :> OptionalSafetyFeature;\n    type Tire;\n}",
    "package RiskManagementSystem {\n    enum SeverityLevel {\n        low,\n        medium,\n        high,\n        critical\n    }\n\n    block Situation {\n        attribute description: String;\n    }\n\n    block Cause {\n        attribute probability: Real[0..1];\n    }\n\n    block Failure {\n        attribute severity: SeverityLevel;\n    }\n\n    association CauseToSituation {\n        source: cause Cause[1];\n        target: resultingSituation Situation[1..*];\n    }\n\n    association SituationToFailure {\n        source: situation Situation[1];\n        target: resultingFailure Failure[1..*];\n    }\n\n    block RiskScenario {\n        part situations: Situation[*];\n        part causes: Cause[*];\n        part failures: Failure[*];\n    }\n}",
    "package RiskModel {\n    enum SeverityLevel {\n        Low,\n        Medium,\n        High,\n        Critical\n    }\n\n    part def Cause {\n        attribute probability: Real;\n    }\n\n    part def Failure {\n        attribute severity: SeverityLevel;\n    }\n\n    part def RiskScenario {\n        attribute description: String;\n        part cause: Cause[0..*];\n        part failure: Failure[0..*];\n    }\n\n    association CausalLink {\n        source: RiskScenario[1];\n        target: RiskScenario[1..*];\n    }\n\n    part def RiskCase {\n        part scenario: RiskScenario[1..*];\n        part cause: Cause[0..*];\n        part failure: Failure[0..*];\n    }\n}",
    "package FailureAnalysis {\n    part def Equipment {\n        part battery: Battery;\n    }\n\n    part def Battery {\n        attribute level: Real;\n        attribute age: Real;\n    }\n\n    state def OperationalState {\n        state normal;\n        state lowBattery;\n        state shutdown;\n    }\n\n    state machine def BatteryStateMachine {\n        state states: OperationalState;\n        initial -> states/normal;\n        transition t1: states/normal -> states/lowBattery \n            when [battery.level < minThreshold];\n        transition t2: states/lowBattery -> states/shutdown \n            when [persistentLowBattery];\n    }\n\n    requirement def MonitorBattery {\n        id: 'REQ1';\n        text: \"Continuously monitor battery level during operation\";\n    }\n\n    requirement def DetectFailureRisk {\n        id: 'REQ2';\n        text: \"Detect increased battery failure probability due to aging\";\n    }\n\n    requirement def IdentifyLowBatteryRisk {\n        id: 'REQ3';\n        text: \"Identify risk that battery aging leads to low battery level\";\n    }\n\n    requirement def AssignSeverity {\n        id: 'REQ4';\n        text: \"Assign severity level for critical failures to alert stakeholders\";\n    }\n\n    risk def BatteryAgingRisk {\n        cause: \"battery aging\";\n        effect: \"low battery level\";\n    }\n\n    risk def DeviceShutdownRisk {\n        cause: \"persistent low battery\";\n        effect: \"device shutdown\";\n    }\n\n    constraint def MinBatteryThreshold {\n        param minThreshold: Real;\n    }\n\n    constraint def PersistentLowBattery {\n        param durationThreshold: Time;\n    }\n\n    scenario def FailureScenario {\n        step 1: normal operation;\n        step 2: battery aging increases failure probability;\n        step 3: battery level drops below minThreshold;\n        step 4: enter lowBattery state;\n        step 5: if persistentLowBattery then shutdown;\n    }\n\n    analysis def RiskAnalysis {\n        subject: Equipment;\n        evaluate: [BatteryAgingRisk, DeviceShutdownRisk];\n        assign: severityLevel;\n    }\n}",
    "package StructuralDecomposition {\n    part def System {\n        part subsystem : Subsystem[0..*];\n        satisfy req_structure;\n    }\n\n    part def Subsystem {\n        part component : Component[0..*];\n        port external : Interface;\n    }\n\n    part def Component {\n        port provided : Interface;\n        port required : Interface;\n    }\n\n    interface def Interface {\n        // Interface specifications defined here\n    }\n\n    requirement req_structure {\n        id = \"STR-001\"\n        text = \"The system must possess structural decomposition capability with hierarchical structure, well-defined interfaces, and support for IV&V analysis to ensure requirement coverage.\"\n    }\n\n    part def DecompositionContext {\n        part sys : System;\n        part sub : Subsystem;\n        part comp : Component;\n\n        connection conn1 : sys.subsystem -> sub;\n        connection conn2 : sub.component -> comp;\n        connection conn3 : sub.external -> comp.provided;\n        connection conn4 : comp.required -> comp.provided;\n    }\n}",
    "package AutomotiveSystem {\n    enum SafetyStatus {\n        mandatory, optional\n    }\n\n    part AutomotiveSystem {\n        part body: Body;\n        part chassis: Chassis;\n        part powertrain: Powertrain;\n    }\n\n    part Body {\n        part bumper: Bumper;\n        part seatBelt: SeatBelt;\n        part driverAirbag: Airbag;\n        part door: Door;\n    }\n\n    part Chassis {\n        part abs: ABS;\n        part suspension: Suspension;\n    }\n\n    part Powertrain {\n        part engine: Engine;\n        part transmission: Transmission;\n    }\n\n    part Bumper {\n        attribute safetyStatus: SafetyStatus = mandatory;\n    }\n\n    part SeatBelt {\n        attribute safetyStatus: SafetyStatus = mandatory;\n    }\n\n    part Airbag {\n        attribute safetyStatus: SafetyStatus = optional;\n    }\n\n    part ABS {\n        attribute safetyStatus: SafetyStatus = optional;\n    }\n\n    part Door {}\n    part Suspension {}\n    part Engine {}\n    part Transmission {}\n\n    viewpoint StructuralViewpoint {\n        concern: \"Hierarchical structure of all components\";\n        stakeholder: [\"System Engineers\", \"IV&V Personnel\"];\n    }\n\n    viewpoint SafetyViewpoint {\n        concern: \"Safety-related components with mandatory/optional status\";\n        stakeholder: [\"System Engineers\", \"IV&V Personnel\"];\n    }\n\n    viewpoint NonSafetyViewpoint {\n        concern: \"Complete list of non-safety components\";\n        stakeholder: [\"System Engineers\", \"IV&V Personnel\"];\n    }\n\n    view Structure for StructuralViewpoint {}\n    view SafetyView for SafetyViewpoint {}\n    view NonSafetyView for NonSafetyViewpoint {}\n}",
    "package AutomotiveDomain {\n   comment = \"Standardized definitions and annotations for fundamental automotive concepts. Emphasizes clarity and extensibility for development, integration, and maintenance.\"\n\n   value type 扭矩 {\n      alias = \"Torque\";\n      unit = \"N·m\";\n      comment = \"Rotational force acting on an object, measured in newton-meters (N·m). Fundamental physical quantity for automotive performance characteristics.\"\n   }\n\n   block 汽车 {\n      alias = \"汽车 (Car)\";\n      comment = \"Core component representing an automobile. Central entity for modeling automotive systems and their interactions.\";\n      value maxTorque: 扭矩[1];\n      value minTorque: 扭矩[1];\n   }\n}",
    "package DocumentManagementPlatform {\n    block DocumentManagementPlatform {\n        part automobiles: Automobile[*];\n        part documents: Document[*];\n\n        operation enterAutomobileInfo(in automobile: Automobile);\n        operation queryAutomobileInfo(in criteria: String) : Automobile[*];\n        operation archiveAutomobileInfo(in automobile: Automobile);\n        operation addExplanatoryDocument(in target: Element, in doc: Document);\n    }\n\n    block Automobile {\n        attribute VIN: String;\n        attribute model: String;\n        attribute torqueValue: ISQ_TorqueValue;\n    }\n\n    alias Car = Automobile;\n\n    block Document {\n        attribute title: String;\n        attribute content: String;\n    }\n\n    value type ISQ_TorqueValue: Real;\n\n    association {\n        Automobile explainedObject[0..*];\n        Document documentation[0..*];\n    }\n}",
    "package AutomobileSystem {\n    class Automobile {\n    }\n\n    alias Car = Automobile;\n\n    class PhysicalQuantity {\n        value: Real;\n        unit: String;\n    }\n\n    class TorqueValue : PhysicalQuantity {\n    }\n\n    alias Torque = TorqueValue;\n}",
    "enum VehicleSize {\n   small;\n   standard;\n   large;\n}\n\nclass Engine {\n   attribute cylinderCount : Integer;\n}\n\nclass Vehicle {\n   attribute size : VehicleSize;\n   part engine : Engine [1];\n}\n\nconstraint CylinderConfiguration for Vehicle {\n   (size == VehicleSize::small implies engine.cylinderCount == 4) and\n   (size == VehicleSize::large implies engine.cylinderCount == 6) and\n   (size == VehicleSize::standard implies (engine.cylinderCount >= 4 and engine.cylinderCount <= 6))\n}",
    "package FuelSystem {\n    block FuelManagementSystem {\n        part fuelTank : FuelTank;\n        part engine : Engine;\n        connector fuelSupply : fuelTank.supplyPort -> engine.supplyPort;\n        connector fuelReturn : engine.returnPort -> fuelTank.returnPort;\n        activity ManageFuelFlow;\n        activity MonitorAndManageTemperature;\n    }\n\n    block FuelTank {\n        port supplyPort : out FuelInterface;\n        port returnPort : in FuelInterface;\n    }\n\n    block Engine {\n        port supplyPort : in FuelInterface;\n        port returnPort : out FuelInterface;\n    }\n\n    block FuelInterface;\n}",
    "package VehicleStructure {\n    block Vehicle {\n        value property mass: Real (unit: 'kg');\n\n        part front: FrontAxleAssembly[1];\n        part rear: RearAxleAssembly[1];\n    }\n\n    block AxleAssembly {\n        part leftWheel: Wheel[1];\n        part rightWheel: Wheel[1];\n    }\n\n    block FrontAxleAssembly :> AxleAssembly {\n        part frontAxle: FrontAxle[1];\n    }\n\n    block RearAxleAssembly :> AxleAssembly {\n        part rearAxle: RearAxle[1];\n    }\n\n    block Axle {}\n\n    block FrontAxle :> Axle {\n        value property steeringAngle: Real (unit: 'deg')?;\n    }\n\n    block RearAxle :> Axle {}\n\n    block Wheel {}\n}"
]