[
    "package 'VehicleSystem' {\n  \n  class Vehicle {\n    \n    attribute def mass : Real;\n    attribute def status : VehicleStatus;\n    part engine : Engine;\n    part driver : Driver;\n    \n    \n  }\n  \n  class VehicleStatus {\n    attribute def gearSetting : GearSetting;\n    attribute def acceleratorPosition : Real;\n  }\n  \n  class Engine {\n    \n  }\n  \n  class Driver {\n    \n  }\n  \n  enum GearSetting {\n    Park,\n    Neutral,\n    Drive,\n    Reverse\n  }\n}",
    "package 'VehicleSystem' {\n  class Vehicle {\n    attribute vehicleType : VehicleType;\n    part driver : Personnel;\n    part engine : Engine;\n  }\n  class ManuallyOperatedVehicle {\n    extends Vehicle;\n  }\n  class PoweredVehicle {\n    extends Vehicle;\n  }\n  class ManuallyOperatedPoweredVehicle {\n    extends Vehicle;\n  }\n  class Personnel {\n  }\n  class Engine {\n  }\n  enum VehicleType {\n    ManuallyOperated;\n    Powered;\n    ManuallyOperatedPowered;\n  }\n  relationship hasDriver {\n    from Vehicle to Personnel;\n  }\n  relationship hasEngine {\n    from Vehicle to Engine;\n  }\n}",
    "package 'VehicleStructure' {\n  \n  class Vehicle {\n    \n    property quantity : Integer = 1;\n    \n    part engine : Engine;\n    part transmission : Transmission;\n    part wheels : Wheel[4];\n    \n  }\n  \n  class VehicleComponent {\n    \n    \n  }\n  \n  class Engine extends VehicleComponent {\n    \n    \n  }\n  \n  class Transmission extends VehicleComponent {\n    \n    \n  }\n  \n  class Wheel extends VehicleComponent {\n    \n    \n  }\n  \n}",
    "package 'VehicleSystem' {\n  class Vehicle {\n    attribute def type : VehicleType;\n    part engine : Engine;\n  }\n  class SmallVehicle extends Vehicle {\n    attribute def type : SmallVehicleType;\n  }\n  class LargeVehicle extends Vehicle {\n    attribute def type : LargeVehicleType;\n  }\n  class Engine {\n    part cylinderBlock : CylinderBlock;\n  }\n  class CylinderBlock {\n    attribute def numCylinders : Integer;\n  }\n  class SmallEngine extends Engine {\n    attribute def numCylinders : 4;\n  }\n  class LargeEngine extends Engine {\n    attribute def numCylinders : 6;\n  }\n  enum VehicleType {\n    SmallVehicle;\n    LargeVehicle;\n  }\n  enum SmallVehicleType {\n    SmallCar;\n    SmallTruck;\n  }\n  enum LargeVehicleType {\n    LargeCar;\n    LargeTruck;\n  }\n}",
    "package 'TrafficSignalSystem' {\n  \n  enum TrafficLightColor {\n    Green\n    Yellow\n    Red\n  }\n  \n  block TrafficSignal {\n    \n    attribute color : TrafficLightColor;\n    \n    part greenSignal {\n      block TrafficSignalComponent {\n        attribute color : TrafficLightColor = Green;\n      }\n    }\n  }\n}",
    "package 'InformationClassification' {\n  \n  enum InformationLevel {\n    Unclassified,\n    Confidential,\n    Secret\n  }\n  \n  enum GradeLevel {\n    A,\n    B,\n    C,\n    D,\n    F\n  }\n  \n  attribute def InformationLevelCode {\n    type: string;\n  }\n  \n  attribute def InformationLevelColor {\n    type: string;\n  }\n  \n  attribute def GradeLevelScore {\n    type: real;\n  }\n  \n  block Information {\n    \n    part InformationLevel {\n      type: InformationLevel;\n      \n      property InformationLevelCode : InformationLevelCode;\n      property InformationLevelColor : InformationLevelColor;\n    }\n    \n    part GradeLevel {\n      type: GradeLevel;\n      \n      property GradeLevelScore : GradeLevelScore;\n    }\n  }\n  \n  block UnclassifiedInformation {\n    extends Information;\n    \n    property InformationLevelCode : \"uncl\";\n    property InformationLevelColor : \"green\";\n  }\n  \n  block ConfidentialInformation {\n    extends Information;\n",
    "package 'VehicleEngine' {\n  class Vehicle {\n    property type : String;\n    part engine : Engine;\n  }\n  class Engine {\n    property cylinderCount : Integer;\n    part cylinder : Cylinder;\n  }\n  class Cylinder {\n    property id : Integer;\n  }\n  constraint Engine.cylinderCount >= 4;\n  constraint Engine.cylinderCount <= 6;\n  block SmallVehicle {\n    Vehicle vehicle;\n    Engine engine;\n    constraint engine.cylinderCount = 4;\n  }\n  block LargeVehicle {\n    Vehicle vehicle;\n    Engine engine;\n    constraint engine.cylinderCount = 6;\n  }\n}",
    "package 'VehicleModeling' {\n  \n  class Vehicle {\n    \n    attribute fuelTank : FuelTank;\n    attribute driver : Driver;\n    attribute qualityAttributes : QualityAttributes;\n  }\n  \n  class FuelTank {\n    attribute fuelType : FuelType;\n    attribute capacity : Quantity;\n  }\n  \n  class Driver {\n    attribute name : String;\n    attribute license : String;\n  }\n  \n  class QualityAttributes {\n    attribute reliability : Real;\n    attribute safety : Real;\n    attribute performance : Real;\n  }\n  \n  class FuelType {\n    attribute name : String;\n  }\n  \n  class Personnel {\n    attribute name : String;\n  }\n  \n  class Fuel {\n    attribute type : FuelType;\n    attribute quantity : Quantity;\n  }\n  \n  \n}",
    "package 'AutomobileWheelAssembly' {\n  part WheelBearingUnit {\n    \n  }\n  part Tire {\n    \n  }\n  part Bead {\n    \n  }\n  part Hub {\n    \n  }\n  part Rim {\n    \n  }\n  part BoltMountingHole {\n    \n  }\n  part ThreadedHole {\n    \n  }\n  part Bolt {\n    \n  }\n  part connection {\n    connector boltConnection {\n      from part: BoltMountingHole to part: ThreadedHole\n      using part: Bolt\n    }\n  }\n  part assembly {\n    part tireAssembly {\n      part tire {\n        \n      }\n      part bead {\n        \n      }\n      part rim {\n        \n      }\n      connector tireBeadConnection {\n        from part: tire.bead to part: rim.rim\n      }\n    }\n    part hubAssembly {\n      part hub {\n        \n      }\n      part wheelBearingUnit {\n        \n      }\n      connector hubWheelBearingConnection {\n        from part: hub.hub to part: wheelBearingUnit.wheelBearingUnit",
    "package 'FuelManagementSystem' {\n  attribute def FuelLevel;\n  attribute def ReturnFlowRate;\n  attribute def Temperature;\n  port def FuelSupplyPort {\n    out fuel: FuelLevel;\n  }\n  port def ReturnFuelPort {\n    in returnFuel: FuelLevel;\n  }\n  port def TemperaturePort {\n    out temp: Temperature;\n  }\n  part context {\n    part fuelTank {\n      port fuelSupplyPort: FuelSupplyPort;\n      port returnFuelPort: ReturnFuelPort;\n      port temperaturePort: TemperaturePort;\n      action supplyFuel {\n        out fuel = fuelSupplyPort.fuel;\n      }\n      action receiveReturnFuel {\n        in returnFuel = returnFuelPort.returnFuel;\n      }\n      action measureTemperature {\n        out temp = temperaturePort.temp;\n      }\n    }\n    part engine {\n      port fuelSupplyPort: ~FuelSupplyPort;\n      port returnFuelPort: ~ReturnFuelPort;\n      action consumeFuel {\n        in fuel = fuelSupplyPort.fuel;\n      }\n      action returnExcessFuel {\n        out returnFuel",
    "package 'VehicleConfiguration' {\n  \n  class Vehicle {\n    attribute mass : Real = 1750;\n    part frontAxle : FrontAxle;\n    part rearAxle : RearAxle;\n  }\n  \n  class FrontAxle {\n    attribute mass : Real;\n    part tires : OrderedSet[Tire];\n  }\n  \n  class RearAxle {\n    attribute mass : Real;\n    part tires : OrderedSet[Tire];\n  }\n  \n  class Tire {\n    attribute mass : Real;\n    attribute name : String;\n  }\n  \n  class VehicleVariant {\n    attribute name : String;\n    block vehicle : Vehicle;\n  }\n  \n  VehicleVariant vehicle1_c1 {\n    name = \"vehicle1_c1\";\n    vehicle.mass = 2000;\n    vehicle.frontAxle.steeringAngle = 30;\n  }\n}",
    "package 'VehicleTrailerCoupling' {\n  \n  class Vehicle {\n    part hitchReference : Hitch;\n  }\n  \n  class Trailer {\n    part connectorReference : Hitch;\n  }\n  \n  class Hitch {\n    part ball : Ball;\n  }\n  \n  class Ball {\n  }\n  \n}\n```",
    "package 'VehiclePowerTransmission' {\n  \n  part Engine {\n    port fuelCommandPort: { in fuelCommand: FuelCommand; }\n    port powerPort: { out power: Power; }\n    port clutchPort: { in clutchSignal: ClutchSignal; }\n  }\n  \n  part Transmission {\n    port powerPort: { in power: Power; }\n    port clutchPort: { in clutchSignal: ClutchSignal; }\n    port outputShaftPort: { out outputShaft: OutputShaft; }\n  }\n  \n  part Clutch {\n    port clutchPort: { in clutchSignal: ClutchSignal; }\n    port engagedPort: { out engaged: Boolean; }\n  }\n  \n  part Driveshaft {\n    port inputShaftPort: { in inputShaft: OutputShaft; }\n    port outputShaftPort: { out",
    "package 'MultiArchitectureSystem' {\n  block b11 {\n    part c1 {\n      port pb {\n        signal pe;\n      }\n    }\n    part c2 {\n      port pc {\n        signal pe;\n      }\n    }\n    interface pe {\n      signal pe;\n    }\n  }\n  block b12 {\n    part c3 {\n      port pd {\n        signal pf;\n      }\n    }\n    part c4 {\n      port pc {\n        signal pf;\n      }\n    }\n    interface pf {\n      signal pf;\n    }\n  }\n  block b21 {\n    part c1 {\n      port pb {\n        signal pe;\n      }\n    }\n    part c2 {\n      port pc {",
    "package 'AutomotivePowertrain' {\n  attribute def FuelCommand;\n  attribute def EngineState;\n  attribute def Torque;\n  attribute def TransmissionState;\n  attribute def DriveshaftState;\n  port def FuelCommandPort {\n    in fuelCommand: FuelCommand;\n  }\n  port def EngineStatePort {\n    out engineState: EngineState;\n  }\n  port def TorquePort {\n    out torque: Torque;\n  }\n  port def TransmissionStatePort {\n    out transmissionState: TransmissionState;\n  }\n  port def DriveshaftStatePort {\n    out driveshaftState: DriveshaftState;\n  }\n  part context {\n    part user {\n      port fuelCommandPort: FuelCommandPort;\n      perform sendFuelCommand {\n        out fuelCommand = fuelCommandPort.fuelCommand;\n      }\n    }\n    interface userToPowertrain connect user.fuelCommandPort to powertrain.fuelCommandPort {\n      ref flow references sendFuelCommandFlow\n        from source.fuelCommand to target.fuelCommand;\n    }\n    part powertrain {\n      port fuelCommandPort: ~FuelCommandPort",
    "package 'AutomotivePowertrain' {\n  attribute def FuelControlCmd;\n  attribute def EngineRunning;\n  attribute def Torque;\n  attribute def StallSignal;\n  port def FuelControlCmdPort {\n    in fuelControlCmd: FuelControlCmd;\n  }\n  port def EngineRunningPort {\n    out engineRunning: EngineRunning;\n  }\n  port def TorquePort {\n    out torque: Torque;\n  }\n  port def StallSignalPort {\n    in stallSignal: StallSignal;\n  }\n  part context {\n    part fuelControlUnit {\n      port fuelControlCmdPort: FuelControlCmdPort;\n      perform startEngine.sendFuelControlCmd {\n        in fuelControlCmd = fuelControlCmdPort.fuelControlCmd;\n      }\n    }\n    part engine {\n      port fuelControlCmdPort: ~FuelControlCmdPort;\n      port engineRunningPort: EngineRunningPort;\n      perform startEngine.start {\n        in fuelControlCmd = fuelControlCmdPort.fuelControlCmd;\n        out engineRunning = engineRunningPort.engineRunning;\n      }\n    }\n    part torqueGenerationUnit",
    "package 'VehiclePowertrain' {\n  attribute def FuelCommand;\n  attribute def EngineOutputTorque;\n  attribute def TransmissionOutputTorque;\n  attribute def WheelTorque;\n  port def FuelCommandPort {\n    in fuelCommand: FuelCommand;\n  }\n  port def EngineOutputTorquePort {\n    out engineOutputTorque: EngineOutputTorque;\n  }\n  port def TransmissionOutputTorquePort {\n    out transmissionOutputTorque: TransmissionOutputTorque;\n  }\n  port def WheelTorquePort {\n    out wheelTorque: WheelTorque;\n  }\n  part context {\n    part driver {\n      port fuelCommandPort: FuelCommandPort;\n      perform generateEngineTorque.sendFuelCommand {\n        out fuelCommand = fuelCommandPort.fuelCommand;\n      }\n    }\n    interface driverToEngine connect driver.fuelCommandPort to engine.fuelCommandPort {\n      ref flow references generateEngineTorque.fuelCommandFlow\n        from source.fuelCommand to target.fuelCommand;\n    }\n    part engine {\n      port fuelCommandPort: ~FuelCommandPort;\n      perform generateEngineTorque.calculateEngineTorque {\n        in",
    "package 'VehicleTrailerPowerConnection' {\n\tattribute def Connected;\n\tport def VehicleHitchPort {\n\t\tout hitchBall : HitchBall;\n\t}\n\tport def TrailerCouplerPort {\n\t\tin trailerCoupler : TrailerCoupler;\n\t}\n\tpart context {\n\t\tpart vehicle {\n\t\t\tport vehicleHitchPort: VehicleHitchPort;\n\t\t}\n\t\tpart trailer {\n\t\t\tport trailerCouplerPort: TrailerCouplerPort;\n\t\t}\n\t\tinterface vehicleToTrailer connect vehicle.vehicleHitchPort to trailer.trailerCouplerPort {\n\t\t\tref flow references connectFlow\n\t\t\t\tfrom source.hitchBall to target.trailerCoupler; \n\t\t}\n\t}\n\taction connect {\n\t\taction engageHitch {\n\t\t\tin connected = Connected;\n\t\t}\n\t\tsuccession flow connectFlow from engageHitch.connected to disconnect.connected;\n\t}\n\taction disconnect {\n\t\taction disengageHitch {\n\t\t\tin connected = Connected;\n\t\t}\n\t\tsuccession flow disconnectFlow from disengageHitch.connected to connect.connected;\n\t}\n}",
    "package 'VehicleTrailerConnection' {\n  \n  class Vehicle {\n    \n    part Chassis {\n      port TowBallPort {\n        out towBall : TowBall;\n      }\n    }\n  }\n  \n  class Trailer {\n    \n    part TrailerFrame {\n      port CouplerPort {\n        in coupler : Coupler;\n      }\n    }\n  }\n  \n  class TowBall {\n    \n  }\n  \n  class Coupler {\n    \n  }\n  \n  action Connect {\n    \n    in vehicle : Vehicle;\n    in trailer : Trailer;\n    \n    block Hitching {\n      \n      require vehicle.Chassis.TowBallPort.towBall.connectedTo(trailer.TrailerFrame.CouplerPort.coupler);\n    }\n  }\n  \n  action Disconnect {\n    \n    in vehicle : Vehicle;\n    in trailer : Trailer;\n    \n    block Unhitching {\n      \n      require vehicle.Chassis.TowBallPort.towBall.disconnectedFrom(trailer.TrailerFrame.CouplerPort.coupler);\n    }\n  }\n}\n",
    "package 'TrailerConnection' {\n  block Vehicle {\n    part Chassis {\n      port TowBallPort {\n        out towBall : TowBall;\n      }\n    }\n  }\n  block Trailer {\n    part TrailerChassis {\n      port CouplerPort {\n        in coupler : Coupler;\n      }\n    }\n  }\n  block Coupler {\n    attribute def Engaged;\n    port TowBallPort {\n      in towBall : TowBall;\n    }\n  }\n  block TowBall {\n    attribute def Connected;\n  }\n  action Hitch {\n    in vehicle : Vehicle;\n    in trailer : Trailer;\n    require vehicle.Chassis.TowBallPort.towBall.Connected == false;\n    require trailer.TrailerChassis.CouplerPort.coupler.Engaged == false;\n    effect vehicle.Chassis.TowBallPort.towBall.Connected = true;\n    effect trailer.TrailerChassis.CouplerPort.coupler.Engaged = true;\n  }\n  action UnHitch {\n    in vehicle : Vehicle;\n    in trailer : Trailer;\n    require vehicle.Chassis.TowBall",
    "package 'FuelSystem' {\n  block FuelTank {\n    port FuelSupplyPort {\n      out fuelFlow : Flow;\n    }\n    port FuelReturnPort {\n      in fuelFlow : Flow;\n    }\n    attribute FuelLevel {\n      type Real;\n    }\n    attribute Temperature {\n      type Real;\n    }\n  }\n  block Engine {\n    port FuelSupplyPort {\n      in fuelFlow : Flow;\n    }\n    port FuelReturnPort {\n      out fuelFlow : Flow;\n    }\n    attribute Temperature {\n      type Real;\n    }\n  }\n  interface FuelSystemInterface {\n    part FuelTankPort {\n      ref FuelTank.FuelSupplyPort;\n    }\n    part EnginePort {\n      ref Engine.FuelSupplyPort;\n    }\n  }\n  connector FuelSupplyConnector {\n    end1 FuelTankPort;\n    end2 EnginePort;\n  }\n  connector FuelReturnConnector {\n    end1 EnginePort;\n    end2 FuelTankPort;\n  }\n}",
    "package 'FuelDeliverySystem' {\n  attribute def FuelLevel;\n  attribute def Capacity;\n  block def StorageTank {\n    port def FuelOutPort {\n      out fuel: FuelLevel;\n    }\n  }\n  block def FuelPump {\n    port def FuelInPort {\n      in fuel: FuelLevel;\n    }\n    port def FuelOutPort {\n      out fuel: FuelLevel;\n    }\n  }\n  block def VehicleFuelTank {\n    port def FuelInPort {\n      in fuel: FuelLevel;\n    }\n    attribute FuelLevel;\n    attribute Capacity;\n  }\n  flow def FuelFlow {\n    source StorageTank.FuelOutPort;\n    target FuelPump.FuelInPort;\n  }\n  flow def FuelDeliveryFlow {\n    source FuelPump.FuelOutPort;\n    target VehicleFuelTank.FuelInPort;\n  }\n}",
    "package 'AutomobileAssembly' {\n  block VehicleAssembly {\n    part VehicleChassis {\n      \n    }\n    part Gearbox {\n      \n    }\n    part Engine {\n      \n    }\n  }\n  block GearboxInstallation {\n    input VehicleAssembly {\n      \n    }\n    output VehicleWithGearbox {\n      \n    }\n    \n  }\n  block EngineInstallation {\n    input VehicleWithGearbox {\n      \n    }\n    output FullyAssembledVehicle {\n      \n    }\n    \n  }\n  \n}",
    "package 'VehicleControlSystem' {\n  state Off {\n    transition Starting when brakePressed and startSignal;\n  }\n  state Starting {\n    transition Running when vehicleOn;\n  }\n  state Running {\n    transition Off when vehicleOff;\n    action selfCheck {\n      }\n    action supplyPower {\n      }\n    action applyParkingBrake {\n      }\n  }\n  state HealthManagement {\n    transition Off when restoreToNormal;\n  }\n  state Degraded {\n    transition HealthManagement when restoreToNormal;\n  }\n  state Maintenance {\n    transition Running when maintenanceComplete;\n  }\n  attribute def temperature;\n  guard def overTemperature {\n    temperature > safetyThreshold;\n  }\n  action detectTemperature {",
    "package 'VehicleSystem' {\n  attribute def VehicleStatus;\n  attribute def Temperature;\n  attribute def FuelLevel;\n  attribute def MaintenanceInterval;\n  attribute def TemperatureThreshold;\n  port def VehicleStatusPort {\n    out vehicleStatus: VehicleStatus;\n  }\n  port def TemperaturePort {\n    out temperature: Temperature;\n  }\n  port def FuelLevelPort {\n    out fuelLevel: FuelLevel;\n  }\n  port def MaintenanceIntervalPort {\n    out maintenanceInterval: MaintenanceInterval;\n  }\n  port def TemperatureThresholdPort {\n    out temperatureThreshold: TemperatureThreshold;\n  }\n  part context {\n    part vehicle {\n      port vehicleStatusPort: VehicleStatusPort;\n      port temperaturePort: TemperaturePort;\n      port fuelLevelPort: FuelLevelPort;\n      perform startup {\n        in brakePressed: Boolean;\n        in startSignal: Boolean;\n        out vehicleStatus = vehicleStatusPort.vehicleStatus;\n      }\n      perform shutdown {\n        out vehicleStatus = vehicleStatusPort.vehicleStatus;\n      }\n      perform selfInspection {\n        out",
    "package 'VehicleSimulation' {\n\tattribute def VehicleMass;\n\tattribute def VehiclePosition;\n\tattribute def VehicleVelocity;\n\tattribute def VehicleAcceleration;\n\tattribute def RoadSlope;\n\tattribute def SurfaceFrictionCoefficient;\n\tattribute def VehicleState;\n\tport def VehicleStatePort {\n\t\tout vehicleState: VehicleState;\n\t}\n\tpart context {\n\t\tpart user {\n\t\t\tport vehicleStatePort: VehicleStatePort;\n\t\t\tperform defineVehicleParameters {\n\t\t\t\tin vehicleMass = VehicleMass;\n\t\t\t\tin vehiclePosition = VehiclePosition;\n\t\t\t\tin vehicleVelocity = VehicleVelocity;\n\t\t\t\tin vehicleAcceleration = VehicleAcceleration;\n\t\t\t\tin roadSlope = RoadSlope;\n\t\t\t\tin surfaceFrictionCoefficient = SurfaceFrictionCoefficient;\n\t\t\t}\n\t\t}\n\t\tinterface userToSimulation connect user.vehicleStatePort to simulation.vehicleStatePort {\n\t\t\tref flow references defineVehicleParameters.vehicleStateFlow\n\t\t\t\tfrom source.vehicleState to target.vehicleState; \n\t\t}\n\t\tpart simulation {\n\t\t\tport vehicleStatePort: ~VehicleStatePort;\n\t\t\tperform simulateVehicleDynamics {\n\t\t\t\tin vehicleMass = VehicleMass;\n\t\t\t\tin vehiclePosition",
    "package 'AutomotiveConfigurationManagement' {\n  \n  block Vehicle {\n    part SubsystemA {\n      select ConfigurationA : ConfigurationA\n      select ConfigurationB : ConfigurationB\n    }\n    part SubsystemB {\n      select ConfigurationA : ConfigurationA\n      select ConfigurationB : ConfigurationB\n    }\n  }\n  \n  block ConfigurationA {\n    part SubsystemA {\n      part Component1\n      part Component2\n    }\n    part SubsystemB {\n      part Component4\n      part Component5\n    }\n  }\n  \n  block ConfigurationB {\n    part SubsystemA {\n      part Component2\n      part Component3\n    }\n    part SubsystemB {\n      part Component4\n      part Component5\n    }\n  }\n  \n  constraint",
    "package 'ModularVehiclePlatform' {\n  \n  block SubsystemA {\n    \n    part part1 {\n      port p1: Port;\n    }\n    \n    part part2 {\n      port p1: Port;\n    }\n    \n    part part3 {\n      port p1: Port;\n    }\n    \n    variant VariantA1 {\n      \n    }\n    \n    variant VariantA2 {\n      \n    }\n  }\n  \n  block SubsystemB {\n    \n    part part4 {\n      \n    }\n    \n    part part5 {\n      port p2: Port;\n      \n      variant VariantB1 {\n        \n      }\n      \n      variant VariantB2 {\n        \n      }\n    }\n    \n    part part6 {\n      \n    }\n    \n    variant VariantB1 {\n      \n    }\n    \n    variant VariantB2 {\n      \n    }\n  }\n  \n  block VehicleConfigA",
    "package 'VehicleConfigurationSystem' {\n  \n  block Engine {\n    property EngineType : String;\n    property CylinderCount : Integer;\n    property PowerOutput : Real;\n  }\n  \n  block Transmission {\n    property TransmissionType : String;\n    property GearCount : Integer;\n  }\n  \n  block Wheel {\n    property WheelType : String;\n    property RimWidth : Real;\n  }\n  \n  block VehicleModel {\n    property ModelName : String;\n    part engine : Engine;\n    part transmission : Transmission;\n    part wheels : Wheel;\n  }\n  \n  block Configuration {\n    part vehicleModel : VehicleModel;\n    constraint PerformanceRequirement {\n      if (vehicleModel.engine.CylinderCount = 6) then\n        vehicleModel.transmission.TransmissionType = \"Automatic\";\n      if (vehicleModel.engine.CylinderCount = 4) then\n        vehicleModel.transmission.TransmissionType = \"Manual\";\n    }\n    constraint Compatibility {\n      if (vehicleModel.engine.PowerOutput > 200) then\n        vehicleModel.wheels.RimWidth > 7;",
    "package 'AutomotiveSystem' {\n  \n  class Vehicle {\n    attribute def mass : Real;\n    attribute def fuelStatus : FuelStatus;\n    \n    block VehicleMassLimit {\n      attribute def maxMass : Real;\n    }\n    \n    part engine : Engine;\n    part transmission : Transmission;\n    \n    constraint mass <= VehicleMassLimit.maxMass;\n  }\n  \n  class Engine {\n    attribute def torque : Real;\n    \n    port def driveInterface : DriveInterface;\n  }\n  \n  class Transmission {\n    \n  }\n  \n  class DriveInterface {\n    \n  }\n  \n  enum FuelStatus {\n    Empty;\n    Full;\n  }\n  \n  class MassGrade {\n    attribute def mass : Real;\n  }\n  \n  requirement def R1 {\n    text \"Vehicle mass must comply with the corresponding maximum mass limitations.\";\n  }\n  \n  requirement def R",
    "package 'VehicleMassComplianceSystem' {\n  attribute def MaxPermissibleMass;\n  attribute def MeasuredMass;\n  port def WeighingEquipmentPort {\n    in measuredMass: MeasuredMass;\n  }\n  port def OperatorPort {\n    out complianceStatus: ComplianceStatus;\n  }\n  part context {\n    part weighingEquipment {\n      port weighingEquipmentPort: WeighingEquipmentPort;\n    }\n    part operator {\n      port operatorPort: OperatorPort;\n    }\n    part vehicle {\n      attribute def actualMass: MeasuredMass;\n    }\n  }\n  action testVehicle {\n    action measureMass {\n      in vehicle = vehicle;\n      out measuredMass = vehicle.actualMass;\n    }\n    succession flow massMeasurementFlow from measureMass.measuredMass to compareMass.measuredMass;\n    action compareMass {\n      in measuredMass;\n      in maxPermissibleMass = MaxPermissibleMass;\n      out complianceStatus: ComplianceStatus;\n    }\n    succession flow complianceDeterminationFlow from compareMass.complianceStatus to operatorPort.complianceStatus;\n  }\n}",
    "package 'WaterSupplyNetwork' {\n  block SpigotBank {\n    port hotWaterOut : FlowPort {\n      out hotWaterFlow : Flow;\n    }\n    port coldWaterOut : FlowPort {\n      out coldWaterFlow : Flow;\n    }\n  }\n  block Spigot {\n    port hotWaterIn : FlowPort {\n      in hotWaterFlow : Flow;\n    }\n    port coldWaterIn : FlowPort {\n      in coldWaterFlow : Flow;\n    }\n    port hotWaterOut : FlowPort {\n      out hotWaterFlow : Flow;\n    }\n    port coldWaterOut : FlowPort {\n      out coldWaterFlow : Flow;\n    }\n  }\n  block Faucet {\n    port hotWaterIn : FlowPort {\n      in hotWaterFlow : Flow;\n    }\n    port coldWaterIn : FlowPort {\n      in coldWaterFlow : Flow;\n    }\n  }\n  block FaucetInlet {\n    port hotWaterIn : FlowPort {\n      in hotWaterFlow : Flow;\n    }\n    port coldWaterIn : FlowPort {\n",
    "package 'VehicleQualityAnalysisSystem' {\n  \n  attribute def VehicleMass;\n  \n  block Vehicle {\n    part Engine {\n      \n    }\n    part Transmission {\n      \n    }\n    part FrontAxleAssembly {\n      \n    }\n    part RearAxleAssembly {\n      \n    }\n  }\n  \n  block QualityDataInput {\n    \n  }\n  \n  block QualityAnalysisRequirements {\n    \n  }\n  \n  block AnalysisUseCases {\n    \n  }\n  \n  block AnalysisObjectives {\n    \n  }\n  \n  block AnalysisTasksAndPlans {\n    \n  }\n  \n  action AggregateVehicleMass {\n    in componentMasses: VehicleMass;\n    out vehicleMass: VehicleMass;\n  }\n  \n  action DefineQualityAnalysisRequirements {\n    \n  }\n  \n  action FormulateAnalysisUseCases {\n    \n  }\n  \n  action GenerateAnalysisTasksAndPlans {\n    in analysisObjectives: AnalysisObjectives;\n    out analysisTasksAndPlans: AnalysisTasksAndPlans;\n  }\n  \n  action EvaluateVehicleQuality {\n    ",
    "package 'VehiclePowertrainConfiguration' {\n  \n  attribute def EngineType;\n  attribute def PerformanceIndicator;\n  \n  enum EngineType {\n    FourCylinder;\n    SixCylinder;\n    // Add more engine types as needed\n  }\n  \n  enum PerformanceIndicator {\n    Power;\n    Mass;\n    Efficiency;\n    Reliability;\n    Cost;\n  }\n  \n  block Engine {\n    part Cylinder;\n    part Piston;\n    part ConnectingRod;\n    part Crankshaft;\n  }\n  \n  block EngineConfiguration {\n    part Engine;\n    \n    operation assembleEngine {\n      in EngineType engineType;\n      out Engine engine;\n    }\n  }\n  \n  block TradeOffAnalysis {\n    operation analyzeTradeOffs {\n      in EngineConfiguration engineConfiguration;\n      out PerformanceIndicator optimalIndicator;\n    }\n  }\n  \n  block EvaluationModel {\n    operation evaluateEngine {\n      in EngineConfiguration engineConfiguration;\n      out PerformanceIndicator performanceData;\n    }\n  }\n  \n  block RecommendationEngine {\n    operation recommendEngine {\n      in Engine",
    "package 'FuelEconomySystem' {\n  attribute def UrbanRangeRequirement {\n    value: 25;\n    unit: 'miles/gallon';\n  }\n  attribute def HighwayRangeRequirement {\n    value: 30;\n    unit: 'miles/gallon';\n  }\n  attribute def Load {\n    value: 1000;\n    unit: 'pounds';\n  }\n  block Vehicle {\n    part Powertrain {\n      \n    }\n    part Load {\n      \n    }\n    port OperatingConditionsPort {\n      in UrbanConditions: UrbanConditionsType;\n      in HighwayConditions: HighwayConditionsType;\n    }\n  }\n  block FuelEconomyTest {\n    input Vehicle;\n    input UrbanConditions;\n    input HighwayConditions;\n    input Load;\n    output UrbanFuelEconomy: 'miles/gallon';\n    output HighwayFuelEconomy: 'miles/gallon';\n  }\n  action AnalyzeFuelEconomy {\n    input Vehicle;\n    input UrbanConditions;\n    input HighwayConditions;\n    input Load;\n    output UrbanFuelEconomy: 'miles/gallon';\n    output HighwayFuelEconomy:",
    "package 'VehicleDynamicsSimulator' {\n  attribute def VehicleMass;\n  attribute def InitialPosition;\n  attribute def InitialVelocity;\n  attribute def PowerOutputData;\n  attribute def TimeStep;\n  port def InputPort {\n    in vehicleMass: VehicleMass;\n    in initialPosition: InitialPosition;\n    in initialVelocity: InitialVelocity;\n    in powerOutputData: PowerOutputData;\n    in timeStep: TimeStep;\n  }\n  port def OutputPort {\n    out accelerationSequence: Sequence[Acceleration];\n    out velocitySequence: Sequence[Velocity];\n    out positionSequence: Sequence[Position];\n  }\n  part context {\n    part user {\n      port inputPort: InputPort;\n    }\n    part simulator {\n      port inputPort: ~InputPort;\n      port outputPort: ~OutputPort;\n      perform simulateVehicleMotion {\n        in vehicleMass = inputPort.vehicleMass;\n        in initialPosition = inputPort.initialPosition;\n        in initialVelocity = inputPort.initialVelocity;\n        in powerOutputData = inputPort.powerOutputData;\n        in timeStep = inputPort",
    "package 'Vehicle' {\n  class Vehicle {\n    property mass : Real = 2500;\n    part frontAxleAssembly;\n    part rearAxleAssembly;\n  }\n  class AxleAssembly {\n    property mass : Real;\n  }\n  class FrontAxleAssembly extends AxleAssembly {\n    part frontAxle;\n    part frontWheel1;\n    part frontWheel2;\n    property steeringAngle : Angle;\n  }\n  class RearAxleAssembly extends AxleAssembly {\n    part rearAxle;\n    part rearWheel1;\n    part rearWheel2;\n  }\n}",
    "package 'VehicleSafetySecuritySystem' {\n  \n  class Vehicle {\n    \n    property mandatorySafetyFeatures : String;\n    property optionalSafetyFeatures : String;\n    property securityFeatures : String;\n    \n    part seatBelt : SeatBelt;\n    part airbag : Airbag;\n    part antiLockBrakingSystem : AntiLockBrakingSystem;\n    part bumper : Bumper;\n    part alarm : Alarm;\n    part keylessEntrySystem : KeylessEntrySystem;\n  }\n  \n  class SeatBelt {\n    property type : String;\n  }\n  \n  class Airbag {\n    property type : String;\n  }\n  \n  class AntiLockBrakingSystem {\n    property type : String;\n  }\n  \n  class Bumper {\n    property type : String;\n  }\n  \n  class Alarm {\n    property type : String;\n  }\n  \n  class KeylessEntrySystem {\n    property type : String;\n  }\n  \n  block SafetySecurityDisplay {\n    port displayData : DisplayData;\n  }\n  \n  class DisplayData {\n    property safetyFeatures",
    "package 'System' {\n  block ApplicationLayer {\n    port servicePort: ServiceLayer;\n    require servicePort.serviceFunction;\n  }\n  block ServiceLayer {\n    port dataPort: DataLayer;\n    port applicationPort: ApplicationLayer;\n    require dataPort.getData;\n    require dataPort.saveData;\n    provide serviceFunction;\n  }\n  block DataLayer {\n    port servicePort: ServiceLayer;\n    provide getData;\n    provide saveData;\n  }\n  attribute x;\n  attribute y;\n  attribute z {\n    dependsOn x;\n    dependsOn y;\n  }\n}",
    "package 'TorqueGenerationSystem' {\n  attribute def Torque;\n  port def TorquePort {\n    out torque: Torque;\n  }\n  part context {\n    part logicLayer {\n      port torquePort: TorquePort;\n      perform generateTorque {\n        out torque = torquePort.torque;\n      }\n    }\n    part physicalLayer {\n      port torquePort: ~TorquePort;\n      perform transmitTorque {\n        in torque = torquePort.torque;\n      }\n    }\n    interface logicToPhysical connect logicLayer.torquePort to physicalLayer.torquePort {\n      ref flow references generateTorqueFlow\n        from source.torque to target.torque;\n    }\n  }\n  constraint TorqueGreaterThanZero {\n    torque > 0;\n  }\n}",
    "package 'System' {\n  block System {\n    part TorqueGenerator {\n      property Function;\n    }\n    part Powertrain {\n      part Engine {\n        property TorqueGeneration;\n      }\n    }\n    connector PowerTransmission {\n      end PowerOutput;\n      end PowerInput;\n    }\n    relationship mapsTo {\n      from TorqueGenerator.Function to Engine.TorqueGeneration;\n    }\n  }\n}",
    "package 'VehicleSafetyAndAntitheft' {\n  block Vehicle {\n    part Body {\n      part SeatBelt {\n        property Mandatory : Boolean = true;\n      }\n      part Bumper {\n        property Mandatory : Boolean = true;\n      }\n    }\n    part Interior {\n      part SeatBelt {\n        property Mandatory : Boolean = true;\n      }\n    }\n    part DriverAirbag {\n      property SafetyFeature : Boolean = true;\n      property Mandatory : Boolean = false;\n    }\n    part AntiLockBrakingSystem {\n      property SafetyFeature : Boolean = true;\n      property Mandatory : Boolean = false;\n    }\n    part AlarmSystem {\n      property AntiTheftFeature : Boolean = true;\n    }\n    part KeylessEntrySystem {\n      property AntiTheftFeature : Boolean = true;\n    }\n  }\n}\n\n\n\n",
    "package 'FuelSystem' {\n  attribute def FuelLevel;\n  attribute def FuelTemperature;\n  port def FuelInPort {\n    in fuelIn : Fuel;\n  }\n  port def FuelOutPort {\n    out fuelOut : Fuel;\n  }\n  port def FuelReturnPort {\n    in fuelReturn : Fuel;\n  }\n  port def TemperaturePort {\n    out temperature: FuelTemperature;\n  }\n  part context {\n    part vehicle {\n      port fuelInPort: FuelInPort;\n      port fuelOutPort: FuelOutPort;\n      port fuelReturnPort: FuelReturnPort;\n      port temperaturePort: TemperaturePort;\n    }\n    part fuelTankAssembly {\n      part fuelTank {\n        attribute fuelLevel: FuelLevel;\n      }\n      part fuelPump {\n        port fuelInPort: FuelInPort;\n        port fuelOutPort: FuelOutPort;\n        port fuelReturnPort: FuelReturnPort;\n        perform pressurizeFuel {\n          in fuelIn = fuelInPort.fuelIn;\n          out fuelOut = fuelOutPort.fuelOut;\n          out fuel",
    "package 'VehicleSafetySecurity' {\n  attribute def SeatBeltCount;\n  attribute def AirbagInstalled;\n  attribute def AntiTheftAlarmInstalled;\n  attribute def BumperInstalled;\n  attribute def KeylessEntryInstalled;\n  attribute def WheelCount;\n  attribute def ABSInstalled;\n  part context {\n    part vehicle {\n      port seatBeltPort {\n        out seatBeltCount: SeatBeltCount;\n      }\n      port airbagPort {\n        out airbagInstalled: AirbagInstalled;\n      }\n      port antiTheftAlarmPort {\n        out antiTheftAlarmInstalled: AntiTheftAlarmInstalled;\n      }\n      port bumperPort {\n        out bumperInstalled: BumperInstalled;\n      }\n      port keylessEntryPort {\n        out keylessEntryInstalled: KeylessEntryInstalled;\n      }\n      port wheelPort {\n        out wheelCount: WheelCount;\n      }\n      port absPort {\n        out absInstalled: ABSInstalled;\n      }\n    }\n    interface vehicleToSystem connect vehicle.seatBeltPort to system.seatBeltPort {\n      ref flow references vehicleSafetySecurity.seatBeltFlow\n        from source",
    "package 'VehicleSafetyAndSecurity' {\n  block Vehicle {\n    part Interior {\n      block AlarmSystem;\n      block SeatBelts;\n      block FrontRowSeats;\n      block DriversAirbag;\n    }\n    part BodyAssembly {\n      block VehicleBody;\n      block Bumper;\n      block KeylessEntrySystem;\n    }\n  }\n  requirement SafetyFeatures {\n    text \"The safety features are primarily reflected in the configuration of seat belts, airbags, and bumpers, which enhance the protection of the driver and passengers during driving.\"\n  }\n  requirement SecurityFeatures {\n    text \"The security features are realized through the installation of an onboard alarm and a keyless entry system, providing support for anti-theft and convenient access for users.\"\n  }\n  requirement SystemIntegration {\n    text \"The system integrates safety and security functions, aiming to offer users comprehensive safety protection and a convenient user experience.\"\n  }\n}",
    "package 'SecurityClassification' {\n  attribute def SecurityClassification;\n  part component {\n    port securityClassificationPort {\n      out securityClassification: SecurityClassification;\n    }\n  }\n  action classifyComponent {\n    in component: component;\n    out securityClassification: SecurityClassification;\n  }\n}",
    "package 'AutomotiveECU' {\n  block VCU {\n    port CANBusIF : BusIF;\n    part BusIF {\n      port CANBus : BusIF;\n    }\n  }\n  block ECU {\n    port CANBusIF : BusIF;\n    part BusIF {\n      port CANBus : BusIF;\n    }\n  }\n  block CANBus {\n    port CANBusIF : BusIF;\n  }\n  block Sensor {\n    port SensorData : Data;\n  }\n  interface BusIF {\n    port CANBus : BusIF;\n  }\n  interface Data {\n    port SensorData : Data;\n  }\n  relationship VCU.CANBusIF connects to CANBus.CANBusIF;\n  relationship ECU.CANBusIF connects to CANBus.CANBusIF;\n  relationship Sensor.SensorData connects to VCU.CANBusIF;\n}\n\n\n\n",
    "package 'BloodGlucoseMeter' {\n  attribute def BatteryStatus;\n  attribute def MeasurementStatus;\n  port def BatteryStatusPort {\n    out batteryStatus: BatteryStatus;\n  }\n  port def MeasurementStatusPort {\n    out measurementStatus: MeasurementStatus;\n  }\n  part context {\n    part user {\n      port batteryStatusPort: BatteryStatusPort;\n      port measurementStatusPort: MeasurementStatusPort;\n      perform checkBatteryStatus {\n        out batteryStatus = batteryStatusPort.batteryStatus;\n      }\n      perform checkMeasurementStatus {\n        out measurementStatus = measurementStatusPort.measurementStatus;\n      }\n    }\n    interface userToSystem connect user.batteryStatusPort to system.batteryStatusPort {\n      ref flow references checkBatteryStatus.batteryStatusFlow\n        from source.batteryStatus to target.batteryStatus;\n    }\n    interface userToSystem connect user.measurementStatusPort to system.measurementStatusPort {\n      ref flow references checkMeasurementStatus.measurementStatusFlow\n        from source.measurementStatus to target.measurementStatus;\n    }\n    part system {\n      port batteryStatusPort: ~BatteryStatusPort",
    "package 'Constants' {\n  constant def E { value = 2.718281828459045; unit = '1'; }\n  constant def PI { value = 3.141592653589793; unit = '1'; }\n  constant def SpeedOfLight { value = 299792458; unit = 'm/s'; }\n  constant def FineStructureConstant { value = 1/137.035999084; unit = '1'; }\n  constant def ElectronToProtonMassRatio { value = 1836.15267343; unit = '1'; }\n  constant def GravitationalAcceleration { value = 9.80665; unit = 'm/s^2'; }\n  constant def AmplifierGainX { value = 10; unit = 'dB'; }\n}",
    "package 'AutomotiveComponents' {\n  class Tire {\n    attribute manufacturer : String;\n    attribute rimDiameter : Real;\n    attribute width : Integer;\n  }\n  instance tire1 {\n    Tire;\n    manufacturer = \"Michelin\";\n    rimDiameter = 18.0;\n    width = 245;\n  }\n}",
    "package 'AutomotiveComponentModel' {\n  \n  class Vehicle {\n    property mass : Mass;\n    property length : Length;\n    part leftFrontWheel : Wheel;\n    part rightFrontWheel : Wheel;\n  }\n  \n  class Wheel {\n    property hubDiameter : Diameter;\n    property width : Width;\n    part tire : Tire;\n  }\n  \n  class Tire {\n    property height : Height;\n  }\n  \n  class Mass {\n    property value : Real;\n    property unit : UnitKind;\n  }\n  \n  class Length {\n    property value : Real;\n    property unit : UnitKind;\n  }\n  \n  class Diameter {\n    property value : Real;\n    property unit : UnitKind;\n  }\n  \n  class Width {\n    property value : Real;\n    property unit : UnitKind;\n  }\n  \n  class Height {\n    property value : Real;\n    property unit : UnitKind;\n  }\n  \n  class UnitKind {\n    literal SI;\n    literal Imperial;\n  }\n}",
    "package 'VehiclePowertrain' {\n  \n  block Engine {\n    ownedAttribute engineType : String {\n      value = \"FourCylinder\"\n      value = \"SixCylinder\"\n    }\n  }\n  block Transmission {\n    ownedAttribute transmissionType : String {\n      value = \"Manual\"\n      value = \"Automatic\"\n    }\n  }\n  block Vehicle {\n    ownedAttribute performanceLevel : String {\n      value = \"Standard\"\n      value = \"HighPerformance\"\n    }\n    part engine : Engine\n    part transmission : Transmission\n    constraint engineTypeConstraint {\n      if (self.performanceLevel = \"HighPerformance\") then self.engine.engineType = \"SixCylinder\"\n      else self.engine.engineType = \"FourCylinder\"\n    }\n    constraint transmissionTypeConstraint {\n      if (self.engine.engineType = \"FourCylinder\") then self.transmission.transmissionType = \"Manual\"\n      else self.transmission.transmissionType = \"Automatic\"\n    }\n  }\n}",
    "package 'AutomotiveSystem' {\n  \n  class Vehicle {\n    property mass : Real = 1200;\n    property length : Real = 4.82;\n    part wheelAssembly : WheelAssembly;\n  }\n  \n  class WheelAssembly {\n    part wheel : Wheel;\n    part brakeDisc : BrakeDisc;\n  }\n  \n  class Wheel {\n    property rimDiameter : Real = 18;\n    part tire : Tire;\n  }\n  \n  class Tire {\n    property width : Real = 0.245;\n    property height : Real = 0.045;\n    property treadDepth : Real = 6.0;\n    constraint treadDepth >= 3.5;\n    \n    derived property outerDiameter : Real = rimDiameter + 2 * height;\n  }\n  \n  class BrakeDisc {\n    property radius : Real",
    "package 'AutomotiveFuelSystem' {\n  \n  block FuelTankAssembly {\n    port FuelOutlet {\n      out fuelFlow : Flow;\n      in returnFuelFlow : Flow;\n    }\n  }\n  \n  block FuelPump {\n    part FuelTankAssembly {\n      ref fuelTankAssembly.FuelOutlet;\n    }\n    port FuelIn {\n      in fuelFlow : Flow;\n    }\n    port FuelOut {\n      out fuelFlow : Flow;\n    }\n    port ReturnFuel {\n      in returnFuelFlow : Flow;\n    }\n    \n    action PumpFuel {\n      in fuelFlow = FuelIn.fuelFlow;\n      out fuelFlow = FuelOut.fuelFlow;\n    }\n  }\n  \n  block Engine {\n    port FuelIn {\n      in fuelFlow : Flow;\n    }\n  }\n  \n  action FuelCirculation {\n    succession flow fuelFlow from FuelPump.FuelOut to Engine.FuelIn;\n    succession flow returnFuelFlow from Engine.FuelIn to FuelPump.ReturnFuel;\n  }\n  \n  block FuelTemperatureSensor {\n    ",
    "package 'PhysicalQuantitySystem' {\n  \n  class PhysicalQuantity {\n    attribute name: String;\n    attribute unit: Unit;\n  }\n  \n  class Unit {\n    attribute symbol: String;\n    attribute baseUnit: BaseUnit;\n  }\n  \n  class BaseUnit {\n    attribute name: String;\n  }\n  \n  class PhysicalQuantitySystem {\n    attribute baseUnits: BaseUnit[]\n    attribute physicalQuantities: PhysicalQuantity[]\n    \n    operation importBaseUnit(name: String) : BaseUnit\n    operation importPhysicalQuantity(name: String, unit: Unit) : PhysicalQuantity\n    operation convert(quantity1: PhysicalQuantity, quantity2: PhysicalQuantity) : PhysicalQuantity\n  }\n  \n}",
    "package 'UnitSystemLibrary' {\n  \n  block System {\n    \n    property 'ISQSupport' : Boolean;\n    property 'USCustomaryUnitsSupport' : Boolean;\n    \n    port 'Quantity' : Quantity;\n    port 'Unit' : Unit;\n    \n    action 'ConvertUnits' {\n      in 'Quantity' : Quantity;\n      in 'SourceUnit' : Unit;\n      in 'TargetUnit' : Unit;\n      out 'ConvertedQuantity' : Quantity;\n    }\n    \n    action 'ManageUnits' {\n      in 'UnitType' : UnitType;\n      in 'UnitName' : String;\n      in 'UnitSymbol' : String;\n      in 'UnitDefinition' : String;\n      out 'CreatedUnit' : Unit;\n    }\n    \n    action 'StandardizeUnits' {\n      in 'Quantity' : Quantity;\n      out 'StandardizedQuantity' : Quantity;\n    }\n  }\n  \n  block Quantity {\n    \n    property 'Value' : Real;\n    property 'Unit' : Unit;\n  }\n  \n  block Unit {\n",
    "package 'HeadlampTiltAdjustment' {\n  attribute def TiltAngle : Real;\n  constraint def TiltAngleRange {\n    TiltAngle >= 50 and TiltAngle <= 80;\n  }\n}",
    "package 'SystemDataTypes' {\n  \n  datatype UnsignedInteger {\n    constraint NonNegative: value >= 0;\n  }\n  \n  datatype UnsignedFloat {\n    constraint NonNegative: value >= 0;\n  }\n  \n  datatype DateTime {\n  }\n  \n  datatype String {\n  }\n  \n  datatype Boolean {\n  }\n  \n  enumeration Status {\n    value 'Critical' : 'red';\n    value 'Warning' : 'yellow';\n    value 'Normal' : 'green';\n  }\n  \n  datatype Diameter {\n    value 'Small' : 60;\n    value 'Medium' : 70;\n    value 'Large' : 80;\n  }\n  \n  constraint DefaultDiameter : Diameter = 'Small';\n}",
    "package 'System' {\n  class Bag {\n    ownedAttribute def elements : BagElement*;\n  }\n  class BagElement {\n    ownedAttribute def part : Part;\n  }\n  class Part {\n  }\n  class List {\n    ownedAttribute def elements : Integer*;\n  }\n  class Set {\n    ownedAttribute def elements : String*;\n  }\n  class OrderedSet {\n    ownedAttribute def elements : Person*;\n  }\n  class Person {\n  }\n  class Array {\n    ownedAttribute def elements : Real[4];\n  }\n  \n  \n}",
    "package 'TireInfo' {\n  class Tire {\n    attribute manufacturer : String;\n    attribute rimDiameter : Inch;\n    attribute tireWidth : Inch;\n    attribute installationPosition : Vector3D [0..1];\n  }\n  \n  class Manufacturer {\n    attribute name : String;\n  }\n  \n  class Inch {\n    attribute value : Real;\n  }\n  \n  class Vector3D {\n    attribute x : Real;\n    attribute y : Real;\n    attribute z : Real;\n  }\n}",
    "package 'SpacecraftTrajectory' {\n  attribute def LiftoffTime;\n  attribute def UTCLiftoffTime;\n  block def Spacecraft {\n    port def TrajectoryDataPort {\n      out trajectoryData : TrajectoryData;\n    }\n  }\n  block def TrajectoryRecorder {\n    port def TrajectoryDataPort {\n      in trajectoryData : TrajectoryData;\n    }\n  }\n  data type TrajectoryData {\n    attribute def Time : Time;\n    attribute def Position : CartesianPoint3D;\n    attribute def Velocity : CartesianVector3D;\n  }\n  data type CartesianPoint3D {\n    attribute def X : Real;\n    attribute def Y : Real;\n    attribute def Z : Real;\n  }\n  data type CartesianVector3D {\n    attribute def X : Real;\n    attribute def Y : Real;\n    attribute def Z : Real;\n  }\n  data type Time {\n    attribute def Seconds : Real;\n  }\n  action RecordTrajectory {\n    in liftoffTime : LiftoffTime;\n    in utcLiftoffTime : UTCLiftoffTime;\n    in trajectoryData : TrajectoryData;",
    "package 'AlloyManagementSystem' {\n  \n  class Material {\n    attribute name: String;\n    attribute atomicMass: Real;\n  }\n  \n  class Alloy {\n    attribute name: String;\n    part componentMaterial: Material;\n    attribute massFraction: Real;\n    attribute tensileStrength: Real;\n    \n    block composition {\n      part componentMaterial: Material;\n      attribute massFraction: Real;\n    }\n  }\n  \n  class Metal {\n    attribute name: String;\n    attribute atomicMass: Real;\n    attribute tensileStrength: Real;\n  }\n  \n  \n  \n}",
    "package 'EngineeringMaterialsDatabase' {\n  class Material {\n    attribute def atomicMass : Real;\n    attribute def composition : Composition;\n    attribute def mechanicalProperties : MechanicalProperties;\n  }\n  class Metal extends Material {\n    attribute def massFraction : Composition;\n  }\n  class Composition {\n    attribute def element : String;\n    attribute def massFraction : Real;\n  }\n  class MechanicalProperties {\n    attribute def tensileStrength : Real;\n    attribute def unit : Unit;\n  }\n  class Unit {\n    attribute def name : String;\n  }\n  class Steel_980 extends Metal {\n    attribute def ironMassFraction : Real;\n    attribute def carbonMassFraction : Real;\n    attribute def manganeseMassFraction : Real;\n    attribute def tensileStrength : Real;\n    attribute def unit : Unit;\n  }\n}",
    "package 'PubSubSystem' {\n  \n  class Publisher {\n    \n    attribute def topic: String;\n    \n    port def publishPort {\n      out message: Message;\n    }\n    \n    behavior publishMessage {\n      send message on topic;\n    }\n  }\n  \n  class Subscriber {\n    \n    attribute def topic: String;\n    \n    port def subscribePort {\n      in message: Message;\n    }\n    \n    behavior receiveMessage {\n      receive message on topic;\n    }\n  }\n  \n  class Server {\n    \n    port def publishPort {\n      in message: Message;\n    }\n    \n    port def subscribePort {\n      in topic: String;\n    }\n    \n    port def deliverPort {\n      out message: Message;\n    }\n    \n    behavior manageSubscriptions {\n      subscribe to topic;\n    }\n    \n    behavior processPublish {\n      receive message on publishPort;\n      deliver message to subscribed topics;\n    }\n  }\n  \n  class Message {\n    \n    attribute def content: String;\n  }",
    "package 'VehicleFuelSystem' {\n  block FuelTankAssembly {\n    port FuelSupplyPort {\n      out fuelSupply : Fuel;\n    }\n    port FuelReturnPort {\n      in fuelReturn : Fuel;\n    }\n    attribute FuelLevel;\n    attribute FuelTemperature;\n  }\n  block Engine {\n    port FuelSupplyPort {\n      in fuelSupply : Fuel;\n    }\n    port FuelReturnPort {\n      out fuelReturn : Fuel;\n    }\n    attribute EngineTemperature;\n  }\n  block FuelLine {\n    port FuelSupplyPort {\n      out fuelSupply : Fuel;\n    }\n    port FuelReturnPort {\n      in fuelReturn : Fuel;\n    }\n  }\n  part context {\n    part fuelTankAssembly: FuelTankAssembly;\n    part engine: Engine;\n    part fuelLine: FuelLine;\n    interface fuelTankAssemblyToEngine connect fuelTankAssembly.FuelSupplyPort to engine.FuelSupplyPort {\n      ref flow references fuelFlow;\n      from source.fuelSupply to target.fuelSupply;\n    }\n    interface engineToFuelTankAssembly connect engine.FuelReturn",
    "package 'PublishSubscribe' {\n  \n  class Producer {\n    port publishPort {\n      out message : Message;\n    }\n  }\n  \n  class Server {\n    port subscribePort {\n      in topic : Topic;\n    }\n    port publishPort {\n      in message : Message;\n    }\n    port deliverPort {\n      out message : Message;\n    }\n  }\n  \n  class Consumer {\n    port subscribePort {\n      in topic : Topic;\n    }\n    port receivePort {\n      in message : Message;\n    }\n  }\n  \n  class Message {\n    attribute content : String;\n  }\n  \n  class Topic {\n    attribute name : String;\n  }\n  \n  action PublishMessage {\n    from Producer.publishPort.message to Server.publishPort.message;\n  }\n  \n  action Subscribe {\n    from Consumer.subscribePort.topic to Server.subscribePort.topic;\n  }\n  \n  action DeliverMessage {\n    from Server.deliverPort.message to Consumer.receivePort.message;\n  }\n  \n",
    "package 'TransportationSystem' {\n  attribute def FuelLevel;\n  attribute def MaxFuelCapacity;\n  port def UserPort {\n    in user: User;\n  }\n  part context {\n    part vehicle {\n      port userPort: UserPort;\n      port fuelLevelPort: FuelLevelPort;\n      part driver {\n        port userPort: UserPort;\n      }\n      part passenger {\n        port userPort: UserPort;\n      }\n      action travel {\n        in user = userPort.user;\n        out fuelLevel = fuelLevelPort.fuelLevel;\n      }\n    }\n    part environment {\n      port fuelLevelPort: FuelLevelPort;\n    }\n    part gasStation {\n      port fuelLevelPort: FuelLevelPort;\n    }\n  }\n  action refuel {\n    in fuelLevel = fuelLevelPort.fuelLevel;\n    out fuelLevel = fuelLevelPort.fuelLevel;\n  }\n}",
    "package 'FuelSystem' {\n  block FuelTank {\n    port FuelOutlet {\n      in fuelTemperature : Real;\n      out fuel : Fluid;\n    }\n    port FuelReturn {\n      in fuel : Fluid;\n      out fuelTemperature : Real;\n    }\n  }\n  block Engine {\n    port FuelInlet {\n      in fuel : Fluid;\n      out fuelTemperature : Real;\n    }\n  }\n  interface FuelInterface {\n    port FuelOutlet : FuelTank.FuelOutlet;\n    port FuelInlet : Engine.FuelInlet;\n    port FuelReturn : FuelTank.FuelReturn;\n  }\n  connector FuelConnection {\n    end1 : FuelInterface.FuelOutlet;\n    end2 : FuelInterface.FuelInlet;\n  }\n  connector FuelReturnConnection {\n    end1 : FuelInterface.FuelReturn;\n    end2 : FuelInterface.FuelInlet;\n  }\n}",
    "package 'VehicleFuelSystem' {\n  attribute def FuelTemperature;\n  part FuelTankAssembly {\n    port FuelSupplyPort {\n      out fuelFlow: Flow;\n      out fuelTemperature: FuelTemperature;\n    }\n  }\n  part Engine {\n    port FuelReturnPort {\n      in fuelFlow: Flow;\n      in fuelTemperature: FuelTemperature;\n    }\n    port FuelSupplyPort {\n      in fuelFlow: Flow;\n      in fuelTemperature: FuelTemperature;\n    }\n  }\n  action FuelSupply {\n    flow fuelFlow from FuelTankAssembly.FuelSupplyPort.fuelFlow to Engine.FuelSupplyPort.fuelFlow;\n    flow fuelTemperature from FuelTankAssembly.FuelSupplyPort.fuelTemperature to Engine.FuelSupplyPort.fuelTemperature;\n  }\n  action FuelReturn {\n    flow fuelFlow from Engine.FuelReturnPort.fuelFlow to FuelTankAssembly.FuelSupplyPort.fuelFlow;\n    flow fuelTemperature from Engine.FuelReturnPort.fuelTemperature to FuelTankAssembly.FuelSupplyPort.fuelTemperature;\n  }\n}",
    "package 'PhotoSystem' {\n\tattribute def Scene;\n\tattribute def FocusedImage;\n\tattribute def FinalPhoto;\n\tport def ScenePort {\n\t\tin scene: Scene;\n\t}\n\tport def FocusedImagePort {\n\t\tout focusedImage: FocusedImage;\n\t}\n\tport def FinalPhotoPort {\n\t\tout finalPhoto: FinalPhoto;\n\t}\n\tpart context {\n\t\tpart user {\n\t\t\tport scenePort: ScenePort;\n\t\t\tperform capturePhoto.selectScene {\n\t\t\t\tin scene = scenePort.scene;\n\t\t\t}\n\t\t}\n\t\tinterface userToPhotoSystem connect user.scenePort to photoSystem.scenePort {\n\t\t\tref flow references capturePhoto.sceneFlow\n\t\t\t\tfrom source.scene to target.scene; \n\t\t}\n\t\tpart photoSystem {\n\t\t\tport scenePort: ~ScenePort;\n\t\t\tport focusedImagePort: FocusedImagePort;\n\t\t\tport finalPhotoPort: FinalPhotoPort;\n\t\t\tperform capturePhoto.focusScene {\n\t\t\t\tin scene = scenePort.scene;\n\t\t\t\tout focusedImage = focusedImagePort.focusedImage;\n\t\t\t}\n\t\t\tperform capturePhoto.capturePhoto",
    "package 'PhotographySystem' {\n\tattribute def Scene;\n\tattribute def FocusedImage;\n\tattribute def FinalImage;\n\tport def ScenePort {\n\t\tin scene: Scene;\n\t}\n\tport def FocusedImagePort {\n\t\tout focusedImage: FocusedImage;\n\t}\n\tport def FinalImagePort {\n\t\tout finalImage: FinalImage;\n\t}\n\tpart context {\n\t\tpart user {\n\t\t\tport scenePort: ScenePort;\n\t\t\tperform selectScene {\n\t\t\t\tin scene = scenePort.scene;\n\t\t\t}\n\t\t}\n\t\tinterface userToSystem connect user.scenePort to system.scenePort {\n\t\t\tref flow references selectSceneFlow\n\t\t\t\tfrom source.scene to target.scene;\n\t\t}\n\t\tpart system {\n\t\t\tport scenePort: ~ScenePort;\n\t\t\tport focusedImagePort: FocusedImagePort;\n\t\t\tport finalImagePort: FinalImagePort;\n\t\t\tperform focusScene {\n\t\t\t\tin scene = scenePort.scene;\n\t\t\t\tout focusedImage = focusedImagePort.focusedImage;\n\t\t\t}\n\t\t\tperform shootImage {\n\t\t\t\tin focusedImage = focusedImagePort.focusedImage;\n",
    "package 'PhotographySystem' {\n  attribute def Scene;\n  attribute def FocusImage;\n  attribute def Photograph;\n  port def ScenePort {\n    in scene: Scene;\n  }\n  port def FocusImagePort {\n    out focusImage: FocusImage;\n  }\n  port def PhotographPort {\n    out photograph: Photograph;\n  }\n  part context {\n    part user {\n      port scenePort: ScenePort;\n      perform selectScene {\n        in scene = scenePort.scene;\n      }\n    }\n    interface userToSystem connect user.scenePort to system.scenePort {\n      ref flow references selectScene.sceneFlow\n        from source.scene to target.scene;\n    }\n    part system {\n      port scenePort: ~ScenePort;\n      port focusImagePort: ~FocusImagePort;\n      port photographPort: ~PhotographPort;\n      perform focusScene {\n        in scene = scenePort.scene;\n        out focusImage = focusImagePort.focusImage;\n      }\n      perform capturePhotograph {\n        in focusImage = focusImagePort.focusImage;\n        out",
    "package 'PhotographySystem' {\n  attribute def Scene;\n  attribute def FocusedImage;\n  attribute def Photograph;\n  port def ScenePort {\n    in scene: Scene;\n  }\n  port def FocusedImagePort {\n    out focusedImage: FocusedImage;\n  }\n  port def PhotographPort {\n    out photograph: Photograph;\n  }\n  part context {\n    part user {\n      port scenePort: ScenePort;\n      perform capturePhotograph.provideScene {\n        in scene = scenePort.scene;\n      }\n    }\n    interface userToSystem connect user.scenePort to system.scenePort {\n      ref flow references capturePhotograph.sceneFlow\n        from source.scene to target.scene;\n    }\n    part system {\n      port scenePort: ~ScenePort;\n      port focusedImagePort: FocusedImagePort;\n      port photographPort: PhotographPort;\n      perform capturePhotograph.focusProcessing {\n        in scene = scenePort.scene;\n        out focusedImage = focusedImagePort.focusedImage;\n      }\n      perform capturePhotograph.shootingOperation {\n        in focusedImage = focusedImagePort",
    "package 'PhotographyWorkflow' {\n\tattribute def Scene;\n\tattribute def Image;\n\tattribute def Picture;\n\tport def ScenePort {\n\t\tin scene: Scene;\n\t}\n\tport def ImagePort {\n\t\tout image: Image;\n\t}\n\tport def PicturePort {\n\t\tout picture: Picture;\n\t}\n\tpart context {\n\t\tpart user {\n\t\t\tport scenePort: ScenePort;\n\t\t\tperform capturePhoto.setInputScene {\n\t\t\t\tin scene = scenePort.scene;\n\t\t\t}\n\t\t}\n\t\tinterface userToWorkflow connect user.scenePort to workflow.scenePort {\n\t\t\tref flow references capturePhoto.sceneFlow\n\t\t\t\tfrom source.scene to target.scene;\n\t\t}\n\t\tpart workflow {\n\t\t\tport scenePort: ~ScenePort;\n\t\t\tport imagePort: ~ImagePort;\n\t\t\tport picturePort: ~PicturePort;\n\t\t\tperform capturePhoto.focusScene {\n\t\t\t\tin scene = scenePort.scene;\n\t\t\t\tout image = imagePort.image;\n\t\t\t}\n\t\t\tperform capturePhoto.shootImage {\n\t\t\t\tin image = imagePort.image;\n\t\t\t\tout picture = picture",
    "package 'PhotographySystem' {\n  attribute def Scene;\n  attribute def FocusStatus;\n  attribute def Image;\n  port def ScenePort {\n    in scene: Scene;\n  }\n  port def FocusStatusPort {\n    out focusStatus: FocusStatus;\n  }\n  port def ImagePort {\n    out image: Image;\n  }\n  part context {\n    part user {\n      port scenePort: ScenePort;\n      port focusStatusPort: FocusStatusPort;\n      perform capturePhoto.setScene {\n        in scene = scenePort.scene;\n      }\n    }\n    interface userToSystem connect user.scenePort to system.scenePort {\n      ref flow references capturePhoto.sceneFlow\n        from source.scene to target.scene;\n    }\n    part system {\n      port scenePort: ~ScenePort;\n      port focusStatusPort: ~FocusStatusPort;\n      port imagePort: ~ImagePort;\n      perform capturePhoto.focusScene {\n        in scene = scenePort.scene;\n        out focusStatus = focusStatusPort.focusStatus;\n      }\n      perform capturePhoto.",
    "package 'PhotographySystem' {\n\tattribute def Scene;\n\tattribute def FocusQuality;\n\tattribute def Image;\n\tattribute def Photograph;\n\tport def ScenePort {\n\t\tin scene: Scene;\n\t}\n\tport def FocusQualityPort {\n\t\tout focusQuality: FocusQuality;\n\t}\n\tport def ImagePort {\n\t\tout image: Image;\n\t}\n\tport def PhotographPort {\n\t\tout photograph: Photograph;\n\t}\n\tpart context {\n\t\tpart user {\n\t\t\tport scenePort: ScenePort;\n\t\t\tperform selectScene.setScene {\n\t\t\t\tin scene = scenePort.scene;\n\t\t\t}\n\t\t}\n\t\tinterface userToSystem connect user.scenePort to system.scenePort {\n\t\t\tref flow references selectScene.sceneFlow\n\t\t\t\tfrom source.scene to target.scene;\n\t\t}\n\t\tpart system {\n\t\t\tport scenePort: ~ScenePort;\n\t\t\tport focusQualityPort: FocusQualityPort;\n\t\t\tport imagePort: ImagePort;\n\t\t\tport photographPort: PhotographPort;\n\t\t\tperform selectScene.focusScene {\n\t\t\t\tin scene = scenePort.scene;\n\t\t\t\tout",
    "package 'PhotographyWorkflow' {\n  attribute def Scene;\n  attribute def FocusedImage;\n  attribute def Photo;\n  port def ScenePort {\n    in scene: Scene;\n  }\n  port def FocusedImagePort {\n    out focusedImage: FocusedImage;\n  }\n  port def PhotoPort {\n    out photo: Photo;\n  }\n  part context {\n    part user {\n      port scenePort: ScenePort;\n      perform takePhoto.sendScene {\n        out scene = scenePort.scene;\n      }\n    }\n    interface userToWorkflow connect user.scenePort to workflow.scenePort {\n      ref flow references takePhoto.sceneFlow\n        from source.scene to target.scene;\n    }\n    part workflow {\n      port scenePort: ~ScenePort;\n      perform takePhoto.focus {\n        in scene = scenePort.scene;\n        out focusedImage = focusedImagePort.focusedImage;\n      }\n      port focusedImagePort: ~FocusedImagePort;\n      perform takePhoto.shoot {\n        in focusedImage = focusedImagePort.focusedImage;\n        out photo = photo",
    "package 'AutomaticBrakingSystem' {\n  attribute def BrakePedalStatus;\n  attribute def TractionStatus;\n  attribute def BrakePressure;\n  attribute def ModulationFrequency;\n  port def BrakePedalPort {\n    in brakePedalStatus: BrakePedalStatus;\n  }\n  port def TractionPort {\n    in tractionStatus: TractionStatus;\n  }\n  port def BrakePressurePort {\n    out brakePressure: BrakePressure;\n  }\n  port def ModulationFrequencyPort {\n    out modulationFrequency: ModulationFrequency;\n  }\n  part context {\n    part user {\n      port brakePedalPort: BrakePedalPort;\n      port tractionPort: TractionPort;\n    }\n    interface userToSystem connect user.brakePedalPort to system.brakePedalPort;\n    interface userToSystem connect user.tractionPort to system.tractionPort;\n    part system {\n      port brakePedalPort: ~BrakePedalPort;\n      port tractionPort: ~TractionPort;\n      port brakePressurePort: BrakePressurePort;\n      port modulationFrequencyPort: ModulationFrequencyPort;\n      perform brakeControl",
    "package 'BatteryChargingSystem' {\n  attribute def BatteryLevel;\n  port def BatteryLevelPort {\n    out batteryLevel: BatteryLevel;\n  }\n  part context {\n    part battery {\n      port batteryLevelPort: ~BatteryLevelPort;\n    }\n    part chargingController {\n      port batteryLevelPort: BatteryLevelPort;\n      port chargingPort: ChargingPort;\n      perform monitorBatteryLevel {\n        in batteryLevel = batteryLevelPort.batteryLevel;\n      }\n      perform initiateCharging {\n        out chargingSignal = chargingPort.chargingSignal;\n      }\n      perform terminateCharging {\n      }\n    }\n    interface batteryToController connect battery.batteryLevelPort to chargingController.batteryLevelPort {\n      ref flow references monitorBatteryLevel.batteryLevelFlow\n        from source.batteryLevel to target.batteryLevel;\n    }\n    interface controllerToBattery connect chargingController.chargingPort to battery.chargingPort {\n      ref flow references initiateCharging.chargingSignalFlow\n        from source.chargingSignal to target.chargingSignal;\n    }\n  }\n  action monitorBatteryLevel {\n    in batteryLevel: BatteryLevel",
    "package 'BatteryChargingSystem' {\n  attribute def BatteryLevel;\n  statemachine ChargingStateMachine {\n    state Initial {\n      entry action {\n        BatteryLevel = 0;\n      }\n    }\n    state Charging {\n      entry action {\n        BatteryLevel = BatteryLevel + 1;\n      }\n      transition to FullCharge when BatteryLevel >= 100;\n    }\n    state FullCharge {\n      entry action {\n        BatteryLevel = 100;\n      }\n      transition to Initial when true;\n    }\n  }\n}",
    "package 'Camera' {\n\tattribute def Scene;\n\tattribute def FocusResult;\n\tattribute def Image;\n\tport def ScenePort {\n\t\tin scene: Scene;\n\t}\n\tport def FocusResultPort {\n\t\tout focusResult: FocusResult;\n\t}\n\tport def ImagePort {\n\t\tout image: Image;\n\t}\n\tpart context {\n\t\tpart user {\n\t\t\tport scenePort: ScenePort;\n\t\t\tperform capturePhoto.selectScene {\n\t\t\t\tin scene = scenePort.scene;\n\t\t\t}\n\t\t}\n\t\tinterface userToCamera connect user.scenePort to camera.scenePort {\n\t\t\tref flow references capturePhoto.sceneFlow\n\t\t\t\tfrom source.scene to target.scene; \n\t\t}\n\t\tpart camera {\n\t\t\tport scenePort: ~ScenePort;\n\t\t\tperform capturePhoto.autofocus {\n\t\t\t\tin scene = scenePort.scene;\n\t\t\t\tout focusResult = focusResultPort.focusResult;\n\t\t\t}\n\t\t\tport focusResultPort: FocusResultPort;\n\t\t\tperform capturePhoto.captureImage {\n\t\t\t\tin focusResult = focusResultPort.focusResult;\n\t\t\t\tout image =",
    "package 'DigitalCamera' {\n\tattribute def Scene;\n\tattribute def Focus;\n\tattribute def Image;\n\tport def ScenePort {\n\t\tin scene: Scene;\n\t}\n\tport def FocusPort {\n\t\tout focus: Focus;\n\t}\n\tport def ImagePort {\n\t\tout image: Image;\n\t}\n\tpart context {\n\t\tpart user {\n\t\t\tport scenePort: ScenePort;\n\t\t\tperform captureImage.selectScene {\n\t\t\t\tin scene = scenePort.scene;\n\t\t\t}\n\t\t}\n\t\tinterface userToCamera connect user.scenePort to camera.scenePort {\n\t\t\tref flow references captureImage.sceneFlow\n\t\t\t\tfrom source.scene to target.scene; \n\t\t}\n\t\tpart camera {\n\t\t\tport scenePort: ~ScenePort;\n\t\t\tperform captureImage.autoFocus {\n\t\t\t\tin scene = scenePort.scene;\n\t\t\t\tout focus = focusPort.focus;\n\t\t\t}\n\t\t\tport focusPort: ~FocusPort;\n\t\t\tperform captureImage.generateImage {\n\t\t\t\tin focus = focusPort.focus;\n\t\t\t\tout image = imagePort.image;\n\t\t\t}\n\t\t\t",
    "package 'VehicleSimulation' {\n  attribute def Mass : Real;\n  attribute def InitialPosition : Real;\n  attribute def InitialVelocity : Real;\n  attribute def TimeStep : Real;\n  \n  port def PowerInputPort {\n    in powerInput : Real;\n  }\n  \n  port def PositionOutputPort {\n    out position : Real;\n  }\n  \n  part context {\n    part user {\n      port powerInputPort: PowerInputPort;\n      port positionOutputPort: PositionOutputPort;\n      perform simulateTrajectory {\n        in mass = Mass;\n        in initialPosition = InitialPosition;\n        in initialVelocity = InitialVelocity;\n        in timeStep = TimeStep;\n        in powerInput = powerInputPort.powerInput;\n        out position = positionOutputPort.position;\n      }\n    }\n  }\n  \n  action simulateTrajectory {\n    in mass: Real;\n    in initialPosition: Real;\n    in initialVelocity: Real;\n    in timeStep: Real;\n    in powerInput: Real;\n    out position: Real;\n  }\n}",
    "package 'CameraSystem' {\n\tattribute def Scene;\n\tattribute def FocusedImage;\n\tattribute def Photo;\n\tport def ScenePort {\n\t\tin scene: Scene;\n\t}\n\tport def FocusedImagePort {\n\t\tout focusedImage: FocusedImage;\n\t}\n\tport def PhotoPort {\n\t\tout photo: Photo;\n\t}\n\tpart context {\n\t\tpart user {\n\t\t\tport scenePort: ScenePort;\n\t\t\tperform capturePhoto.inputScene {\n\t\t\t\tin scene = scenePort.scene;\n\t\t\t}\n\t\t}\n\t\tinterface userToCamera connect user.scenePort to camera.scenePort {\n\t\t\tref flow references capturePhoto.sceneFlow\n\t\t\t\tfrom source.scene to target.scene; \n\t\t}\n\t\tpart camera {\n\t\t\tport scenePort: ~ScenePort;\n\t\t\tperform capturePhoto.focusScene {\n\t\t\t\tin scene = scenePort.scene;\n\t\t\t\tout focusedImage = focusedImagePort.focusedImage;\n\t\t\t}\n\t\t\tport focusedImagePort: FocusedImagePort;\n\t\t\tperform capturePhoto.captureImage {\n\t\t\t\tin focusedImage = focusedImagePort.focusedImage;\n\t\t\t\tout photo",
    "package 'Camera' {\n  attribute def viewPort;\n  attribute def Image;\n  attribute def Picture;\n  port def viewPortPort {\n    in viewPort: viewPort;\n  }\n  port def ImagePort {\n    out Image: Image;\n  }\n  port def PicturePort {\n    out Picture: Picture;\n  }\n  port def displayPort {\n    out displayPort: displayPort;\n  }\n  part context {\n    part user {\n      port viewPortPort: viewPortPort;\n      perform selectScene {\n        in viewPort = viewPortPort.viewPort;\n      }\n    }\n    interface userToCamera connect user.viewPortPort to camera.viewPortPort {\n      ref flow references selectScene.viewPortFlow\n        from source.viewPort to target.viewPort;\n    }\n    part camera {\n      port viewPortPort: ~viewPortPort;\n      perform focusScene {\n        in viewPort = viewPortPort.viewPort;\n        out Image = ImagePort.Image;\n      }\n      port ImagePort: ~ImagePort;\n      perform capture",
    "package 'SensorManagementSystem' {\n  \n  attribute def SensorStatus;\n  \n  block Sensor {\n    port sensorStatusPort {\n      out sensorStatus: SensorStatus;\n    }\n  }\n  \n  block SensorManagementSystem {\n    part sensorRegistry {\n      part sensor : Sensor;\n    }\n    \n    action updateSensor {\n      in sensor: Sensor;\n    }\n    \n    behavior monitorAndUpdateSensors {\n      loop traverseSensors {\n        from sensorRegistry.sensor\n        \n        if sensor.sensorStatus = 'Ready' then\n          call updateSensor(sensor);\n      }\n    }\n  }\n}",
    "package 'VehicleStateManagement' {\n  statedef Off {\n  }\n  statedef Starting {\n  }\n  statedef On {\n  }\n  transitiondef StartTransition {\n    from Off to Starting;\n    trigger VehicleStartSignal;\n  }\n  transitiondef PowerOnTransition {\n    from Starting to On;\n    trigger VehiclePowerOnSignal;\n  }\n  transitiondef ShutdownTransition {\n    from On to Off;\n    trigger VehicleShutdownSignal;\n  }\n  statemachine VehicleStateMachine {\n    initial Off;\n    region VehicleStateRegion {\n      state Off;\n      state Starting;\n      state On;\n      StartTransition;\n      PowerOnTransition;\n      ShutdownTransition;\n    }\n  }\n}",
    "package 'VehicleStatusManagement' {\n  statedef Off {\n    transition VehicleStartSignal -> Starting;\n  }\n  statedef Starting {\n    transition VehicleOnSignal -> On;\n  }\n  statedef On {\n    transition VehicleOffSignal -> Off;\n  }\n  \n  statemachine VehicleStatus {\n    initial Off;\n    state Off;\n    state Starting;\n    state On;\n    \n    transition VehicleStartSignal from Off to Starting;\n    transition VehicleOnSignal from Starting to On;\n    transition VehicleOffSignal from On to Off;\n  }\n}",
    "package 'VehiclePowerManagement' {\n\tstatemachine VehiclePowerState {\n\t\tstate Off {\n\t\t\ttransition startCommand -> StartPhase;\n\t\t}\n\t\tstate StartPhase {\n\t\t\ttransition startedSignal -> PoweredOn;\n\t\t}\n\t\tstate PoweredOn {\n\t\t\tactivity selfDiagnosis;\n\t\t\tactivity powerSupply;\n\t\t\ttransition shutdownCommand -> SafetyOperations;\n\t\t}\n\t\tstate SafetyOperations {\n\t\t\tactivity parkingBrakeEngagement;\n\t\t\ttransition offState -> Off;\n\t\t}\n\t\toffState : Off;\n\t}\n\t\n\tactivity selfDiagnosis {\n\t\t\n\t}\n\tactivity powerSupply {\n\t\t\n\t}\n\tactivity parkingBrakeEngagement {\n\t\t\n\t}\n\t\n\tport def startCommandPort {\n\t\tin startCommand : Boolean;\n\t}\n\tport def startedSignalPort {\n\t\tin startedSignal : Boolean;\n\t}\n\tport def shutdownCommandPort {\n\t\tin shutdownCommand : Boolean;\n\t}\n\t\n\tpart context {\n\t\tpart user {\n\t\t\tport startCommandPort: startCommandPort;\n\t\t\tport shutdownCommandPort: shutdownCommandPort;\n\t\t}\n\t\tpart vehicle {\n",
    "package 'VehicleControlSystem' {\n  state machine VehicleState {\n    state Shutdown {\n      transition startSignal -> StartUp;\n    }\n    state StartUp {\n      transition startedSignal -> Running;\n    }\n    state Running {\n      transition shutdownSignal -> Shutdown;\n    }\n  }\n  \n  interface VehicleControl {\n    signal startSignal;\n    signal shutdownSignal;\n    signal startedSignal;\n  }\n}",
    "package 'VehiclePowerManagement' {\n  attribute def OperatingState;\n  attribute def HealthState;\n  statemachine OperatingStateSM {\n    state Off {\n      transition startSignal -> Start;\n    }\n    state Start {\n      transition onSignal -> On;\n    }\n    state On {\n      transition offSignal -> Off;\n    }\n  }\n  statemachine HealthStateSM {\n    state Healthy {\n      \n    }\n    state Warning {\n      \n    }\n    state Critical {\n      \n    }\n  }\n  port def StartSignalPort {\n    in startSignal: Boolean;\n  }\n  port def OnSignalPort {\n    in onSignal: Boolean;\n  }\n  port def OffSignalPort {\n    in offSignal: Boolean;\n  }\n  port def HealthStatePort {\n    out healthState: HealthState;\n  }\n  part context {\n    part user {\n      port startSignalPort: StartSignalPort;\n      port onSignalPort: OnSignalPort;\n      port offSignalPort: OffSignalPort;\n    }\n    interface userToVehicle connect user",
    "package 'VehicleHealthMonitoringSystem' {\n  attribute def VehicleTemperature;\n  attribute def MaxAllowableTemperature;\n  attribute def VehicleHealthStatus;\n  attribute def MaintenanceStatus;\n  attribute def MaintenanceCycleTime;\n  port def VehicleControllerPort {\n    out overTemperatureWarning: Boolean;\n  }\n  part context {\n    part vehicle {\n      port vehicleControllerPort: VehicleControllerPort;\n      port temperatureSensorPort {\n        in vehicleTemperature: VehicleTemperature;\n      }\n      perform monitorTemperature {\n        in vehicleTemperature = temperatureSensorPort.vehicleTemperature;\n        out overTemperatureWarning = vehicleControllerPort.overTemperatureWarning;\n      }\n    }\n    part temperatureSensor {\n      port temperatureSensorPort: ~temperatureSensorPort;\n    }\n    part vehicleController {\n      port vehicleControllerPort: ~VehicleControllerPort;\n    }\n    part maintenanceScheduler {\n      port maintenanceCycleTimePort {\n        in maintenanceCycleTime: MaintenanceCycleTime;\n      }\n      perform scheduleMaintenance {\n        in maintenanceCycleTime = maintenanceCycleTimePort.maintenanceCycleTime;\n      }\n    }\n  }\n  action monitor",
    "package 'Server' {\n  attribute def state;\n  attribute def localClock;\n  port def requestPort {\n    in request : String;\n  }\n  part context {\n    part server {\n      port requestPort: ~requestPort;\n      stateMachine state {\n        state off {\n          transition start : startCmd;\n        }\n        state waiting {\n          transition response : request;\n        }\n        state response {\n          transition waiting : timeDelay(5 minutes);\n        }\n      }\n      action startCmd {\n        in startCmd : String;\n        out state = waiting;\n      }\n      action request {\n        in request : String;\n        out state = response;\n      }\n      action timeDelay {\n        in timeDelay : Time;\n        out state = waiting;\n      }\n      action dailyShutdown {\n        out state = off;\n      }\n    }\n  }\n  action dailyShutdown {\n    trigger dailyShutdownTrigger {\n      when localClock = 11:59:00;\n    }\n    action dailyShutdown {\n      out state = off;\n",
    "package 'VehicleStartStop' {\n  statedef Off {\n    transition startTransition on 'start signal'\n  }\n  statedef Start {\n    transition powerOnTransition on 'power-on signal' when brakePedalDepressed\n    transition operatingTransition on 'start signal'\n  }\n  statedef Operating {\n    transition stopTransition on 'stop signal'\n  }\n  statedef Off {\n    transition startTransition on 'start signal'\n  }\n  transition startTransition {\n    from Off to Start\n  }\n  transition powerOnTransition {\n    from Start to Operating\n  }\n  transition operatingTransition {\n    from Start to Operating\n  }\n  transition stopTransition {\n    from Operating to Off\n  }\n}",
    "package 'VehicleStartStopSystem' {\n  attribute def StartStopState;\n  attribute def VehicleOnSignal;\n  attribute def BrakePedalPressed;\n  attribute def StartControlSignal;\n  attribute def SelfCheckStatus;\n  attribute def ParkingBrakeApplied;\n  port def StartStopStatePort {\n    out startStopState: StartStopState;\n  }\n  port def VehicleOnSignalPort {\n    in vehicleOnSignal: VehicleOnSignal;\n  }\n  port def BrakePedalPressedPort {\n    in brakePedalPressed: BrakePedalPressed;\n  }\n  port def StartControlSignalPort {\n    out startControlSignal: StartControlSignal;\n  }\n  port def SelfCheckStatusPort {\n    out selfCheckStatus: SelfCheckStatus;\n  }\n  port def ParkingBrakeAppliedPort {\n    out parkingBrakeApplied: ParkingBrakeApplied;\n  }\n  part context {\n    part driver {\n      port vehicleOnSignalPort: VehicleOnSignalPort;\n      port brakePedalPressedPort: BrakePedalPressedPort;\n    }\n    interface driverToSystem connect driver",
    "package 'CruiseControlSystem' {\n  attribute def SetSpeedCmd;\n  attribute def ActualSpeed;\n  attribute def FuelControlCmd;\n  port def SetSpeedCmdPort {\n    in setSpeedCmd : SetSpeedCmd;\n  }\n  port def ActualSpeedPort {\n    out actualSpeed : ActualSpeed;\n  }\n  port def FuelControlCmdPort {\n    out fuelControlCmd : FuelControlCmd;\n  }\n  part context {\n    part driver {\n      port setSpeedCmdPort: SetSpeedCmdPort;\n      perform setDesiredSpeed {\n        out setSpeedCmd = setSpeedCmdPort.setSpeedCmd;\n      }\n    }\n    part cruiseController {\n      port setSpeedCmdPort: ~SetSpeedCmdPort;\n      port actualSpeedPort: ~ActualSpeedPort;\n      port fuelControlCmdPort: FuelControlCmdPort;\n      perform setCruiseSpeed {\n        in setSpeedCmd = setSpeedCmdPort.setSpeedCmd;\n        in actualSpeed = actualSpeedPort.actualSpeed;\n        out fuelControlCmd = fuelControlCmdPort.fuelControlCmd;\n      }\n    }\n",
    "package 'CruiseControl' {\n  attribute def SetSpeedCmd;\n  attribute def ActualSpeed;\n  attribute def ThrottleCmd;\n  port def SetSpeedCmdPort {\n    in setSpeedCmd : SetSpeedCmd;\n  }\n  port def ActualSpeedPort {\n    in actualSpeed : ActualSpeed;\n  }\n  port def ThrottleCmdPort {\n    out throttleCmd : ThrottleCmd;\n  }\n  part context {\n    part driver {\n      port setSpeedCmdPort: SetSpeedCmdPort;\n      perform setSpeed {\n        in setSpeedCmd = setSpeedCmdPort.setSpeedCmd;\n      }\n    }\n    part cruiseController {\n      port setSpeedCmdPort: ~SetSpeedCmdPort;\n      port actualSpeedPort: ~ActualSpeedPort;\n      port throttleCmdPort: ThrottleCmdPort;\n      perform acquireActualSpeed {\n        in setSpeedCmd = setSpeedCmdPort.setSpeedCmd;\n        in actualSpeed = actualSpeedPort.actualSpeed;\n        out throttleCmd = throttleCmdPort.throttleCmd;\n      }\n    }\n    part engineSystem {\n      port throttleCmdPort",
    "package 'CruiseControl' {\n\tattribute def SetSpeedCmd;\n\tattribute def CurrentSpeed;\n\tattribute def ThrottleCmd;\n\tport def SetSpeedCmdPort {\n\t\tin setSpeedCmd : SetSpeedCmd;\n\t}\n\tport def CurrentSpeedPort {\n\t\tin currentSpeed : CurrentSpeed;\n\t}\n\tport def ThrottleCmdPort {\n\t\tout throttleCmd : ThrottleCmd;\n\t}\n\tpart context {\n\t\tpart driver {\n\t\t\tport setSpeedCmdPort: SetSpeedCmdPort;\n\t\t\tperform setTargetSpeed {\n\t\t\t\tout setSpeedCmd = setSpeedCmdPort.setSpeedCmd;\n\t\t\t}\n\t\t}\n\t\tpart cruiseController {\n\t\t\tport setSpeedCmdPort: ~SetSpeedCmdPort;\n\t\t\tport currentSpeedPort: ~CurrentSpeedPort;\n\t\t\tport throttleCmdPort: ~ThrottleCmdPort;\n\t\t\tperform calculateThrottle {\n\t\t\t\tin setSpeedCmd = setSpeedCmdPort.setSpeedCmd;\n\t\t\t\tin currentSpeed = currentSpeedPort.currentSpeed;\n\t\t\t\tout throttleCmd = throttleCmdPort.throttleCmd;\n\t\t\t}\n\t\t}\n\t\tpart speedometer {\n\t\t\tport currentSpeedPort",
    "package 'CruiseControl' {\n\tattribute def DesiredSpeed;\n\tattribute def ActualSpeed;\n\tport def SetSpeedCmdPort {\n\t\tin setSpeedCmd : DesiredSpeed;\n\t}\n\tport def ActualSpeedPort {\n\t\tout actualSpeed : ActualSpeed;\n\t}\n\tpart context {\n\t\tpart driver {\n\t\t\tport setSpeedCmdPort: SetSpeedCmdPort;\n\t\t\tperform setDesiredSpeed {\n\t\t\t\tout setSpeedCmd = setSpeedCmdPort.setSpeedCmd;\n\t\t\t}\n\t\t}\n\t\tinterface driverToCruiseControl connect driver.setSpeedCmdPort to cruiseControl.setSpeedCmdPort {\n\t\t\tref flow references setSpeedFlow\n\t\t\t\tfrom source.setSpeedCmd to target.setSpeedCmd;\n\t\t}\n\t\tpart cruiseControl {\n\t\t\tport setSpeedCmdPort: ~SetSpeedCmdPort;\n\t\t\tport actualSpeedPort: ActualSpeedPort;\n\t\t\tperform calculateThrottle {\n\t\t\t\tin setSpeedCmd = setSpeedCmdPort.setSpeedCmd;\n\t\t\t\tout throttleCmd : ThrottleCmd;\n\t\t\t}\n\t\t}\n\t\tpart speedometer {\n\t\t\tport actualSpeedPort: ~ActualSpeedPort;\n\t\t\tperform get",
    "package 'CruiseControl' {\n  attribute def TargetSpeed;\n  attribute def ActualSpeed;\n  attribute def FuelControlCommand;\n  port def SetSpeedPort {\n    in setSpeed: TargetSpeed;\n  }\n  port def ActualSpeedPort {\n    out actualSpeed: ActualSpeed;\n  }\n  port def FuelControlPort {\n    out fuelControlCommand: FuelControlCommand;\n  }\n  part context {\n    part driver {\n      port setSpeedPort: SetSpeedPort;\n      perform setTargetSpeed {\n        out setSpeed = setSpeedPort.setSpeed;\n      }\n    }\n    interface driverToCruiseController connect driver.setSpeedPort to cruiseController.setSpeedPort {\n      ref flow references setSpeedFlow\n        from source.setSpeed to target.setSpeed;\n    }\n    part cruiseController {\n      port setSpeedPort: ~SetSpeedPort;\n      port actualSpeedPort: ~ActualSpeedPort;\n      port fuelControlPort: ~FuelControlPort;\n      perform maintainSpeed {\n        in setSpeed = setSpeedPort.setSpeed;\n        ",
    "package 'CruiseControlSystem' {\n  attribute def SetSpeedCmd;\n  attribute def ActualSpeed;\n  attribute def FuelControlCmd;\n  port def SetSpeedCmdPort {\n    in setSpeedCmd : SetSpeedCmd;\n  }\n  port def ActualSpeedPort {\n    out actualSpeed : ActualSpeed;\n  }\n  port def FuelControlCmdPort {\n    out fuelControlCmd : FuelControlCmd;\n  }\n  part context {\n    part driver {\n      port setSpeedCmdPort: SetSpeedCmdPort;\n      perform sendSetSpeedCmd {\n        out setSpeedCmd = setSpeedCmdPort.setSpeedCmd;\n      }\n    }\n    interface driverToCruiseController connect driver.setSpeedCmdPort to cruiseController.setSpeedCmdPort {\n      ref flow references sendSetSpeedCmdFlow\n        from source.setSpeedCmd to target.setSpeedCmd;\n    }\n    part cruiseController {\n      port setSpeedCmdPort: ~SetSpeedCmdPort;\n      port actualSpeedPort: ~ActualSpeedPort;\n      port fuelControlCmdPort: ~FuelControlCmdPort;\n      perform processSetSpeed",
    "package 'VehicleLifecycleManagement' {\n  \n  class Vehicle {\n    attribute def VIN;\n    attribute def AssemblyDate;\n    attribute def DeliveryDate;\n    \n    part Owner {\n      part OwnerInfo {\n        attribute def Name;\n        attribute def ContactInfo;\n      }\n    }\n    part DrivingRecord {\n      part DrivingEvent {\n        attribute def Driver;\n        attribute def StartTime;\n        attribute def EndTime;\n      }\n    }\n  }\n  \n  class OwnershipTransfer {\n    attribute def TransferDate;\n    part FromOwner : Vehicle.Owner;\n    part ToOwner : Vehicle.Owner;\n  }\n  \n  class Scrapping {\n    attribute def ScrappingDate;\n    attribute def ScrappingReason;\n  }\n  \n  \n  \n}",
    "package 'Vehicle' {\n  attribute def Mass : Real;\n  attribute def OperationalStatus : String;\n  attribute def GearSetting : String;\n  attribute def AcceleratorPosition : Real;\n  part context {\n    part Driver {\n      reference;\n    }\n    part Engine {\n      \n    }\n    part LeftFrontWheel {\n      \n    }\n    part RightFrontWheel {\n      \n    }\n  }\n  instance vehicle_1 {\n    Mass = 1500;\n    OperationalStatus = \"Idle\";\n    GearSetting = \"Park\";\n    AcceleratorPosition = 0;\n    part LeftFrontWheel {\n      \n    }\n    part RightFrontWheel {\n      \n    }\n  }\n}\n\n\n\n",
    "package 'VehicleSystem' {\n  class Vehicle {\n    attribute mass : Real;\n    attribute gearSetting : Integer;\n    attribute acceleratorPosition : Real;\n    \n    block Vehicle_1 {\n      Vehicle;\n      \n      instance initial {\n        mass = 2000;\n        gearSetting = 0;\n        acceleratorPosition = 0.0;\n      }\n      \n      instance next {\n        mass = 1500;\n        gearSetting = 2;\n        acceleratorPosition = 0.5;\n      }\n    }\n  }\n  \n  class Engine {\n    \n  }\n  \n  class Driver {\n    \n  }\n  \n  relationship hasEngine {\n    Vehicle to Engine;\n  }\n  \n  relationship hasDriver {\n    Vehicle to Driver;\n  }\n}",
    "package 'Vehicle' {\n  attribute def Mass : Real;\n  attribute def GearPosition : String;\n  attribute def ThrottlePosition : Real;\n  attribute def Driver : Driver;\n  part context {\n    part vehicle {\n      port driverPort: DriverPort;\n      port enginePort: EnginePort;\n    }\n    interface driverToVehicle connect vehicle.driverPort to driver.driverPort {\n      ref flow references driverChangeFlow\n        from source.driver to target.driver;\n    }\n    part driver {\n      port driverPort: DriverPort;\n      attribute def Name : String;\n    }\n    part engine {\n      port enginePort: EnginePort;\n    }\n  }\n  action timeSlice {\n    action updateVehicleState {\n      in mass = Mass;\n      in gearPosition = GearPosition;\n      in throttlePosition = ThrottlePosition;\n    }\n    succession flow stateChangeFlow from updateVehicleState.mass to vehicle.Mass;\n    succession flow stateChangeFlow from updateVehicleState.gearPosition to vehicle.GearPosition;\n    succession flow stateChangeFlow from updateVehicleState.throttlePosition to vehicle",
    "package 'VehicleMassSystem' {\n  \n  class Component {\n    attribute mass : Real;\n  }\n  \n  class Vehicle : Component {\n    part engine : Component;\n    part transmission : Component;\n    part body : Component;\n    \n    block calculateTotalMass {\n      in totalMass : Real;\n      out totalMass : Real;\n      \n      expression totalMass = engine.mass + transmission.mass + body.mass;\n    }\n  }\n  \n  class CompositeComponent : Component {\n    part components : Component;\n    \n    block calculateTotalMass {\n      in totalMass : Real;\n      out totalMass : Real;\n      \n      expression totalMass = sum(components.mass);\n    }\n  }\n  \n  \n}\n\n\n\n",
    "package 'VehicleMassManagement' {\n  \n  class Vehicle {\n    \n    attribute VIN : String;\n    \n    part component : Component;\n    \n    operation calculateTotalMass() : Real;\n  }\n  \n  class Component {\n    \n    attribute serialNumber : String;\n    \n    attribute mass : Real;\n    \n    part subComponent : Component;\n    \n    operation calculateComponentMass() : Real;\n  }\n  \n  class Engine {\n    \n    extends Component;\n    \n    attribute engineType : String;\n  }\n  \n  class Transmission {\n    \n    extends Component;\n    \n    attribute transmissionType : String;\n  }\n  \n  \n  \n  \n}\n",
    "package 'MassAggregation' {\n  class SimpleThing {\n    attribute simpleMass: Real;\n    attribute totalMass: Real;\n  }\n  class CompositeThing {\n    attribute simpleMass: Real;\n    attribute totalMass: Real;\n    part subcomponents: CompositeThing*;\n  }\n  operation calculateTotalMass(self: CompositeThing) : Real {\n    result = self.simpleMass;\n    for subcomponent in self.subcomponents do\n      result += subcomponent.totalMass;\n    return result;\n  }\n}",
    "package 'MassManagementSystem' {\n  \n  class Object {\n    attribute mass : Real;\n    part subcomponent : Object;\n  }\n  \n  class CompositeObject {\n    extends Object\n    part subcomponents : Object;\n  }\n  \n  action CalculateTotalMass {\n    in object : Object;\n    out totalMass : Real;\n    block {\n      if object.oclIsKindOf(CompositeObject) then\n        totalMass := object.mass + sum(subcomponent.mass : subcomponent in object.subcomponents)\n      else\n        totalMass := object.mass\n    }\n  }\n  \n  action FilterAndAggregateMass {\n    in object : Object;\n    in minMassThreshold : Real;\n    out totalMass : Real;\n    block {\n      totalMass := object.mass + sum(subcomponent.mass : subcomponent in object.subcomponents and subcomponent.mass >= minMassThreshold)\n    }\n  }\n}",
    "package 'VehicleDynamics' {\n  attribute def PowerOutput;\n  attribute def Acceleration;\n  attribute def Speed;\n  attribute def Position;\n  attribute def WheelPower;\n  attribute def AerodynamicDragCoefficient;\n  attribute def FrictionCoefficient;\n  attribute def VehicleMass;\n  \n  block VehicleDynamics {\n    port WheelPowerPort {\n      in wheelPower: WheelPower;\n    }\n    port AerodynamicDragCoefficientPort {\n      in aerodynamicDragCoefficient: AerodynamicDragCoefficient;\n    }\n    port FrictionCoefficientPort {\n      in frictionCoefficient: FrictionCoefficient;\n    }\n    port VehicleMassPort {\n      in vehicleMass: VehicleMass;\n    }\n    port SpeedPort {\n      in speed: Speed;\n    }\n    port PowerOutputPort {\n      out powerOutput: PowerOutput;\n    }\n    port AccelerationPort {\n      out acceleration: Acceleration;\n    }\n    port PositionPort {\n      out position: Position;\n    }\n    \n    action CalculatePowerOutput {\n      in wheelPower: WheelPowerPort.wheelPower;\n      in aerodynamicDragCoefficient: AerodynamicDragCoefficientPort.",
    "package 'VehicleDynamics' {\n  attribute def InitialSpeed;\n  attribute def InitialPosition;\n  attribute def TimeStep;\n  attribute def VehicleMass;\n  attribute def AerodynamicDragCoefficient;\n  attribute def RollingResistanceCoefficient;\n  attribute def WheelEndOutputPower;\n  \n  port def InputPort {\n    in initialSpeed: InitialSpeed;\n    in initialPosition: InitialPosition;\n    in timeStep: TimeStep;\n    in vehicleMass: VehicleMass;\n    in aerodynamicDragCoefficient: AerodynamicDragCoefficient;\n    in rollingResistanceCoefficient: RollingResistanceCoefficient;\n    in wheelEndOutputPower: WheelEndOutputPower;\n  }\n  \n  port def OutputPort {\n    out finalSpeed: InitialSpeed;\n    out finalPosition: InitialPosition;\n  }\n  \n  action CalculateVehicleDynamics {\n    input initialSpeed, initialPosition, timeStep, vehicleMass, aerodynamicDragCoefficient, rollingResistanceCoefficient, wheelEndOutputPower;\n    \n    block CalculateAvailableDrivingPower {\n      input wheelEndOutputPower, aerodynamicDragCoefficient, rollingResistanceCoefficient, vehicleMass;\n      output availableDrivingPower;\n    }\n    ",
    "package 'VehicleDynamics' {\n  attribute def VehicleMass;\n  attribute def WheelPower;\n  attribute def AerodynamicDragCoefficient;\n  attribute def RollingResistanceCoefficient;\n  attribute def InitialSpeed;\n  attribute def InitialPosition;\n  port def UserInputPort {\n    in vehicleMass: VehicleMass;\n    in wheelPower: WheelPower;\n    in aerodynamicDragCoefficient: AerodynamicDragCoefficient;\n    in rollingResistanceCoefficient: RollingResistanceCoefficient;\n    in initialSpeed: InitialSpeed;\n    in initialPosition: InitialPosition;\n  }\n  port def OutputPort {\n    out speed: Speed;\n    out acceleration: Acceleration;\n    out displacement: Displacement;\n  }\n  part context {\n    part user {\n      port userInputPort: UserInputPort;\n    }\n    part vehicleDynamicsModel {\n      port userInputPort: ~UserInputPort;\n      port outputPort: ~OutputPort;\n      behavior calculateDynamics {\n        in vehicleMass = userInputPort.vehicleMass;\n        in wheelPower = userInputPort.wheelPower;\n        in aerodynamicDragCoefficient = userInputPort.aerodynamicDragCoefficient;\n        in rollingResistance",
    "package 'VehicleDynamics' {\n  attribute def InitialPosition;\n  attribute def InitialVelocity;\n  attribute def VehicleMass;\n  attribute def WheelEndDrivePower;\n  attribute def TimeInterval;\n  attribute def DragCoefficient;\n  attribute def FrictionCoefficient;\n  \n  port def InputPort {\n    in initialPosition : InitialPosition;\n    in initialVelocity : InitialVelocity;\n    in vehicleMass : VehicleMass;\n    in wheelEndDrivePower : WheelEndDrivePower;\n    in timeInterval : TimeInterval;\n    in dragCoefficient : DragCoefficient;\n    in frictionCoefficient : FrictionCoefficient;\n  }\n  \n  port def OutputPort {\n    out acceleration : Real;\n    out finalVelocity : Real;\n    out finalPosition : Real;\n  }\n  \n  action CalculateVehicleDynamics {\n    in initialPosition : InitialPosition;\n    in initialVelocity : InitialVelocity;\n    in vehicleMass : VehicleMass;\n    in wheelEndDrivePower : WheelEndDrivePower;\n    in timeInterval : TimeInterval;\n    in dragCoefficient : DragCoefficient;\n    in frictionCoefficient : FrictionCoefficient;\n    out acceleration :",
    "package 'VehicleWeightManagement' {\n  attribute def MaxWeight : Real = 2500;\n  attribute def ChassisMass : Real;\n  attribute def EngineMass : Real;\n  attribute def GearboxMass : Real;\n  \n  block Chassis {\n    attribute ChassisMass : Real;\n  }\n  block Engine {\n    attribute EngineMass : Real;\n  }\n  block Gearbox {\n    attribute GearboxMass : Real;\n  }\n  \n  block Vehicle {\n    part chassis : Chassis;\n    part engine : Engine;\n    part gearbox : Gearbox;\n    \n    constraint TotalMass <= MaxWeight {\n      TotalMass = chassis.ChassisMass + engine.EngineMass + gearbox.GearboxMass;\n    }\n  }\n  \n  activity WeightCheck {\n    input chassisMass : Real;\n    input engineMass : Real;\n    input gearboxMass : Real;\n    \n    activity CalculateTotalMass {\n      TotalMass = chassisMass + engineMass + gearboxMass;\n    }\n    \n    activity CheckAgainstLimit {\n      if TotalMass > MaxWeight then\n        issue OverweightWarning;",
    "package 'VehicleMassBudgeting' {\n  attribute def MassLimit : Real = 2500;\n  attribute def ChassisMass : Real;\n  attribute def EngineMass : Real;\n  attribute def TransmissionMass : Real;\n  attribute def TotalMass : Real;\n  \n  block Chassis {\n    \n  }\n  block Engine {\n    \n  }\n  block Transmission {\n    \n  }\n  \n  constraint MassConstraint {\n    TotalMass <= MassLimit\n  }\n  \n  operation CalculateTotalMass {\n    TotalMass = ChassisMass + EngineMass + TransmissionMass;\n  }\n}",
    "package 'VehicleMassManagement' {\n  attribute def ChassisMass;\n  attribute def EngineMass;\n  attribute def TransmissionMass;\n  attribute def MaxVehicleMass : Real = 2500;\n  part context {\n    part Chassis {\n      port chassisMassPort: { in chassisMass: ChassisMass; }\n    }\n    part Engine {\n      port engineMassPort: { in engineMass: EngineMass; }\n    }\n    part Transmission {\n      port transmissionMassPort: { in transmissionMass: TransmissionMass; }\n    }\n    part Vehicle {\n      port chassisMassPort: ~Chassis.chassisMassPort;\n      port engineMassPort: ~Engine.engineMassPort;\n      port transmissionMassPort: ~Transmission.transmissionMassPort;\n      action verifyMassCompliance {\n        in chassisMass = chassisMassPort.chassisMass;\n        in engineMass = engineMassPort.engineMass;\n        in transmissionMass = transmissionMassPort.transmissionMass;\n        calculate totalMass = chassisMass + engineMass + transmissionMass;\n        constraint totalMass <= MaxVehicleMass;\n      }\n    }\n  }\n}\n```",
    "package 'VehicleWeightManagementSystem' {\n  attribute def MaxWeightLimit : Real = 2500;\n  attribute def ChassisWeight : Real;\n  attribute def EngineWeight : Real;\n  attribute def TransmissionWeight : Real;\n  attribute def TotalWeight : Real;\n  port def ChassisWeightPort {\n    in chassisWeight : ChassisWeight;\n  }\n  port def EngineWeightPort {\n    in engineWeight : EngineWeight;\n  }\n  port def TransmissionWeightPort {\n    in transmissionWeight : TransmissionWeight;\n  }\n  port def TotalWeightPort {\n    out totalWeight : TotalWeight;\n  }\n  part context {\n    part chassis {\n      port chassisWeightPort: ChassisWeightPort;\n    }\n    part engine {\n      port engineWeightPort: EngineWeightPort;\n    }\n    part transmission {\n      port transmissionWeightPort: TransmissionWeightPort;\n    }\n    part weightManagementSystem {\n      port chassisWeightPort: ~ChassisWeightPort;\n      port engineWeightPort: ~EngineWeightPort;\n      port transmissionWeightPort: ~TransmissionWeightPort;\n      port totalWeightPort:",
    "package 'Vehicle' {\n  attribute def ChassisMass;\n  attribute def EngineMass;\n  attribute def TransmissionMass;\n  constraint TotalMass <= 2500 {\n    expression ChassisMass + EngineMass + TransmissionMass <= 2500;\n  }\n  constraint PositiveMass {\n    expression ChassisMass > 0 and EngineMass > 0 and TransmissionMass > 0;\n  }\n  block Vehicle {\n    part Chassis {\n      port ChassisMassPort {\n        out chassisMass: ChassisMass;\n      }\n    }\n    part Engine {\n      port EngineMassPort {\n        out engineMass: EngineMass;\n      }\n    }\n    part Transmission {\n      port TransmissionMassPort {\n        out transmissionMass: TransmissionMass;\n      }\n    }\n  }\n  action DynamicBehavior {\n    input def InitialVelocity;\n    input def FinalVelocity;\n    input def AppliedForce;\n    input def Time;\n    output def ChangeInVelocity;\n    constraint ForceTimeRelationship {\n      expression ChangeInVelocity = AppliedForce * Time / Mass;\n    }\n  }\n}",
    "package 'VehicleMaintenanceSystem' {\n  attribute def VehicleID;\n  attribute def NextMaintenanceTime;\n  attribute def MaintenanceInterval;\n  attribute def MaxTemperature;\n  attribute def VehicleStatus;\n  port def VehicleStatusPort {\n    out vehicleStatus: VehicleStatus;\n  }\n  part context {\n    part vehicle {\n      port vehicleStatusPort: VehicleStatusPort;\n      perform scheduleMaintenance {\n        in vehicleID: VehicleID;\n        in nextMaintenanceTime: NextMaintenanceTime;\n        in maintenanceInterval: MaintenanceInterval;\n        in maxTemperature: MaxTemperature;\n        out vehicleStatus = vehicleStatusPort.vehicleStatus;\n      }\n      perform checkMaintenanceTime {\n        out hasReachedMaintenanceTime: Boolean;\n      }\n      perform initiateMaintenance {\n        out maintenanceStartTime: Time;\n      }\n      perform completeMaintenance {\n        in maintenanceEndTime: Time;\n      }\n    }\n  }\n  statemachine VehicleStatusStateMachine {\n    state 'Healthy' {\n      transition 'MaintenanceDue' to 'UnderMaintenance' on checkMaintenanceTime.hasReachedMaintenanceTime;\n    }\n    state 'UnderMaintenance' {",
    "package 'Vehicle' {\n  attribute def MaxMass;\n  attribute def CurbWeight;\n  attribute def FuelMass;\n  attribute def EngineTorque;\n  port def ClutchPort {\n    in torque: EngineTorque;\n  }\n  part context {\n    part vehicle {\n      port maxMassPort: MaxMass;\n      port curbWeightPort: CurbWeight;\n      port fuelMassPort: FuelMass;\n      part engine {\n        port engineTorquePort: EngineTorque;\n        perform generateTorque {\n          in speed: Speed;\n          out engineTorque = engineTorquePort.engineTorque;\n        }\n      }\n      part transmission {\n        port clutchPort: ClutchPort;\n        perform transmitTorque {\n          in torque = clutchPort.torque;\n        }\n      }\n    }\n    interface vehicleToEngine connect vehicle.maxMassPort to engine.maxMassPort {\n      ref flow references massFlow\n        from source.maxMass to target.maxMass;\n    }\n    interface vehicleToEngine connect vehicle.curbWeightPort to engine.curbWeightPort {\n      ref flow references massFlow\n        from source.",
    "package 'Vehicle' {\n  attribute def TotalMass {\n    type: Real;\n    unit: kg;\n  }\n  attribute def DryMass {\n    type: Real;\n    unit: kg;\n  }\n  attribute def FuelMass {\n    type: Real;\n    unit: kg;\n  }\n  attribute def EngineTorque {\n    type: Real;\n    unit: Nm;\n  }\n  block def Engine {\n    port def ClutchInterface {\n      out torque: EngineTorque;\n    }\n  }\n  block def Transmission {\n    port def ClutchInterface {\n      in torque: EngineTorque;\n    }\n  }\n  part context {\n    part vehicle {\n      port totalMassPort: TotalMass;\n      port dryMassPort: DryMass;\n      port fuelMassPort: FuelMass;\n    }\n    interface vehicleToEngine connect vehicle.totalMassPort to engine.totalMassPort {\n      ref flow references vehicleMassFlow\n        from source.totalMass to target.totalMass;\n    }\n    part engine {\n      port totalMassPort: TotalMass;\n      port clutch",
    "package 'Vehicle' {\n  attribute def VehicleMass {\n    type: Real;\n    unit: kilogram;\n    value: 2000;\n  }\n  attribute def EmptyVehicleMass {\n    type: Real;\n    unit: kilogram;\n    value: 1500;\n  }\n  part engine {\n    port clutchInterface {\n      out torque: Torque;\n    }\n    block engineTorqueCurve {\n      type: Table;\n      columns: [Speed, Torque];\n    }\n  }\n  part transmission {\n    port clutchInterface {\n      in torque: Torque;\n    }\n  }\n}",
    "package 'Vehicle' {\n  attribute def VehicleMassLimitFullTank : Real;\n  attribute def VehicleMassLimitEmptyTank : Real;\n  attribute def CurbMass : Real;\n  attribute def FuelMass : Real;\n  block def Vehicle {\n    part def Engine {\n      port def TorqueOutput : Torque;\n      port def ClutchInterface : Clutch;\n    }\n    part def Gearbox {\n      port def ClutchInterface : ~Clutch;\n      port def TorqueInput : Torque;\n    }\n    part def FuelTank {\n      attribute def FuelLevel : Real;\n    }\n    constraint def MassLimitFullTank {\n      VehicleMassLimitFullTank = CurbMass + FuelMass;\n      VehicleMassLimitFullTank <= 2000;\n    }\n    constraint def MassLimitEmptyTank {\n      VehicleMassLimitEmptyTank = CurbMass;\n      VehicleMassLimitEmptyTank <= 1500;\n    }\n    action def TorqueTransmission {\n      from Engine.TorqueOutput to Gearbox.TorqueInput;\n      from Engine.ClutchInterface to Gearbox.ClutchInterface;\n    }\n  }\n}",
    "package 'VehiclePerformanceAnalysis' {\n  attribute def VehicleWeight;\n  attribute def Payload;\n  attribute def WheelDiameter;\n  attribute def TransmissionEfficiency;\n  attribute def UrbanFuelEconomy;\n  attribute def HighwayFuelEconomy;\n  attribute def DrivingCycle;\n  attribute def TargetFuelEconomy;\n  port def VehicleAttributesPort {\n    out vehicleWeight: VehicleWeight;\n    out payload: Payload;\n    out wheelDiameter: WheelDiameter;\n    out transmissionEfficiency: TransmissionEfficiency;\n    out urbanFuelEconomy: UrbanFuelEconomy;\n    out highwayFuelEconomy: HighwayFuelEconomy;\n  }\n  port def DrivingCyclePort {\n    out drivingCycle: DrivingCycle;\n  }\n  port def TargetFuelEconomyPort {\n    out targetFuelEconomy: TargetFuelEconomy;\n  }\n  part context {\n    part user {\n      port vehicleAttributesPort: VehicleAttributesPort;\n      port drivingCyclePort: DrivingCyclePort;\n      port targetFuelEconomyPort: TargetFuelEconomyPort;\n      ",
    "package 'FuelEconomySimulation' {\n  attribute def TargetFuelEconomy {\n    value: Real;\n  }\n  attribute def ActualFuelEconomy {\n    value: Real;\n  }\n  attribute def CurbWeight {\n    value: Real;\n  }\n  attribute def Load {\n    value: Real;\n  }\n  attribute def WheelDiameter {\n    value: Real;\n  }\n  attribute def TransmissionEfficiency {\n    value: Real;\n  }\n  port def DrivingScenarioPort {\n    in drivingScenario: DrivingScenario;\n  }\n  port def VehicleParametersPort {\n    in curbWeight: CurbWeight;\n    in load: Load;\n    in wheelDiameter: WheelDiameter;\n    in transmissionEfficiency: TransmissionEfficiency;\n  }\n  part context {\n    part user {\n      port drivingScenarioPort: DrivingScenarioPort;\n      port vehicleParametersPort: VehicleParametersPort;\n      perform analyzeFuelEconomy {\n        in drivingScenario = drivingScenarioPort.drivingScenario;\n        in curbWeight = vehicleParametersPort.curbWeight;\n        in load = vehicleParametersPort.load;\n        in wheelDiameter =",
    "package 'EngineSelectionSystem' {\n  \n  attribute def EngineType {\n    enumeration 'FourCylinder', 'SixCylinder';\n  }\n  \n  attribute def Power {\n    type Real;\n  }\n  \n  attribute def Mass {\n    type Real;\n  }\n  \n  attribute def Efficiency {\n    type Real;\n  }\n  \n  attribute def Cost {\n    type Real;\n  }\n  \n  attribute def EvaluationScore {\n    type Real;\n  }\n  \n  block Engine {\n    \n    part EngineType {\n      type EngineType;\n    }\n    \n    part Power {\n      type Power;\n    }\n    \n    part Mass {\n      type Mass;\n    }\n    \n    part Efficiency {\n      type Efficiency;\n    }\n    \n    part Cost {\n      type Cost;\n    }\n  }\n  \n  block EngineSelectionSystem {\n    \n    part EngineDatabase {\n      type Block;\n      \n      part Engine {\n        type Engine;\n      }\n    }\n    \n    part EvaluationFunction {\n      type Function;\n",
    "package 'VehicleWeightCheck' {\n  attribute def CurbWeightLimit {\n    value: 2500 kg;\n  }\n  block Vehicle {\n    port dataOut: DataOut;\n  }\n  block WeightSensor {\n    port dataIn: DataIn;\n  }\n  block WeightProcessor {\n    port dataIn: DataIn;\n    port dataOut: DataOut;\n  }\n  block WeightEvaluator {\n    port dataIn: DataOut;\n    port resultOut: Result;\n  }\n  action CollectWeightData {\n    from Vehicle.dataOut to WeightSensor.dataIn;\n  }\n  action ProcessWeightData {\n    from WeightSensor.dataIn to WeightProcessor.dataIn;\n  }\n  action EvaluateWeight {\n    from WeightProcessor.dataOut to WeightEvaluator.dataIn;\n  }\n  action GenerateResult {\n    from WeightEvaluator.resultOut to Result;\n  }\n  block Result {\n    attribute def Status {\n      value: 'Qualified' | 'Unqualified';\n    }\n  }\n  interface DataIn {\n    in data: Real;",
    "package 'VehicleMassVerification' {\n  attribute def MaxMass : Real = 2500;\n  \n  block Vehicle {\n    port massSensorPort: MassSensorPort;\n  }\n  \n  block WeighingEquipment {\n    port massSensorPort: MassSensorPort;\n    port massOutputPort: MassOutputPort;\n  }\n  \n  block MassVerificationUnit {\n    port vehiclePort: VehiclePort;\n    port weighingEquipmentPort: WeighingEquipmentPort;\n    port resultPort: ResultPort;\n  }\n  \n  interface MassSensorPort {\n    in mass: Real;\n  }\n  \n  interface MassOutputPort {\n    out mass: Real;\n  }\n  \n  interface VehiclePort {\n    in vehicle: Vehicle;\n  }\n  \n  interface WeighingEquipmentPort {\n    in weighingEquipment: WeighingEquipment;\n  }\n  \n  interface ResultPort {\n    out result: Boolean;\n  }\n  \n  action MassVerificationProcess {\n    block MassVerification {\n      part vehicle: Vehicle;\n      part weighingEquipment: WeighingEquipment;\n      part mass",
    "package 'TransportationSystem' {\n  attribute def Driver;\n  attribute def Passengers;\n  attribute def StartingPoint;\n  attribute def Destination;\n  port def UserEntryExitPort {\n    in userEntryExit : Boolean;\n  }\n  part context {\n    part vehicle {\n      port userEntryExitPort: UserEntryExitPort;\n      part driver {\n        port userEntryExitPort: ~UserEntryExitPort;\n      }\n      part passengers {\n        port userEntryExitPort: ~UserEntryExitPort;\n      }\n    }\n    part environment {\n      port environmentalFactors : String;\n    }\n    part infrastructure {\n      port gasStationCompatibility : Boolean;\n    }\n  }\n  action transportationProcess {\n    action userEntryExit {\n      in userEntryExit = userEntryExitPort.userEntryExit;\n    }\n    succession flow entryExitFlow from userEntryExit.userEntryExit to transportationProcess.start;\n    action start {\n      in driver = driver.Driver;\n      in passengers = passengers.Passengers;\n      in startingPoint = startingPoint.StartingPoint;\n      in destination =",
    "package 'TransportationSystem' {\n  attribute def Driver;\n  attribute def Passengers;\n  attribute def Vehicle;\n  attribute def Destination;\n  attribute def FuelLevel;\n  port def DriverPort {\n    in driver: Driver;\n  }\n  port def PassengerPort {\n    in passenger: Passengers;\n  }\n  port def VehiclePort {\n    in vehicle: Vehicle;\n  }\n  port def DestinationPort {\n    in destination: Destination;\n  }\n  port def FuelStationPort {\n    in fuelLevel: FuelLevel;\n  }\n  part context {\n    part user {\n      port driverPort: DriverPort;\n      port passengerPort: PassengerPort;\n      perform enterVehicle {\n        out driver = driverPort.driver;\n        out passengers = passengerPort.passengers;\n      }\n    }\n    part driver {\n      port driverPort: ~DriverPort;\n      perform operateVehicle {\n        in driver = driverPort.driver;\n        in vehicle = vehiclePort.vehicle;\n      }\n    }\n    part vehicle {\n      port vehiclePort: ~VehiclePort;\n      port destinationPort",
    "package 'VehicleConfiguration' {\n  \n  class Engine {\n    attribute def CylinderCount : Integer;\n    attribute def CylinderDiameter : String;\n  }\n  \n  class FourCylinderEngine {\n    extends Engine {\n      CylinderCount = 4;\n    }\n  }\n  \n  class SixCylinderEngine {\n    extends Engine {\n      CylinderCount = 6;\n    }\n  }\n  \n  class CylinderDiameterOption {\n    attribute def Diameter : String;\n  }\n  \n  class SmallCylinderDiameter {\n    extends CylinderDiameterOption {\n      Diameter = \"70 mm\";\n    }\n  }\n  \n  class LargeCylinderDiameter {\n    extends CylinderDiameterOption {\n      Diameter = \"100 mm\";\n    }\n  }\n  \n  class Transmission {\n    attribute def Type : String;\n  }\n  \n  class ManualTransmission {\n    extends Transmission {\n      Type = \"Manual\";\n    }\n  }\n  \n  class AutomaticTransmission {\n    extends Transmission {\n      Type = \"Automatic\";\n    }\n  }\n  \n  class Vehicle {\n    ",
    "package 'Engine' {\n  \n  block Cylinder {\n    property CylinderCount : Integer = 4;\n    property Diameter : String = \"70 mm\";\n  }\n  \n  block Engine {\n    property CylinderCount : Integer;\n    property Diameter : String;\n    part CylinderPart {\n      part Cylinder : Cylinder;\n    }\n    \n    variant FourCylinderEngine {\n      CylinderCount = 4;\n    }\n    variant SixCylinderEngine {\n      CylinderCount = 6;\n    }\n  }\n}",
    "package 'AutomotiveConfiguration' {\n  \n  class Engine {\n    property CylinderCount : Integer;\n    property CylinderDiameter : String;\n  }\n  \n  class FourCylinderEngine extends Engine {\n    property CylinderCount = 4;\n  }\n  \n  class SixCylinderEngine extends Engine {\n    property CylinderCount = 6;\n  }\n  \n  class Transmission {\n    property Type : String;\n  }\n  \n  class ManualTransmission extends Transmission {\n    property Type = \"Manual\";\n  }\n  \n  class AutomaticTransmission extends Transmission {\n    property Type = \"Automatic\";\n  }\n  \n  class Vehicle {\n    part Engine : Engine;\n    part Transmission : Transmission;\n  }\n  \n  constraint EngineTransmissionConstraint {\n    Vehicle.Engine.CylinderCount = 4 implies Vehicle.Transmission.Type = \"Manual\";\n    Vehicle.Engine.CylinderCount = 6 implies Vehicle.Transmission.Type = \"Automatic\";\n  }\n}",
    "package 'System' {\n  part systemAssembly {\n    part computerSubsystem {\n      interface softwareInterface {\n        port messagePort {\n          out message : Message;\n        }\n        port dataPort {\n          out data : Data;\n        }\n      }\n    }\n    part storageSubsystem {\n      interface softwareInterface {\n        port messagePort {\n          in message : Message;\n        }\n        port dataPort {\n          in data : Data;\n        }\n      }\n    }\n  }\n  interface softwareDesign {\n    block messageFormat {\n      \n    }\n    block dataFormat {\n      \n    }\n  }\n  action processInformation {\n    succession flow dataFlow from softwareDesign.dataFormat to computerSubsystem.dataPort;\n    succession flow messageFlow from softwareDesign.messageFormat to computerSubsystem.messagePort;\n    succession flow storageAccess from computerSubsystem.dataPort to storageSubsystem.dataPort;\n    succession flow storageAccess from computerSubsystem.messagePort to storageSubsystem.messagePort;\n  }\n}",
    "package 'PowertrainSystem' {\n  block LogicalLayer {\n    block TorqueGenerator {\n      property PowerOutput : Real;\n      property TorqueOutput : Real;\n    }\n  }\n  block PhysicalLayer {\n    block PowerUnit {\n      property PowerOutput : Real;\n      property TorqueOutput : Real;\n    }\n  }\n  relationship LogicalToPhysicalMapping {\n    source LogicalLayer.TorqueGenerator;\n    target PhysicalLayer.PowerUnit;\n  }\n}",
    "package 'PowerTransmissionSystem' {\n  block PowerTransmissionSystem {\n    part Engine {\n      port PowerOutputPort {\n        out power: Power;\n      }\n      port TorqueOutputPort {\n        out torque: Torque;\n      }\n      behavior generateTorque {\n        action generateTorque {\n          in power = PowerOutputPort.power;\n          out torque = TorqueOutputPort.torque;\n        }\n      }\n    }\n    block TorqueGenerator {\n      port PowerInputPort {\n        in power: Power;\n      }\n      port TorqueOutputPort {\n        out torque: Torque;\n      }\n      behavior generateTorque {\n        action generateTorque {\n          in power = PowerInputPort.power;\n          out torque = TorqueOutputPort.torque;\n        }\n      }\n    }\n    allocation EngineToTorqueGenerator {\n      from PowerTransmissionSystem.Engine to TorqueGenerator;\n      from PowerTransmissionSystem.Engine.generateTorque to TorqueGenerator.generateTorque;\n    }\n  }\n}",
    "package 'VehicleFeatureAnnotationSystem' {\n  block Vehicle {\n    part Interior {\n      part SeatBelt {\n        property SafetyFunction : SafetyFunction;\n      }\n      part FrontSeat {\n        property SafetyFunction : SafetyFunction;\n      }\n      part DriverAirbag {\n        property SafetyFunction : SafetyFunction;\n      }\n      part AlarmSystem {\n        property SecurityFunction : SecurityFunction;\n      }\n    }\n    part BodyAssembly {\n      part BodyShell {\n        property SafetyFunction : SafetyFunction;\n      }\n      part Bumpers {\n        property SafetyFunction : SafetyFunction;\n      }\n      part KeylessEntryDevice {\n        property SecurityFunction : SecurityFunction;\n      }\n    }\n  }\n  enumeration SafetyFunction {\n    value SeatBelt;\n    value Airbag;\n    value Bumper;\n  }\n  enumeration SecurityFunction {\n    value Alarm;\n    value KeylessEntry;\n  }\n}",
    "package 'VehicleDynamics' {\n  attribute def InitialVelocity;\n  attribute def InitialPosition;\n  attribute def Acceleration;\n  attribute def TimeStep;\n  attribute def FinalVelocity;\n  attribute def FinalPosition;\n  port def InputPort {\n    in initialVelocity: InitialVelocity;\n    in initialPosition: InitialPosition;\n    in acceleration: Acceleration;\n    in timeStep: TimeStep;\n  }\n  port def OutputPort {\n    out finalVelocity: FinalVelocity;\n    out finalPosition: FinalPosition;\n  }\n  part context {\n    part user {\n      port inputPort: InputPort;\n      port outputPort: OutputPort;\n      perform simulateVehicleDynamics {\n        in initialVelocity = inputPort.initialVelocity;\n        in initialPosition = inputPort.initialPosition;\n        in acceleration = inputPort.acceleration;\n        in timeStep = inputPort.timeStep;\n        out finalVelocity = outputPort.finalVelocity;\n        out finalPosition = outputPort.finalPosition;\n      }\n    }\n    part modelCenter {\n      port inputPort: ~InputPort;\n      port outputPort:",
    "package 'Safety Features' {\n\tpart seatBelt {\n\t\tannotation isMandatory = true;\n\t\tannotation @Safety;\n\t}\n\tpart seatBelt2 {\n\t\tannotation isMandatory = true;\n\t\tannotation @Safety;\n\t}\n\tpart airbag {\n\t\tannotation @Safety;\n\t}\n\tpart bumper {\n\t\tannotation isMandatory = true;\n\t\tannotation @Safety;\n\t}\n\tpart keylessEntry {\n\t\tannotation @Safety;\n\t}\n\tpart wheel {\n\t\tannotation @Safety;\n\t}\n\tpart abs {\n\t\tannotation @Safety;\n\t}\n}\npackage 'Mandatory Safety Features' {\n\tpart seatBelt {\n\t\tannotation isMandatory = true;\n\t\tannotation @Safety;\n\t}\n\tpart seatBelt2 {\n\t\tannotation isMandatory = true;\n\t\tannotation @Safety;\n\t}\n\tpart bumper {\n\t\tannotation isMandatory = true;\n\t\tannotation @Safety;\n\t}\n}\n\n\n\n",
    "package 'VehicleSafetyCompliance' {\n  class Vehicle {\n    part interior {\n      part seatBelt1 {\n        property mandatory : Boolean = true;\n      }\n      part seatBelt2 {\n        property mandatory : Boolean = true;\n      }\n      part driverAirbag {\n        property mandatory : Boolean = false;\n      }\n    }\n    part body {\n      part bumper {\n        property mandatory : Boolean = true;\n      }\n      part keylessEntry {\n        property mandatory : Boolean = false;\n      }\n    }\n    part chassis {\n      part tires {\n        property fixedQuantity : Integer = 4;\n      }\n      part abs {\n        property mandatory : Boolean = false;\n      }\n    }\n  }\n}\n\n\n\n",
    "package 'RiskManagementSystem' {\n  attribute def Situation;\n  attribute def Cause;\n  attribute def Failure;\n  attribute def Probability;\n  attribute def Severity;\n  port def SituationPort {\n    out situation: Situation;\n  }\n  port def CausePort {\n    out cause: Cause;\n  }\n  port def FailurePort {\n    out failure: Failure;\n  }\n  part context {\n    part user {\n      port situationPort: SituationPort;\n      port causePort: CausePort;\n      port failurePort: FailurePort;\n      perform identifySituation {\n        out situation = situationPort.situation;\n      }\n      perform identifyCause {\n        out cause = causePort.cause;\n      }\n      perform identifyFailure {\n        out failure = failurePort.failure;\n      }\n    }\n    part riskManagementSystem {\n      port situationPort: ~SituationPort;\n      port causePort: ~CausePort;\n      port failurePort: ~FailurePort;\n      perform analyzeRisk {\n        in situation = situationPort.situation;\n        in cause = causePort.cause;\n        in failure",
    "package 'RiskManagementSystem' {\n  \n  attribute def ScenarioID;\n  attribute def ScenarioDescription;\n  attribute def CauseID;\n  attribute def CauseDescription;\n  attribute def CauseProbability;\n  attribute def FailureType;\n  attribute def FailureSeverity;\n  attribute def CausalRelationship;\n  \n  part Scenario {\n    port ScenarioIDPort {\n      out scenarioID: ScenarioID;\n    }\n    port ScenarioDescriptionPort {\n      out scenarioDescription: ScenarioDescription;\n    }\n    part Cause {\n      port CauseIDPort {\n        out causeID: CauseID;\n      }\n      port CauseDescriptionPort {\n        out causeDescription: CauseDescription;\n      }\n      port CauseProbabilityPort {\n        out causeProbability: CauseProbability;\n      }\n      part Failure {\n        port FailureTypePort {\n          out failureType: FailureType;\n        }\n        port FailureSeverityPort {\n          out failureSeverity: FailureSeverity;\n        }\n      }\n    }\n    part CausalRelationship {\n      port CausalRelationshipPort {\n        out causalRelationship: CausalRelationship;\n      }\n    }\n  }",
    "package 'RiskAnalysisSystem' {\n  attribute def BatteryLevel;\n  attribute def BatteryAge;\n  attribute def RiskLevel;\n  port def BatteryLevelPort {\n    out batteryLevel: BatteryLevel;\n  }\n  port def BatteryAgePort {\n    out batteryAge: BatteryAge;\n  }\n  port def RiskLevelPort {\n    out riskLevel: RiskLevel;\n  }\n  part context {\n    part equipment {\n      port batteryLevelPort: BatteryLevelPort;\n      port batteryAgePort: BatteryAgePort;\n      port riskLevelPort: RiskLevelPort;\n    }\n    interface equipmentToSystem connect equipment.batteryLevelPort to system.batteryLevelPort {\n      ref flow references batteryLevelFlow\n        from source.batteryLevel to target.batteryLevel;\n    }\n    interface equipmentToSystem connect equipment.batteryAgePort to system.batteryAgePort {\n      ref flow references batteryAgeFlow\n        from source.batteryAge to target.batteryAge;\n    }\n    part system {\n      port batteryLevelPort: ~BatteryLevelPort;\n      port batteryAgePort: ~BatteryAgePort",
    "package 'System' {\n  block System {\n    part Subsystem1 {\n      block Subsystem1 {\n        part Component1 {\n          block Component1 {\n            \n          }\n        }\n        part Component2 {\n          block Component2 {\n            \n          }\n        }\n      }\n    }\n    part Subsystem2 {\n      block Subsystem2 {\n        part Component3 {\n          block Component3 {\n            \n          }\n        }\n        part Component4 {\n          block Component4 {\n            \n          }\n        }\n      }\n    }\n    interface SystemInterface {\n      port port1 : Type1;\n      port port2 : Type2;\n    }\n  }\n}",
    "package 'AutomotiveSystem' {\n  \n  block RootComponent {\n    \n    part Subsystem1 {\n      part ComponentA {\n        property safetyAttribute : SafetyLevel;\n        property mandatory : Boolean;\n      }\n      part ComponentB {\n        property safetyAttribute : SafetyLevel;\n        property mandatory : Boolean;\n      }\n    }\n    part Subsystem2 {\n      part ComponentC {\n        property safetyAttribute : SafetyLevel;\n        property mandatory : Boolean;\n      }\n      part ComponentD {\n        property safetyAttribute : SafetyLevel;\n        property mandatory : Boolean;\n      }\n    }\n  }\n  \n  enum SafetyLevel {\n    Mandatory,\n    Optional\n  }\n  \n  view HierarchicalStructure {\n    type : Tree;\n    show : RootComponent,\n           RootComponent.Subsystem1,\n           RootComponent.Subsystem1.ComponentA,\n           RootComponent.Subsystem1.ComponentB,\n           Root",
    "package 'AutomotiveDomainModel' {\n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n",
    "package 'DocumentManagementPlatform' {\n  \n  class Automobile {\n    \n    attribute def id : String;\n    attribute def description : String;\n    \n    part document : Document;\n    part alias : Car;\n  }\n  \n  class Car {\n    \n    alias Automobile;\n  }\n  \n  class Document {\n    \n    attribute def content : String;\n    \n    part physicalQuantity : PhysicalQuantity;\n  }\n  \n  class PhysicalQuantity {\n    \n    attribute def unit : String;\n    attribute def value : Real;\n  }\n  \n  class TorqueValue {\n    \n    extends PhysicalQuantity;\n  }\n  \n  class Explanation {\n    \n    attribute def text : String;\n    \n    part object : Object;\n  }\n  \n  class Object {\n    \n    attribute def name : String;\n  }\n}\n\n\n\n",
    "package 'AutomobileSystem' {\n  \n  class Automobile {\n    \n    attribute def TorqueValue : TorqueValue;\n    \n    alias def Car;\n  }\n  \n  class TorqueValue {\n    \n    attribute def Value : Real;\n    \n    alias def Torque;\n  }\n  \n  class PhysicalQuantity {\n    \n    attribute def Value : Real;\n  }\n}\n\n\n\n",
    "package 'VehicleSystem' {\n  class Vehicle {\n    property size : String;\n    part engine : Engine;\n  }\n  class Engine {\n    property cylinderCount : Integer;\n  }\n  class BasicVehicle {\n    extends Vehicle;\n  }\n  class SmallVehicle {\n    extends BasicVehicle;\n    constraint size = \"Small\";\n  }\n  class LargeVehicle {\n    extends BasicVehicle;\n    constraint size = \"Large\";\n  }\n  block EngineConfiguration {\n    input vehicleSize : String;\n    output cylinderCount : Integer;\n    behavior {\n      if vehicleSize = \"Small\" then\n        cylinderCount = 4;\n      else if vehicleSize = \"Large\" then\n        cylinderCount = 6;\n      else\n        cylinderCount = 4;\n    }\n  }\n}",
    "package 'FuelSystem' {\n  attribute def FuelLevel;\n  attribute def FuelTemperature;\n  port def FuelTankPort {\n    in fuelIn: Fuel;\n    out fuelOut: Fuel;\n  }\n  port def EnginePort {\n    in fuelIn: Fuel;\n    out fuelOut: Fuel;\n  }\n  part context {\n    part fuelTank {\n      port fuelTankPort: ~FuelTankPort;\n    }\n    part engine {\n      port enginePort: ~EnginePort;\n    }\n    interface fuelTankToEngine connect fuelTank.fuelTankPort to engine.enginePort {\n      ref flow references fuelFlow\n        from source.fuelOut to target.fuelIn;\n    }\n  }\n  action fuelManagement {\n    action fuelDelivery {\n      in fuelLevel = FuelLevel;\n      in fuelTemperature = FuelTemperature;\n      out fuelFlow: Fuel;\n    }\n    action fuelReturn {\n      in fuelFlow: Fuel;\n    }\n  }\n}",
    "package 'VehicleStructure' {\n  attribute def Mass;\n  part vehicle {\n    attribute mass : Mass;\n    part frontAxleAssembly;\n    part rearAxleAssembly;\n  }\n  part axleAssembly {\n    part axle;\n    part wheel1;\n    part wheel2;\n  }\n  part frontAxleAssembly {\n    part frontAxle : frontAxleType;\n    part axleAssembly1;\n  }\n  part rearAxleAssembly {\n    part rearAxle : axleType;\n    part axleAssembly2;\n  }\n  part frontAxleType {\n    attribute def SteeringAngle;\n  }\n  part wheel {\n    attribute def WheelName;\n  }\n}"
]