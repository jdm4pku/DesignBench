[
    "model VehicleModel {\n  class Vehicle {\n    property mass : Integer;\n    property currentStatus : Status;\n    property engine : Engine [1] {subsets parts};\n    property driver : Driver [0..1];\n  }\n\n  class Status {\n    property gearSetting : String;\n    property acceleratorPedalPosition : Float;\n  }\n\n  class Engine {\n    // Engine-specific properties can be added here\n  }\n\n  class Driver {\n    // Driver-specific properties can be added here\n  }\n\n  association VehicleEngineAssociation {\n    member end vehicle : Vehicle [1] = Vehicle.engine;\n    member end engine : Engine [1];\n  }\n\n  association VehicleDriverAssociation {\n    member end vehicle : Vehicle [1] = Vehicle.driver;\n    member end driver : Driver [1];\n  }\n}",
    "package VehicleModel {\n    class Vehicle\n    class ManuallyOperatedVehicle <|-- Vehicle {\n        driver:Personnel[1]\n    }\n    class PoweredVehicle <|-- Vehicle {\n        engine:Engine[1]\n    }\n    class ManuallyOperatedPoweredVehicle <|-- ManuallyOperatedVehicle, PoweredVehicle\n    class Personnel\n    class Engine\n}",
    "package AutomotiveStructure {\n  class VehicleComponent {}\n  \n  class Engine extends VehicleComponent {}\n  \n  class Transmission extends VehicleComponent {}\n  \n  class Wheel extends VehicleComponent {}\n  \n  class Vehicle {\n    part engine : Engine [1];\n    part transmission : Transmission [1];\n    part wheels : Wheel [4];\n  }\n}\n```",
    "class Cylinder component;class Engine component {\n    part cylinders : Cylinder [1..*];\n}class SmallEngine extends Engine {\n    redef part cylinders : Cylinder [4];\n}class LargeEngine extends Engine {\n    redef part cylinders : Cylinder [6];\n}class Vehicle {\n    part engine : Engine;\n}class SmallVehicle extends Vehicle {\n    redef part engine : SmallEngine;\n}class LargeVehicle extends Vehicle {\n    redef part engine : LargeEngine;\n}",
    "model TrafficSignalSystem {\n  component TrafficSignal {\n    state machine ColorState {\n      initial state Initial {\n        entry: set color to Green;\n      }\n      state Green {\n        entry: set color to Green;\n      }\n      state Yellow {\n        entry: set color to Yellow;\n      }\n      state Red {\n        entry: set color to Red;\n      }\n      transition Initial -> Green {\n        trigger: start;\n      }\n      transition Green -> Yellow {\n        trigger: changeToYellow;\n      }\n      transition Yellow -> Red {\n        trigger: changeToRed;\n      }\n      transition Red -> Green {\n        trigger: changeToGreen;\n      }\n    }\n  }\n\n  component AlwaysGreenTrafficSignal {\n    state machine ColorState {\n      initial state Initial {\n        entry: set color to Green;\n      }\n      state Green {\n        entry: set color to Green;\n      }\n    }\n  }\n}",
    "module InformationClassificationSystem {\n  enumeration InformationLevel {\n    unclassified,\n    confidential,\n    secret;\n  }\n\n  enumeration Color {\n    green,\n    yellow,\n    red;\n  }\n\n  value type InformationClassification {\n    code : String;\n    color : Color;\n  }\n\n  value specification Unclassified : InformationClassification {\n    code = \"uncl\";\n    color = green;\n  }\n\n  value specification Confidential : InformationClassification {\n    code = \"conf\";\n    color = yellow;\n  }\n\n  value specification Secret : InformationClassification {\n    code = \"secr\";\n    color = red;\n  }\n\n  enumeration GradeLevel {\n    A,\n    B,\n    C,\n    D,\n    F;\n  }\n\n  value type GradeClassification {\n    grade : GradeLevel;\n    points : Real;\n  }\n\n  value specification GradeA : GradeClassification {\n    grade = A;\n    points = 4.0;\n  }\n\n  value specification GradeB : GradeClassification {\n    grade = B;\n    points = 3.0;\n  }\n\n  value specification GradeC : GradeClassification {\n    grade = C;\n    points = 2.0;\n  }\n\n  value specification GradeD : GradeClassification {\n    grade = D;\n    points = 1.0;\n  }\n\n  value specification GradeF : GradeClassification {\n    grade = F;\n    points = 0.0;\n  }\n}",
    "model Vehicles {\n  class Vehicle {\n    part engine : Engine [1];\n  }\n  class SmallVehicle extends Vehicle {\n    redefines engine : SmallEngine [1];\n  }\n  class LargeVehicle extends Vehicle {\n    redefines engine : LargeEngine [1];\n  }\n  class Engine {\n    part cylinders : Cylinder [4..6];\n  }\n  class SmallEngine extends Engine {\n    redefines cylinders : Cylinder [4];\n  }\n  class LargeEngine extends Engine {\n    redefines cylinders : Cylinder [6];\n  }\n  class Cylinder;\n}",
    "model VehicleModel {\n  class Vehicle {\n    driver: Driver [1]\n    fuelTank: FuelTank [1]\n    qualityAttributes: QualityAttribute [*]\n  }\n\n  class Driver {\n    name: String\n    licenseNumber: String\n  }\n\n  class FuelTank {\n    fuelType: Fuel [1]\n  }\n\n  class Fuel {\n    type: String\n    capacity: Integer\n  }\n\n  class Personnel {\n    name: String\n    id: String\n  }\n\n  class QualityAttribute {\n    name: String\n    value: String\n  }\n}",
    "block WheelAssembly {\n  part wheelBearingUnit : WheelBearingUnit;\n  part tire : Tire;\n  part hub : Hub;\n  part boltConnections : BoltConnection[*];\n  \n  connection tire.beads[0] to hub.rims[0];\n  connection tire.beads[1] to hub.rims[1];\n  \n  for (i in 0 to size(boltConnections)-1) {\n    connection hub.mountingHoles[i] to boltConnections[i].mountingHole;\n    connection hub.threadedHoles[i] to boltConnections[i].threadedHole;\n  }\n}\n\nblock Tire {\n  part beads : Bead[2];\n}\n\nblock Hub {\n  part rims : Rim[2];\n  part mountingHoles : MountingHole[*];\n  part threadedHoles : ThreadedHole[*];\n}\n\nblock Bead;\n\nblock Rim;\n\nblock WheelBearingUnit;\n\nblock MountingHole;\n\nblock ThreadedHole;\n\nblock Bolt;\n\nblock BoltConnection {\n  part mountingHole : MountingHole;\n  part threadedHole : ThreadedHole;\n  part bolt : Bolt;\n}",
    "block FuelInterface {\n  temperature : Real;\n}\n\nblock FuelTankAssembly {\n  supplyPort : Port [out] conformsTo FuelInterface {\n    fuelSupplyFlow : Real;\n  };\n  returnPort : Port [in] conformsTo FuelInterface {\n    fuelReturnFlow : Real;\n  };\n}\n\nblock Engine {\n  intakePort : Port [in] conformsTo FuelInterface {\n    fuelConsumptionFlow : Real;\n  };\n  returnPort : Port [out] conformsTo FuelInterface {\n    fuelReturnFlow : Real;\n  };\n}\n\nblock System {\n  fuelTank : FuelTankAssembly;\n  engine : Engine;\n}",
    "model BaseVehicleModel {\n  class Vehicle {\n    mass : Real = 1750;\n    part frontAxle : Axle;\n    part rearAxle : Axle;\n  }\n\n  class Axle {\n    mass : Real = 500;\n    part tires[*2 ordered] : Tire;\n  }\n\n  class Tire {\n    mass : Real = 20;\n  }\n}\n\nvariant model VehicleVariantModel {\n  variant Vehicle {\n    mass : Real = 2000;\n    part dedicatedFrontAxle : DedicatedFrontAxle;\n    part rearAxle : Axle;\n  }\n\n  class DedicatedFrontAxle : Axle {\n    steeringAngle : Real;\n    mass : Real = 550;\n  }\n}",
    "model CouplingSystemModel {\n  component Vehicle {\n    port hitchReference: reference CouplingBall;\n  }\n  component Trailer {\n    port connectorReference: reference Connector;\n  }\n  component Hitch {\n    part couplingBall: CouplingBall;\n    part connector: Connector;\n  }\n  component CouplingBall;\n  component Connector;\n\n  connect Vehicle.hitchReference to Hitch.couplingBall via physical;\n  connect Trailer.connectorReference to Hitch.connector via physical;\n}",
    "model VehiclePowerTransmissionSystem\n  interface block FuelCommandInterface\n  interface block PowerInterface\n  interface block ClutchInterface\n  interface block RoadInterface\n\n  block Engine\n    port fuelCommandPort: FuelCommandInterface in\n    port powerPort: PowerInterface out\n    port clutchPort: ClutchInterface out\n  end\n\n  block Transmission\n    port powerInput: PowerInterface in\n    port clutchInput: ClutchInterface in\n    port outputPower: PowerInterface out\n  end\n\n  block Clutch\n    port inputClutchPort: ClutchInterface in\n    port outputClutchPort: ClutchInterface out\n  end\n\n  block Driveshaft\n    port inputPower: PowerInterface in\n    port outputPower: PowerInterface out\n  end\n\n  block Differential\n    port powerInput: PowerInterface in\n    port leftOutput: PowerInterface out\n    port rightOutput: PowerInterface out\n  end\n\n  block LeftHalfShaft\n    port inputPower: PowerInterface in\n    port outputPower: PowerInterface out\n    connect inputPower to outputPower\n  end\n\n  block RightHalfShaft\n    port inputPower: PowerInterface in\n    port outputPower: PowerInterface out\n    connect inputPower to outputPower\n  end\n\n  block RearAxleAssembly\n    port inputPower: PowerInterface in\n    part differential: Differential\n    part leftHalfShaft: LeftHalfShaft\n    part rightHalfShaft: RightHalfShaft\n    connect inputPower to differential.powerInput\n    connect differential.leftOutput to leftHalfShaft.inputPower\n    connect differential.rightOutput to rightHalfShaft.inputPower\n  end\n\n  block Wheel\n    port inputPower: PowerInterface in\n    port roadInterfacePort: RoadInterface out\n  end\n\n  block RoadInterface\n    port roadPort: RoadInterface in\n  end\n\n  part engine: Engine\n  part transmission: Transmission\n  part clutch: Clutch\n  part driveshaft: Driveshaft\n  part rearAxle: RearAxleAssembly\n  part leftWheel: Wheel\n  part rightWheel: Wheel\n  part leftRoadInterface: RoadInterface\n  part rightRoadInterface: RoadInterface\n\n  connect engine.powerPort to transmission.powerInput\n  connect engine.clutchPort to clutch.inputClutchPort\n  connect clutch.outputClutchPort to transmission.clutchInput\n  connect transmission.outputPower to driveshaft.inputPower\n  connect driveshaft.outputPower to rearAxle.inputPower\n  connect rearAxle.leftHalfShaft.outputPower to leftWheel.inputPower\n  connect rearAxle.rightHalfShaft.outputPower to rightWheel.inputPower\n  connect leftWheel.roadInterfacePort to leftRoadInterface.roadPort\n  connect rightWheel.roadInterfacePort to rightRoadInterface.roadPort\nend",
    "model System {\n  interface pe;\n  interface pf;\n  component c1 {\n    port pb: pe;\n    port pa: Signal;\n  };\n  component c2 {\n    port pb: Signal;\n  };\n  component c3 {\n    port pd: pf;\n    port pa: Signal;\n  };\n  component c4 {\n    port pb: Signal;\n  };\n  model b11 {\n    part c1: Component;\n    part c2: Component;\n    connection c1.pa -> c2.pb;\n    bind c1.pb to pe;\n  };\n  model b12 {\n    part c3: Component;\n    part c4: Component;\n    connection c3.pa -> c4.pb;\n    bind c3.pd to pf;\n  };\n  breakdown b11, b12;\n  part b11: Subsystem;\n  part b12: Subsystem;\n  connection b11.pe -> b12.pf;\n  model a11 {\n    part c1: Component;\n    part c2: Component;\n    part c3: Component;\n    part c4: Component;\n  };\n  model b21 {\n    part c1: Component ref a11.c1;\n    part c3: Component ref a11.c3;\n  };\n  model b22 {\n    part c2: Component ref a11.c2;\n    part c4: Component ref a11.c4;\n  };\n  breakdown b21, b22;\n  part b21: Module;\n  part b22: Module;\n  part a11: System;\n}",
    "block PowertrainSystem {\n  part engine : Engine;\n  part transmission : Transmission;\n  part driveshaft : Driveshaft;\n  part leftWheel : Wheel;\n  part rightWheel : Wheel;\n  property fuelCommand : Real;\n  operation startEngine() {\n    engine.startEngine();\n  }\n  operation stopEngine() {\n    engine.stopEngine();\n  }\n  constraint {\n    engine.engineTorque = fuelCommand;\n    transmission.inputTorque = engine.engineTorque;\n    driveshaft.inputTorque = transmission.outputTorque;\n    leftWheel.inputTorque = driveshaft.outputTorque / 2;\n    rightWheel.inputTorque = driveshaft.outputTorque / 2;\n  }\n}\n\nblock Engine {\n  property fuelCommand : Real;\n  property engineState : String;\n  property engineTorque : Real;\n  operation startEngine() {\n    engineState = \"Running\";\n  }\n  operation stopEngine() {\n    engineState = \"Shutdown\";\n  }\n  constraint {\n    if (engineState == \"Running\") then {\n      engineTorque = fuelCommand;\n    } else {\n      engineTorque = 0.0;\n    }\n  }\n}\n\nblock Transmission {\n  property inputTorque : Real;\n  property outputTorque : Real;\n  constraint {\n    outputTorque = inputTorque * 1.5;\n  }\n}\n\nblock Driveshaft {\n  property inputTorque : Real;\n  property outputTorque : Real;\n  constraint {\n    outputTorque = inputTorque;\n  }\n}\n\nblock Wheel {\n  property inputTorque : Real;\n  property drivingForce : Real;\n  constraint {\n    drivingForce = inputTorque;\n  }\n}\n```",
    "block PowertrainSystem {\n  part engine : Engine;\n  part torqueAmplifier : TorqueAmplifier;\n  part transmission : Transmission;\n  part driveWheels : DriveWheels;\n  property fuelControlCommand : FuelControlCommand;\n  property stallSignal : StallSignal;\n\n  operation startEngine() {\n    self.engine.start();\n  }\n\n  operation shutdownEngine() {\n    self.engine.shutdown();\n  }\n\n  operation generateTorque() {\n    self.engine.generatedTorque = self.engine.calculateTorque(self.fuelControlCommand);\n  }\n\n  operation amplifyTorque() {\n    self.torqueAmplifier.amplifiedTorque = self.torqueAmplifier.amplify(self.engine.generatedTorque);\n  }\n\n  operation transmitTorque() {\n    self.transmission.transmittedTorque = self.transmission.transmit(self.torqueAmplifier.amplifiedTorque);\n  }\n\n  operation distributeTorque() {\n    self.driveWheels.outputTorque = self.transmission.transmittedTorque;\n  }\n\n  constraint c1 : StallCondition;\n}\n\nblock Engine {\n  operation start();\n  operation shutdown();\n  operation calculateTorque(fuelCommand : FuelControlCommand) : Torque;\n  property generatedTorque : Torque;\n}\n\nblock TorqueAmplifier {\n  operation amplify(inputTorque : Torque) : Torque;\n  property amplifiedTorque : Torque;\n}\n\nblock Transmission {\n  operation transmit(inputTorque : Torque) : Torque;\n  property transmittedTorque : Torque;\n}\n\nblock DriveWheels {\n  property outputTorque : Torque;\n  operation distribute(inputTorque : Torque) {\n    self.outputTorque = inputTorque;\n  }\n}\n\nsignal FuelControlCommand;\nsignal StallSignal;constraint StallCondition {\n  context PowertrainSystem;\n  self.stallSignal.implies(self.engine.isStopped and self.torqueAmplifier.isIdle and self.transmission.isNeutral and self.driveWheels.isLocked);\n}\n```",
    "model VehiclePowertrainModel {\n  block VehiclePowertrainSystem {\n    property fuelInputCommand : Real;\n    property engineStartSignal : Boolean;\n    property engineShutdownSignal : Boolean;\n    part engine : Engine;\n    part transmission : Transmission;\n    part wheel1, wheel2, wheel3, wheel4 : Wheel;\n    behavior managePowertrain {\n      state Inactive {\n        on entry {\n          // Terminate power output process\n        }\n        transition to Active when engineStartSignal == true;\n      }\n      state Active {\n        on entry {\n          // Initiate power output process\n        }\n        do {\n          action generateEngineTorque {\n            let engineTorque = engine.generateTorque(fuelInputCommand);\n            transmission.inputTorque = engineTorque;\n          }\n          action amplifyAndTransmitTorque {\n            transmission.outputTorque = transmission.amplifyAndTransmit(transmission.inputTorque);\n          }\n          action distributeTorqueToWheels {\n            wheel1.inputTorque = transmission.outputTorque;\n            wheel2.inputTorque = transmission.outputTorque;\n            wheel3.inputTorque = transmission.outputTorque;\n            wheel4.inputTorque = transmission.outputTorque;\n          }\n        }\n        transition to Inactive when engineShutdownSignal == true;\n      }\n    }\n  }\n  block Engine {\n    property outputTorque : Real;\n    behavior generateTorque {\n      input fuelCommand : Real;\n      output torque : Real;\n      action calculateTorque {\n        torque = fuelCommand * 10; // Example torque generation logic\n      }\n    }\n  }\n  block Transmission {\n    property inputTorque : Real;\n    property outputTorque : Real;\n    behavior amplifyAndTransmit {\n      input inputTorque : Real;\n      output outputTorque : Real;\n      action amplify {\n        outputTorque = inputTorque * 1.5; // Example amplification logic\n      }\n    }\n  }\n  block Wheel {\n    property inputTorque : Real;\n    behavior distributeTorque {\n      input torque : Real;\n      action applyTorque {\n        // Torque distribution logic to wheel\n      }\n    }\n  }\n}",
    "block StructuralFrame\n\nblock HitchBall\n\nblock TrailerCoupler\n\nblock Vehicle {\n  part frame : StructuralFrame;\n  part hitchBall : HitchBall;\n}\n\nblock Trailer {\n  part frame : StructuralFrame;\n  part coupler : TrailerCoupler;\n}\n\nblock PowerConnectionSystem {\n  part vehicle : Vehicle;\n  part trailer : Trailer;\n  constraint connectionState : ConnectionStateConstraint;\n}constraint block ConnectionStateConstraint {\n  value connected, disconnected;\n}\n```",
    "block VehicleTrailerSystem {\n  part vehicle : Vehicle;\n  part trailer : Trailer;\n  constraint safeReliableConnection;\n  operation hitch(towBall : TowBall, coupler : Coupler) : Boolean;\n  operation unhitch(towBall : TowBall, coupler : Coupler) : Boolean;\n}\n\nblock Vehicle {\n  part chassis : Chassis;\n  part towBall : TowBall;\n}\n\nblock Trailer {\n  part coupler : Coupler;\n  part trailerFrame : TrailerFrame;\n}\n\nblock Chassis {}\n\nblock TowBall {}\n\nblock Coupler {}\n\nblock TrailerFrame {}\n```",
    "model DynamicConnectionModel\n  class Vehicle\n    part chassis : Chassis\n    part towBall : TowBall\n  end\n\n  class Trailer\n    part trailerChassis : Chassis\n    part coupler : Coupler\n  end\n\n  class Chassis\n  end\n\n  class TowBall\n    property connected : Boolean\n  end\n\n  class Coupler\n    part internalStructure : InternalStructure\n    property state : String\n  end\n\n  class InternalStructure\n  end\n\n  constraint SecureLatch\n    Trailer.coupler.state == \"Engaged\" implies TowBall.connected == true\n  end\n\n  constraint SmoothSeparation\n    Trailer.coupler.state == \"Disengaged\" implies TowBall.connected == false\n  end\nend",
    "block FuelSystem {\n  part fuelTank: FuelTankAssembly;\n  part engine: Engine;\n  connect fuelTank.supply to engine.supply;\n  connect engine.return to fuelTank.return;\n}\n\nblock FuelTankAssembly {\n  port supply: FuelSupplyPort;\n  port return: FuelReturnPort;\n}\n\nblock Engine {\n  port supply: FuelSupplyPort;\n  port return: FuelReturnPort;\n}\n\ninterface FuelSupplyInterface {\n  action supplyFuel;\n}\n\ninterface FuelReturnInterface {\n  action returnFuel;\n}port FuelSupplyPort {\n  provides FuelSupplyInterface;\n}port FuelReturnPort {\n  requires FuelReturnInterface;\n}\n\nbehavior FuelFlowBehavior {\n  parameter temp: Temperature;\n  action supplyFuel {\n    when (temp < maxTemp) do;\n  }\n  action returnFuel {\n    when (temp < maxTemp) do;\n  }\n}constraint TemperatureConstraint {\n  parameter temp: Temperature;\n  constraintClause temp <= maxTemp;\n}\n```",
    "model FuelDeliverySystem {  \n  flow FuelFlow {  \n    property fuelQuantity : Real;  \n  }  \n  \n  block StorageTank {  \n    port out fuelOut : FlowPort<FuelFlow>;  \n    property capacity : Real;  \n    property currentLevel : Real;  \n  }  \n  \n  block FuelPump {  \n    port in fuelIn : FlowPort<FuelFlow>;  \n    port out fuelOut : FlowPort<FuelFlow>;  \n  }  \n  \n  block VehicleFuelTank {  \n    port in fuelIn : FlowPort<FuelFlow>;  \n    property capacity : Real;  \n    property currentLevel : Real;  \n  }  \n  \n  block FuelDeliverySystem {  \n    part storageTank : StorageTank;  \n    part fuelPump : FuelPump;  \n    part vehicleFuelTank : VehicleFuelTank;  \n  \n    connection storageToPump : fuelOut(storageTank) -> fuelIn(fuelPump);  \n    connection pumpToVehicle : fuelOut(fuelPump) -> fuelIn(vehicleFuelTank);  \n  \n    constraint maxCapacityConstraint : vehicleFuelTank.currentLevel <= vehicleFuelTank.capacity;  \n    constraint levelUpdateConstraint : vehicleFuelTank.currentLevel = vehicleFuelTank.currentLevel@pre + fuelOut(fuelPump).fuelQuantity;  \n  }  \n}",
    "block VehicleAssemblyWithoutGearboxAndEngine\nend\n\nblock Gearbox\nend\n\nblock Engine\nend\n\nblock VehicleAssemblyWithGearboxWithoutEngine\nend\n\nblock FullyAssembledVehicle\n  part gearbox : Gearbox\n  part engine : Engine\nend\n\naction InstallGearbox\n  input vehicle : VehicleAssemblyWithoutGearboxAndEngine\n  input gearbox : Gearbox\n  output assembly : VehicleAssemblyWithGearboxWithoutEngine\nend\n\naction InstallEngine\n  input vehicle : VehicleAssemblyWithGearboxWithoutEngine\n  input engine : Engine\n  output assembly : FullyAssembledVehicle\nend\n\nflow AssemblyProcess\n  step installGearbox : InstallGearbox\n  step installEngine : InstallEngine\n  sequence installGearbox >> installEngine\nend\n```",
    "block VehicleA {\n  stateMachine vehicleState : VehicleState;\n}\n\nblock VehicleController {\n  stateMachine controllerState : ControllerState;\n}\n\nsignal startSignal;\nsignal vehicleOnSignal;\nsignal restoreToNormalSignal;\nsignal overTemperatureSignal;\nsignal maintenanceSignal;\n\nstateMachine VehicleState {\n  initial state off {\n    entry / performInitialStartupChecks;\n  }\n  state starting {\n    entry / initiateStartingSequence;\n  }\n  state running {\n    entry / performSelfChecks, supplyPower;\n    exit / applyParkingBrake;\n  }\n  state degraded {\n    entry / enterDegradedMode;\n    exit / exitDegradedMode;\n  }\n  state maintenance {\n    entry / enterMaintenanceMode;\n    exit / exitMaintenanceMode;\n  }\n  state normal {\n    entry / resumeNormalOperation;\n  }\n  transition off -> starting {\n    trigger startSignal;\n    guard brakePressed;\n  }\n  transition starting -> running {\n    trigger vehicleOnSignal;\n  }\n  transition running -> degraded {\n    trigger temperatureExceedsThreshold;\n    action send overTemperatureSignal;\n  }\n  transition degraded -> normal {\n    trigger restoreToNormalSignal;\n  }\n  transition running -> maintenance {\n    trigger maintenanceSignal;\n  }\n  transition maintenance -> normal {\n    trigger restoreToNormalSignal;\n  }\n}\n\nstateMachine ControllerState {\n  initial state idle {\n    entry / awaitStartupSignal;\n  }\n  state active {\n    entry / manageVehicleStates;\n  }\n  transition idle -> active {\n    trigger startSignal;\n  }\n  transition active -> idle {\n    trigger shutdownSignal;\n  }\n}",
    "model VehicleSystem {\n  part vehicle : Vehicle;\n  part vehicleController : VehicleController;\n\n  property fuel : String;\n  property maintenanceInterval : Duration;\n  property temperatureThreshold : Temperature;\n\n  stateMachine VehicleStateMachine {\n    initial state shutdown;\n    state operational;\n    state degraded;\n\n    transition shutdown -> operational {\n      trigger brakePedalPressed, startSignalReceived;\n      activity selfInspection, powerSupply;\n    }\n\n    transition operational -> degraded {\n      trigger temperature > temperatureThreshold;\n      activity sendWarningSignal(vehicleController), ensureSafety;\n    }\n\n    transition degraded -> operational {\n      trigger faultRecoveryCompleted;\n      activity restoreNormalOperation;\n    }\n  }\n\n  behavior selfInspection {\n    do {\n      // Execute vehicle self-inspection procedures\n    }\n  }\n\n  behavior powerSupply {\n    do {\n      // Complete power supply initialization\n    }\n  }\n\n  behavior sendWarningSignal(input vehicleController : VehicleController) {\n    do {\n      vehicleController.receiveWarningSignal();\n    }\n  }\n\n  behavior ensureSafety {\n    do {\n      // Implement safety protocols in degraded mode\n    }\n  }\n\n  behavior receiveWarningSignal() {\n    do {\n      // Process warning signal and initiate fault handling\n    }\n  }\n\n  behavior restoreNormalOperation {\n    do {\n      // Execute fault recovery and return to normal mode\n    }\n  }\n\n  behavior handleMaintenance(input interval : Duration) {\n    do {\n      if (timeSinceLastMaintenance >= interval) {\n        perform scheduledMaintenance;\n      }\n    }\n  }\n}",
    "module SimulationSystem {  \n  class Vehicle {  \n    property mass : Real;  \n    property position : Real;  \n    property velocity : Real;  \n    property acceleration : Real;  \n    reference state : VehicleState;  \n  }  \n\n  class Road {  \n    property slope : Real;  \n    property frictionCoefficient : Real;  \n    reference state : RoadState;  \n  }  \n\n  class Snapshot {  \n    property time : Real;  \n    reference vehicleState : VehicleState;  \n    reference roadState : RoadState;  \n  }  \n\n  class VehicleState {  \n    property status : String;  \n  }  \n\n  class RoadState {  \n    property condition : String;  \n  }  \n\n  class SimulationSystem {  \n    property startTime : Real;  \n    property endTime : Real;  \n    property timeStep : Real;  \n    property snapshots : Set(Snapshot);  \n  }  \n\n  statemachine VehicleDrivingStateMachine {  \n    state On {  \n      entry do {  \n        self.status = \"Operational\";  \n      }  \n    }  \n    state Off {  \n      entry do {  \n        self.status = \"Inactive\";  \n      }  \n    }  \n    transition On.to.Off on stopEvent;  \n    transition Off.to.On on startEvent;  \n  }  \n}",
    "model AutomotiveConfigurationModel {\n  block Component1 {}\n  block Component2 {}\n  block Component3 {}\n  block Component4 {}\n  block Component5 {}\n  block Component6 {}\n\n  block SubsystemA {}\n  block SubsystemB {}\n\n  block SubsystemA_Config1 {\n    part component1 : Component1\n    part component2 : Component2\n  }\n  block SubsystemA_Config2 {\n    part component2 : Component2\n    part component3 : Component3\n  }\n\n  block SubsystemB_Config1 {\n    part component4 : Component4\n    part component5 : Component5\n  }\n  block SubsystemB_Config2 {\n    part component5 : Component5\n    part component6 : Component6\n  }\n\n  block Automobile {\n    part subsystemA : SubsystemA\n    part subsystemB : SubsystemB\n  }\n\n  substitution for Automobile.subsystemA from SubsystemA_Config1\n  substitution for Automobile.subsystemA from SubsystemA_Config2\n  substitution for Automobile.subsystemB from SubsystemB_Config1\n  substitution for Automobile.subsystemB from SubsystemB_Config2\n\n  constraintblock ConfigurationConstraint {\n    variable a : Automobile.subsystemA\n    variable b : Automobile.subsystemB\n    condition = if (a.type == SubsystemA_Config2) then (b.type == SubsystemB_Config1) else true\n  }\n\n  instance specification ConfigurationA : Automobile {\n    subsystemA = SubsystemA_Config1\n    subsystemB = SubsystemB_Config1\n  }\n\n  instance specification ConfigurationB : Automobile {\n    subsystemA = SubsystemA_Config2\n    subsystemB = SubsystemB_Config1\n  }\n}",
    "model ModularVehiclePlatform {\n  block System {\n    part subsystemA : SubsystemA;\n    part subsystemB : SubsystemB;\n    connection subsystemA.portA -> subsystemB.portB;\n    apply SystemConstraint;\n  }\n\n  block SubsystemA {\n    part part1 : Part1;\n    part part2 : Part2;\n    part part3 : Part3 [1..3];\n    part part4 : Part4;\n    port portA;\n  }\n\n  block SubsystemB {\n    part part5 : Part5 [1..2];\n    part part6 : Part6;\n    port portB;\n  }\n\n  block Part3 {\n    port p1;\n  }\n\n  block Part5 {\n    port p2;\n    behavior behaviorVariant1;\n    behavior behaviorVariant2;\n  }\n\n  block Part1 {}\n  block Part2 {}\n  block Part4 {}\n  block Part6 {}\n\n  variantSet VehicleConfigA {\n    select System.subsystemA.part1;\n    select System.subsystemA.part2;\n    set System.subsystemA.part3.quantity = 2;\n    select System.subsystemB.part4;\n    select System.subsystemB.part5;\n    set System.subsystemB.part5.behaviorVariant1;\n  }\n\n  variantSet VehicleConfigB {\n    select System.subsystemA.part4;\n    select System.subsystemA.part3;\n    set System.subsystemA.part3.quantity = 3;\n    select System.subsystemB.part5;\n    select System.subsystemB.part6;\n    set System.subsystemB.part5.behaviorVariant2;\n  }\n\n  constraint block SystemConstraint {\n    parameter minPartsA : Integer = 1;\n    parameter maxPartsA : Integer = 3;\n    constraint subsystemA.part3.size >= minPartsA and subsystemA.part3.size <= maxPartsA;\n    constraint if (subsystemB.part5.behaviorVariant1) then (subsystemB.portB.isConnected);\n  }\n}",
    "class Engine {\n    cylinders: Integer;\n}class Transmission {\n    type: String;\n}class Wheel {\n    rimWidth: String;\n}class VehicleConfiguration {\n    performanceLevel: String;\n    engine: Engine;\n    transmission: Transmission;\n    wheels: Wheel[*];\n    constraint highPerformanceConstraint {\n        performanceLevel == \"high\" implies (\n            engine.cylinders == 6 and\n            transmission.type == \"automatic\" and\n            wheels->forAll(w | w.rimWidth == \"wide\")\n        )\n    }\n    constraint standardPerformanceConstraint {\n        performanceLevel == \"standard\" implies (\n            engine.cylinders == 4 and\n            transmission.type == \"manual\" and\n            wheels->forAll(w | w.rimWidth == \"narrow\")\n        )\n    }\n}class VehicleModelVariant {\n    modelName: String;\n    configuration: VehicleConfiguration;\n}\n```",
    "model AutomobileSystem {  \n  block Vehicle {  \n    property mass : Real;  \n    property fuelStatus : String;  \n    property reliability : Real;  \n    reference engine : Engine;  \n    reference transmission : Transmission;  \n    reference driveInterface : DriveInterface;  \n  }  \n\n  block Engine {  \n    property torqueOutput : Real;  \n  }  \n\n  block Transmission {  \n    property torqueInput : Real;  \n  }  \n\n  interface DriveInterface {  \n    port enginePort : Engine;  \n    port transmissionPort : Transmission;  \n  }  \n\n  constraintBlock MassGradeConstraint {  \n    parameter maxMass : Real;  \n    note \"Defines maximum allowable mass for a vehicle (e.g., 2000 kg or 2500 kg)\";  \n  }  \n\n  constraintBlock FuelStatusConstraint {  \n    parameter requiredFuelState : String;  \n    note \"Specifies whether vehicle must comply with mass requirements in full or empty fuel state\";  \n  }  \n\n  constraintBlock PowertrainConstraint {  \n    parameter torqueTransfer : Real;  \n    note \"Ensures engine torque is effectively transferred to transmission via drive interface\";  \n  }  \n\n  constraintBlock ReliabilityConstraint {  \n    parameter minReliability : Real;  \n    note \"Specifies minimum reliability/durability requirements for vehicle lifecycle\";  \n  }  \n\n  requirement VehicleMassRequirement {  \n    text \"Vehicle must have a defined mass grade (2000 kg or 2500 kg) and actual mass must not exceed maximum mass limitation\";  \n    satisfy mass : MassGradeConstraint;  \n  }  \n\n  requirement FuelComplianceRequirement {  \n    text \"Vehicle must comply with mass requirements in specified fuel state (full or empty)\";  \n    satisfy fuelStatus : FuelStatusConstraint;  \n  }  \n\n  requirement PowertrainFunctionalityRequirement {  \n    text \"Engine must output torque and be connected to transmission via drive interface for reliable power transfer\";  \n    satisfy powertrain : PowertrainConstraint;  \n    verify interface : DriveInterface;  \n  }  \n\n  requirement ReliabilityPerformanceRequirement {  \n    text \"Vehicle must maintain specified reliability and durability throughout its lifecycle\";  \n    satisfy reliability : ReliabilityConstraint;  \n  }  \n\n  decomposition VehicleDecomposition {  \n    part engine : Engine;  \n    part transmission : Transmission;  \n    part driveInterface : DriveInterface;  \n  }  \n\n  allocation VehicleMassAllocation {  \n    allocate VehicleMassRequirement to Vehicle;  \n  }  \n\n  allocation FuelStatusAllocation {  \n    allocate FuelComplianceRequirement to Vehicle;  \n  }  \n\n  allocation PowertrainAllocation {  \n    allocate PowertrainFunctionalityRequirement to Engine;  \n    allocate PowertrainFunctionalityRequirement to Transmission;  \n  }  \n\n  allocation ReliabilityAllocation {  \n    allocate ReliabilityPerformanceRequirement to Vehicle;  \n  }  \n}",
    "module VehicleMassCompliance {  \n  class Vehicle {  \n    property actualMass : Real;  \n  }  \n\n  class WeighingEquipment {  \n    behavior measureMass(vehicle: Vehicle): Real {  \n      return vehicle.actualMass;  \n    }  \n  }  \n\n  class TestOperator {  \n    behavior operateEquipment(equipment: WeighingEquipment, vehicle: Vehicle): Real {  \n      return equipment.measureMass(vehicle);  \n    }  \n  }  \n\n  class ComplianceCheckSystem {  \n    parameter maxPermissibleMass : Real;  \n    constraint maxPermissibleMass > 0;  \n\n    behavior determineCompliance(vehicle: Vehicle): Boolean {  \n      return vehicle.actualMass <= maxPermissibleMass;  \n    }  \n\n    behavior processVehicles(vehicles: List<Vehicle>): List<Boolean> {  \n      var results := List<Boolean>();  \n      for (v in vehicles) {  \n        results.add(determineCompliance(v));  \n      }  \n      return results;  \n    }  \n  }  \n}",
    "model WaterSupplyNetwork {\n  class SpigotBank;\n  class Spigot;\n  class Faucet;\n  class FaucetInlet;\n\n  SpigotBank has port hotOut: FlowPort;\n  SpigotBank has port coldOut: FlowPort;\n\n  Spigot has port source: FlowPort;\n  Spigot has port destination: FlowPort;\n\n  Faucet has port hotInlet: FaucetInlet;\n  Faucet has port coldInlet: FaucetInlet;\n\n  SpigotBank->hotOut connected to Spigot->source;\n  Spigot->destination connected to Faucet->hotInlet;\n  SpigotBank->coldOut connected to Spigot->source;\n  Spigot->destination connected to Faucet->coldInlet;\n}",
    "model VehicleQualityAnalysisModel\n  class Vehicle\n    property engine : Engine\n    property transmission : Transmission\n    property frontAxleAssembly : FrontAxleAssembly\n    property rearAxleAssembly : RearAxleAssembly\n    property totalMass : Real\n  end Vehicle\n\n  class Engine\n    property mass : Real\n  end Engine\n\n  class Transmission\n    property mass : Real\n  end Transmission\n\n  class FrontAxleAssembly\n    property mass : Real\n  end FrontAxleAssembly\n\n  class RearAxleAssembly\n    property mass : Real\n  end RearAxleAssembly\n\n  constraint VehicleTotalMassConstraint\n    property totalMass : Real\n    property engineMass : Real\n    property transmissionMass : Real\n    property frontAxleMass : Real\n    property rearAxleMass : Real\n    expression totalMass = engineMass + transmissionMass + frontAxleMass + rearAxleMass\n  end VehicleTotalMassConstraint\n\n  class QualityAnalysisRequirement\n    property description : String\n    property constraintValue : Real\n  end QualityAnalysisRequirement\n\n  class AnalysisTask\n    property name : String\n    property description : String\n    property requirement : QualityAnalysisRequirement\n    property useCase : QualityAnalysisUseCase\n    property result : Real\n  end AnalysisTask\n\n  use case DefineQualityAnalysisRequirements\n    name: \"Define Quality Analysis Requirements\"\n    description: \"Establish measurable quality requirements for vehicle components and systems\"\n  end DefineQualityAnalysisRequirements\n\n  use case GenerateAnalysisPlans\n    name: \"Generate Analysis Plans\"\n    description: \"Automatically create analysis tasks and plans based on defined quality objectives\"\n  end GenerateAnalysisPlans\n\n  use case ExecuteQualityEvaluation\n    name: \"Execute Quality Evaluation\"\n    description: \"Perform comprehensive quality attribute evaluation of vehicle and components\"\n  end ExecuteQualityEvaluation\nend VehicleQualityAnalysisModel",
    "package VehiclePowertrainConfigurationSystem {\n  system VehiclePowertrainConfigurationSystem {\n    evaluationModel: PerformanceEvaluationModel;\n    recommendOptimalEngine(): EngineType;\n    explanation: Explanation;\n  }\n\n  class EngineType {\n    numberOfCylinders: Integer;\n    composite cylinders: Cylinder[*];\n    composite crankshaft: Crankshaft;\n  }\n\n  class Cylinder {\n    composite piston: Piston;\n    composite connectingRod: ConnectingRod;\n  }\n\n  class Piston {}\n  class ConnectingRod {}\n  class Crankshaft {}\n\n  class PerformanceEvaluationModel {\n    power: Real;\n    mass: Real;\n    efficiency: Real;\n    reliability: Real;\n    cost: Real;\n    evaluateEngine(engine: EngineType): Real;\n  }\n\n  class Explanation {\n    rationale: String;\n  }\n}",
    "model VehicleFuelEconomySystemModel {  \n  block VehicleFuelEconomySystem {  \n    part powertrain: Powertrain;  \n    part load: Load;  \n    part operatingConditions: OperatingConditions;  \n    part fuelEconomy: FuelEconomy;  \n  }  \n\n  block Powertrain {  \n    property efficiency: Float;  \n  }  \n\n  block Load {  \n    property weight: Float;  \n  }  \n\n  block OperatingConditions {  \n    property type: OperatingConditionsType;  \n  }  \n\n  enumeration OperatingConditionsType {  \n    urban;  \n    highway;  \n  }  \n\n  block FuelEconomy {  \n    property rangePerGallon: Float;  \n  }  \n\n  constraint block UrbanFuelEconomyConstraint {  \n    appliesTo system: VehicleFuelEconomySystem;  \n    property constraint: Float;  \n    constraint = system.fuelEconomy.rangePerGallon >= 25.0;  \n  }  \n\n  constraint block HighwayFuelEconomyConstraint {  \n    appliesTo system: VehicleFuelEconomySystem;  \n    property constraint: Float;  \n    constraint = system.fuelEconomy.rangePerGallon >= 30.0;  \n  }  \n\n  value 1000PoundLoad {  \n    value: Load {  \n      weight = 1000.0;  \n    }  \n  }  \n\n  value USGallon {  \n    value: Float = 231.0;  \n  }  \n\n  requirement RegulatoryFuelEconomyRequirement {  \n    text: \"Vehicle fuel economy must meet minimum range per gallon under urban and highway conditions.\";  \n    satisfies constraint: UrbanFuelEconomyConstraint, HighwayFuelEconomyConstraint;  \n  }  \n\n  block FuelEconomyTestScenario {  \n    part system: VehicleFuelEconomySystem;  \n    constraint urbanTest: UrbanFuelEconomyConstraint {  \n      system.operatingConditions.type = OperatingConditionsType.urban;  \n    }  \n    constraint highwayTest: HighwayFuelEconomyConstraint {  \n      system.operatingConditions.type = OperatingConditionsType.highway;  \n    }  \n  }  \n}",
    "block MassParameters\n  mass: Real\nend\n\nblock PowerSegment\n  start: Duration\n  end: Duration\n  power: Real\nend\n\nblock SegmentedPowerOutput\n  segments: PowerSegment[*]\nend\n\nblock AccelerationSequence\n  time: Duration[*]\n  acceleration: Real[*]\nend\n\nblock VelocitySequence\n  time: Duration[*]\n  velocity: Real[*]\nend\n\nblock PositionSequence\n  time: Duration[*]\n  position: Real[*]\nendconstraintblock VehicleDynamicsConstraint\n  parameter mass: Real\n  parameter power: Real\n  parameter velocity: Real\n  parameter acceleration: Real\n  equation\n    acceleration = power / (mass * velocity)\nend\n\nblock VehicleMotionSimulationSystem\n  massParams: MassParameters\n  initialPosition: PositionSequence\n  initialVelocity: VelocitySequence\n  powerSegments: SegmentedPowerOutput\n  timeStep: Duration\n  accelerationSequence: AccelerationSequence\n  velocitySequence: VelocitySequence\n  positionSequence: PositionSequence\n  constraint c1: VehicleDynamicsConstraint\n    relating\n      massParams.mass,\n      powerSegments.segments[*].power,\n      velocitySequence.velocity,\n      accelerationSequence.acceleration\nend",
    "model VehicleSystemModel {\n  block Vehicle {\n    property totalMass : Mass = 2500 kg;\n    part frontAxleAssembly : FrontAxleAssembly;\n    part rearAxleAssembly : RearAxleAssembly;\n  }\n\n  block FrontAxleAssembly {\n    property mass : Mass = 150 kg;\n    part frontWheel1 : FrontWheel;\n    part frontWheel2 : FrontWheel;\n    part frontAxle : FrontAxle;\n  }\n\n  block FrontAxle {\n    property mass : Mass;\n    property steeringAngle : Angle;\n  }\n\n  block RearAxleAssembly {\n    property mass : Mass = 250 kg;\n    part rearWheel1 : RearWheel;\n    part rearWheel2 : RearWheel;\n    part rearAxle : RearAxle;\n  }\n\n  block RearAxle {\n    property mass : Mass;\n  }\n\n  block FrontWheel {\n  }\n\n  block RearWheel {\n  }\n}",
    "package VehicleSafetySecuritySystem {\n  enumeration RequirementStatus {\n    Mandatory,\n    Optional\n  }\n\n  class Component {\n    name: String;\n    description: String;\n  }\n\n  class SafetyComponent extends Component {\n    status: RequirementStatus;\n  }\n\n  class SecurityComponent extends Component {\n  }\n\n  constraint block MandatorySafetyConstraint {\n    inv: self.status = RequirementStatus::Mandatory;\n  }\n\n  constraint block OptionalSafetyConstraint {\n    inv: self.status = RequirementStatus::Optional;\n  }\n\n  class SeatBelt extends SafetyComponent constrainedBy MandatorySafetyConstraint {\n  }\n\n  class Bumper extends SafetyComponent constrainedBy MandatorySafetyConstraint {\n  }\n\n  class Airbag extends SafetyComponent constrainedBy OptionalSafetyConstraint {\n  }\n\n  class AntiLockBrakingSystem extends SafetyComponent constrainedBy OptionalSafetyConstraint {\n  }\n\n  class Alarm extends SecurityComponent {\n  }\n\n  class KeylessEntrySystem extends SecurityComponent {\n  }\n\n  class Vehicle {\n    seatBelts: SeatBelt[1..*];\n    bumpers: Bumper[1..*];\n    airbags: Airbag[0..*];\n    antiLockBrakingSystems: AntiLockBrakingSystem[0..*];\n    alarms: Alarm[0..*];\n    keylessEntrySystems: KeylessEntrySystem[0..*];\n    operation filterAndOrganizeComponents(): Structure;\n  }\n\n  class Structure {\n  }\n}\n```",
    "module ApplicationLayer { }\nmodule ServiceLayer { }\nmodule DataLayer { }module System {\n  part application : ApplicationLayer;\n  part service : ServiceLayer;\n  part data : DataLayer;\n  connector appToService : UsageConnector between application and service;\n  connector serviceToData : UsageConnector between service and data;\n\n  part x : X;\n  part y : Y;\n  part z : Z;\n  connector xToZ : DerivationConnector between x and z;\n  connector yToZ : DerivationConnector between y and z;\n}",
    "module PowertrainSystem {\n  part engine : Engine;\n  part transmission : Transmission;\n  part driveshaft : Driveshaft;\n  part wheels : Wheels;\n\n  allocation TorqueGenerationFunction to engine;\n  requirement torque_positive: \n    \"Torque produced during operation must be > 0 Nm\";\n}\n\nfunction TorqueGenerationFunction {\n  // Logic layer function for torque generation\n}",
    "block System {\n  part powertrain : Powertrain;\n  part torqueGenerator : TorqueGenerator;\n  function transmitPower : TransmitPower;\n  function outputPower : OutputPower;\n}\n\nblock Powertrain {\n  part engine : Engine;\n  function transmitPower : TransmitPower;\n}\n\nblock Engine {\n  function generateTorque : GenerateTorque;\n}\n\nblock TorqueGenerator {\n  function generateTorque : GenerateTorque;\n}\n\nallocate (System.torqueGenerator.generateTorque to System.powertrain.engine.generateTorque);",
    "model VehicleSafetyAntiTheftCatalogue {\n  stereotype SafetyComponent;\n  stereotype AntiTheftComponent;\n  stereotype BothSafetyAndAntiTheft;\n  stereotype MandatorySafetyComponent;\n\n  class Vehicle {\n    frontSeatBelts : FrontSeatBelts [1..1];\n    bumpers : Bumpers [1..1];\n    driverAirbag : DriverAirbag [0..1];\n    antiLockBrakingSystem : AntiLockBrakingSystem [0..1];\n    alarmSystem : AlarmSystem [1..1];\n    keylessEntrySystem : KeylessEntrySystem [1..1];\n  }\n\n  class FrontSeatBelts {\n    apply SafetyComponent, MandatorySafetyComponent;\n  }\n\n  class Bumpers {\n    apply SafetyComponent, MandatorySafetyComponent;\n  }\n\n  class DriverAirbag {\n    apply SafetyComponent;\n  }\n\n  class AntiLockBrakingSystem {\n    apply SafetyComponent;\n  }\n\n  class AlarmSystem {\n    apply AntiTheftComponent;\n  }\n\n  class KeylessEntrySystem {\n    apply AntiTheftComponent;\n  }\n}",
    "model FuelSystemModel {  \n  block FuelSystem {  \n    part: FuelTankAssembly [1];  \n    part: FuelLine [1];  \n    part: ReturnLine [1];  \n    part: FuelConsumingUnits [1..*];  \n    part: FuelTemperatureMonitor [1];  \n    part: DataTransmitter [1];  \n  }  \n\n  block FuelTankAssembly {  \n    part: FuelTank [1];  \n    part: FuelPump [1];  \n  }  \n\n  block FuelTank {  \n    port: out FuelFlow;  \n    port: in ReturnFuelFlow;  \n    port: out FuelTemperatureData;  \n  }  \n\n  block FuelPump {  \n    port: out FuelFlow;  \n  }  \n\n  block FuelLine {  \n    port: in FuelFlow;  \n    port: out FuelFlow;  \n  }  \n\n  block ReturnLine {  \n    port: in ReturnFuelFlow;  \n    port: out ReturnFuelFlow;  \n  }  \n\n  block FuelConsumingUnit {  \n    port: in FuelFlow;  \n    port: out ReturnFuelFlow;  \n  }  \n\n  block FuelTemperatureMonitor {  \n    port: in FuelTemperatureData;  \n    port: out FuelTemperatureData;  \n  }  \n\n  block DataTransmitter {  \n    port: in FuelTemperatureData;  \n    port: out FuelTemperatureData;  \n  }  \n\n  flow FuelFlow;  \n  flow ReturnFuelFlow;  \n  flow FuelTemperatureData;  \n}",
    "model VehicleSafetySecuritySystem {\n  package SafetySecurityRequirements {\n    requirement req_seat_belts {\n      text: \"The vehicle interior must have two seat belts.\";\n      constraint: mandatory;\n    }\n    requirement req_airbag {\n      text: \"An airbag should be installed in the cockpit.\";\n      constraint: optional;\n    }\n    requirement req_anti_theft_alarm {\n      text: \"The vehicle must be equipped with an anti-theft alarm device.\";\n      constraint: mandatory;\n    }\n    requirement req_bumper {\n      text: \"The vehicle body must be equipped with a bumper.\";\n      constraint: mandatory;\n    }\n    requirement req_keyless_entry {\n      text: \"The vehicle must have a keyless entry system.\";\n      constraint: mandatory;\n    }\n    requirement req_wheels {\n      text: \"The chassis structure must be fitted with two wheels.\";\n      constraint: mandatory;\n    }\n    requirement req_anti_lock_braking_systems {\n      text: \"The chassis must be equipped with two sets of anti-lock braking systems.\";\n      constraint: optional;\n    }\n    requirement req_component_classification {\n      text: \"All safety and security components must be identified and classified by the system.\";\n      constraint: mandatory;\n    }\n    requirement req_regulatory_compliance {\n      text: \"The system must ensure compliance with regulations regarding critical safety and security functions.\";\n      constraint: mandatory;\n    }\n  }\n  package Components {\n    component SeatBelt {\n      classification: SafetyComponent;\n    }\n    component Airbag {\n      classification: SafetyComponent;\n    }\n    component AntiTheftAlarm {\n      classification: SecurityComponent;\n    }\n    component Bumper {\n      classification: SafetyComponent;\n    }\n    component KeylessEntry {\n      classification: SecurityComponent;\n    }\n    component Wheel {\n      classification: SafetyComponent;\n    }\n    component AntiLockBrakingSystem {\n      classification: SafetyComponent;\n    }\n  }\n}",
    "model VehicleSafetyAndSecurity {\n  block VehicleSafetyAndSecuritySystem {\n    part interior: Interior;\n    part bodyAssembly: BodyAssembly;\n    part safetyFeatures: SafetyFeatures;\n    part securityFeatures: SecurityFeatures;\n  }\n  block Interior {\n    part alarmSystem: AlarmSystem;\n    part seatBelts: SeatBelts;\n    part frontRowSeats: FrontRowSeats;\n    part driverAirbag: DriverAirbag;\n  }\n  block BodyAssembly {\n    part vehicleBody: VehicleBody;\n    part bumper: Bumper;\n    part keylessEntrySystem: KeylessEntrySystem;\n  }\n  block SafetyFeatures {\n    part seatBelts: SeatBelts;\n    part airbags: DriverAirbag;\n    part bumper: Bumper;\n  }\n  block SecurityFeatures {\n    part alarmSystem: AlarmSystem;\n    part keylessEntrySystem: KeylessEntrySystem;\n  }\n  block AlarmSystem;\n  block SeatBelts;\n  block FrontRowSeats;\n  block DriverAirbag;\n  block VehicleBody;\n  block Bumper;\n  block KeylessEntrySystem;\n  relationship hasSafety: VehicleSafetyAndSecuritySystem has SafetyFeatures;\n  relationship hasSecurity: VehicleSafetyAndSecuritySystem has SecurityFeatures;\n  relationship usesAlarm: SecurityFeatures uses AlarmSystem;\n  relationship usesKeyless: SecurityFeatures uses KeylessEntrySystem;\n  relationship usesSeatBelts: SafetyFeatures uses SeatBelts;\n  relationship usesAirbags: SafetyFeatures uses DriverAirbag;\n  relationship usesBumper: SafetyFeatures uses Bumper;\n}",
    "model InformationSecurityModel {\n  package InformationSecurity {\n    enumeration SecurityClassification {\n      literal Unclassified;\n      literal Confidential;\n      literal Secret;\n    }\n\n    class Component {\n      property securityLevel : SecurityClassification [1];\n    }\n\n    constraint DisplayConfidentialConstraint {\n      context Component\n      self.securityLevel = SecurityClassification::Confidential implies \n        -- System must recognize and display the classification attribute for Confidential components\n        true\n    }\n  }\n}",
    "model AutomotiveECUModel {\n  interface BusIF {\n  }\n\n  interface SensorIF {\n  }\n\n  block VCU {\n    port canPort: BusIF;\n    port sensorPort: SensorIF;\n    property vehicleState: State;\n  }\n\n  block ECU {\n    port canPort: BusIF;\n    port sensorPort: SensorIF;\n    property engineState: State;\n  }\n\n  block CANBus {\n    port vcuPort: BusIF;\n    port ecuPort: BusIF;\n  }\n\n  block AutomotiveSystem {\n    part vcu: VCU;\n    part ecu: ECU;\n    part canBus: CANBus;\n\n    connect vcu.canPort to canBus.vcuPort;\n    connect ecu.canPort to canBus.ecuPort;\n\n    flow vcuToEcuFlow: canBus.vcuPort -> ecu.canPort;\n    flow ecuToVcuFlow: canBus.ecuPort -> vcu.canPort;\n  }\n\n  dataType State;\n}",
    "model BloodGlucoseMeterSystem {  \n  block System {  \n    block BatteryStatusMonitor {  \n      property batteryLevel : BatteryLevelType;  \n      action detectBatteryStatus;  \n    }  \n    block AlertSystem {  \n      action sendUserAlert;  \n    }  \n    block MeasurementFunction {  \n      action measureGlucose;  \n    }  \n    block EmergencyResponse {  \n      action activateEmergencyProtocol;  \n    }  \n  }  \n\n  requirement req1: \"System must automatically detect battery depletion or charging failure\" {  \n    satisfy BatteryStatusMonitor.detectBatteryStatus;  \n    constraint AutomaticDetectionConstraint: \"Battery status is monitored in real-time with 99.9% accuracy\";  \n  }  \n\n  requirement req2: \"System must alert user when battery status is abnormal\" {  \n    satisfy AlertSystem.sendUserAlert;  \n    refine req1;  \n    constraint PromptAlertConstraint: \"Alert is generated within 5 seconds of detecting low battery\";  \n  }  \n\n  requirement req3: \"Preventive measures must ensure continuous battery status monitoring\" {  \n    satisfy BatteryStatusMonitor;  \n    constraint PreventiveMeasuresConstraint: \"Battery monitoring system undergoes weekly self-diagnostics\";  \n  }  \n\n  requirement req4: \"System must implement alarm and emergency response for measurement function abnormalities\" {  \n    satisfy MeasurementFunction.measureGlucose;  \n    satisfy EmergencyResponse.activateEmergencyProtocol;  \n    constraint EmergencyResponseConstraint: \"Emergency protocol activates within 2 seconds of measurement failure\";  \n  }  \n\n  requirement req5: \"Management measures must address key risk scenarios for therapeutic continuity\" {  \n    satisfy System;  \n    constraint RiskManagementConstraint: \"All critical failure scenarios have documented mitigation plans approved by regulatory bodies\";  \n  }  \n}",
    "module ScientificConstants {\n  module MathematicalConstants {\n    value e : Real = 2.71828182845904523536;\n    annotation precision : String = \"20 decimal places\";\n    value pi : Real = 3.14159265358979323846;\n    annotation precision : String = \"20 decimal places\";\n  }\n  module PhysicalConstants {\n    value speedOfLightInVacuum : Real = 299792458.0;\n    unit m_per_s = m / s;\n    value fineStructureConstant : Real = 0.0072973525693;\n    annotation unit : String = \"unitless\";\n    value electronToProtonMassRatio : Real = 0.000544617;\n    annotation unit : String = \"unitless\";\n    annotation source : String = \"NIST\";\n  }\n  module ScenarioConstants {\n    value standardGravitationalAcceleration : Real = 9.80665;\n    unit m_per_s2 = m / (s^2);\n    value amplifierGainModelX : Real = 10.0;\n    annotation unit : String = \"unitless\";\n    annotation context : String = \"Model X amplifier\";\n  }\n}",
    "model TireSpecificationModel {\n  class Tire {\n    manufacturer : String;\n    rimDiameter : Real;\n    width : Integer;\n  }\n\n  instance michelinTire : Tire {\n    manufacturer = \"Michelin\";\n    rimDiameter = 18.0;\n    width = 245;\n  };\n}",
    "package AutomotiveComponentModel {\n  import sysml.base.units.*;\n  import sysml.base.quantityKinds.*;\n\n  class Vehicle {\n    property mass : PhysicalQuantity {\n      value : Real = 1200;\n      unit : kilogram;\n    }\n    property length : PhysicalQuantity {\n      value : Real = 4.82;\n      unit : meter;\n    }\n    property frontWheels : FrontWheel [2];\n  }\n\n  class FrontWheel {\n    property hub : WheelHub;\n    property tire : Tire;\n    property outerDiameter : PhysicalQuantity {\n      unit : meter;\n      derive value = hub.diameter.value + 2 * tire.height.value;\n    }\n  }\n\n  class WheelHub {\n    property diameter : PhysicalQuantity {\n      value : Real = 18;\n      unit : inch;\n    }\n    property width : PhysicalQuantity {\n      value : Real = 245;\n      unit : millimeter;\n    }\n  }\n\n  class Tire {\n    property height : PhysicalQuantity {\n      unit : millimeter;\n    }\n  }\n}",
    "model PowertrainConfiguration {\n  block Engine {}\n  block FourCylinder extends Engine {}\n  block SixCylinder extends Engine {}\n  \n  block Transmission {}\n  block Manual extends Transmission {}\n  block Automatic extends Transmission {}\n  \n  block Vehicle {\n    property engine : Engine\n    property transmission : Transmission\n    property highPerformanceModel : Boolean\n    \n    constraint highPerformanceEngine: highPerformanceModel implies (engine is SixCylinder)\n    constraint standardEngine: not highPerformanceModel implies (engine is FourCylinder)\n    constraint validCombination: (engine is FourCylinder and transmission is Manual) or (engine is SixCylinder and transmission is Automatic)\n  }\n}",
    "model AutomotiveSystem {\n  block Car {\n    property totalMass : Mass = 1200 kg;\n    property length : Length = 4.82 m;\n    part wheelAssembly : WheelAssembly [4];\n  }\n\n  block WheelAssembly {\n    part wheel : Wheel;\n    part brakeDisc : BrakeDisc;\n    constraint brakeDiscFit : BrakeDiscFitConstraint {\n      parameter wheelOuterDiameter : Length = wheel.outerDiameter;\n      parameter brakeDiscDiameter : Length = brakeDisc.diameter;\n      constraint brakeDiscDiameter < wheelOuterDiameter;\n    }\n  }\n\n  block Wheel {\n    part rim : Rim;\n    part tire : Tire;\n    property outerDiameter : Length;\n    constraint outerDiameterCalc : OuterDiameterConstraint {\n      parameter rimDiameter : Length = rim.diameter;\n      parameter tireHeight : Length = tire.height;\n      parameter calculatedOuterDiameter : Length = rimDiameter * 25.4 + 2 * tireHeight;\n      constraint outerDiameter = calculatedOuterDiameter;\n    }\n  }\n\n  block Rim {\n    property diameter : Length = 18 in;\n  }\n\n  block Tire {\n    property width : Length = 245 mm;\n    property height : Length = 45 mm;\n    property treadDepth : Length = 6.0 mm;\n    constraint minTreadDepth : TreadDepthConstraint {\n      parameter td : Length = treadDepth;\n      constraint td >= 3.5 mm;\n    }\n  }\n\n  block BrakeDisc {\n    property radius : Length = 95 mm;\n    property diameter : Length;\n    constraint diameterCalc : DiameterConstraint {\n      parameter r : Length = radius;\n      parameter d : Length = diameter;\n      constraint d = 2 * r;\n    }\n  }\n\n  constraint Block OuterDiameterConstraint {\n    parameter rimDiameter : Length;\n    parameter tireHeight : Length;\n    parameter calculatedOuterDiameter : Length = rimDiameter * 25.4 + 2 * tireHeight;\n    constraint outerDiameter = calculatedOuterDiameter;\n  }\n\n  constraint Block BrakeDiscFitConstraint {\n    parameter wheelOuterDiameter : Length;\n    parameter brakeDiscDiameter : Length;\n    constraint brakeDiscDiameter < wheelOuterDiameter;\n  }\n\n  constraint Block TreadDepthConstraint {\n    parameter treadDepth : Length;\n    constraint treadDepth >= 3.5 mm;\n  }\n\n  constraint Block DiameterConstraint {\n    parameter radius : Length;\n    parameter diameter : Length;\n    constraint diameter = 2 * radius;\n  }\n}",
    "model AutomotiveFuelSystemModel {  \n  block AutomotiveFuelSystem {  \n    part fuelTankAssembly: FuelTankAssembly;  \n    part engine: Engine;  \n\n    constraint c1: fuelTankAssembly.fuelTank.fuelOut -> fuelTankAssembly.fuelPump.fuelIn;  \n    constraint c2: fuelTankAssembly.fuelPump.fuelOut -> engine.fuelIn;  \n    constraint c3: engine.fuelReturn -> fuelTankAssembly.fuelPump.returnFuelIn;  \n    constraint c4: fuelTankAssembly.fuelTank.returnFuelIn -> fuelTankAssembly.fuelPump.returnFuelOut;  \n    requirement r1: fuelTankAssembly.fuelPump.temperatureMonitoring;  \n    requirement r2: fuelTankAssembly.fuelPump.temperatureTransmission;  \n    requirement r3: fuelTankAssembly.fuelPump.efficientSafeCirculation;  \n  }  \n\n  block FuelTankAssembly {  \n    part fuelTank: FuelTank;  \n    part fuelPump: FuelPump;  \n  }  \n\n  block FuelTank {  \n    port fuelOut: FuelPort (direction: out);  \n    port returnFuelIn: FuelPort (direction: in);  \n  }  \n\n  block FuelPump {  \n    port fuelIn: FuelPort (direction: in);  \n    port fuelOut: FuelPort (direction: out);  \n    port returnFuelIn: FuelPort (direction: in);  \n    port returnFuelOut: FuelPort (direction: out);  \n    property temperature: Temperature;  \n    behavior temperatureMonitoring: MonitorTemperature;  \n    behavior temperatureTransmission: TransmitTemperature;  \n    behavior efficientSafeCirculation: EnsureCirculation;  \n  }  \n\n  block Engine {  \n    port fuelIn: FuelPort (direction: in);  \n    port fuelReturn: FuelPort (direction: out);  \n  }  \n\n  data type FuelPort;  \n  data type Temperature;  \n  behavior MonitorTemperature;  \n  behavior TransmitTemperature;  \n  behavior EnsureCirculation;  \n}",
    "package PhysicalQuantities {\n  class Quantity {\n    name: String;\n    symbol: String;\n  }\n\n  class BaseQuantity < Quantity {\n    unit: Unit;\n  }\n\n  class Length < BaseQuantity;\n  class Mass < BaseQuantity;\n  class Time < BaseQuantity;\n  class ElectricCurrent < BaseQuantity;\n  class Temperature < BaseQuantity;\n  class AmountOfSubstance < BaseQuantity;\n  class LuminousIntensity < BaseQuantity;\n\n  class Unit {\n    name: String;\n    symbol: String;\n    conversionFactor: Real;\n  }\n\n  class Meter < Unit;\n  class Kilogram < Unit;\n  class Second < Unit;\n  class Ampere < Unit;\n  class Kelvin < Unit;\n  class Mole < Unit;\n  class Candela < Unit;\n\n  class Length {\n    unit: Meter;\n  }\n\n  class Mass {\n    unit: Kilogram;\n  }\n\n  class Time {\n    unit: Second;\n  }\n\n  class ElectricCurrent {\n    unit: Ampere;\n  }\n\n  class Temperature {\n    unit: Kelvin;\n  }\n\n  class AmountOfSubstance {\n    unit: Mole;\n  }\n\n  class LuminousIntensity {\n    unit: Candela;\n  }\n\n  class UnitConversion {\n    sourceUnit: Unit;\n    targetUnit: Unit;\n    factor: Real;\n  }\n}",
    "package UnitSystemLibrary {\n  package ISQ {\n    unit Meter: Unit { symbol: \"m\"; definition: \"Base unit of length in the International System of Units (SI)\"; }\n    unit Kilogram: Unit { symbol: \"kg\"; definition: \"Base unit of mass in the SI\"; }\n    unit Second: Unit { symbol: \"s\"; definition: \"Base unit of time in the SI\"; }\n    unit Ampere: Unit { symbol: \"A\"; definition: \"Base unit of electric current in the SI\"; }\n    unit Kelvin: Unit { symbol: \"K\"; definition: \"Base unit of thermodynamic temperature in the SI\"; }\n    unit Mole: Unit { symbol: \"mol\"; definition: \"Base unit of amount of substance in the SI\"; }\n    unit Candela: Unit { symbol: \"cd\"; definition: \"Base unit of luminous intensity in the SI\"; }\n\n    unit Newton: Unit { symbol: \"N\"; definition: \"Derived unit of force in the SI, equal to kg·m/s²\"; }\n    unit Joule: Unit { symbol: \"J\"; definition: \"Derived unit of energy in the SI, equal to N·m\"; }\n    unit Watt: Unit { symbol: \"W\"; definition: \"Derived unit of power in the SI, equal to J/s\"; }\n    unit Celsius: Unit { symbol: \"°C\"; definition: \"Derived unit of temperature in the SI, equal to K with an offset of 273.15\"; }\n    unit Kilometer: Unit { symbol: \"km\"; definition: \"Derived unit of length in the SI, equal to 1000 meters\"; }\n  }\n\n  package USCustomaryUnits {\n    unit Foot: Unit { symbol: \"ft\"; definition: \"Common unit of length in the United States Customary system\"; }\n    unit Mile: Unit { symbol: \"mi\"; definition: \"Unit of length in the US Customary system, equal to 5280 feet\"; }\n    unit Pound: Unit { symbol: \"lb\"; definition: \"Common unit of mass in the US Customary system\"; }\n    unit Ounce: Unit { symbol: \"oz\"; definition: \"Unit of mass in the US Customary system, equal to 1/16 of a pound\"; }\n    unit Hour: Unit { symbol: \"hr\"; definition: \"Unit of time in the US Customary system, equal to 60 minutes\"; }\n    unit Minute: Unit { symbol: \"min\"; definition: \"Unit of time in the US Customary system, equal to 60 seconds\"; }\n    unit PoundForce: Unit { symbol: \"lbf\"; definition: \"Unit of force in the US Customary system, equal to the gravitational force exerted on a mass of one pound\"; }\n    unit BritishThermalUnit: Unit { symbol: \"BTU\"; definition: \"Unit of energy in the US Customary system, approximately equal to 1055 joules\"; }\n    unit Horsepower: Unit { symbol: \"hp\"; definition: \"Unit of power in the US Customary system, approximately equal to 745.7 watts\"; }\n    unit Fahrenheit: Unit { symbol: \"°F\"; definition: \"Unit of temperature in the US Customary system\"; }\n  }\n\n  conversion FootToMeter: Conversion { source: USCustomaryUnits::Foot; target: ISQ::Meter; formula: \"value * 0.3048\"; }\n  conversion MileToKilometer: Conversion { source: USCustomaryUnits::Mile; target: ISQ::Kilometer; formula: \"value * 1.60934\"; }\n  conversion PoundToKilogram: Conversion { source: USCustomaryUnits::Pound; target: ISQ::Kilogram; formula: \"value * 0.453592\"; }\n  conversion OunceToKilogram: Conversion { source: USCustomaryUnits::Ounce; target: ISQ::Kilogram; formula: \"value * 0.0283495\"; }\n  conversion HourToSecond: Conversion { source: USCustomaryUnits::Hour; target: ISQ::Second; formula: \"value * 3600\"; }\n  conversion MinuteToSecond: Conversion { source: USCustomaryUnits::Minute; target: ISQ::Second; formula: \"value * 60\"; }\n  conversion PoundForceToNewton: Conversion { source: USCustomaryUnits::PoundForce; target: ISQ::Newton; formula: \"value * 4.44822\"; }\n  conversion BTUToJoule: Conversion { source: USCustomaryUnits::BritishThermalUnit; target: ISQ::Joule; formula: \"value * 1055.06\"; }\n  conversion HorsepowerToWatt: Conversion { source: USCustomaryUnits::Horsepower; target: ISQ::Watt; formula: \"value * 745.7\"; }\n  conversion FahrenheitToCelsius: Conversion { source: USCustomaryUnits::Fahrenheit; target: ISQ::Celsius; formula: \"(value - 32) * 5 / 9\"; }\n  conversion CelsiusToFahrenheit: Conversion { source: ISQ::Celsius; target: USCustomaryUnits::Fahrenheit; formula: \"value * 9 / 5 + 32\"; }\n}",
    "package HeadlampTiltSystem {\n  block HeadlampTiltAdjustmentKnob {\n    property tiltAngle : Real { unit 'deg' }\n  }\n\n  constraint TiltAngleConstraint {\n    assert: self.tiltAngle between (50.0, 80.0) unit 'deg'\n  }\n}\n```",
    "valueDefinition UnsignedInteger : Integer {\n  minInclusive = 0;\n}\n\nvalueDefinition UnsignedFloat : Float {\n  minInclusive = 0.0;\n}\n\nenumeration StatusLevel {\n  Critical;\n  Warning;\n  Normal;\n}\n\nenumeration ColorLabel {\n  Red;\n  Yellow;\n  Green;\n}constraintBlock StatusColorConstraint {\n  parameter status : StatusLevel;\n  parameter color : ColorLabel;\n  constraint status = Critical implies color = Red;\n  constraint status = Warning implies color = Yellow;\n  constraint status = Normal implies color = Green;\n}\n\nenumeration DiameterSize {\n  Small;\n  Medium;\n  Large;\n}\n\nvalueDefinition Diameter : UnsignedFloat {\n  constraint sizeConstraint : DiameterConstraint {\n    size = Small implies self = 60.0;\n    size = Medium implies self = 70.0;\n    size = Large implies self = 80.0;\n  }\n  default = 60.0;\n}\n\nvalueDefinition PhysicalDimension {\n  property size : DiameterSize { default = Small; }\n  property diameter : Diameter;\n  constraint diameterConstraint : DiameterConstraint {\n    size = self.size;\n    diameter = self.diameter;\n  }\n}\n\nvalueDefinition String : String;\nvalueDefinition Boolean : Boolean;\nvalueDefinition DateTime : DateTime;\n```",
    "package SystemModel {\n  definition Person : Class {}\n  definition SparePart : Class {}\n  definition SparePartsBag : Bag<SparePart> {}\n  definition IntegerList : List<Integer> {}\n  definition StringSet : Set<String> {}\n  definition PersonnelOrderedSet : OrderedSet<Person> {}\n  definition NestedPersonnelList : List<Set<Person>> {}\n  definition RealArray : Array<Real>[size=4] {}\n}\n```",
    "class Point3D {\n  x : Real;\n  y : Real;\n  z : Real;\n}class Tire {\n  manufacturer : String;\n  rimDiameter : Real {unit inch};\n  tireWidth : Integer;\n  installationPosition : Point3D [0..1];\n}",
    "value definition Position3D {\n  x : Real @unit m;\n  y : Real @unit m;\n  z : Real @unit m;\n};\n\nvalue definition Velocity3D {\n  x : Real @unit m/s;\n  y : Real @unit m/s;\n  z : Real @unit m/s;\n};\n\nblock SamplingPoint {\n  time : Duration;\n  position : Position3D;\n  velocity : Velocity3D;\n};\n\nblock TrajectoryRecordingSystem {\n  missionLiftoffTime : Duration;\n  utcLiftoffTime : String;\n  samplingPoints : Sequence<SamplingPoint>;\n};\n```",
    "model AlloyModel {\n  class Substance {\n    property atomicMass : ValueDefinition;\n  }\n  class Material extends Substance {\n  }\n  class Metal extends Material {\n  }\n  class Alloy extends Material {\n    property composition[*2..*] : PartDefinition(Material) {\n      property massFraction : ValueDefinition;\n    }\n    property tensileStrength : ValueDefinition;\n  }\n  class ValueDefinition {\n    property value : Real;\n    property unit : Unit;\n  }\n  class Unit {\n  }\n  unit g/mol;\n  unit N/mm²;\n  instances {\n    instance iron : Metal {\n      atomicMass : ValueDefinition {\n        value : 55.85;\n        unit : g/mol;\n      }\n    }\n    instance carbon : Metal {\n      atomicMass : ValueDefinition {\n        value : 12.01;\n        unit : g/mol;\n      }\n    }\n    instance manganese : Metal {\n      atomicMass : ValueDefinition {\n        value : 54.94;\n        unit : g/mol;\n      }\n    }\n    instance steel980 : Alloy {\n      composition : [ \n        part iron : Iron { massFraction : ValueDefinition { value : 0.85; } }, \n        part carbon : Carbon { massFraction : ValueDefinition { value : 0.15; } }, \n        part manganese : Manganese { massFraction : ValueDefinition { value : 0.02; } } \n      ];\n      tensileStrength : ValueDefinition {\n        value : 980;\n        unit : N/mm²;\n      }\n    }\n  }\n}",
    "package EngineeringMaterials {\n  class EngineeringMaterial {\n    property name : String;\n    property atomicMass : Real;\n  }\n\n  class Metal extends EngineeringMaterial {\n  }\n\n  class Alloy extends EngineeringMaterial {\n    property composition : Composition[*];\n  }\n\n  class Composition {\n    property material : EngineeringMaterial [1..1];\n    property constituent : EngineeringMaterial[*];\n    property massFraction : Real[*];\n  }\n\n  class MechanicalProperty {\n    property value : Real;\n    property unit : Unit;\n  }\n\n  class Unit {\n  }\n\n  instance Steel_980 : Alloy {\n    name = \"High-Strength Steel 980\";\n    atomicMass = 55.845; // Approximate average atomic mass\n    composition = [\n      {\n        material = Steel_980;\n        constituent = Iron;\n        massFraction = 0.96;\n      },\n      {\n        material = Steel_980;\n        constituent = Carbon;\n        massFraction = 0.02;\n      },\n      {\n        material = Steel_980;\n        constituent = Manganese;\n        massFraction = 0.02;\n      }\n    ];\n    tensileStrength : MechanicalProperty {\n      value = 980;\n      unit = N_per_mm2;\n    }\n  }\n\n  instance Iron : Metal {\n    name = \"Iron\";\n    atomicMass = 55.845;\n  }\n\n  instance Carbon : Metal {\n    name = \"Carbon\";\n    atomicMass = 12.007;\n  }\n\n  instance Manganese : Metal {\n    name = \"Manganese\";\n    atomicMass = 54.938;\n  }\n\n  instance N_per_mm2 : Unit {\n    name = \"Newton per square millimeter\";\n  }\n}\n```",
    "model PubSubModel {\n  class Producer {\n    behavior publishMessage(topic: Topic, message: Message) {\n      action publish(topic, message)\n    }\n  }\n\n  class Consumer {\n    behavior subscribeToTopic(topic: Topic) {\n      action subscribe(topic)\n    }\n\n    behavior receiveMessage(message: Message) {\n      action receive(message)\n    }\n  }\n\n  class Server {\n    behavior distributeMessage(topic: Topic, message: Message) {\n      action checkSubscriptions(topic)\n      for (subscription in Server.subscriptions where subscription.topic == topic) {\n        action deliverMessage(subscription.consumer, message)\n      }\n    }\n\n    behavior manageSubscription(consumer: Consumer, topic: Topic) {\n      action addSubscription(consumer, topic)\n    }\n  }\n\n  class Topic {\n    property name: String\n  }\n\n  class Message {\n    property content: String\n  }\n\n  class Subscription {\n    property consumer: Consumer\n    property topic: Topic\n  }\n\n  association ProducerToServer {\n    Producer.producerSendsToServer : Producer --> Server\n  }\n\n  association ConsumerToServer {\n    Server.serverManagesConsumers : Server --> Consumer\n  }\n\n  association TopicToServer {\n    Server.serverManagesTopics : Server --> Topic\n  }\n\n  association SubscriptionLink {\n    Subscription.subscriptionOfTopic : Subscription --> Topic\n    Subscription.subscriptionByConsumer : Subscription --> Consumer\n  }\n\n  association MessageDelivery {\n    Server.serverSendsMessages : Server --> Message\n    Consumer.consumerReceivesMessages : Consumer --> Message\n  }\n}",
    "model VehicleFuelSystem  \n  block FuelTankAssembly  \n    property capacity : Float  \n    property fuelLevel : Float  \n    do  \n      action supplyFuel()  \n  end FuelTankAssembly  \n  \n  block Engine  \n    property fuelConsumptionRate : Float  \n    property operationalStatus : String  \n    do  \n      action consumeFuel()  \n      action returnFuel()  \n  end Engine  \n  \n  block FuelLine  \n    property flowRate : Float  \n    property direction : String  \n  end FuelLine  \n  \n  block FuelMonitoringSystem  \n    property temperatureReading : Float  \n    do  \n      action monitorTemperature()  \n      action transmitData()  \n  end FuelMonitoringSystem  \n  \n  part supplyFuelLine : FuelLine  \n  part returnFuelLine : FuelLine  \n  part fuelTank : FuelTankAssembly  \n  part engine : Engine  \n  part monitoringSystem : FuelMonitoringSystem  \n  \n  reference fuelTank.supplyFuel -> supplyFuelLine  \n  reference engine.consumeFuel -> supplyFuelLine  \n  reference engine.returnFuel -> returnFuelLine  \n  reference fuelTank.supplyFuel <- returnFuelLine  \n  \n  reference monitoringSystem.monitorTemperature -> supplyFuelLine  \n  reference monitoringSystem.monitorTemperature -> returnFuelLine  \n  reference monitoringSystem.transmitData -> monitoringSystem.temperatureReading  \nend VehicleFuelSystem",
    "model PublishSubscribeSystem\n\n  block Producer\n    port publishMessage : PublishMessagePort\n  end Producer\n\n  block Server\n    port receiveMessage : PublishMessagePort\n    port receiveSubscription : SubscriptionRequestPort\n    port deliverMessage : DeliverMessagePort\n    property subscriptions : List<Subscription>\n  end Server\n\n  block Consumer\n    port subscribe : SubscriptionRequestPort\n    port receiveMessage : DeliverMessagePort\n  end Consumer\n\n  block TopicMessage\n    property topic : String\n    property content : String\n  end TopicMessage\n\n  block SubscriptionRequest\n    property topic : String\n  end SubscriptionRequest\n\n  block Subscription\n    property topic : String\n    property consumer : Consumer\n  end Subscription\n\n  action PublishMessageAction\n    input message : TopicMessage\n    output message : TopicMessage\n  end PublishMessageAction\n\n  action HandleSubscriptionAction\n    input request : SubscriptionRequest\n    output subscription : Subscription\n  end HandleSubscriptionAction\n\n  action DeliverMessageAction\n    input message : TopicMessage\n    input subscriptions : List<Subscription>\n    output deliveredMessages : List<TopicMessage>\n  end DeliverMessageAction\n\n  flow PublishMessagePort\n    source Producer::publishMessage\n    target Server::receiveMessage\n  end PublishMessagePort\n\n  flow SubscriptionRequestPort\n    source Consumer::subscribe\n    target Server::receiveSubscription\n  end SubscriptionRequestPort\n\n  flow DeliverMessagePort\n    source Server::deliverMessage\n    target Consumer::receiveMessage\n  end DeliverMessagePort\n\n  Server::subscriptions = collect(Consumer::subscribe->handleSubscription())\n\n  Producer::publishMessage->Server::receiveMessage->publishMessageAction(message)\n  Server::receiveSubscription->handleSubscriptionAction(request)\n  Server::deliverMessage->deliverMessageAction(message, subscriptions)\n\nend PublishSubscribeSystem\n```",
    "package TransportationSystem {\n  class User {}\n  class Driver extends User {}\n  class Passenger extends User {}\n  class Vehicle {\n    driver: Driver\n    passengers: Passenger[0..4]\n    fuelSystem: FuelSystem\n    environmentalFactors: EnvironmentalFactors\n    startTravel()\n    completeTravel()\n  }\n  class FuelSystem {\n    fuelLevel: Float\n    maxTankCapacity: Float\n    refuel()\n  }\n  class GasStation {\n    location: String\n    fuelPump: Behavior\n  }\n  class EnvironmentalFactors {\n    weather: String\n    roadConditions: String\n  }\n\n  context FuelSystem\n  inv FuelLevelConstraint: fuelLevel >= 0.0 and fuelLevel <= maxTankCapacity\n\n  context FuelSystem::refuel()\n  post RefuelPostCondition: fuelLevel = maxTankCapacity\n\n  context Vehicle::startTravel()\n  post StartTravelPostCondition: fuelSystem.fuelLevel >= 0.1 * fuelSystem.maxTankCapacity\n\n  context Vehicle::completeTravel()\n  post CompleteTravelPostCondition: passengers->isEmpty() and driver = null\n}\n```",
    "model VehicleFuelManagementSystem {\n  block FuelTankAssembly {\n    port fuelOutletPort : FuelInterface [out] {\n      property fuelTemperature : Real;\n    };\n    port fuelReturnInletPort : FuelInterface [in] {\n      property fuelTemperature : Real;\n    };\n  }\n\n  block EngineUnit {\n    port fuelInletPort : FuelInterface [in] {\n      property fuelTemperature : Real;\n    };\n    port fuelReturnOutletPort : FuelInterface [out] {\n      property fuelTemperature : Real;\n    };\n  }\n\n  interface FuelInterface {\n    member forwardFlow : Flow [out];\n    member reverseFlow : Flow [in];\n  }\n\n  instance fuelTank : FuelTankAssembly;\n  instance engine : EngineUnit;\n\n  connect fuelTank.fuelOutletPort to engine.fuelInletPort;\n  connect engine.fuelReturnOutletPort to fuelTank.fuelReturnInletPort;\n}",
    "model VehicleFuelSystemModel {\n  block VehicleFuelSystem {\n    part fuelTank: FuelTankAssembly;\n    part engine: Engine;\n    connection fuelTank.supplyPort -> engine.supplyPort;\n    connection engine.returnPort -> fuelTank.returnPort;\n  }\n\n  block FuelTankAssembly {\n    port supplyPort: FlowPort {\n      interface FuelFlow;\n      interface Temperature;\n    }\n    port returnPort: FlowPort {\n      interface FuelFlow;\n      interface Temperature;\n    }\n  }\n\n  block Engine {\n    port supplyPort: FlowPort {\n      interface FuelFlow;\n      interface Temperature;\n    }\n    port returnPort: FlowPort {\n      interface FuelFlow;\n      interface Temperature;\n    }\n  }\n\n  flow FuelFlow {\n    property flowRate: Integer;\n    property temperature: TemperatureValueType;\n  }\n\n  value type TemperatureValueType {\n    unit degreeCelsius;\n  }\n}",
    "model PhotoCaptureSystemModel {  \n  system PhotoCaptureSystem {  \n    useCase ObtainPhotosFromRealWorldScenes {  \n      actor User;  \n      scenario PrimaryScenario {  \n        activity PhotoCaptureActivity {  \n          input SceneSelection;  \n          output FinalPhoto;  \n          \n          action SceneSelectionAction {  \n            input selectedScene: Scene;  \n            output sceneInput: Scene;  \n          }  \n          \n          action AutoFocusAction {  \n            input scene: Scene;  \n            output focusedImage: IntermediateImage;  \n          }  \n          \n          action CapturePhotoAction {  \n            input focusedImage: IntermediateImage;  \n            output finalPhoto: FinalPhoto;  \n          }  \n          \n          flow SceneSelection -> SceneSelectionAction::sceneInput;  \n          flow SceneSelectionAction::sceneInput -> AutoFocusAction::scene;  \n          flow AutoFocusAction::focusedImage -> CapturePhotoAction::focusedImage;  \n          flow CapturePhotoAction::finalPhoto -> FinalPhoto;  \n        }  \n      }  \n    }  \n  }  \n}",
    "model PhotographySystemModel {  \n    block PhotographySystem {  \n        part sceneSelection : SceneSelection;  \n        part focusingActivity : FocusingActivity;  \n        part shootingActivity : ShootingActivity;  \n        part intermediateImage : IntermediateImage;  \n        part finalPhotograph : FinalPhotograph;  \n    }  \n\n    block SceneSelection {  \n        reference selectedScene : Scene;  \n    }  \n\n    block FocusingActivity {  \n        input selectedScene : Scene;  \n        output intermediateImage : IntermediateImage;  \n        action focusOnScene(selectedScene : Scene) : IntermediateImage;  \n    }  \n\n    block ShootingActivity {  \n        input focusedImage : IntermediateImage;  \n        output finalPhotograph : FinalPhotograph;  \n        action captureImage(focusedImage : IntermediateImage) : FinalPhotograph;  \n    }  \n\n    block IntermediateImage {  \n        property imageData : String;  \n    }  \n\n    block FinalPhotograph {  \n        property photoData : String;  \n    }  \n\n    activity Workflow {  \n        parameter selectedScene : Scene;  \n        parameter intermediateImage : IntermediateImage;  \n        parameter finalPhotograph : FinalPhotograph;  \n\n        step focusStep : FocusingActivity {  \n            input selectedScene;  \n            output intermediateImage;  \n        }  \n\n        step shootStep : ShootingActivity {  \n            input intermediateImage;  \n            output finalPhotograph;  \n        }  \n    }  \n\n    constraint Constraint_SequentialWorkflow {  \n        apply Workflow {  \n            focusStep before shootStep;  \n        }  \n    }  \n}",
    "block User {}\n\nblock Scene {}\n\nblock Image {}\n\nblock Photograph {}\n\nblock PhotographySystem {\n  behavior photographyWorkflow : Behavior {\n    input scene : Scene;\n    output finalPhotograph : Photograph;\n\n    action selectSceneAction {\n      input scene : Scene;\n      output selectedScene : Scene;\n    }\n\n    action focusAction {\n      input selectedScene : Scene;\n      output image : Image;\n    }\n\n    action shootAction {\n      input image : Image;\n      output finalPhotograph : Photograph;\n    }\n\n    selectSceneAction.scene <- scene;\n    focusAction.selectedScene <- selectSceneAction.selectedScene;\n    shootAction.image <- focusAction.image;\n    finalPhotograph <- shootAction.finalPhotograph;\n  }\n}\n```",
    "model AutomatedPhotographySystem  \n  block PhotographySystem  \n    part focusProcessor: FocusProcessor  \n    part shooter: Shooter  \n\n    behavior automatePhotography  \n      input scene: ShootingScene  \n      output photograph: Photograph  \n\n      action processFocus  \n        input scene: ShootingScene  \n        output focusedImage: FocusedImage  \n        using focusProcessor.focusProcessing(scene)  \n      end action  \n\n      action capturePhoto  \n        input image: FocusedImage  \n        output photograph: Photograph  \n        using shooter.shoot(image)  \n      end action  \n    end behavior  \n  end block  \n\n  block FocusProcessor  \n    behavior focusProcessing  \n      input scene: ShootingScene  \n      output focusedImage: FocusedImage  \n    end behavior  \n  end block  \n\n  block Shooter  \n    behavior shoot  \n      input image: FocusedImage  \n      output photograph: Photograph  \n    end behavior  \n  end block  \nend model",
    "model PhotographyWorkflowModel {\n  block PhotographyWorkflow {\n    input Scene : Scene;\n    output Picture : Picture;\n    part focusStep : FocusAction;\n    part shootStep : ShootAction;\n    focusStep.Scene <- Scene;\n    Image <- focusStep.Image;\n    shootStep.Image <- Image;\n    Picture <- shootStep.Picture;\n  }\n  block FocusAction {\n    input Scene : Scene;\n    output Image : Image;\n  }\n  block ShootAction {\n    input Image : Image;\n    output Picture : Picture;\n  }\n  block Scene {}\n  block Image {}\n  block Picture {}\n}",
    "block PhotographySystem {\n  user: User;\n  camera: Camera;\n  scene: Scene;\n}\n\nblock User {}\n\nblock Camera {\n  focus: Focus;\n}\n\nblock Focus {\n  isClear: Boolean;\n}\n\nblock Image {}\n\nactivity OneClickShooting {\n  step selectScene: Action;\n  step performFocus: Action;\n  step checkFocusClarity: Decision;\n  step capturePhoto: Action;\n  output finalImage: Image;\n\n  control selectScene -> performFocus;\n  control performFocus -> checkFocusClarity;\n  decision checkFocusClarity when (camera.focus.isClear) do capturePhoto;\n  control capturePhoto -> finalImage;\n}\n```",
    "block PhotoCaptureSystem {\n  sceneInput: SceneInput;\n  selectedScene: SceneOutput from SceneSelection;\n  focusedScene: FocusedScene from FocusActivity;\n  image: Image from ImageGeneration;\n  focusQualityResult: FocusQualityResult from FocusEvaluation;\n  photograph: Photograph from ShootingOperation;\n  finalPhoto: FinalPhoto from PhotoProduction;\n\n  valueFlow sceneInput -> selectedScene @ SceneSelection;\n  valueFlow selectedScene -> focusedScene @ FocusActivity;\n  valueFlow focusedScene -> image @ ImageGeneration;\n  valueFlow image -> focusQualityResult @ FocusEvaluation;\n  valueFlow image -> photograph @ ShootingOperation if (focusQualityResult = WellFocused);\n  valueFlow photograph -> finalPhoto @ PhotoProduction;\n}\n\nactivity SceneSelection {\n  in SceneInput;\n  out SceneOutput;\n}\n\nactivity FocusActivity {\n  in SceneOutput;\n  out FocusedScene;\n}\n\nactivity ImageGeneration {\n  in FocusedScene;\n  out Image;\n}\n\nactivity FocusEvaluation {\n  in Image;\n  out FocusQualityResult;\n}\n\nactivity ShootingOperation {\n  in Image;\n  in FocusQualityResult;\n  out Photograph;\n}\n\nactivity PhotoProduction {\n  in Photograph;\n  out FinalPhoto;\n}\n```",
    "model PhotographyWorkflowModel  \n  block PhotographySystem  \n    part sceneAcquisition : SceneAcquisition  \n    part focusFunction : FocusFunction  \n    part shootingOperation : ShootingOperation  \n    part display : Display  \n\n    operation takePhoto()  \n      flow takePhoto -> sceneAcquisition.acquireScene : SceneData  \n      flow focusFunction.performFocus -> shootingOperation.executeShooting : Photograph  \n      flow shootingOperation.executeShooting -> display.displayPhoto : DisplayedImage  \n    end takePhoto  \n  end PhotographySystem  \n\n  block SceneAcquisition  \n    operation acquireScene() : SceneData  \n    end acquireScene  \n  end SceneAcquisition  \n\n  block FocusFunction  \n    operation performFocus(image : SceneData) : FocusedImage  \n    end performFocus  \n  end FocusFunction  \n\n  block ShootingOperation  \n    operation executeShooting(image : FocusedImage) : Photograph  \n    end executeShooting  \n  end ShootingOperation  \n\n  block Display  \n    operation displayPhoto(photo : Photograph) : DisplayedImage  \n    end displayPhoto  \n  end Display  \n\n  value type SceneData  \n  value type FocusedImage  \n  value type Photograph  \n  value type DisplayedImage  \nend PhotographyWorkflowModel",
    "model AutomaticBrakingControlSystem {  \n  class VehicleBrakingSystem {  \n    part brakePedalStatusMonitor: BrakePedalStatusMonitor;  \n    part roadAdhesionMonitor: RoadAdhesionMonitor;  \n    part brakePressureAdjuster: BrakePressureAdjuster;  \n    part modulationFrequencyRegulator: ModulationFrequencyRegulator;  \n\n    behavior controlBrakingProcess {  \n      trigger keyTurnedToStart;  \n      loop monitorAndRegulateBraking {  \n        action detectBrakePedalStatus {  \n          monitor brakePedalStatusMonitor.brakePressure;  \n        }  \n        action evaluateTractionVariations {  \n          monitor roadAdhesionMonitor.roadAdhesionLevel;  \n        }  \n        action adjustBrakePressure {  \n          set brakePressureAdjuster.targetPressure = calculateOptimalPressure();  \n        }  \n        action adjustModulationFrequency {  \n          set modulationFrequencyRegulator.frequency = calculateOptimalFrequency();  \n        }  \n        constraint ensureOptimalBrakingPerformance {  \n          require brakePressureAdjuster.targetPressure > 0;  \n          require modulationFrequencyRegulator.frequency between 10..50 Hz;  \n        }  \n      }  \n    }  \n  }  \n\n  class BrakePedalStatusMonitor {  \n    property brakePressure: BrakePressure;  \n  }  \n\n  class RoadAdhesionMonitor {  \n    property roadAdhesionLevel: RoadAdhesionLevel;  \n  }  \n\n  class BrakePressureAdjuster {  \n    property targetPressure: BrakePressure;  \n  }  \n\n  class ModulationFrequencyRegulator {  \n    property frequency: Frequency;  \n  }  \n\n  goal EnsureOptimalBrakingPerformance {  \n    satisfy safeBrakingPerformance: VehicleBrakingSystem.brakePressureAdjuster.targetPressure > 0;  \n    satisfy reliableOperation: VehicleBrakingSystem.modulationFrequencyRegulator.frequency between 10..50 Hz;  \n  }  \n}",
    "model BatteryChargingControlSystem {  \n  block BatteryChargingSystem {  \n    part monitor: BatteryCapacityMonitor {  \n      property batteryLevel: BatteryLevelSignal;  \n      behavior monitorBatteryLevel {  \n        action monitorBatteryLevel() {  \n          output batteryLevel: BatteryLevelSignal;  \n        }  \n      }  \n    }  \n    part charger: AutomaticCharger {  \n      property chargingActive: Boolean;  \n      behavior supplyCharge {  \n        action supplyCharge(batteryLevel: BatteryLevelSignal) {  \n          set chargingActive = batteryLevel.level < 100;  \n        }  \n      }  \n    }  \n    part terminator: ChargingTerminationController {  \n      property chargingTerminated: Boolean;  \n      behavior terminateCharging {  \n        action terminateCharging(batteryLevel: BatteryLevelSignal) {  \n          set chargingTerminated = batteryLevel.level >= 100;  \n        }  \n      }  \n    }  \n    delegation connector monitorToSystem: monitor.batteryLevel -> system.batteryLevel;  \n    delegation connector chargerToSystem: charger.chargingActive -> system.chargingActive;  \n    delegation connector terminatorToSystem: terminator.chargingTerminated -> system.chargingTerminated;  \n  }  \n  block BatteryCapacityMonitor {  \n    property batteryLevel: BatteryLevelSignal;  \n  }  \n  block AutomaticCharger {  \n    property chargingActive: Boolean;  \n  }  \n  block ChargingTerminationController {  \n    property chargingTerminated: Boolean;  \n  }  \n  data type BatteryLevelSignal {  \n    property level: Real;  \n  }  \n}",
    "block BatteryChargingSystem {\n  property batteryLevel : Percentage;\n  property chargingActive : Boolean;\n}constraint ChargingControl {\n  self.batteryLevel < 100% implies self.chargingActive = true;\n  self.batteryLevel >= 100% implies self.chargingActive = false;\n}constraint AutomationConstraint {\n  self.chargingActive = (self.batteryLevel < 100%);\n}",
    "block User {\n  behavior selectScene : Scene;\n}\n\nblock Scene {\n}\n\nblock Photo {\n  constraint extend ImageQualityConstraint;\n  constraint extend PhotoStorageConstraint;\n}\n\nblock ImageQualityConstraint {\n  property clear : Boolean;\n  property realistic : Boolean;\n}\n\nblock PhotoStorageConstraint {\n  property saved : Boolean;\n}\n\nblock AutofocusSubsystem {\n  behavior focusOnScene(input scene : Scene, output focusedScene : Scene);\n}\n\nblock ImagingSubsystem {\n  behavior captureImage(input scene : Scene, output photo : Photo);\n}\n\nblock CameraSystem {\n  part autofocus : AutofocusSubsystem;\n  part imaging : ImagingSubsystem;\n  reference user : User;\n  reference photo : Photo;\n\n  behavior takePhoto(input scene : Scene, output photo : Photo) {\n    call autofocus.focusOnScene(scene: scene, focusedScene: focusedScene);\n    call imaging.captureImage(scene: focusedScene, photo: photo);\n    call savePhoto(photo: photo);\n  }\n\n  behavior savePhoto(input photo : Photo) {\n    photo.saved = true;\n  }\n}\n```",
    "block DigitalCameraShootingSystem\n  part viewfindingModule : ViewfindingModule\n  part focusingModule : FocusingModule\n  part imagingModule : ImagingModule\n  behavior shoot : BehaviorDefinition\n    step selectScene : viewfindingModule.selectScene()\n    step autoFocus : focusingModule.autoFocus(selectedScene)\n    step captureImage : imagingModule.captureImage(focusedScene)\n    output finalPhoto : HighQualityPhoto = captureImage.result\nend\n\nblock ViewfindingModule\n  action selectScene()\n    output selectedScene : Scene\n  end\nend\n\nblock FocusingModule\n  action autoFocus(scene : Scene)\n    input scene\n    output focusedScene : Scene\n  end\nend\n\nblock ImagingModule\n  action captureImage(scene : Scene)\n    input scene\n    output result : HighQualityPhoto\n  end\nend\n\nvaluetype Scene\nend\n\nvaluetype HighQualityPhoto\nend\n```",
    "block PowerInput {\n    property timeStep : Integer;\n    property powerValue : Real;\n}\n\nblock Vehicle {\n    property mass : Real;\n    property initialPosition : Real;\n    property initialVelocity : Real;\n    property timeInterval : Real;\n    property powerInputs : Sequence<PowerInput>;\n    property trajectory : Sequence<Real>;\n}constraint VehicleSimulation {\n    variable velocity : Sequence<Real>;\n    variable position : Sequence<Real>;\n    equation\n        velocity[0] = initialVelocity;\n        position[0] = initialPosition;\n        for i in 0..size(powerInputs)-1 loop\n            0.5 * mass * velocity[i+1]^2 = 0.5 * mass * velocity[i]^2 + powerInputs[i].powerValue * timeInterval;\n            position[i+1] = position[i] + (velocity[i] + velocity[i+1]) / 2 * timeInterval;\n        end for;\n        trajectory = position;\n    end equation;\n}\n```",
    "model CameraSystemModel {\n  action SceneInputAction {\n    input userScene: Scene\n    output scene: Scene\n  }\n  action FocusingProcessAction {\n    input scene: Scene\n    output focusedImage: FocusedImage\n  }\n  action ImageCaptureAction {\n    input focusedImage: FocusedImage\n    output photo: Photo\n  }\n  action PhotoDisplayAction {\n    input photo: Photo\n    output displayedPhoto: DisplayedPhoto\n  }\n  block CameraSystem {\n    sceneInput: SceneInputAction\n    focusingProcess: FocusingProcessAction\n    imageCapture: ImageCaptureAction\n    photoDisplay: PhotoDisplayAction\n    uses sceneInput\n    uses focusingProcess\n    uses imageCapture\n    uses photoDisplay\n  }\n}",
    "block CameraSystem {\n  port viewPort : ViewPort;\n  port displayPort : DisplayPort;\n\n  behavior CameraWorkflow {\n    action UserSelectScene {\n      output scene : Image;\n    }\n\n    action FocusAction {\n      input scene : Image;\n      output focusedImage : Image;\n    }\n\n    action CaptureAction {\n      input image : Image;\n      output picture : Picture;\n    }\n\n    action DisplayAction {\n      input picture : Picture;\n      output displayedPicture : Picture;\n    }\n\n    transition UserSelectScene -> FocusAction when output scene;\n    transition FocusAction -> CaptureAction when output focusedImage;\n    transition CaptureAction -> DisplayAction when output picture;\n    transition DisplayAction -> end when output displayedPicture;\n  }\n}\n\ndataType Image;\ndataType Picture;\n\nblock ViewPort;\nblock DisplayPort;",
    "enum SensorStatus {\n    Ready\n    Updating\n    Updated\n}\n\nblock Sensor {\n    property status : SensorStatus\n    operation update() : Boolean\n}\n\nblock SensorManagementSystem {\n    property sensors : Sensor[*]\n    operation registerSensor(sensor : Sensor) : Void\n    operation processReadySensors() : Void\n    constraintClause {\n        processReadySensors() iterates over sensors where (s.status == SensorStatus::Ready) and invokes s.update()\n    }\n}\n```",
    "stateMachine VehicleStateController {\n  initial state off {\n    transition when (vehicleStartSignal) to starting;\n  }\n  state starting {\n    transition when (vehiclePowerOnSignal) to on;\n    transition when (vehicleShutdownSignal) to off;\n  }\n  state on {\n    transition when (vehicleShutdownSignal) to off;\n  }\n}",
    "package VehicleStateManagement {\n  signal VehicleStartSignal;\n  signal VehicleOnSignal;\n  signal VehicleOffSignal;\n\n  stateMachine VehicleStateMachine {\n    initial off;\n    state off {\n      when (VehicleStartSignal) transition to starting;\n    }\n    state starting {\n      when (VehicleOnSignal) transition to on;\n    }\n    state on {\n      when (VehicleOffSignal) transition to off;\n    }\n  }\n}",
    "block VehiclePowerManagementSystem\n  part powerStateMachine : PowerStateStateMachine\nend\n\nblock PowerStateStateMachine\n  state offState\n    entry: cutOffPowerSupply\n  end\n  state startPhase\n  end\n  state poweredOnState\n    entry: performSelfDiagnosis\n    entry: supplyPowerToFunctionalUnits\n    exit: executeSafetyOperations\n  end\n  transition offToStart\n    source: offState\n    target: startPhase\n    when: vehicleStartCommand\n  end\n  transition startToPoweredOn\n    source: startPhase\n    target: poweredOnState\n    when: vehicleStartedSignal\n  end\n  transition poweredOnToOff\n    source: poweredOnState\n    target: offState\n    when: vehicleShutdownCommand\n  end\nend",
    "model VehicleControl {\n  stateMachine VehicleControlStateMachine {\n    initial state Shutdown {}\n    state Startup {}\n    state Running {}\n    \n    transition Shutdown -> Startup on vehicleStartSignal\n    transition Startup -> Running on vehicleStartedSignal\n    transition Running -> Shutdown on vehicleShutdownSignal\n  }\n}",
    "model PowerManagementSystem {\n  package PowerStates {\n    stateMachine VehiclePowerStateMachine {\n      state Off {}\n      state Start {}\n      state On {}\n      transition Off -> Start when StartSignal {}\n      transition Start -> On when OnSignal {}\n      transition On -> Off when OffSignal {}\n    }\n  }\n  package HealthStateManagement {\n  }\n  signal StartSignal {}\n  signal OnSignal {}\n  signal OffSignal {}\n}",
    "model VehicleHealthSystemModel {\n  partDefinition TemperatureSensor {\n    property currentTemperature : Real;\n  }\n\n  partDefinition Controller {\n    property maxAllowableTemperature : Real;\n  }\n\n  partDefinition MaintenanceScheduler {\n    property nextMaintenanceTime : Duration;\n    property maintenanceInterval : Duration;\n    property maintenanceDuration : Duration = 48h;\n  }\n\n  partDefinition VehicleHealthSystem {\n    part temperatureSensor : TemperatureSensor;\n    part controller : Controller;\n    part maintenanceScheduler : MaintenanceScheduler;\n  }\n\n  signalDefinition OverTemperatureWarning;\n\n  behaviorDefinition VehicleHealthSystemBehavior : Behavior {\n    stateMachine healthStatus : Enumeration { Normal, Degraded, Maintenance } {\n      initial state Normal {\n        transition to Degraded when (temperatureSensor.currentTemperature > controller.maxAllowableTemperature) {\n          send OverTemperatureWarning to controller;\n        }\n        transition to Maintenance when at (maintenanceScheduler.nextMaintenanceTime);\n      }\n      state Degraded {\n        transition to Normal when (temperatureSensor.currentTemperature < controller.maxAllowableTemperature);\n        transition to Maintenance when at (maintenanceScheduler.nextMaintenanceTime);\n      }\n      state Maintenance {\n        after (maintenanceScheduler.maintenanceDuration) transition to Normal {\n          maintenanceScheduler.nextMaintenanceTime = currentTime + maintenanceScheduler.maintenanceInterval;\n        }\n      }\n    }\n  }\n}",
    "block Server {\n  port requestPort: RequestPort;\n  part stateMachine: ServerStateMachine;\n}\n\ninterface RequestPort {\n  operation startCommand();\n  operation request();\n}\n\nstateMachine ServerStateMachine {\n  initial state off;\n\n  state off {\n    entry / log(\"Server is off\");\n    exit / log(\"Server turned on\");\n    transition to: waiting when: requestPort.startCommand;\n  }\n\n  state waiting {\n    entry / log(\"Waiting for requests\");\n    transition to: response when: requestPort.request;\n    transition to: off when: time(11:59:00) every: 1d;\n  }\n\n  state response {\n    entry / log(\"Processing response\");\n    exit / log(\"Response completed\");\n    transition to: waiting after: 5min;\n    transition to: off when: time(11:59:00) every: 1d;\n  }\n}\n```",
    "model VehicleStartStopControl {\n  block VehicleControlSystem {\n    brakePedalDepressed : Boolean;\n    powerOnSignal : Event;\n    startSignal : Event;\n    stopSignal : Event;\n    controller : Controller;\n\n    stateMachine VehicleControlStateMachine {\n      initial state off {\n        transition to: startProcess on startSignal;\n      }\n      state startProcess {\n        transition to: operating on powerOnSignal when (brakePedalDepressed) do {\n          send startSignal to controller;\n        };\n      }\n      state operating {\n        entry do {\n          perform selfCheck;\n          start continuousPowerSupply;\n        }\n        exit do {\n          applyParkingBrake;\n        }\n        transition to: off on stopSignal;\n      }\n    }\n  }\n\n  block Controller {\n    action receiveStartSignal;\n  }\n}\n```",
    "block VehicleControlSystem {\n  vehicleController: VehicleController\n  brakePedalDepressed: Boolean\n  vehicleOnSignalReceived: Boolean\n  parkingBrakeApplied: Boolean\n}\n\nblock VehicleController {\n  startControlSignal: Boolean\n}\n\nstateMachine VehicleControlSystemStateMachine for VehicleControlSystem {\n  state off {\n    initial\n    transition to start-up when vehicleStartSignal\n  }\n  state start-up {\n    transition to started when vehicleOnSignal if (brakePedalDepressed) do {\n      set vehicleController.startControlSignal to true\n      set vehicleOnSignalReceived to true\n    }\n  }\n  state started {\n    do {\n      perform selfCheck\n      supplyPower\n    }\n    transition to shuttingDown when shutdownSignal\n  }\n  state shuttingDown {\n    do {\n      apply parkingBrake\n      set parkingBrakeApplied to true\n    }\n    transition to off when done\n  }\n}",
    "model CruiseControlSystemModel {  \n  block Driver {  \n    command: SetSpeedCommand;  \n  }  \n\n  block CruiseController {  \n    input setSpeedCommand: SetSpeedCommand;  \n    input actualSpeed: ActualSpeed;  \n    output fuelControlCommand: FuelControlCommand;  \n  }  \n\n  block Speedometer {  \n    vehicle: Vehicle;  \n    output actualSpeed: ActualSpeed;  \n  }  \n\n  block Engine {  \n    input fuelControlCommand: FuelControlCommand;  \n    output adjustedOutput: AdjustedOutput;  \n  }  \n\n  block Vehicle {  \n    speed: Integer;  \n  }  \n\n  block SetSpeedCommand;  \n  block ActualSpeed;  \n  block FuelControlCommand;  \n  block AdjustedOutput;  \n\n  block CruiseControlSystem {  \n    parts: {  \n      driver: Driver;  \n      cruiseController: CruiseController;  \n      speedometer: Speedometer;  \n      engine: Engine;  \n      vehicle: Vehicle;  \n    }  \n    constraints: {  \n      driver.command -> cruiseController.setSpeedCommand;  \n      speedometer.actualSpeed -> cruiseController.actualSpeed;  \n      cruiseController.fuelControlCommand -> engine.fuelControlCommand;  \n    }  \n    behaviors: {  \n      when(driver.command) {  \n        cruiseController.setSpeedCommand = driver.command;  \n      }  \n      when(speedometer.actualSpeed) {  \n        cruiseController.actualSpeed = speedometer.actualSpeed;  \n      }  \n      when(cruiseController.fuelControlCommand) {  \n        engine.fuelControlCommand = cruiseController.fuelControlCommand;  \n      }  \n    }  \n  }  \n}",
    "block CruiseControlSystem\n  part cruiseController : CruiseController\n  part speedometer : Speedometer\n  part engineSystem : EngineSystem\nend block\n\nblock CruiseController\n  port setSpeedCommand in SetSpeedCommand\n  port actualSpeed in ActualSpeed\n  port throttleCommand out ThrottleCommand\nend block\n\nblock Speedometer\n  port actualSpeed out ActualSpeed\nend block\n\nblock EngineSystem\n  port throttleCommand in ThrottleCommand\nend block\n\nvalue type SetSpeedCommand\n  property value : Real\n  dataType Real\nend value type\n\nvalue type ActualSpeed\n  property value : Real\n  dataType Real\nend value type\n\nvalue type ThrottleCommand\n  property value : Real\n  dataType Real\nend value typeconnector cruiseController.actualSpeed -> speedometer.actualSpeed\nconnector cruiseController.throttleCommand -> engineSystem.throttleCommand",
    "model CruiseControlSystem {  \n  block Driver {  \n    part controlInterface : ControlInterface;  \n  }  \n\n  block ControlInterface {  \n    property setSpeed : Real;  \n  }  \n\n  block CruiseController {  \n    property setSpeed : Real;  \n    property currentSpeed : Real;  \n    property throttleCommand : Real;  \n\n    behavior calculateThrottle {  \n      action compareSpeeds {  \n        input setSpeed : Real;  \n        input currentSpeed : Real;  \n        output throttleCommand : Real;  \n      }  \n    }  \n  }  \n\n  block Speedometer {  \n    property currentSpeed : Real;  \n  }  \n\n  block Engine {  \n    property throttleCommand : Real;  \n  }  \n\n  message setSpeedCommand : send Real to CruiseController;  \n  message requestCurrentSpeed : send Void to Speedometer;  \n  message currentSpeedResponse : receive Real from Speedometer;  \n  message sendThrottleCommand : send Real to Engine;  \n}",
    "valuetype SpeedValue {\n  unit: km/h;\n}\n\nvaluetype ThrottleControlCommand {\n  unit: percentage;\n}\n\nblock Driver {\n  valueprop setSpeedCommand : SpeedValue;\n}\n\nblock CruiseController {\n  valueprop desiredSpeed : SpeedValue;\n  valueprop currentSpeed : SpeedValue;\n  valueprop throttleControlCommand : ThrottleControlCommand;\n}\n\nblock Speedometer {\n  valueprop measuredSpeed : SpeedValue;\n}\n\nblock Engine {\n  valueprop appliedThrottle : ThrottleControlCommand;\n}\n\nvalueflow DriverSpeedCommand {\n  source: Driver.setSpeedCommand;\n  destination: CruiseController.desiredSpeed;\n}\n\nvalueflow VehicleSpeedFeedback {\n  source: Speedometer.measuredSpeed;\n  destination: CruiseController.currentSpeed;\n}\n\nvalueflow ThrottleAdjustmentCommand {\n  source: CruiseController.throttleControlCommand;\n  destination: Engine.appliedThrottle;\n}\n```",
    "model AutomotiveCruiseControl {  \n  block CruiseControlSystem {  \n    part interface: CruiseControlInterface;  \n    part controller: CruiseController;  \n    part sensor: SpeedSensor;  \n    part engine: Engine;  \n    part vehicleSpeed: VehicleSpeed;  \n\n    interface.setSpeedCommandPort->controller.setSpeedCommandPort;  \n    sensor.actualSpeedPort->controller.actualSpeedPort;  \n    controller.fuelControlCommandPort->engine.fuelControlCommandPort;  \n    sensor.speedSensorReference->vehicleSpeed;  \n  }  \n\n  block CruiseControlInterface {  \n    port setSpeedCommandPort: SetSpeedCommand [out];  \n  }  \n\n  block CruiseController {  \n    port setSpeedCommandPort: SetSpeedCommand [in];  \n    port actualSpeedPort: ActualSpeedInfo [in];  \n    port fuelControlCommandPort: FuelControlCommand [out];  \n  }  \n\n  block SpeedSensor {  \n    port actualSpeedPort: ActualSpeedInfo [out];  \n    reference speedSensorReference: VehicleSpeed;  \n  }  \n\n  block Engine {  \n    port fuelControlCommandPort: FuelControlCommand [in];  \n  }  \n\n  block VehicleSpeed {  \n    property speed: Float;  \n  }  \n\n  block SetSpeedCommand {  \n    property targetSpeed: Float;  \n    property isActive: Boolean;  \n  }  \n\n  block ActualSpeedInfo {  \n    property currentSpeed: Float;  \n    property timestamp: String;  \n  }  \n\n  block FuelControlCommand {  \n    property throttlePosition: Float;  \n    property commandType: String;  \n  }  \n}",
    "block Driver {\n}\n\nblock CruiseController {\n  reference speedSensor : SpeedSensor [1];\n  reference engineController : EngineController [1];\n}\n\nblock SpeedSensor {\n}\n\nblock EngineController {\n  reference engine : Engine [1];\n}\n\nblock Engine {\n}message SetSpeedCommand {\n  send from Driver;\n  receive by CruiseController;\n}message ActualSpeed {\n  send from SpeedSensor;\n  receive by CruiseController;\n}message FuelControlCommand {\n  send from CruiseController;\n  receive by EngineController;\n}message FuelControlCommand {\n  send from EngineController;\n  receive by Engine;\n}",
    "module VehicleLifecycleModel {\n  enum DisposalType {\n    scrapping\n    deRegistration\n  }\n\n  class Vehicle {\n    delivery : Delivery\n    ownerships : List<Ownership>\n    disposal : Disposal\n  }\n\n  class Delivery {\n    date : Date\n  }\n\n  class Ownership {\n    ownerInfo : String\n    startDate : Date\n    endDate : Date\n    drivingOperations : List<DrivingOperation>\n    vehicle : Vehicle\n  }\n\n  class DrivingOperation {\n    driver : String\n    date : Date\n    ownership : Ownership\n  }\n\n  class Disposal {\n    disposalType : DisposalType\n    date : Date\n    vehicle : Vehicle\n  }\n}",
    "module VehicleModel {\n  class Vehicle {\n    property mass : Real;\n    property operationalStatus : OperationalStatus;\n    property engine : Engine;\n    property driver : Driver {reference};\n    property wheels : Wheel[*];\n  }\n\n  class OperationalStatus {\n    property gearSetting : String;\n    property acceleratorPedalPosition : Real;\n  }\n\n  class Engine {}\n  class Driver {}\n  class Wheel {}\n\n  instance vehicle_1 : Vehicle {\n    mass = 1500.0;\n    operationalStatus.gearSetting = \"Drive\";\n    operationalStatus.acceleratorPedalPosition = 0.5;\n    engine : Engine = {};\n    driver : Driver {reference};\n    wheels : Wheel[2] = {\n      leftFrontWheel : Wheel {\n        // Time snapshot 1 attributes\n      },\n      rightFrontWheel : Wheel {\n        // Time snapshot 2 attributes\n      }\n    };\n  }\n}",
    "model CompositeVehicleSystem {\n  class Vehicle {\n    property mass : Number { unit = kg };\n    property state : VehicleState;\n    property engine : Engine;\n    property driver : Driver;\n  }\n\n  class VehicleState {\n    property gear : Integer;\n    property acceleratorPosition : Float;\n  }\n\n  class Engine {}\n\n  class Driver {}\n\n  instanceDefinition Vehicle_1 : Vehicle {\n    mass = 2000;\n    state.gear = 0;\n    state.acceleratorPosition = 0.0;\n  } then {\n    mass = 1500;\n    state.gear = 2;\n    state.acceleratorPosition = 0.5;\n  }\n}",
    "model VehicleModel {\n  class Vehicle {\n    property mass : Real;\n    property gearPosition : String;\n    property throttlePedalPosition : Real;\n    property engine : Engine [1..1] {subsets part};\n    property driver : Driver [0..1];\n  }\n\n  class Driver {\n    property name : String;\n  }\n\n  class Engine {\n  }\n\n  Driver Alice {\n    name = \"Alice\";\n  }\n\n  Driver Bob {\n    name = \"Bob\";\n  }\n\n  value myVehicle : Vehicle {\n    timeSlice 0 {\n      mass = 2000.0;\n      gearPosition = \"neutral\";\n      throttlePedalPosition = 0.0;\n      driver = Alice;\n    }\n\n    timeSlice 1 {\n      mass = 1500.0;\n      gearPosition = \"second\";\n      throttlePedalPosition = 0.5;\n      driver = Bob;\n    }\n  }\n}",
    "package VehicleMassModel {\n  class Mass {\n    value : Decimal;\n  }\n\n  class Component {\n    mass : Mass;\n    parts : Component[*];\n  }\n\n  class Vehicle {\n    mass : Mass;\n    parts : Component[*];\n    engine : Component;\n    transmission : Component;\n    body : Component;\n  }\n}\n```",
    "block Component {\n  property mass : Float;\n  property serialNumber : String {unique};\n  property parts[*] : Component;\n}\n\nblock Engine {\n  super Component;\n}\n\nblock Transmission {\n  super Component;\n}\n\nblock Vehicle {\n  super Component;\n  property vin : String {unique};\n  property engine : Engine;\n  property transmission : Transmission;\n}constraintBlock TotalMassConstraint {\n  parameter vehicle : Vehicle;\n  parameter threshold : Float;\n  parameter totalMass : Float;\n  totalMass = vehicle.mass + sum( filter( vehicle.parts.mass, mass >= threshold ) );\n}",
    "module QualityAggregationManagement {\n  class Thing {\n    property simpleMass : Real;\n    property totalMass : Real;\n  }\n\n  class simpleThing specializes Thing {\n    property simpleMass : Real;\n    property totalMass : Real constraint totalMass = simpleMass;\n  }\n\n  class compositeThing specializes Thing {\n    property parts : Part[*] of Thing;\n    property simpleMass : Real;\n    property totalMass : Real constraint totalMass = simpleMass + sum(parts.totalMass);\n  }\n}",
    "package MassManagement {\n    class Object {\n        basicMass: Float;\n        totalMass: Float;\n    }\n\n    class CompositeObject : Object {\n        parts: Bag<Object>;\n        minMass: Float;\n        totalMass: Float;\n    }\n\n    constraint block TotalMassConstraint for CompositeObject {\n        totalMass = self.basicMass + (if self.minMass.oclIsUndefined then self.parts->collect(p | p.totalMass)->sum() else self.parts->select(p | p.totalMass >= self.minMass)->collect(p | p.totalMass)->sum() endif);\n    }\n\n    constraint block ObjectTotalMassConstraint for Object {\n        totalMass = self.basicMass;\n    }\n}",
    "model VehicleDynamicsModel {\n  block VehicleDynamicsSystem {\n    wheelPower : Power;\n    dragCoefficient : Dimensionless;\n    frictionCoefficient : Dimensionless;\n    mass : Mass;\n    speed : Speed;\n    availablePower : Power;\n    acceleration : Acceleration;\n    time : Time;\n    position : Length;\n    initialSpeed : Speed;\n    initialPosition : Length;\n  }\n\n  value model VehicleDynamicsVM {\n    base unit set SI;\n    wheelPower : Power;\n    dragCoefficient : Dimensionless;\n    frictionCoefficient : Dimensionless;\n    mass : Mass;\n    speed : Speed;\n    availablePower : Power;\n    acceleration : Acceleration;\n    time : Time;\n    position : Length;\n    initialSpeed : Speed;\n    initialPosition : Length;\n    gravity : Acceleration = 9.81 m/s²;\n\n    constraint availablePower = wheelPower - (0.5 * dragCoefficient * speed³ + frictionCoefficient * mass * gravity * speed);\n    constraint acceleration = (availablePower / (mass * speed)) - (0.5 * dragCoefficient * speed² / mass) - frictionCoefficient * gravity;\n    constraint speed = initialSpeed + acceleration * time;\n    constraint position = initialPosition + initialSpeed * time + 0.5 * acceleration * time²;\n  }\n}",
    "model VehicleDynamicSimulation  \n  block Vehicle  \n    part powerSystem: PowerSystem  \n    part resistanceModel: ResistanceModel  \n    part motionModel: MotionModel  \n\n    parameter mass: Real  \n    parameter initialSpeed: Real  \n    parameter initialPosition: Real  \n    parameter timeStep: Time  \n    parameter dragCoefficient: Real  \n    parameter rollingResistanceCoefficient: Real  \n  end  \n\n  block PowerSystem  \n    parameter wheelEndPower: Real  \n  end  \n\n  block ResistanceModel  \n    parameter aerodynamicDragCoefficient: Real  \n    parameter rollingResistanceCoefficient: Real  \n    behavior calculateResistiveForce  \n      input speed: Real  \n      input mass: Real  \n      input dragCoefficient: Real  \n      input rollingResistanceCoefficient: Real  \n      output resistiveForce: Real  \n    end  \n  end  \n\n  block MotionModel  \n    parameter acceleration: Real  \n    parameter speed: Real  \n    parameter position: Real  \n    behavior calculateAcceleration  \n      input drivingPower: Real  \n      input resistiveForce: Real  \n      input mass: Real  \n      output acceleration: Real  \n    end  \n    behavior updateSpeed  \n      input initialSpeed: Real  \n      input acceleration: Real  \n      input timeStep: Time  \n      output newSpeed: Real  \n    end  \n    behavior updatePosition  \n      input initialPosition: Real  \n      input speed: Real  \n      input timeStep: Time  \n      output newPosition: Real  \n    end  \n  end  \n\n  block VehicleSimulation  \n    parameter wheelEndPower: Real  \n    parameter mass: Real  \n    parameter initialSpeed: Real  \n    parameter initialPosition: Real  \n    parameter timeStep: Time  \n    parameter dragCoefficient: Real  \n    parameter rollingResistanceCoefficient: Real  \n    parameter resistiveForce: Real  \n    parameter acceleration: Real  \n    parameter newSpeed: Real  \n    parameter newPosition: Real  \n\n    part vehicle: Vehicle  \n    part powerSystem: PowerSystem  \n    part resistanceModel: ResistanceModel  \n    part motionModel: MotionModel  \n\n    behavior simulateTimeStep  \n      input wheelEndPower: Real  \n      input mass: Real  \n      input initialSpeed: Real  \n      input initialPosition: Real  \n      input timeStep: Time  \n      input dragCoefficient: Real  \n      input rollingResistanceCoefficient: Real  \n      output newSpeed: Real  \n      output newPosition: Real  \n\n      resistiveForce = resistanceModel.calculateResistiveForce(  \n        speed: initialSpeed,  \n        mass: mass,  \n        dragCoefficient: dragCoefficient,  \n        rollingResistanceCoefficient: rollingResistanceCoefficient  \n      )  \n      acceleration = motionModel.calculateAcceleration(  \n        drivingPower: wheelEndPower,  \n        resistiveForce: resistiveForce,  \n        mass: mass  \n      )  \n      newSpeed = motionModel.updateSpeed(  \n        initialSpeed: initialSpeed,  \n        acceleration: acceleration,  \n        timeStep: timeStep  \n      )  \n      newPosition = motionModel.updatePosition(  \n        initialPosition: initialPosition,  \n        speed: newSpeed,  \n        timeStep: timeStep  \n      )  \n    end  \n  end  \nend",
    "model VehicleDrivingDynamicsModel {\n  block VehicleDrivingDynamicsSystem {\n    vehicleMass: Real;\n    wheelPower: Real;\n    dragCoefficient: Real;\n    rollingResistanceCoefficient: Real;\n    initialSpeed: Real;\n    initialPosition: Length;\n    currentSpeed: Real;\n    currentPosition: Length;\n    currentTime: Duration;\n    timeStep: Duration;\n  }\n  behavior simulateDynamics {\n    dynamic state DrivingSimulation {\n      currentSpeed := initialSpeed;\n      currentPosition := initialPosition;\n      currentTime := 0.0;\n      loop {\n        dragForce := 0.5 * dragCoefficient * currentSpeed^2;\n        rollingResistance := rollingResistanceCoefficient * vehicleMass * 9.81;\n        netForce := (wheelPower / currentSpeed) - dragForce - rollingResistance;\n        acceleration := netForce / vehicleMass;\n        currentSpeed := currentSpeed + acceleration * timeStep;\n        currentPosition := currentPosition + currentSpeed * timeStep + 0.5 * acceleration * timeStep^2;\n        currentTime := currentTime + timeStep;\n      }\n    }\n  }\n}",
    "model VehicleDynamicModel {\n  block VehicleDynamicSystem {\n    initialPosition : Real;\n    initialVelocity : Real;\n    mass : Real;\n    drivePower : Real;\n    timeInterval : Real;\n    dragCoefficient : Real;\n    frictionCoefficient : Real;\n    acceleration : Real;\n    finalVelocity : Real;\n    finalPosition : Real;\n  }\n\n  constraint block VehicleDynamicConstraint {\n    acceleration = (drivePower / initialVelocity - 0.5 * dragCoefficient * initialVelocity^2 - frictionCoefficient * mass * 9.81) / mass;\n    finalVelocity = initialVelocity + acceleration * timeInterval;\n    finalPosition = initialPosition + initialVelocity * timeInterval + 0.5 * acceleration * timeInterval^2;\n  }\n}",
    "class Chassis {\n    mass: Mass unit kg;\n}class Engine {\n    mass: Mass unit kg;\n}class Gearbox {\n    mass: Mass unit kg;\n}class Vehicle {\n    chassis: Chassis;\n    engine: Engine;\n    gearbox: Gearbox;\n    totalMass: Mass = chassis.mass + engine.mass + gearbox.mass unit kg;\n    constraint totalMassConstraint: totalMass <= 2500 kg;\n}",
    "package VehicleMassConstraint {\n  class Vehicle {\n    chassis : Chassis;\n    engine : Engine;\n    transmission : Transmission;\n    totalMass : Real {unit=kg} = chassis.mass + engine.mass + transmission.mass;\n    constraint totalMassConstraint: totalMass <= 2500;\n  }\n\n  class Chassis {\n    mass : Real {unit=kg};\n  }\n\n  class Engine {\n    mass : Real {unit=kg};\n  }\n\n  class Transmission {\n    mass : Real {unit=kg};\n  }\n\n  requirement massLimitRequirement {\n    constraint: Vehicle.totalMass <= 2500;\n  }\n}",
    "package VehicleMassCompliance {\n    class Chassis {\n        property mass : Real;\n    }\n\n    class Engine {\n        property mass : Real;\n    }\n\n    class Transmission {\n        property mass : Real;\n    }\n\n    class Vehicle {\n        part chassis : Chassis;\n        part engine : Engine;\n        part transmission : Transmission;\n        constraint totalMassConstraint;\n    }\n\n    constraint totalMassConstraint {\n        context Vehicle\n        expression: chassis.mass + engine.mass + transmission.mass <= 2500;\n    }\n}",
    "block Chassis\n  property weight : Real[0..1] {non_negative}\nend Chassis\n\nblock Engine\n  property weight : Real[0..1] {non_negative}\nend Engine\n\nblock Transmission\n  property weight : Real[0..1] {non_negative}\nend Transmission\n\nblock Vehicle\n  part chassis : Chassis\n  part engine : Engine\n  part transmission : Transmission\n  property totalWeight : Real[0..1] {non_negative} = chassis.weight + engine.weight + transmission.weight\nend Vehicleconstraintblock MaxWeightConstraint\n  parameter totalWeight : Real\n  parameter maxWeight : Real\n  expression totalWeight <= maxWeight\nend MaxWeightConstraint\n\napply Vehicle.totalWeight to MaxWeightConstraint {\n  maxWeight = 2500.0\n}\n```",
    "model VehicleModel\n  block Vehicle\n    parts:\n      chassis : Chassis\n      engine : Engine\n      transmission : Transmission\n    constraints:\n      totalMassConstraint : TotalMassConstraint\n      dynamicConstraint : DynamicConstraint\n  end\n\n  block Chassis\n    properties:\n      mass : Real\n  end\n\n  block Engine\n    properties:\n      mass : Real\n  end\n\n  block Transmission\n    properties:\n      mass : Real\n  end\n\n  constraintblock TotalMassConstraint\n    parameters:\n      chassisMass : Real\n      engineMass : Real\n      transmissionMass : Real\n    constraints:\n      chassisMass + engineMass + transmissionMass <= 2500\n  end\n\n  constraintblock DynamicConstraint\n    parameters:\n      vInitial : Real\n      vFinal : Real\n      m : Real\n      F : Real\n      t : Real\n    constraints:\n      m > 0\n      F = m * (vFinal - vInitial) / t\n  end\nend",
    "package VehicleMaintenanceSystem {\n  block Vehicle {\n    property nextMaintenanceTime : TimeValue;\n    property maintenanceInterval : Duration;\n    property maxAllowedTemperature : Temperature;\n    property status : String;\n    property actualMaintenanceStartTime : TimeValue;\n    property maintenanceDuration : Duration;\n\n    stateMachine VehicleStatusStateMachine {\n      state Healthy {\n        entry / status = \"Healthy\";\n        exit / status = \"UnderMaintenance\";\n        transition to UnderMaintenance when time reaches nextMaintenanceTime;\n      }\n      state UnderMaintenance {\n        entry / status = \"UnderMaintenance\";\n        exit / status = \"Healthy\";\n        transition to Healthy when time reaches (actualMaintenanceStartTime + maintenanceDuration);\n        exit / nextMaintenanceTime = currentTime + maintenanceInterval;\n      }\n    }\n\n    constraint ActualMaintenanceStartConstraint {\n      actualMaintenanceStartTime > nextMaintenanceTime;\n    }\n\n    constraint MaintenanceInitiationConstraint {\n      actualMaintenanceStartTime - nextMaintenanceTime <= 2s;\n    }\n\n    constraint MaintenanceDurationConstraint {\n      maintenanceDuration <= 48h;\n    }\n\n    constraint NextMaintenancePostponementConstraint {\n      nextMaintenanceTime = actualMaintenanceStartTime + maintenanceInterval;\n    }\n\n    constraint HealthRestorationConstraint {\n      status = \"Healthy\" after maintenance completion;\n    }\n  }\n}",
    "interfaceblock EngineTorqueInterface {\n  parameter torque : Real;\n}\n\nblock Engine {\n  port outputTorque : EngineTorqueInterface direction out;\n  behavior generateTorque : FunctionBehavior {\n    input speed : Real;\n    output torque : Real;\n    equation {\n      torque := 500 - 0.5 * speed; // Example speed-torque relationship\n    }\n  }\n}\n\nblock Clutch {\n  port inputTorque : EngineTorqueInterface direction in;\n  port outputTorque : EngineTorqueInterface direction out;\n}\n\nblock Transmission {\n  port inputTorque : EngineTorqueInterface direction in;\n}\n\nblock Vehicle {\n  part engine : Engine;\n  part clutch : Clutch;\n  part transmission : Transmission;\n  valueproperty curbWeight : Real;\n  valueproperty fuelMass : Real;\n  valueproperty totalMass : Real;\n  valueproperty maxMassLimit : Real;\n  constraintclause {\n    totalMass = curbWeight + fuelMass;\n    totalMass <= maxMassLimit;\n    fuelMass > 0;\n  }\n}\n```",
    "model VehicleSystemModel {\n  component VehicleSystem {\n    component engine : Engine;\n    component transmission : Transmission;\n    component fuelTank : FuelTank;\n\n    property dryMass : Mass;\n    property fuelMass : Mass;\n\n    constraint c1 : MassConstraint {\n      dryMass + fuelMass <= maxMass;\n    }\n\n    constraint c2 : MassConstraint_FullTank {\n      when (fuelTank.isFull) {\n        maxMass <= 2000 kg;\n      }\n    }\n\n    constraint c3 : MassConstraint_EmptyTank {\n      when (fuelTank.isEmpty) {\n        maxMass <= 1500 kg;\n      }\n    }\n\n    constraint c4 : TorqueTransmissionConstraint {\n      engine.torqueOutput -> transmission.torqueInput via ClutchInterface;\n    }\n\n    constraint c5 : SpeedTorqueConstraint {\n      engine.torqueOutput.value = f(engine.speed.value) as per Table1;\n    }\n  }\n\n  component Engine {\n    port torqueOutput : ClutchInterface;\n    property speed : Speed;\n  }\n\n  component Transmission {\n    port torqueInput : ClutchInterface;\n  }\n\n  component FuelTank {\n    property fuelMass : Mass;\n    property isFull : Boolean;\n    property isEmpty : Boolean;\n  }\n\n  constraint MassConstraint {\n    parameter dryMass : Mass;\n    parameter fuelMass : Mass;\n    parameter maxMass : Mass;\n    dryMass + fuelMass <= maxMass;\n  }\n\n  constraint MassConstraint_FullTank {\n    parameter maxMass : Mass;\n    when (isFull) {\n      maxMass <= 2000 kg;\n    }\n  }\n\n  constraint MassConstraint_EmptyTank {\n    parameter maxMass : Mass;\n    when (isEmpty) {\n      maxMass <= 1500 kg;\n    }\n  }\n\n  constraint SpeedTorqueConstraint {\n    parameter speed : Speed;\n    parameter torque : Torque;\n    torque = f(speed) as per Table1;\n  }\n\n  type Mass : Real;\n  type Speed : Real;\n  type Torque : Real;\n  type Boolean : Boolean;\n}",
    "model VehicleSystemModel {\n  block Vehicle {\n    part engine : Engine;\n    property fullyFueledMass : Real;\n    constraintProperty fullyFueledMass <= 2000 * kilogram;\n    property emptyMass : Real;\n    constraintProperty emptyMass <= 1500 * kilogram;\n  }\n\n  block Engine {\n    port powerPort : PowerInterface;\n    property generatedTorque : Real;\n    constraintProperty powerPort.torque = generatedTorque;\n    constraintProperty torqueVariation : String = \"Torque varies with speed according to performance table specifications.\";\n  }\n\n  block PowerInterface {\n    property torque : Real;\n  }\n\n  package requirements {\n    requirement VehicleMassRequirements {\n      constraintProperty fullyFueledMass <= 2000 * kilogram;\n      constraintProperty emptyMass <= 1500 * kilogram;\n    }\n\n    requirement EnginePowerInterfaceRequirements {\n      constraintProperty torqueTransmitted = powerPort.torque;\n      constraintProperty torqueVariation : String = \"Torque varies with speed according to performance table specifications.\";\n    }\n  }\n}",
    "model VehicleModel {\n  block Vehicle {\n    part engine : Engine;\n    part clutch : Clutch;\n    part gearbox : Gearbox;\n    part fuelTank : FuelTank;\n    property curbMass : Real;\n    property fuelMass : Real;\n  }\n\n  block Engine {\n    property torqueOutput : Real;\n    property speed : Real;\n  }\n\n  block Clutch {\n    property transmittedTorque : Real;\n  }\n\n  block FuelTank {\n    property capacity : Real;\n  }\n\n  constraintBlock FullFuelMassConstraint {\n    parameter totalMass = (Vehicle.curbMass + FuelTank.capacity) : Real;\n    parameter massLimit = 2000 : kg;\n    expression totalMass <= massLimit;\n  }\n\n  constraintBlock EmptyFuelMassConstraint {\n    parameter totalMass = (Vehicle.curbMass + 0) : Real;\n    parameter massLimit = 1500 : kg;\n    expression totalMass <= massLimit;\n  }\n\n  constraintBlock TorqueTransmissionConstraint {\n    parameter engineTorque = Engine.torqueOutput : Real;\n    parameter clutchTorque = Clutch.transmittedTorque : Real;\n    expression clutchTorque == engineTorque;\n  }\n}",
    "model VehicleDynamicPerformanceAnalysis {\n  block Vehicle {\n    property curbWeight : Real {unit = 'kg'};\n    property payload : Real {unit = 'kg'};\n    property wheelDiameter : Real {unit = 'm'};\n    property transmissionEfficiency : Real {unit = 'dimensionless'};\n    property urbanFuelEconomy : Real {unit = 'mpg'};\n    property highwayFuelEconomy : Real {unit = 'mpg'};\n  }\n\n  block TimeStampedData {\n    property timestamp : Time;\n    property position : Length {unit = 'm'};\n    property speed : Velocity {unit = 'm/s'};\n  }\n\n  block DrivingCycle {\n    property dataPoints : TimeStampedData[*];\n  }\n\n  block AnalysisSystem {\n    property vehicle : Vehicle;\n    property drivingCycle : DrivingCycle;\n    property requiredEnginePower : Power {unit = 'kW'};\n    property acceleration : Acceleration {unit = 'm/s^2'};\n    property fuelEconomyResult : FuelEconomy {unit = 'mpg'};\n    property complianceStatus : Boolean;\n  }\n\n  value ComplianceTarget {\n    property targetFuelEconomy : Real {unit = 'mpg'};\n    property meetsTarget : Boolean;\n  }\n}",
    "block VehicleFuelEconomySystem\n  has urbanScenario: UrbanDrivingScenario\n  has highwayScenario: HighwayDrivingScenario\n  has vehicleParams: VehicleParameters\n  has dynamicsAnalysis: VehicleDynamicsAnalysis\n  has engineEstimator: EnginePowerEstimator\n  has fuelCalculator: FuelConsumptionCalculator\n  has fuelEconomyConstraint: FuelEconomyConstraint\n\n  dynamicsAnalysis.uses vehicleParams: VehicleParameters\n  dynamicsAnalysis.uses scenario: UrbanDrivingScenario\n  engineEstimator.uses dynamicsAnalysis.wheelPower: Power\n  engineEstimator.uses vehicleParams.transmissionEfficiency: Efficiency\n  fuelCalculator.uses engineEstimator.enginePower: Power\n  fuelCalculator.uses vehicleParams.curbWeight: Mass\n  fuelCalculator.uses vehicleParams.load: Mass\n  fuelEconomyConstraint.uses fuelCalculator.fuelEconomy: FuelEconomy\nend\n\nblock UrbanDrivingScenario\n  speedProfile: Function<Time, Speed>\n  trajectory: Function<Time, Distance>\nend\n\nblock HighwayDrivingScenario\n  speedProfile: Function<Time, Speed>\n  trajectory: Function<Time, Distance>\nend\n\nblock VehicleParameters\n  curbWeight: Mass\n  load: Mass\n  wheelDiameter: Length\n  transmissionEfficiency: Efficiency\nend\n\nblock VehicleDynamicsAnalysis\n  uses vehicleParams: VehicleParameters\n  uses drivingScenario: DrivingScenario\n  wheelPower: Power\n  acceleration: Acceleration\n  energyConsumption: Energy\nend\n\nblock EnginePowerEstimator\n  uses wheelPower: Power\n  uses transmissionEfficiency: Efficiency\n  enginePower: Power\nend\n\nblock FuelConsumptionCalculator\n  uses enginePower: Power\n  uses curbWeight: Mass\n  uses load: Mass\n  fuelEconomy: FuelEconomy\nendconstraint block FuelEconomyConstraint\n  fuelEconomyLimit: FuelEconomy = 7.84 @ 'L/100km'\n  assert fuelCalculator.fuelEconomy < fuelEconomyLimit\nend\n\ntype Mass is Real;\ntype Length is Real;\ntype Efficiency is Real;\ntype Power is Real;\ntype Speed is Real;\ntype Distance is Real;\ntype Energy is Real;\ntype FuelEconomy is Real;\ntype Time is Real;\n```",
    "model EngineSelectionModel {\n  class Engine {\n    power : Real;\n    mass : Real;\n    efficiency : Real;\n    cost : Real;\n  }\n\n  class FourCylinderEngine extends Engine {}\n\n  class SixCylinderEngine extends Engine {}\n\n  function evaluateEngine(power : Real, mass : Real, efficiency : Real, cost : Real) : Real;\n\n  class EngineSelectionSystem {\n    function selectOptimalEngine(engines : List<Engine>) : Engine;\n  }\n}",
    "model VehicleCurbWeightCheck {\n  block DataCollection {\n    action collectActualWeight {\n      output: actualWeight : Real;\n      unit: kg;\n    }\n    var actualWeight : Real;\n    unit: kg;\n  }\n\n  block DataProcessing {\n    action processWeightData {\n      input: rawWeight : Real;\n      unit: kg;\n      output: processedWeight : Real;\n      unit: kg;\n    }\n    var processedWeight : Real;\n    unit: kg;\n  }\n\n  block Evaluation {\n    action checkWeightCompliance {\n      input: evaluatedWeight : Real;\n      unit: kg;\n      input: maxCurbWeight : Real;\n      unit: kg;\n      output: result : Boolean;\n    }\n    var result : Boolean;\n  }\n\n  constraintClause MaxCurbWeightConstraint {\n    maxCurbWeight : Real = 2500;\n    unit: kg;\n  }\n\n  block VehicleWeightCheckSystem {\n    part dataCollector : DataCollection;\n    part processor : DataProcessing;\n    part evaluator : Evaluation;\n    \n    dataCollector.actualWeight -> processor.rawWeight;\n    processor.processedWeight -> evaluator.evaluatedWeight;\n    \n    action executeCheck {\n      input: maxCurbWeightConstraint : MaxCurbWeightConstraint;\n      output: evaluator.result;\n    }\n  }\n}",
    "package MassVerification {\n    block Vehicle {\n        property actualMass : Real;\n    }\n\n    block WeighingEquipment {\n        operation measureMass() : Real;\n    }\n\n    block MassVerificationUnit {\n        operation verifyMass(actualMass : Real, massLimit : Real) : Boolean;\n    }\n\n    constraint MaxMassConstraint {\n        parameter massLimit : Real = 2500;\n    }\n\n    block MassVerificationSystem {\n        part vehicle : Vehicle;\n        part weighingEquipment : WeighingEquipment;\n        part verificationUnit : MassVerificationUnit;\n        apply MaxMassConstraint;\n\n        operation verifyVehicleMass() {\n            var measuredMass : Real = weighingEquipment.measureMass();\n            var isQualified : Boolean = verificationUnit.verifyMass(measuredMass, massLimit);\n            return isQualified;\n        }\n    }\n}\n```",
    "model ConvenientTransportationSystem {\n  system TransportationSystem {\n    part vehicle: Vehicle;\n    part driver: Driver [1];\n    part passengers: Passenger [0..4];\n    constraint ensureSafeAndComfortableJourney: SafeAndComfortableJourney;\n    constraint integrateEnvironmentalFactors: EnvironmentalIntegration;\n    constraint infrastructureCompatibility: GasStationCompatibility;\n    constraint smoothEntryExit: SmoothEntryExit;\n    constraint humanCenteredOperation: HumanNeedsFocus;\n  }\n}",
    "module TransportationSystem {\n  element Driver {\n    operation operateVehicle(conditions: EnvironmentalConditions) : Boolean;\n    operation exitVehicle() : Boolean;\n  }\n\n  element Passenger {\n    operation enterVehicle() : Boolean;\n    operation exitVehicle() : Boolean;\n  }\n\n  element Vehicle {\n    property driver : Driver;\n    property passengers : Passenger[*] {0..4};\n    operation transportPassengers() : Boolean;\n    operation refuelAtStation(station: GasStation) : Boolean;\n  }\n\n  element EnvironmentalConditions {\n    // Environmental factors affecting vehicle operation\n  }\n\n  element GasStation {\n    // Fueling location for vehicle\n  }\n\n  relation Enters from Passenger to Vehicle;\n  relation Exits from Passenger to Vehicle;\n  relation Operates from Driver to Vehicle;\n  relation RefuelsAt from Vehicle to GasStation;\n  relation Influences from EnvironmentalConditions to Vehicle;\n\n  constraint SafetyConstraint {\n    condition (vehicle.driver <> null and vehicle.passengers->size() <= 4) implies (vehicle.transportPassengers() = true);\n  }\n\n  constraint ConvenienceConstraint {\n    condition (passenger.enterVehicle() = true) and (passenger.exitVehicle() = true);\n  }\n}",
    "class Vehicle {\n  parts:\n    engine: Engine;\n    transmission: Transmission;\n  constraints:\n    transmissionConstraint: TransmissionConstraint;\n    diameterConstraint: DiameterConstraint;\n}class Engine {\n  diameter: Integer;\n}class FourCylinderEngine extends Engine {\n  cylinders: Integer = 4;\n}class SixCylinderEngine extends Engine {\n  cylinders: Integer = 6;\n}class Transmission {\n}class ManualTransmission extends Transmission {\n}class AutomaticTransmission extends Transmission {\n}constraint block DiameterConstraint {\n  diameter in {70, 100};\n}constraint block TransmissionConstraint {\n  if (transmission.isKindOf(ManualTransmission)) then\n    engine.isKindOf(FourCylinderEngine)\n  endif;\n  if (engine.isKindOf(SixCylinderEngine)) then\n    transmission.isKindOf(AutomaticTransmission)\n  endif;\n}",
    "value definition CylinderCount : Integer { allowedValues = 4, 6 }\nvalue definition CylinderDiameter : Length { allowedValues = 70 mm, 100 mm }\n\nblock Engine {\n  parameter cylinderCount : CylinderCount\n  parameter cylinderDiameter : CylinderDiameter\n  part cylinders : Cylinder [cylinderCount] { diameter = cylinderDiameter }\n}\n\nblock Cylinder {\n  parameter diameter : Length\n}",
    "block Engine {\n  value cylinders : Integer\n  value diameter : Length\n}\n\nblock Transmission {\n  value type : String\n}\n\nblock Vehicle {\n  part engine : Engine\n  part transmission : Transmission\n}constraint EngineCylinderConstraint {\n  Engine.cylinders in {4, 6}\n}constraint EngineDiameterConstraint {\n  Engine.diameter in {70, 100}\n}constraint TransmissionTypeConstraint {\n  if (Engine.cylinders == 4) then (Transmission.type == \"manual\") else (Transmission.type == \"automatic\")\n}\n```",
    "model SystemModel {\n  block SystemAssembly {\n    parts: computer: ComputerSubSystem;\n    parts: storage: StorageSubSystem;\n    behaviors: mainBehavior: Behavior {\n      parameters: message: MessageFormat;\n      parameters: data: DataFormat;\n      steps: computer.computerBehavior(message, data);\n      steps: storage.storageBehavior(message, data);\n    }\n  }\n  block ComputerSubSystem {\n    parts: softwareDesign: SoftwareDesign;\n    behaviors: computerBehavior: Behavior {\n      parameters: message: MessageFormat;\n      parameters: data: DataFormat;\n      steps: processInformation(message, data);\n    }\n  }\n  block StorageSubSystem {\n    parts: softwareDesign: SoftwareDesign;\n    behaviors: storageBehavior: Behavior {\n      parameters: message: MessageFormat;\n      parameters: data: DataFormat;\n      steps: storeData(data);\n      steps: transmitMessage(message);\n    }\n  }\n  block SoftwareDesign {\n    parts: messageFormat: MessageFormat;\n    parts: dataFormat: DataFormat;\n  }\n  block MessageFormat {}\n  block DataFormat {}\n}",
    "block PowertrainLogicalLayer {\n  parts:\n    powerProvider : PowerProvider;\n    torqueGenerator : TorqueGenerator;\n}\n\nblock PowerProvider {\n  behaviors:\n    providePower : Behavior;\n}\n\nblock TorqueGenerator {\n  behaviors:\n    convertPowerToTorque : Behavior;\n}\n\nblock PowertrainPhysicalLayer {\n  parts:\n    powerUnit : PowerUnit;\n}\n\nblock PowerUnit {\n  behaviors:\n    outputPower : Behavior;\n    generateTorque : Behavior;\n}\n\nallocateTo: PowertrainLogicalLayer.torqueGenerator -> PowertrainPhysicalLayer.powerUnit;\nallocateTo: PowertrainLogicalLayer.powerProvider -> PowertrainPhysicalLayer.powerUnit;\n```",
    "model PowerTransmissionSystem {\n  block LogicalModel {\n    component TorqueGenerator {\n      action generateTorque;\n    };\n  }\n\n  block PhysicalModel {\n    component Powertrain {\n      component Engine {\n        action generateTorque;\n      };\n    };\n  }\n\n  allocate LogicalModel::TorqueGenerator to PhysicalModel::Powertrain;\n  allocate LogicalModel::TorqueGenerator::generateTorque to PhysicalModel::Powertrain::Engine::generateTorque;\n}",
    "model VehicleFeatureAnnotationSystem {\n  block Vehicle {\n    property interior : InteriorAssembly;\n    property body : BodyAssembly;\n  }\n\n  block InteriorAssembly {\n    property seatBelts : SeatBelt;\n    property frontSeats : FrontSeat;\n    property driverAirbag : DriverAirbag;\n    property alarmSystem : AlarmSystem;\n  }\n\n  block BodyAssembly {\n    property bodyShell : BodyShell;\n    property bumpers : Bumper;\n    property keylessEntry : KeylessEntryDevice;\n  }\n\n  block SeatBelt {\n    function : String = \"Occupant Restraint (Safety)\";\n  }\n\n  block FrontSeat {\n    // No function specified in requirements\n  }\n\n  block DriverAirbag {\n    function : String = \"Collision Protection (Safety)\";\n  }\n\n  block AlarmSystem {\n    function : String = \"Anti-Theft Alarm (Security)\";\n  }\n\n  block BodyShell {\n    // No function specified in requirements\n  }\n\n  block Bumper {\n    function : String = \"Collision Protection (Safety)\";\n  }\n\n  block KeylessEntryDevice {\n    function : String = \"Keyless Entry (Security)\";\n  }\n}",
    "model VehicleDynamicSimulation {\n  block VehicleDynamicSystem {\n    property initialVelocity : Real;\n    property initialPosition : Real;\n    property acceleration : Real;\n    property timeStep : Real;\n    property modelCenterTool : ModelCenterAnalysisTool;\n    property finalVelocity : Real;\n    property finalPosition : Real;\n    constraint c1 : VelocityConstraint {\n      param vFinal : Real = self.finalVelocity;\n      param vInitial : Real = self.initialVelocity;\n      param a : Real = self.acceleration;\n      param dt : Real = self.timeStep;\n      vFinal = vInitial + a * dt;\n    };\n    constraint c2 : PositionConstraint {\n      param pFinal : Real = self.finalPosition;\n      param pInitial : Real = self.initialPosition;\n      param vInitial : Real = self.initialVelocity;\n      param a : Real = self.acceleration;\n      param dt : Real = self.timeStep;\n      pFinal = pInitial + vInitial * dt + 0.5 * a * dt^2;\n    };\n  };\n  block ModelCenterAnalysisTool {\n  };\n  constraint VelocityConstraint {\n    param vFinal : Real;\n    param vInitial : Real;\n    param a : Real;\n    param dt : Real;\n    vFinal = vInitial + a * dt;\n  };\n  constraint PositionConstraint {\n    param pFinal : Real;\n    param pInitial : Real;\n    param vInitial : Real;\n    param a : Real;\n    param dt : Real;\n    pFinal = pInitial + vInitial * dt + 0.5 * a * dt^2;\n  };\n};",
    "package SafetyCompliance {\n  package SafetyFeatures {\n    @Safety class SeatBelts {\n      isMandatory = true\n    }\n\n    @Safety class DriverAirbag {\n      isMandatory = false\n    }\n\n    @Safety class Bumper {\n      isMandatory = true\n    }\n\n    @Safety class AntiLockBrakingSystem {\n      isMandatory = false\n    }\n  } end package\n\n  package MandatorySafetyFeatures {\n    @Safety class SeatBelts {\n      isMandatory = true\n    }\n\n    @Safety class Bumper {\n      isMandatory = true\n    }\n  } end package\n\n  class Car {\n    parts:\n      interior : Interior {\n        parts:\n          seatBelts : SafetyFeatures::SeatBelts [2]\n      },\n      bumper : SafetyFeatures::Bumper,\n      wheelAssembly : WheelAssembly [2] {\n        parts:\n          wheels : Wheel [2],\n          abs : SafetyFeatures::AntiLockBrakingSystem\n      },\n      keylessEntrySystem : KeylessEntrySystem,\n      driverAirbag : SafetyFeatures::DriverAirbag\n  }\n\n  class Wheel {\n  }\n\n  class WheelAssembly {\n    parts:\n      Wheel : Wheel [2],\n      ABS : AntiLockBrakingSystem\n  }\n\n  class Interior {\n    parts:\n      SeatBelts : SeatBelts [2]\n  }\n\n  class KeylessEntrySystem {\n  }\n} end package",
    "model VehicleSafetyComplianceSystem {\n  class Vehicle {\n    part interior: VehicleInterior;\n    part body: VehicleBody;\n    part chassis: Chassis;\n  }\n\n  class VehicleInterior {\n    part seatBelts: SeatBelt [2] «RequiredSafetyFeature»;\n    part driverAirbag: DriverAirbag [0..1] «OptionalSafetyFeature»;\n  }\n\n  class VehicleBody {\n    part bumper: Bumper [1] «RequiredSafetyFeature»;\n    part keylessEntrySystem: KeylessEntrySystem [0..1] «OptionalSafetyFeature»;\n  }\n\n  class Chassis {\n    part tires: Tire [4] «RequiredSafetyFeature»;\n    part abs: AntiLockBrakingSystem [0..1] «OptionalSafetyFeature»;\n  }\n\n  constraint «RequiredSafetyFeature» {\n    // Enforces compliance with mandatory safety standards\n  }\n\n  constraint «OptionalSafetyFeature» {\n    // Supports optional safety configurations\n  }\n}",
    "module RiskManagementModel {\n  class Risk {\n    property probability : Float;\n  }\n  class Failure {\n    property severity : Float;\n  }\n  class Situation {\n    property name : String;\n    property causes : Risk[*];\n    property failures : Failure[*];\n  }\n  class CausalRelationship {\n    property source : Situation;\n    property target : Situation;\n  }\n  class RiskScenario {\n    property name : String;\n    property risks : Risk[*];\n    property failures : Failure[*];\n    property situations : Situation[*];\n    property causalRelationships : CausalRelationship[*];\n  }\n}",
    "model RiskMetadataModel {\n    package RiskMetadataModel {\n        class Scenario {\n            name <String>\n            description <String>\n            causes <List<Cause>>\n            failures <List<Failure>>\n            causalRelationships <List<CausalRelationship>>\n            standardModelReference <String>\n        }\n\n        class Cause {\n            name <String>\n            description <String>\n            probability <Real>\n            scenario <Scenario>\n            standardModelReference <String>\n        }\n\n        class Failure {\n            name <String>\n            description <String>\n            severity <Integer>\n            scenario <Scenario>\n            standardModelReference <String>\n        }\n\n        class CausalRelationship {\n            source <Scenario>\n            target <Scenario>\n            strength <Real>\n            standardModelReference <String>\n        }\n\n        class RiskScenario {\n            name <String>\n            description <String>\n            scenarios <List<Scenario>>\n            causes <List<Cause>>\n            failures <List<Failure>>\n            completeScenario <String>\n            standardModelReference <String>\n        }\n    }\n}",
    "block Equipment {\n  part battery : Battery;\n  part monitoringSystem : BatteryMonitoringSystem;\n}\n\nblock Battery {\n  property level : Float;\n  property age : Integer;\n}\n\nblock BatteryMonitoringSystem {}constraint MinimumBatteryLevelConstraint {\n  check (battery.level > minimumThreshold);\n}constraint LowBatteryLevelConstraint {\n  check (battery.level <= minimumThreshold);\n}constraint BatteryAgingConstraint {\n  check (battery.age > agingThreshold);\n}constraint ProlongedLowBatteryConstraint {\n  check (LowBatteryLevelConstraint and duration > thresholdTime);\n}constraint SeverityLevelConstraint {\n  check (assignSeverityLevel(failureScenario, \"high\"));\n}\n\nrisk BatteryAgingRisk {\n  description: \"Increased probability of battery failure due to aging\";\n}\n\nrisk LowBatteryLevelRisk {\n  description: \"Risk of battery level falling below minimum threshold\";\n}\n\nrisk DeviceShutdownRisk {\n  description: \"Failure consequence of device shutdown due to prolonged low battery\";\n}\n\nfailure scenario LowBatteryLevelFailureScenario {\n  condition: uses LowBatteryLevelConstraint;\n  consequence: equipment enters low battery state;\n}\n\nfailure scenario DeviceShutdownFailureScenario {\n  condition: uses ProlongedLowBatteryConstraint;\n  consequence: device shutdown;\n}\n\nBatteryAgingRisk results in LowBatteryLevelRisk;\nLowBatteryLevelRisk results in DeviceShutdownRisk;\n\nEquipment::monitoringSystem satisfies MinimumBatteryLevelConstraint;\nEquipment::monitoringSystem satisfies LowBatteryLevelConstraint;\nEquipment::monitoringSystem satisfies BatteryAgingConstraint;\n\nLowBatteryLevelFailureScenario satisfies LowBatteryLevelRisk;\nDeviceShutdownFailureScenario satisfies DeviceShutdownRisk;\nDeviceShutdownFailureScenario refines LowBatteryLevelFailureScenario;\n\nDeviceShutdownRisk satisfies SeverityLevelConstraint;\n```",
    "model StructuralDecompositionModel {\n  block System {\n    decompose Subsystems;\n  }\n\n  block Subsystems {\n    part componentA : ComponentA;\n    part componentB : ComponentB;\n    decompose Components;\n  }\n\n  block ComponentA {\n    port dataPort provides DataInterface;\n    port controlPort requires ControlInterface;\n  }\n\n  block ComponentB {\n    port dataPort uses DataInterface;\n    port controlPort provides ControlInterface;\n  }\n\n  interface DataInterface {\n    operation transmitData(data : String);\n    operation receiveData(data : String);\n  }\n\n  interface ControlInterface {\n    operation sendCommand(command : String);\n    operation acknowledgeStatus(status : Boolean);\n  }\n\n  block Components {\n    part subComponentA : SubComponentA;\n    part subComponentB : SubComponentB;\n  }\n\n  block SubComponentA {\n    port interfacePort uses DataInterface;\n  }\n\n  block SubComponentB {\n    port interfacePort provides ControlInterface;\n  }\n}\n```",
    "model AutomotiveSystemModel {\n  stereotype SafetyAttribute {\n    property isMandatory : Boolean;\n    property isOptional : Boolean;\n  }\n\n  block AutomotiveSystemRoot {\n    part chassis : ChassisSubSystem;\n    part powertrain : PowertrainSubSystem;\n    part electrical : ElectricalSubSystem;\n    part body : BodySubSystem;\n  }\n\n  block ChassisSubSystem {\n    part bumper : Bumper;\n    part brakingSystem : BrakingSystem;\n  }\n\n  block BrakingSystem {\n    part abs : ABS;\n  }\n\n  block PowertrainSubSystem {\n    part engine : Engine;\n    part transmission : Transmission;\n  }\n\n  block ElectricalSubSystem {\n    part battery : Battery;\n    part driverAirbag : DriverAirbag;\n  }\n\n  block BodySubSystem {\n    part seatBelt : SeatBelt;\n    part dashboard : Dashboard;\n  }\n\n  interface SafetyInterface;\n\n  block Bumper {\n    port safetyPort : SafetyInterface;\n    apply SafetyAttribute {\n      isMandatory = true;\n    };\n  }\n\n  block ABS {\n    port safetyPort : SafetyInterface;\n    apply SafetyAttribute {\n      isOptional = true;\n    };\n  }\n\n  block SeatBelt {\n    port safetyPort : SafetyInterface;\n    apply SafetyAttribute {\n      isMandatory = true;\n    };\n  }\n\n  block DriverAirbag {\n    port safetyPort : SafetyInterface;\n    apply SafetyAttribute {\n      isOptional = true;\n    };\n  }\n\n  block Engine {\n    port functionalPort : FunctionalInterface;\n  }\n\n  block Transmission {\n    port functionalPort : FunctionalInterface;\n  }\n\n  block Battery {\n    port functionalPort : FunctionalInterface;\n  }\n\n  block Dashboard {\n    port functionalPort : FunctionalInterface;\n  }\n\n  interface FunctionalInterface;\n}",
    "module 汽车 {\n  alias Car for 汽车;\n  /* 核心组件汽车的定义 */\n  element 汽车 {\n    /* 汽车的属性，例如扭矩 */\n    property engineTorque : 扭矩;\n  }\n  element 扭矩 {\n    /* 扭矩是衡量旋转力的物理量，单位为牛·米 (Nm) */\n    property value : Real;\n    property unit : String = \"Nm\";\n  }\n}",
    "model DocumentManagementPlatform {\n  class Automobile {\n    documents : Document[*];\n  }\n  alias Car : Automobile;\n  \n  unit NewtonMeter = SI::Newton * SI::Meter;\n  \n  class Document {\n    text content;\n    appliesTo : Element;\n  }\n  \n  class TorqueValue {\n    value : Real;\n    unit : NewtonMeter;\n  }\n}",
    "model AutomobileSystem {\n  class Automobile {\n    property torque : TorqueValue;\n  }\n  alias Car for Automobile;\n  \n  type TorqueValue = Real { unit: N·m };\n  alias Torque for TorqueValue;\n}",
    "class Cylinder;class Engine {\n  cylinders : Cylinder[*];\n}class Vehicle {\n  engine : Engine;\n  where {\n    engine.cylinders->size() >= 4 and engine.cylinders->size() <= 6;\n  }\n}class SmallVehicle extends Vehicle {\n  where {\n    engine.cylinders->size() = 4;\n  }\n}class LargeVehicle extends Vehicle {\n  where {\n    engine.cylinders->size() = 6;\n  }\n}",
    "model FuelManagementSystemModel {  \n  block FuelInterface {  \n    port fuelSupply : in Fuel;  \n    port fuelReturn : out Fuel;  \n  } constraint StandardizedFuelInterface;  \n\n  block FuelTank {  \n    part interface : FuelInterface [1];  \n  }  \n\n  block Engine {  \n    part interface : FuelInterface [1];  \n  }  \n\n  block FuelManagementSystem {  \n    part tank : FuelTank [1];  \n    part engine : Engine [1];  \n    connector tank.interface -> engine.interface;  \n\n    operation manageFuelFlow() : Boolean;  \n    operation monitorFuelTemperature() : TemperatureStatus;  \n  }  \n\n  block StandardizedFuelInterface {  \n    // No properties or operations needed for this constraint block  \n  }  \n}",
    "model VehicleModel {\n  block Vehicle {\n    property mass : Float { nonNegative }\n    part frontAxleAssembly : AxleAssembly\n    part rearAxleAssembly : AxleAssembly\n  }\n  block AxleAssembly {\n    part axle : Axle\n    part leftWheel : Wheel\n    part rightWheel : Wheel\n  }\n  block Axle {\n  }\n  block FrontAxle {\n    extends Axle\n    property steeringAngle : Float { lowerBound -30 upperBound 30 }\n  }\n  block RearAxle {\n    extends Axle\n  }\n  block Wheel {\n  }\n}"
]