[
    "package 'VehicleSystem' {\n\tattribute def VehicleMass;\n\tattribute def GearSetting;\n\tattribute def AcceleratorPosition;\n\tattribute def Engine;\n\tattribute def Driver;\n\tport def EnginePort {\n\t\tin engine: Engine;\n\t}\n\tport def DriverPort {\n\t\tin driver: Driver;\n\t}\n\tpart context {\n\t\tpart vehicle {\n\t\t\tport enginePort: ~EnginePort;\n\t\t\tport driverPort: ~DriverPort;\n\t\t\tattribute mass: VehicleMass;\n\t\t\tattribute gearSetting: GearSetting;\n\t\t\tattribute acceleratorPosition: AcceleratorPosition;\n\t\t\tperform defineVehicleInfo.setVehicleParameters {\n\t\t\t\tout mass = this.mass;\n\t\t\t\tout gearSetting = this.gearSetting;\n\t\t\t\tout acceleratorPosition = this.acceleratorPosition;\n\t\t\t\tout engine = enginePort.engine;\n\t\t\t\tout driver = driverPort.driver;\n\t\t\t}\n\t\t}\n\t\tinterface vehicleToEngine connect vehicle.enginePort to engineComponent.enginePort {\n\t\t\tref flow references defineVehicleInfo.engineFlow\n\t\t\t\tfrom source.engine to target.engine;\n\t\t}\n\t\tinterface vehicleToDriver connect vehicle.driverPort to driverComponent.driverPort {\n\t\t\tref flow references defineVehicleInfo.driverFlow\n\t\t\t\tfrom source.driver to target.driver;\n\t\t}\n\t\tpart engineComponent {\n\t\t\tport enginePort: EnginePort;\n\t\t\tattribute engine: Engine;\n\t\t}\n\t\tpart driverComponent {\n\t\t\tport driverPort: DriverPort;\n\t\t\tattribute driver: Driver;\n\t\t}\n\t}\n\taction defineVehicleInfo {\n\t\taction setVehicleParameters {\n\t\t\tout mass: VehicleMass;\n\t\t\tout gearSetting: GearSetting;\n\t\t\tout acceleratorPosition: AcceleratorPosition;\n\t\t\tout engine: Engine;\n\t\t\tout driver: Driver;\n\t\t}\n\t\tsuccession flow massFlow from setVehicleParameters.mass to vehicle.mass;\n\t\tsuccession flow gearFlow from setVehicleParameters.gearSetting to vehicle.gearSetting;\n\t\tsuccession flow acceleratorFlow from setVehicleParameters.acceleratorPosition to vehicle.acceleratorPosition;\n\t\tsuccession flow engineFlow from setVehicleParameters.engine to engineComponent.enginePort.engine;\n\t\tsuccession flow driverFlow from setVehicleParameters.driver to driverComponent.driverPort.driver;\n\t}\n}",
    "package 'Vehicles' {\n\tinterface def driverToVehicle;\n\tinterface def engineToVehicle;\n\n\tpart context {\n\t\tpart personnel;\n\t\tpart engine;\n\n\t\tpart manuallyOperatedVehicle {\n\t\t\tport driverPort: driverToVehicle;\n\t\t}\n\t\tinterface driverConnection connect personnel to manuallyOperatedVehicle.driverPort;\n\n\t\tpart poweredVehicle {\n\t\t\tport enginePort: engineToVehicle;\n\t\t}\n\t\tinterface engineConnection connect poweredVehicle.enginePort to engine;\n\n\t\tpart manuallyOperatedPoweredVehicle {\n\t\t\tport driverPort: driverToVehicle;\n\t\t\tport enginePort: engineToVehicle;\n\t\t}\n\t\tinterface driverEngineConnection1 connect personnel to manuallyOperatedPoweredVehicle.driverPort;\n\t\tinterface driverEngineConnection2 connect manuallyOperatedPoweredVehicle.enginePort to engine;\n\t}\n}",
    "package 'VehicleStructure' {\n\tclass VehicleComponent;\n\tclass Engine subClass of VehicleComponent;\n\tclass Transmission subClass of VehicleComponent;\n\tclass Wheel subClass of VehicleComponent;\n\tclass Vehicle;\n\n\tpart context {\n\t\tpart vehicle {\n\t\t\tpart engine : Engine;\n\t\t\tpart transmission : Transmission;\n\t\t\tpart wheels : Wheel [4];\n\t\t}\n\t}\n}",
    "package 'VehicleSystem' {  \n    part SmallVehicle;  \n    part LargeVehicle;  \n    part SmallEngine;  \n    part LargeEngine;  \n    part Cylinder;  \n  \n    part context {  \n        part smallVehicle {  \n            part engine: SmallEngine;  \n        }  \n        part largeVehicle {  \n            part engine: LargeEngine;  \n        }  \n        part smallEngine {  \n            part cylinder: Cylinder [4];  \n        }  \n        part largeEngine {  \n            part cylinder: Cylinder [6];  \n        }  \n    }  \n}",
    "package 'TrafficSignalSystem' {\n\tattribute def ColorState;\n\tport def ColorPort {\n\t\tout color: ColorState;\n\t}\n\tpart context {\n\t\tpart trafficSignal {\n\t\t\tport colorPort: ColorPort;\n\t\t\tperform displayColor.setCurrentColor {\n\t\t\t\tout colorPort.color = currentColor;\n\t\t\t}\n\t\t}\n\t\tpart alwaysGreenSignal {\n\t\t\tport colorPort: ColorPort;\n\t\t\tperform displayColor.setGreen {\n\t\t\t\tout colorPort.color = green;\n\t\t\t}\n\t\t}\n\t}\n\taction displayColor {\n\t\taction setCurrentColor { out currentColor: ColorState; }\n\t\taction setGreen { out green: ColorState; }\n\t}\n}",
    "package 'InformationClassification' {  \n    value type SecurityLevel {  \n        literal uncl {  \n            code = \"uncl\";  \n            color = \"green\";  \n        }  \n        literal conf {  \n            code = \"conf\";  \n            color = \"yellow\";  \n        }  \n        literal secr {  \n            code = \"secr\";  \n            color = \"red\";  \n        }  \n    }  \n\n    value type GradeLevel {  \n        literal A {  \n            points = 4.0;  \n        }  \n        literal B {  \n            points = 3.0;  \n        }  \n        literal C {  \n            points = 2.0;  \n        }  \n        literal D {  \n            points = 1.0;  \n        }  \n        literal F {  \n            points = 0.0;  \n        }  \n    }  \n\n    attribute def SecurityLevelCmd;  \n    attribute def GradeLevelCmd;  \n\n    port def SecurityCmdPort {  \n        out securityLevelCmd : SecurityLevelCmd;  \n    }  \n\n    port def GradeCmdPort {  \n        out gradeLevelCmd : GradeLevelCmd;  \n    }  \n\n    part context {  \n        part user {  \n            port securityCmdPort: SecurityCmdPort;  \n            port gradeCmdPort: GradeCmdPort;  \n            perform classification.assignSecurityLevelCmd {  \n                out securityLevelCmd = securityCmdPort.securityLevelCmd;  \n            }  \n            perform classification.assignGradeLevelCmd {  \n                out gradeLevelCmd = gradeCmdPort.gradeLevelCmd;  \n            }  \n        }  \n\n        interface userToSecurityClassifier connect user.securityCmdPort to securityClassifier.securityCmdPort {  \n            ref flow references classification.securityLevelFlow  \n                from source.securityLevelCmd to target.securityLevelCmd;  \n        }  \n\n        interface userToGradeClassifier connect user.gradeCmdPort to gradeClassifier.gradeCmdPort {  \n            ref flow references classification.gradeLevelFlow  \n                from source.gradeLevelCmd to target.gradeLevelCmd;  \n        }  \n\n        part securityClassifier {  \n            port securityCmdPort: ~SecurityCmdPort;  \n            perform classification.processSecurityLevel {  \n                in securityLevelCmd = securityCmdPort.securityLevelCmd;  \n                out securityLevel = info.securityLevel;  \n            }  \n        }  \n\n        part gradeClassifier {  \n            port gradeCmdPort: ~GradeCmdPort;  \n            perform classification.processGradeLevel {  \n                in gradeLevelCmd = gradeCmdPort.gradeLevelCmd;  \n                out gradeLevel = info.gradeLevel;  \n            }  \n        }  \n\n        part info {  \n            attribute securityLevel: SecurityLevel;  \n            attribute gradeLevel: GradeLevel;  \n        }  \n    }  \n\n    action classification {  \n        action assignSecurityLevelCmd { out securityLevelCmd: SecurityLevelCmd; }  \n        succession flow securityLevelFlow from assignSecurityLevelCmd.securityLevelCmd to processSecurityLevel.securityLevelCmd;  \n        action processSecurityLevel { in securityLevelCmd: SecurityLevelCmd; out securityLevel: SecurityLevel; }  \n\n        action assignGradeLevelCmd { out gradeLevelCmd: GradeLevelCmd; }  \n        succession flow gradeLevelFlow from assignGradeLevelCmd.gradeLevelCmd to processGradeLevel.gradeLevelCmd;  \n        action processGradeLevel { in gradeLevelCmd: GradeLevelCmd; out gradeLevel: GradeLevel; }  \n    }  \n}",
    "package 'VehicleSystem' {\n    part def Vehicle;\n    part def SmallVehicle specializes Vehicle;\n    part def LargeVehicle specializes Vehicle;\n    part def Engine;\n    part def Cylinder;\n    \n    part context {\n        part smallVehicle: SmallVehicle {\n            part engine: Engine {\n                part cylinders [4]: Cylinder;\n            }\n        }\n        part largeVehicle: LargeVehicle {\n            part engine: Engine {\n                part cylinders [6]: Cylinder;\n            }\n        }\n    }\n}",
    "package 'VehicleModeling' {\n\tattribute def QualityAttributes;\n\tattribute def FuelType;\n\tattribute def DriverInfo;\n\tattribute def Personnel;\n\tport def FuelCmdPort {\n\t\tin fuelType : FuelType;\n\t}\n\tport def DriverInfoPort {\n\t\tin driverInfo : DriverInfo;\n\t}\n\tpart context {\n\t\tpart vehicle {\n\t\t\tattribute quality : QualityAttributes;\n\t\t\tpart driverInfo {\n\t\t\t\tport driverInfoPort : DriverInfoPort;\n\t\t\t\tperform defineVehicle.driverInfoAction {\n\t\t\t\t\tout driverInfo = driverInfoPort.driverInfo;\n\t\t\t\t}\n\t\t\t}\n\t\t\tpart fuelTank {\n\t\t\t\tport fuelCmdPort : FuelCmdPort;\n\t\t\t\tperform defineVehicle.fuelTankAction {\n\t\t\t\t\tin fuelType = fuelCmdPort.fuelType;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tinterface vehicleToPersonnel connect vehicle.driverInfo.driverInfoPort to personnel.driverInfoPort {\n\t\t\tref flow references defineVehicle.driverInfoFlow\n\t\t\t\tfrom source.driverInfo to target.driverInfo;\n\t\t}\n\t\tinterface vehicleToFuel connect vehicle.fuelTank.fuelCmdPort to fuel.fuelCmdPort {\n\t\t\tref flow references defineVehicle.fuelTypeFlow\n\t\t\t\tfrom source.fuelType to target.fuelType;\n\t\t}\n\t\tpart personnel {\n\t\t\tport driverInfoPort : ~DriverInfoPort;\n\t\t\tattribute data : Personnel;\n\t\t}\n\t\tpart fuel {\n\t\t\tport fuelCmdPort : ~FuelCmdPort;\n\t\t\tattribute type : FuelType;\n\t\t}\n\t}\n\taction defineVehicle {\n\t\taction driverInfoAction { out driverInfo : DriverInfo; }\n\t\taction fuelTankAction { in fuelType : FuelType; }\n\t\tsuccession flow driverInfoFlow from driverInfoAction.driverInfo to personnel.driverInfo;\n\t\tsuccession flow fuelTypeFlow from fuelTankAction.fuelType to fuel.type;\n\t}\n}",
    "package 'AutomobileWheelAssembly' {\n\tpart context {\n\t\tpart hub {\n\t\t\tpart rim [2];\n\t\t\tpart boltMountingHole [*];\n\t\t\tpart threadedHole [*];\n\t\t}\n\t\tpart tire {\n\t\t\tpart bead [2];\n\t\t}\n\t\tpart wheelBearingUnit;\n\t\tpart boltConnection [*] {\n\t\t\tpart bolt;\n\t\t}\n\t\tinterface beadToRim connect tire.bead to hub.rim;\n\t\tinterface hubMountingHoleToBolt connect hub.boltMountingHole to boltConnection.bolt;\n\t\tinterface boltToThreadedHole connect boltConnection.bolt to hub.threadedHole;\n\t\tinterface wheelBearingToHub connect wheelBearingUnit to hub;\n\t}\n}",
    "package 'FuelFlowManagement' {\n\tattribute def Fuel;\n\tattribute def FuelReturn;\n\tattribute def TemperatureData;\n\tport def FuelSupplyPort {\n\t\tout fuel: Fuel;\n\t}\n\tport def FuelReturnPort {\n\t\tout fuelReturn: FuelReturn;\n\t}\n\tport def TemperaturePort {\n\t\tout temperatureData: TemperatureData;\n\t}\n\tpart context {\n\t\tpart fuelTankAssembly {\n\t\t\tport fuelSupplyPort: FuelSupplyPort;\n\t\t\tport fuelReturnPort: ~FuelReturnPort;\n\t\t\tport temperaturePort: TemperaturePort;\n\t\t\tperform fuelTransfer.supplyFuel {\n\t\t\t\tout fuel = fuelSupplyPort.fuel;\n\t\t\t}\n\t\t\tperform fuelTransfer.receiveReturnFuel {\n\t\t\t\tin fuelReturn = fuelReturnPort.fuelReturn;\n\t\t\t}\n\t\t\tperform fuelTransfer.monitorFuelTankTemperature {\n\t\t\t\tout temperatureData = temperaturePort.temperatureData;\n\t\t\t}\n\t\t}\n\t\tpart engine {\n\t\t\tport fuelSupplyPort: ~FuelSupplyPort;\n\t\t\tport fuelReturnPort: FuelReturnPort;\n\t\t\tport temperaturePort: TemperaturePort;\n\t\t\tperform fuelTransfer.receiveFuel {\n\t\t\t\tin fuel = fuelSupplyPort.fuel;\n\t\t\t}\n\t\t\tperform fuelTransfer.returnExcessFuel {\n\t\t\t\tout fuelReturn = fuelReturnPort.fuelReturn;\n\t\t\t}\n\t\t\tperform fuelTransfer.monitorEngineTemperature {\n\t\t\t\tout temperatureData = temperaturePort.temperatureData;\n\t\t\t}\n\t\t}\n\t\tpart userInterface {\n\t\t\tport fuelSupplyStatusPort: ~FuelSupplyPort;\n\t\t\tport fuelReturnStatusPort: ~FuelReturnPort;\n\t\t\tport fuelTankTempPort: ~TemperaturePort;\n\t\t\tport engineTempPort: ~TemperaturePort;\n\t\t\tperform fuelTransfer.displayFuelData {\n\t\t\t\tin fuel = fuelSupplyStatusPort.fuel;\n\t\t\t\tin fuelReturn = fuelReturnStatusPort.fuelReturn;\n\t\t\t\tin fuelTankTemp = fuelTankTempPort.temperatureData;\n\t\t\t\tin engineTemp = engineTempPort.temperatureData;\n\t\t\t}\n\t\t}\n\t\tinterface fuelSupplyInterface connect fuelTankAssembly.fuelSupplyPort to engine.fuelSupplyPort {\n\t\t\tref flow references fuelTransfer.fuelSupplyFlow from source.fuel to target.fuel;\n\t\t}\n\t\tinterface fuelReturnInterface connect engine.fuelReturnPort to fuelTankAssembly.fuelReturnPort {\n\t\t\tref flow references fuelTransfer.fuelReturnFlow from source.fuelReturn to target.fuelReturn;\n\t\t}\n\t\tinterface fuelTankTempInterface connect fuelTankAssembly.temperaturePort to userInterface.fuelTankTempPort {\n\t\t\tref flow references fuelTransfer.fuelTankTempFlow from source.temperatureData to target.temperatureData;\n\t\t}\n\t\tinterface engineTempInterface connect engine.temperaturePort to userInterface.engineTempPort {\n\t\t\tref flow references fuelTransfer.engineTempFlow from source.temperatureData to target.temperatureData;\n\t\t}\n\t}\n\taction fuelTransfer {\n\t\taction supplyFuel { out fuel: Fuel; }\n\t\tsuccession flow fuelSupplyFlow from supplyFuel.fuel to receiveFuel.fuel;\n\t\taction receiveFuel { in fuel: Fuel; }\n\t\taction returnExcessFuel { out fuelReturn: FuelReturn; }\n\t\tsuccession flow fuelReturnFlow from returnExcessFuel.fuelReturn to receiveReturnFuel.fuelReturn;\n\t\taction receiveReturnFuel { in fuelReturn: FuelReturn; }\n\t\taction monitorFuelTankTemperature { out temperatureData: TemperatureData; }\n\t\tsuccession flow fuelTankTempFlow from monitorFuelTankTemperature.temperatureData to displayFuelData.fuelTankTemp;\n\t\taction monitorEngineTemperature { out temperatureData: TemperatureData; }\n\t\tsuccession flow engineTempFlow from monitorEngineTemperature.temperatureData to displayFuelData.engineTemp;\n\t\taction displayFuelData {\n\t\t\tin fuel: Fuel;\n\t\t\tin fuelReturn: FuelReturn;\n\t\t\tin fuelTankTemp: TemperatureData;\n\t\t\tin engineTemp: TemperatureData;\n\t\t}\n\t}\n}",
    "package 'VehicleConfigurations' {  \n\tattribute def mass : Number;  \n\tattribute def steeringAngle : Number;  \n\n\tpart def Vehicle;  \n\tpart def Axle;  \n\tpart def FrontAxle subtypeof Axle;  \n\tpart def RearAxle subtypeof Axle;  \n\tpart def Tire;  \n\n\tpart context {  \n\t\tpart baseVehicle {  \n\t\t\tattribute mass = 1750;  \n\t\t\tpart frontAxle : FrontAxle;  \n\t\t\tpart rearAxle : RearAxle;  \n\t\t}  \n\t\tpart frontAxle {  \n\t\t\tattribute mass = 200;  \n\t\t\tpart tires[2] : Tire;  \n\t\t}  \n\t\tpart rearAxle {  \n\t\t\tattribute mass = 200;  \n\t\t\tpart tires[2] : Tire;  \n\t\t}  \n\t\tpart tire {  \n\t\t\tattribute mass = 25;  \n\t\t}  \n\t}  \n\n\tpart context 'vehicle1_c1' {  \n\t\textend baseVehicle;  \n\t\tattribute mass = 2000;  \n\t\tpart dedicatedFrontAxle : ~FrontAxle {  \n\t\t\tattribute steeringAngle = 30;  \n\t\t\tattribute mass = 250;  \n\t\t} insteadof baseVehicle.frontAxle;  \n\t\tpart rearAxle {  \n\t\t\tattribute mass = 220;  \n\t\t\tpart tires[2] : Tire;  \n\t\t}  \n\t\tpart tire {  \n\t\t\tattribute mass = 30;  \n\t\t}  \n\t}  \n}",
    "package 'VehicleTrailerCoupling' {\n\tattribute def CouplingBall;\n\tattribute def TrailerConnector;\n\tport def CouplingPort {\n\t\tout couplingBall: CouplingBall;\n\t}\n\tport def TrailerPort {\n\t\tout trailerConnector: TrailerConnector;\n\t}\n\tpart context {\n\t\tpart vehicle {\n\t\t\tport couplingPort: ~CouplingPort;\n\t\t\tperform connectToHitch.attachVehicle {\n\t\t\t\tref couplingBall = couplingPort.couplingBall;\n\t\t\t}\n\t\t\tperform disconnectFromHitch.detachVehicle {\n\t\t\t\tunref couplingBall;\n\t\t\t}\n\t\t}\n\t\tpart hitch {\n\t\t\tpart couplingBall: CouplingBall;\n\t\t\tpart trailerConnector: TrailerConnector;\n\t\t\tport couplingPort: CouplingPort {\n\t\t\t\tout couplingBall = this.couplingBall;\n\t\t\t}\n\t\t\tport trailerPort: TrailerPort {\n\t\t\t\tout trailerConnector = this.trailerConnector;\n\t\t\t}\n\t\t}\n\t\tpart trailer {\n\t\t\tport trailerPort: ~TrailerPort;\n\t\t\tperform connectToHitch.attachTrailer {\n\t\t\t\tref trailerConnector = trailerPort.trailerConnector;\n\t\t\t}\n\t\t\tperform disconnectFromHitch.detachTrailer {\n\t\t\t\tunref trailerConnector;\n\t\t\t}\n\t\t}\n\t\tinterface vehicleToHitch connect vehicle.couplingPort to hitch.couplingPort {\n\t\t\tref flow references connectToHitch.attachVehicle.couplingBall;\n\t\t\tref flow references disconnectFromHitch.detachVehicle.couplingBall;\n\t\t}\n\t\tinterface trailerToHitch connect trailer.trailerPort to hitch.trailerPort {\n\t\t\tref flow references connectToHitch.attachTrailer.trailerConnector;\n\t\t\tref flow references disconnectFromHitch.detachTrailer.trailerConnector;\n\t\t}\n\t}\n\taction connectToHitch {\n\t\taction attachVehicle { ref couplingBall: CouplingBall; }\n\t\taction attachTrailer { ref trailerConnector: TrailerConnector; }\n\t}\n\taction disconnectFromHitch {\n\t\taction detachVehicle { unref couplingBall: CouplingBall; }\n\t\taction detachTrailer { unref trailerConnector: TrailerConnector; }\n\t}\n}",
    "package 'VehiclePowerTransmission' {\n\tattribute def FuelCmd;\n\tattribute def Power;\n\tattribute def ClutchSignal;\n\tattribute def DriveshaftPower;\n\tattribute def Torque;\n\tport def FuelCmdPort {\n\t\tout fuelCmd : FuelCmd;\n\t}\n\tport def PowerPort {\n\t\tout power : Power;\n\t}\n\tport def ClutchPort {\n\t\tout clutch : ClutchSignal;\n\t}\n\tport def DriveshaftPowerPort {\n\t\tout driveshaftPower : DriveshaftPower;\n\t}\n\tport def DifferentialPort {\n\t\tout power : Power;\n\t}\n\tport def HalfShaftPowerPort {\n\t\tout shaftPower : DriveshaftPower;\n\t}\n\tport def RoadInterfacePort {\n\t\tout torque : Torque;\n\t}\n\tpart context {\n\t\tpart user {\n\t\t\tport fuelCmdPort: FuelCmdPort;\n\t\t\tperform powerTransmissionAction.sendFuelCmd {\n\t\t\t\tout fuelCmd = fuelCmdPort.fuelCmd;\n\t\t\t}\n\t\t}\n\t\tinterface userToEngine connect user.fuelCmdPort to engine.fuelCmdPort {\n\t\t\tref flow references powerTransmissionAction.fuelCmdFlow from source.fuelCmd to target.fuelCmd;\n\t\t}\n\t\tpart engine {\n\t\t\tport fuelCmdPort: ~FuelCmdPort;\n\t\t\tport powerPort: PowerPort;\n\t\t\tport clutchPort: ClutchPort;\n\t\t\tperform powerTransmissionAction.produceEnginePower {\n\t\t\t\tin fuelCmd = fuelCmdPort.fuelCmd;\n\t\t\t\tout power = powerPort.power;\n\t\t\t\tout clutch = clutchPort.clutch;\n\t\t\t}\n\t\t}\n\t\tpart transmission {\n\t\t\tport enginePowerPort: ~PowerPort;\n\t\t\tport clutchPort: ~ClutchPort;\n\t\t\tport driveshaftPowerPort: DriveshaftPowerPort;\n\t\t\tperform powerTransmissionAction.transmitPower {\n\t\t\t\tin power = enginePowerPort.power;\n\t\t\t\tin clutch = clutchPort.clutch;\n\t\t\t\tout driveshaftPower = driveshaftPowerPort.driveshaftPower;\n\t\t\t}\n\t\t}\n\t\tinterface engineToTransmission connect engine.powerPort to transmission.enginePowerPort {\n\t\t\tref flow references powerTransmissionAction.powerFlow from source.power to target.power;\n\t\t}\n\t\tinterface engineToTransmissionClutch connect engine.clutchPort to transmission.clutchPort {\n\t\t\tref flow references powerTransmissionAction.clutchFlow from source.clutch to target.clutch;\n\t\t}\n\t\tpart driveshaft {\n\t\t\tport inputPort: ~DriveshaftPowerPort;\n\t\t\tport outputPort: DriveshaftPowerPort;\n\t\t\tperform powerTransmissionAction.transmitDriveshaftPower {\n\t\t\t\tin power = inputPort.driveshaftPower;\n\t\t\t\tout driveshaftPower = outputPort.driveshaftPower;\n\t\t\t}\n\t\t}\n\t\tinterface transmissionToDriveshaft connect transmission.driveshaftPowerPort to driveshaft.inputPort {\n\t\t\tref flow references powerTransmissionAction.driveshaftPowerFlow from source.driveshaftPower to target.driveshaftPower;\n\t\t}\n\t\tpart rearAxleAssembly {\n\t\t\tport inputPort: ~DriveshaftPowerPort;\n\t\t\tpart differential {\n\t\t\t\tport input: DriveshaftPowerPort;\n\t\t\t\tport leftOutput: DifferentialPort;\n\t\t\t\tport rightOutput: DifferentialPort;\n\t\t\t\tperform powerTransmissionAction.splitPower {\n\t\t\t\t\tin power = input.driveshaftPower;\n\t\t\t\t\tout left = leftOutput.power;\n\t\t\t\t\tout right = rightOutput.power;\n\t\t\t\t}\n\t\t\t}\n\t\t\tinterface rearAxleInput to inputPort: DriveshaftPowerPort {\n\t\t\t\tref flow references powerTransmissionAction.rearAxleInputFlow from source.driveshaftPower to target.driveshaftPower;\n\t\t\t}\n\t\t\tinterface differentialInput connect rearAxleAssembly.inputPort to differential.input {\n\t\t\t\tref flow references powerTransmissionAction.differentialInputFlow from source.driveshaftPower to target.driveshaftPower;\n\t\t\t}\n\t\t\tpart leftHalfShaft {\n\t\t\t\tport input: ~DifferentialPort;\n\t\t\t\tport output: HalfShaftPowerPort;\n\t\t\t\tperform powerTransmissionAction.leftHalfShaftTransfer {\n\t\t\t\t\tin power = input.power;\n\t\t\t\t\tout shaftPower = output.shaftPower;\n\t\t\t\t}\n\t\t\t}\n\t\t\tinterface differentialToLeft connect differential.leftOutput to leftHalfShaft.input {\n\t\t\t\tref flow references powerTransmissionAction.differentialLeftFlow from source.power to target.power;\n\t\t\t}\n\t\t\tpart rightHalfShaft {\n\t\t\t\tport input: ~DifferentialPort;\n\t\t\t\tport output: HalfShaftPowerPort;\n\t\t\t\tperform powerTransmissionAction.rightHalfShaftTransfer {\n\t\t\t\t\tin power = input.power;\n\t\t\t\t\tout shaftPower = output.shaftPower;\n\t\t\t\t}\n\t\t\t}\n\t\t\tinterface differentialToRight connect differential.rightOutput to rightHalfShaft.input {\n\t\t\t\tref flow references powerTransmissionAction.differentialRightFlow from source.power to target.power;\n\t\t\t}\n\t\t}\n\t\tinterface driveshaftToRearAxle connect driveshaft.outputPort to rearAxleAssembly.inputPort {\n\t\t\tref flow references powerTransmission.drivetoshaftFlow from source.driveshaftPower to target.driveshaftPower;\n\t\t}\n\t\tpart leftWheel {\n\t\t\tport shaftInput: ~HalfShaftPowerPort;\n\t\t\tport roadPort: RoadInterfacePort;\n\t\t\tperform powerTransmissionAction.leftWheelAction {\n\t\t\t\tin power = shaftInput.shaftPower;\n\t\t\t\tout torque = roadPort.torque;\n\t\t\t}\n\t\t}\n\t\tinterface leftHalfShaftToWheel connect leftHalfShaft.output to leftWheel.shaftInput {\n\t\t\tref flow references powerTransmissionAction.leftShaftToWheelFlow from source.shaftPower to target.shaftPower;\n\t\t}\n\t\tinterface leftWheelToRoad connect leftWheel.roadPort to road.roadInterfacePort {\n\t\t\tref flow references powerTransmissionAction.leftWheelToRoadFlow from source.torque to target.torque;\n\t\t}\n\t\tpart rightWheel {\n\t\t\tport shaftInput: ~HalfShaftPowerPort;\n\t\t\tport roadPort: RoadInterfacePort;\n\t\t\tperform powerTransmissionAction.rightWheelAction {\n\t\t\t\tin power = shaftInput.shaftPower;\n\t\t\t\tout torque = roadPort.torque;\n\t\t\t}\n\t\t}\n\t\tinterface rightHalfShaftToWheel connect rightHalfShaft.output to rightWheel.shaftInput {\n\t\t\tref flow references powerTransmissionAction.rightShaftToWheelFlow from source.shaftPower to target.shaftPower;\n\t\t}\n\t\tinterface rightWheelToRoad connect rightWheel.roadPort to road.roadInterfacePort {\n\t\t\tref flow references powerTransmissionAction.rightWheelToRoadFlow from source.torque to target.torque;\n\t\t}\n\t\tpart road {\n\t\t\tport roadInterfacePort: RoadInterfacePort;\n\t\t}\n\t}\n\taction powerTransmissionAction {\n\t\taction sendFuelCmd { out fuelCmd: FuelCmd; }\n\t\tsuccession flow fuelCmdFlow from sendFuelCmd.fuelCmd to produceEnginePower.fuelCmd;\n\t\taction produceEnginePower { in fuelCmd; out power: Power; out clutch: ClutchSignal; }\n\t\tsuccession flow powerFlow from produceEnginePower.power to transmitPower.power;\n\t\tsuccession flow clutchFlow from produceEnginePower.clutch to transmitPower.clutch;\n\t\taction transmitPower { in power: Power; in clutch: ClutchSignal; out driveshaftPower: DriveshaftPower; }\n\t\tsuccession flow driveshaftPowerFlow from transmitPower.driveshaftPower to transmitDriveshaftPower.driveshaftPower;\n\t\taction transmitDriveshaftPower { in driveshaftPower: DriveshaftPower; out driveshaftPower: DriveshaftPower; }\n\t\tsuccession flow driveshaftToRearAxleFlow from transmitDriveshaftPower.driveshaftPower to splitPower.power;\n\t\taction splitPower { in power: DriveshaftPower; out left: Power; out right: Power; }\n\t\tsuccession flow differentialLeftFlow from splitPower.left to distributePower.power;\n\t\taction distributePower { in power: Power; out left: Power; out right: Power; }\n\t\tsuccession flow leftShaftToWheelFlow from distributePower.left to leftWheelAction.power;\n\t\taction leftWheelAction { in power: Power; out torque: Torque; }\n\t\tsuccession flow leftWheelToRoadFlow from leftWheelAction.torque to roadInterfaceLeft.torque;\n\t\taction rightWheelAction { in power: Power; out torque: Torque; }\n\t\tsuccession flow rightWheelToRoadFlow from rightWheelAction.torque to roadInterfaceRight.torque;\n\t}\n}",
    "package 'MultiArchitectureSystem' {\n\tattribute def Signal;\n\tport def PortC1_pb {\n\t\tout signal : Signal;\n\t}\n\tport def PortC2_pa {\n\t\tin signal : Signal;\n\t}\n\tport def PortC3_pd {\n\t\tout signal : Signal;\n\t}\n\tport def PortC4_pc {\n\t\tin signal : Signal;\n\t}\n\tpart context {\n\t\tpart b11 {\n\t\t\tpart c1 {\n\t\t\t\tport pb : PortC1_pb;\n\t\t\t\tperform sendSignalB11 {\n\t\t\t\t\tout signal = pb.signal;\n\t\t\t\t}\n\t\t\t}\n\t\t\tpart c2 {\n\t\t\t\tport pa : PortC2_pa;\n\t\t\t\tperform receiveSignalB11 {\n\t\t\t\t\tin signal = pa.signal;\n\t\t\t\t}\n\t\t\t}\n\t\t\tinterface pe connect c1.pb to c2.pa {\n\t\t\t\tref flow references b11.signalFlow from source.signal to target.signal;\n\t\t\t}\n\t\t}\n\t\tpart b12 {\n\t\t\tpart c3 {\n\t\t\t\tport pd : PortC3_pd;\n\t\t\t\tperform sendSignalB12 {\n\t\t\t\t\tout signal = pd.signal;\n\t\t\t\t}\n\t\t\t}\n\t\t\tpart c4 {\n\t\t\t\tport pc : PortC4_pc;\n\t\t\t\tperform receiveSignalB12 {\n\t\t\t\t\tin signal = pc.signal;\n\t\t\t\t}\n\t\t\t}\n\t\t\tinterface pf connect c3.pd to c4.pc {\n\t\t\t\tref flow references b12.signalFlow from source.signal to target.signal;\n\t\t\t}\n\t\t}\n\t\tinterface systemInterface connect b11.pe to b12.pf {\n\t\t\tref flow references systemFlow from source.signal to target.signal;\n\t\t}\n\t}\n\tpart context {\n\t\tpart b21 {\n\t\t\tpart c1 : ~b11.c1;\n\t\t\tpart c2 : ~b11.c2;\n\t\t\tpart c3 : ~b12.c3;\n\t\t\tpart c4 : ~b12.c4;\n\t\t\tperform reorganizeB21 {\n\t\t\t\tout signal = c1.pb.signal;\n\t\t\t\tin signal = c3.pd.signal;\n\t\t\t}\n\t\t}\n\t\tpart b22 {\n\t\t\tpart c1 : ~b11.c1;\n\t\t\tpart c2 : ~b11.c2;\n\t\t\tpart c3 : ~b12.c3;\n\t\t\tpart c4 : ~b12.c4;\n\t\t\tperform reorganizeB22 {\n\t\t\t\tout signal = c2.pa.signal;\n\t\t\t\tin signal = c4.pc.signal;\n\t\t\t}\n\t\t}\n\t}\n\taction system {\n\t\taction sendSignalB11 { out signal : Signal; }\n\t\tsuccession flow signalFlow from sendSignalB11.signal to receiveSignalB11.signal;\n\t\taction receiveSignalB11 { in signal : Signal; }\n\t\taction sendSignalB12 { out signal : Signal; }\n\t\tsuccession flow signalFlow from sendSignalB12.signal to receiveSignalB12.signal;\n\t\taction receiveSignalB12 { in signal : Signal; }\n\t\tsuccession flow systemFlow from sendSignalB11.signal to sendSignalB12.signal;\n\t\taction reorganizeB21 { out signal : Signal; in signal : Signal; }\n\t\tsuccession flow b21Flow from reorganizeB21.signal to reorganizeB22.signal;\n\t\taction reorganizeB22 { in signal : Signal; out signal : Signal; }\n\t}\n}",
    "package 'AutomotivePowertrain' {  \n\tattribute def FuelCmd;  \n\tattribute def EngineState;  \n\tattribute def EngineTorque;  \n\tattribute def TransmissionTorque;  \n\tattribute def DriveshaftTorque;  \n\tattribute def WheelTorque;  \n\tattribute def ShutdownCmd;  \n\n\tport def FuelCmdPort {  \n\t\tout fuelCmd : FuelCmd;  \n\t}  \n\tport def EngineStatePort {  \n\t\tout engineState : EngineState;  \n\t}  \n\tport def TorquePort {  \n\t\tout torque : EngineTorque;  \n\t}  \n\tport def TransmissionInputPort {  \n\t\tin torque : EngineTorque;  \n\t}  \n\tport def TransmissionOutputPort {  \n\t\tout torque : TransmissionTorque;  \n\t}  \n\tport def DriveshaftInputPort {  \n\t\tin torque : TransmissionTorque;  \n\t}  \n\tport def DriveshaftOutputPort {  \n\t\tout torque : DriveshaftTorque;  \n\t}  \n\tport def WheelInputPort {  \n\t\tin torque : DriveshaftTorque;  \n\t}  \n\tport def ShutdownCmdPort {  \n\t\tout shutdownCmd : ShutdownCmd;  \n\t}  \n\n\tpart context {  \n\t\tpart user {  \n\t\t\tport fuelCmdPort: FuelCmdPort;  \n\t\t\tport shutdownCmdPort: ShutdownCmdPort;  \n\t\t\tperform controlPower.sendFuelCmd {  \n\t\t\t\tout fuelCmd = fuelCmdPort.fuelCmd;  \n\t\t\t}  \n\t\t\tperform controlPower.sendShutdownCmd {  \n\t\t\t\tout shutdownCmd = shutdownCmdPort.shutdownCmd;  \n\t\t\t}  \n\t\t}  \n\t\tinterface userToEngine connect user.fuelCmdPort to engine.fuelCmdPort {  \n\t\t\tref flow references controlPower.fuelCmdFlow  \n\t\t\t\tfrom source.fuelCmd to target.fuelCmd;  \n\t\t}  \n\t\tinterface userToEngineShutdown connect user.shutdownCmdPort to engine.shutdownCmdPort {  \n\t\t\tref flow references controlPower.shutdownFlow  \n\t\t\t\tfrom source.shutdownCmd to target.shutdownCmd;  \n\t\t}  \n\n\t\tpart engine {  \n\t\t\tport fuelCmdPort: ~FuelCmdPort;  \n\t\t\tport shutdownCmdPort: ~ShutdownCmdPort;  \n\t\t\tport engineStatePort: EngineStatePort;  \n\t\t\tport torquePort: TorquePort;  \n\t\t\tperform controlPower.generateEngineTorque {  \n\t\t\t\tin fuelCmd = fuelCmdPort.fuelCmd;  \n\t\t\t\tin shutdownCmd = shutdownCmdPort.shutdownCmd;  \n\t\t\t\tout engineState = engineStatePort.engineState;  \n\t\t\t\tout torque = torquePort.torque;  \n\t\t\t}  \n\t\t}  \n\n\t\tpart transmission {  \n\t\t\tport fuelCmdPort: FuelCmdPort;  \n\t\t\tport engineStatePort: ~EngineStatePort;  \n\t\t\tport transmissionInputPort: ~TransmissionInputPort;  \n\t\t\tport transmissionOutputPort: TransmissionOutputPort;  \n\t\t\tperform controlPower.amplifyTorque {  \n\t\t\t\tin fuelCmd = fuelCmdPort.fuelCmd;  \n\t\t\t\tin engineState = engineStatePort.engineState;  \n\t\t\t\tin torque = transmissionInputPort.torque;  \n\t\t\t\tout torque = transmissionOutputPort.torque;  \n\t\t\t}  \n\t\t}  \n\n\t\tinterface engineToTransmission connect engine.torquePort to transmission.transmissionInputPort {  \n\t\t\tref flow references controlPower.torqueFlow1  \n\t\t\t\tfrom source.torque to target.torque;  \n\t\t}  \n\t\tinterface engineToTransmissionState connect engine.engineStatePort to transmission.engineStatePort {  \n\t\t\tref flow references controlPower.stateFlow  \n\t\t\t\tfrom source.engineState to target.engineState;  \n\t\t}  \n\t\tinterface engineToTransmissionCmd connect user.fuelCmdPort to transmission.fuelCmdPort {  \n\t\t\tref flow references controlPower.fuelCmdFlow  \n\t\t\t\tfrom source.fuelCmd to target.fuelCmd;  \n\t\t}  \n\n\t\tpart driveshaft {  \n\t\t\tport transmissionInputPort: ~TransmissionOutputPort;  \n\t\t\tport driveshaftOutputPort: DriveshaftOutputPort;  \n\t\t\tperform controlPower.transmitTorque {  \n\t\t\t\tin torque = transmissionInputPort.torque;  \n\t\t\t\tout torque = driveshaftOutputPort.torque;  \n\t\t\t}  \n\t\t}  \n\t\tinterface transmissionToDriveshaft connect transmission.transmissionOutputPort to driveshaft.transmissionInputPort {  \n\t\t\tref flow references controlPower.torqueFlow2  \n\t\t\t\tfrom source.torque to target.torque;  \n\t\t}  \n\n\t\tpart leftWheel {  \n\t\t\tport wheelInputPort: ~DriveshaftOutputPort;  \n\t\t\tperform controlPower.distributeTorque {  \n\t\t\t\tin torque = wheelInputPort.torque;  \n\t\t\t\tout wheelTorque = wheelInputPort.torque;  \n\t\t\t}  \n\t\t}  \n\t\tinterface driveshaftToLeftWheel connect driveshaft.driveshaftOutputPort to leftWheel.wheelInputPort {  \n\t\t\tref flow references controlPower.torqueFlow3  \n\t\t\t\tfrom source.torque to target.torque;  \n\t\t}  \n\n\t\tpart rightWheel {  \n\t\t\tport wheelInputPort: ~DriveshaftOutputPort;  \n\t\t\tperform controlPower.distributeTorque {  \n\t\t\t\tin torque = wheelInputPort.torque;  \n\t\t\t\tout wheelTorque = wheelInputPort.torque;  \n\t\t\t}  \n\t\t}  \n\t\tinterface driveshaftToRightWheel connect driveshaft.driveshaftOutputPort to rightWheel.wheelInputPort {  \n\t\t\tref flow references controlPower.torqueFlow3  \n\t\t\t\tfrom source.torque to target.torque;  \n\t\t}  \n\t}  \n\n\taction controlPower {  \n\t\taction sendFuelCmd { out fuelCmd: FuelCmd; }  \n\t\taction sendShutdownCmd { out shutdownCmd: ShutdownCmd; }  \n\t\tsuccession flow shutdownFlow from sendShutdownCmd.shutdownCmd to generateEngineTorque.shutdownCmd;  \n\t\tsuccession flow fuelCmdFlow from sendFuelCmd.fuelCmd to generateEngineTorque.fuelCmd;  \n\t\tsuccession flow fuelCmdFlow to amplifyTorque.fuelCmd;  \n\n\t\taction generateEngineTorque {  \n\t\t\tin fuelCmd: FuelCmd;  \n\t\t\tin shutdownCmd: ShutdownCmd;  \n\t\t\tout engineState: EngineState;  \n\t\t\tout torque: EngineTorque;  \n\t\t}  \n\t\tsuccession flow stateFlow from generateEngineTorque.engineState to amplifyTorque.engineState;  \n\t\tsuccession flow torqueFlow1 from generateEngineTorque.torque to amplifyTorque.torque;  \n\n\t\taction amplifyTorque {  \n\t\t\tin fuelCmd: FuelCmd;  \n\t\t\tin engineState: EngineState;  \n\t\t\tin torque: EngineTorque;  \n\t\t\tout torque: TransmissionTorque;  \n\t\t}  \n\t\tsuccession flow torqueFlow2 from amplifyTorque.torque to transmitTorque.torque;  \n\n\t\taction transmitTorque {  \n\t\t\tin torque: TransmissionTorque;  \n\t\t\tout torque: DriveshaftTorque;  \n\t\t}  \n\t\tsuccession flow torqueFlow3 from transmitTorque.torque to distributeTorque.torque;  \n\n\t\taction distributeTorque {  \n\t\t\tin torque: DriveshaftTorque;  \n\t\t\tout wheelTorque: WheelTorque;  \n\t\t}  \n\t}  \n}",
    "package 'AutomotivePowertrain' {\n\tattribute def FuelControlCmd;\n\tattribute def EngineControlCmd;\n\tattribute def StallSignal;\n\tattribute def Torque;\n\tattribute def AmplifiedTorque;\n\tattribute def TransmittedTorque;\n\tattribute def DistributedTorque;\n\tattribute def WheelTorque;\n\n\tport def FuelCmdPort {\n\t\tout fuelCmd : FuelControlCmd;\n\t}\n\tport def EngineControlPort {\n\t\tout engineControlCmd : EngineControlCmd;\n\t}\n\tport def StallSignalPort {\n\t\tin stallSignal : StallSignal;\n\t}\n\tport def WheelTorquePort {\n\t\tout wheelTorque : WheelTorque;\n\t}\n\n\tpart context {\n\t\tpart user {\n\t\t\tport fuelCmdPort: FuelCmdPort;\n\t\t\tperform powertrainControl.sendFuelCmd {\n\t\t\t\tout fuelCmd = fuelCmdPort.fuelCmd;\n\t\t\t}\n\t\t\tport engineControlPort: EngineControlPort;\n\t\t\tperform powertrainControl.sendEngineControlCmd {\n\t\t\t\tout engineControlCmd = engineControlPort.engineControlCmd;\n\t\t\t}\n\t\t}\n\t\tinterface userToPowertrain connect user.fuelCmdPort to powertrain.fuelCmdPort {\n\t\t\tref flow references powertrainControl.fuelCmdFlow\n\t\t\t\tfrom source.fuelCmd to target.fuelCmd;\n\t\t}\n\t\tinterface userToPowertrain2 connect user.engineControlPort to powertrain.engineControlPort {\n\t\t\tref flow references powertrainControl.engineControlFlow\n\t\t\t\tfrom source.engineControlCmd to target.engineControlCmd;\n\t\t}\n\t\tpart powertrain {\n\t\t\tport fuelCmdPort: ~FuelCmdPort;\n\t\t\tport engineControlPort: ~EngineControlPort;\n\t\t\tport stallSignalPort: ~StallSignalPort;\n\t\t\tport wheelTorquePort: WheelTorquePort;\n\t\t\tperform powertrainControl.receiveFuelCmd {\n\t\t\t\tin fuelCmd = fuelCmdPort.fuelCmd;\n\t\t\t}\n\t\t\tperform powertrainControl.receiveEngineControlCmd {\n\t\t\t\tin engineControlCmd = engineControlPort.engineControlCmd;\n\t\t\t}\n\t\t\tperform powertrainControl.startEngine {\n\t\t\t\tin fuelCmd = receiveFuelCmd.fuelCmd;\n\t\t\t\tin engineControlCmd = receiveEngineControlCmd.engineControlCmd;\n\t\t\t\tout torque = generateTorque.torque;\n\t\t\t}\n\t\t\tperform powertrainControl.generateTorque {\n\t\t\t\tin torqueInput = startEngine.torque;\n\t\t\t\tout torqueOutput = amplifyTorque.torque;\n\t\t\t}\n\t\t\tperform powertrainControl.amplifyTorque {\n\t\t\t\tin torque = generateTorque.torqueOutput;\n\t\t\t\tout amplified = transmitTorque.amplified;\n\t\t\t}\n\t\t\tperform powertrainControl.transmitTorque {\n\t\t\t\tin amplified = amplifyTorque.amplified;\n\t\t\t\tout transmitted = distributeTorque.transmitted;\n\t\t\t}\n\t\t\tperform powertrainControl.distributeTorque {\n\t\t\t\tin transmitted = transmitTorque.transmitted;\n\t\t\t\tout distributed = deliverToWheels.distributed;\n\t\t\t}\n\t\t\tperform powertrainControl.deliverToWheels {\n\t\t\t\tin distributed = distributeTorque.distributed;\n\t\t\t\tout wheelTorque = wheelTorquePort.wheelTorque;\n\t\t\t}\n\t\t\tperform powertrainControl.detectStall {\n\t\t\t\tin stallSignal = stallSignalPort.stallSignal;\n\t\t\t}\n\t\t\tperform powertrainControl.haltProcesses {\n\t\t\t\tin stallSignal = detectStall.stallSignal;\n\t\t\t}\n\t\t}\n\t}\n\taction powertrainControl {\n\t\taction sendFuelCmd { out fuelCmd: FuelControlCmd; }\n\t\taction receiveFuelCmd { in fuelCmd: FuelControlCmd; }\n\t\tsuccession flow fuelCmdFlow from sendFuelCmd.fuelCmd to receiveFuelCmd.fuelCmd;\n\t\taction sendEngineControlCmd { out engineControlCmd: EngineControlCmd; }\n\t\taction receiveEngineControlCmd { in engineControlCmd: EngineControlCmd; }\n\t\tsuccession flow engineControlFlow from sendEngineControlCmd.engineControlCmd to receiveEngineControlCmd.engineControlCmd;\n\t\taction startEngine { in fuelCmd: FuelControlCmd; in engineControlCmd: EngineControlCmd; out torque: Torque; }\n\t\tsuccession flow startEngineFlow from receiveFuelCmd.fuelCmd to startEngine.fuelCmd;\n\t\tsuccession flow engineControlToStart from receiveEngineControlCmd.engineControlCmd to startEngine.engineControlCmd;\n\t\taction generateTorque { in torqueInput: Torque; out torqueOutput: Torque; }\n\t\tsuccession flow generateTorqueFlow from startEngine.torque to generateTorque.torqueInput;\n\t\taction amplifyTorque { in torque: Torque; out amplified: AmplifiedTorque; }\n\t\tsuccession flow amplifyFlow from generateTorque.torqueOutput to amplifyTorque.torque;\n\t\taction transmitTorque { in amplified: AmplifiedTorque; out transmitted: TransmittedTorque; }\n\t\tsuccession flow transmitFlow from amplifyTorque.amplified to transmitTorque.amplified;\n\t\taction distributeTorque { in transmitted: TransmittedTorque; out distributed: DistributedTorque; }\n\t\tsuccession flow distributeFlow from transmitTorque.transmitted to distributeTorque.transmitted;\n\t\taction deliverToWheels { in distributed: DistributedTorque; out wheelTorque: WheelTorque; }\n\t\tsuccession flow deliverFlow from distributeTorque.distributed to deliverToWheels.distributed;\n\t\taction detectStall { in stallSignal: StallSignal; }\n\t\tsuccession flow stallSignalFlow from detectStall.stallSignal to haltProcesses.stallSignal;\n\t\taction haltProcesses { in stallSignal: StallSignal; }\n\t}\n}",
    "package 'VehiclePowertrain' {\n\tattribute def FuelCmd;\n\tattribute def EngineStartSignal;\n\tattribute def EngineStopSignal;\n\tattribute def EngineOutputTorque;\n\tattribute def AmplifiedTorque;\n\tattribute def WheelTorque;\n\tport def FuelCmdPort {\n\t\tout fuelCmd : FuelCmd;\n\t}\n\tport def EngineStartPort {\n\t\tout engineStartSignal : EngineStartSignal;\n\t}\n\tport def EngineStopPort {\n\t\tout engineStopSignal : EngineStopSignal;\n\t}\n\tport def EngineOutputPort {\n\t\tout engineOutputTorque : EngineOutputTorque;\n\t}\n\tport def TransmissionInputPort {\n\t\tin engineOutputTorque : EngineOutputTorque;\n\t}\n\tport def TransmissionOutputPort {\n\t\tout transmissionOutputTorque : AmplifiedTorque;\n\t}\n\tport def WheelInputPort {\n\t\tin wheelTorque : WheelTorque;\n\t}\n\tpart context {\n\t\tpart driver {\n\t\t\tport fuelCmdPort: FuelCmdPort;\n\t\t\tport engineStartPort: EngineStartPort;\n\t\t\tport engineStopPort: EngineStopPort;\n\t\t\tperform powertrainControl.sendFuelCmd {\n\t\t\t\tout fuelCmd = fuelCmdPort.fuelCmd;\n\t\t\t}\n\t\t\tperform powertrainControl.sendEngineStart {\n\t\t\t\tout engineStartSignal = engineStartPort.engineStartSignal;\n\t\t\t}\n\t\t\tperform powertrainControl.sendEngineStop {\n\t\t\t\tout engineStopSignal = engineStopPort.engineStopSignal;\n\t\t\t}\n\t\t}\n\t\tinterface driverToEngine connect driver.fuelCmdPort to engine.fuelCmdPort {\n\t\t\tref flow powertrainControl.fuelCmdFlow\n\t\t\t\tfrom source.fuelCmd to target.fuelCmd;\n\t\t}\n\t\tinterface driverToEngineStart connect driver.engineStartPort to engine.engineStartPort {\n\t\t\tref flow powertrainControl.startSignalFlow\n\t\t\t\tfrom source.engineStartSignal to target.engineStartSignal;\n\t\t}\n\t\tinterface driverToEngineStop connect driver.engineStopPort to engine.engineStopPort {\n\t\t\tref flow powertrainControl.stopSignalFlow\n\t\t\t\tfrom source.engineStopSignal to target.engineStopSignal;\n\t\t}\n\t\tpart engine {\n\t\t\tport fuelCmdPort: ~FuelCmdPort;\n\t\t\tport engineStartPort: ~EngineStartPort;\n\t\t\tport engineStopPort: ~EngineStopPort;\n\t\t\tport engineOutputPort: EngineOutputPort;\n\t\t\tperform powertrainControl.generateEngineTorque {\n\t\t\t\tin fuelCmd = fuelCmdPort.fuelCmd;\n\t\t\t\tin engineStartSignal = engineStartPort.engineStartSignal;\n\t\t\t\tin engineStopSignal = engineStopPort.engineStopSignal;\n\t\t\t\tout engineOutputTorque = engineOutputPort.engineOutputTorque;\n\t\t\t}\n\t\t}\n\t\tinterface engineToTransmission connect engine.engineOutputPort to transmission.engineInputPort {\n\t\t\tref flow powertrainControl.engineOutputFlow\n\t\t\t\tfrom source.engineOutputTorque to target.engineOutputTorque;\n\t\t}\n\t\tpart transmission {\n\t\t\tport engineInputPort: TransmissionInputPort;\n\t\t\tport transmissionOutputPort: TransmissionOutputPort;\n\t\t\tperform powertrainControl.amplifyTorque {\n\t\t\t\tin engineOutputTorque = engineInputPort.engineOutputTorque;\n\t\t\t\tout transmissionOutputTorque = transmissionOutputPort.transmissionOutputTorque;\n\t\t\t}\n\t\t}\n\t\tinterface transmissionToWheels connect transmission.transmissionOutputPort to wheels.wheelInputPort {\n\t\t\tref flow powertrainControl.transmissionToWheelFlow\n\t\t\t\tfrom source.transmissionOutputTorque to target.wheelTorque;\n\t\t}\n\t\tpart wheels {\n\t\t\tport wheelInputPort: ~WheelInputPort;\n\t\t\tperform powertrainControl.receiveWheelTorque {\n\t\t\t\tin wheelTorque = wheelInputPort.wheelTorque;\n\t\t\t}\n\t\t}\n\t}\n\taction powertrainControl {\n\t\taction sendFuelCmd { out fuelCmd: FuelCmd; }\n\t\taction sendEngineStart { out engineStartSignal: EngineStartSignal; }\n\t\taction sendEngineStop { out engineStopSignal: EngineStopSignal; }\n\t\tsuccession flow fuelCmdFlow from sendFuelCmd.fuelCmd to generateEngineTorque.fuelCmd;\n\t\tsuccession flow startSignalFlow from sendEngineStart.engineStartSignal to generateEngineTorque.engineStartSignal;\n\t\tsuccession flow stopSignalFlow from sendEngineStop.engineStopSignal to generateEngineTorque.engineStopSignal;\n\t\taction generateEngineTorque { in fuelCmd; in engineStartSignal; in engineStopSignal; out engineOutputTorque: EngineOutputTorque; }\n\t\tsuccession flow engineOutputFlow from generateEngineTorque.engineOutputTorque to amplifyTorque.engineInputTorque;\n\t\taction amplifyTorque { in engineInputTorque: EngineOutputTorque; out transmissionOutputTorque: AmplifiedTorque; }\n\t\tsuccession flow transmissionToWheelFlow from amplifyTorque.transmissionOutputTorque to distributeTorque.amplifiedTorque;\n\t\taction distributeTorque { in amplifiedTorque: AmplifiedTorque; out wheelTorque: WheelTorque; }\n\t\tsuccession flow wheelTorqueFlow from distributeTorque.wheelTorque to receiveWheelTorque.wheelTorque;\n\t\taction receiveWheelTorque { in wheelTorque: WheelTorque; }\n\t}\n}",
    "package 'TrailerHitchSystem' {  \n    attribute def Command;  \n    attribute def Status;  \n    port def CommandPort {  \n        out command: Command;  \n    }  \n    port def StatusPort {  \n        out status: Status;  \n    }  \n    part context {  \n        part user {  \n            port commandPort: CommandPort;  \n            perform hitchingAction.sendCommand {  \n                out command = commandPort.command;  \n            }  \n        }  \n        interface userToMechanism connect user.commandPort to hitchingMechanism.commandPort {  \n            ref flow references hitchingAction.commandFlow  \n                from source.command to target.command;  \n        }  \n        part hitchingMechanism {  \n            port commandPort: ~CommandPort;  \n            port statusPort: StatusPort;  \n            perform hitchingAction.processCommand {  \n                in command = commandPort.command;  \n                out status = statusPort.status;  \n            }  \n        }  \n        interface mechanismToVehicle connect hitchingMechanism.statusPort to vehicle.statusPort {  \n            ref flow references hitchingAction.statusFlow  \n                from source.status to target.status;  \n        }  \n        interface mechanismToTrailer connect hitchingMechanism.statusPort to trailer.statusPort {  \n            ref flow references hitchingAction.statusFlow  \n                from source.status to target.status;  \n        }  \n        part vehicle {  \n            port statusPort: ~StatusPort;  \n            perform hitchingAction.updateVehicleStatus {  \n                in status = statusPort.status;  \n            }  \n        }  \n        part trailer {  \n            port statusPort: ~StatusPort;  \n            perform hitchingAction.updateTrailerStatus {  \n                in status = statusPort.status;  \n            }  \n        }  \n    }  \n    action hitchingAction {  \n        action sendCommand { out command: Command; }  \n        succession flow commandFlow from sendCommand.command to processCommand.command;  \n        action processCommand { in command: Command; out status: Status; }  \n        succession flow statusFlow from processCommand.status to updateVehicleStatus.status;  \n        succession flow statusFlow from processCommand.status to updateTrailerStatus.status;  \n        action updateVehicleStatus { in status: Status; }  \n        action updateTrailerStatus { in status: Status; }  \n    }  \n}",
    "package 'VehicleTrailerConnection' {  \n\tattribute def ConnectionCommand;  \n\tattribute def ConnectionStatus;  \n\tport def ConnectionCommandPort {  \n\t\tout command : ConnectionCommand;  \n\t}  \n\tport def TowBallPort {  \n\t\tout status: ConnectionStatus;  \n\t}  \n\tport def CouplerPort {  \n\t\tin status: ConnectionStatus;  \n\t}  \n\tpart context {  \n\t\tpart user {  \n\t\t\tport commandPort: ConnectionCommandPort;  \n\t\t\tperform connectOrDisconnect.sendCommand {  \n\t\t\t\tout command = commandPort.command;  \n\t\t\t}  \n\t\t}  \n\t\tinterface userToVehicle connect user.commandPort to vehicle.commandPort {  \n\t\t\tref flow references connectOrDisconnect.commandFlow  \n\t\t\t\tfrom source.command to target.command;  \n\t\t}  \n\t\tpart vehicle {  \n\t\t\tport commandPort: ~ConnectionCommandPort;  \n\t\t\tpart chassis;  \n\t\t\tpart towBall {  \n\t\t\t\tport towBallPort: TowBallPort;  \n\t\t\t\tperform connectOrDisconnect.engageTowBall {  \n\t\t\t\t\tin command = vehicle.commandPort.command;  \n\t\t\t\t\tout status = towBallPort.status;  \n\t\t\t\t}  \n\t\t\t}  \n\t\t}  \n\t\tinterface towBallToCoupler connect vehicle.towBall.towBallPort to trailer.coupler.couplerPort {  \n\t\t\tref flow references connectOrDisconnect.statusFlow  \n\t\t\t\tfrom source.status to target.status;  \n\t\t}  \n\t\tpart trailer {  \n\t\t\tport couplerPort: ~CouplerPort;  \n\t\t\tpart trailerFrame;  \n\t\t\tpart coupler {  \n\t\t\t\tport couplerPort: CouplerPort;  \n\t\t\t\tperform connectOrDisconnect.lockCoupler {  \n\t\t\t\t\tin status = couplerPort.status;  \n\t\t\t\t\tout connectionStatus = trailerFrame.connectionStatus;  \n\t\t\t\t}  \n\t\t\t}  \n\t\t}  \n\t}  \n\taction connectOrDisconnect {  \n\t\taction sendCommand { out command: ConnectionCommand; }  \n\t\tsuccession flow commandFlow from sendCommand.command to engageTowBall.command;  \n\t\taction engageTowBall { in command; out status: ConnectionStatus; }  \n\t\tsuccession flow statusFlow from engageTowBall.status to lockCoupler.status;  \n\t\taction lockCoupler { in status: ConnectionStatus; out connectionStatus: ConnectionStatus; }  \n\t}  \n}",
    "package 'VehicleTrailerSystem' {  \n\tattribute def ConnectCmd;  \n\tattribute def DisconnectCmd;  \n\tattribute def SecureLatch;  \n\tattribute def SmoothSeparation;  \n\tport def CommandPort {  \n\t\tout connectCmd : ConnectCmd;  \n\t\tout disconnectCmd : DisconnectCmd;  \n\t}  \n\tport def TowBallPort {  \n\t\tin connectCmd : ConnectCmd;  \n\t\tin disconnectCmd : DisconnectCmd;  \n\t\tout secureLatch : SecureLatch;  \n\t\tout smoothSeparation : SmoothSeparation;  \n\t}  \n\tport def CouplerPort {  \n\t\tin connectCmd : ConnectCmd;  \n\t\tin disconnectCmd : DisconnectCmd;  \n\t\tout secureLatch : SecureLatch;  \n\t\tout smoothSeparation : SmoothSeparation;  \n\t}  \n\tpart context {  \n\t\tpart user {  \n\t\t\tport commandPort: CommandPort;  \n\t\t\tperform hitchingRegion.sendConnectCmd {  \n\t\t\t\tout connectCmd = commandPort.connectCmd;  \n\t\t\t}  \n\t\t\tperform hitchingRegion.sendDisconnectCmd {  \n\t\t\t\tout disconnectCmd = commandPort.disconnectCmd;  \n\t\t\t}  \n\t\t}  \n\t\tinterface userToVehicle connect user.commandPort to vehicle.commandPort {  \n\t\t\tref flow references hitchingRegion.commandFlow  \n\t\t\t\tfrom source.connectCmd to target.connectCmd;  \n\t\t\t\tref flow references hitchingRegion.discommandFlow  \n\t\t\t\tfrom source.disconnectCmd to target.disconnectCmd;  \n\t\t}  \n\t\tpart vehicle {  \n\t\t\tport commandPort: ~CommandPort;  \n\t\t\tpart towBall {  \n\t\t\t\tport towBallPort: TowBallPort;  \n\t\t\t}  \n\t\t\tperform hitchingRegion.processConnectCmd {  \n\t\t\t\tin connectCmd = commandPort.connectCmd;  \n\t\t\t\tout secureLatch = towBall.towBallPort.secureLatch;  \n\t\t\t}  \n\t\t\tperform hitchingRegion.processDisconnectCmd {  \n\t\t\t\tin disconnectCmd = commandPort.disconnectCmd;  \n\t\t\t\tout smoothSeparation = towBall.towBallPort.smoothSeparation;  \n\t\t\t}  \n\t\t}  \n\t\tinterface vehicleToTrailer connect vehicle.towBall.towBallPort to trailer.coupler.couplerPort {  \n\t\t\tref flow references hitchingRegion.commandFlow  \n\t\t\t\tfrom source.connectCmd to target.connectCmd;  \n\t\t\t\tref flow references hitchingRegion.discommandFlow  \n\t\t\t\tfrom source.disconnectCmd to target.disconnectCmd;  \n\t\t\tref flow references hitchingRegion.latchFlow  \n\t\t\t\tfrom source.secureLatch to target.secureLatch;  \n\t\t\tref flow references hitchingRegion.separationFlow  \n\t\t\t\tfrom source.smoothSeparation to target.smoothSeparation;  \n\t\t}  \n\t\tpart trailer {  \n\t\t\tport couplerPort: ~CouplerPort;  \n\t\t\tpart coupler {  \n\t\t\t\tperform hitchingRegion.engageCoupler {  \n\t\t\t\t\tin connectCmd = couplerPort.connectCmd;  \n\t\t\t\t\tout secureLatch = couplerPort.secureLatch;  \n\t\t\t\t}  \n\t\t\t\tperform hitchingRegion.disengageCoupler {  \n\t\t\t\t\tin disconnectCmd = couplerPort.disconnectCmd;  \n\t\t\t\t\tout smoothSeparation = couplerPort.smoothSeparation;  \n\t\t\t\t}  \n\t\t\t}  \n\t\t}  \n\t}  \n\taction hitchingRegion {  \n\t\taction sendConnectCmd { out connectCmd: ConnectCmd; }  \n\t\taction sendDisconnectCmd { out disconnectCmd: DisconnectCmd; }  \n\t\tsuccession flow commandFlow from sendConnectCmd.connectCmd to processConnectCmd.connectCmd;  \n\t\taction processConnectCmd { in connectCmd: ConnectCmd; out secureLatch: SecureLatch; }  \n\t\tsuccession flow discommandFlow from sendDisconnectCmd.disconnectCmd to processDisconnectCmd.disconnectCmd;  \n\t\taction processDisconnectCmd { in disconnectCmd: DisconnectCmd; out smoothSeparation: SmoothSeparation; }  \n\t\tsuccession flow latchFlow from processConnectCmd.secureLatch to engageCoupler.secureLatch;  \n\t\taction engageCoupler { in connectCmd: ConnectCmd; out secureLatch: SecureLatch; }  \n\t\tsuccession flow separationFlow from processDisconnectCmd.smoothSeparation to disengageCoupler.smoothSeparation;  \n\t\taction disengageCoupler { in disconnectCmd: DisconnectCmd; out smoothSeparation: SmoothSeparation; }  \n\t}  \n}",
    "package 'FuelSystem' {\n\tattribute def Fuel;\n\tattribute def Temperature;\n\tport def FuelSupplyPort {\n\t\tout fuel: Fuel;\n\t}\n\tport def FuelReturnPort {\n\t\tin fuel: Fuel;\n\t}\n\tport def TemperaturePort {\n\t\tout temperature: Temperature;\n\t}\n\tpart context {\n\t\tpart fuelTank {\n\t\t\tport supplyPort: FuelSupplyPort;\n\t\t\tperform fuelSupplyRegion.returnFuel {\n\t\t\t\tin fuel = supplyPort.fuel;\n\t\t\t}\n\t\t}\n\t\tinterface fuelTankToEngine connect fuelTank.supplyPort to engine.supplyPort {\n\t\t\tref flow references fuelSupplyRegion.supplyFlow\n\t\t\t\tfrom source.fuel to target.fuel;\n\t\t}\n\t\tinterface engineToFuelTank connect engine.returnPort to fuelTank.returnPort {\n\t\t\tref flow references fuelSupplyRegion.returnFlow\n\t\t\t\tfrom source.fuel to target.fuel;\n\t\t}\n\t\tinterface engineToMonitor connect engine.temperaturePort to monitor.temperaturePort {\n\t\t\tref flow references fuelSupplyRegion.temperatureFlow\n\t\t\t\tfrom source.temperature to target.temperature;\n\t\t}\n\t\tpart engine {\n\t\t\tport supplyPort: ~FuelSupplyPort;\n\t\t\tport returnPort: FuelReturnPort;\n\t\t\tport temperaturePort: TemperaturePort;\n\t\t\tperform fuelSupplyRegion.processFuel {\n\t\t\t\tin fuel = supplyPort.fuel;\n\t\t\t\tout fuel = returnPort.fuel;\n\t\t\t\tout temperature = temperaturePort.temperature;\n\t\t\t}\n\t\t}\n\t\tpart monitor {\n\t\t\tport temperaturePort: ~TemperaturePort;\n\t\t\tperform fuelSupplyRegion.monitorTemperature {\n\t\t\t\tin temperature = temperaturePort.temperature;\n\t\t\t}\n\t\t}\n\t}\n\taction fuelSupplyRegion {\n\t\taction supplyFuel { out fuel: Fuel; }\n\t\tsuccession flow supplyFlow from supplyFuel.fuel to processFuel.fuel;\n\t\taction processFuel { in fuel; out fuel: Fuel; out temperature: Temperature; }\n\t\tsuccession flow returnFlow from processFuel.fuel to returnFuel.fuel;\n\t\tsuccession flow temperatureFlow from processFuel.temperature to monitorTemperature.temperature;\n\t\taction returnFuel { in fuel: Fuel; }\n\t\taction monitorTemperature { in temperature: Temperature; }\n\t}\n}",
    "package 'FuelDeliverySystem' {\n\tattribute def Fuel;\n\tattribute def MaxCapacity;\n\tattribute def CurrentFuelLevel;\n\tport def StorageFuelPort {\n\t\tout fuel: Fuel;\n\t}\n\tport def PumpFuelPort {\n\t\tin fuel: Fuel;\n\t\tout fuel: Fuel;\n\t}\n\tport def VehicleFuelPort {\n\t\tin fuel: Fuel;\n\t}\n\tpart context {\n\t\tpart storageTank {\n\t\t\tport fuelPort: StorageFuelPort;\n\t\t\tperform fuelDelivery.extractFuel {\n\t\t\t\tout fuel = fuelPort.fuel;\n\t\t\t}\n\t\t}\n\t\tinterface storageToPump connect storageTank.fuelPort to fuelPump.fuelPort {\n\t\t\tref flow references fuelDelivery.fuelFlow1\n\t\t\t\tfrom source.fuel to target.fuel; \n\t\t}\n\t\tpart fuelPump {\n\t\t\tport fuelPort: ~PumpFuelPort;\n\t\t\tperform fuelDelivery.pumpFuel {\n\t\t\t\tin fuel = fuelPort.fuel;\n\t\t\t\tout fuel = vehicleFuelPort.fuel;\n\t\t\t}\n\t\t\tport vehicleFuelPort: PumpFuelPort;\n\t\t}\n\t\tinterface pumpToVehicle connect fuelPump.vehicleFuelPort to vehicle.fuelTank.fuelPort {\n\t\t\tref flow references fuelDelivery.fuelFlow2\n\t\t\t\tfrom source.fuel to target.fuel; \n\t\t}\n\t\tpart vehicle {\n\t\t\tpart fuelTank {\n\t\t\t\tport fuelPort: VehicleFuelPort;\n\t\t\t\tperform fuelDelivery.deliverFuel {\n\t\t\t\t\tin fuel = fuelPort.fuel;\n\t\t\t\t}\n\t\t\t\tattribute maxCapacity: MaxCapacity;\n\t\t\t\tattribute currentFuelLevel: CurrentFuelLevel;\n\t\t\t\tperform fuelDelivery.monitorLevel {\n\t\t\t\t\tin maxCapacity = maxCapacity;\n\t\t\t\t\tin currentFuelLevel = currentFuelLevel;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\taction fuelDelivery {\n\t\taction extractFuel { out fuel: Fuel; }\n\t\tsuccession flow fuelFlow1 from extractFuel.fuel to pumpFuel.fuel;\n\t\taction pumpFuel { in fuel: Fuel; out fuel: Fuel; }\n\t\tsuccession flow fuelFlow2 from pumpFuel.fuel to deliverFuel.fuel;\n\t\taction deliverFuel { in fuel: Fuel; }\n\t\taction monitorLevel { in maxCapacity: MaxCapacity; in currentFuelLevel: CurrentFuelLevel; }\n\t}\n}",
    "package 'AutomobileAssembly' {\n\tattribute def VehicleWithoutGearboxAndEngine;\n\tattribute def VehicleWithGearboxWithoutEngine;\n\tattribute def FullyAssembledVehicle;\n\tattribute def Gearbox;\n\tattribute def Engine;\n\tport def StartAssemblyPort {\n\t\tout vehicle: VehicleWithoutGearboxAndEngine;\n\t}\n\tport def GearboxInstallationPort {\n\t\tin vehicle: VehicleWithoutGearboxAndEngine;\n\t\tin gearbox: Gearbox;\n\t\tout vehicle: VehicleWithGearboxWithoutEngine;\n\t}\n\tport def EngineInstallationPort {\n\t\tin vehicle: VehicleWithGearboxWithoutEngine;\n\t\tin engine: Engine;\n\t\tout vehicle: FullyAssembledVehicle;\n\t}\n\tport def FinalVehiclePort {\n\t\tout vehicle: FullyAssembledVehicle;\n\t}\n\tpart context {\n\t\tpart assemblyLine {\n\t\t\tpart initialVehicle {\n\t\t\t\tport startPort: StartAssemblyPort;\n\t\t\t\tperform startAssembly {\n\t\t\t\t\tout vehicle = startPort.vehicle;\n\t\t\t\t}\n\t\t\t}\n\t\t\tinterface initialToGearbox connect initialVehicle.startPort to gearboxInstallation.inPort {\n\t\t\t\tref flow references startAssembly.vehicle to installGearbox.vehicle;\n\t\t\t\tref flow references installGearbox.gearbox to gearboxInstallation.gearbox;\n\t\t\t}\n\t\t\tpart gearboxInstallation {\n\t\t\t\tport inPort: ~GearboxInstallationPort;\n\t\t\t\tport outPort: GearboxInstallationPort;\n\t\t\t\tperform installGearbox {\n\t\t\t\t\tin vehicle = inPort.vehicle;\n\t\t\t\t\tin gearbox = inPort.gearbox;\n\t\t\t\t\tout vehicle = outPort.vehicle;\n\t\t\t\t}\n\t\t\t}\n\t\t\tinterface gearboxToEngine connect gearboxInstallation.outPort to engineInstallation.inPort {\n\t\t\t\tref flow references installGearbox.vehicle to installEngine.vehicle;\n\t\t\t\tref flow references installEngine.engine to engineInstallation.engine;\n\t\t\t}\n\t\t\tpart engineInstallation {\n\t\t\t\tport inPort: ~EngineInstallationPort;\n\t\t\t\tport outPort: EngineInstallationPort;\n\t\t\t\tperform installEngine {\n\t\t\t\t\tin vehicle = inPort.vehicle;\n\t\t\t\t\tin engine = inPort.engine;\n\t\t\t\t\tout vehicle = outPort.vehicle;\n\t\t\t\t}\n\t\t\t}\n\t\t\tpart finalVehicle {\n\t\t\t\tport finalPort: FinalVehiclePort;\n\t\t\t\tperform finalizeVehicle {\n\t\t\t\t\tin vehicle = engineInstallation.outPort.vehicle;\n\t\t\t\t\tout vehicle = finalPort.vehicle;\n\t\t\t\t}\n\t\t\t\tpart gearbox;\n\t\t\t\tpart engine;\n\t\t\t}\n\t\t}\n\t}\n\taction assemblyProcess {\n\t\taction startAssembly { out vehicle: VehicleWithoutGearboxAndEngine; }\n\t\tsuccession flow toGearbox from startAssembly.vehicle to installGearbox.vehicle;\n\t\taction installGearbox { in vehicle; in gearbox: Gearbox; out vehicle: VehicleWithGearboxWithoutEngine; }\n\t\tsuccession flow toEngine from installGearbox.vehicle to installEngine.vehicle;\n\t\taction installEngine { in vehicle; in engine: Engine; out vehicle: FullyAssembledVehicle; }\n\t\tsuccession flow toFinal from installEngine.vehicle to finalizeVehicle.vehicle;\n\t\taction finalizeVehicle { in vehicle; out vehicle: FullyAssembledVehicle; }\n\t}\n}",
    "package 'VehicleControlSystem' {\n    signal StartSignal;\n    signal VehicleOnSignal;\n    signal OverTemperatureSignal;\n    signal RestoreToNormalSignal;\n    signal MaintenanceSignal;\n\n    port def StartSignalPort {\n        in startSignal: StartSignal;\n    }\n\n    port def VehicleOnSignalPort {\n        in vehicleOnSignal: VehicleOnSignal;\n    }\n\n    port def OverTemperatureSignalPort {\n        out overTemperatureSignal: OverTemperatureSignal;\n    }\n\n    port def RestoreToNormalSignalPort {\n        in restoreToNormalSignal: RestoreToNormalSignal;\n    }\n\n    port def MaintenanceSignalPort {\n        in maintenanceSignal: MaintenanceSignal;\n    }\n\n    part context VehicleA {\n        port startSignalPort: StartSignalPort;\n        port vehicleOnSignalPort: VehicleOnSignalPort;\n        port overTemperatureSignalPort: ~OverTemperatureSignalPort;\n        port restoreToNormalSignalPort: RestoreToNormalSignalPort;\n        port maintenanceSignalPort: MaintenanceSignalPort;\n\n        state machine operationStates {\n            initial state Off;\n            state Off;\n            state Starting;\n            state Running;\n            state Degraded;\n            state Maintenance;\n            state HealthManagement;\n\n            transition from Off to Starting when startSignalPort.startSignal and BrakePedalPressed;\n            transition from Starting to Running when vehicleOnSignalPort.vehicleOnSignal;\n\n            exit Running when exit, perform applyParkingBrake;\n\n            transition from Running to Degraded when temperature > threshold;\n            transition from Degraded to Normal when restoreToNormalSignalPort.restoreToNormalSignal;\n            transition from Maintenance to Normal when restoreToNormalSignalPort.restoreToNormalSignal;\n\n            transition from Running to Maintenance when maintenanceSignalPort.maintenanceSignal;\n            transition from Running to HealthManagement when healthCheckTrigger;\n            transition from HealthManagement to Running when healthCheckComplete;\n        }\n    }\n}",
    "package 'VehicleSystem' {\n\tattribute def StartupSignal;\n\tattribute def BrakePressed;\n\tattribute def Temperature;\n\tattribute def WarningSignal;\n\tattribute def HealthStatus;\n\tattribute def FuelLevel;\n\tattribute def MaintenanceInterval;\n\tattribute def TempThreshold;\n\tport def ControlInputPort {\n\t\tin startupSignal : StartupSignal;\n\t\tin brakePressed : BrakePressed;\n\t}\n\tport def StatusOutputPort {\n\t\tout healthStatus : HealthStatus;\n\t\tout warningSignal : WarningSignal;\n\t}\n\tport def TemperaturePort {\n\t\tin temperature : Temperature;\n\t}\n\tport def ConfigurationPort {\n\t\tin fuelLevel : FuelLevel;\n\t\tin maintenanceInterval : MaintenanceInterval;\n\t\tin tempThreshold : TempThreshold;\n\t}\n\tpart context {\n\t\tpart vehicle {\n\t\t\tport controlInputPort: ControlInputPort;\n\t\t\tport temperaturePort: TemperaturePort;\n\t\t\tport statusOutputPort: StatusOutputPort;\n\t\t\tperform startupProcess.startup {\n\t\t\t\tin startupSignal = controlInputPort.startupSignal;\n\t\t\t\tin brakePressed = controlInput-port.brakePressed;\n\t\t\t}\n\t\t\tperform healthManagement.detectOverheat {\n\t\t\t\tin temperature = temperaturePort.temperature;\n\t\t\t}\n\t\t\tperform healthManagement.maintenance {\n\t\t\t\tin healthStatus = healthManagement.healthStatus;\n\t\t\t}\n\t\t\tperform healthManagement.faultReCOVERY {\n\t\t\t\tin healthStatus = healthManagement.healthStatus;\n\t\t\t}\n\t\t}\n\t\tinterface vehicleToController connect vehicle.statusOutputPort to controller.statusINPUTPort {\n\t\t\tref flow references healthManagement.statusFlow\n\t\t\t\tfrom source.healthStatus to target.healthStatus;\n\t\t\tref flow references healthManagement.warningFlow\n\t\t\t\tfrom source.warningSignal to target.warningSignal;\n\t\t}\n\t\tpart controller {\n\t\t\tport statusInputPort: ~StatusOutputPort;\n\t\t\tport configurationPort: ~ConfigurationPort;\n\t\t\tperform controlOperations.processStartup {\n\t\t\t\tin startupSignal = vehicle.controlInputPort.startupSignal;\n\t\t\t\tin brakePressed = vehicle.controlInputPort.brakePressed;\n\t\t\t\tout healthStatus = statusInputPort.healthStatus;\n\t\t\t}\n\t\t\tperform controlOperations.processShutdown {\n\t\t\t\tin healthStatus = statusInputPort.healthStatus;\n\t\t\t}\n\t\t\tperform controlOperations.configureSystem {\n\t\t\t\tin fuelLevel = configurationPort.fuelLevel;\n\t\t\t\tin maintenanceInterval = configurationPort.maintenanceInterval;\n\t\t\t\tin tempThreshold =$ configurationPort.tempThreshold;\n\t\t\t}\n\t\t}\n\t}\n\taction startupProcess {\n\t\taction startup {\n\t\t\tin startupSignal : StartupSignal;\n\t\t\tin brakePressed : BrakePressed;\n\t\t\tout healthStatus : HealthStatus;\n\t\t}\n\t\tsuccession flow startupFlow from startup to selfInspection;\n\t\taction.selfInspection {\n\t\t\tin healthStatus;\n\t\t\tout powerSupplyStatus : PowerSupplyStatus;\n\t\t}\n\t\tsuccession flow powerSupplyFlow from selfInspection.powerSupplyStatus to.powerSupply;\n\t\taction powerSupply {\n\t\t\tin powerSupplyStatus;\n\t\t\tout healthStatus : HealthStatus;\n\t\t$\n\t}\n\taction healthManagement {\n\t\taction detectOverheat {\n\t\t\tin temperature : Temperature;\n\t\t\tout warningSignal : WarningSignal;\n\t\t\tout healthStatus : HealthStatus;\n\t\t}\n\t\tsuccession flow statusFlow from detectOverheat.healthStatus to maintenance.healthStatus;\n\t\tsuccession flow warningFlow from detectOverheat.warningSignal to processStartup.warningSignal;\n\t\taction maintenance {\n\t\t\tin healthStatus : HealthStatus;\n\t\t\tout maintenanceStatus : MaintenanceStatus;\n\t\t}\n\t\tsuccession flow recoveryFlow from maintenance.maintenanceStatus to faultRecovery.healthStatus;\n\t\taction faultReCOVERY {\n\t\t\tin healthStatus : HealthStatus;\n\t\t\tout operationalStatus : OperationalStatus;\n\t\t}\n\t}\n\taction controlOperations {\n\t\taction processStartup {\n\t\t\tin startupSignal : StartupSignal;\n\t\t\tin brakePressed : BrakePressed;\n\t\t\tout healthStatus : HealthStatus;\n\t\t\tout warningSignal : WarningSignal;\n\t\t}\n\t\tsuccession flow statusFlow from processStartup.healthStatus to vehicle.healthStatus;\n\tsuccession flow warningFlow from processStartup.warningSignal to vehicle.warningSignal;\n\t\taction processShutdown {\n\t\t\tin healthStatus : HealthStatus;\n\t\t\tout shutdownCommand : ShutdownCommand;\n\t\t}\n\t\taction configureSystem {\n\t\t\tin fuelLevel : FuelLevel;\n\t\t\tin maintenanceInterval : MaintenanceInterval;\n\t\t\tin tempThreshold : TempThreshold;\n\t\t}\n\t}\n}",
    "package 'VehicleDynamicsSimulation' {  \n\tattribute def VehicleMass;  \n\tattribute def VehiclePosition;  \n\tattribute def VehicleVelocity;  \n\tattribute def VehicleAcceleration;  \n\tattribute def RoadSlope;  \n\tattribute def RoadFriction;  \n\tattribute def TimePoint;  \n\tattribute def StateCmd;  \n\tattribute def Snapshot;  \n\n\tport def VehicleParamPort {  \n\t\tout mass: VehicleMass;  \n\t\tout position: VehiclePosition;  \n\t\tout velocity: VehicleVelocity;  \n\t\tout acceleration: VehicleAcceleration;  \n\t}  \n\tport def RoadParamPort {  \n\t\tout slope: RoadSlope;  \n\t\tout friction: RoadFriction;  \n\t}  \n\tport def SimulationCmdPort {  \n\t\tout startCmd: StateCmd;  \n\t\tout time: TimePoint;  \n\t}  \n\tport def SnapshotPort {  \n\t\tout snapshot: Snapshot;  \n\t}  \n\n\tpart context {  \n\t\tpart user {  \n\t\t\tport vehicleParamPort: VehicleParamPort;  \n\t\t\tport roadParamPort: RoadParamPort;  \n\t\t\tport simulationCmdPort: SimulationCmdPort;  \n\t\t\t\n\t\t\tperform simulateVehicleDynamics.defineVehicleParams {  \n\t\t\t\tout mass = vehicleParamPort.mass;  \n\t\t\t\tout position = vehicleParamPort.position;  \n\t\t\t\tout velocity = vehicleParamPort.velocity;  \n\t\t\t\tout acceleration = vehicleParamPort.acceleration;  \n\t\t\t}  \n\t\t\tperform simulateVehicleDynamics.defineRoadParams {  \n\t\t\t\tout slope = roadParamPort.slope;  \n\t\t\t\tout friction = roadParamPort.friction;  \n\t\t\t}  \n\t\t\tperform simulateVehicleDynamics.initiateSimulation {  \n\t\t\t\tout startCmd = simulationCmdPort.startCmd;  \n\t\t\t\tout time = simulationCmdPort.time;  \n\t\t\t}  \n\t\t}  \n\t\t\n\t\tinterface userToVehicle connect user.vehicleParamPort to vehicle.vehicleParamPort {  \n\t\t\tref flow references simulateVehicleDynamics.vehicleParamFlow  \n\t\t\t\tfrom source.mass to target.mass,  \n\t\t\t\tfrom source.position to target.position,  \n\t\t\t\tfrom source.velocity to target.velocity,  \n\t\t\t\tfrom source.acceleration to target.acceleration;  \n\t\t}  \n\t\tinterface userToRoad connect user.roadParamPort to road.roadParamPort {  \n\t\t\tref flow references simulateVehicleDynamics.roadParamFlow  \n\t\t\t\tfrom source.slope to target.slope,  \n\t\t\t\tfrom source.friction to target.friction;  \n\t\t}  \n\t\tinterface userToSimulation connect user.simulationCmdPort to simulationEngine.simulationCmdPort {  \n\t\t\tref flow references simulateVehicleDynamics.simulationCmdFlow  \n\t\t\t\tfrom source.startCmd to target.startCmd,  \n\t\t\t\tfrom source.time to target.time;  \n\t\t}  \n\t\t\n\t\tpart vehicle {  \n\t\t\tport vehicleParamPort: ~VehicleParamPort;  \n\t\t\tport statePort: SimulationCmdPort;  \n\t\t\t\n\t\t\tperform simulateVehicleDynamics.updateVehicleState {  \n\t\t\t\tin mass = vehicleParamPort.mass;  \n\t\t\t\tin position = vehicleParamPort.position;  \n\t\t\t\tin velocity = vehicleParamPort.velocity;  \n\t\t\t\tin acceleration = vehicleParamPort.acceleration;  \n\t\t\t\tin startCmd = statePort.startCmd;  \n\t\t\t\tin time = statePort.time;  \n\t\t\t\tout state = statePort.state;  \n\t\t\t}  \n\t\t}  \n\t\t\n\t\tpart road {  \n\t\t\tport roadParamPort: ~RoadParamPort;  \n\t\t\tport statePort: SimulationCmdPort;  \n\t\t\t\n\t\t\tperform simulateVehicleDynamics.updateRoadState {  \n\t\t\t\tin slope = roadParamPort.slope;  \n\t\t\t\tin friction = roadParamPort.friction;  \n\t\t\t\tin time = statePort.time;  \n\t\t\t\tout state = statePort.state;  \n\t\t\t}  \n\t\t}  \n\t\t\n\t\tpart simulationEngine {  \n\t\t\tport simulationCmdPort: ~SimulationCmdPort;  \n\t\t\tport snapshotPort: SnapshotPort;  \n\t\t\t\n\t\t\tperform simulateVehicleDynamics.recordSnapshot {  \n\t\t\t\tin vehicleState = vehicle.statePort.state;  \n\t\t\t\tin roadState = road.statePort.state;  \n\t\t\t\tin time = simulationCmdPort.time;  \n\t\t\t\tout snapshot = snapshotPort.snapshot;  \n\t\t\t}  \n\t\t\tperform simulateVehicleDynamics.aggregateSnapshots {  \n\t\t\t\tin snapshots = snapshotPort.snapshot;  \n\t\t\t\tout stateTransitions: StateCmd;  \n\t\t\t}  \n\t\t}  \n\t}  \n\n\taction simulateVehicleDynamics {  \n\t\taction defineVehicleParams {  \n\t\t\tout mass: VehicleMass;  \n\t\t\tout position: VehiclePosition;  \n\t\t\tout velocity: VehicleVelocity;  \n\t\t\tout acceleration: VehicleAcceleration;  \n\t\t}  \n\t\taction defineRoadParams {  \n\t\t\tout slope: RoadSlope;  \n\t\t\tout friction: RoadFriction;  \n\t\t}  \n\t\taction initiateSimulation {  \n\t\t\tout startCmd: StateCmd;  \n\t\t\tout time: TimePoint;  \n\t\t}  \n\t\tsuccession flow vehicleParamFlow from defineVehicleParams to updateVehicleState;  \n\t\tsuccession flow roadParamFlow from defineRoadParams to updateRoadState;  \n\t\tsuccession flow simulationCmdFlow from initiateSimulation to updateVehicleState.startCmd, updateRoadState.time;  \n\t\t\n\t\taction updateVehicleState {  \n\t\t\tin mass: VehicleMass;  \n\t\t\tin position: VehiclePosition;  \n\t\t\tin velocity: VehicleVelocity;  \n\t\t\tin acceleration: VehicleAcceleration;  \n\t\t\tin startCmd: StateCmd;  \n\t\t\tin time: TimePoint;  \n\t\t\tout state: StateCmd;  \n\t\t}  \n\t\taction updateRoadState {  \n\t\t\tin slope: RoadSlope;  \n\t\t\tin friction: RoadFriction;  \n\t\t\tin time: TimePoint;  \n\t\t\tout state: StateCmd;  \n\t\t}  \n\t\taction recordSnapshot {  \n\t\t\tin vehicleState: StateCmd;  \n\t\t\tin roadState: StateCmd;  \n\t\t\tin time: TimePoint;  \n\t\t\tout snapshot: Snapshot;  \n\t\t}  \n\t\tsuccession flow snapshotFlow from updateVehicleState.state to recordSnapshot.vehicleState;  \n\t\tsuccession flow snapshotFlow from updateRoadState.state to recordSnapshot.roadState;  \n\t\tsuccession flow snapshotFlow from initiateSimulation.time to recordSnapshot.time;  \n\t\t\n\t\taction aggregateSnapshots {  \n\t\t\tin snapshots: Snapshot*;  \n\t\t\tout stateTransitions: StateCmd;  \n\t\t}  \n\t\tsuccession flow snapshotAggregation from recordSnapshot.snapshot to aggregateSnapshots.snapshots;  \n\t}  \n}",
    "package 'AutomotiveConfigurations' {\n\tblock Automobile {\n\t\tpart subA: SubsystemA;\n\t\tpart subB: SubsystemB;\n\t\tconstraint configConstraint {\n\t\t\tif (subA.variant == SubsystemA::Config2) then\n\t\t\t\tsubB.variant == SubsystemB::Config2;\n\t\t}\n\t}\n\n\tblock SubsystemA {\n\t\tvariant Config1 {\n\t\t\tpart comp1: Component1;\n\t\t\tpart comp2: Component2;\n\t\t}\n\t\tvariant Config2 {\n\t\t\tpart comp2: Component2;\n\t\t\tpart comp3: Component3;\n\t\t}\n\t}\n\n\tblock SubsystemB {\n\t\tvariant Config1 {\n\t\t\tpart comp4: Component4;\n\t\t\tpart comp5: Component5;\n\t\t}\n\t\tvariant Config2 {\n\t\t\tpart comp5: Component5;\n\t\t\tpart comp6: Component6;\n\t\t}\n\t}\n\n\tblock ConfigurationA {\n\t\tvariant of Automobile {\n\t\t\tselect subA.variant = SubsystemA::Config1;\n\t\t\tselect subB.variant = SubsystemB::Config1;\n\t\t}\n\t}\n\n\tblock ConfigurationB {\n\t\tvariant of Automobile {\n\t\t\tselect subA.variant = SubsystemA::Config2;\n\t\t\tselect subB.variant = SubsystemB::Config2;\n\t\t}\n\t}\n}",
    "package 'ModularVehiclePlatform' {\n    part def part1;\n    part def part2;\n    part def part3 {\n        port p1;\n    }\n    part def part4;\n    part def part5 {\n        port p2;\n        behavior def variant1;\n        behavior def variant2;\n    }\n    part def part6;\n\n    part context SubsystemA {\n        part p1: part1;\n        part p2: part2;\n        part p3: part3;\n        part p4: part4;\n        port subsystemAPort;\n    }\n\n    part context SubsystemB {\n        part p5: part5;\n        part p6: part6;\n        port subsystemBPort;\n    }\n\n    interface subsystemInterface connect SubsystemA.subsystemAPort to SubsystemB.subsystemBPort;\n\n    part context VehicleConfigA {\n        part subsystemA: SubsystemA;\n        part subsystemB: SubsystemB {\n            part p5: part5;\n            perform part5.variant1;\n        }\n        constraint configConstraintA;\n    }\n\n    part context VehicleConfigB {\n        part subsystemA: SubsystemA;\n        part subsystemB: SubsystemB {\n            part p5: part5;\n            perform part5.variant2;\n        }\n        constraint configConstraintB;\n    }\n\n    constraint def configConstraintA {\n        // Define constraints for VehicleConfigA\n    }\n\n    constraint def configConstraintB {\n        // Define constraints for VehicleConfigB\n    }\n\n    constraint def SystemConsistencyConstraint {\n        // Apply to configurations\n    }\n}",
    "package 'VehicleConfiguration' {  \n\tattribute def EngineType;  \n\tattribute def TransmissionType;  \n\tattribute def WheelType;  \n\tattribute def PerformanceLevel;  \n\tattribute def UserPreferences;  \n\tport def ConfigRequestPort {  \n\t\tout performanceLevel: PerformanceLevel;  \n\t\tout userPreferences: UserPreferences;  \n\t}  \n\tport def ComponentConfigPort {  \n\t\tout engineType: EngineType;  \n\t\tout transmissionType: TransmissionType;  \n\t\tout wheelType: WheelType;  \n\t}  \n\tpart context {  \n\t\tpart user {  \n\t\t\tport configRequestPort: ConfigRequestPort;  \n\t\t\tperform configureVehicle.sendConfigRequest {  \n\t\t\t\tout performanceLevel = configRequestPort.performanceLevel;  \n\t\t\t\tout userPreferences = configRequestPort.userPreferences;  \n\t\t\t}  \n\t\t}  \n\t\tinterface userToSystem connect user.configRequestPort to system.configRequestPort {  \n\t\t\tref flow references configureVehicle.requestFlow  \n\t\t\t\tfrom source.performanceLevel to target.performanceLevel,  \n\t\t\t\tfrom source.userPreferences to target.userPreferences;  \n\t\t}  \n\t\tpart system {  \n\t\t\tport configRequestPort: ~ConfigRequestPort;  \n\t\t\tperform configureVehicle.determineConfiguration {  \n\t\t\t\tin performanceLevel = configRequestPort.performanceLevel;  \n\t\t\t\tin userPreferences = configRequestPort.userPreferences;  \n\t\t\t\tout engineType = componentConfigPort.engineType;  \n\t\t\t\tout transmissionType = componentConfigPort.transmissionType;  \n\t\t\t\tout wheelType = componentConfigPort.wheelType;  \n\t\t\t}  \n\t\t\tport componentConfigPort: ComponentConfigPort;  \n\t\t\tperform configureVehicle.checkConstraints {  \n\t\t\t\tin engineType = componentConfigPort.engineType;  \n\t\t\t\tin transmissionType = componentConfigPort.transmissionType;  \n\t\t\t\tin wheelType = componentConfigPort.wheelType;  \n\t\t\t}  \n\t\t}  \n\t\tpart engine {  \n\t\t\tport componentPort: ~ComponentConfigPort;  \n\t\t}  \n\t\tpart transmission {  \n\t\t\tport componentPort: ~ComponentConfigPort;  \n\t\t}  \n\t\tpart wheels {  \n\t\t\tport componentPort: ~ComponentConfigPort;  \n\t\t}  \n\t}  \n\taction configureVehicle {  \n\t\taction sendConfigRequest {  \n\t\t\tout performanceLevel: PerformanceLevel;  \n\t\t\tout userPreferences: UserPreferences;  \n\t\t}  \n\t\tsuccession flow requestFlow from sendConfigRequest.performanceLevel to determineConfiguration.performanceLevel,  \n\t\t\tfrom sendConfigRequest.userPreferences to determineConfiguration.userPreferences;  \n\t\taction determineConfiguration {  \n\t\t\tin performanceLevel;  \n\t\t\tin userPreferences;  \n\t\t\tout engineType: EngineType;  \n\t\t\tout transmissionType: TransmissionType;  \n\t\t\tout wheelType: WheelType;  \n\t\t}  \n\t\tsuccession flow configFlow from determineConfiguration.engineType to selectEngine.engineType,  \n\t\t\tfrom determineConfiguration.transmissionType to selectTransmission.transmissionType,  \n\t\t\tfrom determineConfiguration.wheelType to selectWheels.wheelType;  \n\t\taction selectEngine { out engineType: EngineType; }  \n\t\taction selectTransmission { out transmissionType: TransmissionType; }  \n\t\taction selectWheels { out wheelType: WheelType; }  \n\t\taction checkConstraints {  \n\t\t\tin engineType: EngineType;  \n\t\t\tin transmissionType: TransmissionType;  \n\t\t\tin wheelType: WheelType;  \n\t\t}  \n\t}  \n}",
    "package 'AutomobileSystem' {\n\tattribute def VehicleMass;\n\tattribute def FuelStatus;\n\tattribute def Reliability;\n\tattribute def MaxMassLimitation;\n\tattribute def DurabilityConstraint;\n\tport def VehicleMassPort {\n\t\tout mass: VehicleMass;\n\t}\n\tport def FuelStatusPort {\n\t\tout fuelStatus: FuelStatus;\n\t}\n\tport def DriveInterfacePort {\n\t\tout torque: Torque;\n\t}\n\tport def ReliabilityPort {\n\t\tout reliability: Reliability;\n\t}\n\tpart context {\n\t\tpart vehicle {\n\t\t\tport massPort: VehicleMassPort;\n\t\t\tport fuelStatusPort: FuelStatusPort;\n\t\t\tport reliabilityPort: ReliabilityPort;\n\t\t\tperform checkMassCompliance.validateMass {\n\t\t\t\tin mass = massPort.mass;\n\t\t\t\tin fuelStatus = fuelStatusPort.fuelStatus;\n\t\t\t\tref constraint references maxMassConstraint.MaxMassLimitation;\n\t\t\t}\n\t\t\tperform ensureDurability.validateLifecycle {\n\t\t\t\tout reliability = reliabilityPort.reliability;\n\t\t\t\tref constraint references durabilityConstraint.DurabilityConstraint;\n\t\t\t}\n\t\t}\n\t\tinterface vehicleToEngine connect vehicle.massPort to engine.massPort {\n\t\t\tref flow references checkMassCompliance.massFlow;\n\t\t}\n\t\tpart engine {\n\t\t\tport massPort: ~VehicleMassPort;\n\t\t\tport drivePort: DriveInterfacePort;\n\t\t\tperform produceTorque.deliverPower {\n\t\t\t\tout torque = drivePort.torque;\n\t\t\t}\n\t\t}\n\t\tpart transmission {\n\t\t\tport drivePort: ~DriveInterfacePort;\n\t\t\tperform receiveTorque.transferPower {\n\t\t\t\tin torque = drivePort.torque;\n\t\t\t}\n\t\t}\n\t}\n\taction checkMassCompliance {\n\t\taction validateMass {\n\t\t\tin mass: VehicleMass;\n\t\t\tin fuelStatus: FuelStatus;\n\t\t\tref constraint MaxMassLimitation;\n\t\t}\n\t\taction produceTorque {\n\t\t\tout torque: Torque;\n\t\t}\n\t\tsuccession flow massFlow from validateMass.mass to receiveTorque.mass;\n\t\taction ensureDurability {\n\t\t\tout reliability: Reliability;\n\t\t\tref constraint DurabilityConstraint;\n\t\t}\n\t}\n}",
    "package 'VehicleMassCompliance' {\n\tattribute def ActualMass;\n\tattribute def MaxPermissibleMass;\n\tattribute def ComplianceStatus;\n\tport def CommandPort {\n\t\tout startTest : Boolean;\n\t}\n\tport def MassMeasurementPort {\n\t\tin actualMass : ActualMass;\n\t}\n\tport def ComplianceResultPort {\n\t\tout complianceStatus : ComplianceStatus;\n\t}\n\tpart context {\n\t\tpart testOperator {\n\t\t\tport commandPort: CommandPort;\n\t\t\tperform measureVehicleMass.sendStartTest {\n\t\t\t\tout startTest = commandPort.startTest;\n\t\t\t}\n\t\t}\n\t\tinterface testOperatorToVehicle connect testOperator.commandPort to vehicle.commandPort {\n\t\t\tref flow references measureVehicleMass.testCommandFlow\n\t\t\t\tfrom source.startTest to target.startTest;\n\t\t}\n\t\tpart vehicle {\n\t\t\tport commandPort: ~CommandPort;\n\t\t\tport massMeasurementPort: MassMeasurementPort;\n\t\t\tperform measureVehicleMass.provideActualMass {\n\t\t\t\tin startTest = commandPort.startTest;\n\t\t\t\tout actualMass = massMeasurementPort.actualMass;\n\t\t\t}\n\t\t}\n\t\tinterface vehicleToWeighingEquipment connect vehicle.massMeasurementPort to weighingEquipment.massInputPort {\n\t\t\tref flow references measureVehicleMass.massFlow\n\t\t\t\tfrom source.actualMass to target.actualMass;\n\t\t}\n\t\tpart weighingEquipment {\n\t\t\tport massInputPort: ~MassMeasurementPort;\n\t\t\tport systemMassPort: ~MassMeasurementPort;\n\t\t\tperform measureVehicleMass.transmitMeasuredMass {\n\t\t\t\tin actualMass = massInputPort.actualMass;\n\t\t\t\tout measuredMass = system.massMeasurementPort.actualMass;\n\t\t\t}\n\t\t}\n\t\tpart system {\n\t\t\tport massMeasurementPort: MassMeasurementPort;\n\t\t\tport complianceResultPort: ComplianceResultPort;\n\t\t\tperform measureVehicleMass.compareMass {\n\t\t\t\tin measuredMass = massMeasurementPort.actualMass;\n\t\t\t\tin maxMass = config.maxPermissibleMass;\n\t\t\t\tout comparisonResult;\n\t\t\t}\n\t\t\tperform measureVehicleMass.determineCompliance {\n\t\t\t\tin comparisonResult;\n\t\t\t\tout complianceStatus = complianceResultPort.complianceStatus;\n\t\t\t}\n\t\t}\n\t}\n\taction measureVehicleMass {\n\t\taction sendStartTest { out startTest: Boolean; }\n\t\tsuccession flow testCommandFlow from sendStartTest.startTest to provideActualMass.startTest;\n\t\taction provideActualMass { in startTest; out actualMass: ActualMass; }\n\t\tsuccession flow massFlow from provideActualMass.actualMass to transmitMeasuredMass.actualMass;\n\t\taction transmitMeasuredMass { in actualMass; out measuredMass: ActualMass; }\n\t\tsuccession flow massComparisonFlow from transmitMeasuredMass.measuredMass to compareMass.measuredMass;\n\t\taction compareMass { \n\t\t\tin measuredMass: ActualMass; \n\t\t\tin maxPermissibleMass: MaxPermissibleMass; \n\t\t\tout comparisonResult: Boolean; \n\t\t}\n\t\tsuccession flow complianceFlow from compareMass.comparisonResult to determineCompliance.comparisonResult;\n\t\taction determineCompliance { \n\t\t\tin comparisonResult: Boolean; \n\t\t\tout complianceStatus: ComplianceStatus; \n\t\t}\n\t}\n}",
    "package 'WaterSupplyNetwork' {  \n\tport def SpigotBankHotPort {  \n\t\tout hotWater: Water;  \n\t}  \n\tport def SpigotBankColdPort {  \n\t\tout coldWater: Water;  \n\t}  \n\tport def SpigotHotPort {  \n\t\tin hotWater: Water;  \n\t\tout hotWater: Water;  \n\t}  \n\tport def SpigotColdPort {  \n\t\tin coldWater: Water;  \n\t\tout coldWater: Water;  \n\t}  \n\tport def FaucetInletPort {  \n\t\tin water: Water;  \n\t}  \n  \n\tpart context {  \n\t\tpart spigotBank {  \n\t\t\tport hot: SpigotBankHotPort;  \n\t\t\tport cold: SpigotBankColdPort;  \n\t\t}  \n\t\tinterface spigotBankToSpigotHot connect spigotBank.hot to spigot.hot {  \n\t\t\tref flow references supplyHotWater.hotWaterFlow  \n\t\t\t\tfrom source.hotWater to target.hotWater;  \n\t\t}  \n\t\tinterface spigotBankToSpigotCold connect spigotBank.cold to spigot.cold {  \n\t\t\tref flow references supplyColdWater.coldWaterFlow  \n\t\t\t\tfrom source.coldWater to target.coldWater;  \n\t\t}  \n\t\tpart spigot {  \n\t\t\tport hot: ~SpigotHotPort;  \n\t\t\tport cold: ~SpigotColdPort;  \n\t\t}  \n\t\tinterface spigotToFaucetInletHot connect spigot.hot to faucetInlet.hot;  \n\t\tinterface spigotToFaucetInletCold connect spigot.cold to faucetInlet.cold;  \n\t\tpart faucetInlet {  \n\t\t\tport hot: FaucetInletPort;  \n\t\t\tport cold: FaucetInletPort;  \n\t\t}  \n\t}  \n  \n\taction supplyHotWater {  \n\t\taction supplyHotWaterAction { out hotWater: Water; }  \n\t\tsuccession flow hotWaterFlow from supplyHotWaterAction.hotWater to transmitHotWaterAction.hotWater;  \n\t\taction transmitHotWaterAction { in hotWater: Water; out hotWater: Water; }  \n\t\tsuccession flow distributeHotWaterFlow from transmitHotWaterAction.hotWater to receiveHotWaterAction.hotWater;  \n\t\taction receiveHotWaterAction { in hotWater: Water; }  \n\t}  \n  \n\taction supplyColdWater {  \n\t\taction supplyColdWaterAction { out coldWater: Water; }  \n\t\tsuccession flow coldWaterFlow from supplyColdWaterAction.coldWater to transmitColdWaterAction.coldWater;  \n\t\taction transmitColdWaterAction { in coldWater: Water; out coldWater: Water; }  \n\t\tsuccession flow distributeColdWaterFlow from transmitColdWaterAction.coldWater to receiveColdWaterAction.coldWater;  \n\t\taction receiveColdWaterAction { in coldWater: Water; }  \n\t}  \n}",
    "package 'VehicleQualitySystem' {\n\tattribute def Mass;\n\tattribute def TotalMass;\n\tattribute def QualityRequirement;\n\tattribute def AnalysisUseCase;\n\tattribute def AnalysisObjective;\n\tattribute def AnalysisTask;\n\tattribute def AnalysisPlan;\n\tport def MassPort {\n\t\tout mass: Mass;\n\t}\n\tport def TotalMassPort {\n\t\tout totalMass: TotalMass;\n\t}\n\tport def QualityRequirementPort {\n\t\tout qualityRequirement: QualityRequirement;\n\t}\n\tport def AnalysisUseCasePort {\n\t\tout analysisUseCase: AnalysisUseCase;\n\t}\n\tport def AnalysisObjectivePort {\n\t\tout analysisObjective: AnalysisObjective;\n\t}\n\tport def AnalysisTaskPort {\n\t\tout analysisTask: AnalysisTask;\n\t}\n\tport def AnalysisPlanPort {\n\t\tout analysisPlan: AnalysisPlan;\n\t}\n\tpart context {\n\t\tpart vehicle {\n\t\t\tpart engine {\n\t\t\t\tport massPort: MassPort;\n\t\t\t\tperform qualityAnalysis.aggregateTotalMass.engineMass {\n\t\t\t\t\tout mass = massPort.mass;\n\t\t\t\t}\n\t\t\t}\n\t\t\tpart transmission {\n\t\t\t\tport massPort: MassPort;\n\t\t\t\tperform qualityAnalysis.aggregateTotalMass.transmissionMass {\n\t\t\t\t\tout mass = massPort.mass;\n\t\t\t\t}\n\t\t\t}\n\t\t\tpart frontAxle {\n\t\t\t\tport massPort: MassPort;\n\t\t\t\tperform qualityAnalysis.aggregateTotalMass.frontAxleMass {\n\t\t\t\t\tout mass = massPort.mass;\n\t\t\t\t}\n\t\t\t}\n\t\t\tpart rearAxle {\n\t\t\t\tport massPort: MassPort;\n\t\t\t\tperform qualityAnalysis.aggregateTotalMass.rearAxleMass {\n\t\t\t\t\tout mass = massPort.mass;\n\t\t\t\t}\n\t\t\t}\n\t\t\tport totalMassPort: TotalMassPort;\n\t\t}\n\t\tinterface componentToAnalyzer connect engine.massPort to qualityAnalyzer.massInputPorts.engineMass {\n\t\t\tref flow references qualityAnalysis.aggregateTotalMass.engineMassFlow\n\t\t\t\tfrom source.mass to target.engineMass;\n\t\t}\n\t\tinterface componentToAnalyzer connect transmission.massPort to qualityAnalyzer.massInputPorts.transmissionMass {\n\t\t\tref flow references qualityAnalysis.aggregateTotalMass.transmissionMassFlow\n\t\t\t\tfrom source.mass to target.transmissionMass;\n\t\t}\n\t\tinterface componentToAnalyzer connect frontAxle.massPort to qualityAnalyzer.massInputPorts.frontAxleMass {\n\t\t\tref flow references qualityAnalysis.aggregateTotalMass.frontAxleMassFlow\n\t\t\t\tfrom source.mass to target.frontAxleMass;\n\t\t}\n\t\tinterface componentToAnalyzer connect rearAxle.massPort to qualityAnalyzer.massInputPorts.rearAxleMass {\n\t\t\tref flow references qualityAnalysis.aggregateTotalMass.rearAxleMassFlow\n\t\t\t\tfrom source.mass to target.rearAxleMass;\n\t\t}\n\t\tinterface analyzerToVehicle connect qualityAnalyzer.totalMassPort to vehicle.totalMassPort {\n\t\t\tref flow references qualityAnalysis.aggregateTotalMass.totalMassFlow\n\t\t\t\tfrom source.totalMass to target.totalMass;\n\t\t}\n\t\tpart qualityAnalyzer {\n\t\t\tport massInputPorts: MassPort[4];\n\t\t\tport totalMassPort: ~TotalMassPort;\n\t\t\tperform qualityAnalysis.aggregateTotalMass {\n\t\t\t\tin engineMass = massInputPorts[0].mass;\n\t\t\t\tin transmissionMass = massInputPorts[1].mass;\n\t\t\t\tin frontAxleMass = massInputPorts[2].mass;\n\t\t\t\tin rearAxleMass = massInputPorts[3].mass;\n\t\t\t\tout totalMass = totalMassPort.totalMass;\n\t\t\t}\n\t\t\tperform qualityAnalysis.defineQualityRequirements {\n\t\t\t\tout qualityRequirement = qualityRequirementPort.qualityRequirement;\n\t\t\t}\n\t\t\tport qualityRequirementPort: QualityRequirementPort;\n\t\t\tperform qualityAnalysis.formulateAnalysisUseCases {\n\t\t\t\tin qualityRequirement = qualityRequirementPort.qualityRequirement;\n\t\t\t\tout analysisUseCase = analysisUseCasePort.analysisUseCase;\n\t\t\t}\n\t\t\tport analysisUseCasePort: AnalysisUseCasePort;\n\t\t\tperform qualityAnalysis.generateAnalysisTasks {\n\t\t\t\tin analysisObjective = analysisObjectivePort.analysisObjective;\n\t\t\t\tin analysisUseCase = analysisUseCasePort.analysisUseCase;\n\t\t\t\tout analysisTask = analysisTaskPort.analysisTask;\n\t\t\t\tout analysisPlan = analysisPlanPort.analysisPlan;\n\t\t\t}\n\t\t\tport analysisObjectivePort: AnalysisObjectivePort;\n\t\t\tport analysisTaskPort: AnalysisTaskPort;\n\t\t\tport analysisPlanPort: AnalysisPlanPort;\n\t\t}\n\t}\n\taction qualityAnalysis {\n\t\taction aggregateTotalMass {\n\t\t\tin engineMass: Mass;\n\t\t\tin transmissionMass: Mass;\n\t\t\tin frontAxleMass: Mass;\n\t\t\tin rearAxleMass: Mass;\n\t\t\tout totalMass: TotalMass;\n\t\t}\n\t\taction defineQualityRequirements { out qualityRequirement: QualityRequirement; }\n\t\taction formulateAnalysisUseCases {\n\t\t\tin qualityRequirement: QualityRequirement;\n\t\t\tout analysisUseCase: AnalysisUseCase;\n\t\t}\n\t\taction generateAnalysisTasks {\n\t\t\tin analysisObjective: AnalysisObjective;\n\t\t\tin analysisUseCase: AnalysisUseCase;\n\t\t\tout analysisTask: AnalysisTask;\n\t\t\tout analysisPlan: AnalysisPlan;\n\t\t}\n\t\tsuccession flow massAggregationFlow from aggregateTotalMass.totalMass to formulateAnalysisUseCases.analysisUseCase;\n\t\tsuccession flow requirementFlow from defineQualityRequirements.qualityRequirement to formulateAnalysisUseCases.qualityRequirement;\n\t\tsuccession flow useCaseFlow from formulateAnalysisUseCases.analysisUseCase to generateAnalysisTasks.analysisUseCase;\n\t\tsuccession flow objectiveFlow from analysisObjective to generateAnalysisTasks.analysisObjective;\n\t}\n}",
    "package 'VehiclePowertrainConfigurator' {  \n\tattribute def Power;  \n\tattribute def Mass;  \n\tattribute def Efficiency;  \n\tattribute def Reliability;  \n\tattribute def Cost;  \n\tattribute def EvaluationResult;  \n\tattribute def Explanation;  \n\n\tport def EngineDataPort {  \n\t\tout power: Power;  \n\t\tout mass: Mass;  \n\t\tout efficiency: Efficiency;  \n\t\tout reliability: Reliability;  \n\t\tout cost: Cost;  \n\t}  \n\tport def RecommendationPort {  \n\t\tout evaluationResult: EvaluationResult;  \n\t\tout explanation: Explanation;  \n\t}  \n\n\tpart context {  \n\t\tpart configurator {  \n\t\t\tport engineDataPort: ~EngineDataPort;  \n\t\t\tperform tradeOffAnalysis.sendEngineData {  \n\t\t\t\tout power = engineDataPort.power;  \n\t\t\t\tout mass = engineDataPort.mass;  \n\t\t\t\tout efficiency = engineDataPort.efficiency;  \n\t\t\t\tout reliability = engineDataPort.reliability;  \n\t\t\t\tout cost = engineDataPort.cost;  \n\t\t\t}  \n\t\t\tperform recommendEngine.generateRecommendation {  \n\t\t\t\tin evaluationResult = tradeOffAnalysis.evaluationResult;  \n\t\t\t\tout evaluationResult = recommendationPort.evaluationResult;  \n\t\t\t\tout explanation = recommendationPort.explanation;  \n\t\t\t}  \n\t\t}  \n\t\tinterface engineToEvaluator connect engine.engineDataPort to configurator.engineDataPort {  \n\t\t\tref flow references tradeOffAnalysis.engineDataFlow  \n\t\t\t\tfrom source.power to target.power,  \n\t\t\t\tfrom source.mass to target.mass,  \n\t\t\t\tfrom source.efficiency to target.efficiency,  \n\t\t\t\tfrom source.reliability to target.reliability,  \n\t\t\t\tfrom source.cost to target.cost;  \n\t\t}  \n\t\tpart engine {  \n\t\t\tport engineDataPort: EngineDataPort;  \n\t\t\tperform tradeOffAnalysis.produceEngineData {  \n\t\t\t\tout power = engineDataPort.power;  \n\t\t\t\tout mass = engineDataPort.mass;  \n\t\t\t\tout efficiency = engineDataPort.efficiency;  \n\t\t\t\tout reliability = engineDataPort.reliability;  \n\t\t\t\tout cost = engineDataPort.cost;  \n\t\t\t}  \n\t\t}  \n\t\tpart evaluationModel {  \n\t\t\tport engineDataPort: ~EngineDataPort;  \n\t\t\tport recommendationPort: ~RecommendationPort;  \n\t\t\tperform tradeOffAnalysis.analyzeTradeOffs {  \n\t\t\t\tin power = engineDataPort.power;  \n\t\t\t\tin mass = engineDataPort.mass;  \n\t\t\t\tin efficiency = engineDataPort.efficiency;  \n\t\t\t\tin reliability = engineDataPort.reliability;  \n\t\t\t\tin cost = engineDataPort.cost;  \n\t\t\t\tout evaluationResult = recommendationPort.evaluationResult;  \n\t\t\t\tout explanation = recommendationPort.explanation;  \n\t\t\t}  \n\t\t}  \n\t}  \n\n\taction tradeOffAnalysis {  \n\t\taction sendEngineData {  \n\t\t\tout power: Power;  \n\t\t\tout mass: Mass;  \n\t\t\tout efficiency: Efficiency;  \n\t\t\tout reliability: Reliability;  \n\t\t\tout cost: Cost;  \n\t\t}  \n\t\tsuccession flow engineDataFlow from sendEngineData.power to analyzeTradeOffs.power,  \n\t\t\tsendEngineData.mass to analyzeTradeOffs.mass,  \n\t\t\tsendEngineData.efficiency to analyzeTradeOffs.efficiency,  \n\t\t\tsendEngineData.reliability to analyzeTradeOffs.reliability,  \n\t\t\tsendEngineData.cost to analyzeTradeOffs.cost;  \n\t\taction analyzeTradeOffs {  \n\t\t\tin power: Power;  \n\t\t\tin mass: Mass;  \n\t\t\tin efficiency: Efficiency;  \n\t\t\tin reliability: Reliability;  \n\t\t\tin cost: Cost;  \n\t\t\tout evaluationResult: EvaluationResult;  \n\t\t\tout explanation: Explanation;  \n\t\t}  \n\t\tsuccession flow analysisResultFlow from analyzeTradeOffs.evaluationResult to generateRecommendation.evaluationResult;  \n\t\taction generateRecommendation {  \n\t\t\tin evaluationResult: EvaluationResult;  \n\t\t\tout evaluationResult: EvaluationResult;  \n\t\t\tout explanation: Explanation;  \n\t\t}  \n\t}  \n}",
    "package 'VehicleFuelEconomy' {\n\tattribute def mpgUrban;\n\tattribute def mpgHighway;\n\tattribute def usGallon = 231; // cubic inches\n\tattribute def testLoad = 1000; // pounds\n\tport def FuelEconomyPort {\n\t\tout mpgUrban: mpgUrban;\n\t\tout mpgHighway: mpgHighway;\n\t}\n\tport def TestScenarioPort {\n\t\tin mpg: mpgUrban or mpgHighway;\n\t\tin load: testLoad;\n\t\tin conditions: String;\n\t}\n\tpart context {\n\t\tpart vehicle {\n\t\t\tport fuelEconomyPort: FuelEconomyPort;\n\t\t\tperform calculateFuelEconomy {\n\t\t\t\tout mpgUrban = fuelEconomyPort.mpgUrban;\n\t\t\t\tout mpgHighway = fuelEconomyPort.mpgHighway;\n\t\t\t}\n\t\t}\n\t\tinterface urbanTestScenario connect vehicle.fuelEconomyPort to urbanTest.fuelEconomyPort {\n\t\t\tref flow references validateUrbanScenario.mpgFlow\n\t\t\t\tfrom source.mpgUrban to target.mpg;\n\t\t\tref flow references validateUrbanScenario.loadFlow\n\t\t\t\tfrom source.testLoad to target.load;\n\t\t}\n\t\tinterface highwayTestScenario connect vehicle.fuelEconomyPort to highwayTest.fuelEconomyPort {\n\t\t\tref flow references validateHighwayScenario.mpgFlow\n\t\t\t\tfrom source.mpgHighway to target.mpg;\n\t\t\tref flow references validateHighwayScenario.loadFlow\n\t\t\t\tfrom source.testLoad to target.load;\n\t\t}\n\t\tpart urbanTest {\n\t\t\tport fuelEconomyPort: ~FuelEconomyPort;\n\t\t\tperform validateUrbanScenario {\n\t\t\t\tin mpg: vehicle.mpgUrban;\n\t\t\t\tin load: testLoad;\n\t\t\t\tconstraint assert mpg >= 25;\n\t\t\t}\n\t\t}\n\t\tpart highwayTest {\n\t\t\tport fuelEconomyPort: ~FuelEconomyPort;\n\t\t\tperform validateHighwayScenario {\n\t\t\t\tin mpg: vehicle.mpgHighway;\n\t\t\t\tin load: testLoad;\n\t\t\t\tconstraint assert mpg >= 30;\n\t\t\t}\n\t\t}\n\t}\n\taction calculateFuelEconomy {\n\t\taction calculateFuelEconomy {\n\t\t\tin powertrain: String;\n\t\t\tin load: testLoad;\n\t\t\tin conditions: String;\n\t\t\tout mpgUrban: mpgUrban;\n\t\t\tout mpgHighway: mpgHighway;\n\t\t}\n\t\tsuccession flow mpgFlow from calculateFuelEconomy.mpgUrban to validateUrbanScenario.mpg;\n\t\tsuccession flow mpgFlow from calculateFuelEconomy.mpgHighway to validateHighwayScenario.mpg;\n\t\tsuccession flow loadFlow from calculateFuelEconomy.load to validateUrbanScenario.load;\n\t\tsuccession flow loadFlow from calculateFuelEconomy.load to validateHighwayScenario.load;\n\t}\n}",
    "package 'VehicleDynamicsSimulation' {\n\tattribute def vehicleMass;\n\tattribute def initialPosition;\n\tattribute def initialVelocity;\n\tattribute def powerOutputData;\n\tattribute def timeStep;\n\tattribute def accelerationSequence;\n\tattribute def velocityVariationSequence;\n\tattribute def displacementSequence;\n\tport def VehicleMassPort {\n\t\tout vehicleMass : vehicleMass;\n\t}\n\tport def InitialPositionPort {\n\t\tout initialPosition : initialPosition;\n\t}\n\tport def InitialVelocityPort {\n\t\tout initialVelocity : initialVelocity;\n\t}\n\tport def PowerOutputPort {\n\t\tout powerOutputData : powerOutputData;\n\t}\n\tport def TimeStepPort {\n\t\tout timeStep : timeStep;\n\t}\n\tport def AccelerationSequencePort {\n\t\tout accelerationSequence : accelerationSequence;\n\t}\n\tport def VelocityVariationSequencePort {\n\t\tout velocityVariationSequence : velocityVariationSequence;\n\t}\n\tport def DisplacementSequencePort {\n\t\tout displacementSequence : displacementSequence;\n\t}\n\tpart context {\n\t\tpart user {\n\t\t\tport vehicleMassPort: VehicleMassPort;\n\t\t\tport initialPositionPort: InitialPositionPort;\n\t\t\tport initialVelocityPort: InitialVelocityPort;\n\t\t\tport powerOutputPort: PowerOutputPort;\n\t\t\tport timeStepPort: TimeStepPort;\n\t\t\tperform simulateLongitudinalMotion.sendInputs {\n\t\t\t\tout vehicleMass = vehicleMassPort.vehicleMass;\n\t\t\t\tout initialPosition = initialPositionPort.initialPosition;\n\t\t\t\tout initialVelocity = initialVelocityPort.initialVelocity;\n\t\t\t\tout powerOutputData = powerOutputPort.powerOutputData;\n\t\t\t\tout timeStep = timeStepPort.timeStep;\n\t\t\t}\n\t\t}\n\t\tinterface userToSimulation connect user.vehicleMassPort to simulationSystem.vehicleMassPort, user.initialPositionPort to simulationSystem.initialPositionPort, user.initialVelocityPort to simulationSystem.initialVelocityPort, user.powerOutputPort to simulationSystem.powerOutputPort, user.timeStepPort to simulationSystem.timeStepPort {\n\t\t\tref flow references simulateLongitudinalMotion.inputFlow, simulateLongitudinalMotion.accelerationFlow, simulateLongitudinalMotion.velocityFlow, simulateLongitudinalMotion.positionFlow, simulateLongitudinalMotion.sequenceFlow;\n\t\t}\n\t\tpart simulationSystem {\n\t\t\tport vehicleMassPort: ~VehicleMassPort;\n\t\t\tport initialPositionPort: ~InitialPositionPort;\n\t\t\tport initialVelocityPort: ~InitialVelocityPort;\n\t\t\tport powerOutputPort: ~PowerOutputPort;\n\t\t\tport timeStepPort: ~TimeStepPort;\n\t\t\tperform simulateLongitudinalMotion.calculateAcceleration {\n\t\t\t\tin vehicleMass = vehicleMassPort.vehicleMass;\n\t\t\t\tin powerOutput = powerOutputPort.powerOutputData;\n\t\t\t\tin timeStep = timeStepPort.timeStep;\n\t\t\t\tout acceleration = accelerationPort.acceleration;\n\t\t\t}\n\t\t\tperform simulateLongitudinalMotion.updateVelocity {\n\t\t\t\tin acceleration = accelerationPort.acceleration;\n\t\t\t\tin initialVelocity = initialVelocityPort.initialVelocity;\n\t\t\t\tin timeStep = timeStepPort.timeStep;\n\t\t\t\tout velocity = velocityPort.velocity;\n\t\t\t}\n\t\t\tperform simulateLongitudinalMotion.updatePosition {\n\t\t\t\tin velocity = velocityPort.velocity;\n\t\t\t\tin initialPosition = initialPositionPort.initialPosition;\n\t\t\t\tin timeStep = timeStepPort.timeStep;\n\t\t\t\tout position = positionPort.position;\n\t\t\t}\n\t\t\tport accelerationPort: acceleration;\n\t\t\tport velocityPort: velocity;\n\t\t\tport positionPort: position;\n\t\t\tport outputPort: AccelerationSequencePort, VelocityVariationSequencePort, DisplacementSequencePort;\n\t\t\tperform simulateLongitudinalMotion.generateSequences {\n\t\t\t\tin acceleration = accelerationPort.acceleration;\n\t\t\t\tin velocity = velocityPort.velocity;\n\t\t\t\tin position = positionPort.position;\n\t\t\t\tout accelerationSequence = outputPort.accelerationSequence;\n\t\t\t\tout velocityVariationSequence = outputPort.velocityVariationSequence;\n\t\t\t\tout displacementSequence = outputPort.displacementSequence;\n\t\t\t}\n\t\t}\n\t}\n\taction simulateLongitudinalMotion {\n\t\taction sendInputs { \n\t\t\tout vehicleMass: vehicleMass; \n\t\t\tout initialPosition: initialPosition; \n\t\t\tout initialVelocity: initialVelocity; \n\t\t\tout powerOutputData: powerOutputData; \n\t\t\tout timeStep: timeStep; \n\t\t}\n\t\tsuccession flow inputFlow from sendInputs.vehicleMass to calculateAcceleration.vehicleMass;\n\t\tsuccession flow inputFlow2 from sendInputs.initialPosition to updatePosition.initialPosition;\n\t\tsuccession flow inputFlow3 from sendInputs.initialVelocity to updateVelocity.initialVelocity;\n\t\tsuccession flow inputFlow4 from sendInputs.powerOutputData to calculateAcceleration.powerOutput;\n\t\tsuccession flow inputFlow5 from sendInputs.timeStep to calculateAcceleration.timeStep;\n\t\taction calculateAcceleration { \n\t\t\tin vehicleMass; \n\t\t\tin powerOutput; \n\t\t\tin timeStep; \n\t\t\tout acceleration: acceleration; \n\t\t}\n\t\tsuccession flow accelerationFlow from calculateAcceleration.acceleration to updateVelocity.acceleration;\n\t\taction updateVelocity { \n\t\t\tin acceleration; \n\t\t\tin initialVelocity; \n\t\t\tin timeStep; \n\t\t\tout velocity: velocity; \n\t\t}\n\t\tsuccession flow velocityFlow from updateVelocity.velocity to updatePosition.velocity;\n\t\taction updatePosition { \n\t\t\tin velocity; \n\t\t\tin initialPosition; \n\t\t\tin timeStep; \n\t\t\tout position: position; \n\t\t}\n\t\tsuccession flow positionFlow from updatePosition.position to generateSequences.position;\n\t\taction generateSequences { \n\t\t\tin acceleration; \n\t\t\tin velocity; \n\t\t\tin position; \n\t\t\tout accelerationSequence: accelerationSequence; \n\t\t\tout velocityVariationSequence: velocityVariationSequence; \n\t\t\tout displacementSequence: displacementSequence; \n\t\t}\n\t}\n}",
    "package 'VehicleSystem' {\n\tattribute def totalMass;\n\tattribute def mass;\n\tattribute def steeringAngle;\n\tport def massPort {\n\t\tout mass: mass;\n\t}\n\tport def steeringPort {\n\t\tout steeringAngle: steeringAngle;\n\t}\n\tpart context {\n\t\tpart vehicle {\n\t\t\tattribute totalMass = 2500 kg;\n\t\t\tpart frontAxleAssembly;\n\t\t\tpart rearAxleAssembly;\n\t\t}\n\t\tpart frontAxleAssembly {\n\t\t\tattribute mass = 150 kg;\n\t\t\tpart frontWheel1;\n\t\t\tpart frontWheel2;\n\t\t\tpart frontAxle;\n\t\t}\n\t\tpart frontAxle {\n\t\t\tattribute mass;\n\t\t\tattribute steeringAngle;\n\t\t\tport massPort: massPort;\n\t\t\tport steeringPort: steeringPort;\n\t\t}\n\t\tpart rearAxleAssembly {\n\t\t\tattribute mass = 250 kg;\n\t\t\tpart rearWheel1;\n\t\t\tpart rearWheel2;\n\t\t\tpart rearAxle;\n\t\t}\n\t\tpart rearAxle {\n\t\t\tattribute mass;\n\t\t\tport massPort: massPort;\n\t\t}\n\t\tinterface vehicleToAxle connect vehicle.frontAxleAssembly.massPort.mass to frontAxleAssembly.mass;\n\t\tinterface vehicleToAxle connect vehicle.rearAxleAssembly.massPort.mass to rearAxleAssembly.mass;\n\t\tinterface frontAxleAssemblyToComponents connect frontAxleAssembly.frontWheel1.massPort.mass to mass;\n\t\tinterface frontAxleAssemblyToComponents connect frontAxleAssembly.frontWheel2.massPort.mass to mass;\n\t\tinterface frontAxleAssemblyToComponents connect frontAxleAssembly.frontAxle.massPort.mass to mass;\n\t\tinterface rearAxleAssemblyToComponents connect rearAxleAssembly.rearWheel1.massPort.mass to mass;\n\t\tinterface rearAxleAssemblyToComponents connect rearAxleAssembly.rearWheel2.massPort.mass to mass;\n\t\tinterface rearAxleAssemblyToComponents connect rearAxleAssembly.rearAxle.massPort.mass to mass;\n\t}\n\taction massAllocation {\n\t\taction calculateTotalMass { \n\t\t\tin mass: mass; \n\t\t\tout totalMass: totalMass; \n\t\t}\n\t\tsuccession flow frontAxleMassFlow from frontAxle.mass to calculateTotalMass.mass;\n\t\tsuccession flow rearAxleMassFlow from rearAxle.mass to calculateTotalMass.mass;\n\t\taction calculateFrontAxleAssemblyMass { \n\t\t\tin mass: mass; \n\t\t\tout assemblyMass: mass; \n\t\t}\n\t\tsuccession flow frontWheel1MassFlow from frontWheel1.mass to calculateFrontAxleAssemblyMass.mass;\n\t\tsuccession flow frontWheel2MassFlow from frontWheel2.mass to calculateFrontAxleAssemblyMass.mass;\n\t\tsuccession flow frontAxleMassFlow from frontAxle.mass to calculateFrontAxleAssemblyMass.mass;\n\t\taction calculateRearAxleAssemblyMass { \n\t\t\tin mass: mass; \n\t\t\tout assemblyMass: mass; \n\t\t}\n\t\tsuccession flow rearWheel1MassFlow from rearWheel1.mass to calculateRearAxleAssemblyMass.mass;\n\t\tsuccession flow rearWheel2MassFlow from rearWheel2.mass to calculateRearAxleAssemblyMass.mass;\n\t\tsuccession flow rearAxleMassFlow from rearAxle.mass to calculateRearAxleAssemblyMass.mass;\n\t}\n}",
    "package 'VehicleSafetySecuritySystem' {\n\tattribute def ComponentType;\n\tattribute def MandatoryStatus;\n\tport def SafetyComponentPort {\n\t\tout componentType : ComponentType;\n\t\tout mandatoryStatus : MandatoryStatus;\n\t}\n\tport def SecurityComponentPort {\n\t\tout componentType : ComponentType;\n\t}\n\tpart context {\n\t\tpart seatBelts {\n\t\t\tport componentPort: SafetyComponentPort;\n\t\t\tperform manageAndVisualize.collectMandatorySafety;\n\t\t}\n\t\tpart bumpers {\n\t\t\tport componentPort: SafetyComponentPort;\n\t\t\tperform manageAndVisualize.collectMandatorySafety;\n\t\t}\n\t\tpart airbags {\n\t\t\tport componentPort: SafetyComponentPort;\n\t\t\tperform manageAndVisualize.collectOptionalSafety;\n\t\t}\n\t\tpart antiLockBrakes {\n\t\t\tport componentPort: SafetyComponentPort;\n\t\t\tperform manageAndVisualize.collectOptionalSafety;\n\t\t}\n\t\tpart alarms {\n\t\t\tport componentPort: SecurityComponentPort;\n\t\t\tperform manageAndVisualize.collectSecurity;\n\t\t}\n\t\tpart keylessEntry {\n\t\t\tport componentPort: SecurityComponentPort;\n\t\t\tperform manageAndVisualize.collectSecurity;\n\t\t}\n\t\tinterface safetyInterface connect seatBelts.componentPort to managementSystem.safetyPort {\n\t\t\tref flow references manageAndVisualize.safetyFlow\n\t\t\t\tfrom source.componentType to target.componentType,\n\t\t\t\tfrom source.mandatoryStatus to target.mandatoryStatus;\n\t\t}\n\t\tinterface safetyInterface connect bumpers.componentPort to managementSystem.safetyPort {\n\t\t\tref flow references manageAndVisualize.safetyFlow\n\t\t\t\tfrom source.componentType to target.componentType,\n\t\t\t\tfrom source.mandatoryStatus to target.mandatoryStatus;\n\t\t}\n\t\tinterface safetyInterface connect airbags.componentPort to managementSystem.safetyPort {\n\t\t\tref flow references manageAndVisualize.safetyFlow\n\t\t\t\tfrom source.componentType to target.componentType,\n\t\t\t\tfrom source.mandatoryStatus to target.mandatoryStatus;\n\t\t}\n\t\tinterface safetyInterface connect antiLockBrakes.componentPort to managementSystem.safetyPort {\n\t\t\tref flow references manageAndVisualize.safetyFlow\n\t\t\t\tfrom source.componentType to target.componentType,\n\t\t\t\tfrom source.mandatoryStatus to target.mandatoryStatus;\n\t\t}\n\t\tinterface securityInterface connect alarms.componentPort to managementSystem.securityPort {\n\t\t\tref flow references manageAndVisualize.securityFlow\n\t\t\t\tfrom source.componentType to target.componentType;\n\t\t}\n\t\tinterface securityInterface connect keylessEntry.componentPort to managementSystem.securityPort {\n\t\t\tref flow references manageAndVisualize.securityFlow\n\t\t\t\tfrom source.componentType to target.componentType;\n\t\t}\n\t\tpart managementSystem {\n\t\t\tport safetyPort: ~SafetyComponentPort;\n\t\t\tport securityPort: ~SecurityComponentPort;\n\t\t\tperform manageAndVisualize.organizeAndVisualize;\n\t\t}\n\t}\n\taction manageAndVisualize {\n\t\taction collectMandatorySafety { out componentType = 'Safety'; out mandatoryStatus = 'Mandatory'; }\n\t\taction collectOptionalSafety { out componentType = 'Safety'; out mandatoryStatus = 'Optional'; }\n\t\taction collectSecurity { out componentType = 'Security'; }\n\t\tsuccession flow safetyFlow from collectMandatorySafety.componentType to organizeSafety.safetyComponents;\n\t\tsuccession flow safetyFlow from collectOptionalSafety.componentType to organizeSafety.safetyComponents;\n\t\tsuccession flow securityFlow from collectSecurity.componentType to organizeSecurity.securityComponents;\n\t\taction organizeSafety { in safetyComponents; in mandatoryStatus; out mandatorySafety; out optionalSafety; }\n\t\taction organizeSecurity { in securityComponents; out securityList; }\n\t\tsuccession flow organizeSafetyFlow from organizeSafety.mandatorySafety to visualizeTree.mandatorySafety;\n\t\tsuccession flow organizeSafetyFlow from organizeSafety.optionalSafety to visualizeTree.optionalSafety;\n\t\tsuccession flow organizeSecurityFlow from organizeSecurity.securityList to visualizeTree.security;\n\t\taction visualizeTree { in mandatorySafety; in optionalSafety; in security; out treeStructure; }\n\t\taction visualizeTable { in mandatorySafety; in optionalSafety; in security; out tableFormat; }\n\t}\n}",
    "package 'LayeredSystem' {\n\tattribute def x;\n\tattribute def y;\n\tattribute def z;\n\tz depends on x, y;\n\n\tport def AppServicePort {\n\t\tout command : Command;\n\t}\n\n\tport def ServiceDataPort {\n\t\tout dataRequest : DataRequest;\n\t\tin dataResponse : DataResponse;\n\t}\n\n\tport def DataPort {\n\t\tin dataRequest : DataRequest;\n\t\tout dataResponse : DataResponse;\n\t}\n\n\tpart context {\n\t\tpart application {\n\t\t\tport appServicePort: AppServicePort;\n\t\t\tperform handleRequest.sendCommand {\n\t\t\t\tout command = appServicePort.command;\n\t\t\t}\n\t\t}\n\n\t\tinterface appToService connect application.appServicePort to service.serviceAppPort {\n\t\t\tref flow references handleRequest.commandFlow\n\t\t\t\tfrom source.command to target.command;\n\t\t}\n\n\t\tpart service {\n\t\t\tport serviceAppPort: ~AppServicePort;\n\t\t\tport serviceDataPort: ServiceDataPort;\n\t\t\tperform handleRequest.processCommand {\n\t\t\t\tin command = serviceAppPort.command;\n\t\t\t\tout dataRequest = serviceDataPort.dataRequest;\n\t\t\t}\n\t\t\tperform handleRequest.computeZ {\n\t\t\t\tin x, y;\n\t\t\t\tout z;\n\t\t\t}\n\t\t}\n\n\t\tinterface serviceToData connect service.serviceDataPort to data.dataServicePort {\n\t\t\tref flow references handleRequest.dataRequestFlow\n\t\t\t\tfrom source.dataRequest to target.dataRequest;\n\t\t\tref flow references handleRequest.dataResponseFlow\n\t\t\t\tfrom source.dataResponse to target.dataResponse;\n\t\t}\n\n\t\tpart data {\n\t\t\tport dataServicePort: ~ServiceDataPort;\n\t\t\tperform handleRequest.storeRetrieveData {\n\t\t\t\tin dataRequest = dataServicePort.dataRequest;\n\t\t\t\tout dataResponse = dataServicePort.dataResponse;\n\t\t\t}\n\t\t}\n\t}\n\n\taction handleRequest {\n\t\taction sendCommand { out command: Command; }\n\t\tsuccession flow commandFlow from sendCommand.command to processCommand.command;\n\n\t\taction processCommand { in command; out dataRequest: DataRequest; in dataResponse: DataResponse; }\n\t\tsuccession flow dataRequestFlow from processCommand.dataRequest to storeRetrieveData.dataRequest;\n\t\tsuccession flow dataResponseFlow from storeRetrieveData.dataResponse to processCommand.dataResponse;\n\n\t\taction storeRetrieveData { in dataRequest; out dataResponse; }\n\n\t\taction computeZ { in x, y; out z; }\n\t\tsuccession flow xFlow from processCommand.dataResponse to computeZ.x;\n\t\tsuccession flow yFlow from processCommand.dataResponse to computeZ.y;\n\t}\n}",
    "package 'PowertrainTorqueSystem' {\n\tattribute def TorqueCmd;\n\tattribute def Torque;\n\tport def TorqueCmdPort {\n\t\tout torqueCmd : TorqueCmd;\n\t}\n\tport def TorqueOutputPort {\n\t\tout torque: Torque;\n\t}\n\tpart context {\n\t\tpart logicLayer {\n\t\t\tport torqueCmdPort: TorqueCmdPort;\n\t\t\tperform torqueGenerationRegion.generateTorqueCmd {\n\t\t\t\tout torqueCmd = torqueCmdPort.torqueCmd;\n\t\t\t}\n\t\t}\n\t\tinterface logicToPhysical connect logicLayer.torqueCmdPort to physicalLayer.torqueCmdPort {\n\t\t\tref flow references torqueGenerationRegion.torqueCmdFlow\n\t\t\t\tfrom source.torqueCmd to target.torqueCmd;\n\t\t}\n\t\tpart physicalLayer {\n\t\t\tport torqueCmdPort: ~TorqueCmdPort;\n\t\t\tperform torqueGenerationRegion.produceTorque {\n\t\t\t\tin torqueCmd = torqueCmdPort.torqueCmd;\n\t\t\t\tout torque = engine.torqueOutputPort.torque;\n\t\t\t}\n\t\t\tpart engine {\n\t\t\t\tport torqueOutputPort: TorqueOutputPort;\n\t\t\t}\n\t\t}\n\t}\n\taction torqueGenerationRegion {\n\t\taction generateTorqueCmd { out torqueCmd: TorqueCmd; }\n\t\tsuccession flow torqueCmdFlow from generateTorqueCmd.torqueCmd to produceTorque.torqueCmd;\n\t\taction produceTorque { in torqueCmd: TorqueCmd; out torque: Torque; }\n\t\tpost torque > 0;\n\t}\n}",
    "package 'PowerSystem' {\n\tattribute def Power;\n\tattribute def Torque;\n\tport def TorqueCmdPort {\n\t\tout torqueCmd : Torque;\n\t}\n\tport def PowerPort {\n\t\tout power: Power;\n\t}\n\tpart context {\n\t\tpart system {\n\t\t\tport torqueCmdPort: TorqueCmdPort;\n\t\t\tperform powerGeneration.outputPower {\n\t\t\t\tout power = powerPort.power;\n\t\t\t}\n\t\t}\n\t\tinterface systemToTorqueGenerator connect system.torqueCmdPort to torqueGenerator.torqueCmdPort {\n\t\t\tref flow references powerGeneration.torqueCmdFlow\n\t\t\t\tfrom source.torqueCmd to target.torqueCmd;\n\t\t}\n\t\tpart torqueGenerator {\n\t\t\tport torqueCmdPort: ~TorqueCmdPort;\n\t\t\tperform powerGeneration.generateTorque {\n\t\t\t\tout torqueCmd = torqueCmdPort.torqueCmd;\n\t\t\t}\n\t\t}\n\t\tinterface torqueGeneratorToPowertrain connect torqueGenerator.enginePowerPort to powertrain.engineInputPort {\n\t\t\tref flow references powerGeneration.powerFlow\n\t\t\t\tfrom source.power to target.power;\n\t\t}\n\t\tpart powertrain {\n\t\t\tport engineInputPort: PowerPort;\n\t\t\tport systemPowerPort: ~PowerPort;\n\t\t\tperform powerGeneration.transmitPower {\n\t\t\t\tin power = engineInputPort.power;\n\t\t\t\tout power = systemPowerPort.power;\n\t\t\t}\n\t\t}\n\t\tinterface powertrainToEngine connect powertrain.engineInputPort to engine.powerOutPort {\n\t\t\tref flow references powerGeneration.powerFlow\n\t\t\t\tfrom source.power to target.power;\n\t\t}\n\t\tpart engine {\n\t\t\tport powerOutPort: ~PowerPort;\n\t\t\tperform powerGeneration.executeTorqueGeneration {\n\t\t\t\tin torqueCmd = torqueGenerator.torqueCmdPort.torqueCmd;\n\t\t\t\tout power = powerOutPort.power;\n\t\t\t}\n\t\t}\n\t}\n\taction powerGeneration {\n\t\taction generateTorque { out torqueCmd: Torque; }\n\t\tsuccession flow torqueCmdFlow from generateTorque.torqueCmd to executeTorqueGeneration.torqueCmd;\n\t\taction executeTorqueGeneration { in torqueCmd: Torque; out power: Power; }\n\t\tsuccession flow powerFlow from executeTorqueGeneration.power to transmitPower.power;\n\t\taction transmitPower { in power: Power; out power: Power; }\n\t\tsuccession flow powerFlow from transmitPower.power to outputPower.power;\n\t\taction outputPower { in power: Power; out power: Power; }\n\t}\n}",
    "package 'VehicleSafetyAndAntiTheftFunctionCatalogue' {\n\tattribute def SafetyStatus;\n\tattribute def AntiTheftStatus;\n\tport def SafetyCommandPort {\n\t\tout safetyCommand : SafetyStatus;\n\t}\n\tport def AntiTheftCommandPort {\n\t\tout antiTheftCommand : AntiTheftStatus;\n\t}\n\tpart context {\n\t\tpart vehicle {\n\t\t\tpart basicSafety {\n\t\t\t\tpart frontSeatBelts;\n\t\t\t\tpart bumpers;\n\t\t\t}\n\t\t\tpart safetyFeatures {\n\t\t\t\tpart driverAirbag;\n\t\t\t\tpart antiLockBrakingSystem;\n\t\t\t}\n\t\t\tpart antiTheft {\n\t\t\t\tpart alarmSystem;\n\t\t\t\tpart keylessEntrySystem;\n\t\t\t}\n\t\t\tpart combined {\n\t\t\t\tpart multiFunctionComponents;\n\t\t\t}\n\t\t}\n\t}\n\taction configureSafetyAndAntiTheft {\n\t\taction ensureBasicSafety { out safetyCommand: SafetyStatus; }\n\t\taction activateDriverAirbag { in safetyCommand: SafetyStatus; }\n\t\taction engageAntiLockBraking { in safetyCommand: SafetyStatus; }\n\t\taction triggerAlarm { out antiTheftCommand: AntiTheftStatus; }\n\t\taction enableKeylessEntry { out antiTheftCommand: AntiTheftStatus; }\n\t\taction enhanceSafetyAndAntiTheft { \n\t\t\tin safetyCommand: SafetyStatus; \n\t\t\tin antiTheftCommand: AntiTheftStatus; \n\t\t}\n\t}\n}",
    "package 'FuelSystem' {\n\tattribute def Fuel;\n\tattribute def TemperatureData;\n\tport def FuelSupplyPort {\n\t\tout fuel: Fuel;\n\t}\n\tport def FuelReturnPort {\n\t\tin fuel: Fuel;\n\t}\n\tport def TemperatureSensorPort {\n\t\tout temperatureData: TemperatureData;\n\t}\n\tport def TemperatureDataPort {\n\t\tout temperatureData: TemperatureData;\n\t}\n\tpart context {\n\t\tpart vehicle {\n\t\t\tport temperatureDataPort: TemperatureDataPort;\n\t\t\tperform fuelSupplyChain.returnExcessFuel {\n\t\t\t\tout temperatureData = temperatureDataPort.temperatureData;\n\t\t\t}\n\t\t}\n\t\tinterface vehicleToFuelSystem connect vehicle.temperatureDataPort to fuelTankAssembly.temperatureSensorPort {\n\t\t\tref flow references fuelSupplyChain.temperatureFlow\n\t\t\t\tfrom source.temperatureData to target.temperatureData;\n\t\t}\n\t\tpart fuelTankAssembly {\n\t\t\tport temperatureSensorPort: ~TemperatureSensorPort;\n\t\t\tperform fuelSupplyChain.pressurizeAndDeliverFuel {\n\t\t\t\tout fuel = fuelPump.supplyPort.fuel;\n\t\t\t\tin temperatureData = temperatureSensorPort.temperatureData;\n\t\t\t}\n\t\t\tperform fuelSupplyChain.returnExcessFuel {\n\t\t\t\tin fuel = fuelPump.returnPort.fuel;\n\t\t\t\tout temperatureData = temperatureSensorPort.temperatureData;\n\t\t\t}\n\t\t}\n\t\tpart fuelPump {\n\t\t\tport supplyPort: FuelSupplyPort;\n\t\t\tport returnPort: FuelReturnPort;\n\t\t}\n\t\tpart fuelTank {\n\t\t\tport fuelInPort: FuelReturnPort;\n\t\t\tport fuelOutPort: FuelSupplyPort;\n\t\t}\n\t\tinterface tankToPump connect fuelTank.fuelOutPort to fuelPump.supplyPort {\n\t\t\tref flow references fuelSupplyChain.fuelFlow\n\t\t\t\tfrom source.fuel to target.fuel;\n\t\t}\n\t\tinterface pumpToTank connect fuelPump.returnPort to fuelTank.fuelInPort {\n\t\t\tref flow references fuelSupplyChain.returnFlow\n\t\t\t\tfrom source.fuel to target.fuel;\n\t\t}\n\t\tpart fuelConsumingUnits {\n\t\t\tport inletPort: FuelSupplyPort;\n\t\t\tport outletPort: FuelReturnPort;\n\t\t}\n\t\tinterface pumpToConsumers connect fuelPump.supplyPort to fuelConsumingUnits.inletPort {\n\t\t\tref flow references fuelSupplyChain.fuelFlow\n\t\t\t\tfrom source.fuel to target.fuel;\n\t\t}\n\t\tinterface consumersToPump connect fuelConsumingUnits.outletPort to fuelPump.returnPort {\n\t\t\tref flow references fuelSupplyChain.returnFlow\n\t\t\t\tfrom source.fuel to target.fuel;\n\t\t}\n\t}\n\taction fuelSupplyChain {\n\t\taction pressurizeAndDeliverFuel { \n\t\t\tin temperatureData: TemperatureData; \n\t\t\tout fuel: Fuel; \n\t\t}\n\t\tsuccession flow fuelFlow from pressurizeAndDeliverFuel.fuel to deliverFuelToConsumers.fuel;\n\t\taction deliverFuelToConsumers { \n\t\t\tin fuel; \n\t\t\tout fuel; \n\t\t}\n\t\tsuccession flow returnFlow from deliverFuelToConsumers.fuel to returnExcessFuel.fuel;\n\t\taction returnExcessFuel { \n\t\t\tin fuel: Fuel; \n\t\t\tout temperatureData: TemperatureData; \n\t\t}\n\t\tsuccession flow temperatureFlow from returnExcessFuel.temperatureData to transmitTemperatureData.temperatureData;\n\t\taction transmitTemperatureData { \n\t\t\tin temperatureData: TemperatureData; \n\t\t}\n\t}\n}",
    "package 'VehicleSafetySecurity' {\n\tattribute def SafetyClassification;\n\tattribute def SecurityClassification;\n\tattribute def ComplianceStatus;\n\n\tpart context {\n\t\tpart vehicle {\n\t\t\tpart interior {\n\t\t\t\tpart seatBelts [2];\n\t\t\t\tpart airbag [0..1];\n\t\t\t\tpart antiTheftAlarm;\n\t\t\t}\n\t\t\tpart body {\n\t\t\t\tpart bumper;\n\t\t\t\tpart keylessEntry;\n\t\t\t}\n\t\t\tpart chassis {\n\t\t\t\tpart wheels [2];\n\t\t\t\tpart absSystems [0..2];\n\t\t\t}\n\t\t\tperform safetySecurityManagement.classifySafetySecurityComponents {\n\t\t\t\tin seatBelts = interior.seatBelts;\n\t\t\t\tin airbag = interior.airbag;\n\t\t\t\tin antiTheftAlarm = interior.antiTheftAlarm;\n\t\t\t\tin bumper = body.bumper;\n\t\t\t\tin keylessEntry = body.keylessEntry;\n\t\t\t\tin wheels = chassis.wheels;\n\t\t\t\tin absSystems = chassis.absSystems;\n\t\t\t}\n\t\t\tperform safetySecurityManagement.checkCompliance {\n\t\t\t\tin safetyClassification = classifySafetySecurityComponents.safetyClassification;\n\t\t\t\tin securityClassification = classifySafetySecurityComponents.securityClassification;\n\t\t\t}\n\t\t}\n\t}\n\n\taction safetySecurityManagement {\n\t\taction classifySafetySecurityComponents {\n\t\t\tin seatBelts: SeatBelts [2];\n\t\t\tin airbag: Airbag [0..1];\n\t\t\tin antiTheftAlarm: AntiTheftAlarm;\n\t\t\tin bumper: Bumper;\n\t\t\tin keylessEntry: KeylessEntry;\n\t\t\tin wheels: Wheels [2];\n\t\t\tin absSystems: ABSsystems [0..2];\n\t\t\tout safetyClassification: SafetyClassification;\n\t\t\tout securityClassification: SecurityClassification;\n\t\t}\n\t\tsuccession flow classificationFlow from classifySafetySecurityComponents.safetyClassification to checkCompliance.safetyClassification;\n\t\tsuccession flow classificationFlow2 from classifySafetySecurityComponents.securityClassification to checkCompliance.securityClassification;\n\t\taction checkCompliance {\n\t\t\tin safetyClassification: SafetyClassification;\n\t\t\tin securityClassification: SecurityClassification;\n\t\t\tout complianceStatus: ComplianceStatus;\n\t\t}\n\t}\n}",
    "package 'VehicleSafetySecurity' {\n\tattribute def AlarmSignal;\n\tattribute def KeySignal;\n\tattribute def AirbagDeployment;\n\tattribute def SeatbeltEngagement;\n\tattribute def BumperImpact;\n\n\tport def AlarmTriggerPort {\n\t\tin trigger: AlarmSignal;\n\t}\n\tport def KeyEntryPort {\n\t\tin key: KeySignal;\n\t}\n\tport def AirbagPort {\n\t\tout deploy: AirbagDeployment;\n\t}\n\tport def SeatbeltPort {\n\t\tout engage: SeatbeltEngagement;\n\t}\n\tport def BumperPort {\n\t\tin impact: BumperImpact;\n\t}\n\n\tpart context {\n\t\tpart interior {\n\t\t\tpart alarmSystem {\n\t\t\t\tport trigger: AlarmTriggerPort;\n\t\t\t\tperform safetySecurityRegion.triggerAlarm {\n\t\t\t\t\tin trigger = trigger.trigger;\n\t\t\t\t}\n\t\t\t}\n\t\t\tpart seatBelts {\n\t\t\t\tport engage: SeatbeltPort;\n\t\t\t\tperform safetySecurityRegion.activateSeatbelts {\n\t\t\t\t\tout engage = engage.engage;\n\t\t\t\t}\n\t\t\t}\n\t\t\tpart frontRowSeats;\n\t\t\tpart driverAirbag {\n\t\t\t\tport deploy: AirbagPort;\n\t\t\t\tperform safetySecurityRegion.deployAirbag {\n\t\t\t\t\tout deploy = deploy.deploy;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tpart bodyAssembly {\n\t\t\tpart vehicleBody;\n\t\t\tpart bumper {\n\t\t\t\tport impact: BumperPort;\n\t\t\t\tperform safetySecurityRegion.absorbImpact {\n\t\t\t\t\tin impact = impact.impact;\n\t\t\t\t}\n\t\t\t}\n\t\t\tpart keylessEntry {\n\t\t\t\tport key: KeyEntryPort;\n\t\t\t\tperform safetySecurityRegion.processKeylessEntry {\n\t\t\t\t\tin key = key.key;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tinterface keylessToAlarm connect bodyAssembly.keylessEntry.key to interior.alarmSystem.trigger {\n\t\t\tref flow references safetySecurityRegion.keylessToAlarmFlow\n\t\t\t\tfrom source.key to target.trigger;\n\t\t}\n\t\tinterface bumperToAirbag connect bodyAssembly.bumper.impact to interior.driverAirbag.deploy {\n\t\t\tref flow references safetySecurityRegion.impactToAirbagFlow\n\t\t\t\tfrom source.impact to target.deploy;\n\t\t}\n\t}\n\n\taction safetySecurityRegion {\n\t\taction processKeylessEntry { in key: KeySignal; }\n\t\taction triggerAlarm { in trigger: AlarmSignal; }\n\t\taction deployAirbag { out deploy: AirbagDeployment; }\n\t\taction activateSeatbelts { out engage: SeatbeltEngagement; }\n\t\taction absorbImpact { in impact: BumperImpact; }\n\n\t\tsuccession flow keylessToAlarmFlow from processKeylessEntry.key to triggerAlarm.trigger;\n\t\tsuccession flow impactToAirbagFlow from absorbImpact.impact to deployAirbag.deploy;\n\t}\n}",
    "package 'InformationSecurityManagement' {\n\tattribute def SecurityClassification;\n\tattribute def SecurityLabel;\n\tport def ClassificationPort {\n\t\tout classification: SecurityClassification;\n\t}\n\tport def LabelDisplayPort {\n\t\tout label: SecurityLabel;\n\t}\n\tpart context {\n\t\tpart component {\n\t\t\tport classificationPort: ClassificationPort;\n\t\t\tperform classifyComponent.assignClassification {\n\t\t\t\tout classification = classificationPort.classification;\n\t\t\t}\n\t\t}\n\t\tinterface componentToSecurityManager connect component.classificationPort to securityManager.classificationPort {\n\t\t\tref flow references classifyComponent.classificationFlow\n\t\t\t\tfrom source.classification to target.classification;\n\t\t}\n\t\tpart securityManager {\n\t\t\tport classificationPort: ~ClassificationPort;\n\t\t\tperform classifyComponent.processClassification {\n\t\t\t\tin classification = classificationPort.classification;\n\t\t\t\tout label = labelDisplayPort.label;\n\t\t\t}\n\t\t\tport labelDisplayPort: LabelDisplayPort;\n\t\t}\n\t\tpart securityLabelDisplay {\n\t\t\tport labelDisplayPort: ~LabelDisplayPort;\n\t\t\tperform classifyComponent.displayLabel {\n\t\t\t\tin label = labelDisplayPort.label;\n\t\t\t}\n\t\t}\n\t}\n\taction classifyComponent {\n\t\taction assignClassification { out classification: SecurityClassification; }\n\t\tsuccession flow classificationFlow from assignClassification.classification to processClassification.classification;\n\t\taction processClassification { in classification: SecurityClassification; out label: SecurityLabel; }\n\t\tsuccession flow labelFlow from processClassification.label to displayLabel.label;\n\t\taction displayLabel { in label: SecurityLabel; }\n\t}\n}",
    "package 'AutomotiveECU' {  \n\tattribute def VehicleState;  \n\tattribute def EngineState;  \n\tattribute def SensorData;  \n\tattribute def Message;  \n  \n\tport def BusIFPort {  \n\t\tout sendMsg : Message;  \n\t\tin receiveMsg : Message;  \n\t}  \n  \n\tport def SensorIFPort {  \n\t\tout sensorData : SensorData;  \n\t}  \n  \n\tpart context {  \n\t\tpart vcu {  \n\t\t\tport busIFPort: BusIFPort;  \n\t\t\tport sensorIFPort: SensorIFPort;  \n\t\t\tperform controlActions.monitorVehicleState {  \n\t\t\t\tout vehicleState = vcu.vehicleState;  \n\t\t\t}  \n\t\t\tperform controlActions.sendVCUCommand {  \n\t\t\t\tout sendMsg = busIFPort.sendMsg;  \n\t\t\t}  \n\t\t}  \n  \n\t\tinterface vcuToBusIF connect vcu.busIFPort to vcuBusIF.busIFPort {  \n\t\t\tref flow references controlActions.vcuCmdFlow  \n\t\t\t\tfrom source.sendMsg to target.receiveMsg;  \n\t\t}  \n  \n\t\tpart vcuBusIF {  \n\t\t\tport busIFPort: ~BusIFPort;  \n\t\t\tperform controlActions.transmitVCUMessage {  \n\t\t\t\tin receiveMsg = busIFPort.receiveMsg;  \n\t\t\t\tout sendMsg = canBus.busIFPort1.sendMsg;  \n\t\t\t}  \n\t\t}  \n  \n\t\tinterface busIFToCAN connect vcuBusIF.busIFPort to canBus.busIFPort1 {  \n\t\t\tref flow references controlActions.vcuMsgFlow  \n\t\t\t\tfrom source.sendMsg to target.receiveMsg;  \n\t\t}  \n  \n\t\tpart ecu {  \n\t\t\tport busIFPort: BusIFPort;  \n\t\t\tport sensorIFPort: SensorIFPort;  \n\t\t\tperform controlActions.monitorEngineState {  \n\t\t\t\tout engineState = ecu.engineState;  \n\t\t\t}  \n\t\t\tperform controlActions.sendECUCommand {  \n\t\t\t\tout sendMsg = busIFPort.sendMsg;  \n\t\t\t}  \n\t\t}  \n  \n\t\tinterface ecuToBusIF connect ecu.busIFPort to ecuBusIF.busIFPort {  \n\t\t\tref flow references controlActions.ecuCmdFlow  \n\t\t\t\tfrom source.sendMsg to target.receiveMsg;  \n\t\t}  \n  \n\t\tpart ecuBusIF {  \n\t\t\tport busIFPort: ~BusIFPort;  \n\t\t\tperform controlActions.transmitECUMessage {  \n\t\t\t\tin receiveMsg = busIFPort.receiveMsg;  \n\t\t\t\tout sendMsg = canBus.busIFPort2.sendMsg;  \n\t\t\t}  \n\t\t}  \n  \n\t\tinterface busIFToCAN2 connect ecuBusIF.busIFPort to canBus.busIFPort2 {  \n\t\t\tref flow references controlActions.ecuMsgFlow  \n\t\t\t\tfrom source.sendMsg to target.receiveMsg;  \n\t\t}  \n  \n\t\tpart canBus {  \n\t\t\tport busIFPort1: ~BusIFPort;  \n\t\t\tport busIFPort2: ~BusIFPort;  \n\t\t\tport reservedSensorPort: SensorIFPort;  \n\t\t}  \n\t}  \n  \n\taction controlActions {  \n\t\taction monitorVehicleState { out vehicleState: VehicleState; }  \n\t\taction monitorEngineState { out engineState: EngineState; }  \n  \n\t\tsuccession flow vcuCmdFlow from monitorVehicleState.vehicleState to sendVCUCommand.input;  \n\t\taction sendVCUCommand { in input: VehicleState; out sendMsg: Message; }  \n  \n\t\tsuccession flow vcuMsgFlow from sendVCUCommand.sendMsg to transmitVCUMessage.receiveMsg;  \n\t\taction transmitVCUMessage { in receiveMsg: Message; out sendMsg: Message; }  \n  \n\t\tsuccession flow ecuCmdFlow from monitorEngineState.engineState to sendECUCommand.input;  \n\t\taction sendECUCommand { in input: EngineState; out sendMsg: Message; }  \n  \n\t\tsuccession flow ecuMsgFlow from sendECUCommand.sendMsg to transmitECUMessage.receiveMsg;  \n\t\taction transmitECUMessage { in receiveMsg: Message; out sendMsg: Message; }  \n\t}  \n}",
    "package 'BloodGlucoseMeter' {\n\tattribute def BatteryStatus;\n\tattribute def Alert;\n\tattribute def Measurement;\n\tattribute def EmergencyResponse;\n\n\tport def BatteryStatusPort {\n\t\tin batteryStatus: BatteryStatus;\n\t}\n\tport def AlertPort {\n\t\tout alert: Alert;\n\t}\n\tport def MeasurementPort {\n\t\tout measurement: Measurement;\n\t}\n\tport def EmergencyResponsePort {\n\t\tout emergencyResponse: EmergencyResponse;\n\t}\n\n\tpart context {\n\t\tpart user {\n\t\t\tport alertPort: AlertPort;\n\t\t\tperform batteryMonitoring.sendAlert {\n\t\t\t\tin alert = alertPort.alert;\n\t\t\t}\n\t\t}\n\t\tinterface userToMeter connect user.alertPort to meter.alertPort {\n\t\t\tref flow references batteryMonitoring.alertFlow\n\t\t\t\tfrom source.alert to target.alert;\n\t\t}\n\t\tpart meter {\n\t\t\tport batteryStatusPort: BatteryStatusPort;\n\t\t\tport alertPort: ~AlertPort;\n\t\t\tport measurementPort: MeasurementPort;\n\t\t\tperform batteryMonitoring.detectBatteryStatus {\n\t\t\t\tin batteryStatus = batteryStatusPort.batteryStatus;\n\t\t\t}\n\t\t\tperform measurementProcess.measureBloodGlucose {\n\t\t\t\tin batteryStatus = batteryStatusPort.batteryStatus;\n\t\t\t\tout measurement = measurementPort.measurement;\n\t\t\t}\n\t\t}\n\t\tinterface meterToEmergency connect meter.alertPort to emergencyResponseSystem.alertPort {\n\t\t\tref flow references batteryMonitoring.alertFlow\n\t\t\t\tfrom source.alert to target.alert;\n\t\t}\n\t\tinterface meterToEmergencyMeasurement connect meter.measurementPort to emergencyResponseSystem.measurementPort {\n\t\t\tref flow references measurementProcess.measurementFlow\n\t\t\t\tfrom source.measurement to target.measurement;\n\t\t}\n\t\tpart emergencyResponseSystem {\n\t\t\tport alertPort: ~AlertPort;\n\t\t\tport measurementPort: ~MeasurementPort;\n\t\t\tport emergencyResponsePort: EmergencyResponsePort;\n\t\t\tperform measurementProcess.monitorMeasurement {\n\t\t\t\tin measurement = measurementPort.measurement;\n\t\t\t\tout abnormality = handleEmergency.abnormality;\n\t\t\t}\n\t\t\tperform emergencyHandling.handleEmergency {\n\t\t\t\tin alert = alertPort.alert;\n\t\t\t\tin abnormality = monitorMeasurement.abnormality;\n\t\t\t\tout emergencyResponse = emergencyResponsePort.emergencyResponse;\n\t\t\t}\n\t\t}\n\t}\n\n\taction batteryMonitoring {\n\t\taction detectBatteryStatus { in batteryStatus: BatteryStatus; }\n\t\tsuccession flow alertFlow from detectBatteryStatus.batteryStatus to sendAlert.batteryStatus;\n\t\taction sendAlert { in batteryStatus; out alert: Alert; }\n\t}\n\taction measurementProcess {\n\t\taction measureBloodGlucose { in batteryStatus: BatteryStatus; out measurement: Measurement; }\n\t\tsuccession flow measurementFlow from measureBloodGlucose.measurement to monitorMeasurement.measurement;\n\t\taction monitorMeasurement { in measurement; out abnormality: Boolean; }\n\t}\n\taction emergencyHandling {\n\t\taction handleEmergency { in alert: Alert; in abnormality: Boolean; out emergencyResponse: EmergencyResponse; }\n\t}\n}",
    "package 'ScientificConstants' {\n\tattribute def e;\n\tattribute def pi;\n\tattribute def speedOfLight;\n\tattribute def fineStructureConstant;\n\tattribute def electronToProtonMassRatio;\n\tattribute def standardGravitationalAcceleration;\n\tattribute def amplifierGainCoefficient;\n\tpart context {\n\t\tpart constantsProvider {\n\t\t\tattribute e : Real = 2.71828182845904523536;\n\t\t\tattribute pi : Real = 3.14159265358979323846;\n\t\t\tattribute speedOfLight : Real = 299792458.0 unit 'm/s';\n\t\t\tattribute fineStructureConstant : Real = 0.0072973525664 unit dimensionless;\n\t\t\tattribute electronToProtonMassRatio : Real = 1836.15267343 unit dimensionless;\n\t\t\tattribute standardGravitationalAcceleration : Real = 9.80665 unit 'm/s^2';\n\t\t\tattribute amplifierGainCoefficient : Real = 100.0 unit 'V/V';\n\t\t}\n\t}\n}",
    "package 'AutomotiveComponents' {\n\tattribute def Manufacturer;\n\tattribute def RimDiameter;\n\tattribute def Width;\n\tattribute def Country;\n\tpart def Tire {\n\t\tproperty manufacturer: Manufacturer;\n\t\tproperty rimDiameter: RimDiameter;\n\t\tproperty width: Width;\n\t\tproperty country: Country;\n\t}\n\tpart context {\n\t\tpart michelinTire: Tire {\n\t\t\tmanufacturer = \"Michelin\";\n\t\t\trimDiameter = 18.0;\n\t\t\twidth = 245;\n\t\t\tcountry = \"France\";\n\t\t}\n\t\tpart pirelliTire: Tire {\n\t\t\tmanufacturer = \"Pirelli\";\n\t\t\trimDiameter = 17.0;\n\t\t\twidth = 225;\n\t\t\tcountry = \"Italy\";\n\t\t}\n\t}\n}",
    "package 'AutomotiveComponentModel' {\n    unit def kg = SI::kilogram;\n    unit def lb = Imperial::pound_mass;\n    conversion def kgToLb from kg to lb { factor: 2.20462; }\n\n    unit def m = SI::meter;\n    unit def ft = Imperial::foot;\n    conversion def mToft from m to ft { factor: 3.28084; }\n\n    unit def mm = SI::millimeter;\n    unit def in = Imperial::inch;\n    conversion def mmToin from mm to in { factor: 0.039370; }\n    conversion def inTomm from in to mm { factor: 25.4; }\n\n    attribute def Mass with unit kg, lb;\n    attribute def Length with unit m, ft;\n    attribute def HubDiameter with unit in, mm;\n    attribute def Width with unit mm, in;\n    attribute def TireHeight with unit mm, in;\n    attribute def OuterDiameter with unit mm, in;\n\n    part context {\n        part vehicle {\n            attribute mass: 1200 kg;\n            attribute length: 4.82 m;\n            part frontWheels {\n                part leftWheel {\n                    attribute hubDiameter: 18 in;\n                    attribute width: 245 mm;\n                    attribute outerDiameter: OuterDiameter;\n                    part tire {\n                        attribute height: TireHeight;\n                    }\n                    perform calculateWheelDimensions {\n                        in hubDiameter = this.hubDiameter;\n                        in tireHeight = tire.height;\n                        out outerDiameter = this.outerDiameter;\n                    }\n                }\n                part rightWheel {\n                    attribute hubDiameter: 18 in;\n                    attribute width: 245 mm;\n                    attribute outerDiameter: OuterDiameter;\n                    part tire {\n                        attribute height: TireHeight;\n                    }\n                    perform calculateWheelDimensions {\n                        in hubDiameter = this.hubDiameter;\n                        in tireHeight = tire.height;\n                        out outerDiameter = this.outerDiameter;\n                    }\n                }\n            }\n        }\n    }\n\n    action calculateWheelDimensions {\n        in hubDiameter: HubDiameter;\n        in tireHeight: TireHeight;\n        out outerDiameter: OuterDiameter;\n    }\n\n    succession flow leftHubFlow from vehicle.frontWheels.leftWheel.hubDiameter to calculateWheelDimensions.hubDiameter;\n    succession flow leftTireFlow from vehicle.frontWheels.leftWheel.tire.height to calculateWheelDimensions.tireHeight;\n    succession flow leftOuterFlow from calculateWheelDimensions.outerDiameter to vehicle.frontWheels.leftWheel.outerDiameter;\n\n    succession flow rightHubFlow from vehicle.frontWheels.rightWheel.hubDiameter to calculateWheelDimensions.hubDiameter;\n    succession flow rightTireFlow from vehicle.frontWheels.rightWheel.tire.height to calculateWheelDimensions.tireHeight;\n    succession flow rightOuterFlow from calculateWheelDimensions.outerDiameter to vehicle.frontWheels.rightWheel.outerDiameter;\n}",
    "package 'VehiclePowertrain' {\n\tattribute def isHighPerformance : Boolean;\n\tattribute def CylinderType : String;\n\tattribute def TransmissionType : String;\n\tpart context {\n\t\tpart engine {\n\t\t\tattribute cylinderType : CylinderType;\n\t\t}\n\t\tpart transmission {\n\t\t\tattribute transmissionType : TransmissionType;\n\t\t}\n\t\tconstraint highPerformanceEngine {\n\t\t\tif isHighPerformance then engine.cylinderType = \"six\" else engine.cylinderType = \"four\";\n\t\t}\n\t\tconstraint validCombination {\n\t\t\t(engine.cylinderType = \"four\" and transmission.transmissionType = \"manual\") or (engine.cylinderType = \"six\" and transmission.transmissionType = \"automatic\");\n\t\t}\n\t}\n}",
    "package 'AutomotiveComponents' {\n\tattribute def CarMass = 1200 kg;\n\tattribute def CarLength = 4.82 m;\n\tattribute def TreadDepthMin = 3.5 mm;\n\tattribute def TreadDepthDefault = 6.0 mm;\n\tattribute def RimDiameter = 18 in;\n\tattribute def TireWidth = 245 mm;\n\tattribute def TireHeight = 45 mm;\n\tattribute def BrakeDiscRadius = 95 mm;\n\t\n\tpart context {\n\t\tpart car {\n\t\t\tproperty mass: CarMass;\n\t\t\tproperty length: CarLength;\n\t\t\tpart wheelAssemblies[*] {\n\t\t\t\tpart wheel {\n\t\t\t\t\tpart rim {\n\t\t\t\t\t\tproperty diameter: RimDiameter;\n\t\t\t\t\t}\n\t\t\t\t\tpart tire {\n\t\t\t\t\t\tproperty width: TireWidth;\n\t\t\t\t\t\tproperty height: TireHeight;\n\t\t\t\t\t\tproperty treadDepth: TreadDepthDefault;\n\t\t\t\t\t}\n\t\t\t\t\tproperty outerDiameter = rim.diameter * 25.4 + 2 * tire.height;\n\t\t\t\t}\n\t\t\t\tpart brakeDisc {\n\t\t\t\t\tproperty radius: BrakeDiscRadius;\n\t\t\t\t\tproperty diameter = 2 * radius;\n\t\t\t\t}\n\t\t\t\tconstraint brakeDiscFitment {\n\t\t\t\t\tparameter discDiameter = brakeDisc.diameter;\n\t\t\t\t\tparameter wheelOD = wheel.outerDiameter;\n\t\t\t\t\tdiscDiameter < wheelOD;\n\t\t\t\t}\n\t\t\t\tconstraint treadDepthConstraint {\n\t\t\t\t\tparameter minTread = TreadDepthMin;\n\t\t\t\t\ttire.treadDepth >= minTread;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n}",
    "package 'AutomotiveFuelSystem' {\n\tattribute def Fuel;\n\tattribute def Temperature;\n\tport def FuelOutletPort {\n\t\tout fuel: Fuel;\n\t\tout temperature: Temperature;\n\t}\n\tport def FuelInletPort {\n\t\tin fuel: Fuel;\n\t}\n\tport def FuelPumpPort {\n\t\tin fuel: Fuel;\n\t\tout fuel: Fuel;\n\t\tin returnFuel: Fuel;\n\t\tin temperature: Temperature;\n\t}\n\tport def EngineFuelPort {\n\t\tin fuel: Fuel;\n\t\tout returnFuel: Fuel;\n\t}\n\tpart context {\n\t\tpart fuelTankAssembly {\n\t\t\tport outletPort: FuelOutletPort;\n\t\t\tperform manageFuelDelivery {\n\t\t\t\tout fuel = outletPort.fuel;\n\t\t\t\tout temperature = outletPort.temperature;\n\t\t\t}\n\t\t}\n\t\tinterface assemblyToPump connect fuelTankAssembly.outletPort to fuelPump.fuelPumpPort {\n\t\t\tref flow references manageFuelDelivery.fuelFlow\n\t\t\t\tfrom source.fuel to target.fuel;\n\t\t\tref flow references manageFuelDelivery.temperatureFlow\n\t\t\t\tfrom source.temperature to target.temperature;\n\t\t}\n\t\tpart fuelPump {\n\t\t\tport fuelPumpPort: FuelPumpPort;\n\t\t\tperform pumpFuel {\n\t\t\t\tin fuel = fuelPumpPort.fuel;\n\t\t\t\tout fuel = enginePort.fuel;\n\t\t\t\tin returnFuel = enginePort.returnFuel;\n\t\t\t}\n\t\t\tperform monitorTemperature {\n\t\t\t\tin temperature = fuelPumpPort.temperature;\n\t\t\t\tout temperature = transmitTemperature.temperature;\n\t\t\t}\n\t\t\tport enginePort: ~EngineFuelPort;\n\t\t\tperform handleFuelReturn {\n\t\t\t\tin returnFuel = enginePort.returnFuel;\n\t\t\t\tout returnFuel = fuelPumpPort.returnFuel;\n\t\t\t}\n\t\t}\n\t\tinterface pumpToEngine connect fuelPump.enginePort to engine.fuelPort {\n\t\t\tref flow references pumpFuel.fuelFlow\n\t\t\t\tfrom source.fuel to target.fuel;\n\t\t\tref flow references handleFuelReturn.returnFuelFlow\n\t\t\t\tfrom source.returnFuel to target.returnFuel;\n\t\t}\n\t\tpart fuelTank {\n\t\t\tport inletPort: FuelInletPort;\n\t\t\tperform supplyFuel {\n\t\t\t\tout fuel = inletPort.fuel;\n\t\t\t}\n\t\t}\n\t\tinterface tankToAssembly connect fuelTank.inletPort to fuelTankAssembly.outletPort {\n\t\t\tref flow references supplyFuel.fuelFlow\n\t\t\t\tfrom source.fuel to target.fuel;\n\t\t}\n\t\tpart engine {\n\t\t\tport fuelPort: ~EngineFuelPort;\n\t\t}\n\t\tpart monitoringUnit {\n\t\t\tperform transmitTemperature {\n\t\t\t\tin temperature: Temperature;\n\t\t\t}\n\t\t}\n\t\tinterface pumpToMonitoring connect fuelPump.monitorTemperature to monitoringUnit.transmitTemperature {\n\t\t\tref flow references monitorTemperature.temperatureFlow\n\t\t\t\tfrom source.temperature to target.temperature;\n\t\t}\n\t}\n\taction manageFuelDelivery {\n\t\taction supplyFuel { out fuel: Fuel; }\n\t\tsuccession flow fuelFlow from supplyFuel.fuel to pumpFuel.fuel;\n\t\taction pumpFuel { in fuel: Fuel; out fuel: Fuel; }\n\t\tsuccession flow returnFuelFlow from handleFuelReturn.returnFuel to supplyFuel.returnFuel;\n\t\taction monitorTemperature { in temperature: Temperature; out temperature: Temperature; }\n\t}\n}",
    "package 'PhysicalQuantitySystem' {\n\tattribute def Length;\n\tattribute def Mass;\n\tattribute def Time;\n\tattribute def ElectricCurrent;\n\tattribute def Temperature;\n\tattribute def AmountOfSubstance;\n\tattribute def LuminousIntensity;\n\tport def QuantityInputPort {\n\t\tin quantity: Length | Mass | Time | ElectricCurrent | Temperature | AmountOfSubstance | LuminousIntensity;\n\t\tin unit: String;\n\t}\n\tport def QuantityOutputPort {\n\t\tout convertedQuantity: Length | Mass | Time | ElectricCurrent | Temperature | AmountOfSubstance | LuminousIntensity;\n\t\tout convertedUnit: String;\n\t}\n\tinterface def ImportInterface {\n\t\timport baseQuantities: Length, Mass, Time, ElectricCurrent, Temperature, AmountOfSubstance, LuminousIntensity;\n\t}\n\tinterface def ExtensionInterface {\n\t\textend derivedQuantities: Area, Volume, Speed;\n\t}\n\tpart context {\n\t\tpart user {\n\t\t\tport inputPort: QuantityInputPort;\n\t\t\tperform dataProcessing.receiveQuantity {\n\t\t\t\tin quantity = inputPort.quantity;\n\t\t\t\tin unit = inputPort.unit;\n\t\t\t}\n\t\t}\n\t\tinterface userToSystem connect user.inputPort to system.inputPort {\n\t\t\tref flow references dataProcessing.quantityFlow\n\t\t\t\tfrom source.quantity to target.quantity,\n\t\t\t\tfrom source.unit to target.unit;\n\t\t}\n\t\tpart system {\n\t\t\tport inputPort: ~QuantityInputPort;\n\t\t\tport outputPort: QuantityOutputPort;\n\t\t\tperform dataProcessing.validateQuantity {\n\t\t\t\tin quantity = inputPort.quantity;\n\t\t\t\tin unit = inputPort.unit;\n\t\t\t\tout validatedQuantity = validatedQuantity;\n\t\t\t\tout baseUnit = baseUnit;\n\t\t\t}\n\t\t\tperform dataProcessing.convertUnits {\n\t\t\t\tin validatedQuantity;\n\t\t\t\tin baseUnit;\n\t\t\t\tin targetUnit = outputPort.convertedUnit;\n\t\t\t\tout convertedQuantity = outputPort.convertedQuantity;\n\t\t\t}\n\t\t\tperform importOperation.importBaseQuantities {\n\t\t\t\tref importInterface: ImportInterface;\n\t\t\t}\n\t\t\tperform extensionOperation.extendQuantities {\n\t\t\t\tref extensionInterface: ExtensionInterface;\n\t\t\t}\n\t\t}\n\t}\n\taction dataProcessing {\n\t\taction receiveQuantity { in quantity: Length | Mass | Time | ElectricCurrent | Temperature | AmountOfSubstance | LuminousIntensity; in unit: String; }\n\t\tsuccession flow quantityFlow from receiveQuantity.quantity to validateQuantity.quantity, from receiveQuantity.unit to validateQuantity.unit;\n\t\taction validateQuantity { in quantity; in unit; out validatedQuantity; out baseUnit: String; }\n\t\tsuccession flow validationFlow from validateQuantity.validatedQuantity to convertUnits.validatedQuantity, from validateQuantity.baseUnit to convertUnits.baseUnit;\n\t\taction convertUnits { in validatedQuantity; in baseUnit; in targetUnit: String; out convertedQuantity; }\n\t\tsuccession flow conversionFlow from convertUnits.convertedQuantity to outputQuantity.convertedQuantity;\n\t\taction outputQuantity { out convertedQuantity: Length | Mass | Time | ElectricCurrent | Temperature | AmountOfSubstance | LuminousIntensity; out convertedUnit: String; }\n\t}\n\taction importOperation {\n\t\taction importBaseQuantities {\n\t\t\tref importInterface: ImportInterface;\n\t\t\timport baseQuantities from importInterface.baseQuantities;\n\t\t}\n\t}\n\taction extensionOperation {\n\t\taction extendQuantities {\n\t\t\tref extensionInterface: ExtensionInterface;\n\t\t\textend derivedQuantities to extensionInterface.derivedQuantities;\n\t\t}\n\t}\n}",
    "package 'UnitSystemLibrary' {  \n\tattribute def ConversionRequest;  \n\tattribute def ConversionResult;  \n\tattribute def ValidationStatus;  \n\tport def ConversionRequestPort {  \n\t\tout conversionRequest : ConversionRequest;  \n\t}  \n\tport def ConversionResultPort {  \n\t\tout conversionResult: ConversionResult;  \n\t}  \n\tport def ValidationPort {  \n\t\tout validationStatus: ValidationStatus;  \n\t}  \n\tpart context {  \n\t\tpart user {  \n\t\t\tport requestPort: ConversionRequestPort;  \n\t\t\tperform conversionRegion.sendConversionRequest {  \n\t\t\t\tout conversionRequest = requestPort.conversionRequest;  \n\t\t\t}  \n\t\t}  \n\t\tinterface userToManager connect user.requestPort to manager.requestPort {  \n\t\t\tref flow references conversionRegion.requestFlow  \n\t\t\t\tfrom source.conversionRequest to target.conversionRequest;  \n\t\t}  \n\t\tpart manager {  \n\t\t\tport requestPort: ~ConversionRequestPort;  \n\t\t\tport resultPort: ConversionResultPort;  \n\t\t\tport validationPort: ValidationPort;  \n\t\t\tperform conversionRegion.validateUnits {  \n\t\t\t\tin conversionRequest = requestPort.conversionRequest;  \n\t\t\t\tout validationStatus = validationPort.validationStatus;  \n\t\t\t}  \n\t\t\tperform conversionRegion.convertToTargetUnit {  \n\t\t\t\tin conversionRequest = requestPort.conversionRequest;  \n\t\t\t\tout conversionResult = resultPort.conversionResult;  \n\t\t\t}  \n\t\t}  \n\t\tinterface managerToISQ connect manager.resultPort to isq.unitPort {  \n\t\t\tref flow references conversionRegion.resultFlow  \n\t\t\t\tfrom source.conversionResult to target.unitValue;  \n\t\t}  \n\t\tinterface managerToUSCustomary connect manager.resultPort to usCustomary.unitPort {  \n\t\t\tref flow references conversionRegion.resultFlow  \n\t\t\t\tfrom source.conversionResult to target.unitValue;  \n\t\t}  \n\t\tpart isq {  \n\t\t\tport unitPort: ~ConversionResultPort;  \n\t\t\tattribute length: Double;  \n\t\t\tattribute mass: Double;  \n\t\t\tattribute time: Double;  \n\t\t}  \n\t\tpart usCustomary {  \n\t\t\tport unitPort: ~ConversionResultPort;  \n\t\t\tattribute distance: Double;  \n\t\t\tattribute weight: Double;  \n\t\t\tattribute time: Double;  \n\t\t}  \n\t}  \n\taction conversionRegion {  \n\t\taction sendConversionRequest { out conversionRequest: ConversionRequest; }  \n\t\tsuccession flow requestFlow from sendConversionRequest.conversionRequest to validateUnits.conversionRequest;  \n\t\taction validateUnits { in conversionRequest: ConversionRequest; out validationStatus: ValidationStatus; }  \n\t\tsuccession flow validatedFlow from validateUnits.validationStatus to convertToTargetUnit.conversionRequest;  \n\t\taction convertToTargetUnit { in conversionRequest: ConversionRequest; out conversionResult: ConversionResult; }  \n\t\tsuccession flow resultFlow from convertToTargetUnit.conversionResult to sendConversionResult.conversionResult;  \n\t\taction sendConversionResult { out conversionResult: ConversionResult; }  \n\t}  \n}",
    "package 'CarHeadlampTiltValidation' {\n\tattribute def TiltAngle;\n\tattribute def SIUnit;\n\tattribute def RealConstants;\n\tport def TiltAnglePort {\n\t\tout tiltAngle : TiltAngle;\n\t}\n\tport def ValidationResultPort {\n\t\tout validationResult: Boolean;\n\t}\n\tpart context {\n\t\tpart adjustmentKnob {\n\t\t\tport tiltAnglePort: TiltAnglePort;\n\t\t\tperform adjustmentRegion.produceTiltAngle {\n\t\t\t\tout tiltAngle = tiltAnglePort.tiltAngle;\n\t\t\t}\n\t\t}\n\t\tinterface adjustmentKnobToValidation connect adjustmentKnob.tiltAnglePort to validationSystem.tiltAnglePort {\n\t\t\tref flow references adjustmentRegion.tiltAngleFlow\n\t\t\t\tfrom source.tiltAngle to target.tiltAngle;\n\t\t}\n\t\tpart validationSystem {\n\t\t\tport tiltAnglePort: ~TiltAnglePort;\n\t\t\tperform adjustmentRegion.validateTiltAngle {\n\t\t\t\tin tiltAngle = tiltAnglePort.tiltAngle;\n\t\t\t\tout validationResult = validationResultPort.validationResult;\n\t\t\t\tconstraint tiltAngle >= 50 and tiltAngle <= 80;\n\t\t\t}\n\t\t\tport validationResultPort: ValidationResultPort;\n\t\t}\n\t\tpart constants {\n\t\t\tattribute siUnit: SIUnit;\n\t\t\tattribute realConstants: RealConstants;\n\t\t}\n\t}\n\taction adjustmentRegion {\n\t\taction produceTiltAngle { out tiltAngle: TiltAngle; }\n\t\tsuccession flow tiltAngleFlow from produceTiltAngle.tiltAngle to validateTiltAngle.tiltAngle;\n\t\taction validateTiltAngle { in tiltAngle: TiltAngle; out validationResult: Boolean; constraint tiltAngle >= 50 and tiltAngle <= 80; }\n\t}\n}",
    "package 'DataTypeSystem' {\n\tvalue type UnsignedInteger {\n\t\tminInclusive 0;\n\t}\n\tvalue type UnsignedFloat {\n\t\tminInclusive 0.0;\n\t}\n\tenum StatusLevel {\n\t\tCritical, Warning, Normal;\n\t}\n\tenum ColorLabel {\n\t\tRed, Yellow, Green;\n\t}\n\tenum DiameterSize {\n\t\tSmall(60), Medium(70), Large(80);\n\t}\n\tpart PhysicalDimensions {\n\t\tproperty diameter: DiameterSize;\n\t\tinitial value for diameter is Small;\n\t}\n\tpart context {\n\t\tpart system {\n\t\t\tproperty unsignedInt: UnsignedInteger;\n\t\t\tproperty unsignedFloat: UnsignedFloat;\n\t\t\tproperty dateTime: DateTime;\n\t\t\tproperty stringVal: String;\n\t\t\tproperty booleanVal: Boolean;\n\t\t\tproperty status: StatusLevel;\n\t\t\tproperty color: ColorLabel;\n\t\t\tproperty dimensions: PhysicalDimensions;\n\n\t\t\tperform manageCoreDataTypes {\n\t\t\t\tin unsignedInt = system.unsignedInt;\n\t\t\t\tin unsignedFloat = system.unsignedFloat;\n\t\t\t}\n\t\t\tperform associateStatusColor {\n\t\t\t\tin status = system.status;\n\t\t\t\tout color = system.color;\n\t\t\t}\n\t\t}\n\t}\n\taction manageCoreDataTypes {\n\t\tin unsignedInt: UnsignedInteger;\n\t\tin unsignedFloat: UnsignedFloat;\n\t}\n\taction associateStatusColor {\n\t\tin status: StatusLevel;\n\t\tout color: ColorLabel;\n\t}\n\tsuccession flow statusToColor from associateStatusColor.status to associateStatusColor.color;\n}",
    "package 'CollectionManagementSystem' {\n    part SpareParts;\n    part Integers;\n    part Strings;\n    part Person;\n    part Real;\n\n    port def SparePartsPort {\n        out spareParts: Bag<SpareParts>;\n    }\n    port def IntegersPort {\n        out integers: List<Integer>;\n    }\n    port def StringsPort {\n        out strings: Set<String>;\n    }\n    port def PersonnelOrderedSetPort {\n        out personnel: OrderedSet<Person>;\n    }\n    port def NestedPersonnelSetsPort {\n        out nestedSets: List<Set<Person>>;\n    }\n    port def RealArrayPort {\n        out realArray: Array<Real>;\n    }\n\n    part context {\n        part system {\n            part sparePartsPart {\n                port sparePartsPort: SparePartsPort;\n                perform manageCollections.manageSpareParts {\n                    out spareParts = sparePartsPort.spareParts;\n                }\n            }\n            part integersPart {\n                port integersPort: IntegersPort;\n                perform manageCollections.manageIntegers {\n                    out integers = integersPort.integers;\n                }\n            }\n            part stringsPart {\n                port stringsPort: StringsPort;\n                perform manageCollections.manageStrings {\n                    out strings = stringsPort.strings;\n                }\n            }\n            part personnelPart {\n                port personnelPort: PersonnelOrderedSetPort;\n                perform manageCollections.managePersonnel {\n                    out personnel = personnelPort.personnel;\n                }\n            }\n            part nestedPersonnelSetsPart {\n                port nestedPersonnelSetsPort: NestedPersonnelSetsPort;\n                perform manageCollections.manageNestedPersonnelSets {\n                    out nestedSets = nestedPersonnelSetsPort.nestedSets;\n                }\n            }\n            part realNumbersPart {\n                port realNumbersPort: RealArrayPort;\n                perform manageCollections.processRealArray {\n                    out realArray = realNumbersPort.realArray;\n                }\n            }\n        }\n\n        interface SparePartsInterface connect sparePartsPart.sparePartsPort to manageCollections.manageSpareParts.spareParts {\n            ref flow references manageCollections.sparePartsFlow\n                from source.spareParts to target.spareParts;\n        }\n        interface IntegersInterface connect integersPart.integersPort to manageCollections.manageIntegers.integers {\n            ref flow references manageCollections.integersFlow\n                from source.integers to target.integers;\n        }\n        interface StringsInterface connect stringsPart.stringsPort to manageCollections.manageStrings.strings {\n            ref flow references manageCollections.stringsFlow\n                from source.strings to target.strings;\n        }\n        interface PersonnelInterface connect personnelPart.personnelPort to manageCollections.managePersonnel.personnel {\n            ref flow references manageCollections.personnelFlow\n                from source.personnel to target.personnel;\n        }\n        interface NestedPersonnelSetsInterface connect nestedPersonnelSetsPart.nestedPersonnelSetsPort to manageCollections.manageNestedPersonnelSets.nestedSets {\n            ref flow references manageCollections.nestedSetsFlow\n                from source.nestedSets to target.nestedSets;\n        }\n        interface RealNumbersInterface connect realNumbersPart.realNumbersPort to manageCollections.processRealArray.realArray {\n            ref flow references manageCollections.realArrayFlow\n                from source.realArray to target.realArray;\n        }\n    }\n\n    action manageCollections {\n        action manageSpareParts { out spareParts: Bag<SpareParts>; }\n        action manageIntegers { out integers: List<Integer>; }\n        action manageStrings { out strings: Set<String>; }\n        action managePersonnel { out personnel: OrderedSet<Person>; }\n        action manageNestedPersonnelSets { in personnel: OrderedSet<Person>; out nestedSets: List<Set<Person>>; }\n        action processRealArray { out realArray: Array<Real,4>; }\n\n        succession flow sparePartsFlow from manageSpareParts.spareParts to manageSpareParts.spareParts;\n        succession flow integersFlow from manageIntegers.integers to manageIntegers.integers;\n        succession flow stringsFlow from manageStrings.strings to manageStrings.strings;\n        succession flow personnelFlow from managePersonnel.personnel to manageNestedPersonnelSets.personnel;\n        succession flow nesetedSetsFlow from manageNestedPersonnelSets.nestedSets to manageNestedPersonnelSets.nestedSets;\n        succession flow realArrayFlow from processRealArray.realArray to processRealArray.realArray;\n    }\n}",
    "package 'TireInformationSystem' {\n\tattribute def ManufacturerName;\n\tattribute def RimDiameter;\n\tattribute def TireWidth;\n\tattribute def InstallationPosition;\n\tport def TireDataPort {\n\t\tout tireEntry : TireEntry;\n\t}\n\tpart context {\n\t\tpart user {\n\t\t\tport tireDataPort: TireDataPort;\n\t\t\tperform recordTireEntry.sendTireEntry {\n\t\t\t\tout tireEntry = tireDataPort.tireEntry;\n\t\t\t}\n\t\t}\n\t\tinterface userToSystem connect user.tireDataPort to system.tireDataPort {\n\t\t\tref flow references recordTireEntry.tireEntryFlow\n\t\t\t\tfrom source.tireEntry to target.tireEntry;\n\t\t}\n\t\tpart system {\n\t\t\tport tireDataPort: ~TireDataPort;\n\t\t\tperform recordTireEntry.validateTireEntry {\n\t\t\t\tin tireEntry = tireDataPort.tireEntry;\n\t\t\t}\n\t\t}\n\t}\n\taction recordTireEntry {\n\t\taction sendTireEntry { \n\t\t\tout tireEntry: TireEntry;\n\t\t}\n\t\tsuccession flow tireEntryFlow from sendTireEntry.tireEntry to validateTireEntry.tireEntry;\n\t\taction validateTireEntry { \n\t\t\tin tireEntry: TireEntry;\n\t\t}\n\t}\n\tclass TireEntry {\n\t\tproperty manufacturerName: ManufacturerName;\n\t\tproperty rimDiameter: RimDiameter;\n\t\tproperty tireWidth: TireWidth;\n\t\tproperty installationPosition: InstallationPosition [0..1];\n\t}\n}",
    "package 'SpacecraftTrajectorySampling' {\n\tattribute def ReferenceTime unit 's';\n\tattribute def UTCTime;\n\tstruct Position {\n\t\tx: float unit 'm';\n\t\ty: float unit 'm';\n\t\tz: float unit 'm';\n\t};\n\tstruct Velocity {\n\t\tx: float unit 'm/s';\n\t\ty: float unit 'm/s';\n\t\tz: float unit 'm/s';\n\t};\n\tport def TrajectoryPort {\n\t\tout trajectoryData: TrajectoryData;\n\t};\n\tpart def SamplePoint {\n\t\ttime: ReferenceTime;\n\t\tposition: Position;\n\t\tvelocity: Velocity;\n\t};\n\tpart def TrajectoryData {\n\t\tsamplePoints: SamplePoint[*];\n\t};\n\t\n\tpart context {\n\t\tpart system {\n\t\t\tport trajectoryPort: TrajectoryPort;\n\t\t\tperform sampleTrajectoryAction {\n\t\t\t\tout time = SampleTime.time;\n\t\t\t\tout position = SamplePosition.position;\n\t\t\t\tout velocity = SampleVelocity.velocity;\n\t\t\t}\n\t\t\tpart dataRecorder {\n\t\t\t\tperform recordTrajectoryAction {\n\t\t\t\t\tin time;\n\t\t\t\t\tin position;\n\t\t\t\t\tin velocity;\n\t\t\t\t\tout trajectoryData = TrajectoryData.samplePoints;\n\t\t\t\t}\n\t\t\t\tpart trajectoryData: TrajectoryData;\n\t\t\t}\n\t\t}\n\t}\n\t\n\taction sampleTrajectory {\n\t\taction sampleTrajectoryAction {\n\t\t\tout time: ReferenceTime;\n\t\t\tout position: Position;\n\t\t\tout velocity: Velocity;\n\t\t}\n\t\tsuccession flow timeFlow from sampleTrajectoryAction.time to recordTrajectoryAction.time;\n\t\tsuccession flow positionFlow from sampleTrajectoryAction.position to recordTrajectoryAction.position;\n\t\tsuccession flow velocityFlow from sampleTrajectoryAction.velocity to recordTrajectoryAction.velocity;\n\t\taction recordTrajectoryAction {\n\t\t\tin time: ReferenceTime;\n\t\t\tin position: Position;\n\t\t\tin velocity: Velocity;\n\t\t\tout trajectoryData: TrajectoryData;\n\t\t}\n\t}\n}",
    "package 'MaterialsSystem' {\n\tattribute def atomicMass unit kg/mol;\n\tattribute def massFraction unit dimensionless;\n\tattribute def tensileStrength unit N/mm²;\n\tport def SubstancePort {\n\t\tout atomicMass: atomicMass;\n\t}\n\tport def AlloyComponentPort {\n\t\tout massFraction: massFraction;\n\t\tout atomicMass: atomicMass;\n\t}\n\tport def AlloyPropertyPort {\n\t\tout tensileStrength: tensileStrength;\n\t}\n\tpart context {\n\t\tpart iron {\n\t\t\tport substancePort: SubstancePort;\n\t\t\tperform defineSubstance.setAtomicMass {\n\t\t\t\tout atomicMass = substancePort.atomicMass;\n\t\t\t}\n\t\t}\n\t\tpart carbon {\n\t\t\tport substancePort: SubstancePort;\n\t\t\tperform defineSubstance.setAtomicMass {\n\t\t\t\tout atomicMass = substancePort.atomicMass;\n\t\t\t}\n\t\t}\n\t\tpart manganese {\n\t\t\tport substancePort: SubstancePort;\n\t\t\tperform defineSubstance.setAtomicMass {\n\t\t\t\tout atomicMass = substancePort.atomicMass;\n\t\t\t}\n\t\t}\n\t\tpart steel980 {\n\t\t\tpart ironComponent {\n\t\t\t\tport componentPort: AlloyComponentPort;\n\t\t\t\tperform defineAlloy.setMassFraction {\n\t\t\t\t\tout massFraction = componentPort.massFraction;\n\t\t\t\t}\n\t\t\t\tperform defineSubstance.setAtomicMass {\n\t\t\t\t\tout atomicMass = componentPort.atomicMass;\n\t\t\t\t}\n\t\t\t}\n\t\t\tpart carbonComponent {\n\t\t\t\tport componentPort: AlloyComponentPort;\n\t\t\t\tperform defineAlloy.setMassFraction {\n\t\t\t\t\tout massFraction = componentPort.massFraction;\n\t\t\t\t}\n\t\t\t\tperform defineSubstance.setAtomicMass {\n\t\t\t\t\tout atomicMass = componentPort.atomicMass;\n\t\t\t\t}\n\t\t\t}\n\t\t\tpart manganeseComponent {\n\t\t\t\tport componentPort: AlloyComponentPort;\n\t\t\t\tperform defineAlloy.setMassFraction {\n\t\t\t\t\tout massFraction = componentPort.massFraction;\n\t\t\t\t}\n\t\t\t\tperform defineSubstance.setAtomicMass {\n\t\t\t\t\tout atomicMass = componentPort.atomicMass;\n\t\t\t\t}\n\t\t\t}\n\t\t\tport propertyPort: AlloyPropertyPort;\n\t\t\tperform calculateTensileStrength.determineStrength {\n\t\t\t\tin ironMassFraction = ironComponent.componentPort.massFraction;\n\t\t\t\tin carbonMassFraction = carbonComponent.componentPort.massFraction;\n\t\t\t\tin manganeseMassFraction = manganeseComponent.componentPort.massFraction;\n\t\t\t\tin ironAtomicMass = ironComponent.componentPort.atomicMass;\n\t\t\t\tin carbonAtomicMass = carbonComponent.componentPort.atomicMass;\n\t\t\t\tin manganeseAtomicMass = manganeseComponent.componentPort.atomicMass;\n\t\t\t\tout strength = propertyPort.tensileStrength;\n\t\t\t}\n\t\t}\n\t}\n\taction defineSubstance {\n\t\taction setAtomicMass { out atomicMass: atomicMass; }\n\t}\n\taction defineAlloy {\n\t\taction setMassFraction { out massFraction: massFraction; }\n\t}\n\taction calculateTensileStrength {\n\t\taction determineStrength { \n\t\t\tin ironMassFraction: massFraction; \n\t\t\tin carbonMassFraction: massFraction; \n\t\t\tin manganeseMassFraction: massFraction; \n\t\t\tin ironAtomicMass: atomicMass; \n\t\t\tin carbonAtomicMass: atomicMass; \n\t\t\tin manganeseAtomicMass: atomicMass; \n\t\t\tout tensileStrength: tensileStrength; \n\t\t}\n\t}\n\tsuccession flow from defineSubstance.setAtomicMass to defineAlloy.setMassFraction;\n\tsuccession flow from defineAlloy.setMassFraction to calculateTensileStrength.determineStrength;\n\tsuccession flow from defineSubstance.setAtomicMass to calculateTensileStrength.determineStrength;\n}",
    "package 'EngineeringMaterialsDB' {\n\tattribute def AtomicMass;\n\tattribute def MassFraction;\n\tattribute def TensileStrength;\n\tattribute def Unit;\n\tport def DataEntryPort {\n\t\tin addMaterialCmd: AddMaterialCmd;\n\t}\n\tport def QueryPort {\n\t\tin queryMaterialCmd: QueryMaterialCmd;\n\t\tout materialData: MaterialData;\n\t}\n\tport def ComparisonPort {\n\t\tin compareMaterialsCmd: CompareMaterialsCmd;\n\t\tout comparisonResult: ComparisonResult;\n\t}\n\tport def PropertyPort {\n\t\tout tensileStrength: TensileStrength;\n\t\tout unit: Unit;\n\t}\n\tpart context {\n\t\tpart user {\n\t\t\tport dataEntryPort: DataEntryPort;\n\t\t\tperform materialManagement.addMaterial {\n\t\t\t\tout addMaterialCmd = dataEntryPort.addMaterialCmd;\n\t\t\t}\n\t\t\tport queryPort: QueryPort;\n\t\t\tperform materialManagement.queryMaterial {\n\t\t\t\tout queryMaterialCmd = queryPort.queryMaterialCmd;\n\t\t\t}\n\t\t\tport comparisonPort: ComparisonPort;\n\t\t\tperform materialManagement.compareMaterials {\n\t\t\t\tout compareMaterialsCmd = comparisonPort.compareMaterialsCmd;\n\t\t\t}\n\t\t}\n\t\tinterface userDataEntry connect user.dataEntryPort to database.dataEntryPort {\n\t\t\tref flow references materialManagement.addMaterialFlow\n\t\t\t\tfrom source.addMaterialCmd to target.addMaterialCmd;\n\t\t}\n\t\tinterface userQuery connect user.queryPort to database.queryPort {\n\t\t\tref flow references materialManagement.queryMaterialFlow\n\t\t\t\tfrom source.queryMaterialCmd to target.queryMaterialCmd;\n\t\t\tref flow references materialManagement.materialDataFlow\n\t\t\t\tfrom source.materialData to target.materialData;\n\t\t}\n\t\tinterface userComparison connect user.comparisonPort to database.comparisonPort {\n\t\t\tref flow references materialManagement.compareMaterialsFlow\n\t\t\t\tfrom source.compareMaterialsCmd to target.compareMaterialsCmd;\n\t\t\tref flow references materialManagement.comparisonResultFlow\n\t\t\t\tfrom source.comparisonResult to target.comparisonResult;\n\t\t}\n\t\tpart database {\n\t\t\tport dataEntryPort: ~DataEntryPort;\n\t\t\tperform materialManagement.addMaterial {\n\t\t\t\tin addMaterialCmd = dataEntryPort.addMaterialCmd;\n\t\t\t}\n\t\t\tport queryPort: ~QueryPort;\n\t\t\tperform materialManagement.queryMaterial {\n\t\t\t\tin queryMaterialCmd = queryPort.queryMaterialCmd;\n\t\t\t\tout materialData = queryPort.materialData;\n\t\t\t}\n\t\t\tport comparisonPort: ~ComparisonPort;\n\t\t\tperform materialManagement.compareMaterials {\n\t\t\t\tin compareMaterialsCmd = comparisonPort.compareMaterialsCmd;\n\t\t\t\tout comparisonResult = comparisonPort.comparisonResult;\n\t\t\t}\n\t\t\tpart materialStorage {\n\t\t\t\tproperty materials: Material[];\n\t\t\t}\n\t\t}\n\t\tpart material {\n\t\t\tproperty atomicMass: AtomicMass;\n\t\t\tproperty fundamentalProperties: FundamentalProperty;\n\t\t\tproperty mechanicalProperties: MechanicalProperty;\n\t\t}\n\t\tpart metal {\n\t\t\textends material;\n\t\t}\n\t\tpart alloy {\n\t\t\textends material;\n\t\t\tpart constituent1 {\n\t\t\t\tproperty massFraction: MassFraction;\n\t\t\t}\n\t\t\tpart constituent2 {\n\t\t\t\tproperty massFraction: MassFraction;\n\t\t\t}\n\t\t\tpart constituent3 {\n\t\t\t\tproperty massFraction: MassFraction;\n\t\t\t}\n\t\t}\n\t\tpart steel980 {\n\t\t\textends alloy;\n\t\t\tproperty name: String = \"Steel_980\";\n\t\t\tpart iron {\n\t\t\t\treference to metal;\n\t\t\t\tproperty massFraction: MassFraction = 0.96;\n\t\t\t}\n\t\t\tpart carbon {\n\t\t\t\treference to material;\n\t\t\t\tproperty massFraction: MassFraction = 0.025;\n\t\t\t}\n\t\t\tpart manganese {\n\t\t\t\treference to material;\n\t\t\t\tproperty massFraction: MassFraction = 0.015;\n\t\t\t}\n\t\t\tproperty tensileStrength: TensileStrength = 980;\n\t\t\tproperty unit: Unit = \"N/mm²\";\n\t\t}\n\t}\n\taction materialManagement {\n\t\taction addMaterial { out addMaterialCmd: AddMaterialCmd; }\n\t\tsuccession flow addMaterialFlow from addMaterial.addMaterialCmd to addMaterialCmd.addMaterialCmd;\n\t\taction queryMaterial { out queryMaterialCmd: QueryMaterialCmd; }\n\t\tsuccession flow queryMaterialFlow from queryMaterial.queryMaterialCmd to queryMaterialCmd.queryMaterialCmd;\n\t\tsuccession flow materialDataFlow from retrieveMaterialData.materialData to queryPort.materialData;\n\t\taction compareMaterials { out compareMaterialsCmd: CompareMaterialsCmd; }\n\t\tsuccession flow compareMaterialsFlow from compareMaterials.compareMaterialsCmd to compareMaterialsCmd.compareMaterialsCmd;\n\t\tsuccession flow comparisonResultFlow from generateComparisonResult.comparisonResult to comparisonPort.comparisonResult;\n\t\taction retrieveMaterialData { in queryMaterialCmd; out materialData; }\n\t\taction generateComparisonResult { in compareMaterialsCmd; out comparisonResult; }\n\t}\n}",
    "package 'PubSubSystem' {  \n\tattribute def Message;  \n\tattribute def Topic;  \n\tattribute def Subscription;  \n\tport def PublishPort {  \n\t\tout message : Message;  \n\t\tout topic : Topic;  \n\t}  \n\tport def SubscribePort {  \n\t\tin topic : Topic;  \n\t\tout message : Message;  \n\t}  \n\tport def SubscriptionPort {  \n\t\tout subscription : Subscription;  \n\t}  \n\tpart context {  \n\t\tpart producer {  \n\t\t\tport publishPort: PublishPort;  \n\t\t\tperform publishMessage.sendPublish {  \n\t\t\t\tout message = publishPort.message;  \n\t\t\t\tout topic = publishPort.topic;  \n\t\t\t}  \n\t\t}  \n\t\tinterface producerToServer connect producer.publishPort to server.publishPort {  \n\t\t\tref flow references publishMessage.publishFlow  \n\t\t\t\tfrom source.message to target.message,  \n\t\t\t\tfrom source.topic to target.topic;  \n\t\t}  \n\t\tpart server {  \n\t\t\tport publishPort: ~PublishPort;  \n\t\t\tport subscribePort: ~SubscribePort;  \n\t\t\tport subscriptionPort: SubscriptionPort;  \n\t\t\tperform publishMessage.receivePublish {  \n\t\t\t\tin message = publishPort.message;  \n\t\t\t\tin topic = publishPort.topic;  \n\t\t\t\tout subscription = subscriptionPort.subscription;  \n\t\t\t}  \n\t\t\tperform manageSubscriptions.updateSubscriptions {  \n\t\t\t\tin subscription = subscriptionPort.subscription;  \n\t\t\t}  \n\t\t\tperform distributeMessage.distribute {  \n\t\t\t\tin message = publishPort.message;  \n\t\t\t\tin topic = publishPort.topic;  \n\t\t\t\tout message = subscribePort.message;  \n\t\t\t}  \n\t\t}  \n\t\tinterface serverToSubscriber connect server.subscribePort to subscriber.subscribePort {  \n\t\t\tref flow references distributeMessage.distributionFlow  \n\t\t\t\tfrom source.message to target.message,  \n\t\t\t\tfrom source.topic to target.topic;  \n\t\t}  \n\t\tpart subscriber {  \n\t\t\tport subscribePort: SubscribePort;  \n\t\t\tperform receiveMessage.deliverMessage {  \n\t\t\t\tin message = subscribePort.message;  \n\t\t\t\tin topic = subscribePort.topic;  \n\t\t\t}  \n\t\t}  \n\t}  \n\taction publishMessage {  \n\t\taction sendPublish { out message: Message; out topic: Topic; }  \n\t\tsuccession flow publishFlow from sendPublish.message to receivePublish.message,  \n\t\t\tsendPublish.topic to receivePublish.topic;  \n\t\taction receivePublish { in message: Message; in topic: Topic; out subscription: Subscription; }  \n\t}  \n\taction manageSubscriptions {  \n\t\taction updateSubscriptions { in subscription: Subscription; }  \n\t}  \n\taction distributeMessage {  \n\t\taction distribute { in message: Message; in topic: Topic; out message: Message; }  \n\t\tsuccession flow distributionFlow from distribute.message to deliverMessage.message;  \n\t\taction deliverMessage { in message: Message; in topic: Topic; }  \n\t}  \n}",
    "package 'VehicleFuelSystem' {\n\tattribute def Fuel;\n\tattribute def Temperature;\n\tport def FuelPort {\n\t\tin fuel: Fuel;\n\t\tout fuel: Fuel;\n\t}\n\tport def TemperaturePort {\n\t\tout temperature: Temperature;\n\t}\n\tpart context {\n\t\tpart fuelTankAssembly {\n\t\t\tport supplyFuelPort: FuelPort;\n\t\t\tport returnFuelPort: FuelPort;\n\t\t\tperform supplyFuelAction {\n\t\t\t\tout fuel = supplyFuelPort.out.fuel;\n\t\t\t}\n\t\t\tperform returnFuelAction {\n\t\t\t\tin fuel = returnFuelPort.in.fuel;\n\t\t\t}\n\t\t}\n\t\tpart engine {\n\t\t\tport supplyFuelPort: FuelPort;\n\t\t\tport returnFuelPort: FuelPort;\n\t\t\tperform supplyFuelAction {\n\t\t\t\tin fuel = supplyFuelPort.in.fuel;\n\t\t\t}\n\t\t\tperform returnFuelAction {\n\t\t\t\tout fuel = returnFuelPort.out.fuel;\n\t\t\t}\n\t\t}\n\t\tpart supplyFuelLine {\n\t\t\tport inFuelPort: FuelPort;\n\t\t\tport outFuelPort: FuelPort;\n\t\t\tport temperaturePort: TemperaturePort;\n\t\t\tperform monitorTemperatureSupply {\n\t\t\t\tin fuel = inFuelPort.in.fuel;\n\t\t\t\tout temperature = temperaturePort.out.temperature;\n\t\t\t}\n\t\t}\n\t\tpart returnFuelLine {\n\t\t\tport inFuelPort: FuelPort;\n\t\t\tport outFuelPort: FuelPort;\n\t\t\tport temperaturePort: TemperaturePort;\n\t\t\tperform monitorTemperatureReturn {\n\t\t\t\tin fuel = inFuelPort.in.fuel;\n\t\t\t\tout temperature = temperaturePort.out.temperature;\n\t\t\t}\n\t\t}\n\t\tinterface fuelTankToSupplyLine connect fuelTankAssembly.supplyFuelPort to supplyFuelLine.inFuelPort {\n\t\t\tref flow references supplyFuelFlow;\n\t\t}\n\t\tinterface supplyLineToEngine connect supplyFuelLine.outFuelPort to engine.supplyFuelPort {\n\t\t\tref flow references supplyFuelFlow;\n\t\t}\n\t\tinterface engineToReturnLine connect engine.returnFuelPort to returnFuelLine.inFuelPort {\n\t\t\tref flow references returnFuelFlow;\n\t\t}\n\t\tinterface returnLineToFuelTank connect returnFuelLine.outFuelPort to fuelTankAssembly.returnFuelPort {\n\t\t\tref flow references returnFuelFlow;\n\t\t}\n\t}\n\taction supplyFuelFlow {\n\t\taction supplyFuel { out fuel: Fuel; }\n\t\tsuccession flow from supplyFuel.fuel to monitorTemperatureSupply.fuel;\n\t\taction monitorTemperatureSupply { in fuel; out temperature: Temperature; }\n\t}\n\taction returnFuelFlow {\n\t\taction returnFuel { out fuel: Fuel; }\n\t\tsuccession flow from returnFuel.fuel to monitorTemperatureReturn.fuel;\n\t\taction monitorTemperatureReturn { in fuel; out temperature: Temperature; }\n\t}\n}",
    "package 'PublishSubscribeSystem' {\n\tattribute def Message;\n\tattribute def Topic;\n\tport def SubscribePort {\n\t\tout topic: Topic;\n\t}\n\tport def PublishPort {\n\t\tin message: Message;\n\t\tin topic: Topic;\n\t}\n\tport def DeliverPort {\n\t\tout message: Message;\n\t\tout topic: Topic;\n\t}\n\tpart context {\n\t\tpart consumer {\n\t\t\tport subscribePort: SubscribePort;\n\t\t\tperform subscriptionRequest.sendSubscriptionRequest {\n\t\t\t\tout topic = subscribePort.topic;\n\t\t\t}\n\t\t}\n\t\tinterface consumerToServer connect consumer.subscribePort to server.subscribePort {\n\t\t\tref flow references subscriptionRequest.subscriptionFlow\n\t\t\t\tfrom source.topic to target.topic;\n\t\t}\n\t\tpart producer {\n\t\t\tport publishPort: PublishPort;\n\t\t\tperform publishMessage.sendMessage {\n\t\t\t\tin message = publishPort.message;\n\t\t\t\tin topic = publishPort.topic;\n\t\t\t}\n\t\t}\n\t\tinterface producerToServer connect producer.publishPort to server.publishPort {\n\t\t\tref flow references publishMessage.messageFlow\n\t\t\t\tfrom source.message to target.message;\n\t\t\tref flow references publishMessage.topicFlow\n\t\t\t\tfrom source.topic to target.topic;\n\t\t}\n\t\tpart server {\n\t\t\tport subscribePort: ~SubscribePort;\n\t\t\tport publishPort: ~PublishPort;\n\t\t\tperform handleSubscribe.storeSubscription {\n\t\t\t\tin topic = subscribePort.topic;\n\t\t\t}\n\t\t\tperform messageDistribution.distributeMessage {\n\t\t\t\tin message = publishPort.message;\n\t\t\t\tin topic = publishPort.topic;\n\t\t\t\tout topics = handleSubscribe.topic;\n\t\t\t}\n\t\t\tinterface serverToConsumers connect messageDistribution.deliverPort to consumer.deliverPort {\n\t\t\t\tref flow references messageDistribution.deliveryFlow\n\t\t\t\t\tfrom source.message to target.message;\n\t\t\t\tref flow references messageDistribution.topicFlow\n\t\t\t\t\tfrom source.topics to target.topics;\n\t\t\t}\n\t\t}\n\t\tpart consumer {\n\t\t\tport deliverPort: ~DeliverPort;\n\t\t\tperform messageReception.receiveMessage {\n\t\t\t\tin message = deliverPort.message;\n\t\t\t\tin topic = deliverPort.topic;\n\t\t\t}\n\t\t}\n\t}\n\taction subscriptionRequest {\n\t\taction sendSubscriptionRequest { out topic: Topic; }\n\t\tsuccession flow subscriptionFlow from sendSubscriptionRequest.topic to storeSubscription.topic;\n\t}\n\taction publishMessage {\n\t\taction sendMessage { in message: Message; in topic: Topic; }\n\t\tsuccession flow messageFlow from sendMessage.message to distributeMessage.message;\n\t\tsuccession flow topicFlow from sendMessage.topic to distributeMessage.topic;\n\t}\n\taction messageDistribution {\n\t\taction distributeMessage { in message: Message; in topic: Topic; out topics: Topic; }\n\t\tsuccession flow deliveryFlow from distributeMessage.message to receiveMessage.message;\n\t\tsuccession flow topicFlow from distributeMessage.topics to receiveMessage.topic;\n\t}\n\taction messageReception {\n\t\taction receiveMessage { in message: Message; in topic: Topic; }\n\t}\n}",
    "package 'TransportationSystem' {\n\tattribute def FuelLevel;\n\tattribute def MaxTankCapacity;\n\tattribute def BoardingStatus;\n\tattribute def ExitStatus;\n\tport def OperationCmdPort {\n\t\tout operationCmd;\n\t}\n\tport def RefuelCmdPort {\n\t\tout refuelCmd;\n\t}\n\tport def BoardingPort {\n\t\tout boarding: BoardingStatus;\n\t}\n\tport def ExitPort {\n\t\tout exit: ExitStatus;\n\t}\n\tport def EnvironmentalInputPort {\n\t\tin environmentalFactors;\n\t}\n\tpart context {\n\t\tpart driver {\n\t\t\tport operationCmdPort: OperationCmdPort;\n\t\t\tperform operateVehicle.sendOperationCmd {\n\t\t\t\tout operationCmd = operationCmdPort.operationCmd;\n\t\t\t}\n\t\t\tport refuelCmdPort: RefuelCmdPort;\n\t\t\tperform refuelVehicle.sendRefuelCmd {\n\t\t\t\tout refuelCmd = refuelCmdPort.refuelCmd;\n\t\t\t}\n\t\t}\n\t\tinterface driverToVehicle connect driver.operationCmdPort to vehicle.operationCmdPort {\n\t\t\tref flow references operateVehicle.operationCmdFlow\n\t\t\t\tfrom source.operationCmd to target.operationCmd;\n\t\t}\n\t\tinterface driverToFuelSystem connect driver.refuelCmdPort to fuelSystem.refuelCmdPort {\n\t\t\tref flow references refuelVehicle.refuelCmdFlow\n\t\t\t\tfrom source.refuelCmd to target.refuelCmd;\n\t\t}\n\t\tpart passengers {\n\t\t\tport boardingPort: BoardingPort;\n\t\t\tperform boardUsers.sendBoardingStatus {\n\t\t\t\tout boarding = boardingPort.boarding;\n\t\t\t}\n\t\t\tport exitPort: ExitPort;\n\t\t\tperform exitUsers.sendExitStatus {\n\t\t\t\tout exit = exitPort.exit;\n\t\t\t}\n\t\t}\n\t\tinterface passengersToVehicle connect passengers.boardingPort to vehicle.boardingPort {\n\t\t\tref flow references boardUsers.boardingFlow\n\t\t\t\tfrom source.boarding to target.boarding;\n\t\t}\n\t\tinterface passengersToVehicleExit connect passengers.exitPort to vehicle.exitPort {\n\t\t\tref flow references exitUsers.exitFlow\n\t\t\t\tfrom source.exit to target.exit;\n\t\t}\n\t\tpart vehicle {\n\t\t\tport operationCmdPort: ~OperationCmdPort;\n\t\t\tport boardingPort: ~BoardingPort;\n\t\t\tport exitPort: ~ExitPort;\n\t\t\tport environmentalInputPort: EnvironmentalInputPort;\n\t\t\tperform operateVehicle.consumeFuel {\n\t\t\t\tin operationCmd = operationCmdPort.operationCmd;\n\t\t\t\tout fuelLevel = fuelSystem.fuelLevel;\n\t\t\t}\n\t\t\tperform checkFuelLevel.evaluate {\n\t\t\t\tin fuelLevel = fuelSystem.fuelLevel;\n\t\t\t\tout refuelDecision = fuelSystem.refuelDecision;\n\t\t\t}\n\t\t\tperform exitUsers.finalizeExit {\n\t\t\t\tin exit;\n\t\t\t\tout exitStatus;\n\t\t\t}\n\t\t}\n\t\tpart fuelSystem {\n\t\t\tport refuelCmdPort: ~RefuelCmdPort;\n\t\t\tattribute fuelLevel: FuelLevel;\n\t\t\tattribute maxTankCapacity: MaxTankCapacity;\n\t\t\tperform refuelVehicle.updateFuel {\n\t\t\t\tin refuelCmd = refuelCmdPort.refuelCmd;\n\t\t\t\tout fuelLevel = fuelSystem.fuelLevel;\n\t\t\t}\n\t\t}\n\t\tpart environment {\n\t\t\tport environmentalInputPort: ~EnvironmentalInputPort;\n\t\t\tperform monitorEnvironment.provideFactors {\n\t\t\t\tout environmentalFactors = environmentalInputPort.environmentalFactors;\n\t\t\t}\n\t\t}\n\t}\n\taction operateVehicle {\n\t\taction sendOperationCmd { out operationCmd; }\n\t\tsuccession flow operationCmdFlow from sendOperationCmd.operationCmd to consumeFuel.operationCmd;\n\t\taction consumeFuel { in operationCmd; out fuelLevel; }\n\t}\n\taction checkFuelLevel {\n\t\taction evaluate { in fuelLevel; out refuelDecision; }\n\t\tdecision ifLowFuel condition refuelDecision < 0.1 * maxTankCapacity {\n\t\t\tbranch refuel { to refuelVehicle.evaluate; }\n\t\t\tbranch continue { to operateVehicle.consumeFuel; }\n\t\t}\n\t}\n\taction refuelVehicle {\n\t\taction sendRefuelCmd { out refuelCmd; }\n\t\tsuccession flow refuelCmdFlow from sendRefuelCmd.refuelCmd to updateFuel.refuelCmd;\n\t\taction updateFuel { in refuelCmd; out fuelLevel; }\n\t}\n\taction boardUsers {\n\t\taction sendBoardingStatus { out boarding; }\n\t\tsuccession flow boardingFlow from sendBoardingStatus.boarding to vehicle.boarding;\n\t}\n\taction exitUsers {\n\t\taction sendExitStatus { out exit; }\n\t\tsuccession flow exitFlow from sendExitStatus.exit to vehicle.exit;\n\t}\n}",
    "package 'VehicleFuelSystem' {\n\tattribute def Fuel;\n\tattribute def FuelTemp;\n\tport def FuelOutPort {\n\t\tout fuel: Fuel;\n\t\tout fuelTemp: FuelTemp;\n\t}\n\tport def FuelInPort {\n\t\tin fuel: Fuel;\n\t\tin fuelTemp: FuelTemp;\n\t}\n\tpart context {\n\t\tpart fuelTankAssembly {\n\t\t\tport fuelOutPort: FuelOutPort;\n\t\t\tport fuelInPort: FuelInPort;\n\t\t\tperform fuelSupplyRegion.supplyFuel {\n\t\t\t\tout fuel = fuelOutPort.fuel;\n\t\t\t\tout fuelTemp = fuelOutPort.fuelTemp;\n\t\t\t}\n\t\t\tperform fuelReturnRegion.receiveReturnFuel {\n\t\t\t\tin fuel = fuelInPort.fuel;\n\t\t\t\tin fuelTemp = fuelInPort.fuelTemp;\n\t\t\t}\n\t\t}\n\t\tinterface fuelTankToEngine connect fuelTankAssembly.fuelOutPort to engineUnit.fuelInPort {\n\t\t\tref flow references fuelSupplyRegion.fuelFlow\n\t\t\t\tfrom source.fuel to target.fuel;\n\t\t\tref flow references fuelSupplyRegion.fuelTempFlow\n\t\t\t\tfrom source.fuelTemp to target.fuelTemp;\n\t\t}\n\t\tpart engineUnit {\n\t\t\tport fuelInPort: ~FuelInPort;\n\t\t\tport fuelOutPort: FuelOutPort;\n\t\t\tperform fuelSupplyRegion.consumeFuel {\n\t\t\t\tin fuel = fuelInPort.fuel;\n\t\t\t\tin fuelTemp = fuelInPort.fuelTemp;\n\t\t\t}\n\t\t\tperform fuelReturnRegion.returnFuel {\n\t\t\t\tout fuel = fuelOutPort.fuel;\n\t\t\t\tout fuelTemp = fuelOutPort.fuelTemp;\n\t\t\t}\n\t\t}\n\t\tinterface engineToFuelTank connect engineUnit.fuelOutPort to fuelTankAssembly.fuelInPort {\n\t\t\tref flow references fuelReturnRegion.returnFuelFlow\n\t\t\t\tfrom source.fuel to target.fuel;\n\t\t\tref flow references fuelReturnRegion.returnFuelTempFlow\n\t\t\t\tfrom source.fuelTemp to target.fuelTemp;\n\t\t}\n\t}\n\taction fuelSupplyRegion {\n\t\taction supplyFuel { out fuel: Fuel; out fuelTemp: FuelTemp; }\n\t\tsuccession flow fuelFlow from supplyFuel.fuel to consumeFuel.fuel;\n\t\tsuccession flow fuelTempFlow from supplyFuel.fuelTemp to consumeFuel.fuelTemp;\n\t\taction consumeFuel { in fuel: Fuel; in fuelTemp: FuelTemp; }\n\t}\n\taction fuelReturnRegion {\n\t\taction returnFuel { out fuel: Fuel; out fuelTemp: FuelTemp; }\n\t\tsuccession flow returnFuelFlow from returnFuel.fuel to receiveReturnFuel.fuel;\n\t\tsuccession flow returnFuelTempFlow from returnFuel.fuelTemp to receiveReturnFuel.fuelTemp;\n\t\taction receiveReturnFuel { in fuel: Fuel; in fuelTemp: FuelTemp; }\n\t}\n}",
    "package 'VehicleFuelSystem' {\n\tattribute def FuelFlow;\n\tattribute def FuelTemp;\n\tport def FuelSupplyPort {\n\t\tout fuelFlow : FuelFlow;\n\t\tout fuelTemp : FuelTemp;\n\t}\n\tport def FuelReturnPort {\n\t\tout fuelFlow : FuelFlow;\n\t\tout fuelTemp : FuelTemp;\n\t}\n\tpart context {\n\t\tpart fuelTankAssembly {\n\t\t\tport supplyPort: FuelSupplyPort;\n\t\t\tport returnPort: ~FuelReturnPort;\n\t\t\tperform supplyFuel {\n\t\t\t\tout fuelFlow = supplyPort.fuelFlow;\n\t\t\t\tout fuelTemp = supplyPort.fuelTemp;\n\t\t\t}\n\t\t\tperform returnFuel {\n\t\t\t\tin fuelFlow = returnPort.fuelFlow;\n\t\t\t\tin fuelTemp = returnPort.fuelTemp;\n\t\t\t}\n\t\t}\n\t\tinterface fuelTankToEngine connect fuelTankAssembly.supplyPort to engine.supplyPort {\n\t\t\tref flow references supplyFuel.supplyFlow\n\t\t\t\tfrom source.fuelFlow to target.fuelFlow;\n\t\t\tref flow references supplyFuel.supplyTemp\n\t\t\t\tfrom source.fuelTemp to target.fuelTemp;\n\t\t}\n\t\tinterface engineToFuelTank connect engine.returnPort to fuelTankAssembly.returnPort {\n\t\t\tref flow references returnFuel.returnFlow\n\t\t\t\tfrom source.fuelFlow to target.fuelFlow;\n\t\t\tref flow references returnFuel.returnTemp\n\t\t\t\tfrom source.fuelTemp to target.fuelTemp;\n\t\t}\n\t\tpart engine {\n\t\t\tport supplyPort: ~FuelSupplyPort;\n\t\t\tport returnPort: FuelReturnPort;\n\t\t\tperform receiveSupply {\n\t\t\t\tin fuelFlow = supplyPort.fuelFlow;\n\t\t\t\tin fuelTemp = supplyPort.fuelTemp;\n\t\t\t}\n\t\t\tperform returnFuel {\n\t\t\t\tout fuelFlow = returnPort.fuelFlow;\n\t\t\t\tout fuelTemp = returnPort.fuelTemp;\n\t\t\t}\n\t\t}\n\t}\n\taction manageFuelSystem {\n\t\taction supplyFuel { out fuelFlow: FuelFlow; out fuelTemp: FuelTemp; }\n\t\tsuccession flow supplyFlow from supplyFuel.fuelFlow to receiveSupply.fuelFlow;\n\t\tsuccession flow supplyTemp from supplyFuel.fuelTemp to receiveSupply.fuelTemp;\n\t\taction returnFuel { out fuelFlow: FuelFlow; out fuelTemp: FuelTemp; }\n\t\tsuccession flow returnFlow from returnFuel.fuelFlow to returnFuel.fuelFlow;\n\t\tsuccession flow returnTemp from returnFuel.fuelTemp to returnFuel.fuelTemp;\n\t}\n}",
    "package 'PhotoCaptureSystem' {\n\tattribute def SelectSceneCmd;\n\tattribute def FocusedImage;\n\tattribute def IntermediateImage;\n\tattribute def FinalPhoto;\n\tport def SelectSceneCmdPort {\n\t\tout selectSceneCmd : SelectSceneCmd;\n\t}\n\tport def FinalPhotoPort {\n\t\tout finalPhoto : FinalPhoto;\n\t}\n\tpart context {\n\t\tpart user {\n\t\t\tport selectSceneCmdPort: SelectSceneCmdPort;\n\t\t\tperform photoCapture.sendSelectSceneCmd {\n\t\t\t\tout selectSceneCmd = selectSceneCmdPort.selectSceneCmd;\n\t\t\t}\n\t\t}\n\t\tinterface userToSystem connect user.selectSceneCmdPort to photoSystem.selectSceneCmdPort {\n\t\t\tref flow references photoCapture.selectSceneCmdFlow\n\t\t\t\tfrom source.selectSceneCmd to target.selectSceneCmd;\n\t\t}\n\t\tpart photoSystem {\n\t\t\tport selectSceneCmdPort: ~SelectSceneCmdPort;\n\t\t\tperform photoCapture.autoFocus {\n\t\t\t\tin selectSceneCmd = selectSceneCmdPort.selectSceneCmd;\n\t\t\t\tout focusedImage = generateIntermediate.focusedImage;\n\t\t\t}\n\t\t\tperform photoCapture.generateIntermediate {\n\t\t\t\tin focusedImage: FocusedImage;\n\t\t\t\tout intermediateImage = capturePhoto.intermediateImage;\n\t\t\t}\n\t\t\tperform photoCapture.capturePhoto {\n\t\t\t\tin intermediateImage: IntermediateImage;\n\t\t\t\tout finalPhoto = finalPhotoPort.finalPhoto;\n\t\t\t}\n\t\t\tport finalPhotoPort: FinalPhotoPort;\n\t\t}\n\t}\n\taction photoCapture {\n\t\taction sendSelectSceneCmd { out selectSceneCmd: SelectSceneCmd; }\n\t\tsuccession flow selectSceneCmdFlow from sendSelectSceneCmd.selectSceneCmd to autoFocus.selectSceneCmd;\n\t\taction autoFocus { in selectSceneCmd; out focusedImage: FocusedImage; }\n\t\tsuccession flow focusedImageFlow from autoFocus.focusedImage to generateIntermediate.focusedImage;\n\t\taction generateIntermediate { in focusedImage: FocusedImage; out intermediateImage: IntermediateImage; }\n\t\tsuccession flow intermediateImageFlow from generateIntermediate.intermediateImage to capturePhoto.intermediateImage;\n\t\taction capturePhoto { in intermediateImage: IntermediateImage; out finalPhoto: FinalPhoto; }\n\t}\n}",
    "package 'PhotographyWorkflow' {  \n\tattribute def Scene;  \n\tattribute def FocusedImage;  \n\tattribute def FinalImage;  \n\tport def SelectScenePort {  \n\t\tout scene : Scene;  \n\t}  \n\tport def FocusedImagePort {  \n\t\tout focusedImage : FocusedImage;  \n\t}  \n\tport def FinalImagePort {  \n\t\tout finalImage : FinalImage;  \n\t}  \n\tpart context {  \n\t\tpart user {  \n\t\t\tport selectScenePort: SelectScenePort;  \n\t\t\tperform photographyProcess.selectScene {  \n\t\t\t\tout scene = selectScenePort.scene;  \n\t\t\t}  \n\t\t}  \n\t\tinterface userToFocusing connect user.selectScenePort to focusingModule.selectScenePort {  \n\t\t\tref flow references photographyProcess.sceneFlow  \n\t\t\t\tfrom source.scene to target.scene;  \n\t\t}  \n\t\tpart focusingModule {  \n\t\t\tport selectScenePort: ~SelectScenePort;  \n\t\t\tperform photographyProcess.processScene {  \n\t\t\t\tin scene = selectScenePort.scene;  \n\t\t\t\tout focusedImage = focusedImagePort.focusedImage;  \n\t\t\t}  \n\t\t\tport focusedImagePort: FocusedImagePort;  \n\t\t}  \n\t\tinterface focusingToShooting connect focusingModule.focusedImagePort to shootingModule.focusedImagePort {  \n\t\t\tref flow references photographyProcess.imageFlow  \n\t\t\t\tfrom source.focusedImage to target.focusedImage;  \n\t\t}  \n\t\tpart shootingModule {  \n\t\t\tport focusedImagePort: ~FocusedImagePort;  \n\t\t\tperform photographyProcess.captureFinalImage {  \n\t\t\t\tin focusedImage = focusedImagePort.focusedImage;  \n\t\t\t\tout finalImage = finalImagePort.finalImage;  \n\t\t\t}  \n\t\t\tport finalImagePort: FinalImagePort;  \n\t\t}  \n\t}  \n\taction photographyProcess {  \n\t\taction selectScene { out scene: Scene; }  \n\t\tsuccession flow sceneFlow from selectScene.scene to processScene.scene;  \n\t\taction processScene { in scene: Scene; out focusedImage: FocusedImage; }  \n\t\tsuccession flow imageFlow from processScene.focusedImage to captureFinalImage.focusedImage;  \n\t\taction captureFinalImage { in focusedImage: FocusedImage; out finalImage: FinalImage; }  \n\t}  \n}",
    "package 'PhotographySystem' {\n\tattribute def SceneSelectionCmd;\n\tattribute def FocusedImage;\n\tattribute def FinalPhotograph;\n\tport def SceneSelectionPort {\n\t\tout sceneSelectionCmd : SceneSelectionCmd;\n\t}\n\tport def ImagePort {\n\t\tout focusedImage: FocusedImage;\n\t}\n\tport def PhotographPort {\n\t\tout finalPhotograph: FinalPhotograph;\n\t}\n\tpart context {\n\t\tpart user {\n\t\t\tport sceneSelectionPort: SceneSelectionPort;\n\t\t\tperform captureWorkflow.sendSceneSelectionCmd {\n\t\t\t\tout sceneSelectionCmd = sceneSelectionPort.sceneSelectionCmd;\n\t\t\t}\n\t\t}\n\t\tinterface userToSystem connect user.sceneSelectionPort to system.sceneSelectionPort {\n\t\t\tref flow references captureWorkflow.sceneSelectionFlow\n\t\t\t\tfrom source.sceneSelectionCmd to target.sceneSelectionCmd;\n\t\t}\n\t\tpart system {\n\t\t\tport sceneSelectionPort: ~SceneSelectionPort;\n\t\t\tperform captureWorkflow.processScene {\n\t\t\t\tin sceneSelectionCmd = sceneSelectionPort.sceneSelectionCmd;\n\t\t\t\tout focusedImage = imagePort.focusedImage;\n\t\t\t}\n\t\t\tport imagePort: ImagePort;\n\t\t\tperform captureWorkflow.shoot {\n\t\t\t\tin focusedImage = imagePort.focusedImage;\n\t\t\t\tout finalPhotograph = photographPort.finalPhotograph;\n\t\t\t}\n\t\t\tport photographPort: PhotographPort;\n\t\t}\n\t\tpart finalPhotograph {\n\t\t\tport photographPort: ~PhotographPort;\n\t\t\tperform captureWorkflow.receivePhotograph {\n\t\t\t\tin finalPhotograph = photographPort.finalPhotograph;\n\t\t\t}\n\t\t}\n\t}\n\taction captureWorkflow {\n\t\taction sendSceneSelectionCmd { out sceneSelectionCmd: SceneSelectionCmd; }\n\t\tsuccession flow sceneSelectionFlow from sendSceneSelectionCmd.sceneSelectionCmd to processScene.sceneSelectionCmd;\n\t\taction processScene { in sceneSelectionCmd; out focusedImage: FocusedImage; }\n\t\tsuccession flow imageFlow from processScene.focusedImage to shoot.focusedImage;\n\t\taction shoot { in focusedImage: FocusedImage; out finalPhotograph: FinalPhotograph; }\n\t}\n}",
    "package 'AutomatedPhotographySystem' {\n\tattribute def ShootingScene;\n\tattribute def FocusedImage;\n\tattribute def Photograph;\n\tport def SceneInputPort {\n\t\tin scene: ShootingScene;\n\t}\n\tport def ImageOutputPort {\n\t\tout image: FocusedImage;\n\t}\n\tport def PhotographOutputPort {\n\t\tout photograph: Photograph;\n\t}\n\tpart context {\n\t\tpart user {\n\t\t\tport sceneInputPort: SceneInputPort;\n\t\t\tperform photographyProcess.submitScene {\n\t\t\t\tin scene = sceneInputPort.scene;\n\t\t\t}\n\t\t}\n\t\tinterface userToSystem connect user.sceneInputPort to system.sceneInputPort {\n\t\t\tref flow references photographyProcess.sceneFlow\n\t\t\t\tfrom source.scene to target.scene;\n\t\t}\n\t\tpart system {\n\t\t\tport sceneInputPort: ~SceneInputPort;\n\t\t\tpart focusProcessor {\n\t\t\t\tperform photographyProcess.processFocus {\n\t\t\t\t\tin scene = sceneInputPort.scene;\n\t\t\t\t\tout image = imageOutputPort.image;\n\t\t\t\t}\n\t\t\t}\n\t\t\tport imageOutputPort: ImageOutputPort;\n\t\t\tpart shootingModule {\n\t\t\t\tperform photographyProcess.performShooting {\n\t\t\t\t\tin image = imageOutputPort.image;\n\t\t\t\t\tout photograph = photographOutputPort.photograph;\n\t\t\t\t}\n\t\t\t}\n\t\t\tport photographOutputPort: PhotographOutputPort;\n\t\t}\n\t}\n\taction photographyProcess {\n\t\taction submitScene { in scene: ShootingScene; }\n\t\tsuccession flow sceneFlow from submitScene.scene to processFocus.scene;\n\t\taction processFocus { in scene: ShootingScene; out image: FocusedImage; }\n\t\tsuccession flow imageFlow from processFocus.image to performShooting.image;\n\t\taction performShooting { in image: FocusedImage; out photograph: Photograph; }\n\t}\n}",
    "package 'PhotographyWorkflow' {\n\tattribute def Scene;\n\tattribute def Image;\n\tattribute def Picture;\n\tport def SceneInputPort {\n\t\tin scene: Scene;\n\t}\n\tport def ImageOutputPort {\n\t\tout image: Image;\n\t}\n\tport def PictureOutputPort {\n\t\tout picture: Picture;\n\t}\n\tpart context {\n\t\tpart user {\n\t\t\tport sceneInputPort: SceneInputPort;\n\t\t\tperform photographyProcess.sendScene {\n\t\t\t\tin scene = sceneInputPort.scene;\n\t\t\t}\n\t\t}\n\t\tinterface userToSystem connect user.sceneInputPort to system.sceneInputPort {\n\t\t\tref flow references photographyProcess.sceneFlow\n\t\t\t\tfrom source.scene to target.scene;\n\t\t}\n\t\tpart system {\n\t\t\tport sceneInputPort: ~SceneInputPort;\n\t\t\tperform photographyProcess.focusImage {\n\t\t\t\tin scene = sceneInputPort.scene;\n\t\t\t\tout image = imageOutputPort.image;\n\t\t\t}\n\t\t\tport imageOutputPort: ~ImageOutputPort;\n\t\t\tperform photographyProcess.takePicture {\n\t\t\t\tin image = imageOutputPort.image;\n\t\t\t\tout picture = pictureOutputPort.picture;\n\t\t\t}\n\t\t\tport pictureOutputPort: PictureOutputPort;\n\t\t}\n\t}\n\taction photographyProcess {\n\t\taction sendScene { in scene: Scene; }\n\t\tsuccession flow sceneFlow from sendScene.scene to focusImage.scene;\n\t\taction focusImage { in scene: Scene; out image: Image; }\n\t\tsuccession flow imageFlow from focusImage.image to takePicture.image;\n\t\taction takePicture { in image: Image; out picture: Picture; }\n\t}\n}",
    "package 'PhotographyWorkflow' {  \n\tattribute def CaptureCmd;  \n\tattribute def FocusStatus;  \n\tattribute def FinalImage;  \n\tport def CaptureCmdPort {  \n\t\tout captureCmd : CaptureCmd;  \n\t}  \n\tport def FocusStatusPort {  \n\t\tout focusStatus: FocusStatus;  \n\t}  \n\tport def ImagePort {  \n\t\tout image: FinalImage;  \n\t}  \n\tpart context {  \n\t\tpart user {  \n\t\t\tport captureCmdPort: CaptureCmdPort;  \n\t\t\tperform selectScene.sendCaptureCmd {  \n\t\t\t\tout captureCmd = captureCmdPort.captureCmd;  \n\t\t\t}  \n\t\t}  \n\t\tinterface userToCamera connect user.captureCmdPort to camera.captureCmdPort {  \n\t\t\tref flow references selectScene.captureCmdFlow  \n\t\t\t\tfrom source.captureCmd to target.captureCmd;  \n\t\t}  \n\t\tpart camera {  \n\t\t\tport captureCmdPort: ~CaptureCmdPort;  \n\t\t\tport focusStatusPort: ~FocusStatusPort;  \n\t\t\tport imagePort: ImagePort;  \n\t\t\tperform captureProcess.initiateFocus {  \n\t\t\t\tin captureCmd = captureCmdPort.captureCmd;  \n\t\t\t\tout focusStatus = focusStatusPort.focusStatus;  \n\t\t\t}  \n\t\t\tperform captureProcess.capturePhoto {  \n\t\t\t\tin focusStatus = focusStatusPort.focusStatus;  \n\t\t\t\tout image = imagePort.image;  \n\t\t\t}  \n\t\t}  \n\t\tpart focusDetector {  \n\t\t\tport focusStatusPort: ~FocusStatusPort;  \n\t\t\tperform captureProcess.checkFocus {  \n\t\t\t\tin focusStatus = focusStatusPort.focusStatus;  \n\t\t\t}  \n\t\t}  \n\t}  \n\taction captureProcess {  \n\t\taction sendCaptureCmd { out captureCmd: CaptureCmd; }  \n\t\tsuccession flow captureCmdFlow from sendCaptureCmd.captureCmd to initiateFocus.captureCmd;  \n\t\taction initiateFocus { in captureCmd: CaptureCmd; out focusStatus: FocusStatus; }  \n\t\tsuccession flow focusStatusFlow from initiateFocus.focusStatus to checkFocus.focusStatus;  \n\t\taction checkFocus { in focusStatus: FocusStatus; }  \n\t\tsuccession flow confirmedFocusFlow from checkFocus.focusStatus to capturePhoto.focusStatus;  \n\t\taction capturePhoto { in focusStatus: FocusStatus; out image: FinalImage; }  \n\t}  \n}",
    "package 'PhotographyWorkflow' {\n\tattribute def Scene;\n\tattribute def FocusData;\n\tattribute def Image;\n\tattribute def QualityResult;\n\tattribute def Photograph;\n\tattribute def FinalPhoto;\n\tport def ScenePort {\n\t\tout scene: Scene;\n\t}\n\tport def FocusDataPort {\n\t\tout focusData: FocusData;\n\t}\n\tport def ImagePort {\n\t\tout image: Image;\n\t}\n\tport def QualityResultPort {\n\t\tout qualityResult: QualityResult;\n\t}\n\tport def PhotographPort {\n\t\tout photograph: Photograph;\n\t}\n\tport def FinalPhotoPort {\n\t\tout finalPhoto: FinalPhoto;\n\t}\n\tpart context {\n\t\tpart user {\n\t\t\tport scenePort: ScenePort;\n\t\t\tperform selectScene.sendScene {\n\t\t\t\tout scene = scenePort.scene;\n\t\t\t}\n\t\t}\n\t\tinterface userToSystem connect user.scenePort to cameraSystem.scenePort {\n\t\t\tref flow references selectSceneToFocus.focusFlow\n\t\t\t\tfrom source.scene to target.scene;\n\t\t}\n\t\tpart cameraSystem {\n\t\t\tport scenePort: ~ScenePort;\n\t\t\tport focusDataPort: ~FocusDataPort;\n\t\t\tport imagePort: ~ImagePort;\n\t\t\tport qualityResultPort: ~QualityResultPort;\n\t\t\tport photographPort: ~PhotographPort;\n\t\t\tport finalPhotoPort: ~FinalPhotoPort;\n\t\t\tperform focusRegion.performFocus {\n\t\t\t\tin scene = scenePort.scene;\n\t\t\t\tout focusData = focusDataPort.focusData;\n\t\t\t}\n\t\t\tperform generateImageRegion.generateImage {\n\t\t\t\tin focusData = focusDataPort.focusData;\n\t\t\t\tout image = imagePort.image;\n\t\t\t}\n\t\t\tperform evaluateFocusRegion.evaluateFocus {\n\t\t\t\tin image = imagePort.image;\n\t\t\t\tin focusData = focusDataPort.focusData;\n\t\t\t\tout qualityResult = qualityResultPort.qualityResult;\n\t\t\t}\n\t\t\tperform shootingRegion.convertToPhoto {\n\t\t\t\tin image = imagePort.image;\n\t\t\t\tout photograph = photographPort.photograph;\n\t\t\t}\n\t\t\tperform shootingRegion.produceFinalPhoto {\n\t\t\t\tin photograph = photographPort.photograph;\n\t\t\t\tout finalPhoto = finalPhotoPort.finalPhoto;\n\t\t\t}\n\t\t}\n\t}\n\taction focusRegion {\n\t\taction sendScene { out scene: Scene; }\n\t\tsuccession flow focusFlow from sendScene.scene to performFocus.scene;\n\t\taction performFocus { in scene: Scene; out focusData: FocusData; }\n\t\tsuccession flow focusDataFlow from performFocus.focusData to generateImage.focusData;\n\t\taction generateImage { in focusData: FocusData; out image: Image; }\n\t\tsuccession flow imageFlow from generateImage.image to evaluateFocus.image;\n\t\taction evaluateFocus { in image: Image; in focusData: FocusData; out qualityResult: QualityResult; }\n\t\tsuccession flow qualityFlow from evaluateFocus.qualityResult to convertToPhoto.qualityResult;\n\t\taction convertToPhoto { in image: Image; in qualityResult: QualityResult; out photograph: Photograph; }\n\t\tsuccession flow photoFlow from convertToPhoto.photograph to produceFinalPhoto.photograph;\n\t\taction produceFinalPhoto { in photograph: Photograph; out finalPhoto: FinalPhoto; }\n\t}\n}",
    "package 'PhotographyWorkflow' {  \n\tattribute def PhotoCommand;  \n\tattribute def SceneData;  \n\tattribute def FocusedImage;  \n\tattribute def FinalPhoto;  \n  \n\tport def TakePhotoPort {  \n\t\tout takePhotoCmd : PhotoCommand;  \n\t}  \n  \n\tport def SceneInputPort {  \n\t\tin scene : SceneData;  \n\t}  \n  \n\tport def FocusPort {  \n\t\tout focusedImage : FocusedImage;  \n\t}  \n  \n\tport def DisplayPort {  \n\t\tin photo : FinalPhoto;  \n\t}  \n  \n\tpart context {  \n\t\tpart user {  \n\t\t\tport takePhotoPort: TakePhotoPort;  \n\t\t\tperform takePhoto.sendTakePhotoCmd {  \n\t\t\t\tout takePhotoCmd = takePhotoPort.takePhotoCmd;  \n\t\t\t}  \n\t\t}  \n  \n\t\tinterface userToCameraSystem connect user.takePhotoPort to cameraSystem.takePhotoPort {  \n\t\t\tref flow references takePhoto.takePhotoFlow  \n\t\t\t\tfrom source.takePhotoCmd to target.takePhotoCmd;  \n\t\t}  \n  \n\t\tpart cameraSystem {  \n\t\t\tport takePhotoPort: ~TakePhotoPort;  \n\t\t\tperform photographyWorkflow {  \n\t\t\t\taction acquireScene { in takePhotoCmd; out sceneData; }  \n\t\t\t\taction performFocus { in sceneData; out focusedImage; }  \n\t\t\t\taction executeShooting { in focusedImage; out finalPhoto; }  \n\t\t\t\tsuccession flow sceneFlow from acquireScene.sceneData to performFocus.sceneData;  \n\t\t\t\tsuccession flow focusFlow from performFocus.focusedImage to executeShooting.focusedImage;  \n\t\t\t}  \n\t\t\tport sceneInputPort: SceneInputPort;  \n\t\t\tport focusOutputPort: FocusPort;  \n\t\t\tport photoOutputPort: DisplayPort;  \n\t\t}  \n  \n\t\tinterface cameraSystemToDisplay connect cameraSystem.photoOutputPort to display.photoInputPort {  \n\t\t\tref flow references executeShooting.finalPhotoFlow  \n\t\t\t\tfrom source.finalPhoto to target.photo;  \n\t\t}  \n  \n\t\tpart display {  \n\t\t\tport photoInputPort: ~DisplayPort;  \n\t\t\tperform photographyWorkflow.displayPhoto {  \n\t\t\t\tin photo = photoInputPort.photo;  \n\t\t\t}  \n\t\t}  \n\t}  \n  \n\taction takePhoto {  \n\t\taction sendTakePhotoCmd { out takePhotoCmd: PhotoCommand; }  \n\t\taction acquireScene { in takePhotoCmd; out sceneData: SceneData; }  \n\t\taction performFocus { in sceneData; out focusedImage: FocusedImage; }  \n\t\taction executeShooting { in focusedImage; out finalPhoto: FinalPhoto; }  \n\t\taction displayPhoto { in photo: FinalPhoto; }  \n  \n\t\tsuccession flow takePhotoFlow from sendTakePhotoCmd.takePhotoCmd to acquireScene.takePhotoCmd;  \n\t\tsuccession flow sceneFlow from acquireScene.sceneData to performFocus.sceneData;  \n\t\tsuccession flow focusFlow from performFocus.focusedImage to executeShooting.focusedImage;  \n\t\tsuccession flow photoFlow from executeShooting.finalPhoto to displayPhoto.photo;  \n\t}  \n}",
    "package 'AutomaticBrakingSystem' {  \n\tattribute def ActivationSignal;  \n\tattribute def BrakePedalStatus;  \n\tattribute def TractionInfo;  \n\tattribute def BrakePressure;  \n\tattribute def ModulationFrequency;  \n\n\tport def ActivationPort {  \n\t\tout activation: ActivationSignal;  \n\t}  \n\tport def BrakePedalPort {  \n\t\tin pedalStatus: BrakePedalStatus;  \n\t}  \n\tport def TractionSensorPort {  \n\t\tin tractionInfo: TractionInfo;  \n\t}  \n\tport def BrakeActuatorPort {  \n\t\tout pressure: BrakePressure;  \n\t\tout frequency: ModulationFrequency;  \n\t}  \n\n\tpart context {  \n\t\tpart user {  \n\t\t\tport activationPort: ActivationPort;  \n\t\t\tperform monitorBraking.startSystem {  \n\t\t\t\tout activation = activationPort.activation;  \n\t\t\t}  \n\t\t}  \n\t\tinterface userToBrakingSystem connect user.activationPort to brakingSystem.activationPort {  \n\t\t\tref flow references monitorBraking.activationFlow  \n\t\t\t\tfrom source.activation to target.activation;  \n\t\t}  \n\t\tpart brakingSystem {  \n\t\t\tport activationPort: ~ActivationPort;  \n\t\t\tport pedalPort: BrakePedalPort;  \n\t\t\tport sensorPort: TractionSensorPort;  \n\t\t\tport actuatorPort: BrakeActuatorPort;  \n\n\t\t\tperform monitorBraking.detectBrakePedal {  \n\t\t\t\tin pedalStatus = pedalPort.pedalStatus;  \n\t\t\t\tout pressure = detectBrakePedal.brakePressure;  \n\t\t\t}  \n\t\t\tperform monitorBraking.evaluateTraction {  \n\t\t\t\tin tractionInfo = sensorPort.tractionInfo;  \n\t\t\t\tout info = evaluateTraction.tractionInfo;  \n\t\t\t}  \n\t\t\tperform monitorBraking.adjustBraking {  \n\t\t\t\tin brakePressure = detectBrakePedal.brakePressure;  \n\t\t\t\tin tractionInfo = evaluateTraction.tractionInfo;  \n\t\t\t\tout pressure = actuatorPort.pressure;  \n\t\t\t\tout frequency = actuatorPort.frequency;  \n\t\t\t}  \n\t\t}  \n\t}  \n\n\taction monitorBraking {  \n\t\taction startSystem { out activation: ActivationSignal; }  \n\t\tsuccession flow activationFlow from startSystem.activation to detectBrakePedal.activation;  \n\n\t\taction detectBrakePedal { in pedalStatus: BrakePedalStatus; out brakePressure: BrakePressure; }  \n\t\taction evaluateTraction { in tractionInfo: TractionInfo; out evaluatedTraction: TractionInfo; }  \n\t\tsuccession flow sensorFlow from evaluateTraction.evaluatedTraction to adjustBraking.tractionInfo;  \n\n\t\taction adjustBraking {  \n\t\t\tin brakePressure: BrakePressure;  \n\t\t\tin tractionInfo: TractionInfo;  \n\t\t\tout pressure: BrakePressure;  \n\t\t\tout frequency: ModulationFrequency;  \n\t\t}  \n\t\tsuccession flow pressureFlow from detectBrakePedal.brakePressure to adjustBraking.brakePressure;  \n\t}  \n}",
    "package 'BatteryChargingControlSystem' {\n\tattribute def BatteryLevel;\n\tattribute def ChargeCmd;\n\tport def BatteryLevelPort {\n\t\tout batteryLevel : BatteryLevel;\n\t}\n\tport def ChargeCmdPort {\n\t\tout chargeCmd : ChargeCmd;\n\t}\n\tpart context {\n\t\tpart battery {\n\t\t\tport batteryLevelPort: BatteryLevelPort;\n\t\t\tperform monitorBatteryLevel.sendBatteryLevel {\n\t\t\t\tout batteryLevel = batteryLevelPort.batteryLevel;\n\t\t\t}\n\t\t}\n\t\tinterface batteryToControl connect battery.batteryLevelPort to controlUnit.batteryLevelPort {\n\t\t\tref flow references monitorBatteryLevel.batteryLevelFlow\n\t\t\t\tfrom source.batteryLevel to target.batteryLevel;\n\t\t}\n\t\tinterface controlToCharger connect controlUnit.chargeCmdPort to charger.chargeCmdPort {\n\t\t\tref flow references decideChargeAction.chargeCmdFlow\n\t\t\t\tfrom source.chargeCmd to target.chargeCmd;\n\t\t}\n\t\tpart controlUnit {\n\t\t\tport batteryLevelPort: ~BatteryLevelPort;\n\t\t\tport chargeCmdPort: ~ChargeCmdPort;\n\t\t\tperform monitorBatteryLevel.monitorBatteryLevel {\n\t\t\t\tin batteryLevel = batteryLevelPort.batteryLevel;\n\t\t\t}\n\t\t\tperform decideChargeAction.decideChargeAction {\n\t\t\t\tin batteryLevel = batteryLevelPort.batteryLevel;\n\t\t\t\tout chargeCmd = chargeCmdPort.chargeCmd;\n\t\t\t}\n\t\t}\n\t\tpart charger {\n\t\t\tport chargeCmdPort: ~ChargeCmdPort;\n\t\t\tperform chargeBattery.chargeBattery {\n\t\t\t\tin chargeCmd = chargeCmdPort.chargeCmd;\n\t\t\t}\n\t\t}\n\t}\n\taction monitorBatteryLevel {\n\t\taction sendBatteryLevel { out batteryLevel: BatteryLevel; }\n\t\taction monitorBatteryLevel { \n\t\t\tin batteryLevel: BatteryLevel; \n\t\t\tout chargeDecision: ChargeCmd;\n\t\t}\n\t\taction decideChargeAction { \n\t\t\tin batteryLevel: BatteryLevel; \n\t\t\tout chargeCmd: ChargeCmd;\n\t\t}\n\t\taction chargeBattery { \n\t\t\tin chargeCmd: ChargeCmd; \n\t\t}\n\t\tsuccession flow batteryLevelFlow from sendBatteryLevel.batteryLevel to monitorBatteryLevel.batteryLevel;\n\t\tsuccession flow chargeCmdFlow from decideChargeAction.chargeCmd to chargeBattery.chargeCmd;\n\t}\n}",
    "package 'BatteryChargingSystem' {\n\tattribute def BatteryLevel;\n\tattribute def ChargingCmd;\n\tport def BatteryLevelPort {\n\t\tout batteryLevel : BatteryLevel;\n\t}\n\tport def ChargingCmdPort {\n\t\tout chargingCmd : ChargingCmd;\n\t}\n\tpart context {\n\t\tpart battery {\n\t\t\tport batteryLevelPort: BatteryLevelPort;\n\t\t\tperform chargingProcess.monitorBatteryLevel {\n\t\t\t\tout batteryLevel = batteryLevelPort.batteryLevel;\n\t\t\t}\n\t\t}\n\t\tpart chargingController {\n\t\t\tport batteryLevelInput: ~BatteryLevelPort;\n\t\t\tperform chargingProcess.checkChargeStatus {\n\t\t\t\tin batteryLevel = batteryLevelInput.batteryLevel;\n\t\t\t}\n\t\t\tport chargingCmdOutput: ChargingCmdPort;\n\t\t\tperform chargingProcess.replenishBattery {\n\t\t\t\tout chargingCmd = chargingCmdOutput.chargingCmd;\n\t\t\t}\n\t\t\tperform chargingProcess.terminateCharging {\n\t\t\t\tout chargingCmdTerminated = chargingCmdOutput.chargingCmd;\n\t\t\t}\n\t\t}\n\t\tinterface batteryToController connect battery.batteryLevelPort to chargingController.batteryLevelInput {\n\t\t\tref flow references chargingProcess.batteryLevelFlow\n\t\t\t\tfrom source.batteryLevel to target.batteryLevel;\n\t\t}\n\t}\n\taction chargingProcess {\n\t\taction monitorBatteryLevel { out batteryLevel: BatteryLevel; }\n\t\tsuccession flow batteryLevelFlow from monitorBatteryLevel.batteryLevel to checkChargeStatus.batteryLevel;\n\t\taction checkChargeStatus { in batteryLevel: BatteryLevel; out decision: Boolean; }\n\t\tsuccession flow decisionToReplenish from checkChargeStatus.decision to replenishBattery.condition where batteryLevel < 100%;\n\t\tsuccession flow decisionToTerminate from checkChargeStatus.decision to terminateCharging.condition where batteryLevel >= 100%;\n\t\taction replenishBattery { out chargingCmd: ChargingCmd; }\n\t\tsuccession flow replenishToMonitor from replenishBattery.chargingCmd to monitorBatteryLevel.trigger;\n\t\taction terminateCharging { out chargingCmdTerminated: ChargingCmd; }\n\t}\n}",
    "package 'CameraSystem' {  \n\tattribute def Scene;  \n\tattribute def FocusedImage;  \n\tattribute def Photo;  \n\tattribute def SavedPhoto;  \n\n\tport def SceneSelectionPort {  \n\t\tout scene: Scene;  \n\t}  \n\tport def FocusPort {  \n\t\tin scene: Scene;  \n\t\tout focusedImage: FocusedImage;  \n\t}  \n\tport def ImagingPort {  \n\t\tin focusedImage: FocusedImage;  \n\t\tout photo: Photo;  \n\t}  \n\tport def StoragePort {  \n\t\tin photo: Photo;  \n\t\tout savedPhoto: SavedPhoto;  \n\t}  \n\n\tpart context {  \n\t\tpart user {  \n\t\t\tport sceneSelectionPort: SceneSelectionPort;  \n\t\t\tperform photoCaptureRegion.sendSceneSelection {  \n\t\t\t\tout scene = sceneSelectionPort.scene;  \n\t\t\t}  \n\t\t}  \n\t\tinterface userToCamera connect user.sceneSelectionPort to camera.sceneSelectionPort {  \n\t\t\tref flow references photoCaptureRegion.sceneFlow  \n\t\t\t\tfrom source.scene to target.scene;  \n\t\t}  \n\t\tpart camera {  \n\t\t\tport sceneSelectionPort: ~SceneSelectionPort;  \n\t\t\tport focusPort: FocusPort;  \n\t\t\tport imagingPort: ImagingPort;  \n\n\t\t\tperform photoCaptureRegion.autoFocus {  \n\t\t\t\tin scene = focusPort.scene;  \n\t\t\t\tout focusedImage = focusPort.focusedImage;  \n\t\t\t}  \n\t\t\tperform photoCaptureRegion.captureImage {  \n\t\t\t\tin focusedImage = imagingPort.focusedImage;  \n\t\t\t\tout photo = imagingPort.photo;  \n\t\t\t}  \n\t\t}  \n\t\tinterface cameraToStorage connect camera.imagingPort.photo to storage.storagePort.photo {  \n\t\t\tref flow references photoCaptureRegion.photoFlow  \n\t\t\t\tfrom source.photo to target.photo;  \n\t\t}  \n\t\tpart storage {  \n\t\t\tport storagePort: ~StoragePort;  \n\t\t\tperform photoCaptureRegion.savePhoto {  \n\t\t\t\tin photo = storagePort.photo;  \n\t\t\t\tout savedPhoto = storagePort.savedPhoto;  \n\t\t\t}  \n\t\t}  \n\t}  \n\n\taction photoCaptureRegion {  \n\t\taction sendSceneSelection { out scene: Scene; }  \n\t\tsuccession flow sceneFlow from sendSceneSelection.scene to autoFocus.scene;  \n\t\taction autoFocus { in scene: Scene; out focusedImage: FocusedImage; }  \n\t\tsuccession flow focusFlow from autoFocus.focusedImage to captureImage.focusedImage;  \n\t\taction captureImage { in focusedImage: FocusedImage; out photo: Photo; }  \n\t\tsuccession flow photoFlow from captureImage.photo to savePhoto.photo;  \n\t\taction savePhoto { in photo: Photo; out savedPhoto: SavedPhoto; }  \n\t}  \n}",
    "package 'DigitalCamera' {\n\tattribute def SceneSelection;\n\tattribute def FocusCommand;\n\tattribute def FocusStatus;\n\tattribute def ImageCommand;\n\tattribute def FinalPhoto;\n\tport def SceneSelectionPort {\n\t\tout sceneSelection : SceneSelection;\n\t}\n\tport def FocusCommandPort {\n\t\tout focusCommand : FocusCommand;\n\t}\n\tport def FocusStatusPort {\n\t\tout focusStatus : FocusStatus;\n\t}\n\tport def ImageCommandPort {\n\t\tout imageCommand : ImageCommand;\n\t}\n\tport def PhotoPort {\n\t\tout finalPhoto : FinalPhoto;\n\t}\n\tpart context {\n\t\tpart user {\n\t\t\tport sceneSelectionPort: SceneSelectionPort;\n\t\t\tperform shootingProcess.selectScene {\n\t\t\t\tout sceneSelection = sceneSelectionPort.sceneSelection;\n\t\t\t}\n\t\t}\n\t\tinterface userToCamera connect user.sceneSelectionPort to camera.sceneSelectionPort {\n\t\t\tref flow references shootingProcess.sceneSelectionFlow\n\t\t\t\tfrom source.sceneSelection to target.sceneSelection; \n\t\t}\n\t\tpart camera {\n\t\t\tport sceneSelectionPort: ~SceneSelectionPort;\n\t\t\tperform shootingProcess.autoFocus {\n\t\t\t\tin sceneSelection = sceneSelectionPort.sceneSelection;\n\t\t\t\tout focusCommand = focusingModule.focusCommandPort.focusCommand;\n\t\t\t}\n\t\t\tport focusStatusPort: FocusStatusPort;\n\t\t\tinterface cameraToFocusing connect focusStatusPort to focusingModule.focusStatusPort {\n\t\t\t\tref flow references shootingProcess.focusStatusFlow\n\t\t\t\t\tfrom source.focusStatus to target.focusStatus; \n\t\t\t}\n\t\t\tperform shootingProcess.generateImage {\n\t\t\t\tin focusStatus = focusStatusPort.focusStatus;\n\t\t\t\tout imageCommand = imagingModule.imageCommandPort.imageCommand;\n\t\t\t}\n\t\t\tport photoPort: PhotoPort;\n\t\t\tinterface imagingToCamera connect imagingModule.photoPort to photoPort {\n\t\t\t\tref flow references shootingProcess.photoFlow\n\t\t\t\t\tfrom source.finalPhoto to target.finalPhoto; \n\t\t\t}\n\t\t\tpart focusingModule {\n\t\t\t\tport focusCommandPort: ~FocusCommandPort;\n\t\t\t\tport focusStatusPort: ~FocusStatusPort;\n\t\t\t\tperform shootingProcess.focusAction {\n\t\t\t\t\tin focusCommand = focusCommandPort.focusCommand;\n\t\t\t\t\tout focusStatus = focusStatusPort.focusStatus;\n\t\t\t\t}\n\t\t\t}\n\t\t\tpart imagingModule {\n\t\t\t\tport imageCommandPort: ~ImageCommandPort;\n\t\t\t\tport photoPort: ~PhotoPort;\n\t\t\t\tperform shootingProcess.capturePhoto {\n\t\t\t\t\tin imageCommand = imageCommandPort.imageCommand;\n\t\t\t\t\tout finalPhoto = photoPort.finalPhoto;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\taction shootingProcess {\n\t\taction selectScene { out sceneSelection: SceneSelection; }\n\t\tsuccession flow sceneSelectionFlow from selectScene.sceneSelection to autoFocus.sceneSelection;\n\t\taction autoFocus { in sceneSelection; out focusCommand: FocusCommand; }\n\t\tsuccession flow focusCommandFlow from autoFocus.focusCommand to focusAction.focusCommand;\n\t\taction focusAction { in focusCommand: FocusCommand; out focusStatus: FocusStatus; }\n\t\tsuccession flow focusStatusFlow from focusAction.focusStatus to generateImage.focusStatus;\n\t\taction generateImage { in focusStatus; out imageCommand: ImageCommand; }\n\t\tsuccession flow imageCommandFlow from generateImage.imageCommand to capturePhoto.imageCommand;\n\t\taction capturePhoto { in imageCommand: ImageCommand; out finalPhoto: FinalPhoto; }\n\t\tsuccession flow photoFlow from capturePhoto.finalPhoto to outputPhoto.finalPhoto;\n\t\taction outputPhoto { in finalPhoto: FinalPhoto; }\n\t}\n}",
    "package 'VehicleSimulation' {\n\tattribute def Mass;\n\tattribute def InitialPosition;\n\tattribute def InitialVelocity;\n\tattribute def TimeInterval;\n\tattribute def PowerInput;\n\tattribute def Velocity;\n\tattribute def Position;\n\tattribute def Trajectory;\n\n\tport def MassPort {\n\t\tin mass: Mass;\n\t}\n\tport def InitialPositionPort {\n\t\tin initialPosition: InitialPosition;\n\t}\n\tport def InitialVelocityPort {\n\t\tin initialVelocity: InitialVelocity;\n\t}\n\tport def TimeIntervalPort {\n\t\tin timeInterval: TimeInterval;\n\t}\n\tport def PowerInputPort {\n\t\tin powerInput: Sequence<PowerInput>;\n\t}\n\tport def TrajectoryPort {\n\t\tout trajectory: Trajectory;\n\t}\n\n\tpart context {\n\t\tpart user {\n\t\t\tport massPort: MassPort;\n\t\t\tport initialPositionPort: InitialPositionPort;\n\t\t\tport initialVelocityPort: InitialVelocityPort;\n\t\t\tport timeIntervalPort: TimeIntervalPort;\n\t\t\tport powerInputPort: PowerInputPort;\n\t\t\tperform simulateVehicle.sendMass {\n\t\t\t\tout mass = massPort.mass;\n\t\t\t}\n\t\t\tperform simulateVehicle.sendInitialPosition {\n\t\t\t\tout initialPosition = initialPositionPort.initialPosition;\n\t\t\t}\n\t\t\tperform simulateVehicle.sendInitialVelocity {\n\t\t\t\tout initialVelocity = initialVelocityPort.initialVelocity;\n\t\t\t}\n\t\t\tperform simulateVehicle.sendTimeInterval {\n\t\t\t\tout timeInterval = timeIntervalPort.timeInterval;\n\t\t\t}\n\t\t\tperform simulateVehicle.sendPowerInputs {\n\t\t\t\tout powerInputs = powerInputPort.powerInput;\n\t\t\t}\n\t\t}\n\t\tinterface userToVehicle connect user.massPort to vehicle.massPort {\n\t\t\tref flow references simulateVehicle.massFlow\n\t\t\t\tfrom source.mass to target.mass;\n\t\t}\n\t\tinterface userToVehicle connect user.initialPositionPort to vehicle.initialPositionPort {\n\t\t\tref flow references simulateVehicle.initialPositionFlow\n\t\t\t\tfrom source.initialPosition to target.initialPosition;\n\t\t}\n\t\tinterface userToVehicle connect user.initialVelocityPort to vehicle.initialVelocityPort {\n\t\t\tref flow references simulateVehicle.initialVelocityFlow\n\t\t\t\tfrom source.initialVelocity to target.initialVelocity;\n\t\t}\n\t\tinterface userToVehicle connect user.timeIntervalPort to vehicle.timeIntervalPort {\n\t\t\tref flow references simulateVehicle.timeIntervalFlow\n\t\t\t\tfrom source.timeInterval to target.timeInterval;\n\t\t}\n\t\tinterface userToVehicle connect user.powerInputPort to vehicle.powerInputPort {\n\t\t\tref flow references simulateVehicle.powerInputFlow\n\t\t\t\tfrom source.powerInput to target.powerInput;\n\t\t}\n\t\tinterface vehicleToUser connect vehicle.trajectoryPort to user.trajectoryPort {\n\t\t\tref flow references simulateVehicle.trajectoryFlow\n\t\t\t\tfrom source.trajectory to target.trajectory;\n\t\t}\n\t\tpart vehicle {\n\t\t\tport massPort: ~MassPort;\n\t\t\tport initialPositionPort: ~InitialPositionPort;\n\t\t\tport initialVelocityPort: ~InitialVelocityPort;\n\t\t\tport timeIntervalPort: ~TimeIntervalPort;\n\t\t\tport powerInputPort: ~PowerInputPort;\n\t\t\tport trajectoryPort: TrajectoryPort;\n\t\t\tperform simulateVehicle.initializeSimulation {\n\t\t\t\tin mass = massPort.mass;\n\t\t\t\tin initialPosition = initialPositionPort.initialPosition;\n\t\t\t\tin initialVelocity = initialVelocityPort.initialVelocity;\n\t\t\t\tin timeInterval = timeIntervalPort.timeInterval;\n\t\t\t\tout currentVelocity = initialVelocity;\n\t\t\t\tout currentPosition = initialPosition;\n\t\t\t}\n\t\t\tperform simulateVehicle.processStep {\n\t\t\t\tin mass = massPort.mass;\n\t\t\t\tin timeInterval = timeIntervalPort.timeInterval;\n\t\t\t\tin currentVelocity;\n\t\t\t\tin currentPosition;\n\t\t\t\tin powerInput = powerInputPort.powerInput;\n\t\t\t\tout newVelocity;\n\t\t\t\tout newPosition;\n\t\t\t}\n\t\t\tperform simulateVehicle.outputTrajectory {\n\t\t\t\tin newPosition;\n\t\t\t\tout trajectoryPort.trajectory;\n\t\t\t}\n\t\t}\n\t}\n\taction simulateVehicle {\n\t\tin mass: Mass;\n\t\tin initialPosition: InitialPosition;\n\t\tin initialVelocity: InitialVelocity;\n\t\tin timeInterval: TimeInterval;\n\t\tin powerInputs: Sequence<PowerInput>;\n\t\tout trajectory: Trajectory;\n\n\t\taction initializeSimulation {\n\t\t\tin mass, initialPosition, initialVelocity, timeInterval;\n\t\t\tout currentVelocity, currentPosition;\n\t\t}\n\t\tloop processSteps for (step in powerInputs) {\n\t\t\taction processStep {\n\t\t\t\tin mass, timeInterval, currentVelocity, currentPosition, powerInput;\n\t\t\t\tout newVelocity, newPosition;\n\t\t\t}\n\t\t\tsuccession flow from processStep.newVelocity to processStep.currentVelocity;\n\t\t\tsuccession flow from processStep.newPosition to processStep.currentPosition;\n\t\t}\n\t\taction outputTrajectory {\n\t\t\tin newPosition;\n\t\t\tout trajectory;\n\t\t}\n\t\tsuccession flow from initializeSimulation.currentVelocity to processSteps.processStep.currentVelocity;\n\t\tsuccession flow from initializeSimulation.currentPosition to processSteps.processStep.currentPosition;\n\t\tsuccession flow from processSteps.processStep.newPosition to outputTrajectory.newPosition;\n\t}\n}",
    "package 'CameraSystem' {\n\tattribute def Scene;\n\tattribute def Image;\n\tattribute def Photo;\n\tport def SceneInputPort {\n\t\tout scene: Scene;\n\t}\n\tport def ImagePort {\n\t\tout image: Image;\n\t}\n\tport def PhotoPort {\n\t\tout photo: Photo;\n\t}\n\tpart context {\n\t\tpart user {\n\t\t\tport sceneInputPort: SceneInputPort;\n\t\t\tperform inputScene.sendScene {\n\t\t\t\tout scene = sceneInputPort.scene;\n\t\t\t}\n\t\t}\n\t\tinterface userToCamera connect user.sceneInputPort to camera.sceneInputPort {\n\t\t\tref flow references inputScene.sceneFlow\n\t\t\t\tfrom source.scene to target.scene;\n\t\t}\n\t\tpart camera {\n\t\t\tport sceneInputPort: ~SceneInputPort;\n\t\t\tperform inputScene.focusImage {\n\t\t\t\tin scene = sceneInputPort.scene;\n\t\t\t\tout image = imagePort.image;\n\t\t\t}\n\t\t\tport imagePort: ~ImagePort;\n\t\t\tperform captureImage.generatePhoto {\n\t\t\t\tin image = imagePort.image;\n\t\t\t\tout photo = photoPort.photo;\n\t\t\t}\n\t\t\tport photoPort: PhotoPort;\n\t\t}\n\t\tinterface cameraToDisplay connect camera.photoPort to display.photoPort {\n\t\t\tref flow references generatePhoto.photoFlow\n\t\t\t\tfrom source.photo to target.photo;\n\t\t}\n\t\tpart display {\n\t\t\tport photoPort: ~PhotoPort;\n\t\t\tperform displayPhoto {\n\t\t\t\tin photo = photoPort.photo;\n\t\t\t}\n\t\t}\n\t}\n\taction inputScene {\n\t\taction sendScene { out scene: Scene; }\n\t\tsuccession flow sceneFlow from sendScene.scene to focusImage.scene;\n\t\taction focusImage { in scene: Scene; out image: Image; }\n\t}\n\taction captureImage {\n\t\taction generatePhoto { in image: Image; out photo: Photo; }\n\t}\n\taction displayPhoto {\n\t\taction showPhoto { in photo: Photo; }\n\t\tsuccession flow photoFlow from generatePhoto.photo to showPhoto.photo;\n\t}\n}",
    "package 'CameraSystem' {\n\tattribute def Scene;\n\tattribute def Image;\n\tattribute def Picture;\n\tport def ViewPort {\n\t\tin scene: Scene;\n\t}\n\tport def DisplayPort {\n\t\tout picture: Picture;\n\t}\n\tpart context {\n\t\tpart user {\n\t\t\tport viewPort: ~ViewPort;\n\t\t\tport displayPort: DisplayPort;\n\t\t\tperform selectScene.sendScene {\n\t\t\t\tout scene = viewPort.scene;\n\t\t\t}\n\t\t}\n\t\tinterface userToCamera connect user.viewPort to camera.viewPort {\n\t\t\tref flow references selectScene.sceneFlow\n\t\t\t\tfrom source.scene to target.scene;\n\t\t}\n\t\tpart camera {\n\t\t\tport viewPort: ViewPort;\n\t\t\tport displayPort: ~DisplayPort;\n\t\t\tperform processingWorkflow.focusScene {\n\t\t\t\tin scene = viewPort.scene;\n\t\t\t\tout image = captureImage.image;\n\t\t\t}\n\t\t\tperform processingWorkflow.captureImage {\n\t\t\t\tin image = focusScene.image;\n\t\t\t\tout picture = displayPicture.picture;\n\t\t\t}\n\t\t\tperform processingWorkflow.displayPicture {\n\t\t\t\tin picture = captureImage.picture;\n\t\t\t\tout picture = displayPort.picture;\n\t\t\t}\n\t\t}\n\t}\n\taction selectScene {\n\t\taction sendScene { out scene: Scene; }\n\t\tsuccession flow sceneFlow from sendScene.scene to focusScene.scene;\n\t\taction focusScene { in scene: Scene; out image: Image; }\n\t\tsuccession flow imageFlow from focusScene.image to captureImage.image;\n\t\taction captureImage { in image: Image; out picture: Picture; }\n\t\tsuccession flow pictureFlow from captureImage.picture to displayPicture.picture;\n\t\taction displayPicture { in picture: Picture; out picture: Picture; }\n\t}\n}",
    "package 'SensorManagementSystem' {\n\tattribute def SensorStatus;\n\tattribute def UpdateCmd;\n\tport def SensorStatusPort {\n\t\tout status : SensorStatus;\n\t}\n\tport def UpdateCmdPort {\n\t\tout updateCmd : UpdateCmd;\n\t}\n\tpart context {\n\t\tpart system {\n\t\t\tport sensorStatusPort: ~SensorStatusPort;\n\t\t\tperform manageSensors.checkSensorStatus {\n\t\t\t\tin status = sensorStatusPort.status;\n\t\t\t}\n\t\t\tperform manageSensors.sendUpdateCmd {\n\t\t\t\tin status = checkSensorStatus.status;\n\t\t\t\tout updateCmd = updateCmdPort.updateCmd;\n\t\t\t}\n\t\t\tport updateCmdPort: UpdateCmdPort;\n\t\t}\n\t\tinterface systemToSensorStatus connect system.sensorStatusPort to sensor.sensorStatusPort {\n\t\t\tref flow references manageSensors.statusFlow\n\t\t\t\tfrom source.status to target.status;\n\t\t}\n\t\tinterface systemToSensorCmd connect system.updateCmdPort to sensor.updateCmdPort {\n\t\t\tref flow references manageSensors.updateFlow\n\t\t\t\tfrom source.updateCmd to target.updateCmd;\n\t\t}\n\t\tpart sensor {\n\t\t\tport sensorStatusPort: SensorStatusPort;\n\t\t\tport updateCmdPort: ~UpdateCmdPort;\n\t\t\tperform manageSensors.processUpdate {\n\t\t\t\tin updateCmd = updateCmdPort.updateCmd;\n\t\t\t}\n\t\t}\n\t}\n\taction manageSensors {\n\t\taction checkSensorStatus { in status: SensorStatus; out ready: Boolean; }\n\t\tdecision if (ready) then {\n\t\t\tsuccession flow statusFlow from checkSensorStatus.ready to sendUpdateCmd.status;\n\t\t}\n\t\taction sendUpdateCmd { in status: Boolean; out updateCmd: UpdateCmd; }\n\t\tsuccession flow updateFlow from sendUpdateCmd.updateCmd to processUpdate.updateCmd;\n\t\taction processUpdate { in updateCmd: UpdateCmd; }\n\t}\n}",
    "package 'VehicleStateControl' {\n\tattribute def startSignal;\n\tattribute def powerOnSignal;\n\tattribute def shutdownSignal;\n\tport def StartPort {\n\t\tin startSig : startSignal;\n\t}\n\tport def PowerOnPort {\n\t\tin powerOnSig : powerOnSignal;\n\t}\n\tport def ShutdownPort {\n\t\tin shutdownSig : shutdownSignal;\n\t}\n\tport def StatePort {\n\t\tout state : String;\n\t}\n\tpart context {\n\t\tpart user {\n\t\t\tport startPort: StartPort;\n\t\t\tport powerOnPort: PowerOnPort;\n\t\t\tport shutdownPort: ShutdownPort;\n\t\t\tperform startup.shutdownAction {\n\t\t\t\tout shutdownSig = shutdownPort.shutdownSig;\n\t\t\t}\n\t\t\tperform startup.startAction {\n\t\t\t\tout startSig = startPort.startSig;\n\t\t\t}\n\t\t\tperform startup.powerOnAction {\n\t\t\t\tout powerOnSig = powerOnPort.powerOnSig;\n\t\t\t}\n\t\t}\n\t\tinterface userToVehicle connect user.startPort to vehicle.startPort {\n\t\t\tref flow references startup.startFlow\n\t\t\t\tfrom source.startSig to target.startSig;\n\t\t}\n\t\tinterface userToVehicle connect user.powerOnPort to vehicle.powerOnPort {\n\t\t\tref flow references startup.powerOnFlow\n\t\t\t\tfrom source.powerOnSig to target.powerOnSig;\n\t\t}\n\t\tinterface userToVehicle connect user.shutdownPort to vehicle.shutdownPort {\n\t\t\tref flow references startup.shutdownFlow\n\t\t\t\tfrom source.shutdownSig to target.shutdownSig;\n\t\t}\n\t\tpart vehicle {\n\t\t\tport startPort: ~StartPort;\n\t\t\tport powerOnPort: ~PowerOnPort;\n\t\t\tport shutdownPort: ~ShutdownPort;\n\t\t\tport statePort: StatePort;\n\t\t\tperform startup.transitionToOff {\n\t\t\t\tin shutdownSig = shutdownPort.shutdownSig;\n\t\t\t\tout state = statePort.state;\n\t\t\t}\n\t\t\tperform startup.transitionToStarting {\n\t\t\t\tin startSig = startPort.startSig;\n\t\t\t\tout state = statePort.state;\n\t\t\t}\n\t\t\tperform startup.transitionToOn {\n\t\t\t\tin powerOnSig = powerOnPort.powerOnSig;\n\t\t\t\tout state = statePort.state;\n\t\t\t}\n\t\t}\n\t}\n\taction startup {\n\t\tstate def off;\n\t\tstate def starting;\n\t\tstate def on;\n\t\taction startAction { out startSig: startSignal; }\n\t\taction powerOnAction { out powerOnSig: powerOnSignal; }\n\t\taction shutdownAction { out shutdownSig: shutdownSignal; }\n\t\tsuccession flow startFlow from startAction.startSig to transitionToStarting.startSig;\n\t\tsuccession flow powerOnFlow from powerOnAction.powerOnSig to transitionToOn.powerOnSig;\n\t\tsuccession flow shutdownFlow from shutdownAction.shutdownSig to transitionToOff.shutdownSig;\n\t\taction transitionToStarting {\n\t\t\tin startSig: startSignal;\n\t\t\tout state: String = \"starting\";\n\t\t}\n\t\taction transitionToOn {\n\t\t\tin powerOnSig: powerOnSignal;\n\t\t\tout state: String = \"on\";\n\t\t}\n\t\taction transitionToOff {\n\t\t\tin shutdownSig: shutdownSignal;\n\t\t\tout state: String = \"off\";\n\t\t}\n\t}\n}",
    "package 'VehicleStateManagement' {\n\tattribute def OffState;\n\tattribute def StartingState;\n\tattribute def OnState;\n\tport def ControlSignalPort {\n\t\tin vehicleStartSignal : VehicleStartSignal;\n\t\tin vehicleOnSignal : VehicleOnSignal;\n\t\tin vehicleOffSignal : VehicleOffSignal;\n\t}\n\tpart context {\n\t\tpart vehicle {\n\t\t\tport controlPort : ControlSignalPort;\n\t\t\tperform manageVehicleState {\n\t\t\t\tout initialState = OffState;\n\t\t\t}\n\t\t}\n\t\tinterface controlInterface connect vehicle.controlPort to manageVehicleState.controlFlow {\n\t\t\tref flow references manageVehicleState.startSignalFlow\n\t\t\t\tfrom source.vehicleStartSignal to target.vehicleStartSignal;\n\t\t\tref flow references manageVehicleState.onSignalFlow\n\t\t\t\tfrom source.vehicleOnSignal to target.vehicleOnSignal;\n\t\t\tref flow references manageVehicleState.offSignalFlow\n\t\t\t\tfrom source.vehicleOffSignal to target.vehicleOffSignal;\n\t\t}\n\t}\n\taction manageVehicleState {\n\t\taction initialState { out state : OffState; }\n\t\taction receiveVehicleStartSignal { in state; out nextState : StartingState; }\n\t\tsuccession flow startSignalFlow from receiveVehicleStartSignal.nextState to transitionToStarting.state;\n\t\taction transitionToStarting { in state : StartingState; }\n\t\taction receiveVehicleOnSignal { in state; out nextState : OnState; }\n\t\tsuccession flow onSignalFlow from receiveVehicleOnSignal.nextState to transitionToOn.state;\n\t\taction transitionToOn { in state : OnState; }\n\t\taction receiveVehicleOffSignal { in state; out nextState : OffState; }\n\t\tsuccession flow offSignalFlow from receiveVehicleOffSignal.nextState to initialState.nextState;\n\t}\n}",
    "package 'VehiclePowerManagement' {  \n\tattribute def VehicleStartCmd;  \n\tattribute def VehicleStartedSignal;  \n\tattribute def VehicleShutdownCmd;  \n\tattribute def DiagnosticResult;  \n\tattribute def PowerSupplyStatus;  \n\tattribute def SafetyOperationsStatus;  \n\n\tport def StartCmdPort {  \n\t\tout startCmd : VehicleStartCmd;  \n\t}  \n\tport def ShutdownCmdPort {  \n\t\tout shutdownCmd : VehicleShutdownCmd;  \n\t}  \n\tport def StartedSignalPort {  \n\t\tout startedSignal : VehicleStartedSignal;  \n\t}  \n\tport def DiagnosticPort {  \n\t\tout diagnosticResult : DiagnosticResult;  \n\t}  \n\tport def PowerSupplyPort {  \n\t\tout powerSupply : PowerSupplyStatus;  \n\t}  \n\n\tpart context {  \n\t\tpart user {  \n\t\t\tport startCmdPort: StartCmdPort;  \n\t\t\tport shutdownCmdPort: ShutdownCmdPort;  \n\t\t\tperform powerManagement.sendStartCmd {  \n\t\t\t\tout startCmd = startCmdPort.startCmd;  \n\t\t\t}  \n\t\t\tperform powerManagement.sendShutdownCmd {  \n\t\t\t\tout shutdownCmd = shutdownCmdPort.shutdownCmd;  \n\t\t\t}  \n\t\t}  \n\t\tinterface userToVehicleStart connect user.startCmdPort to vehiclePowerSystem.startCmdPort {  \n\t\t\tref flow references powerManagement.startCmdFlow  \n\t\t\t\tfrom source.startCmd to target.startCmd;  \n\t\t}  \n\t\tinterface userToVehicleShutdown connect user.shutdownCmdPort to vehiclePowerSystem.shutdownCmdPort {  \n\t\t\tref flow references powerManagement.shutdownCmdFlow  \n\t\t\t\tfrom source.shutdownCmd to target.shutdownCmd;  \n\t\t}  \n\n\t\tpart vehiclePowerSystem {  \n\t\t\tport startCmdPort: ~StartCmdPort;  \n\t\t\tport shutdownCmdPort: ~ShutdownCmdPort;  \n\t\t\tport startedSignalPort: StartedSignalPort;  \n\t\t\tport diagnosticPort: DiagnosticPort;  \n\t\t\tport powerSupplyPort: PowerSupplyPort;  \n\n\t\t\tperform powerManagement.transitionToStartPhase {  \n\t\t\t\tin startCmd = startCmdPort.startCmd;  \n\t\t\t\tout startedSignal = startedSignalPort.startedSignal;  \n\t\t\t}  \n\t\t\tperform powerManagement.transitionToPoweredOn {  \n\t\t\t\tin startedSignal = startedSignalPort.startedSignal;  \n\t\t\t\tout diagnosticResult = diagnosticPort.diagnosticResult;  \n\t\t\t\tout powerSupply = powerSupplyPort.powerSupply;  \n\t\t\t}  \n\t\t\tperform powerManagement.executeSafetyOperations {  \n\t\t\t\tin shutdownCmd = shutdownCmdPort.shutdownCmd;  \n\t\t\t\tout safetyStatus = safetySystem.safetyStatus;  \n\t\t\t}  \n\t\t}  \n\n\t\tpart engine {  \n\t\t\tport startedSignalPort: ~StartedSignalPort;  \n\t\t\tperform powerManagement.engineStartup {  \n\t\t\t\tin startedSignal = startedSignalPort.startedSignal;  \n\t\t\t}  \n\t\t}  \n\n\t\tpart safetySystem {  \n\t\t\tport safetyStatusPort: ~PowerSupplyPort;  \n\t\t\tperform powerManagement.parkingBrakeEngagement {  \n\t\t\t\tout powerSupply = safetyStatusPort.powerSupply;  \n\t\t\t}  \n\t\t}  \n\n\t\tpart functionalUnits {  \n\t\t\tport powerSupplyPort: ~PowerSupplyPort;  \n\t\t\tperform powerManagement.receivePower {  \n\t\t\t\tin powerSupply = powerSupplyPort.powerSupply;  \n\t\t\t}  \n\t\t}  \n\t}  \n\n\taction powerManagement {  \n\t\taction sendStartCmd { out startCmd: VehicleStartCmd; }  \n\t\tsuccession flow startCmdFlow from sendStartCmd.startCmd to transitionToStartPhase.startCmd;  \n\t\taction transitionToStartPhase { in startCmd: VehicleStartCmd; out startedSignal: VehicleStartedSignal; }  \n\t\tsuccession flow startedSignalFlow from transitionToStartPhase.startedSignal to transitionToPoweredOn.startedSignal;  \n\t\taction transitionToPoweredOn {  \n\t\t\tin startedSignal: VehicleStartedSignal;  \n\t\t\tout diagnosticResult: DiagnosticResult;  \n\t\t\tout powerSupply: PowerSupplyStatus;  \n\t\t}  \n\t\tsuccession flow diagnosticFlow from transitionToPoweredOn.diagnosticResult to diagnosticResult;  \n\t\tsuccession flow powerSupplyFlow from transitionToPoweredOn.powerSupply to receivePower.powerSupply;  \n\t\taction sendShutdownCmd { out shutdownCmd: VehicleShutdownCmd; }  \n\t\tsuccession flow shutdownCmdFlow from sendShutdownCmd.shutdownCmd to executeSafetyOperations.shutdownCmd;  \n\t\taction executeSafetyOperations {  \n\t\t\tin shutdownCmd: VehicleShutdownCmd;  \n\t\t\tout safetyStatus: PowerSupplyStatus;  \n\t\t}  \n\t\tsuccession flow safetyPowerFlow from executeSafetyOperations.safetyStatus to parkingBrakeEngagement.powerSupply;  \n\t\taction parkingBrakeEngagement { out powerSupply: PowerSupplyStatus; }  \n\t\tsuccession flow finalShutdownFlow from parkingBrakeEngagement.powerSupply to transitionToOff.powerStatus;  \n\t\taction transitionToOff { in powerStatus: PowerSupplyStatus; }  \n\t}  \n}",
    "package 'VehicleStateManagement' {\n\tattribute def VehicleState;\n\tattribute def StartSignal;\n\tattribute def ShutdownSignal;\n\tport def CommandPort {\n\t\tout startSignal : StartSignal;\n\t\tout shutdownSignal : ShutdownSignal;\n\t}\n\tport def StatePort {\n\t\tout vehicleState : VehicleState;\n\t}\n\tpart context {\n\t\tpart user {\n\t\t\tport commandPort: CommandPort;\n\t\t\tperform startupAction.sendStartSignal {\n\t\t\t\tout startSignal = commandPort.startSignal;\n\t\t\t}\n\t\t\tperform shutdownAction.sendShutdownSignal {\n\t\t\t\tout shutdownSignal = commandPort.shutdownSignal;\n\t\t\t}\n\t\t}\n\t\tinterface userToVehicle connect user.commandPort to vehicle.commandPort {\n\t\t\tref flow references startupAction.startSignalFlow\n\t\t\t\tfrom source.startSignal to target.startSignal;\n\t\t\tref flow references shutdownAction.shutdownSignalFlow\n\t\t\t\tfrom source.shutdownSignal to target.shutdownSignal;\n\t\t}\n\t\tpart vehicle {\n\t\t\tport commandPort: ~CommandPort;\n\t\t\tport statePort: StatePort;\n\t\t\tperform startupAction.startupProcess {\n\t\t\t\tin startSignal = commandPort.startSignal;\n\t\t\t\tout vehicleState = statePort.vehicleState;\n\t\t\t}\n\t\t\tperform operationAction.setRunningState {\n\t\t\t\tin startSignal = commandPort.startSignal;\n\t\t\t\tout vehicleState = statePort.vehicleState;\n\t\t\t}\n\t\t\tperform shutdownAction.shutdownProcess {\n\t\t\t\tin shutdownSignal = commandPort.shutdownSignal;\n\t\t\t\tout vehicleState = statePort.vehicleState;\n\t\t\t}\n\t\t}\n\t}\n\taction startupAction {\n\t\taction sendStartSignal { out startSignal: StartSignal; }\n\t\tsuccession flow startSignalFlow from sendStartSignal.startSignal to startupProcess.startSignal;\n\t\taction startupProcess { in startSignal: StartSignal; out vehicleState: VehicleState; }\n\t\tsuccession flow startupToOperationFlow from startupProcess.vehicleState to setRunningState.vehicleState;\n\t}\n\taction operationAction {\n\t\taction setRunningState { in vehicleState: VehicleState; out vehicleState: VehicleState; }\n\t}\n\taction shutdownAction {\n\t\taction sendShutdownSignal { out shutdownSignal: ShutdownSignal; }\n\t\tsuccession flow shutdownSignalFlow from sendShutdownSignal.shutdownSignal to shutdownProcess.shutdownSignal;\n\t\taction shutdownProcess { in shutdownSignal: ShutdownSignal; out vehicleState: VehicleState; }\n\t\tsuccession flow operationToShutdownFlow from setRunningState.vehicleState to shutdownProcess.vehicleState;\n\t}\n}",
    "package 'VehiclePowerManagement' {\n\tattribute def StartSignal;\n\tattribute def OnSignal;\n\tattribute def OffSignal;\n\tattribute def HealthStatus;\n\tport def StartSignalPort {\n\t\tout startSignal : StartSignal;\n\t}\n\tport def OnSignalPort {\n\t\tout onSignal : OnSignal;\n\t}\n\tport def OffSignalPort {\n\t\tout offSignal : OffSignal;\n\t}\n\tport def HealthPort {\n\t\tout healthStatus: HealthStatus;\n\t}\n\tpart context {\n\t\tpart user {\n\t\t\tport startSignalPort: StartSignalPort;\n\t\t\tperform transitionToStart.sendStartSignal {\n\t\t\t\tout startSignal = startSignalPort.startSignal;\n\t\t\t}\n\t\t\tport onSignalPort: OnSignalPort;\n\t\t\tperform transitionToOn.sendOnSignal {\n\t\t\t\tout onSignal = onSignalPort.onSignal;\n\t\t\t}\n\t\t\tport offSignalPort: OffSignalPort;\n\t\t\tperform transitionToOff.sendOffSignal {\n\t\t\t\tout offSignal = offSignalPort.offSignal;\n\t\t\t}\n\t\t}\n\t\tinterface userToVehicle connect user.startSignalPort to vehicle.startSignalPort {\n\t\t\tref flow references transitionToStart.startSignalFlow\n\t\t\t\tfrom source.startSignal to target.startSignal;\n\t\t}\n\t\tinterface userToVehicleOn connect user.onSignalPort to vehicle.onSignalPort {\n\t\t\tref flow references transitionToOn.onSignalFlow\n\t\t\t\tfrom source.onSignal to target.onSignal;\n\t\t}\n\t\tinterface userToVehicleOff connect user.offSignalPort to vehicle.offSignalPort {\n\t\t\tref flow references transitionToOff.offSignalFlow\n\t\t\t\tfrom source.offSignal to target.offSignal;\n\t\t}\n\t\tpart vehicle {\n\t\t\tport startSignalPort: ~StartSignalPort;\n\t\t\tport onSignalPort: ~OnSignalPort;\n\t\t\tport offSignalPort: ~OffSignalPort;\n\t\t\tattribute operatingState: Off;\n\t\t\tperform transitionToStart.updateOperatingState {\n\t\t\t\tin startSignal = startSignalPort.startSignal;\n\t\t\t\tout operatingState = Start;\n\t\t\t}\n\t\t\tperform transitionToOn.updateOperatingState {\n\t\t\t\tin onSignal = onSignalPort.onSignal;\n\t\t\t\tout operatingState = On;\n\t\t\t}\n\t\t\tperform transitionToOff.updateOperatingState {\n\t\t\t\tin offSignal = offSignalPort.offSignal;\n\t\t\t\tout operatingState = Off;\n\t\t\t}\n\t\t}\n\t\tpart healthManager {\n\t\t\tport healthPort: ~HealthPort;\n\t\t\tperform monitorHealth.generateHealthStatus {\n\t\t\t\tout healthStatus = healthPort.healthStatus;\n\t\t\t}\n\t\t}\n\t}\n\taction transitionToStart {\n\t\taction sendStartSignal { out startSignal: StartSignal; }\n\t\tsuccession flow startSignalFlow from sendStartSignal.startSignal to updateOperatingState.startSignal;\n\t\taction updateOperatingState { in startSignal: StartSignal; out operatingState: Start; }\n\t}\n\taction transitionToOn {\n\t\taction sendOnSignal { out onSignal: OnSignal; }\n\t\tsuccession flow onSignalFlow from sendOnSignal.onSignal to updateOperatingState.onSignal;\n\t\taction updateOperatingState { in onSignal: OnSignal; out operatingState: On; }\n\t}\n\taction transitionToOff {\n\t\taction sendOffSignal { out offSignal: OffSignal; }\n\t\tsuccession flow offSignalFlow from sendOffSignal.offSignal to updateOperatingState.offSignal;\n\t\taction updateOperatingState { in offSignal: OffSignal; out operatingState: Off; }\n\t}\n\taction monitorHealth {\n\t\taction generateHealthStatus { out healthStatus: HealthStatus; }\n\t}\n}",
    "package 'VehicleHealthMonitoringSystem' {\n\tattribute def CurrentTemperature;\n\tattribute def MaxAllowableTemperature;\n\tattribute def HealthStatus;\n\tattribute def MaintenanceStatus;\n\tattribute def NextMaintenanceTime;\n\tattribute def MaintenanceDuration;\n\tport def TemperaturePort {\n\t\tout currentTemperature : CurrentTemperature;\n\t}\n\tport def WarningPort {\n\t\tout warning: Boolean;\n\t}\n\tport def StatusPort {\n\t\tout healthStatus: HealthStatus;\n\t}\n\tport def MaintenancePort {\n\t\tout maintenanceStatus: MaintenanceStatus;\n\t\tout nextMaintenanceTime: NextMaintenanceTime;\n\t}\n\tport def ClockPort {\n\t\tout currentTime: CurrentTime;\n\t}\n\tpart context {\n\t\tpart temperatureSensor {\n\t\t\tport tempPort: TemperaturePort;\n\t\t\tperform monitorTemperature.sendCurrentTemp {\n\t\t\t\tout currentTemperature = tempPort.currentTemperature;\n\t\t\t}\n\t\t}\n\t\tinterface sensorToController connect temperatureSensor.tempPort to controller.tempPort {\n\t\t\tref flow references monitorTemperature.tempFlow\n\t\t\t\tfrom source.currentTemperature to target.currentTemp;\n\t\t}\n\t\tpart controller {\n\t\t\tport tempPort: ~TemperaturePort;\n\t\t\tport warningPort: WarningPort;\n\t\t\tport statusPort: StatusPort;\n\t\t\tperform monitorTemperature.compareTemperature {\n\t\t\t\tin currentTemp = tempPort.currentTemperature;\n\t\t\t\tout warning = warningPort.warning;\n\t\t\t\tout healthStatus = statusPort.healthStatus;\n\t\t\t}\n\t\t\tperform maintenanceScheduler.updateMaintenanceStatus {\n\t\t\t\tin currentTime = clock.currentTime;\n\t\t\t\tout maintenanceStatus = statusPort.healthStatus;\n\t\t\t}\n\t\t}\n\t\tpart maintenanceScheduler {\n\t\t\tport statusPort: ~StatusPort;\n\t\t\tport maintenancePort: MaintenancePort;\n\t\t\tperform maintenanceCycle.enterMaintenance {\n\t\t\t\tin maintenanceTrigger = statusPort.healthStatus;\n\t\t\t\tout maintenanceStatus = maintenancePort.maintenanceStatus;\n\t\t\t\tout nextMaintenanceTime = maintenancePort.nextMaintenanceTime;\n\t\t\t}\n\t\t\tperform maintenanceCycle.exitMaintenance {\n\t\t\t\tin duration = maintenancePort.maintenanceStatus;\n\t\t\t\tout healthStatus = statusPort.healthStatus;\n\t\t\t}\n\t\t}\n\t\tpart clock {\n\t\t\tport clockPort: ClockPort;\n\t\t\tperform maintenanceCycle.provideCurrentTime {\n\t\t\t\tout currentTime = clockPort.currentTime;\n\t\t\t}\n\t\t}\n\t}\n\taction monitorTemperature {\n\t\taction sendCurrentTemp { out currentTemperature: CurrentTemperature; }\n\t\tsuccession flow tempFlow from sendCurrentTemp.currentTemperature to compareTemperature.currentTemp;\n\t\taction compareTemperature { \n\t\t\tin currentTemp: CurrentTemperature; \n\t\t\tout warning: Boolean; \n\t\t\tout healthStatus: HealthStatus; \n\t\t\tif (currentTemp > MaxAllowableTemperature) {\n\t\t\t\tout warning = true;\n\t\t\t\tout healthStatus = \"Degraded\";\n\t\t\t} else {\n\t\t\t\tout healthStatus = \"Normal\";\n\t\t\t}\n\t\t}\n\t}\n\taction maintenanceCycle {\n\t\taction provideCurrentTime { out currentTime: CurrentTime; }\n\t\tsuccession flow timeFlow from provideCurrentTime.currentTime to enterMaintenance.currentTime;\n\t\taction enterMaintenance { \n\t\t\tin currentTime: CurrentTime; \n\t\t\tout maintenanceStatus: MaintenanceStatus; \n\t\t\tout nextMaintenanceTime: NextMaintenanceTime; \n\t\t\tif (currentTime >= NextMaintenanceTime) {\n\t\t\t\tout maintenanceStatus = \"Maintenance\";\n\t\t\t\tout nextMaintenanceTime = currentTime + 30d; // Example: 30-day cycle\n\t\t\t}\n\t\t}\n\t\tsuccession flow maintenanceFlow from enterMaintenance.maintenanceStatus to exitMaintenance.duration;\n\t\taction exitMaintenance { \n\t\t\tin duration: MaintenanceStatus; \n\t\t\tout healthStatus: HealthStatus; \n\t\t\tif (duration >= 48h) {\n\t\t\t\tout healthStatus = \"Normal\";\n\t\t\t}\n\t\t}\n\t}\n}",
    "package 'ServerSystem' {\n\tattribute def Command;\n\tattribute def Time;\n\tport def RequestPort {\n\t\tin command: Command;\n\t}\n\tpart context {\n\t\tpart user {\n\t\t\tport requestPort: RequestPort;\n\t\t\tperform serverStateMachine.sendStartCommand {\n\t\t\t\tout command = requestPort.command;\n\t\t\t}\n\t\t\tperform serverStateMachine.sendRequestCommand {\n\t\t\t\tout command = requestPort.command;\n\t\t\t}\n\t\t}\n\t\tinterface userToServer connect user.requestPort to server.requestPort {\n\t\t\tref flow references serverStateMachine.startFlow, serverStateMachine.requestFlow, serverStateMachine.dailyReset1, serverStateMachine.dailyReset2;\n\t\t}\n\t\tpart server {\n\t\t\tport requestPort: ~RequestPort;\n\t\t\tattribute clock: Time;\n\t\t\tperform serverStateMachine.offState { ... }\n\t\t\tperform serverStateMachine.waitingState { ... }\n\t\t\tperform serverStateMachine.responseState { ... }\n\t\t}\n\t}\n\taction serverStateMachine {\n\t\taction sendStartCommand { out command: Command; }\n\t\taction sendRequestCommand { out command: Command; }\n\t\taction offState { }\n\t\taction waitingState { }\n\t\taction responseState { }\n\n\t\tsuccession flow startFlow from sendStartCommand.command to waitingState.command when (command == \"start\");\n\t\tsuccession flow requestFlow from sendRequestCommand.command to responseState.command when (command == \"request\");\n\t\tsuccession flow delayFlow from responseState to waitingState after 5 minutes;\n\t\tsuccession flow dailyReset1 from waitingState to offState when (clock == \"11:59:00\");\n\t\tsuccession flow dailyReset2 from responseState to offState when (clock == \"11:59:00\");\n\t}\n}",
    "package 'VehicleStartStopControl' {\n\tattribute def StartSignal;\n\tattribute def StopSignal;\n\tattribute def BrakeStatus;\n\tattribute def StartCmd;\n\tattribute def PowerSupply;\n\tattribute def ParkingBrakeCmd;\n\tport def StartSignalPort {\n\t\tin startSignal : StartSignal;\n\t}\n\tport def StopSignalPort {\n\t\tin stopSignal : StopSignal;\n\t}\n\tport def BrakeStatusPort {\n\t\tout brakeStatus : BrakeStatus;\n\t}\n\tport def ControllerStartPort {\n\t\tout startCmd : StartCmd;\n\t}\n\tport def ParkingBrakePort {\n\t\tout applyBrake : ParkingBrakeCmd;\n\t}\n\tpart context {\n\t\tpart vehicle {\n\t\t\tport startSignalPort: StartSignalPort;\n\t\t\tport stopSignalPort: StopSignalPort;\n\t\t\tport brakeStatusPort: ~BrakeStatusPort;\n\t\t\tport controllerStartPort: ControllerStartPort;\n\t\t\tport parkingBrakePort: ParkingBrakePort;\n\t\t\tperform startStopControl.receiveStartSignal {\n\t\t\t\tin startSignal = startSignalPort.startSignal;\n\t\t\t}\n\t\t\tperform startStopControl.checkBrakeStatus {\n\t\t\t\tin brakeStatus = brakeStatusPort.brakeStatus;\n\t\t\t}\n\t\t\tperform startStopControl.sendStartToController {\n\t\t\t\tout startCmd = controllerStartPort.startCmd;\n\t\t\t}\n\t\t\tperform startStopControl.enterOperating {\n\t\t\t\tref flow references startStopControl.operatingFlow\n\t\t\t\t\tfrom source.entry to target.entry;\n\t\t\t}\n\t\t\tperform startStopControl.performSelfCheck {\n\t\t\t\tref flow references startStopControl.selfCheckFlow\n\t\t\t\t\tfrom source.entry to target.entry;\n\t\t\t}\n\t\t\tperform startStopControl.supplyPower {\n\t\t\t\tout power = powerSupply;\n\t\t\t}\n\t\t\tperform startStopControl.receiveStopSignal {\n\t\t\t\tin stopSignal = stopSignalPort.stopSignal;\n\t\t\t}\n\t\t\tperform startStopControl.sendStopToController {\n\t\t\t\tout stopCmd = controllerStartPort.startCmd;\n\t\t\t}\n\t\t\tperform startStopControl.applyParkingBrake {\n\t\t\t\tout applyBrake = parkingBrakePort.applyBrake;\n\t\t\t}\n\t\t\tperform startStopControl.exitToOff {\n\t\t\t\tref flow references startStopControl.offFlow\n\t\t\t\t\tfrom source.exit to target.exit;\n\t\t\t}\n\t\t}\n\t\tinterface vehicleToBrake connect vehicle.brakeStatusPort to brakePedal.brakeStatusPort {\n\t\t\tref flow references startStopControl.brakeStatusFlow\n\t\t\t\tfrom source.brakeStatus to target.brakeStatus;\n\t\t}\n\t\tinterface vehicleToController connect vehicle.controllerStartPort to controller.controllerStartPort {\n\t\t\tref flow references startStopControl.startCmdFlow\n\t\t\t\tfrom source.startCmd to target.startCmd;\n\t\t\tref flow references startStopControl.stopCmdFlow\n\t\t\t\tfrom source.stopCmd to target.startCmd;\n\t\t}\n\t\tinterface vehicleToParkingBrake connect vehicle.parkingBrakePort to parkingBrake.applyPort {\n\t\t\tref flow references startStopControl.parkingBrakeFlow\n\t\t\t\tfrom source.applyBrake to target.applyBrake;\n\t\t}\n\t\tpart brakePedal {\n\t\t\tport brakeStatusPort: ~BrakeStatusPort;\n\t\t}\n\t\tpart controller {\n\t\t\tport controllerStartPort: ~ControllerStartPort;\n\t\t}\n\t\tpart parkingBrake {\n\t\t\tport applyPort: ~ParkingBrakePort;\n\t\t}\n\t}\n\taction startStopControl {\n\t\taction receiveStartSignal { in startSignal: StartSignal; }\n\t\tsuccession flow startTriggerFlow from receiveStartSignal.startSignal to checkBrakeStatus.brakeStatus;\n\t\taction checkBrakeStatus { in brakeStatus: BrakeStatus; }\n\t\tsuccession flow startCmdFlow from checkBrakeStatus.brakeStatus to sendStartToController.startCmd;\n\t\taction sendStartToController { out startCmd: StartCmd; }\n\t\tsuccession flow operatingFlow from sendStartToController.startCmd to enterOperating.entry;\n\t\taction enterOperating { }\n\t\tsuccession flow selfCheckFlow from enterOperating.entry to performSelfCheck.entry;\n\t\taction performSelfCheck { }\n\t\tsuccession flow powerFlow from performSelfCheck.exit to supplyPower.entry;\n\t\taction supplyPower { out power: PowerSupply; }\n\t\taction receiveStopSignal { in stopSignal: StopSignal; }\n\t\tsuccession flow stopTriggerFlow from receiveStopSignal.stopSignal to sendStopToController.stopCmd;\n\t\taction sendStopToController { out stopCmd: StopSignal; }\n\t\tsuccession flow stopCmdFlow from sendStopToController.stopCmd to applyParkingBrake.applyBrake;\n\t\taction applyParkingBrake { out applyBrake: ParkingBrakeCmd; }\n\t\tsuccession flow offFlow from applyParkingBrake.applyBrake to exitToOff.exit;\n\t\taction exitToOff { }\n\t}\n}",
    "package 'VehicleControlSystem' {\n\tattribute def StartSignal;\n\tattribute def BrakeDepressed;\n\tattribute def VehicleOnSignal;\n\tattribute def StartControlSignal;\n\tattribute def ShutdownSignal;\n\tattribute def ParkingBrakeApplied;\n\tport def StartSignalPort {\n\t\tin startSignal : StartSignal;\n\t}\n\tport def BrakePort {\n\t\tin brakeDepressed : BrakeDepressed;\n\t}\n\tport def VehicleOnPort {\n\t\tin vehicleOn : VehicleOnSignal;\n\t}\n\tport def StartControlPort {\n\t\tout startControl : StartControlSignal;\n\t}\n\tport def ShutdownPort {\n\t\tin shutdownSignal : ShutdownSignal;\n\t}\n\tport def ParkingBrakePort {\n\t\tout parkingBrake : ParkingBrakeApplied;\n\t}\n\tpart context {\n\t\tpart driver {\n\t\t\tport startSignalPort: StartSignalPort;\n\t\t\tperform startupProcess.receiveStartSignal {\n\t\t\t\tin startSignal = startSignalPort.startSignal;\n\t\t\t}\n\t\t}\n\t\tinterface driverToSystem connect driver.startSignalPort to system.startSignalPort {\n\t\t\tref flow references startupProcess.startSignalFlow\n\t\t\t\tfrom source.startSignal to target.startSignal;\n\t\t}\n\t\tpart system {\n\t\t\tport startSignalPort: ~StartSignalPort;\n\t\t\tport brakePort: ~BrakePort;\n\t\t\tport vehicleOnPort: ~VehicleOnPort;\n\t\t\tport startControlPort: ~StartControlPort;\n\t\t\tport shutdownPort: ~ShutdownPort;\n\t\t\tport parkingBrakePort: ~ParkingBrakePort;\n\t\t\t\n\t\t\tperform startupProcess.checkBrakeAndVehicleOn {\n\t\t\t\tin startSignal = startSignalPort.startSignal;\n\t\t\t\tin brakeDepressed = brakePort.brakeDepressed;\n\t\t\t\tin vehicleOn = vehicleOnPort.vehicleOn;\n\t\t\t\tout startControl = startControlPort.startControl;\n\t\t\t}\n\t\t\t\n\t\t\tperform startupProcess.sendStartControl {\n\t\t\t\tin startControl = checkBrakeAndVehicleOn.startControl;\n\t\t\t\tout startControl = startControlPort.startControl;\n\t\t\t}\n\t\t\t\n\t\t\tperform operationProcess.performSelfCheck { }\n\t\t\tperform operationProcess.supplyPower { }\n\t\t\t\n\t\t\tperform shutdownProcess.receiveShutdownSignal {\n\t\t\t\tin shutdownSignal = shutdownPort.shutdownSignal;\n\t\t\t}\n\t\t\tperform shutdownProcess.applyParkingBrake {\n\t\t\t\tout parkingBrake = parkingBrakePort.parkingBrake;\n\t\t\t}\n\t\t\tperform shutdownProcess.switchToOff {\n\t\t\t\tin parkingBrakeApplied = applyParkingBrake.parkingBrake;\n\t\t\t}\n\t\t}\n\t\tinterface systemToController connect system.startControlPort to vehicleController.startControlPort {\n\t\t\tref flow references startupProcess.startControlFlow\n\t\t\t\tfrom source.startControl to target.startControl;\n\t\t}\n\t\tpart vehicleController {\n\t\t\tport startControlPort: ~StartControlPort;\n\t\t\tperform startupProcess.activateEngine {\n\t\t\t\tin startControl = startControlPort.startControl;\n\t\t\t}\n\t\t}\n\t\tinterface systemToBrake connect system.brakePort to brakeSystem.brakePort {\n\t\t\tref flow references startupProcess.brakeSignalFlow\n\t\t\t\tfrom source.brakeDepressed to target.brakeDepressed;\n\t\t}\n\t\tpart brakeSystem {\n\t\t\tport brakePort: ~BrakePort;\n\t\t}\n\t\tinterface systemToParkingBrake connect system.parkingBrakePort to parkingBrake.parkingBrakePort {\n\t\t\tref flow references shutdownProcess.parkingBrakeFlow\n\t\t\t\tfrom source.parkingBrake to target.parkingBrake;\n\t\t}\n\t\tpart parkingBrake {\n\t\t\tport parkingBrakePort: ~ParkingBrakePort;\n\t\t}\n\t}\n\taction startupProcess {\n\t\taction receiveStartSignal { in startSignal: StartSignal; }\n\t\tsuccession flow startSignalFlow from receiveStartSignal.startSignal to checkBrakeAndVehicleOn.startSignal;\n\t\taction checkBrakeAndVehicleOn { \n\t\t\tin startSignal; \n\t\t\tin brakeDepressed: BrakeDepressed; \n\t\t\tin vehicleOn: VehicleOnSignal; \n\t\t\tout startControl: StartControlSignal; \n\t\t}\n\t\tsuccession flow brakeSignalFlow from brakeSystem.brakeDepressed to checkBrakeAndVehicleOn.brakeDepressed;\n\t\tsuccession flow vehicleOnSignalFlow from brakeSystem.vehicleOn to checkBrakeAndVehicleOn.vehicleOn;\n\t\taction sendStartControl { out startControl: StartControlSignal; }\n\t\tsuccession flow startControlFlow from sendStartControl.startControl to activateEngine.startControl;\n\t\taction activateEngine { in startControl: StartControlSignal; }\n\t}\n\taction operationProcess {\n\t\taction performSelfCheck { }\n\t\taction supplyPower { }\n\t}\n\taction shutdownProcess {\n\t\taction receiveShutdownSignal { in shutdownSignal: ShutdownSignal; }\n\t\tsuccession flow shutdownSignalFlow from receiveShutdownSignal.shutdownSignal to applyParkingBrake.shutdownSignal;\n\t\taction applyParkingBrake { out parkingBrake: ParkingBrakeApplied; }\n\t\tsuccession flow parkingBrakeFlow from applyParkingBrake.parkingBrake to switchToOff.parkingBrakeApplied;\n\t\taction switchToOff { in parkingBrakeApplied: ParkingBrakeApplied; }\n\t}\n}",
    "package 'CruiseControlSystem' {\n\tattribute def SetSpeedCmd;\n\tattribute def ActualSpeed;\n\tattribute def FuelCtrlCmd;\n\tport def SetSpeedCmdPort {\n\t\tout setSpeedCmd : SetSpeedCmd;\n\t}\n\tport def ActualSpeedPort {\n\t\tout actualSpeed : ActualSpeed;\n\t}\n\tport def FuelCtrlCmdPort {\n\t\tin fuelCtrlCmd : FuelCtrlCmd;\n\t}\n\tpart context {\n\t\tpart driver {\n\t\t\tport setSpeedCmdPort: SetSpeedCmdPort;\n\t\t\tperform activateCruiseControl.sendSetSpeedCmd {\n\t\t\t\tout setSpeedCmd = setSpeedCmdPort.setSpeedCmd;\n\t\t\t}\n\t\t}\n\t\tinterface driverToCruiseController connect driver.setSpeedCmdPort to cruiseController.setSpeedCmdPort {\n\t\t\tref flow references activateCruiseControl.setSpeedCmdFlow\n\t\t\t\tfrom source.setSpeedCmd to target.setSpeedCmd;\n\t\t}\n\t\tpart cruiseController {\n\t\t\tport setSpeedCmdPort: ~SetSpeedCmdPort;\n\t\t\tport actualSpeedPort: ~ActualSpeedPort;\n\t\t\tport fuelCtrlCmdPort: FuelCtrlCmdPort;\n\t\t\tperform activateCruiseControl.receiveSetSpeedCmd {\n\t\t\t\tin setSpeedCmd = setSpeedCmdPort.setSpeedCmd;\n\t\t\t}\n\t\t\tperform activateCruiseControl.getActualSpeed {\n\t\t\t\tin actualSpeed = actualSpeedPort.actualSpeed;\n\t\t\t}\n\t\t\tperform activateCruiseControl.generateFuelCtrlCmd {\n\t\t\t\tout fuelCtrlCmd = fuelCtrlCmdPort.fuelCtrlCmd;\n\t\t\t}\n\t\t}\n\t\tpart speedometer {\n\t\t\tport actualSpeedPort: ActualSpeedPort;\n\t\t\tperform activateCruiseControl.collectActualSpeed {\n\t\t\t\tout actualSpeed = actualSpeedPort.actualSpeed;\n\t\t\t}\n\t\t}\n\t\tinterface speedometerToCruiseController connect speedometer.actualSpeedPort to cruiseController.actualSpeedPort {\n\t\t\tref flow references activateCruiseControl.actualSpeedFlow\n\t\t\t\tfrom source.actualSpeed to target.actualSpeed;\n\t\t}\n\t\tpart engine {\n\t\t\tport fuelCtrlCmdPort: ~FuelCtrlCmdPort;\n\t\t\tperform activateCruiseControl.adjustOutput {\n\t\t\t\tin fuelCtrlCmd = fuelCtrlCmdPort.fuelCtrlCmd;\n\t\t\t}\n\t\t}\n\t\tinterface cruiseControllerToEngine connect cruiseController.fuelCtrlCmdPort to engine.fuelCtrlCmdPort {\n\t\t\tref flow references activateCruiseControl.fuelCtrlCmdFlow\n\t\t\t\tfrom source.fuelCtrlCmd to target.fuelCtrlCmd;\n\t\t}\n\t\tpart vehicle {\n\t\t\t// Structural container for system components\n\t\t}\n\t}\n\taction activateCruiseControl {\n\t\taction sendSetSpeedCmd { out setSpeedCmd: SetSpeedCmd; }\n\t\tsuccession flow setSpeedCmdFlow from sendSetSpeedCmd.setSpeedCmd to receiveSetSpeedCmd.setSpeedCmd;\n\t\taction receiveSetSpeedCmd { in setSpeedCmd: SetSpeedCmd; }\n\t\taction collectActualSpeed { out actualSpeed: ActualSpeed; }\n\t\tsuccession flow actualSpeedFlow from collectActualSpeed.actualSpeed to getActualSpeed.actualSpeed;\n\t\taction getActualSpeed { in actualSpeed: ActualSpeed; }\n\t\taction generateFuelCtrlCmd { in setSpeedCmd: SetSpeedCmd; in actualSpeed: ActualSpeed; out fuelCtrlCmd: FuelCtrlCmd; }\n\t\tsuccession flow fuelCtrlCmdFlow from generateFuelCtrlCmd.fuelCtrlCmd to adjustOutput.fuelCtrlCmd;\n\t\taction adjustOutput { in fuelCtrlCmd: FuelCtrlCmd; }\n\t}\n}",
    "package 'CruiseControl' {  \n\tattribute def SetSpeedCmd;  \n\tattribute def VehicleSpeed;  \n\tattribute def ThrottleCmd;  \n\tport def SetSpeedPort {  \n\t\tout setSpeedCmd : SetSpeedCmd;  \n\t}  \n\tport def VehicleSpeedPort {  \n\t\tout vehicleSpeed : VehicleSpeed;  \n\t}  \n\tport def ThrottlePort {  \n\t\tout throttleCmd : ThrottleCmd;  \n\t}  \n\tpart context {  \n\t\tpart driver {  \n\t\t\tport setSpeedPort: SetSpeedPort;  \n\t\t\tperform cruiseControlAction.sendSetSpeedCmd {  \n\t\t\t\tout setSpeedCmd = setSpeedPort.setSpeedCmd;  \n\t\t\t}  \n\t\t}  \n\t\tinterface driverToController connect driver.setSpeedPort to cruiseController.setSpeedPort {  \n\t\t\tref flow references cruiseControlAction.setSpeedFlow  \n\t\t\t\tfrom source.setSpeedCmd to target.setSpeedCmd;  \n\t\t}  \n\t\tpart cruiseController {  \n\t\t\tport setSpeedPort: ~SetSpeedPort;  \n\t\t\tport vehicleSpeedPort: ~VehicleSpeedPort;  \n\t\t\tport throttlePort: ThrottlePort;  \n\t\t\tperform cruiseControlAction.acquireVehicleSpeed {  \n\t\t\t\tout vehicleSpeed = vehicleSpeedPort.vehicleSpeed;  \n\t\t\t}  \n\t\t\tperform cruiseControlAction.computeThrottleCmd {  \n\t\t\t\tin setSpeedCmd = setSpeedPort.setSpeedCmd;  \n\t\t\t\tin vehicleSpeed = vehicleSpeedPort.vehicleSpeed;  \n\t\t\t\tout throttleCmd = throttlePort.throttleCmd;  \n\t\t\t}  \n\t\t}  \n\t\tinterface controllerToSpeedometer connect cruiseController.vehicleSpeedPort to speedometer.vehicleSpeedPort {  \n\t\t\tref flow references cruiseControlAction.vehicleSpeedFlow  \n\t\t\t\tfrom source.vehicleSpeed to target.vehicleSpeed;  \n\t\t}  \n\t\tpart speedometer {  \n\t\t\tport vehicleSpeedPort: ~VehicleSpeedPort;  \n\t\t\tperform cruiseControlAction.provideVehicleSpeed {  \n\t\t\t\tout vehicleSpeed = vehicleSpeedPort.vehicleSpeed;  \n\t\t\t}  \n\t\t}  \n\t\tinterface controllerToEngine connect cruiseController.throttlePort to engine.throttlePort {  \n\t\t\tref flow references cruiseControlAction.throttleFlow  \n\t\t\t\tfrom source.throttleCmd to target.throttleCmd;  \n\t\t}  \n\t\tpart engine {  \n\t\t\tport throttlePort: ~ThrottlePort;  \n\t\t\tperform cruiseControlAction.applyThrottleCmd {  \n\t\t\t\tin throttleCmd = throttlePort.throttleCmd;  \n\t\t\t}  \n\t\t}  \n\t}  \n\taction cruiseControlAction {  \n\t\taction sendSetSpeedCmd { out setSpeedCmd: SetSpeedCmd; }  \n\t\tsuccession flow setSpeedFlow from sendSetSpeedCmd.setSpeedCmd to acquireVehicleSpeed.setSpeedCmd;  \n\t\taction acquireVehicleSpeed { in setSpeedCmd: SetSpeedCmd; out vehicleSpeed: VehicleSpeed; }  \n\t\tsuccession flow vehicleSpeedFlow from acquireVehicleSpeed.vehicleSpeed to provideVehicleSpeed.vehicleSpeed;  \n\t\taction computeThrottleCmd { in setSpeedCmd: SetSpeedCmd; in vehicleSpeed: VehicleSpeed; out throttleCmd: ThrottleCmd; }  \n\t\tsuccession flow throttleFlow from computeThrottleCmd.throttleCmd to applyThrottleCmd.throttleCmd;  \n\t\taction provideVehicleSpeed { out vehicleSpeed: VehicleSpeed; }  \n\t\taction applyThrottleCmd { in throttleCmd: ThrottleCmd; }  \n\t}  \n}",
    "package 'CruiseControl' {  \n\tattribute def SetSpeedCmd;  \n\tattribute def CurrentSpeed;  \n\tattribute def ThrottleCmd;  \n\tport def SetSpeedPort { out setSpeedCmd : SetSpeedCmd; }  \n\tport def CurrentSpeedPort { out currentSpeed : CurrentSpeed; }  \n\tport def ThrottlePort { out throttleCmd : ThrottleCmd; }  \n\t  \n\tpart context {  \n\t\tpart driver {  \n\t\t\tport setSpeedPort: SetSpeedPort;  \n\t\t\tperform cruiseControlRegion.sendSetSpeedCmd {  \n\t\t\t\tout setSpeedCmd = setSpeedPort.setSpeedCmd;  \n\t\t\t}  \n\t\t}  \n\t\tinterface driverToController connect driver.setSpeedPort to cruiseController.setSpeedPort {  \n\t\t\tref flow references cruiseControlRegion.setSpeedFlow  \n\t\t\t\tfrom source.setSpeedCmd to target.setSpeedCmd;  \n\t\t}  \n\t\tpart cruiseController {  \n\t\t\tport setSpeedPort: ~SetSpeedPort;  \n\t\t\tport currentSpeedPort: ~CurrentSpeedPort;  \n\t\t\tport throttlePort: ThrottlePort;  \n\t\t\tperform cruiseControlRegion.compareSpeeds {  \n\t\t\t\tin setSpeedCmd = setSpeedPort.setSpeedCmd;  \n\t\t\t\tin currentSpeed = currentSpeedPort.currentSpeed;  \n\t\t\t\tout speedDifference = calculateDifference.speedDifference;  \n\t\t\t}  \n\t\t\tperform cruiseControlRegion.calculateDifference {  \n\t\t\t\tin setSpeedCmd;  \n\t\t\t\tin currentSpeed;  \n\t\t\t\tout speedDifference;  \n\t\t\t}  \n\t\t\tperform cruiseControlRegion.generateThrottleCmd {  \n\t\t\t\tin speedDifference = calculateDifference.speedDifference;  \n\t\t\t\tout throttleCmd = throttlePort.throttleCmd;  \n\t\t\t}  \n\t\t}  \n\t\tinterface controllerToSpeedometer connect cruiseController.currentSpeedPort to speedometer.currentSpeedPort {  \n\t\t\tref flow references cruiseControlRegion.currentSpeedFlow  \n\t\t\t\tfrom source.currentSpeed to target.currentSpeed;  \n\t\t}  \n\t\tinterface controllerToEngine connect cruiseController.throttlePort to engine.throttlePort {  \n\t\t\tref flow references cruiseControlRegion.throttleCmdFlow  \n\t\t\t\tfrom source.throttleCmd to target.throttleCmd;  \n\t\t}  \n\t\tpart speedometer {  \n\t\t\tport currentSpeedPort: ~CurrentSpeedPort;  \n\t\t\tperform cruiseControlRegion.provideCurrentSpeed {  \n\t\t\t\tout currentSpeed = currentSpeedPort.currentSpeed;  \n\t\t\t}  \n\t\t}  \n\t\tpart engine {  \n\t\t\tport throttlePort: ~ThrottlePort;  \n\t\t\tperform cruiseControlRegion.adjustEngineOutput {  \n\t\t\t\tin throttleCmd = throttlePort.throttleCmd;  \n\t\t\t}  \n\t\t}  \n\t}  \n\taction cruiseControlRegion {  \n\t\taction sendSetSpeedCmd { out setSpeedCmd: SetSpeedCmd; }  \n\t\tsuccession flow setSpeedFlow from sendSetSpeedCmd.setSpeedCmd to compareSpeeds.setSpeedCmd;  \n\t\taction compareSpeeds { in setSpeedCmd; in currentSpeed; out speedDifference: CurrentSpeed; }  \n\t\tsuccession flow currentSpeedFlow from provideCurrentSpeed.currentSpeed to compareSpeeds.currentSpeed;  \n\t\taction provideCurrentSpeed { out currentSpeed: CurrentSpeed; }  \n\t\taction calculateDifference { in setSpeedCmd; in currentSpeed; out speedDifference: CurrentSpeed; }  \n\t\tsuccession flow differenceFlow from compareSpeeds.speedDifference to generateThrottleCmd.speedDifference;  \n\t\taction generateThrottleCmd { in speedDifference; out throttleCmd: ThrottleCmd; }  \n\t\tsuccession flow throttleCmdFlow from generateThrottleCmd.throttleCmd to adjustEngineOutput.throttleCmd;  \n\t\taction adjustEngineOutput { in throttleCmd: ThrottleCmd; }  \n\t}  \n}",
    "package 'AutomotiveCruiseControl' {\n\tattribute def speedCommand;\n\tattribute def currentSpeed;\n\tattribute def throttleCmd;\n\tport def SpeedCmdPort {\n\t\tout speedCmd : speedCommand;\n\t}\n\tport def CurrentSpeedPort {\n\t\tout currentSpeed : currentSpeed;\n\t}\n\tport def ThrottleCmdPort {\n\t\tout throttleCmd : throttleCmd;\n\t}\n\tpart context {\n\t\tpart driver {\n\t\t\tport speedCmdPort: SpeedCmdPort;\n\t\t\tperform maintainCruiseSpeed.sendSpeedCmd {\n\t\t\t\tout speedCmd = speedCmdPort.speedCmd;\n\t\t\t}\n\t\t}\n\t\tinterface driverToController connect driver.speedCmdPort to cruiseController.speedCmdPort {\n\t\t\tref flow references maintainCruiseSpeed.speedCmdFlow\n\t\t\t\tfrom source.speedCmd to target.speedCmd;\n\t\t}\n\t\tpart cruiseController {\n\t\t\tport speedCmdPort: ~SpeedCmdPort;\n\t\t\tport currentSpeedPort: ~CurrentSpeedPort;\n\t\t\tperform maintainCruiseSpeed.adjustThrottle {\n\t\t\t\tin speedCmd = speedCmdPort.speedCmd;\n\t\t\t\tin currentSpeed = currentSpeedPort.currentSpeed;\n\t\t\t\tout throttleCmd = throttleCmdPort.throttleCmd;\n\t\t\t}\n\t\t\tport throttleCmdPort: ThrottleCmdPort;\n\t\t}\n\t\tinterface controllerToSpeedometer connect cruiseController.currentSpeedPort to speedometer.currentSpeedPort {\n\t\t\tref flow references maintainCruiseSpeed.speedFeedbackFlow\n\t\t\t\tfrom source.currentSpeed to target.currentSpeed;\n\t\t}\n\t\tinterface controllerToEngine connect cruiseController.throttleCmdPort to engine.throttleCmdPort {\n\t\t\tref flow references maintainCruiseSpeed.throttleFlow\n\t\t\t\tfrom source.throttleCmd to target.throttleCmd;\n\t\t}\n\t\tpart speedometer {\n\t\t\tport currentSpeedPort: ~CurrentSpeedPort;\n\t\t\tperform maintainCruiseSpeed.senseSpeed {\n\t\t\t\tout currentSpeed = currentSpeedPort.currentSpeed;\n\t\t\t}\n\t\t}\n\t\tpart engine {\n\t\t\tport throttleCmdPort: ~ThrottleCmdPort;\n\t\t\tperform maintainCruiseSpeed.applyThrottle {\n\t\t\t\tin throttleCmd = throttleCmdPort.throttleCmd;\n\t\t\t}\n\t\t}\n\t}\n\taction maintainCruiseSpeed {\n\t\taction sendSpeedCmd { out speedCmd: speedCommand; }\n\t\tsuccession flow speedCmdFlow from sendSpeedCmd.speedCmd to adjustThrottle.speedCmd;\n\t\taction senseSpeed { out currentSpeed: currentSpeed; }\n\t\tsuccession flow speedFeedbackFlow from senseSpeed.currentSpeed to adjustThrottle.currentSpeed;\n\t\taction adjustThrottle { in speedCmd; in currentSpeed; out throttleCmd: throttleCmd; }\n\t\tsuccession flow throttleFlow from adjustThrottle.throttleCmd to applyThrottle.throttleCmd;\n\t\taction applyThrottle { in throttleCmd; }\n\t}\n}",
    "package 'AutomotiveCruiseControl' {  \n\tattribute def SetSpeedCmd;  \n\tattribute def ActualSpeed;  \n\tattribute def FuelControlCmd;  \n\tport def SetSpeedPort { out setSpeedCmd : SetSpeedCmd; }  \n\tport def SpeedSensorPort { out actualSpeed : ActualSpeed; }  \n\tport def FuelControlPort { out fuelControlCmd : FuelControlCmd; }  \n\t  \n\tpart context {  \n\t\tpart driverInterface {  \n\t\t\tport setSpeedPort: SetSpeedPort;  \n\t\t\tperform cruiseControlRegion.sendSetSpeedCmd {  \n\t\t\t\tout setSpeedCmd = setSpeedPort.setSpeedCmd;  \n\t\t\t}  \n\t\t}  \n\t\tinterface driverToController connect driverInterface.setSpeedPort to cruiseController.setSpeedPort {  \n\t\t\tref flow references cruiseControlRegion.setSpeedFlow  \n\t\t\t\tfrom source.setSpeedCmd to target.setSpeedCmd;  \n\t\t}  \n\t\tpart cruiseController {  \n\t\t\tport setSpeedPort: ~SetSpeedPort;  \n\t\t\tport actualSpeedPort: ~SpeedSensorPort;  \n\t\t\tport fuelControlPort: FuelControlPort;  \n\t\t\tperform cruiseControlRegion.compareSpeeds {  \n\t\t\t\tin setSpeedCmd = setSpeedPort.setSpeedCmd;  \n\t\t\t\tin actualSpeed = actualSpeedPort.actualSpeed;  \n\t\t\t\tout fuelControlCmd = fuelControlPort.fuelControlCmd;  \n\t\t\t}  \n\t\t}  \n\t\tinterface sensorToController connect speedSensor.actualSpeedPort to cruiseController.actualSpeedPort {  \n\t\t\tref flow references cruiseControlRegion.speedSensorFlow  \n\t\t\t\tfrom source.actualSpeed to target.actualSpeed;  \n\t\t}  \n\t\tpart speedSensor {  \n\t\t\tport actualSpeedPort: SpeedSensorPort;  \n\t\t\tperform cruiseControlRegion.detectActualSpeed {  \n\t\t\t\tout actualSpeed = actualSpeedPort.actualSpeed;  \n\t\t\t}  \n\t\t}  \n\t\tpart engine {  \n\t\t\tport fuelControlPort: ~FuelControlPort;  \n\t\t\tperform cruiseControlRegion.adjustEngineOutput {  \n\t\t\t\tin fuelControlCmd = fuelControlPort.fuelControlCmd;  \n\t\t\t}  \n\t\t}  \n\t}  \n\taction cruiseControlRegion {  \n\t\taction sendSetSpeedCmd { out setSpeedCmd: SetSpeedCmd; }  \n\t\taction detectActualSpeed { out actualSpeed: ActualSpeed; }  \n\t\taction compareSpeeds {  \n\t\t\tin setSpeedCmd: SetSpeedCmd;  \n\t\t\tin actualSpeed: ActualSpeed;  \n\t\t\tout fuelControlCmd: FuelControlCmd;  \n\t\t}  \n\t\taction adjustEngineOutput { in fuelControlCmd: FuelControlCmd; }  \n\t\t  \n\t\tsuccession flow setSpeedFlow from sendSetSpeedCmd.setSpeedCmd to compareSpeeds.setSpeedCmd;  \n\t\tsuccession flow speedSensorFlow from detectActualSpeed.actualSpeed to compareSpeeds.actualSpeed;  \n\t\tsuccession flow fuelControlFlow from compareSpeeds.fuelControlCmd to adjustEngineOutput.fuelControlCmd;  \n\t}  \n}",
    "package 'CruiseControlSystem' {\n\tattribute def SetSpeedCmd;\n\tattribute def ActualSpeed;\n\tattribute def FuelControlCmd;\n\tport def SetSpeedPort {\n\t\tin setSpeed: SetSpeedCmd;\n\t}\n\tport def ActualSpeedPort {\n\t\tout actualSpeed: ActualSpeed;\n\t}\n\tport def FuelControlPort {\n\t\tin fuelControlCmd: FuelControlCmd;\n\t}\n\tport def EngineFuelPort {\n\t\tout fuelCommand: FuelControlCmd;\n\t}\n\tpart context {\n\t\tpart driver {\n\t\t\tport setSpeedPort: SetSpeedPort;\n\t\t\tperform sendSetSpeedCmd {\n\t\t\t\tout setSpeed = setSpeedPort.setSpeed;\n\t\t\t}\n\t\t}\n\t\tinterface driverToController connect driver.setSpeedPort to cruiseController.setSpeedPort {\n\t\t\tref flow references sendSetSpeedCmd.setSpeedFlow\n\t\t\t\tfrom source.setSpeed to target.setSpeed;\n\t\t}\n\t\tpart cruiseController {\n\t\t\tport setSpeedPort: ~SetSpeedPort;\n\t\t\tport actualSpeedPort: ActualSpeedPort;\n\t\t\tport fuelControlPort: FuelControlPort;\n\t\t\tperform processSpeedCommands {\n\t\t\t\tin setSpeed = setSpeedPort.setSpeed;\n\t\t\t\tout fuelControlCmd = fuelControlPort.fuelControlCmd;\n\t\t\t}\n\t\t\tperform readActualSpeed {\n\t\t\t\tout actualSpeed = actualSpeedPort.actualSpeed;\n\t\t\t}\n\t\t}\n\t\tinterface controllerToSensor connect cruiseController.actualSpeedPort to speedSensor.actualSpeedPort {\n\t\t\tref flow references readActualSpeed.speedFlow\n\t\t\t\tfrom source.actualSpeed to target.actualSpeed;\n\t\t}\n\t\tpart speedSensor {\n\t\t\tport actualSpeedPort: ~ActualSpeedPort;\n\t\t\tperform reportSpeed {\n\t\t\t\tin actualSpeed = actualSpeedPort.actualSpeed;\n\t\t\t}\n\t\t}\n\t\tinterface controllerToEngineController connect cruiseController.fuelControlPort to engineController.fuelControlPort {\n\t\t\tref flow references processSpeedCommands.fuelFlow\n\t\t\t\tfrom source.fuelControlCmd to target.fuelControlCmd;\n\t\t}\n\t\tpart engineController {\n\t\t\tport fuelControlPort: ~FuelControlPort;\n\t\t\tport engineFuelPort: EngineFuelPort;\n\t\t\tperform transmitFuelControlCmd {\n\t\t\t\tin fuelControlCmd = fuelControlPort.fuelControlCmd;\n\t\t\t\tout fuelCommand = engineFuelPort.fuelCommand;\n\t\t\t}\n\t\t}\n\t\tinterface engineControllerToEngine connect engineController.engineFuelPort to engine.fuelPort {\n\t\t\tref flow references transmitFuelControlCmd.fuelFlow\n\t\t\t\tfrom source.fuelCommand to target.fuelCommand;\n\t\t}\n\t\tpart engine {\n\t\t\tport fuelPort: ~EngineFuelPort;\n\t\t\tperform adjustFuelFlow {\n\t\t\t\tin fuelCommand = fuelPort.fuelCommand;\n\t\t\t}\n\t\t}\n\t}\n\taction speedControlSequence {\n\t\taction sendSetSpeedCmd { out setSpeed: SetSpeedCmd; }\n\t\tsuccession flow setSpeedFlow from sendSetSpeedCmd.setSpeed to processSpeedCommands.setSpeed;\n\t\taction processSpeedCommands { in setSpeed; out fuelControlCmd: FuelControlCmd; }\n\t\taction readActualSpeed { out actualSpeed: ActualSpeed; }\n\t\tsuccession flow speedFlow from readActualSpeed.actualSpeed to processSpeedCommands.actualSpeed;\n\t\taction transmitFuelControlCmd { in fuelControlCmd; out fuelCommand: FuelControlCmd; }\n\t\tsuccession flow fuelFlow from processSpeedCommands.fuelControlCmd to transmitFuelControlCmd.fuelControlCmd;\n\t\taction adjustFuelFlow { in fuelCommand: FuelControlCmd; }\n\t}\n}",
    "package 'VehicleLifecycle' {\n\tattribute def DeliveryDate;\n\tattribute def OwnerInfo;\n\tattribute def Driver;\n\tattribute def ScrapInfo;\n\tport def DeliveryPort {\n\t\tout deliveryDate : DeliveryDate;\n\t}\n\tport def OwnershipPort {\n\t\tout ownerInfo : OwnerInfo;\n\t}\n\tport def DriverPort {\n\t\tout driver : Driver;\n\t}\n\tport def EndOfUsePort {\n\t\tout scrapInfo : ScrapInfo;\n\t}\n\tpart context {\n\t\tpart vehicle {\n\t\t\tport deliveryPort: DeliveryPort;\n\t\t\tperform manageLifecycle.recordDelivery {\n\t\t\t\tout deliveryDate = deliveryPort.deliveryDate;\n\t\t\t}\n\t\t}\n\t\tinterface vehicleToDelivery connect vehicle.deliveryPort to delivery.deliveryPort {\n\t\t\tref flow references manageLifecycle.deliveryFlow\n\t\t\t\tfrom source.deliveryDate to target.deliveryDate;\n\t\t}\n\t\tpart delivery {\n\t\t\tport deliveryPort: ~DeliveryPort;\n\t\t\tperform manageLifecycle.recordDelivery {\n\t\t\t\tin deliveryDate = deliveryPort.deliveryDate;\n\t\t\t\tout deliveryDate = deliveryPort.deliveryDate;\n\t\t\t}\n\t\t\tport ownershipPort: ~OwnershipPort;\n\t\t\tperform manageLifecycle.recordOwnershipChange {\n\t\t\t\tin deliveryDate = deliveryPort.deliveryDate;\n\t\t\t\tout ownerInfo = ownershipPort.ownerInfo;\n\t\t\t}\n\t\t}\n\t\tinterface deliveryToOwnership connect delivery.ownershipPort to ownership.ownershipPort {\n\t\t\tref flow references manageLifecycle.ownershipFlow\n\t\t\t\tfrom source.ownerInfo to target.ownerInfo;\n\t\t}\n\t\tpart ownership {\n\t\t\tport ownershipPort: ~OwnershipPort;\n\t\t\tperform manageLifecycle.recordOwnershipChange {\n\t\t\t\tin ownerInfo = deliveryToOwnership.ownerInfo;\n\t\t\t\tout ownerInfo = ownershipPort.ownerInfo;\n\t\t\t}\n\t\t\tport driverPort: DriverPort;\n\t\t\tperform manageLifecycle.trackDriver {\n\t\t\t\tin ownerInfo = ownershipPort.ownerInfo;\n\t\t\t\tout driver = driverPort.driver;\n\t\t\t}\n\t\t}\n\t\tinterface ownershipToDriving connect ownership.driverPort to driving.driverPort {\n\t\t\tref flow references manageLifecycle.driverFlow\n\t\t\t\tfrom source.driver to target.driver;\n\t\t}\n\t\tpart driving {\n\t\t\tport driverPort: ~DriverPort;\n\t\t\tperform manageLifecycle.trackDriver {\n\t\t\t\tin driver = driverPort.driver;\n\t\t\t\tout driver = driverPort.driver;\n\t\t\t}\n\t\t}\n\t\tinterface ownershipToNextOwnership connect ownership.ownershipPort to nextOwnership.ownershipPort {\n\t\t\tref flow references manageLifecycle.ownershipFlow\n\t\t\t\tfrom source.ownerInfo to target.ownerInfo;\n\t\t}\n\t\tpart endOfUse {\n\t\t\tport ownershipPort: ~OwnershipPort;\n\t\t\tperform manageLifecycle.recordScrap {\n\t\t\t\tin ownerInfo = ownershipToNextOwnership.ownerInfo;\n\t\t\t\tout scrapInfo = endOfUsePort.scrapInfo;\n\t\t\t}\n\t\t\tport endOfUsePort: EndOfUsePort;\n\t\t}\n\t}\n\taction manageLifecycle {\n\t\taction recordDelivery { out deliveryDate: DeliveryDate; }\n\t\tsuccession flow deliveryFlow from recordDelivery.deliveryDate to recordOwnershipChange.deliveryDate;\n\t\taction recordOwnershipChange { in deliveryDate; out ownerInfo: OwnerInfo; }\n\t\tsuccession flow ownershipFlow from recordOwnershipChange.ownerInfo to trackDriver.ownerInfo;\n\t\taction trackDriver { in ownerInfo; out driver: Driver; }\n\t\tsuccession flow driverFlow from trackDriver.driver to recordOwnershipChange.driver;\n\t\taction recordScrap { in ownerInfo; out scrapInfo: ScrapInfo; }\n\t\tsuccession flow scrapFlow from recordScrap.scrapInfo to endOfUse.scrapInfo;\n\t}\n}",
    "package 'Vehicle' {\n\tattribute def mass;\n\tattribute def operationalStatus {\n\t\tattribute def gearSetting;\n\t\tattribute def acceleratorPedalPosition;\n\t}\n\tpart def Engine;\n\tpart def Driver;\n\tpart def Wheel;\n\tpart context {\n\t\tpart vehicle_1 {\n\t\t\tpart engine: Engine;\n\t\t\tpart driver: Driver as reference;\n\t\t\tpart leftFrontWheel_1: Wheel;\n\t\t\tpart leftFrontWheel_2: Wheel;\n\t\t\tpart rightFrontWheel_1: Wheel;\n\t\t\tpart rightFrontWheel_2: Wheel;\n\t\t}\n\t}\n}",
    "package 'VehicleSystem' {\n\tattribute def Mass;\n\tattribute def Gear;\n\tattribute def Accelerator;\n\tport def CommandPort {\n\t\tout gearCmd : Gear;\n\t\tout acceleratorCmd : Accelerator;\n\t}\n\tport def VehicleAttributePort {\n\t\tout mass : Mass;\n\t\tout gear : Gear;\n\t\tout accelerator : Accelerator;\n\t}\n\tport def EnginePort {\n\t\tin mass : Mass;\n\t\tin gear : Gear;\n\t\tin accelerator : Accelerator;\n\t}\n\tpart context {\n\t\tpart driver {\n\t\t\tport commandPort : CommandPort;\n\t\t\tperform initializeVehicle.sendCommands {\n\t\t\t\tout gearCmd = commandPort.gearCmd;\n\t\t\t\tout acceleratorCmd = commandPort.acceleratorCmd;\n\t\t\t}\n\t\t}\n\t\tinterface driverToVehicle connect driver.commandPort to vehicle.commandPort {\n\t\t\tref flow references initializeVehicle.commandFlow\n\t\t\t\tfrom source.gearCmd to target.gearCmd;\n\t\t\t\tfrom source.acceleratorCmd to target.acceleratorCmd;\n\t\t}\n\t\tpart vehicle 'Vehicle_1' {\n\t\t\tport commandPort : ~CommandPort;\n\t\t\tperform initializeVehicle.setInitialAttributes {\n\t\t\t\tin gearCmd = commandPort.gearCmd;\n\t\t\t\tin acceleratorCmd = commandPort.acceleratorCmd;\n\t\t\t\tout mass = 2000;\n\t\t\t\tout gear = 0;\n\t\t\t\tout accelerator = 0.0;\n\t\t\t}\n\t\t\tperform updateVehicleState.setUpdatedAttributes {\n\t\t\t\tout mass = 1500;\n\t\t\t\tout gear = 2;\n\t\t\t\tout accelerator = 0.5;\n\t\t\t}\n\t\t\tport attributePort : VehicleAttributePort;\n\t\t}\n\t\tinterface vehicleToEngine connect vehicle.attributePort to engine.enginePort {\n\t\t\tref flow references initializeVehicle.attributeFlow\n\t\t\t\tfrom source.mass to target.mass;\n\t\t\t\tfrom source.gear to target.gear;\n\t\t\t\tfrom source.accelerator to target.accelerator;\n\t\t\tref flow references updateVehicleState.attributeFlow\n\t\t\t\tfrom source.mass to target.mass;\n\t\t\t\tfrom source.gear to target.gear;\n\t\t\t\tfrom source.accelerator to target.accelerator;\n\t\t}\n\t\tpart engine {\n\t\t\tport enginePort : ~EnginePort;\n\t\t}\n\t}\n\taction initializeVehicle {\n\t\taction sendCommands { out gearCmd : Gear; out acceleratorCmd : Accelerator; }\n\t\tsuccession flow commandFlow from sendCommands.gearCmd to setInitialAttributes.gearCmd;\n\t\tsuccession flow commandFlow from sendCommands.acceleratorCmd to setInitialAttributes.acceleratorCmd;\n\t\taction setInitialAttributes { in gearCmd : Gear; in acceleratorCmd : Accelerator; out mass : Mass; out gear : Gear; out accelerator : Accelerator; }\n\t}\n\taction updateVehicleState {\n\t\taction sendCommands { out gearCmd : Gear; out acceleratorCmd : Accelerator; }\n\t\tsuccession flow commandFlow from sendCommands.gearCmd to setUpdatedAttributes.gearCmd;\n\t\tsuccession flow commandFlow from sendCommands.acceleratorCmd to setUpdatedAttributes.acceleratorCmd;\n\t\taction setUpdatedAttributes { in gearCmd : Gear; in acceleratorCmd : Accelerator; out mass : Mass; out gear : Gear; out accelerator : Accelerator; }\n\t}\n}",
    "package 'VehicleSystem' {\n\tattribute def mass;\n\tattribute def gearPosition;\n\tattribute def throttlePosition;\n\tattribute def driver;\n\tpart context {\n\t\tpart vehicle {\n\t\t\tattribute mass;\n\t\t\tattribute gearPosition;\n\t\t\tattribute throttlePosition;\n\t\t\tattribute driver;\n\t\t\tpart engine;\n\t\t\tperform vehicleOperation.initialState;\n\t\t}\n\t\tpart Alice;\n\t\tpart Bob;\n\t}\n\taction vehicleOperation {\n\t\taction initialState {\n\t\t\tout mass = 2000;\n\t\t\tout gearPosition = \"neutral\";\n\t\t\tout throttlePosition = 0;\n\t\t\tout driver = Alice;\n\t\t}\n\t\tsuccession to subsequentState;\n\t\taction subsequentState {\n\t\t\tout mass = 1500;\n\t\t\tout gearPosition = \"second\";\n\t\t\tout throttlePosition = 0.5;\n\t\t\tout driver = Bob;\n\t\t}\n\t}\n}",
    "package 'VehicleMassSystem' {\n\tattribute def Mass;\n\tport def MassPort {\n\t\tout mass : Mass;\n\t}\n\tpart context {\n\t\tpart vehicle {\n\t\t\tport massPort : MassPort;\n\t\t\tperform massCalculation.aggregateTotalMass {\n\t\t\t\tin bodyMass, engineMass, transmissionMass : Mass;\n\t\t\t\tout totalMass = massPort.mass;\n\t\t\t}\n\t\t\tpart body {\n\t\t\t\tport massPort : ~MassPort;\n\t\t\t\tperform massCalculation.calculateMass {\n\t\t\t\t\tout mass = massPort.mass;\n\t\t\t\t}\n\t\t\t}\n\t\t\tpart engine {\n\t\t\t\tport massPort : ~MassPort;\n\t\t\t\tperform massCalculation.calculateMass {\n\t\t\t\t\tout mass = massPort.mass;\n\t\t\t\t}\n\t\t\t}\n\t\t\tpart transmission {\n\t\t\t\tport massPort : ~MassPort;\n\t\t\t\tperform massCalculation.calculateMass {\n\t\t\t\t\tout mass = massPort.mass;\n\t\t\t\t}\n\t\t\t}\n\t\t\tinterface bodyToVehicle connect body.massPort to vehicle.massPort {\n\t\t\t\tref flow references massCalculation.massFlow from source.mass to target.bodyMass;\n\t\t\t}\n\t\t\tinterface engineToVehicle connect engine.massPort to vehicle.massPort {\n\t\t\t\tref flow references massCalculation.massFlow from source.mass to target.engineMass;\n\t\t\t}\n\t\t\tinterface transmissionToVehicle connect transmission.massPort to vehicle.massPort {\n\t\t\t\tref flow references massCalculation.massFlow from source.mass to target.transmissionMass;\n\t\t\t}\n\t\t}\n\t}\n\taction massCalculation {\n\t\taction calculateMass { out mass : Mass; }\n\t\taction aggregateTotalMass { \n\t\t\tin bodyMass, engineMass, transmissionMass : Mass; \n\t\t\tout totalMass : Mass; \n\t\t}\n\t\tsuccession flow massFlow from calculateMass.mass to aggregateTotalMass.bodyMass, aggregateTotalMass.engineMass, aggregateTotalMass.transmissionMass;\n\t}\n}",
    "package 'VehicleMassManagement' {\n\tattribute def Mass;\n\tattribute def SerialNumber;\n\tattribute def VIN;\n\tattribute def Threshold;\n\tport def ComponentMassPort {\n\t\tout mass : Mass;\n\t\tout serialNumber : SerialNumber;\n\t}\n\tport def VehicleMassPort {\n\t\tout mass : Mass;\n\t\tout vin : VIN;\n\t}\n\tport def ThresholdPort {\n\t\tin threshold : Threshold;\n\t}\n\tpart context {\n\t\tpart vehicle {\n\t\t\tport vinPort: ~VIN;\n\t\t\tport massPort: VehicleMassPort;\n\t\t\tperform calculateTotalMassAction {\n\t\t\t\tin threshold = thresholdPort.threshold;\n\t\t\t\tout mass = massPort.mass;\n\t\t\t}\n\t\t\tattribute vin = vinPort.vin;\n\t\t}\n\t\tinterface vehicleToComponents connect vehicle.massPort to component.massPort {\n\t\t\tref flow references calculateTotalMassAction.massFlow\n\t\t\t\tfrom source.mass to target.mass;\n\t\t}\n\t\tpart component {\n\t\t\tport massPort: ~ComponentMassPort;\n\t\t\tport subcomponentsPort: ~ComponentMassPort;\n\t\t\tperform calculateSubcomponentMass {\n\t\t\t\tin threshold = thresholdPort.threshold;\n\t\t\t\tout mass = massPort.mass;\n\t\t\t}\n\t\t\tattribute serialNumber = massPort.serialNumber;\n\t\t}\n\t\tpart massManager {\n\t\t\tport thresholdPort: ~ThresholdPort;\n\t\t\tport componentMassPort: ~ComponentMassPort;\n\t\t\tperform filterSubcomponents {\n\t\t\t\tin threshold = thresholdPort.threshold;\n\t\t\t\tin componentMass = componentMassPort.mass;\n\t\t\t\tout filteredMass: Mass;\n\t\t\t}\n\t\t}\n\t}\n\taction calculateTotalMassAction {\n\t\taction addBaseMass { in baseMass: Mass; }\n\t\taction filterSubcomponents { in threshold: Threshold; in componentMass: Mass; out filteredMass: Mass; }\n\t\taction sumComponentMasses { in componentMasses: Mass[]; out totalMass: Mass; }\n\t\tsuccession flow baseMassFlow from addBaseMass.baseMass to sumComponentMasses.componentMasses;\n\t\tsuccession flow filteredMassFlow from filterSubcomponents.filteredMass to sumComponentMasses.componentMasses;\n\t\tsuccession flow totalMassFlow from sumComponentMasses.totalMass to calculateTotalMassAction.mass;\n\t}\n}",
    "package 'MassAggregationSystem' {\n\tattribute def simpleMass;\n\tattribute def totalMass;\n\tport def MassPort {\n\t\tout mass : totalMass;\n\t}\n\tpart context {\n\t\tpart simpleThing {\n\t\t\tport massPort: MassPort;\n\t\t\tperform calculateTotalMass {\n\t\t\t\tout mass = massPort.mass;\n\t\t\t}\n\t\t}\n\t\tpart compositeThing {\n\t\t\tport massPort: MassPort;\n\t\t\tport subcomponentsPort: * MassPort;\n\t\t\tperform calculateTotalMass {\n\t\t\t\tin simpleMass = this.simpleMass;\n\t\t\t\tin subcomponentMass = subcomponentsPort.mass;\n\t\t\t\tout mass = simpleMass + subcomponentMass;\n\t\t\t}\n\t\t}\n\t\tinterface compositeToSubcomponents connect compositeThing.subcomponentsPort to subcomponent.massPort {\n\t\t\tref flow references calculateTotalMass.subcomponentMassFlow\n\t\t\t\tfrom source.mass to target.mass;\n\t\t}\n\t}\n\taction calculateTotalMass {\n\t\taction calculateSimpleMass {\n\t\t\tout mass: totalMass;\n\t\t}\n\t\tsuccession flow simpleMassFlow from calculateSimpleMass.mass to calculateTotalMass.mass;\n\t\taction calculateCompositeMass {\n\t\t\tin simpleMass: simpleMass;\n\t\t\tin subcomponentMass: totalMass[*];\n\t\t\tout mass: totalMass;\n\t\t}\n\t}\n}",
    "package 'MassAggregationSystem' {  \n\tattribute def basicMass;  \n\tattribute def totalMass;  \n\tattribute def minMassThreshold;  \n\tport def MassPort {  \n\t\tin minMassThreshold : minMassThreshold;  \n\t\tout totalMass : totalMass;  \n\t}  \n\tport def SubcomponentPort {  \n\t\tin minMassThreshold : minMassThreshold;  \n\t\tout totalMass : totalMass;  \n\t}  \n\tpart context {  \n\t\tpart massAggregationSystem {  \n\t\t\tport massPort: MassPort;  \n\t\t\tperform calculateTotalMass.calculateTotalMass {  \n\t\t\t\tin minMassThreshold = massPort.minMassThreshold;  \n\t\t\t\tout totalMass = massPort.totalMass;  \n\t\t\t}  \n\t\t}  \n\t\tinterface systemToSubcomponents connect massAggregationSystem.massPort to subcomponent1.massPort, subcomponent2.massPort {  \n\t\t\tref flow references calculateTotalMass.minMassThresholdFlow  \n\t\t\t\tfrom source.minMassThreshold to target.minMassThreshold;  \n\t\t\tref flow references calculateTotalMass.totalMassFlow  \n\t\t\t\tfrom source.totalMass to target.totalMass;  \n\t\t}  \n\t\tpart subcomponent1 {  \n\t\t\tport massPort: ~MassPort;  \n\t\t\tperform calculateTotalMass.calculateSubcomponentMass {  \n\t\t\t\tin minMassThreshold = massPort.minMassThreshold;  \n\t\t\t\tout totalMass = massPort.totalMass;  \n\t\t\t}  \n\t\t}  \n\t\tpart subcomponent2 {  \n\t\t\tport massPort: ~MassPort;  \n\t\t\tperform calculateTotalMass.calculateSubcomponentMass {  \n\t\t\t\tin minMassThreshold = massPort.minMassThreshold;  \n\t\t\t\tout totalMass = massPort.totalMass;  \n\t\t\t}  \n\t\t}  \n\t}  \n\taction calculateTotalMass {  \n\t\taction calculateTotalMass {  \n\t\t\tin minMassThreshold: minMassThreshold;  \n\t\t\tout totalMass: totalMass;  \n\t\t}  \n\t\tsuccession flow minMassThresholdFlow from calculateTotalMass.minMassThreshold to calculateSubcomponentMass.minMassThreshold;  \n\t\taction calculateSubcomponentMass {  \n\t\t\tin minMassThreshold: minMassThreshold;  \n\t\t\tout totalMass: totalMass;  \n\t\t}  \n\t\tsuccession flow totalMassFlow from calculateSubcomponentMass.totalMass to calculateTotalMass.subcomponentMasses;  \n\t\taction aggregateMass {  \n\t\t\tin basicMass: basicMass;  \n\t\t\tin subcomponentMasses: totalMass[];  \n\t\t\tout totalMass: totalMass;  \n\t\t}  \n\t\tsuccession flow aggregationFlow from calculateTotalMass.basicMass to aggregateMass.basicMass;  \n\t\tsuccession flow aggregationFlow from calculateSubcomponentMass.totalMass to aggregateMass.subcomponentMasses;  \n\t\taction filterSubcomponents {  \n\t\t\tin minMassThreshold: minMassThreshold;  \n\t\t\tin subcomponentMasses: totalMass[];  \n\t\t\tout filteredMasses: totalMass[];  \n\t\t}  \n\t\tsuccession flow filterFlow from calculateTotalMass.subcomponentMasses to filterSubcomponents.subcomponentMasses;  \n\t\tsuccession flow filterFlow from filterSubcomponents.filteredMasses to aggregateMass.subcomponentMasses;  \n\t}  \n}",
    "package 'VehicleDynamicsSystem' {\n\tattribute def WheelPower;\n\tattribute def DragCoeff;\n\tattribute def FrictionCoeff;\n\tattribute def Mass;\n\tattribute def InitialSpeed;\n\tattribute def Time;\n\tattribute def EffectivePower;\n\tattribute def Acceleration;\n\tattribute def CurrentSpeed;\n\tattribute def Displacement;\n\n\tport def WheelPowerPort { out wheelPower: WheelPower; }\n\tport def DragCoeffPort { out dragCoeff: DragCoeff; }\n\tport def FrictionCoeffPort { out frictionCoeff: FrictionCoeff; }\n\tport def MassPort { out mass: Mass; }\n\tport def InitialSpeedPort { out initialSpeed: InitialSpeed; }\n\tport def TimePort { out time: Time; }\n\tport def EffectivePowerPort { out effectivePower: EffectivePower; }\n\tport def AccelerationPort { out acceleration: Acceleration; }\n\tport def CurrentSpeedPort { out currentSpeed: CurrentSpeed; }\n\tport def DisplacementPort { out displacement: Displacement; }\n\n\tpart context {\n\t\tpart user {\n\t\t\tport wheelPowerPort: WheelPowerPort;\n\t\t\tport dragCoeffPort: DragCoeffPort;\n\t\t\tport frictionCoeffPort: FrictionCoeffPort;\n\t\t\tport massPort: MassPort;\n\t\t\tport initialSpeedPort: InitialSpeedPort;\n\t\t\tport timePort: TimePort;\n\t\t\tperform vehicleDynamicsSystem.sendInputs {\n\t\t\t\tout wheelPower = wheelPowerPort.wheelPower;\n\t\t\t\tout dragCoeff = dragCoeffPort.dragCoeff;\n\t\t\t\tout frictionCoeff = frictionCoeffPort.frictionCoeff;\n\t\t\t\tout mass = massPort.mass;\n\t\t\t\tout initialSpeed = initialSpeedPort.initialSpeed;\n\t\t\t\tout time = timePort.time;\n\t\t\t}\n\t\t}\n\n\t\tinterface userToSystem connect user.wheelPowerPort to vehicleDynamicsSystem.wheelPowerPort {\n\t\t\tref flow references vehicleDynamics.wheelPowerFlow from source.wheelPower to target.wheelPower;\n\t\t}\n\t\tinterface userToSystem connect user.dragCoeffPort to vehicleDynamicsSystem.dragCoeffPort {\n\t\t\tref flow references vehicleDynamics.dragCoeffFlow from source.dragCoeff to target.dragCoeff;\n\t\t}\n\t\tinterface userToSystem connect user.frictionCoeffPort to vehicleDynamicsSystem.frictionCoeffPort {\n\t\t\tref flow references vehicleDynamics.frictionCoeffFlow from source.frictionCoeff to target.frictionCoeff;\n\t\t}\n\t\tinterface userToSystem connect user.massPort to vehicleDynamicsSystem.massPort {\n\t\t\tref flow references vehicleDynamics.massFlow from source.mass to target.mass;\n\t\t}\n\t\tinterface userToSystem connect user.initialSpeedPort to vehicleDynamicsSystem.initialSpeedPort {\n\t\t\tref flow references vehicleDynamics.initialSpeedFlow from source.initialSpeed to target.initialSpeed;\n\t\t}\n\t\tinterface userToSystem connect user.timePort to vehicleDynamicsSystem.timePort {\n\t\t\tref flow references vehicleDynamics.timeFlow from source.time to target.time;\n\t\t}\n\n\t\tpart vehicleDynamicsSystem {\n\t\t\tport wheelPowerPort: ~WheelPowerPort;\n\t\t\tport dragCoeffPort: ~DragCoeffPort;\n\t\t\tport frictionCoeffPort: ~FrictionCoeffPort;\n\t\t\tport massPort: ~MassPort;\n\t\t\tport initialSpeedPort: ~InitialSpeedPort;\n\t\t\tport timePort: ~TimePort;\n\t\t\tperform vehicleDynamicsSystem.calculateEffectivePower {\n\t\t\t\tin wheelPower = wheelPowerPort.wheelPower;\n\t\t\t\tin dragCoeff = dragCoeffPort.dragCoeff;\n\t\t\t\tin frictionCoeff = frictionCoeffPort.frictionCoeff;\n\t\t\t\tin mass = massPort.mass;\n\t\t\t\tin initialSpeed = initialSpeedPort.initialSpeed;\n\t\t\t\tout effectivePower = effectivePowerPort.effectivePower;\n\t\t\t}\n\t\t\tport effectivePowerPort: EffectivePowerPort;\n\t\t\tperform vehicleDynamicsSystem.calculateAcceleration {\n\t\t\t\tin effectivePower = effectivePowerPort.effectivePower;\n\t\t\t\tin mass = massPort.mass;\n\t\t\t\tin initialSpeed = initialSpeedPort.initialSpeed;\n\t\t\t\tout acceleration = accelerationPort.acceleration;\n\t\t\t}\n\t\t\tport accelerationPort: AccelerationPort;\n\t\t\tperform vehicleDynamicsSystem.computeCurrentSpeed {\n\t\t\t\tin acceleration = accelerationPort.acceleration;\n\t\t\t\tin initialSpeed = initialSpeedPort.initialSpeed;\n\t\t\t\tin time = timePort.time;\n\t\t\t\tout currentSpeed = currentSpeedPort.currentSpeed;\n\t\t\t}\n\t\t\tport currentSpeedPort: CurrentSpeedPort;\n\t\t\tperform vehicleDynamicsSystem.estimateDisplacement {\n\t\t\t\tin currentSpeed = currentSpeedPort.currentSpeed;\n\t\t\t\tin time = timePort.time;\n\t\t\t\tout displacement = displacementPort.displacement;\n\t\t\t}\n\t\t\tport displacementPort: DisplacementPort;\n\t\t}\n\t}\n\taction vehicleDynamics {\n\t\taction sendInputs { \n\t\t\tout wheelPower: WheelPower; \n\t\t\tout dragCoeff: DragCoeff; \n\t\t\tout frictionCoeff: FrictionCoeff; \n\t\t\tout mass: Mass; \n\t\t\tout initialSpeed: InitialSpeed; \n\t\t\tout time: Time; \n\t\t}\n\t\tsuccession flow wheelPowerFlow from sendInputs.wheelPower to calculateEffectivePower.wheelPower;\n\t\tsuccession flow dragCoeffFlow from sendInputs.dragCoeff to calculateEffectivePower.dragCoeff;\n\t\tsuccession flow frictionCoeffFlow from sendInputs.frictionCoeff to calculateEffectivePower.frictionCoeff;\n\t\tsuccession flow massFlow from sendInputs.mass to calculateEffectivePower.mass;\n\t\tsuccession flow initialSpeedFlow from sendInputs.initialSpeed to calculateEffectivePower.initialSpeed;\n\t\tsuccession flow timeFlow from sendInputs.time to calculateEffectivePower.time;\n\n\t\taction calculateEffectivePower { \n\t\t\tin wheelPower; \n\t\t\tin dragCoeff; \n\t\t\tin frictionCoeff; \n\t\t\tin mass; \n\t\t\tin initialSpeed; \n\t\t\tout effectivePower; \n\t\t}\n\t\tsuccession flow effectivePowerToAcceleration from calculateEffectivePower.effectivePower to calculateAcceleration.effectivePower;\n\t\tsuccession flow massToAcceleration from calculateEffectivePower.mass to calculateAcceleration.mass;\n\t\tsuccession flow initialSpeedToAcceleration from calculateEffectivePower.initialSpeed to calculateAcceleration.initialSpeed;\n\n\t\taction calculateAcceleration { \n\t\t\tin effectivePower; \n\t\t\tin mass; \n\t\t\tin initialSpeed; \n\t\t\tout acceleration; \n\t\t}\n\t\tsuccession flow accelerationToCurrentSpeed from calculateAcceleration.acceleration to computeCurrentSpeed.acceleration;\n\t\tsuccession flow initialSpeedToCurrentSpeed from calculateAcceleration.initialSpeed to computeCurrentSpeed.initialSpeed;\n\t\tsuccession flow timeToCurrentSpeed from sendInputs.time to computeCurrentSpeed.time;\n\n\t\taction computeCurrentSpeed { \n\t\t\tin acceleration; \n\t\t\tin initialSpeed; \n\t\t\tin time; \n\t\t\tout currentSpeed; \n\t\t}\n\t\tsuccession flow currentSpeedToDisplacement from computeCurrentSpeed.currentSpeed to estimateDisplacement.currentSpeed;\n\t\tsuccession flow timeToDisplacement from sendInputs.time to estimateDisplacement.time;\n\n\t\taction estimateDisplacement { \n\t\t\tin currentSpeed; \n\t\t\tin time; \n\t\t\tout displacement; \n\t\t}\n\t}\n}",
    "package 'VehicleDynamicsSystem' {\n\tattribute def dragCoefficient;\n\tattribute def rollingResistanceCoefficient;\n\tattribute def initialSpeed;\n\tattribute def initialPosition;\n\tattribute def timeStep;\n\tattribute def wheelEndPower;\n\tattribute def mass;\n\tattribute def drivingPower;\n\tattribute def acceleration;\n\tattribute def newSpeed;\n\tattribute def newPosition;\n\t\n\tport def ParameterPort {\n\t\tout dragCoefficient: dragCoefficient;\n\t\tout rollingResistanceCoefficient: rollingResistanceCoefficient;\n\t\tout initialSpeed: initialSpeed;\n\t\tout initialPosition: initialPosition;\n\t\tout timeStep: timeStep;\n\t\tout wheelEndPower: wheelEndPower;\n\t\tout mass: mass;\n\t}\n\t\n\tport def DynamicsPort {\n\t\tout drivingPower: drivingPower;\n\t\tout acceleration: acceleration;\n\t\tout newSpeed: newSpeed;\n\t\tout newPosition: newPosition;\n\t}\n\t\n\tinterface def ParameterInterface {\n\t\tref flow references simulateVehicleDynamics.parameterFlow\n\t\t\tfrom source.dragCoefficient to target.dragCoefficient;\n\t\tref flow references simulateVehicleDynamics.parameterFlow\n\t\t\tfrom source.rollingResistanceCoefficient to target.rollingResistanceCoefficient;\n\t\tref flow references simulateVehicleDynamics.parameterFlow\n\t\t\tfrom source.initialSpeed to target.initialSpeed;\n\t\tref flow references simulateVehicleDynamics.parameterFlow\n\t\t\tfrom source.initialPosition to target.initialPosition;\n\t\tref flow references simulateVehicleDynamics.parameterFlow\n\t\t\tfrom source.timeStep to target.timeStep;\n\t\tref flow references simulateVehicleDynamics.parameterFlow\n\t\t\tfrom source.wheelEndPower to target.wheelEndPower;\n\t\tref flow references simulateVehicleDynamics.parameterFlow\n\t\t\tfrom source.mass to target.mass;\n\t}\n\t\n\tinterface def DynamicsInterface {\n\t\tref flow references simulateVehicleDynamics.drivingPowerFlow\n\t\t\tfrom source.drivingPower to target.drivingPower;\n\t\tref flow references simulateVehicleDynamics.accelerationFlow\n\t\t\tfrom source.acceleration to target.acceleration;\n\t\tref flow references simulateVehicleDynamics.speedUpdateFlow\n\t\t\tfrom source.newSpeed to target.newSpeed;\n\t\tref flow references simulateVehicleDynamics.positionUpdateFlow\n\t\t\tfrom source.newPosition to target.newPosition;\n\t}\n\t\n\tpart context {\n\t\tpart user {\n\t\t\tport parameterPort: ParameterPort;\n\t\t\tperform simulateVehicleDynamics.sendParameters {\n\t\t\t\tout dragCoefficient = parameterPort.dragCoefficient;\n\t\t\t\tout rollingResistanceCoefficient = parameterPort.rollingResistanceCoefficient;\n\t\t\t\tout initialSpeed = parameterPort.initialSpeed;\n\t\t\t\tout initialPosition = parameterPort.initialPosition;\n\t\t\t\tout timeStep = parameterPort.timeStep;\n\t\t\t\tout wheelEndPower = parameterPort.wheelEndPower;\n\t\t\t\tout mass = parameterPort.mass;\n\t\t\t}\n\t\t}\n\t\tinterface userToVehicle connect user.parameterPort to vehicle.parameterPort {\n\t\t\tref flow references simulateVehicleDynamics.parameterFlow\n\t\t\t\tfrom source.dragCoefficient to target.dragCoefficient;\n\t\t\tref flow references simulateVehicleDynamics.parameterFlow\n\t\t\t\tfrom source.rollingResistanceCoefficient to target.rollingResistanceCoefficient;\n\t\t\tref flow references simulateVehicleDynamics.parameterFlow\n\t\t\t\tfrom source.initialSpeed to target.initialSpeed;\n\t\t\tref flow references simulateVehicleDynamics.parameterFlow\n\t\t\t\tfrom source.initialPosition to target.initialPosition;\n\t\t\tref flow references simulateVehicleDynamics.parameterFlow\n\t\t\t\tfrom source.timeStep to target.timeStep;\n\t\t\tref flow references simulateVehicleDynamics.parameterFlow\n\t\t\t\tfrom source.wheelEndPower to target.wheelEndPower;\n\t\t\tref flow references simulateVehicleDynamics.parameterFlow\n\t\t\t\tfrom source.mass to target.mass;\n\t\t}\n\t\tpart vehicle {\n\t\t\tport parameterPort: ~ParameterPort;\n\t\t\tport dynamicsPort: DynamicsPort;\n\t\t\t\n\t\t\tperform simulateVehicleDynamics.calculateDrivingPower {\n\t\t\t\tin dragCoefficient = parameterPort.dragCoefficient;\n\t\t\t\tin rollingResistanceCoefficient = parameterPort.rollingResistanceCoefficient;\n\t\t\t\tin initialSpeed = parameterPort.initialSpeed;\n\t\t\t\tin mass = parameterPort.mass;\n\t\t\t\tin wheelEndPower = parameterPort.wheelEndPower;\n\t\t\t\tout drivingPower = dynamicsPort.drivingPower;\n\t\t\t}\n\t\t\tperform simulateVehicleDynamics.computeAcceleration {\n\t\t\t\tin drivingPower = dynamicsPort.drivingPower;\n\t\t\t\tin mass = parameterPort.mass;\n\t\t\t\tout acceleration = dynamicsPort.acceleration;\n\t\t\t}\n\t\t\tperform simulateVehicleDynamics.updateSpeed {\n\t\t\t\tin initialSpeed = parameterPort.initialSpeed;\n\t\t\t\tin acceleration = dynamicsPort.acceleration;\n\t\t\t\tin timeStep = parameterPort.timeStep;\n\t\t\t\tout newSpeed = dynamicsPort.newSpeed;\n\t\t\t}\n\t\t\tperform simulateVehicleDynamics.updatePosition {\n\t\t\t\tin initialPosition = parameterPort.initialPosition;\n\t\t\t\tin initialSpeed = parameterPort.initialSpeed;\n\t\t\t\tin newSpeed = dynamicsPort.newSpeed;\n\t\t\t\tin timeStep = parameterPort.timeStep;\n\t\t\t\tout newPosition = dynamicsPort.newPosition;\n\t\t\t}\n\t\t}\n\t}\n\t\n\taction simulateVehicleDynamics {\n\t\taction sendParameters {\n\t\t\tout dragCoefficient: dragCoefficient;\n\t\t\tout rollingResistanceCoefficient: rollingResistanceCoefficient;\n\t\t\tout initialSpeed: initialSpeed;\n\t\t\tout initialPosition: initialPosition;\n\t\t\tout timeStep: timeStep;\n\t\t\tout wheelEndPower: wheelEndPower;\n\t\t\tout mass: mass;\n\t\t}\n\t\tsuccession flow parameterFlow from sendParameters.dragCoefficient to calculateDrivingPower.dragCoefficient;\n\t\tsuccession flow parameterFlow from sendParameters.rollingResistanceCoefficient to calculateDrivingPower.rollingResistanceCoefficient;\n\t\tsuccession flow parameterFlow from sendParameters.initialSpeed to calculateDrivingPower.initialSpeed;\n\t\tsuccession flow parameterFlow from sendParameters.mass to calculateDrivingPower.mass;\n\t\tsuccession flow parameterFlow from sendParameters.wheelEndPower to calculateDrivingPower.wheelEndPower;\n\t\t\n\t\taction calculateDrivingPower {\n\t\t\tin dragCoefficient;\n\t\t\tin rollingResistanceCoefficient;\n\t\t\tin initialSpeed;\n\t\t\tin mass;\n\t\t\tin wheelEndPower;\n\t\t\tout drivingPower: drivingPower;\n\t\t}\n\t\tsuccession flow drivingPowerFlow from calculateDrivingPower.drivingPower to computeAcceleration.drivingPower;\n\t\tsuccession flow accelerationFlow from computeAcceleration.acceleration to updateSpeed.acceleration;\n\t\tsuccession flow speedUpdateFlow from updateSpeed.newSpeed to updatePosition.newSpeed;\n\t\tsuccession flow positionUpdateFlow from updatePosition.newPosition to dynamicsPort.newPosition;\n\t\t\n\t\taction computeAcceleration {\n\t\t\tin drivingPower;\n\t\t\tin mass;\n\t\t\tout acceleration: acceleration;\n\t\t}\n\t\t\n\t\taction updateSpeed {\n\t\t\tin initialSpeed;\n\t\t\tin acceleration;\n\t\t\tin timeStep;\n\t\t\tout newSpeed: newSpeed;\n\t\t}\n\t\t\n\t\taction updatePosition {\n\t\t\tin initialPosition;\n\t\t\tin initialSpeed;\n\t\t\tin newSpeed;\n\t\t\tin timeStep;\n\t\t\tout newPosition: newPosition;\n\t\t}\n\t}\n}",
    "package 'VehicleDynamics' {\n\tattribute def VehicleMass;\n\tattribute def WheelPower;\n\tattribute def DragCoefficient;\n\tattribute def RollingResistanceCoefficient;\n\tattribute def InitialSpeed;\n\tattribute def InitialPosition;\n\tattribute def Speed;\n\tattribute def Position;\n\tattribute def Acceleration;\n\tattribute def TimeStep;\n\tport def InputPort {\n\t\tin vehicleMass: VehicleMass;\n\t\tin wheelPower: WheelPower;\n\t\tin dragCoefficient: DragCoefficient;\n\t\tin rollingResistanceCoefficient: RollingResistanceCoefficient;\n\t\tin initialSpeed: InitialSpeed;\n\t\tin initialPosition: InitialPosition;\n\t\tin timeStep: TimeStep;\n\t}\n\tport def OutputPort {\n\t\tout speed: Speed;\n\t\tout position: Position;\n\t\tout acceleration: Acceleration;\n\t}\n\tpart context {\n\t\tpart user {\n\t\t\tport inputPort: InputPort;\n\t\t\tperform computeDynamics.sendInputParameters {\n\t\t\t\tout vehicleMass = inputPort.vehicleMass;\n\t\t\t\tout wheelPower = inputPort.wheelPower;\n\t\t\t\tout dragCoefficient = inputPort.dragCoefficient;\n\t\t\t\tout rollingResistanceCoefficient = inputPort.rollingResistanceCoefficient;\n\t\t\t\tout initialSpeed = inputPort.initialSpeed;\n\t\t\t\tout initialPosition = inputPort.initialPosition;\n\t\t\t\tout timeStep = inputPort.timeStep;\n\t\t\t}\n\t\t}\n\t\tinterface userToCalculator connect user.inputPort to dynamicsCalculator.inputPort {\n\t\t\tref flow references computeDynamics.inputFlow\n\t\t\t\tfrom source.vehicleMass to target.vehicleMass,\n\t\t\t\tfrom source.wheelPower to target.wheelPower,\n\t\t\t\tfrom source.dragCoefficient to target.dragCoefficient,\n\t\t\t\tfrom source.rollingResistanceCoefficient to target.rollingResistanceCoefficient,\n\t\t\t\tfrom source.initialSpeed to target.speed,\n\t\t\t\tfrom source.initialPosition to target.position,\n\t\t\t\tfrom source.timeStep to target.timeStep;\n\t\t}\n\t\tpart dynamicsCalculator {\n\t\t\tport inputPort: ~InputPort;\n\t\t\tport outputPort: OutputPort;\n\t\t\tperform computeDynamics.computeForces {\n\t\t\t\tin vehicleMass = inputPort.vehicleMass;\n\t\t\t\tin wheelPower = inputPort.wheelPower;\n\t\t\t\tin dragCoefficient = inputPort.dragCoefficient;\n\t\t\t\tin rollingResistanceCoefficient = inputPort.rollingResistanceCoefficient;\n\t\t\t\tin speed = inputPort.speed;\n\t\t\t\tin position = inputPort.position;\n\t\t\t\tin timeStep = inputPort.timeStep;\n\t\t\t\tout dragForce;\n\t\t\t\tout rollingResistanceForce;\n\t\t\t}\n\t\t\tperform computeDynamics.calculateNetForce {\n\t\t\t\tin dragForce from computeForces.dragForce;\n\t\t\t\tin rollingResistanceForce from computeForces.rollingResistanceForce;\n\t\t\t\tin wheelPower from inputPort.wheelPower;\n\t\t\t\tout netForce;\n\t\t\t}\n\t\t\tperform computeDynamics.calculateAcceleration {\n\t\t\t\tin netForce from calculateNetForce.netForce;\n\t\t\t\tin vehicleMass from inputPort.vehicleMass;\n\t\t\t\tout acceleration;\n\t\t\t}\n\t\t\tperform computeDynamics.updateSpeedPosition {\n\t\t\t\tin acceleration from calculateAcceleration.acceleration;\n\t\t\t\tin speed from computeForces.speed;\n\t\t\t\tin position from computeForces.position;\n\t\t\t\tin timeStep from computeForces.timeStep;\n\t\t\t\tout nextSpeed;\n\t\t\t\tout nextPosition;\n\t\t\t}\n\t\t\tperform computeDynamics.outputResults {\n\t\t\t\tin nextSpeed from updateSpeedPosition.nextSpeed;\n\t\t\t\tin nextPosition from updateSpeedPosition.nextPosition;\n\t\t\t\tin acceleration from calculateAcceleration.acceleration;\n\t\t\t\tout speed = outputPort.speed;\n\t\t\t\tout position = outputPort.position;\n\t\t\t\tout acceleration = outputPort.acceleration;\n\t\t\t}\n\t\t}\n\t}\n\taction computeDynamics {\n\t\taction sendInputParameters {\n\t\t\tout vehicleMass: VehicleMass;\n\t\t\tout wheelPower: WheelPower;\n\t\t\tout dragCoefficient: DragCoefficient;\n\t\t\tout rollingResistanceCoefficient: RollingResistanceCoefficient;\n\t\t\tout initialSpeed: InitialSpeed;\n\t\t\tout initialPosition: InitialPosition;\n\t\t\tout timeStep: TimeStep;\n\t\t}\n\t\tsuccession flow inputFlow from sendInputParameters.vehicleMass to computeForces.vehicleMass;\n\t\tsuccession flow inputFlow from sendInputParameters.wheelPower to computeForces.wheelPower;\n\t\tsuccession flow inputFlow from sendInputParameters.dragCoefficient to computeForces.dragCoefficient;\n\t\tsuccession flow inputFlow from sendInputParameters.rollingResistanceCoefficient to computeForces.rollingResistanceCoefficient;\n\t\tsuccession flow inputFlow from sendInputParameters.initialSpeed to computeForces.speed;\n\t\tsuccession flow inputFlow from sendInputParameters.initialPosition to computeForces.position;\n\t\tsuccession flow inputFlow from sendInputParameters.timeStep to computeForces.timeStep;\n\t\taction computeForces {\n\t\t\tin vehicleMass: VehicleMass;\n\t\t\tin wheelPower: WheelPower;\n\t\t\tin dragCoefficient: DragCoefficient;\n\t\t\tin rollingResistanceCoefficient: RollingResistanceCoefficient;\n\t\t\tin speed: Speed;\n\t\t\tin position: Position;\n\t\t\tin timeStep: TimeStep;\n\t\t\tout dragForce;\n\t\t\tout rollingResistanceForce;\n\t\t}\n\t\tsuccession flow netForceFlow from computeForces.dragForce to calculateNetForce.dragForce;\n\t\tsuccession flow netForceFlow from computeForces.rollingResistanceForce to calculateNetForce.rollingResistanceForce;\n\t\tsuccession flow netForceFlow from computeForces.wheelPower to calculateNetForce.wheelPower;\n\t\taction calculateNetForce {\n\t\t\tin dragForce;\n\t\t\tin rollingResistanceForce;\n\t\t\tin wheelPower;\n\t\t\tout netForce;\n\t\t}\n\t\tsuccession flow accelerationFlow from calculateNetForce.netForce to calculateAcceleration.netForce;\n\t\tsuccession flow massFlow from computeForces.vehicleMass to calculateAcceleration.vehicleMass;\n\t\taction calculateAcceleration {\n\t\t\tin netForce;\n\t\t\tin vehicleMass;\n\t\t\tout acceleration;\n\t\t}\n\t\tsuccession flow updateFlow from calculateAcceleration.acceleration to updateSpeedPosition.acceleration;\n\t\tsuccession flow speedFlow from computeForces.speed to updateSpeedPosition.speed;\n\t\tsuccession flow positionFlow from computeForces.position to updateSpeedPosition.position;\n\t\tsuccession flow timeStepFlow from computeForces.timeStep to updateSpeedPosition.timeStep;\n\t\taction updateSpeedPosition {\n\t\t\tin acceleration;\n\t\t\tin speed;\n\t\t\tin position;\n\t\t\tin timeStep;\n\t\t\tout nextSpeed;\n\t\t\tout nextPosition;\n\t\t}\n\t\tsuccession flow outputFlow from updateSpeedPosition.nextSpeed to outputResults.nextSpeed;\n\t\tsuccession flow outputFlow from updateSpeedPosition.nextPosition to outputResults.nextPosition;\n\t\tsuccession flow accelerationOutput from calculateAcceleration.acceleration to outputResults.acceleration;\n\t\taction outputResults {\n\t\t\tin nextSpeed;\n\t\t\tin nextPosition;\n\t\t\tin acceleration;\n\t\t\tout speed;\n\t\t\tout position;\n\t\t\tout acceleration;\n\t\t}\n\t}\n}",
    "package 'VehicleLongitudinalDynamics' {\n\tattribute def InitialPosition;\n\tattribute def InitialVelocity;\n\tattribute def Mass;\n\tattribute def WheelEndDrivePower;\n\tattribute def TimeInterval;\n\tattribute def DragCoefficient;\n\tattribute def FrictionCoefficient;\n\tattribute def Acceleration;\n\tattribute def FinalVelocity;\n\tattribute def FinalPosition;\n\tattribute def DriveForce;\n\tattribute def DragForce;\n\tattribute def FrictionForce;\n\tattribute def NetForce;\n\tport def InputPort {\n\t\tout initialPosition: InitialPosition;\n\t\tout initialVelocity: InitialVelocity;\n\t\tout mass: Mass;\n\t\tout wheelEndDrivePower: WheelEndDrivePower;\n\t\tout timeInterval: TimeInterval;\n\t\tout dragCoefficient: DragCoefficient;\n\t\tout frictionCoefficient: FrictionCoefficient;\n\t}\n\tport def OutputPort {\n\t\tout acceleration: Acceleration;\n\t\tout finalVelocity: FinalVelocity;\n\t\tout finalPosition: FinalPosition;\n\t}\n\tport def DragForcePort {\n\t\tin dragForce: DragForce;\n\t}\n\tport def FrictionForcePort {\n\t\tin frictionForce: FrictionForce;\n\t}\n\tpart context {\n\t\tpart user {\n\t\t\tport inputPort: InputPort;\n\t\t\tperform longitudinalDynamicsComputation.sendInputParameters {\n\t\t\t\tout initialPosition = inputPort.initialPosition;\n\t\t\t\tout initialVelocity = inputPort.initialVelocity;\n\t\t\t\tout mass = inputPort.mass;\n\t\t\t\tout wheelEndDrivePower = inputPort.wheelEndDrivePower;\n\t\t\t\tout timeInterval = inputPort.timeInterval;\n\t\t\t\tout dragCoefficient = inputPort.dragCoefficient;\n\t\t\t\tout frictionCoefficient = inputPort.frictionCoefficient;\n\t\t\t}\n\t\t}\n\t\tinterface userToVehicle connect user.inputPort to vehicle.inputPort {\n\t\t\tref flow references longitudinalDynamicsComputation.inputFlow\n\t\t\t\tfrom source.initialPosition to target.initialPosition;\n\t\t\t\tfrom source.initialVelocity to target.initialVelocity;\n\t\t\t\tfrom source.mass to target.mass;\n\t\t\t\tfrom source.wheelEndDrivePower to target.wheelEndDrivePower;\n\t\t\t\tfrom source.timeInterval to target.timeInterval;\n\t\t\t\tfrom source.dragCoefficient to target.dragCoefficient;\n\t\t\t\tfrom source.frictionCoefficient to target.frictionCoefficient;\n\t\t}\n\t\tpart vehicle {\n\t\t\tport inputPort: ~InputPort;\n\t\t\tperform longitudinalDynamicsComputation.calculateDriveForce {\n\t\t\t\tin wheelEndDrivePower = inputPort.wheelEndDrivePower;\n\t\t\t\tin initialVelocity = inputPort.initialVelocity;\n\t\t\t\tout driveForce = dragForcePort.driveForce;\n\t\t\t}\n\t\t\tport dragForcePort: ~DragForcePort;\n\t\t\tperform longitudinalDynamicsComputation.calculateDragForce {\n\t\t\t\tin initialVelocity = inputPort.initialVelocity;\n\t\t\t\tin dragCoefficient = inputPort.dragCoefficient;\n\t\t\t\tout dragForce = dragForcePort.dragForce;\n\t\t\t}\n\t\t\tperform longitudinalDynamicsComputation.calculateFrictionForce {\n\t\t\t\tin mass = inputPort.mass;\n\t\t\t\tin frictionCoefficient = inputPort.frictionCoefficient;\n\t\t\t\tout frictionForce = frictionForcePort.frictionForce;\n\t\t\t}\n\t\t\tport frictionForcePort: ~FrictionForcePort;\n\t\t\tperform longitudinalDynamicsComputation.computeNetForce {\n\t\t\t\tin driveForce = dragForcePort.driveForce;\n\t\t\t\tin dragForce = dragForcePort.dragForce;\n\t\t\t\tin frictionForce = frictionForcePort.frictionForce;\n\t\t\t\tout netForce = accelerationCalculation.netForce;\n\t\t\t}\n\t\t\tperform longitudinalDynamicsComputation.calculateAcceleration {\n\t\t\t\tin netForce = accelerationCalculation.netForce;\n\t\t\t\tin mass = inputPort.mass;\n\t\t\t\tout acceleration = accelerationOutput.acceleration;\n\t\t\t}\n\t\t\tperform longitudinalDynamicsComputation.updateVelocity {\n\t\t\t\tin initialVelocity = inputPort.initialVelocity;\n\t\t\t\tin acceleration = accelerationOutput.acceleration;\n\t\t\t\tin timeInterval = inputPort.timeInterval;\n\t\t\t\tout finalVelocity = velocityOutput.finalVelocity;\n\t\t\t}\n\t\t\tperform longitudinalDynamicsComputation.updatePosition {\n\t\t\t\tin initialPosition = inputPort.initialPosition;\n\t\t\t\tin initialVelocity = inputPort.initialVelocity;\n\t\t\t\tin acceleration = accelerationOutput.acceleration;\n\t\t\t\tin timeInterval = inputPort.timeInterval;\n\t\t\t\tout finalPosition = positionOutput.finalPosition;\n\t\t\t}\n\t\t\tport outputPort: OutputPort;\n\t\t\tperform longitudinalDynamicsComputation.outputResults {\n\t\t\t\tin acceleration = accelerationOutput.acceleration;\n\t\t\t\tin finalVelocity = velocityOutput.finalVelocity;\n\t\t\t\tin finalPosition = positionOutput.finalPosition;\n\t\t\t\tout acceleration = outputPort.acceleration;\n\t\t\t\tout finalVelocity = outputPort.finalVelocity;\n\t\t\t\tout finalPosition = outputPort.finalPosition;\n\t\t\t}\n\t\t}\n\t\tinterface vehicleToAirResistance connect vehicle.dragForcePort to airResistance.dragForcePort {\n\t\t\tref flow references longitudinalDynamicsComputation.dragForceFlow\n\t\t\t\tfrom source.driveForce to target.driveForce;\n\t\t}\n\t\tpart airResistance {\n\t\t\tport dragForcePort: DragForcePort;\n\t\t}\n\t\tinterface vehicleToFriction connect vehicle.frictionForcePort to friction.frictionForcePort {\n\t\t\tref flow references longitudinalDynamicsComputation.frictionForceFlow\n\t\t\t\tfrom source.frictionForce to target.frictionForce;\n\t\t}\n\t\tpart friction {\n\t\t\tport frictionForcePort: FrictionForcePort;\n\t\t}\n\t}\n\taction longitudinalDynamicsComputation {\n\t\taction sendInputParameters {\n\t\t\tout initialPosition: InitialPosition;\n\t\t\tout initialVelocity: InitialVelocity;\n\t\t\tout mass: Mass;\n\t\t\tout wheelEndDrivePower: WheelEndDrivePower;\n\t\t\tout timeInterval: TimeInterval;\n\t\t\tout dragCoefficient: DragCoefficient;\n\t\t\tout frictionCoefficient: FrictionCoefficient;\n\t\t}\n\t\tsuccession flow inputFlow from sendInputParameters.initialPosition to calculateDriveForce.initialPosition;\n\t\tsuccession flow inputFlow from sendInputParameters.initialVelocity to calculateDriveForce.initialVelocity;\n\t\tsuccession flow inputFlow from sendInputParameters.mass to calculateFrictionForce.mass;\n\t\tsuccession flow inputFlow from sendInputParameters.wheelEndDrivePower to calculateDriveForce.wheelEndDrivePower;\n\t\tsuccession flow inputFlow from sendInputParameters.timeInterval to updateVelocity.timeInterval;\n\t\tsuccession flow inputFlow from sendInputParameters.timeInterval to updatePosition.timeInterval;\n\t\tsuccession flow inputFlow from sendInputParameters.dragCoefficient to calculateDragForce.dragCoefficient;\n\t\tsuccession flow inputFlow from sendInputParameters.frictionCoefficient to calculateFrictionForce.frictionCoefficient;\n\t\taction calculateDriveForce {\n\t\t\tin wheelEndDrivePower: WheelEndDrivePower;\n\t\t\tin initialVelocity: InitialVelocity;\n\t\t\tout driveForce: DriveForce;\n\t\t}\n\t\taction calculateDragForce {\n\t\t\tin initialVelocity: InitialVelocity;\n\t\t\tin dragCoefficient: DragCoefficient;\n\t\t\tout dragForce: DragForce;\n\t\t}\n\t\taction calculateFrictionForce {\n\t\t\tin mass: Mass;\n\t\t\tin frictionCoefficient: FrictionCoefficient;\n\t\t\tout frictionForce: FrictionForce;\n\t\t}\n\t\taction computeNetForce {\n\t\t\tin driveForce: DriveForce;\n\t\t\tin dragForce: DragForce;\n\t\t\tin frictionForce: FrictionForce;\n\t\t\tout netForce: NetForce;\n\t\t}\n\t\taction calculateAcceleration {\n\t\t\tin netForce: NetForce;\n\t\t\tin mass: Mass;\n\t\t\tout acceleration: Acceleration;\n\t\t}\n\t\taction updateVelocity {\n\t\t\tin initialVelocity: InitialVelocity;\n\t\t\tin acceleration: Acceleration;\n\t\t\tin timeInterval: TimeInterval;\n\t\t\tout finalVelocity: FinalVelocity;\n\t\t}\n\t\taction updatePosition {\n\t\t\tin initialPosition: InitialPosition;\n\t\t\tin initialVelocity: InitialVelocity;\n\t\t\tin acceleration: Acceleration;\n\t\t\tin timeInterval: TimeInterval;\n\t\t\tout finalPosition: FinalPosition;\n\t\t}\n\t\taction outputResults {\n\t\t\tin acceleration: Acceleration;\n\t\t\tin finalVelocity: FinalVelocity;\n\t\t\tin finalPosition: FinalPosition;\n\t\t\tout acceleration: Acceleration;\n\t\t\tout finalVelocity: FinalVelocity;\n\t\t\tout finalPosition: FinalPosition;\n\t\t}\n\t\tsuccession flow dragForceFlow from calculateDragForce.dragForce to computeNetForce.dragForce;\n\t\tsuccession flow frictionForceFlow from calculateFrictionForce.frictionForce to computeNetForce.frictionForce;\n\t\tsuccession flow driveForceFlow from calculateDriveForce.driveForce to computeNetForce.driveForce;\n\t\tsuccession flow netForceFlow from computeNetForce.netForce to calculateAcceleration.netForce;\n\t\tsuccession flow accelerationFlow from calculateAcceleration.acceleration to updateVelocity.acceleration;\n\t\tsuccession flow accelerationFlow from calculateAcceleration.acceleration to updatePosition.acceleration;\n\t\tsuccession flow velocityFlow from updateVelocity.finalVelocity to outputResults.finalVelocity;\n\t\tsuccession flow positionFlow from updatePosition.finalPosition to outputResults.finalPosition;\n\t}\n}",
    "package 'VehicleMassManagement' {\n\tattribute def Mass;\n\tattribute def Warning;\n\tport def MassPort {\n\t\tout mass: Mass;\n\t}\n\tport def WarningPort {\n\t\tout warning: Warning;\n\t}\n\tpart context {\n\t\tpart chassis {\n\t\t\tport massPort: MassPort;\n\t\t\tperform calculateTotalMass.sendChassisMass {\n\t\t\t\tout mass = massPort.mass;\n\t\t\t}\n\t\t}\n\t\tpart engine {\n\t\t\tport massPort: MassPort;\n\t\t\tperform calculateTotalMass.sendEngineMass {\n\t\t\t\tout mass = massPort.mass;\n\t\t\t}\n\t\t}\n\t\tpart gearbox {\n\t\t\tport massPort: MassPort;\n\t\t\tperform calculateTotalMass.sendGearboxMass {\n\t\t\t\tout mass = massPort.mass;\n\t\t\t}\n\t\t}\n\t\tinterface chassisToCalculator connect chassis.massPort to massCalculator.chassisMassPort {\n\t\t\tref flow references calculateTotalMass.chassisMassFlow\n\t\t\t\tfrom source.mass to target.mass;\n\t\t}\n\t\tinterface engineToCalculator connect engine.massPort to massCalculator.engineMassPort {\n\t\t\tref flow references calculateTotalMass.engineMassFlow\n\t\t\t\tfrom source.mass to target.mass;\n\t\t}\n\t\tinterface gearboxToCalculator connect gearbox.massPort to massCalculator.gearboxMassPort {\n\t\t\tref flow references calculateTotalMass.gearboxMassFlow\n\t\t\t\tfrom source.mass to target.mass;\n\t\t}\n\t\tpart massCalculator {\n\t\t\tport chassisMassPort: ~MassPort;\n\t\t\tport engineMassPort: ~MassPort;\n\t\t\tport gearboxMassPort: ~MassPort;\n\t\t\tperform calculateTotalMass.calculateTotal {\n\t\t\t\tin chassisMass = chassisMassPort.mass;\n\t\t\t\tin engineMass = engineMassPort.mass;\n\t\t\t\tin gearboxMass = gearboxMassPort.mass;\n\t\t\t\tout totalMass = totalMassPort.mass;\n\t\t\t}\n\t\t\tport totalMassPort: MassPort;\n\t\t}\n\t\tinterface calculatorToWarning connect massCalculator.totalMassPort to warningSystem.totalMassPort {\n\t\t\tref flow references calculateTotalMass.totalMassFlow\n\t\t\t\tfrom source.mass to target.mass;\n\t\t}\n\t\tpart warningSystem {\n\t\t\tport totalMassPort: ~MassPort;\n\t\t\tperform checkTotalMass.checkLimit {\n\t\t\t\tin totalMass = totalMassPort.mass;\n\t\t\t\tout warning = warningPort.warning;\n\t\t\t}\n\t\t\tport warningPort: WarningPort;\n\t\t}\n\t}\n\taction calculateTotalMass {\n\t\taction sendChassisMass { out mass: Mass; }\n\t\taction sendEngineMass { out mass: Mass; }\n\t\taction sendGearboxMass { out mass: Mass; }\n\t\tsuccession flow chassisMassFlow from sendChassisMass.mass to calculateTotal.mass;\n\t\tsuccession flow engineMassFlow from sendEngineMass.mass to calculateTotal.mass;\n\t\tsuccession flow gearboxMassFlow from sendGearboxMass.mass to calculateTotal.mass;\n\t\taction calculateTotal { \n\t\t\tin chassisMass: Mass;\n\t\t\tin engineMass: Mass;\n\t\t\tin gearboxMass: Mass;\n\t\t\tout mass: Mass;\n\t\t}\n\t\tsuccession flow totalMassFlow from calculateTotal.mass to checkLimit.totalMass;\n\t\taction checkLimit { \n\t\t\tin totalMass: Mass;\n\t\t\tout warning: Warning;\n\t\t\tif (totalMass > 2500) {\n\t\t\t\twarning = \"Overweight: Total mass exceeds 2,500 kg limit.\";\n\t\t\t}\n\t\t}\n\t}\n}",
    "package 'VehicleMassBudgeting' {\n\tattribute def ChassisMass;\n\tattribute def EngineMass;\n\tattribute def TransmissionMass;\n\tattribute def TotalMass;\n\tattribute def MassLimit = 2500;\n\n\tpart context {\n\t\tpart vehicle {\n\t\t\tpart chassis {\n\t\t\t\tattribute mass: ChassisMass;\n\t\t\t}\n\t\t\tpart engine {\n\t\t\t\tattribute mass: EngineMass;\n\t\t\t}\n\t\t\tpart transmission {\n\t\t\t\tattribute mass: TransmissionMass;\n\t\t\t}\n\t\t\tperform calculateTotalMass {\n\t\t\t\tin chassisMass = chassis.mass;\n\t\t\t\tin engineMass = engine.mass;\n\t\t\t\tin transmissionMass = transmission.mass;\n\t\t\t\tout totalMass = TotalMass;\n\t\t\t}\n\t\t}\n\t}\n\taction calculateTotalMass {\n\t\tin chassisMass: ChassisMass;\n\t\tin engineMass: EngineMass;\n\t\tin transmissionMass: TransmissionMass;\n\t\tout totalMass: TotalMass;\n\t}\n\taction checkMassConstraint {\n\t\tin totalMass: TotalMass;\n\t\tin massLimit: MassLimit;\n\t}\n\tsuccession flow from calculateTotalMass.totalMass to checkMassConstraint.totalMass;\n}",
    "package 'VehicleMassCompliance' {\n\tattribute def ChassisMass;\n\tattribute def EngineMass;\n\tattribute def TransmissionMass;\n\tattribute def TotalMass;\n\tattribute def ComplianceStatus;\n\tport def MassPort {\n\t\tout mass : ChassisMass, EngineMass, TransmissionMass;\n\t}\n\tport def CompliancePort {\n\t\tout compliance : ComplianceStatus;\n\t}\n\tpart context {\n\t\tpart chassis {\n\t\t\tport massPort: MassPort;\n\t\t\tperform checkVehicleMassCompliance.getChassisMass {\n\t\t\t\tout mass = massPort.mass;\n\t\t\t}\n\t\t}\n\t\tinterface chassisToVehicle connect chassis.massPort to vehicle.massPort {\n\t\t\tref flow references checkVehicleMassCompliance.chassisMassFlow\n\t\t\t\tfrom source.mass to target.mass;\n\t\t}\n\t\tpart engine {\n\t\t\tport massPort: MassPort;\n\t\t\tperform checkVehicleMassCompliance.getEngineMass {\n\t\t\t\tout mass = massPort.mass;\n\t\t\t}\n\t\t}\n\t\tinterface engineToVehicle connect engine.massPort to vehicle.massPort {\n\t\t\tref flow references checkVehicleMassCompliance.engineMassFlow\n\t\t\t\tfrom source.mass to target.mass;\n\t\t}\n\t\tpart transmission {\n\t\t\tport massPort: MassPort;\n\t\t\tperform checkVehicleMassCompliance.getTransmissionMass {\n\t\t\t\tout mass = massPort.mass;\n\t\t\t}\n\t\t}\n\t\tinterface transmissionToVehicle connect transmission.massPort to vehicle.massPort {\n\t\t\tref flow references checkVehicleMassCompliance.transmissionMassFlow\n\t\t\t\tfrom source.mass to target.mass;\n\t\t}\n\t\tpart vehicle {\n\t\t\tport massPort: ~MassPort;\n\t\t\tperform checkVehicleMassCompliance.sumTotalMass {\n\t\t\t\tin chassisMass = massPort.mass;\n\t\t\t\tin engineMass = massPort.mass;\n\t\t\t\tin transmissionMass = massPort.mass;\n\t\t\t\tout totalMass = totalMass;\n\t\t\t}\n\t\t\tport compliancePort: CompliancePort;\n\t\t\tperform checkVehicleMassCompliance.checkCompliance {\n\t\t\t\tin totalMass = sumTotalMass.totalMass;\n\t\t\t\tout compliance = compliancePort.compliance;\n\t\t\t}\n\t\t}\n\t}\n\taction checkVehicleMassCompliance {\n\t\taction getChassisMass { out mass: ChassisMass; }\n\t\taction getEngineMass { out mass: EngineMass; }\n\t\taction getTransmissionMass { out mass: TransmissionMass; }\n\t\tsuccession flow chassisMassFlow from getChassisMass.mass to sumTotalMass.chassisMass;\n\t\tsuccession flow engineMassFlow from getEngineMass.mass to sumTotalMass.engineMass;\n\t\tsuccession flow transmissionMassFlow from getTransmissionMass.mass to sumTotalMass.transmissionMass;\n\t\taction sumTotalMass { \n\t\t\tin chassisMass: ChassisMass; \n\t\t\tin engineMass: EngineMass; \n\t\t\tin transmissionMass: TransmissionMass; \n\t\t\tout totalMass: TotalMass = chassisMass + engineMass + transmissionMass; \n\t\t}\n\t\taction checkCompliance { \n\t\t\tin totalMass: TotalMass; \n\t\t\tout compliance: ComplianceStatus = if totalMass <= 2500 then true else false; \n\t\t}\n\t}\n}",
    "package 'VehicleWeightManagement' {  \n\tattribute def ChassisWeight;  \n\tattribute def EngineWeight;  \n\tattribute def TransmissionWeight;  \n\tattribute def TotalWeight;  \n\tattribute def WarningSignal;  \n\tport def ChassisWeightPort { out weight: ChassisWeight; }  \n\tport def EngineWeightPort { out weight: EngineWeight; }  \n\tport def TransmissionWeightPort { out weight: TransmissionWeight; }  \n\tport def TotalWeightPort { out totalWeight: TotalWeight; }  \n\tport def WarningPort { out warning: WarningSignal; }  \n\tpart context {  \n\t\tpart chassis {  \n\t\t\tport weightPort: ChassisWeightPort;  \n\t\t\tperform weightManagementRegion.recordChassisWeight {  \n\t\t\t\tout weight = weightPort.weight;  \n\t\t\t}  \n\t\t}  \n\t\tinterface chassisToManager connect chassis.weightPort to weightManager.chassisWeightPort {  \n\t\t\tref flow references weightManagementRegion.chassisWeightFlow  \n\t\t\t\tfrom source.weight to target.weight;  \n\t\t}  \n\t\tpart engine {  \n\t\t\tport weightPort: EngineWeightPort;  \n\t\t\tperform weightManagementRegion.recordEngineWeight {  \n\t\t\t\tout weight = weightPort.weight;  \n\t\t\t}  \n\t\t}  \n\t\tinterface engineToManager connect engine.weightPort to weightManager.engineWeightPort {  \n\t\t\tref flow references weightManagementRegion.engineWeightFlow  \n\t\t\t\tfrom source.weight to target.weight;  \n\t\t}  \n\t\tpart transmission {  \n\t\t\tport weightPort: TransmissionWeightPort;  \n\t\t\tperform weightManagementRegion.recordTransmissionWeight {  \n\t\t\t\tout weight = weightPort.weight;  \n\t\t\t}  \n\t\t}  \n\t\tinterface transmissionToManager connect transmission.weightPort to weightManager.transmissionWeightPort {  \n\t\t\tref flow references weightManagementRegion.transmissionWeightFlow  \n\t\t\t\tfrom source.weight to target.weight;  \n\t\t}  \n\t\tpart weightManager {  \n\t\t\tport chassisWeightPort: ~ChassisWeightPort;  \n\t\t\tport engineWeightPort: ~EngineWeightPort;  \n\t\t\tport transmissionWeightPort: ~TransmissionWeightPort;  \n\t\t\tport totalWeightPort: TotalWeightPort;  \n\t\t\tperform weightManagementRegion.sumWeights {  \n\t\t\t\tin chassisWeight = chassisWeightPort.weight;  \n\t\t\t\tin engineWeight = engineWeightPort.weight;  \n\t\t\t\tin transmissionWeight = transmissionWeightPort.weight;  \n\t\t\t\tout totalWeight = totalWeightPort.totalWeight;  \n\t\t\t}  \n\t\t}  \n\t\tinterface managerToWarning connect weightManager.totalWeightPort to warningSystem.totalWeightPort {  \n\t\t\tref flow references weightManagementRegion.totalWeightFlow  \n\t\t\t\tfrom source.totalWeight to target.totalWeight;  \n\t\t}  \n\t\tpart warningSystem {  \n\t\t\tport totalWeightPort: ~TotalWeightPort;  \n\t\t\tport warningPort: WarningPort;  \n\t\t\tperform weightManagementRegion.checkWeightLimit {  \n\t\t\t\tin totalWeight = totalWeightPort.totalWeight;  \n\t\t\t\tout warning = warningPort.warning;  \n\t\t\t}  \n\t\t}  \n\t}  \n\taction weightManagementRegion {  \n\t\taction recordChassisWeight { out weight: ChassisWeight; }  \n\t\taction recordEngineWeight { out weight: EngineWeight; }  \n\t\taction recordTransmissionWeight { out weight: TransmissionWeight; }  \n\t\tsuccession flow chassisWeightFlow from recordChassisWeight.weight to sumWeights.chassisWeight;  \n\t\tsuccession flow engineWeightFlow from recordEngineWeight.weight to sumWeights.engineWeight;  \n\t\tsuccession flow transmissionWeightFlow from recordTransmissionWeight.weight to sumWeights.transmissionWeight;  \n\t\taction sumWeights {  \n\t\t\tin chassisWeight: ChassisWeight;  \n\t\t\tin engineWeight: EngineWeight;  \n\t\t\tin transmissionWeight: TransmissionWeight;  \n\t\t\tout totalWeight: TotalWeight;  \n\t\t}  \n\t\tsuccession flow totalWeightFlow from sumWeights.totalWeight to checkWeightLimit.totalWeight;  \n\t\taction checkWeightLimit {  \n\t\t\tin totalWeight: TotalWeight;  \n\t\t\tout warning: WarningSignal;  \n\t\t}  \n\t\tsuccession flow warningFlow from checkWeightLimit.warning to sendWarning.warning;  \n\t\taction sendWarning { out warning: WarningSignal; }  \n\t}  \n}",
    "package 'VehicleSystem' {  \n\tattribute def mass : Real;  \n\tattribute def initialVelocity : Real;  \n\tattribute def finalVelocity : Real;  \n\tattribute def appliedForce : Real;  \n\tattribute def timePeriod : Real;  \n\tattribute def chassisMass : Real;  \n\tattribute def engineMass : Real;  \n\tattribute def transmissionMass : Real;  \n\n\tpart context {  \n\t\tpart vehicle {  \n\t\t\tpart chassis {  \n\t\t\t\tattribute chassisMass;  \n\t\t\t}  \n\t\t\tpart engine {  \n\t\t\t\tattribute engineMass;  \n\t\t\t}  \n\t\t\tpart transmission {  \n\t\t\t\tattribute transmissionMass;  \n\t\t\t}  \n\t\t}  \n\t\taction massConstraintRegion {  \n\t\t\taction calculateTotalMass {  \n\t\t\t\tin chassisMass = vehicle.chassis.chassisMass;  \n\t\t\t\tin engineMass = vehicle.engine.engineMass;  \n\t\t\t\tin transmissionMass = vehicle.transmission.transmissionMass;  \n\t\t\t\tout totalMass = mass;  \n\t\t\t}  \n\t\t\taction checkTotalMassConstraint {  \n\t\t\t\tin totalMass = calculateTotalMass.mass;  \n\t\t\t\tconstraint totalMass <= 2500;  \n\t\t\t}  \n\t\t\taction verifyDynamicConstraints {  \n\t\t\t\tin mass = calculateTotalMass.mass;  \n\t\t\t\tin initialVelocity;  \n\t\t\t\tin finalVelocity;  \n\t\t\t\tin appliedForce;  \n\t\t\t\tin timePeriod;  \n\t\t\t\tconstraint mass > 0;  \n\t\t\t\tconstraint appliedForce * timePeriod == mass * (finalVelocity - initialVelocity);  \n\t\t\t}  \n\t\t}  \n\t\tsuccession flow from calculateTotalMass.chassisMass to checkTotalMassConstraint.chassisMass;  \n\t\tsuccession flow from calculateTotalMass.engineMass to checkTotalMassConstraint.engineMass;  \n\t\tsuccession flow from calculateTotalMass.transmissionMass to checkTotalMassConstraint.transmissionMass;  \n\t\tsuccession flow from calculateTotalMass.totalMass to verifyDynamicConstraints.mass;  \n\t}  \n}",
    "package 'VehicleMaintenanceSystem' {\n\tattribute def MaintenanceCmd;\n\tattribute def HealthStatus;\n\tattribute def Time;\n\tattribute def MaintenanceInterval;\n\tattribute def MaxTemperature;\n\tport def MaintenanceCmdPort {\n\t\tout maintenanceCmd : MaintenanceCmd;\n\t}\n\tport def HealthStatusPort {\n\t\tout healthStatus: HealthStatus;\n\t}\n\tport def TimePort {\n\t\tin currentTime: Time;\n\t}\n\tpart context {\n\t\tpart vehicle {\n\t\t\tport maintenanceCmdPort: MaintenanceCmdPort;\n\t\t\tport healthStatusPort: HealthStatusPort;\n\t\t\tattribute nextMaintenanceTime: Time;\n\t\t\tattribute interval: MaintenanceInterval;\n\t\t\tattribute maxTemp: MaxTemperature;\n\t\t\tperform maintenanceScheduler.checkMaintenanceDue {\n\t\t\t\tin currentTime = timeSource.currentTime;\n\t\t\t\tout maintenanceCmd = maintenanceCmdPort.maintenanceCmd;\n\t\t\t}\n\t\t\tperform maintenanceProcess.updateNextMaintenance {\n\t\t\t\tin currentTime = timeSource.currentTime;\n\t\t\t\tin duration = maintenanceProcess.duration;\n\t\t\t\tout nextMaintenanceTime = nextMaintenanceTime;\n\t\t\t}\n\t\t}\n\t\tpart maintenanceScheduler {\n\t\t\tport maintenanceCmdPort: ~MaintenanceCmdPort;\n\t\t\tport timePort: TimePort;\n\t\t\tperform maintenanceScheduler.checkMaintenanceDue {\n\t\t\t\tin currentTime = timePort.currentTime;\n\t\t\t\tout maintenanceCmd = maintenanceCmdPort.maintenanceCmd;\n\t\t\t}\n\t\t}\n\t\tpart maintenanceProcess {\n\t\t\tport maintenanceCmdPort: ~MaintenanceCmdPort;\n\t\t\tport healthStatusPort: ~HealthStatusPort;\n\t\t\tattribute startTime: Time;\n\t\t\tattribute endTime: Time;\n\t\t\tperform maintenanceProcess.initiateMaintenance {\n\t\t\t\tin maintenanceCmd = maintenanceCmdPort.maintenanceCmd;\n\t\t\t\tconstraint startTime >= vehicle.nextMaintenanceTime;\n\t\t\t\tconstraint startTime - vehicle.nextMaintenanceTime <= 2s;\n\t\t\t\tout healthStatusPort.healthStatus = \"under maintenance\";\n\t\t\t}\n\t\t\tperform maintenanceProcess.performMaintenance {\n\t\t\t\tin startTime = startTime;\n\t\t\t\tconstraint endTime - startTime <= 48h;\n\t\t\t}\n\t\t\tperform maintenanceProcess.completeMaintenance {\n\t\t\t\tout healthStatusPort.healthStatus = \"normal\";\n\t\t\t}\n\t\t}\n\t\tpart timeSource {\n\t\t\tport timePort: TimePort;\n\t\t\tperform timeSource.provideCurrentTime {\n\t\t\t\tout timePort.currentTime = currentTime;\n\t\t\t}\n\t\t}\n\t}\n\taction maintenanceScheduler {\n\t\taction checkMaintenanceDue {\n\t\t\tin currentTime: Time;\n\t\t\tout maintenanceCmd: MaintenanceCmd;\n\t\t}\n\t}\n\taction maintenanceProcess {\n\t\taction initiateMaintenance {\n\t\t\tin maintenanceCmd: MaintenanceCmd;\n\t\t\tin startTime: Time;\n\t\t\tout healthStatus: HealthStatus;\n\t\t}\n\t\taction performMaintenance {\n\t\t\tin startTime: Time;\n\t\t\tconstraint duration = endTime - startTime <= 48h;\n\t\t}\n\t\taction completeMaintenance {\n\t\t\tout healthStatus: HealthStatus;\n\t\t}\n\t\tsuccession flow maintenanceCmdFlow from checkMaintenanceDue.maintenanceCmd to initiateMaintenance.maintenanceCmd;\n\t\tsuccession flow maintenanceDurationFlow from initiateMaintenance.startTime to performMaintenance.startTime;\n\t\tsuccession flow maintenanceCompletionFlow from performMaintenance.endTime to completeMaintenance;\n\t}\n}",
    "package 'VehicleSystem' {\n\tattribute def TotalMass;\n\tattribute def CurbWeight;\n\tattribute def FuelMass;\n\tattribute def MaxMassLimit;\n\tattribute def EngineTorque;\n\tattribute def EngineSpeed;\n\tport def TorquePort {\n\t\tout torque: EngineTorque;\n\t}\n\tpart context {\n\t\tpart vehicle {\n\t\t\tpart curbWeight;\n\t\t\tpart fuelMass;\n\t\t\tconstraint totalMassConstraint {\n\t\t\t\tTotalMass = CurbWeight + FuelMass;\n\t\t\t\tTotalMass <= MaxMassLimit;\n\t\t\t}\n\t\t\tconstraint fuelMassConstraint {\n\t\t\t\tFuelMass > 0;\n\t\t\t}\n\t\t}\n\t\tinterface vehicleMassConstraint {\n\t\t\tref CurbWeight references vehicle.curbWeight;\n\t\t\tref FuelMass references vehicle.fuelMass;\n\t\t\tref TotalMass references vehicle.totalMassConstraint.TotalMass;\n\t\t\tref MaxMassLimit references vehicle.totalMassConstraint.MaxMassLimit;\n\t\t}\n\t\tpart engine {\n\t\t\tperform engineOperation {\n\t\t\t\tout torquePort: TorquePort;\n\t\t\t}\n\t\t}\n\t\tinterface engineToClutch connect engine.torquePort to clutch.torquePort {\n\t\t\tref engineOperation.torquePort.torque to clutchOperation.torquePort.torque;\n\t\t}\n\t\tpart clutch {\n\t\t\tport torquePort: ~TorquePort;\n\t\t\tperform clutchOperation {\n\t\t\t\tin torquePort: TorquePort;\n\t\t\t\tout torquePort: TorquePort;\n\t\t\t}\n\t\t}\n\t\tinterface clutchToTransmission connect clutch.torquePort to transmission.torquePort {\n\t\t\tref clutchOperation.torquePort.torque to transmissionOperation.torquePort.torque;\n\t\t}\n\t\tpart transmission {\n\t\t\tport torquePort: ~TorquePort;\n\t\t\tperform transmissionOperation {\n\t\t\t\tin torquePort: TorquePort;\n\t\t\t}\n\t\t}\n\t}\n\taction engineOperation {\n\t\taction generateTorque {\n\t\t\tin engineSpeed: EngineSpeed;\n\t\t\tout torque: EngineTorque;\n\t\t\tconstraint speedTorqueCurve {\n\t\t\t\tEngineTorque = function(EngineSpeed); \n\t\t\t}\n\t\t}\n\t\tsuccession flow torqueFlow from generateTorque.torque to torquePort.torque;\n\t}\n\taction clutchOperation {\n\t\taction transmitTorque {\n\t\t\tin torque: EngineTorque;\n\t\t\tout torque: EngineTorque;\n\t\t}\n\t\tsuccession flow torqueTransfer from torquePort.torque to transmitTorque.torque;\n\t\tsuccession flow torqueOutput from transmitTorque.torque to torquePort.torque;\n\t}\n\taction transmissionOperation {\n\t\taction deliverPower {\n\t\t\tin torque: EngineTorque;\n\t\t}\n\t\tsuccession flow powerDelivery from torquePort.torque to deliverPower.torque;\n\t}\n}",
    "package 'VehicleSystem' {\n\tattribute def dryMass;\n\tattribute def fuelMass;\n\tattribute def torque;\n\tattribute def speed;\n\tport def TorquePort {\n\t\tout torque : torque;\n\t}\n\tport def SpeedPort {\n\t\tin speed : speed;\n\t}\n\tpart context {\n\t\tpart vehicle {\n\t\t\tattribute dryMass = 1500;\n\t\t\tattribute fuelMass = 500;\n\t\t\tconstraint massConstraint {\n\t\t\t\tdryMass + fuelMass <= 2000;\n\t\t\t\tdryMass <= 1500;\n\t\t\t}\n\t\t}\n\t\tpart engine {\n\t\t\tport speedPort: SpeedPort;\n\t\t\tport torquePort: TorquePort;\n\t\t\tperform powertrainRegion.produceTorque {\n\t\t\t\tin speed = speedPort.speed;\n\t\t\t\tout torque = torquePort.torque;\n\t\t\t}\n\t\t}\n\t\tpart clutch {\n\t\t\tport inTorquePort: ~TorquePort;\n\t\t\tport outTorquePort: TorquePort;\n\t\t\tperform powertrainRegion.transmitTorque {\n\t\t\t\tin torque = inTorquePort.torque;\n\t\t\t\tout torque = outTorquePort.torque;\n\t\t\t}\n\t\t}\n\t\tpart transmission {\n\t\t\tport torquePort: ~TorquePort;\n\t\t\tperform powertrainRegion.receiveTorque {\n\t\t\t\tin torque = torquePort.torque;\n\t\t\t}\n\t\t}\n\t\tinterface engineToClutch connect engine.torquePort to clutch.inTorquePort {\n\t\t\tref flow references powertrainRegion.torqueFlow\n\t\t\t\tfrom source.torque to target.torque;\n\t\t}\n\t\tinterface clutchToTransmission connect clutch.outTorquePort to transmission.torquePort {\n\t\t\tref flow references powertrainRegion.torqueFlow\n\t\t\t\tfrom source.torque to target.torque;\n\t\t}\n\t}\n\taction powertrainRegion {\n\t\taction produceTorque { \n\t\t\tin speed: speed; \n\t\t\tout torque: torque; \n\t\t\tconstraint torqueConstraint references 'Table1_SpeedTorqueCurve';\n\t\t}\n\t\tsuccession flow torqueFlow from produceTorque.torque to transmitTorque.torque;\n\t\taction transmitTorque { \n\t\t\tin torque: torque; \n\t\t\tout torque: torque; \n\t\t}\n\t\tsuccession flow torqueFlow from transmitTorque.torque to receiveTorque.torque;\n\t\taction receiveTorque { \n\t\t\tin torque: torque; \n\t\t}\n\t}\n}",
    "package 'VehicleEngineSystem' {\n\tattribute def EmptyMass;\n\tattribute def FueledMass;\n\tattribute def Torque;\n\tattribute def Speed;\n\tport def ClutchPort {\n\t\tout torque : Torque;\n\t}\n\tport def SpeedPort {\n\t\tin speed : Speed;\n\t}\n\tpart context {\n\t\tpart vehicle {\n\t\t\tproperty emptyMass : EmptyMass <= 1500 kg;\n\t\t\tproperty fueledMass : FueledMass <= 2000 kg;\n\t\t\tpart engine {\n\t\t\t\tport speedPort : SpeedPort;\n\t\t\t\tport clutchPort : ClutchPort;\n\t\t\t\tperform engineOperation.produceTorque {\n\t\t\t\t\tin speed = speedPort.speed;\n\t\t\t\t\tout torque = clutchPort.torque;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tinterface engineToTransmission connect engine.clutchPort to transmission.clutchPort {\n\t\t\tref flow references engineOperation.torqueFlow\n\t\t\t\tfrom source.torque to target.torque;\n\t\t}\n\t\tpart transmission {\n\t\t\tport clutchPort : ~ClutchPort;\n\t\t}\n\t}\n\taction engineOperation {\n\t\taction produceTorque { in speed : Speed; out torque : Torque; }\n\t\tconstraint torqueVsSpeedConstraint applies to produceTorque {\n\t\t\t// Torque varies with speed per performance table specifications\n\t\t}\n\t\tsuccession flow torqueFlow from produceTorque.torque to clutchPort.torque;\n\t\tsuccession flow speedFlow from speedPort.speed to produceTorque.speed;\n\t}\n}",
    "package 'VehicleSystem' {\n\tattribute def Mass;\n\tattribute def Torque;\n\tattribute def Speed;\n\tport def TorquePort {\n\t\tout torque : Torque;\n\t}\n\tport def SpeedPort {\n\t\tout speed : Speed;\n\t}\n\tpart context {\n\t\tpart vehicle {\n\t\t\tattribute curbMass : Mass;\n\t\t\tpart fuelTank {\n\t\t\t\tattribute fuelMassFull : Mass;\n\t\t\t\tattribute fuelMassEmpty : Mass;\n\t\t\t}\n\t\t\tpart engine {\n\t\t\t\tport torquePort : TorquePort;\n\t\t\t\tport speedPort : SpeedPort;\n\t\t\t\tperform powerGeneration.generateTorque {\n\t\t\t\t\tout torque = torquePort.torque;\n\t\t\t\t\tout speed = speedPort.speed;\n\t\t\t\t}\n\t\t\t}\n\t\t\tinterface engineToClutch connect engine.torquePort to clutch.inTorquePort {\n\t\t\t\tref flow references powerGeneration.torqueFlow\n\t\t\t\t\tfrom source.torque to target.torque;\n\t\t\t}\n\t\t\tinterface engineToClutchSpeed connect engine.speedPort to clutch.inSpeedPort {\n\t\t\t\tref flow references powerGeneration.speedFlow\n\t\t\t\t\tfrom source.speed to target.speed;\n\t\t\t}\n\t\t\tpart clutch {\n\t\t\t\tport inTorquePort : ~TorquePort;\n\t\t\t\tport inSpeedPort : ~SpeedPort;\n\t\t\t\tport outTorquePort : TorquePort;\n\t\t\t\tperform powerTransmission.transmitTorque {\n\t\t\t\t\tin torque = inTorquePort.torque;\n\t\t\t\t\tin speed = inSpeedPort.speed;\n\t\t\t\t\tout torque = outTorquePort.torque;\n\t\t\t\t}\n\t\t\t}\n\t\t\tinterface clutchToGearbox connect clutch.outTorquePort to gearbox.inTorquePort {\n\t\t\t\tref flow references powerTransmission.torqueFlow\n\t\t\t\t\tfrom source.torque to target.torque;\n\t\t\t}\n\t\t\tpart gearbox {\n\t\t\t\tport inTorquePort : ~TorquePort;\n\t\t\t}\n\t\t}\n\t}\n\taction powerGeneration {\n\t\taction generateTorque { \n\t\t\tout torque : Torque; \n\t\t\tout speed : Speed; \n\t\t}\n\t}\n\taction powerTransmission {\n\t\taction transmitTorque { \n\t\t\tin torque : Torque; \n\t\t\tin speed : Speed; \n\t\t\tout torque : Torque; \n\t\t}\n\t}\n\taction massConstraints {\n\t\taction checkFullMass { \n\t\t\tin curbMass : Mass; \n\t\t\tin fuelMassFull : Mass; \n\t\t\tconstraint curbMass + fuelMassFull <= 2000; \n\t\t}\n\t\taction checkEmptyMass { \n\t\t\tin curbMass : Mass; \n\t\t\tin fuelMassEmpty : Mass; \n\t\t\tconstraint curbMass + fuelMassEmpty <= 1500; \n\t\t}\n\t}\n}",
    "package 'VehicleDynamicsAnalysis' {\n\tattribute def VehicleAttributes;\n\tattribute def DrivingCycle;\n\tattribute def PowerDemand;\n\tattribute def AccelerationProfile;\n\tattribute def SpeedProfile;\n\tattribute def PositionProfile;\n\tattribute def FuelEconomy;\n\tattribute def EnergyConsumptionTarget;\n\t\n\tport def VehicleAttributesPort {\n\t\tout vehicleAttributes: VehicleAttributes;\n\t}\n\tport def DrivingCyclePort {\n\t\tout drivingCycle: DrivingCycle;\n\t}\n\tport def PowerDemandPort {\n\t\tout powerDemand: PowerDemand;\n\t}\n\tport def AccelerationPort {\n\t\tout acceleration: AccelerationProfile;\n\t}\n\tport def SpeedPort {\n\t\tout speed: SpeedProfile;\n\t}\n\tport def PositionPort {\n\t\tout position: PositionProfile;\n\t}\n\tport def FuelEconomyPort {\n\t\tout fuelEconomy: FuelEconomy;\n\t}\n\tport def TargetPort {\n\t\tout target: EnergyConsumptionTarget;\n\t}\n\t\n\tpart context {\n\t\tpart user {\n\t\t\tport vehicleAttributesPort: VehicleAttributesPort;\n\t\t\tport drivingCyclePort: DrivingCyclePort;\n\t\t\tperform setVehicleAttributes.sendVehicleAttributes {\n\t\t\t\tout vehicleAttributes = vehicleAttributesPort.vehicleAttributes;\n\t\t\t}\n\t\t\tperform setDrivingCycle.sendDrivingCycle {\n\t\t\t\tout drivingCycle = drivingCyclePort.drivingCycle;\n\t\t\t}\n\t\t}\n\t\t\n\t\tinterface userToVehicle connect user.vehicleAttributesPort to vehicle.vehicleAttributesPort {\n\t\t\tref flow references setVehicleAttributes.attributesFlow\n\t\t\t\tfrom source.vehicleAttributes to target.vehicleAttributes;\n\t\t}\n\t\tinterface userToAnalysis connect user.drivingCyclePort to analysisEngine.drivingCyclePort {\n\t\t\tref flow references setDrivingCycle.cycleFlow\n\t\t\t\tfrom source.drivingCycle to target.drivingCycle;\n\t\t}\n\t\t\n\t\tpart vehicle {\n\t\t\tport vehicleAttributesPort: ~VehicleAttributesPort;\n\t\t\tperform calculatePowerDemand.producePowerDemand {\n\t\t\t\tin vehicleAttributes = vehicleAttributesPort.vehicleAttributes;\n\t\t\t\tout powerDemand = powerDemandPort.powerDemand;\n\t\t\t}\n\t\t\tport powerDemandPort: PowerDemandPort;\n\t\t}\n\t\t\n\t\tinterface vehicleToAnalysis connect vehicle.powerDemandPort to analysisEngine.powerDemandPort {\n\t\t\tref flow references calculatePowerDemand.powerDemandFlow\n\t\t\t\tfrom source.powerDemand to target.powerDemand;\n\t\t}\n\t\t\n\t\tpart analysisEngine {\n\t\t\tport drivingCyclePort: ~DrivingCyclePort;\n\t\t\tport powerDemandPort: ~PowerDemandPort;\n\t\t\tperform calculatePowerDemand.analyzePowerDemand {\n\t\t\t\tin drivingCycle = drivingCyclePort.drivingCycle;\n\t\t\t\tin powerDemand = powerDemandPort.powerDemand;\n\t\t\t\tout acceleration = accelerationPort.acceleration;\n\t\t\t\tout speed = speedPort.speed;\n\t\t\t\tout position = positionPort.position;\n\t\t\t}\n\t\t\tport accelerationPort: AccelerationPort;\n\t\t\tport speedPort: SpeedPort;\n\t\t\tport positionPort: PositionPort;\n\t\t}\n\t\t\n\t\tinterface analysisToFuel connect analysisEngine.positionPort to fuelCalculator.positionPort {\n\t\t\tref flow references calculatePosition.positionFlow\n\t\t\t\tfrom source.position to target.position;\n\t\t}\n\t\tinterface analysisToFuel2 connect analysisEngine.speedPort to fuelCalculator.speedPort {\n\t\t\tref flow references calculateSpeed.speedFlow\n\t\t\t\tfrom source.speed to target.speed;\n\t\t}\n\t\t\n\t\tpart fuelCalculator {\n\t\t\tport positionPort: ~PositionPort;\n\t\t\tport speedPort: ~SpeedPort;\n\t\t\tport vehicleAttributesPort: ~VehicleAttributesPort;\n\t\t\tperform computeFuelEconomy.calculateEconomy {\n\t\t\t\tin position = positionPort.position;\n\t\t\t\tin speed = speedPort.speed;\n\t\t\t\tin vehicleAttributes = vehicleAttributesPort.vehicleAttributes;\n\t\t\t\tout fuelEconomy = fuelEconomyPort.fuelEconomy;\n\t\t\t}\n\t\t\tport fuelEconomyPort: FuelEconomyPort;\n\t\t}\n\t\t\n\t\tinterface fuelToCompliance connect fuelCalculator.fuelEconomyPort to complianceChecker.fuelEconomyPort {\n\t\t\tref flow references computeFuelEconomy.economyFlow\n\t\t\t\tfrom source.fuelEconomy to target.fuelEconomy;\n\t\t}\n\t\t\n\t\tpart complianceChecker {\n\t\t\tport fuelEconomyPort: ~FuelEconomyPort;\n\t\t\tport targetPort: TargetPort;\n\t\t\tperform verifyCompliance.checkTarget {\n\t\t\t\tin fuelEconomy = fuelEconomyPort.fuelEconomy;\n\t\t\t\tin target = targetPort.target;\n\t\t\t\tout result: Boolean;\n\t\t\t}\n\t\t}\n\t}\n\t\n\taction setVehicleAttributes {\n\t\taction sendVehicleAttributes { out vehicleAttributes: VehicleAttributes; }\n\t}\n\t\n\taction setDrivingCycle {\n\t\taction sendDrivingCycle { out drivingCycle: DrivingCycle; }\n\t}\n\t\n\taction calculatePowerDemand {\n\t\tsuccession flow attributesFlow from sendVehicleAttributes.vehicleAttributes to analyzePowerDemand.vehicleAttributes;\n\t\tsuccession flow powerDemandFlow from analyzePowerDemand.powerDemand to calculateEconomy.vehicleAttributes;\n\t\taction analyzePowerDemand { \n\t\t\tin drivingCycle: DrivingCycle; \n\t\t\tin powerDemand: PowerDemand; \n\t\t\tout acceleration: AccelerationProfile; \n\t\t\tout speed: SpeedProfile; \n\t\t\tout position: PositionProfile; \n\t\t}\n\t}\n\t\n\taction calculateAcceleration {\n\t\tsuccession flow accelerationFlow from analyzePowerDemand.acceleration to ...;\n\t}\n\t\n\taction calculateSpeed {\n\t\tsuccession flow speedFlow from analyzePowerDemand.speed to calculateSpeed.speed;\n\t}\n\t\n\taction calculatePosition {\n\t\tsuccession flow positionFlow from analyzePowerDemand.position to calculatePosition.position;\n\t}\n\t\n\taction computeFuelEconomy {\n\t\tsuccession flow positionFlow from calculatePosition.position to calculateEconomy.position;\n\t\tsuccession flow speedFlow from calculateSpeed.speed to calculateEconomy.speed;\n\t\taction calculateEconomy { \n\t\t\tin position: PositionProfile; \n\t\t\tin speed: SpeedProfile; \n\t\t\tin vehicleAttributes: VehicleAttributes; \n\t\t\tout fuelEconomy: FuelEconomy; \n\t\t}\n\t}\n\t\n\taction verifyCompliance {\n\t\tsuccession flow economyFlow from calculateEconomy.fuelEconomy to checkTarget.fuelEconomy;\n\t\tsuccession flow targetFlow from sendTarget.target to checkTarget.target;\n\t\taction checkTarget { \n\t\t\tin fuelEconomy: FuelEconomy; \n\t\t\tin target: EnergyConsumptionTarget; \n\t\t\tout result: Boolean; \n\t\t}\n\t}\n}\n–––––",
    "package 'VehicleFuelEconomySimulation' {\n\tattribute def CurbWeight;\n\tattribute def Load;\n\tattribute def WheelDiameter;\n\tattribute def TransmissionEfficiency;\n\tattribute def FuelEconomy;\n\tattribute def DrivingScenario;\n\tattribute def WheelPower;\n\tattribute def Acceleration;\n\tattribute def EnergyConsumption;\n\tattribute def EnginePowerDemand;\n\tport def ScenarioPort {\n\t\tout drivingScenario: DrivingScenario;\n\t}\n\tport def FuelEconomyPort {\n\t\tout fuelEconomy: FuelEconomy;\n\t}\n\tport def ParameterPort {\n\t\tin curbWeight: CurbWeight;\n\t\tin load: Load;\n\t\tin wheelDiameter: WheelDiameter;\n\t\tin transmissionEfficiency: TransmissionEfficiency;\n\t}\n\tpart context {\n\t\tpart user {\n\t\t\tport scenarioPort: ScenarioPort;\n\t\t\tport fuelEconomyPort: ~FuelEconomyPort;\n\t\t\tperform simulationRequest.sendDrivingScenario {\n\t\t\t\tout drivingScenario = scenarioPort.drivingScenario;\n\t\t\t}\n\t\t\tperform resultReception.receiveFuelEconomy {\n\t\t\t\tin fuelEconomy = fuelEconomyPort.fuelEconomy;\n\t\t\t}\n\t\t}\n\t\tinterface userToSimulation connect user.scenarioPort to simulation.scenarioPort {\n\t\t\tref flow references simulationRequest.scenarioFlow\n\t\t\t\tfrom source.drivingScenario to target.drivingScenario;\n\t\t}\n\t\tinterface simulationToUser connect simulation.fuelEconomyPort to user.fuelEconomyPort {\n\t\t\tref flow references determineFuelEconomy.fuelEconomyFlow\n\t\t\t\tfrom source.fuelEconomy to target.fuelEconomy;\n\t\t}\n\t\tpart simulation {\n\t\t\tport scenarioPort: ~ScenarioPort;\n\t\t\tport fuelEconomyPort: FuelEconomyPort;\n\t\t\tperform drivingScenarioProcessing.setDrivingScenario {\n\t\t\t\tin drivingScenario = scenarioPort.drivingScenario;\n\t\t\t}\n\t\t\tperform drivingScenarioProcessing.calculateWheelPower {\n\t\t\t\tin drivingScenario = scenarioPort.drivingScenario;\n\t\t\t\tin curbWeight = parameterPort.curbWeight;\n\t\t\t\tin load = parameterPort.load;\n\t\t\t\tin wheelDiameter = parameterPort.wheelDiameter;\n\t\t\t\tout wheelPower = wheelPowerPort.wheelPower;\n\t\t\t}\n\t\t\tport wheelPowerPort: ~WheelPowerPort;\n\t\t\tperform vehicleDynamics.applyVehicleDynamics {\n\t\t\t\tin wheelPower = wheelPowerPort.wheelPower;\n\t\t\t\tin transmissionEfficiency = parameterPort.transmissionEfficiency;\n\t\t\t\tout acceleration = accelerationPort.acceleration;\n\t\t\t\tout energyConsumption = energyConsumptionPort.energyConsumption;\n\t\t\t}\n\t\t\tport accelerationPort: ~AccelerationPort;\n\t\t\tport energyConsumptionPort: ~EnergyConsumptionPort;\n\t\t\tperform engineAnalysis.estimateEnginePower {\n\t\t\t\tin energyConsumption = energyConsumptionPort.energyConsumption;\n\t\t\t\tout enginePowerDemand = enginePowerPort.enginePowerDemand;\n\t\t\t}\n\t\t\tport enginePowerPort: ~EnginePowerPort;\n\t\t\tperform fuelEconomyAnalysis.determineFuelEconomy {\n\t\t\t\tin enginePowerDemand = enginePowerPort.enginePowerDemand;\n\t\t\t\tin curbWeight = parameterPort.curbWeight;\n\t\t\t\tin load = parameterPort.load;\n\t\t\t\tin wheelDiameter = parameterPort.wheelDiameter;\n\t\t\t\tin transmissionEfficiency = parameterPort.transmissionEfficiency;\n\t\t\t\tout fuelEconomy = fuelEconomyPort.fuelEconomy;\n\t\t\t}\n\t\t}\n\t}\n\taction drivingScenarioProcessing {\n\t\taction sendDrivingScenario { out drivingScenario: DrivingScenario; }\n\t\tsuccession flow scenarioFlow from sendDrivingScenario.drivingScenario to setDrivingScenario.drivingScenario;\n\t\taction setDrivingScenario { in drivingScenario: DrivingScenario; }\n\t}\n\taction vehicleDynamics {\n\t\taction calculateWheelPower { in drivingScenario; in curbWeight; in load; in wheelDiameter; out wheelPower: WheelPower; }\n\t\tsuccession flow wheelPowerFlow from calculateWheelPower.wheelPower to applyVehicleDynamics.wheelPower;\n\t\taction applyVehicleDynamics { in wheelPower: WheelPower; in transmissionEfficiency; out acceleration: Acceleration; out energyConsumption: EnergyConsumption; }\n\t}\n\taction engineAnalysis {\n\t\taction estimateEnginePower { in energyConsumption: EnergyConsumption; out enginePowerDemand: EnginePowerDemand; }\n\t\tsuccession flow enginePowerFlow from estimateEnginePower.enginePowerDemand to determineFuelEconomy.enginePowerDemand;\n\t}\n\taction fuelEconomyAnalysis {\n\t\taction determineFuelEconomy { in enginePowerDemand: EnginePowerDemand; in curbWeight; in load; in wheelDiameter; in transmissionEfficiency; out fuelEconomy: FuelEconomy; }\n\t}\n}",
    "package 'EngineSelection' {\n\tattribute def Power;\n\tattribute def Mass;\n\tattribute def Efficiency;\n\tattribute def Cost;\n\tattribute def EvaluationScore;\n\tattribute def EngineType;\n\tport def KPIPort {\n\t\tout power: Power;\n\t\tout mass: Mass;\n\t\tout efficiency: Efficiency;\n\t\tout cost: Cost;\n\t}\n\tport def EvaluationPort {\n\t\tout evaluationScore: EvaluationScore;\n\t}\n\tpart context {\n\t\tpart fourCylinderEngine {\n\t\t\tport kpiPort: KPIPort;\n\t\t\tperform aggregateFourCylinderKPIs.sendFourKPIs {\n\t\t\t\tout power = kpiPort.power;\n\t\t\t\tout mass = kpiPort.mass;\n\t\t\t\tout efficiency = kpiPort.efficiency;\n\t\t\t\tout cost = kpiPort.cost;\n\t\t\t}\n\t\t}\n\t\tpart sixCylinderEngine {\n\t\t\tport kpiPort: KPIPort;\n\t\t\tperform aggregateSixCylinderKPIs.sendSixKPIs {\n\t\t\t\tout power = kpiPort.power;\n\t\t\t\tout mass = kpiPort.mass;\n\t\t\t\tout efficiency = kpiPort.efficiency;\n\t\t\t\tout cost = kpiPort.cost;\n\t\t\t}\n\t\t}\n\t\tinterface fourEngineToEvaluation connect fourCylinderEngine.kpiPort to evaluationFunction.kpiInputPort {\n\t\t\tref flow references aggregateFourCylinderKPIs.sendFourKPIs\n\t\t\t\tfrom source.power to target.fourPower;\n\t\t\tref flow references aggregateFourCylinderKPIs.sendFourKPIs\n\t\t\t\tfrom source.mass to target.fourMass;\n\t\t\tref flow references aggregateFourCylinderKPIs.sendFourKPIs\n\t\t\t\tfrom source.efficiency to target.fourEfficiency;\n\t\t\tref flow references aggregateFourCylinderKPIs.sendFourKPIs\n\t\t\t\tfrom source.cost to target.fourCost;\n\t\t}\n\t\tinterface sixEngineToEvaluation connect sixCylinderEngine.kpiPort to evaluationFunction.kpiInputPort {\n\t\t\tref flow references aggregateSixCylinderKPIs.sendSixKPIs\n\t\t\t\tfrom source.power to target.sixPower;\n\t\t\tref flow references aggregateSixCylinderKPIs.sendSixKPIs\n\t\t\t\tfrom source.mass to target.sixMass;\n\t\t\tref flow references aggregateSixCylinderKPIs.sendSixKPIs\n\t\t\t\tfrom source.efficiency to target.sixEfficiency;\n\t\t\tref flow references aggregateSixCylinderKPIs.sendSixKPIs\n\t\t\t\tfrom source.cost to target.sixCost;\n\t\t}\n\t\tpart evaluationFunction {\n\t\t\tport kpiInputPort: ~KPIPort;\n\t\t\tport evaluationOutputPort: EvaluationPort;\n\t\t\tperform calculateEvaluation.evaluateEngines {\n\t\t\t\tin fourPower = kpiInputPort.power;\n\t\t\t\tin fourMass = kpiInputPort.mass;\n\t\t\t\tin fourEfficiency = kpiInputPort.efficiency;\n\t\t\t\tin fourCost = kpiInputPort.cost;\n\t\t\t\tin sixPower = kpiInputPort.power;\n\t\t\t\tin sixMass = kpiInputPort.mass;\n\t\t\t\tin sixEfficiency = kpiInputPort.efficiency;\n\t\t\t\tin sixCost = kpiInputPort.cost;\n\t\t\t\tout evaluationScore = evaluationOutputPort.evaluationScore;\n\t\t\t}\n\t\t}\n\t\tinterface evaluationToRecommendation connect evaluationFunction.evaluationOutputPort to recommendation.evaluationInputPort {\n\t\t\tref flow references calculateEvaluation.evaluateEngines\n\t\t\t\tfrom source.evaluationScore to target.evaluationScore;\n\t\t}\n\t\tpart recommendation {\n\t\t\tport evaluationInputPort: ~EvaluationPort;\n\t\t\tport selectionOutputPort: Port {\n\t\t\t\tout selectedEngine: EngineType;\n\t\t\t}\n\t\t\tperform recommendEngine.selectOptimalEngine {\n\t\t\t\tin evaluationScore = evaluationInputPort.evaluationScore;\n\t\t\t\tout selectedEngine = selectionOutputPort.selectedEngine;\n\t\t\t}\n\t\t}\n\t}\n\taction calculateEvaluation {\n\t\taction evaluateEngines {\n\t\t\tin fourPower: Power;\n\t\t\tin fourMass: Mass;\n\t\t\tin fourEfficiency: Efficiency;\n\t\t\tin fourCost: Cost;\n\t\t\tin sixPower: Power;\n\t\t\tin sixMass: Mass;\n\t\t\tin sixEfficiency: Efficiency;\n\t\t\tin sixCost: Cost;\n\t\t\tout evaluationScore: EvaluationScore;\n\t\t}\n\t}\n\taction recommendEngine {\n\t\taction selectOptimalEngine {\n\t\t\tin evaluationScore: EvaluationScore;\n\t\t\tout selectedEngine: EngineType;\n\t\t}\n\t}\n\taction aggregateFourCylinderKPIs {\n\t\taction sendFourKPIs {\n\t\t\tout power: Power;\n\t\t\tout mass: Mass;\n\t\t\tout efficiency: Efficiency;\n\t\t\tout cost: Cost;\n\t\t}\n\t}\n\taction aggregateSixCylinderKPIs {\n\t\taction sendSixKPIs {\n\t\t\tout power: Power;\n\t\t\tout mass: Mass;\n\t\t\tout efficiency: Efficiency;\n\t\t\tout cost: Cost;\n\t\t}\n\t}\n}",
    "package 'VehicleWeightCheck' {\n\tattribute def CurbWeight;\n\tattribute def ProcessedData;\n\tattribute def EvaluationResult;\n\tport def WeightDataPort {\n\t\tout curbWeight : CurbWeight;\n\t}\n\tport def ProcessedDataPort {\n\t\tout processedData : ProcessedData;\n\t}\n\tport def EvaluationPort {\n\t\tout evaluationResult : EvaluationResult;\n\t}\n\tpart context {\n\t\tpart vehicle {\n\t\t\tport weightDataPort: WeightDataPort;\n\t\t\tperform evaluateCurbWeightProcess.sendCurbWeight {\n\t\t\t\tout curbWeight = weightDataPort.curbWeight;\n\t\t\t}\n\t\t}\n\t\tinterface vehicleToTestingSystem connect vehicle.weightDataPort to testingSystem.weightDataPort {\n\t\t\tref flow references evaluateCurbWeightProcess.dataCollectionFlow\n\t\t\t\tfrom source.curbWeight to target.curbWeight;\n\t\t}\n\t\tpart testingSystem {\n\t\t\tport weightDataPort: ~WeightDataPort;\n\t\t\tport processedDataPort: ProcessedDataPort;\n\t\t\tperform evaluateCurbWeightProcess.processWeightData {\n\t\t\t\tin curbWeight = weightDataPort.curbWeight;\n\t\t\t\tout processedData = processedDataPort.processedData;\n\t\t\t}\n\t\t}\n\t\tinterface testingSystemToEvaluator connect testingSystem.processedDataPort to evaluator.processedDataPort {\n\t\t\tref flow references evaluateCurbWeightProcess.dataProcessingFlow\n\t\t\t\tfrom source.processedData to target.processedData;\n\t\t}\n\t\tpart evaluator {\n\t\t\tport processedDataPort: ~ProcessedDataPort;\n\t\t\tport evaluationPort: EvaluationPort;\n\t\t\tperform evaluateCurbWeightProcess.evaluateCompliance {\n\t\t\t\tin processedData = processedDataPort.processedData;\n\t\t\t\tout evaluationResult = evaluationPort.evaluationResult;\n\t\t\t}\n\t\t}\n\t}\n\taction evaluateCurbWeightProcess {\n\t\taction sendCurbWeight { out curbWeight: CurbWeight; }\n\t\tsuccession flow dataCollectionFlow from sendCurbWeight.curbWeight to processWeightData.curbWeight;\n\t\taction processWeightData { in curbWeight; out processedData: ProcessedData; }\n\t\tsuccession flow dataProcessingFlow from processWeightData.processedData to evaluateCompliance.processedData;\n\t\taction evaluateCompliance { in processedData: ProcessedData; out evaluationResult: EvaluationResult; }\n\t}\n}",
    "package 'VehicleMassVerification' {  \n\tattribute def vehicleMass;  \n\tattribute def measuredMass;  \n\tattribute def qualificationStatus;  \n\tport def VehicleMassPort {  \n\t\tout vehicleMass : vehicleMass;  \n\t}  \n\tport def MeasuredMassPort {  \n\t\tout measuredMass : measuredMass;  \n\t}  \n\tport def QualificationStatusPort {  \n\t\tout qualificationStatus : qualificationStatus;  \n\t}  \n\tpart context {  \n\t\tpart vehicle {  \n\t\t\tport vehicleMassPort : VehicleMassPort;  \n\t\t\tperform measureAndVerifyMass.sendVehicleMass {  \n\t\t\t\tout vehicleMass = vehicleMassPort.vehicleMass;  \n\t\t\t}  \n\t\t}  \n\t\tinterface vehicleToWeighing connect vehicle.vehicleMassPort to weighingEquipment.vehicleMassPort {  \n\t\t\tref flow references measureAndVerifyMass.massFlow  \n\t\t\t\tfrom source.vehicleMass to target.vehicleMass;  \n\t\t}  \n\t\tpart weighingEquipment {  \n\t\t\tport vehicleMassPort : ~VehicleMassPort;  \n\t\t\tperform measureAndVerifyMass.measureVehicleMass {  \n\t\t\t\tin vehicleMass = vehicleMassPort.vehicleMass;  \n\t\t\t\tout measuredMass = measuredMassPort.measuredMass;  \n\t\t\t}  \n\t\t\tport measuredMassPort : MeasuredMassPort;  \n\t\t}  \n\t\tinterface weighingToVerification connect weighingEquipment.measuredMassPort to massVerificationUnit.measuredMassPort {  \n\t\t\tref flow references measureAndVerifyMass.measuredMassFlow  \n\t\t\t\tfrom source.measuredMass to target.measuredMass;  \n\t\t}  \n\t\tpart massVerificationUnit {  \n\t\t\tport measuredMassPort : ~MeasuredMassPort;  \n\t\t\tperform measureAndVerifyMass.evaluateMass {  \n\t\t\t\tin measuredMass = measuredMassPort.measuredMass;  \n\t\t\t\tout qualificationStatus = qualificationStatusPort.qualificationStatus;  \n\t\t\t}  \n\t\t\tport qualificationStatusPort : QualificationStatusPort;  \n\t\t}  \n\t}  \n\taction measureAndVerifyMass {  \n\t\taction sendVehicleMass { out vehicleMass : vehicleMass; }  \n\t\tsuccession flow massFlow from sendVehicleMass.vehicleMass to measureVehicleMass.vehicleMass;  \n\t\taction measureVehicleMass { in vehicleMass : vehicleMass; out measuredMass : measuredMass; }  \n\t\tsuccession flow measuredMassFlow from measureVehicleMass.measuredMass to evaluateMass.measuredMass;  \n\t\taction evaluateMass { in measuredMass : measuredMass; out qualificationStatus : qualificationStatus; }  \n\t}  \n}",
    "package 'TransportationSystem' {\n\tattribute def EntryExitCmd;\n\tattribute def EnvironmentalData;\n\tattribute def InfrastructureSignal;\n\tport def EntryExitCmdPort {\n\t\tout entryExitCmd : EntryExitCmd;\n\t}\n\tport def EnvironmentalDataPort {\n\t\tin environmentalData : EnvironmentalData;\n\t}\n\tport def InfrastructureSignalPort {\n\t\tout infrastructureSignal : InfrastructureSignal;\n\t}\n\tpart context {\n\t\tpart user {\n\t\t\tport entryExitCmdPort: EntryExitCmdPort;\n\t\t\tperform transportationTask.sendEntryExitCmd {\n\t\t\t\tout entryExitCmd = entryExitCmdPort.entryExitCmd;\n\t\t\t}\n\t\t}\n\t\tinterface userToVehicle connect user.entryExitCmdPort to vehicle.entryExitCmdPort {\n\t\t\tref flow references transportationTask.entryExitFlow\n\t\t\t\tfrom source.entryExitCmd to target.entryExitCmd;\n\t\t}\n\t\tpart vehicle {\n\t\t\tport entryExitCmdPort: ~EntryExitCmdPort;\n\t\t\tport environmentalDataPort: EnvironmentalDataPort;\n\t\t\tport infrastructureSignalPort: InfrastructureSignalPort;\n\t\t\tperform transportationTask.handleEntryExit {\n\t\t\t\tin entryExitCmd = entryExitCmdPort.entryExitCmd;\n\t\t\t\tout safetyStatus = ensureSafety.safetyStatus;\n\t\t\t}\n\t\t\tperform transportationTask.monitorEnvironment {\n\t\t\t\tin environmentalData = environmentalDataPort.environmentalData;\n\t\t\t\tout adjustedParameters = adjustForEnvironment.adjustedParameters;\n\t\t\t}\n\t\t\tperform transportationTask.adjustForEnvironment {\n\t\t\t\tin environmentalData = monitorEnvironment.adjustedParameters;\n\t\t\t\tout light = provideComfort.light;\n\t\t\t}\n\t\t\tperform transportationTask.ensureSafety {\n\t\t\t\tin safetyInput = handleEntryExit.safetyStatus;\n\t\t\t\tout infrastructureSignal = infrastructureSignalPort.infrastructureSignal;\n\t\t\t}\n\t\t\tperform transportationTask.provideComfort {\n\t\t\t\tin comfortInput = adjustForEnvironment.light;\n\t\t\t}\n\t\t}\n\t\tinterface vehicleToInfrastructure connect vehicle.infrastructureSignalPort to infrastructure.infrastructureSignalPort {\n\t\t\tref flow references transportationTask.infrastructureFlow\n\t\t\t\tfrom source.infrastructureSignal to target.infrastructureSignal;\n\t\t}\n\t\tpart infrastructure {\n\t\t\tport infrastructureSignalPort: ~InfrastructureSignalPort;\n\t\t\tperform transportationTask.supportInfrastructure {\n\t\t\t\tin infrastructureSignal = infrastructureSignalPort.infrastructureSignal;\n\t\t\t}\n\t\t}\n\t\tpart environment {\n\t\t\tport environmentalDataPort: ~EnvironmentalDataPort;\n\t\t\tperform transportationTask.provideEnvironmentalData {\n\t\t\t\tout environmentalData = environmentalDataPort.environmentalData;\n\t\t\t}\n\t\t}\n\t}\n\taction transportationTask {\n\t\taction sendEntryExitCmd { out entryExitCmd: EntryExitCmd; }\n\t\tsuccession flow entryExitFlow from sendEntryExitCmd.entryExitCmd to handleEntryExit.entryExitCmd;\n\t\taction handleEntryExit { in entryExitCmd: EntryExitCmd; out safetyStatus: Boolean; }\n\t\taction provideEnvironmentalData { out environmentalData: EnvironmentalData; }\n\t\tsuccession flow environmentalFlow from provideEnvironmentalData.environmentalData to monitorEnvironment.environmentalData;\n\t\taction monitorEnvironment { in environmentalData: EnvironmentalData; out adjustedParameters: EnvironmentalData; }\n\t\tsuccession flow adjustmentFlow from monitorEnvironment.adjustedParameters to adjustForEnvironment.adjustedParameters;\n\t\taction adjustForEnvironment { in environmentalData: EnvironmentalData; out light: Light; }\n\t\tsuccession flow comfortFlow from adjustForEnvironment.light to provideComfort.light;\n\t\taction provideComfort { in light: Light; }\n\t\tsuccession flow safetyFlow from handleEntryExit.safetyStatus to ensureSafety.safetyInput;\n\t\taction ensureSafety { in safetyInput: Boolean; out infrastructureSignal: InfrastructureSignal; }\n\t\tsuccession flow infrastructureFlow from ensureSafety.infrastructureSignal to supportInfrastructure.infrastructureSignal;\n\t\taction supportInfrastructure { in infrastructureSignal: InfrastructureSignal; }\n\t}\n}",
    "package 'TransportationSystem' {  \n\tattribute def TransportationStatus;  \n\tattribute def FuelLevel;  \n\tport def CommandPort {  \n\t\tout command : TransportationStatus;  \n\t}  \n\tport def FuelPort {  \n\t\tout fuel : FuelLevel;  \n\t}  \n\tport def ExitPort {  \n\t\tout status : TransportationStatus;  \n\t}  \n\tpart context {  \n\t\tpart driver {  \n\t\t\tport commandPort: CommandPort;  \n\t\t\tperform transportationProcess.sendStartCommand {  \n\t\t\t\tout command = commandPort.command;  \n\t\t\t}  \n\t\t\tperform transportationProcess.sendRefuelCommand {  \n\t\t\t\tout command = commandPort.command;  \n\t\t\t}  \n\t\t}  \n\t\tpart passenger1 {  \n\t\t\tport entryExitPort: ~ExitPort;  \n\t\t\tperform transportationProcess.enterVehicle {  \n\t\t\t\tout status = entryExitPort.status;  \n\t\t\t}  \n\t\t}  \n\t\tpart passenger2 {  \n\t\t\tport entryExitPort: ~ExitPort;  \n\t\t\tperform transportationProcess.enterVehicle {  \n\t\t\t\tout status = entryExitPort.status;  \n\t\t\t}  \n\t\t}  \n\t\tpart passenger3 {  \n\t\t\tport entryExitPort: ~ExitPort;  \n\t\t\tperform transportationProcess.enterVehicle {  \n\t\t\t\tout status = entryExitPort.status;  \n\t\t\t}  \n\t\t}  \n\t\tpart passenger4 {  \n\t\t\tport entryExitPort: ~ExitPort;  \n\t\t\tperform transportationProcess.enterVehicle {  \n\t\t\t\tout status = entryExitPort.status;  \n\t\t\t}  \n\t\t}  \n\t\tpart vehicle {  \n\t\t\tport commandPort: ~CommandPort;  \n\t\t\tport fuelPort: FuelPort;  \n\t\t\tport entryExitPort: ~ExitPort;  \n\t\t\tperform transportationProcess.operateVehicle {  \n\t\t\t\tin command = commandPort.command;  \n\t\t\t\tin environment = environmentalContext.environmentalConditions;  \n\t\t\t\tout fuel = fuelPort.fuel;  \n\t\t\t\tout status = entryExitPort.status;  \n\t\t\t}  \n\t\t\tperform transportationProcess.refuelVehicle {  \n\t\t\t\tin fuelLevel = fuelPort.fuel;  \n\t\t\t\tout command = commandPort.command;  \n\t\t\t}  \n\t\t}  \n\t\tpart environment {  \n\t\t\tport commandPort: ~CommandPort;  \n\t\t\tperform transportationProcess.applyEnvironmentalConditions {  \n\t\t\t\tout command = commandPort.command;  \n\t\t\t}  \n\t\t}  \n\t\tpart gasStation {  \n\t\t\tport fuelPort: ~FuelPort;  \n\t\t\tperform transportationProcess.provideFuel {  \n\t\t\t\tout fuel = fuelPort.fuel;  \n\t\t\t}  \n\t\t}  \n\t}  \n\taction transportationProcess {  \n\t\taction sendStartCommand { out command: TransportationStatus; }  \n\t\taction enterVehicle { out status: TransportationStatus; }  \n\t\tsuccession flow startFlow from sendStartCommand.command to operateVehicle.command;  \n\t\taction operateVehicle {  \n\t\t\tin command: TransportationStatus;  \n\t\t\tin environmentalConditions: TransportationStatus;  \n\t\t\tout fuel: FuelLevel;  \n\t\t\tout status: TransportationStatus;  \n\t\t}  \n\t\tsuccession flow fuelFlow from operateVehicle.fuel to refuelVehicle.fuelLevel;  \n\t\taction refuelVehicle {  \n\t\t\tin fuelLevel: FuelLevel;  \n\t\t\tout command: TransportationStatus;  \n\t\t}  \n\t\tsuccession flow refuelFlow from refuelVehicle.command to provideFuel.fuel;  \n\t\taction provideFuel { out fuel: FuelLevel; }  \n\t\taction applyEnvironmentalConditions { out command: TransportationStatus; }  \n\t\tsuccession flow envFlow from applyEnvironmentalConditions.command to operateVehicle.environmentalConditions;  \n\t\taction exitVehicle { in status: TransportationStatus; }  \n\t}  \n}",
    "package 'VehicleConfiguration' {\n\tenumeration def EngineType { fourCylinder, sixCylinder; }\n\tenumeration def TransmissionType { manual, automatic; }\n\tenumeration def CylinderDiameter { small, large; }\n\n\tpart context {\n\t\tpart user {\n\t\t\tperform configureVehicle.selectEngineType;\n\t\t\tperform configureVehicle.selectCylinderDiameter;\n\t\t\tperform configureVehicle.selectTransmissionType;\n\t\t}\n\t\tinterface userToEngine connect user.engineTypePort to engine.engineTypePort {\n\t\t\tref flow references configureVehicle.engineTypeFlow\n\t\t\t\tfrom source.engineType to target.engineType;\n\t\t}\n\t\tinterface userToCylinderDiameter connect user.cylinderDiameterPort to engine.cylinderDiameterPort {\n\t\t\tref flow references configureVehicle.cylinderDiameterFlow\n\t\t\t\tfrom source.cylinderDiameter to target.cylinderDiameter;\n\t\t}\n\t\tinterface userToTransmission connect user.transmissionTypePort to transmission.transmissionTypePort {\n\t\t\tref flow references configureVehicle.transmissionTypeFlow\n\t\t\t\tfrom source.transmissionType to target.transmissionType;\n\t\t}\n\t\tpart engine {\n\t\t\tport engineTypePort: out EngineType;\n\t\t\tport cylinderDiameterPort: out CylinderDiameter;\n\t\t}\n\t\tpart transmission {\n\t\t\tport transmissionTypePort: out TransmissionType;\n\t\t}\n\t}\n\taction configureVehicle {\n\t\taction selectEngineType { out engineType: EngineType; }\n\t\taction selectCylinderDiameter { out cylinderDiameter: CylinderDiameter; }\n\t\taction selectTransmissionType { out transmissionType: TransmissionType; }\n\t\taction checkEngineTransmissionConstraint {\n\t\t\tin engineType: EngineType;\n\t\t\tin transmissionType: TransmissionType;\n\t\t\tconstraint engineType and transmissionType satisfy:\n\t\t\t\t(engineType = fourCylinder and transmissionType = manual) or\n\t\t\t\t(engineType = sixCylinder and transmissionType = automatic);\n\t\t}\n\t\tsuccession flow engineTypeFlow from selectEngineType.engineType to checkEngineTransmissionConstraint.engineType;\n\t\tsuccession flow transmissionTypeFlow from selectTransmissionType.transmissionType to checkEngineTransmissionConstraint.transmissionType;\n\t}\n}",
    "package 'ConfigurableEngine' {\n\tenumeration CylinderDiameter {\n\t\t70mm;\n\t\t100mm;\n\t}\n\tattribute def CylinderDiameter;\n\tpart def Cylinder {\n\t\tattribute diameter: CylinderDiameter;\n\t}\n\tpart def Engine {\n\t\tpart cylinders: Cylinder [4..6];\n\t}\n\tpart context {\n\t\tpart fourCylinderEngine: Engine {\n\t\t\tcylinders: [4];\n\t\t}\n\t\tpart sixCylinderEngine: Engine {\n\t\t\tcylinders: [6];\n\t\t}\n\t\tpart cylinderInstance: Cylinder {\n\t\t\tdiameter: CylinderDiameter;\n\t\t}\n\t}\n}",
    "package 'AutomotiveConfiguration' {\n\tattribute def CylinderCount;\n\tenum CylinderCount {\n\t\t'4-cylinder',\n\t\t'6-cylinder'\n\t}\n\tattribute def CylinderDiameter;\n\tenum CylinderDiameter {\n\t\t'70mm',\n\t\t'100mm'\n\t}\n\tattribute def GearboxType;\n\tenum GearboxType {\n\t\t'manual',\n\t\t'automatic'\n\t}\n\tpart context {\n\t\tpart vehicle {\n\t\t\tpart engine {\n\t\t\t\tproperty cylinderCount: CylinderCount;\n\t\t\t\tproperty cylinderDiameter: CylinderDiameter;\n\t\t\t}\n\t\t\tpart transmission {\n\t\t\t\tproperty gearboxType: GearboxType;\n\t\t\t}\n\t\t\tconstraint configConstraint {\n\t\t\t\tderive from engine.cylinderCount and transmission.gearboxType;\n\t\t\t\tif engine.cylinderCount == '4-cylinder' then transmission.gearboxType == 'manual';\n\t\t\t\tif engine.cylinderCount == '6-cylinder' then transmission.gearboxType == 'automatic';\n\t\t\t}\n\t\t}\n\t}\n\taction configuration {\n\t\taction selectEngine {\n\t\t\tout cylinderCount: CylinderCount;\n\t\t\tout cylinderDiameter: CylinderDiameter;\n\t\t}\n\t\taction selectTransmission {\n\t\t\tin engineCylinderCount: CylinderCount;\n\t\t\tout gearboxType: GearboxType;\n\t\t}\n\t\tsuccession flow from selectEngine.cylinderCount to selectTransmission.engineCylinderCount {\n\t\t\tconstraint if selectEngine.cylinderCount == '4-cylinder' then selectTransmission.gearboxType == 'manual';\n\t\t\tconstraint if selectEngine.cylinderCount == '6-cylinder' then selectTransmission.gearboxType == 'automatic';\n\t\t}\n\t}\n}",
    "package 'SystemAssembly' {\n\tattribute def MessageFormat;\n\tattribute def DataFormat;\n\tport def ComputerInterface {\n\t\tin messageFormat : MessageFormat;\n\t\tin dataFormat : DataFormat;\n\t}\n\tport def StorageInterface {\n\t\tin dataFormat : DataFormat;\n\t\tin messageFormat : MessageFormat;\n\t}\n\tpart context {\n\t\tpart computerSubSystem {\n\t\t\tport computerPort: ComputerInterface;\n\t\t\tperform softwareIntegration.processInformation {\n\t\t\t\tin messageFormat = computerPort.messageFormat;\n\t\t\t\tin dataFormat = computerPort.dataFormat;\n\t\t\t\tout processedData;\n\t\t\t}\n\t\t}\n\t\tinterface computerToSoftware connect computerPort.messageFormat to softwareDef.messageFormatDef {\n\t\t\tref flow references softwareIntegration.formatFlow;\n\t\t}\n\t\tinterface computerToSoftwareData connect computerPort.dataFormat to softwareDef.dataFormatDef {\n\t\t\tref flow references softwareIntegration.dataFlow;\n\t\t}\n\t\tpart storageSubSystem {\n\t\t\tport storagePort: StorageInterface;\n\t\t\tperform softwareIntegration.storeData {\n\t\t\t\tin dataFormat = storagePort.dataFormat;\n\t\t\t\tin messageFormat = storagePort.messageFormat;\n\t\t\t}\n\t\t}\n\t\tinterface storageToSoftwareData connect storagePort.dataFormat to softwareDef.dataFormatDef {\n\t\t\tref flow references softwareIntegration.dataFlow;\n\t\t}\n\t\tinterface storageToSoftwareMessage connect storagePort.messageFormat to softwareDef.messageFormatDef {\n\t\t\tref flow references softwareIntegration.formatFlow;\n\t\t}\n\t}\n\taction softwareIntegration {\n\t\taction defineMessageFormat { out messageFormat: MessageFormat; }\n\t\taction defineDataFormat { out dataFormat: DataFormat; }\n\t\tsuccession flow formatFlow from defineMessageFormat.messageFormat to processInformation.messageFormat;\n\t\tsuccession flow dataFlow from defineDataFormat.dataFormat to processInformation.dataFormat;\n\t\taction processInformation { in messageFormat; in dataFormat; out processedData; }\n\t\taction storeData { in dataFormat; in messageFormat; }\n\t\tsuccession flow storageFlow from defineDataFormat.dataFormat to storeData.dataFormat;\n\t\tsuccession flow messageFlow from defineMessageFormat.messageFormat to storeData.messageFormat;\n\t}\n}",
    "package 'PowertrainSystem' {\n\tattribute def Power;\n\tattribute def TorqueCommand;\n\tattribute def Torque;\n\tport def TorqueCommandPort {\n\t\tout torqueCommand : TorqueCommand;\n\t}\n\tport def TorquePort {\n\t\tout torque: Torque;\n\t}\n\tpart context {\n\t\tpart logicalLayer {\n\t\t\tpart torqueGenerator {\n\t\t\t\tport torqueCommandPort: TorqueCommandPort;\n\t\t\t\tperform generateTorqueCommand {\n\t\t\t\t\tout torqueCommand = torqueCommandPort.torqueCommand;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tinterface logicalToPhysical connect logicalLayer.torqueGenerator.torqueCommandPort to physicalLayer.powerUnit.torqueCommandPort {\n\t\t\tref flow references generateTorqueCommand.torqueCommandFlow\n\t\t\t\tfrom source.torqueCommand to target.torqueCommand;\n\t\t}\n\t\tpart physicalLayer {\n\t\t\tpart powerUnit {\n\t\t\t\tport torqueCommandPort: ~TorqueCommandPort;\n\t\t\t\tperform produceTorque {\n\t\t\t\t\tin torqueCommand = torqueCommandPort.torqueCommand;\n\t\t\t\t\tout torque = torquePort.torque;\n\t\t\t\t}\n\t\t\t\tport torquePort: TorquePort;\n\t\t\t}\n\t\t}\n\t}\n\taction generateTorqueCommand {\n\t\taction generateTorqueCommand { out torqueCommand: TorqueCommand; }\n\t\tsuccession flow torqueCommandFlow from generateTorqueCommand.torqueCommand to produceTorque.torqueCommand;\n\t\taction produceTorque { in torqueCommand: TorqueCommand; out torque: Torque; }\n\t}\n}",
    "package 'PowerTransmissionSystem' {\n\tattribute def Torque;\n\tattribute def Power;\n\tport def TorquePort {\n\t\tout torque : Torque;\n\t}\n\tport def PowerPort {\n\t\tout power : Power;\n\t}\n\tpart context {\n\t\tpart logical {\n\t\t\tpart torqueGenerator {\n\t\t\t\tport torquePort: TorquePort;\n\t\t\t\tperform generateTorqueLogical {\n\t\t\t\t\tout torque = torquePort.torque;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tinterface logicalToPowertrain connect logical.torqueGenerator.torquePort to physical.powertrain.torquePort {\n\t\t\tref flow references generateTorqueLogical.torque to generateTorqueInPowertrain.torque;\n\t\t}\n\t\tpart physical {\n\t\t\tpart powertrain {\n\t\t\t\tport torquePort: ~TorquePort;\n\t\t\t\tperform generateTorqueInPowertrain {\n\t\t\t\t\tin torque = torquePort.torque;\n\t\t\t\t\tout power = powerPort.power;\n\t\t\t\t}\n\t\t\t\tport powerPort: PowerPort;\n\t\t\t\tpart engine {\n\t\t\t\t\tport torquePort: TorquePort;\n\t\t\t\t\tperform generateTorquePhysical {\n\t\t\t\t\t\tout torque = torquePort.torque;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tinterface engineToPowertrain connect engine.torquePort to powertrain.torquePort {\n\t\t\t\t\tref flow references generateTorquePhysical.torque to generateTorqueInPowertrain.torque;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\taction generateTorqueLogical {\n\t\tout torque : Torque;\n\t}\n\taction generateTorqueInPowertrain {\n\t\tin torque : Torque;\n\t\tout power : Power;\n\t}\n\taction generateTorquePhysical {\n\t\tout torque : Torque;\n\t}\n\tsuccession flow from generateTorqueLogical.torque to generateTorqueInPowertrain.torque;\n\tsuccession flow from generateTorquePhysical.torque to generateTorqueInPowertrain.torque;\n}",
    "package 'VehicleFeatureAnnotationSystem' {\n\tattribute def SafetyFunction;\n\tattribute def SecurityFunction;\n\tport def SafetyFunctionPort {\n\t\tout safetyFunction : SafetyFunction;\n\t}\n\tport def SecurityFunctionPort {\n\t\tout securityFunction : SecurityFunction;\n\t}\n\tpart context {\n\t\tpart vehicle {\n\t\t\tpart interiorAssembly {\n\t\t\t\tpart seatBelts {\n\t\t\t\t\tport safetyFunctionPort: SafetyFunctionPort;\n\t\t\t\t\tperform safetyAndSecurityRegion.activateSeatBelts {\n\t\t\t\t\t\tout safetyFunction = safetyFunctionPort.safetyFunction;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tpart frontSeats {\n\t\t\t\t}\n\t\t\t\tpart driverAirbag {\n\t\t\t\t\tport safetyFunctionPort: SafetyFunctionPort;\n\t\t\t\t\tperform safetyAndSecurityRegion.deployDriverAirbag {\n\t\t\t\t\t\tout safetyFunction = safetyFunctionPort.safetyFunction;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tpart alarmSystem {\n\t\t\t\t\tport securityFunctionPort: SecurityFunctionPort;\n\t\t\t\t\tperform safetyAndSecurityRegion.triggerAntiTheftAlarm {\n\t\t\t\t\t\tout securityFunction = securityFunctionPort.securityFunction;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tpart bodyAssembly {\n\t\t\t\tpart bodyShell {\n\t\t\t\t}\n\t\t\t\tpart bumpers {\n\t\t\t\t\tport safetyFunctionPort: SafetyFunctionPort;\n\t\t\t\t\tperform safetyAndSecurityRegion.provideImpactProtection {\n\t\t\t\t\t\tout safetyFunction = safetyFunctionPort.safetyFunction;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tpart keylessEntryDevice {\n\t\t\t\t\tport securityFunctionPort: SecurityFunctionPort;\n\t\t\t\t\tperform safetyAndSecurityRegion.enableKeylessEntry {\n\t\t\t\t\t\tout securityFunction = securityFunctionPort.securityFunction;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\taction safetyAndSecurityRegion {\n\t\taction activateSeatBelts { out safetyFunction: SafetyFunction; }\n\t\taction deployDriverAirbag { out safetyFunction: SafetyFunction; }\n\t\taction provideImpactProtection { out safetyFunction: SafetyFunction; }\n\t\taction triggerAntiTheftAlarm { out securityFunction: SecurityFunction; }\n\t\taction enableKeylessEntry { out securityFunction: SecurityFunction; }\n\t}\n}",
    "package 'VehicleDynamicsSimulation' {\n\tattribute def InitialVelocity;\n\tattribute def InitialPosition;\n\tattribute def Acceleration;\n\tattribute def TimeStep;\n\tattribute def FinalVelocity;\n\tattribute def FinalPosition;\n\tport def InputPort {\n\t\tout initialVelocity: InitialVelocity;\n\t\tout initialPosition: InitialPosition;\n\t\tout acceleration: Acceleration;\n\t\tout timeStep: TimeStep;\n\t}\n\tport def OutputPort {\n\t\tin finalVelocity: FinalVelocity;\n\t\tin finalPosition: FinalPosition;\n\t}\n\tpart context {\n\t\tpart user {\n\t\t\tport inputPort: InputPort;\n\t\t\tperform dynamicAnalysis.sendInputParameters {\n\t\t\t\tout initialVelocity = inputPort.initialVelocity;\n\t\t\t\tout initialPosition = inputPort.initialPosition;\n\t\t\t\tout acceleration = inputPort.acceleration;\n\t\t\t\tout timeStep = inputPort.timeStep;\n\t\t\t}\n\t\t}\n\t\tinterface userToSimulation connect user.inputPort to simulationSystem.inputPort {\n\t\t\tref flow references dynamicAnalysis.inputFlow\n\t\t\t\tfrom source.initialVelocity to target.initialVelocity,\n\t\t\t\tfrom source.initialPosition to target.initialPosition,\n\t\t\t\tfrom source.acceleration to target.acceleration,\n\t\t\t\tfrom source.timeStep to target.timeStep;\n\t\t}\n\t\tpart simulationSystem {\n\t\t\tport inputPort: ~InputPort;\n\t\t\tport outputPort: ~OutputPort;\n\t\t\tperform dynamicAnalysis.calculateDynamicBehavior {\n\t\t\t\tin initialVelocity = inputPort.initialVelocity;\n\t\t\t\tin initialPosition = inputPort.initialPosition;\n\t\t\t\tin acceleration = inputPort.acceleration;\n\t\t\t\tin timeStep = inputPort.timeStep;\n\t\t\t\tout finalVelocity = outputPort.finalVelocity;\n\t\t\t\tout finalPosition = outputPort.finalPosition;\n\t\t\t}\n\t\t\tpart modelCenterTool {\n\t\t\t\tport analysisPort: AnalysisPort;\n\t\t\t\tperform dynamicAnalysis.performAnalysis {\n\t\t\t\t\tin initialVelocity, initialPosition, acceleration, timeStep;\n\t\t\t\t\tout finalVelocity, finalPosition;\n\t\t\t\t}\n\t\t\t}\n\t\t\tinterface simulationToModelCenter connect calculateDynamicBehavior to modelCenterTool.analysisPort {\n\t\t\t\tref flow references dynamicAnalysis.analysisFlow\n\t\t\t\t\tfrom source.initialVelocity to target.initialVelocity,\n\t\t\t\t\tfrom source.initialPosition to target.initialPosition,\n\t\t\t\t\tfrom source.acceleration to target.acceleration,\n\t\t\t\t\tfrom source.timeStep to target.timeStep,\n\t\t\t\t\tfrom target.finalVelocity to source.finalVelocity,\n\t\t\t\t\tfrom target.finalPosition to source.finalPosition;\n\t\t\t}\n\t\t}\n\t}\n\taction dynamicAnalysis {\n\t\taction sendInputParameters {\n\t\t\tout initialVelocity: InitialVelocity;\n\t\t\tout initialPosition: InitialPosition;\n\t\t\tout acceleration: Acceleration;\n\t\t\tout timeStep: TimeStep;\n\t\t}\n\t\tsuccession flow inputFlow from sendInputParameters.initialVelocity to calculateDynamicBehavior.initialVelocity,\n\t\t\tfrom sendInputParameters.initialPosition to calculateDynamicBehavior.initialPosition,\n\t\t\tfrom sendInputParameters.acceleration to calculateDynamicBehavior.acceleration,\n\t\t\tfrom sendInputParameters.timeStep to calculateDynamicBehavior.timeStep;\n\t\taction calculateDynamicBehavior {\n\t\t\tin initialVelocity: InitialVelocity;\n\t\t\tin initialPosition: InitialPosition;\n\t\t\tin acceleration: Acceleration;\n\t\t\tin timeStep: TimeStep;\n\t\t\tout finalVelocity: FinalVelocity;\n\t\t\tout finalPosition: FinalPosition;\n\t\t}\n\t\tsuccession flow analysisFlow from calculateDynamicBehavior.initialVelocity to performAnalysis.initialVelocity,\n\t\t\tfrom calculateDynamicBehavior.initialPosition to performAnalysis.initialPosition,\n\t\t\tfrom calculateDynamicBehavior.acceleration to performAnalysis.acceleration,\n\t\t\tfrom calculateDynamicBehavior.timeStep to performAnalysis.timeStep,\n\t\t\tfrom performAnalysis.finalVelocity to calculateDynamicBehavior.finalVelocity,\n\t\t\tfrom performAnalysis.finalPosition to calculateDynamicBehavior.finalPosition;\n\t\taction performAnalysis {\n\t\t\tin initialVelocity: InitialVelocity;\n\t\t\tin initialPosition: InitialPosition;\n\t\t\tin acceleration: Acceleration;\n\t\t\tin timeStep: TimeStep;\n\t\t\tout finalVelocity: FinalVelocity;\n\t\t\tout finalPosition: FinalPosition;\n\t\t}\n\t}\n}",
    "package 'CarSafetyCompliance' {\n\tattribute def SeatBelt;\n\tattribute def DriverAirbag;\n\tattribute def Bumper;\n\tattribute def KeylessEntry;\n\tattribute def Wheel;\n\tattribute def ABS;\n\t\n\tpart context {\n\t\tpart interior {\n\t\t\t@Safety\n\t\t\tpart seatBelt {\n\t\t\t\tproperty isMandatory: Boolean = true;\n\t\t\t} [2];\n\t\t\t@Safety\n\t\t\tpart driverAirbag {\n\t\t\t\tproperty isMandatory: Boolean = false;\n\t\t\t};\n\t\t}\n\t\tpart body {\n\t\t\t@Safety\n\t\t\tpart bumper {\n\t\t\t\tproperty isMandatory: Boolean = true;\n\t\t\t};\n\t\t}\n\t\tpart wheelAssembly {\n\t\t\tpart wheel {\n\t\t\t\tproperty isMandatory: Boolean = false;\n\t\t\t} [2];\n\t\t\t@Safety\n\t\t\tpart abs {\n\t\t\t\tproperty isMandatory: Boolean = false;\n\t\t\t};\n\t\t}\n\t\tpart keylessEntrySystem {\n\t\t\t// No @Safety annotation\n\t\t};\n\t}\n\t\n\tpackage 'SafetyFeatures' {\n\t\tpart seatBelt;\n\t\tpart driverAirbag;\n\t\tpart bumper;\n\t\tpart abs;\n\t}\n\t\n\tpackage 'MandatorySafetyFeatures' {\n\t\tpart seatBelt;\n\t\tpart bumper;\n\t}\n}",
    "package 'VehicleSafetyCompliance' {\n\tattribute def SafetyFeatureType;\n\tattribute def Integer;\n\tenum Required, Optional;\n\n\tpart def SeatBelt {\n\t\tproperty safetyType: SafetyFeatureType = Required;\n\t}\n\tpart def DriverAirbag {\n\t\tproperty safetyType: SafetyFeatureType = Optional;\n\t}\n\tpart def Bumper {\n\t\tproperty safetyType: SafetyFeatureType = Required;\n\t}\n\tpart def KeylessEntry {\n\t\tproperty safetyType: SafetyFeatureType = Optional;\n\t}\n\tpart def ABS {\n\t\tproperty safetyType: SafetyFeatureType = Optional;\n\t}\n\n\tpart context {\n\t\tpart interior {\n\t\t\tpart seatBelt1: SeatBelt;\n\t\t\tpart seatBelt2: SeatBelt;\n\t\t\tpart driverAirbag: DriverAirbag;\n\t\t}\n\t\tpart body {\n\t\t\tpart bumper: Bumper;\n\t\t\tpart keylessEntry: KeylessEntry;\n\t\t}\n\t\tpart chassis {\n\t\t\tproperty numTires: Integer = 4;\n\t\t\tpart abs: ABS;\n\t\t}\n\t\tpart safetyManager {\n\t\t\tproperty requiredFeatures: List<Part> = [interior.seatBelt1, interior.seatBelt2, body.bumper];\n\t\t\tproperty optionalFeatures: List<Part> = [interior.driverAirbag, body.keylessEntry, chassis.abs];\n\t\t}\n\t}\n}",
    "package 'RiskManagementSystem' {\n\tattribute def Cause;\n\tattribute def Probability;\n\tattribute def Situation;\n\tattribute def Failure;\n\tattribute def SeverityLevel;\n\tport def RiskScenarioPort {\n\t\tout riskScenario: Situation;\n\t}\n\tport def CausalRelationshipPort {\n\t\tin cause: Cause;\n\t\tin probability: Probability;\n\t\tout failure: Failure;\n\t\tout severity: SeverityLevel;\n\t}\n\tpart context {\n\t\tpart system {\n\t\t\tport riskScenarioPort: RiskScenarioPort;\n\t\t\tperform riskScenarioRegion.sendRiskScenario {\n\t\t\t\tout riskScenario = riskScenarioPort.riskScenario;\n\t\t\t}\n\t\t}\n\t\tinterface systemToAnalyzer connect system.riskScenarioPort to analyzer.riskScenarioPort {\n\t\t\tref flow references riskScenarioRegion.scenarioFlow\n\t\t\t\tfrom source.riskScenario to target.riskScenario;\n\t\t}\n\t\tpart analyzer {\n\t\t\tport riskScenarioPort: ~RiskScenarioPort;\n\t\t\tperform riskScenarioRegion.analyzeCausalChain {\n\t\t\t\tin riskScenario = riskScenarioPort.riskScenario;\n\t\t\t\tout causalRelationship = causalRelationshipPort.cause;\n\t\t\t\tout probability = causalRelationshipPort.probability;\n\t\t\t}\n\t\t\tport causalRelationshipPort: CausalRelationshipPort;\n\t\t}\n\t\tinterface analyzerToFailure connect analyzer.causalRelationshipPort to failureModel.causalInputPort {\n\t\t\tref flow references riskScenarioRegion.causalFlow\n\t\t\t\tfrom source.cause to target.cause;\n\t\t\tref flow references riskScenarioRegion.causalFlow\n\t\t\t\tfrom source.probability to target.probability;\n\t\t}\n\t\tpart failureModel {\n\t\t\tport causalInputPort: ~CausalRelationshipPort;\n\t\t\tperform riskScenarioRegion.identifyFailure {\n\t\t\t\tin cause = causalInputPort.cause;\n\t\t\t\tin probability = causalInputPort.probability;\n\t\t\t\tout failure = causalRelationshipPort.failure;\n\t\t\t\tout severity = causalRelationshipPort.severity;\n\t\t\t}\n\t\t\tport causalRelationshipPort: ~CausalRelationshipPort;\n\t\t}\n\t}\n\taction riskScenarioRegion {\n\t\taction sendRiskScenario { out riskScenario: Situation; }\n\t\tsuccession flow scenarioFlow from sendRiskScenario.riskScenario to analyzeCausalChain.riskScenario;\n\t\taction analyzeCausalChain { in riskScenario: Situation; out cause: Cause; out probability: Probability; }\n\t\tsuccession flow causalFlow from analyzeCausalChain.cause to identifyFailure.cause;\n\t\tsuccession flow causalFlow from analyzeCausalChain.probability to identifyFailure.probability;\n\t\taction identifyFailure { in cause: Cause; in probability: Probability; out failure: Failure; out severity: SeverityLevel; }\n\t}\n}",
    "package 'RiskMetadataManagement' {\n\tattribute def Scenario;\n\tattribute def Cause;\n\tattribute def Probability;\n\tattribute def Failure;\n\tattribute def Severity;\n\tattribute def CausalRelationship;\n\tattribute def RiskScenario;\n\tattribute def StandardModelingLanguage;\n\tport def ScenarioCmdPort {\n\t\tout scenario: Scenario;\n\t}\n\tport def CausePort {\n\t\tout cause: Cause;\n\t\tout probability: Probability;\n\t}\n\tport def FailurePort {\n\t\tout failure: Failure;\n\t\tout severity: Severity;\n\t}\n\tport def CausalRelationshipPort {\n\t\tout relationship: CausalRelationship;\n\t}\n\tport def RiskScenarioPort {\n\t\tout riskScenario: RiskScenario;\n\t}\n\tport def CompatibilityPort {\n\t\tout compatibleMetadata: StandardModelingLanguage;\n\t}\n\tpart context {\n\t\tpart user {\n\t\t\tport scenarioCmdPort: ScenarioCmdPort;\n\t\t\tperform identifyScenario.sendScenario {\n\t\t\t\tout scenario = scenarioCmdPort.scenario;\n\t\t\t}\n\t\t}\n\t\tinterface userToSystem connect user.scenarioCmdPort to riskSystem.scenarioCmdPort {\n\t\t\tref flow references identifyScenario.scenarioFlow\n\t\t\t\tfrom source.scenario to target.scenario;\n\t\t}\n\t\tpart riskSystem {\n\t\t\tport scenarioCmdPort: ~ScenarioCmdPort;\n\t\t\tport causePort: CausePort;\n\t\t\tport failurePort: FailurePort;\n\t\t\tport causalRelationshipPort: CausalRelationshipPort;\n\t\t\tport compatibilityPort: CompatibilityPort;\n\t\t\tperform identifyScenario.propagateScenario {\n\t\t\t\tin scenario = scenarioCmdPort.scenario;\n\t\t\t\tout cause = causePort.cause;\n\t\t\t\tout failure = failurePort.failure;\n\t\t\t}\n\t\t\tperform detailCauses.assignProbability {\n\t\t\t\tin cause = causePort.cause;\n\t\t\t\tout probability = causePort.probability;\n\t\t\t}\n\t\t\tperform associateFailures.assignSeverity {\n\t\t\t\tin failure = failurePort.failure;\n\t\t\t\tout severity = failurePort.severity;\n\t\t\t}\n\t\t\tperform trackCausalRelationships.buildChain {\n\t\t\t\tin cause = causePort.cause;\n\t\t\t\tin failure = failurePort.failure;\n\t\t\t\tout relationship = causalRelationshipPort.relationship;\n\t\t\t}\n\t\t\tperform combineRiskElements.formScenario {\n\t\t\t\tin relationship = causalRelationshipPort.relationship;\n\t\t\t\tin probability = causePort.probability;\n\t\t\t\tin severity = failurePort.severity;\n\t\t\t\tout riskScenario = riskScenarioPort.riskScenario;\n\t\t\t}\n\t\t\tperform ensureCompatibility.translate {\n\t\t\t\tin riskScenario = riskScenarioPort.riskScenario;\n\t\t\t\tout compatibleMetadata = compatibilityPort.compatibleMetadata;\n\t\t\t}\n\t\t}\n\t}\n\taction identifyScenario {\n\t\taction sendScenario { out scenario: Scenario; }\n\t\tsuccession flow scenarioFlow from sendScenario.scenario to propagateScenario.scenario;\n\t\taction propagateScenario { in scenario; out cause: Cause; out failure: Failure; }\n\t}\n\taction detailCauses {\n\t\taction assignProbability { in cause: Cause; out probability: Probability; }\n\t\tsuccession flow probabilityFlow from assignProbability.probability to formScenario.probability;\n\t}\n\taction associateFailures {\n\t\taction assignSeverity { in failure: Failure; out severity: Severity; }\n\t\tsuccession flow severityFlow from assignSeverity.severity to formScenario.severity;\n\t}\n\taction trackCausalRelationships {\n\t\taction buildChain { in cause: Cause; in failure: Failure; out relationship: CausalRelationship; }\n\t\tsuccession flow relationshipFlow from buildChain.relationship to formScenario.relationship;\n\t}\n\taction combineRiskElements {\n\t\taction formScenario { in relationship: CausalRelationship; in probability: Probability; in severity: Severity; out riskScenario: RiskScenario; }\n\t\tsuccession flow scenarioOutput from formScenario.riskScenario to translate.riskScenario;\n\t}\n\taction ensureCompatibility {\n\t\taction translate { in riskScenario: RiskScenario; out compatibleMetadata: StandardModelingLanguage; }\n\t}\n}",
    "package 'BatteryRiskAnalysisSystem' {\n\tattribute def BatteryLevel;\n\tattribute def BatteryAgingProbability;\n\tattribute def Risk;\n\tattribute def LowBatteryState;\n\tattribute def PersistenceDuration;\n\tattribute def ShutdownSignal;\n\tattribute def SeverityLevel;\n\tport def BatteryLevelPort {\n\t\tin batteryLevel : BatteryLevel;\n\t}\n\tport def RiskAlertPort {\n\t\tout risk: Risk;\n\t\tout severity: SeverityLevel;\n\t}\n\tport def ShutdownPort {\n\t\tout shutdown: ShutdownSignal;\n\t}\n\tpart context {\n\t\tpart equipment {\n\t\t\tport batteryLevelPort: BatteryLevelPort;\n\t\t\tperform riskAnalysisRegion.monitorBatteryLevel {\n\t\t\t\tout batteryLevel = batteryLevelPort.batteryLevel;\n\t\t\t}\n\t\t\tport riskAlertPort: RiskAlertPort;\n\t\t\tport shutdownPort: ShutdownPort;\n\t\t}\n\t\tinterface equipmentToBattery connect equipment.batteryLevelPort to battery.batteryLevelPort {\n\t\t\tref flow references riskAnalysisRegion.batteryLevelFlow\n\t\t\t\tfrom source.batteryLevel to target.batteryLevel;\n\t\t}\n\t\tpart battery {\n\t\t\tport batteryLevelPort: ~BatteryLevelPort;\n\t\t\tperform riskAnalysisRegion.provideBatteryLevel {\n\t\t\t\tout batteryLevel = batteryLevelPort.batteryLevel;\n\t\t\t}\n\t\t}\n\t\tpart riskAnalysisModule {\n\t\t\tport batteryLevelPort: ~BatteryLevelPort;\n\t\t\tperform riskAnalysisRegion.analyzeBatteryAging {\n\t\t\t\tin batteryLevel = batteryLevelPort.batteryLevel;\n\t\t\t\tout risk = riskAlertPort.risk;\n\t\t\t\tout severity = riskAlertPort.severity;\n\t\t\t}\n\t\t\tperform riskAnalysisRegion.determineLowBattery {\n\t\t\t\tin batteryLevel = batteryLevelPort.batteryLevel;\n\t\t\t\tout lowBatteryState = lowBatteryState;\n\t\t\t}\n\t\t\tperform riskAnalysisRegion.analyzePersistence {\n\t\t\t\tin lowBatteryState = lowBatteryState;\n\t\t\t\tout persistenceDuration = persistenceDuration;\n\t\t\t}\n\t\t\tperform riskAnalysisRegion.triggerShutdown {\n\t\t\t\tin persistenceDuration = persistenceDuration;\n\t\t\t\tout shutdown = shutdownPort.shutdown;\n\t\t\t}\n\t\t}\n\t}\n\taction riskAnalysisRegion {\n\t\taction monitorBatteryLevel { out batteryLevel: BatteryLevel; }\n\t\tsuccession flow batteryLevelFlow from monitorBatteryLevel.batteryLevel to analyzeBatteryAging.batteryLevel;\n\t\taction analyzeBatteryAging { in batteryLevel: BatteryLevel; out risk: Risk; out severity: SeverityLevel; }\n\t\tsuccession flow agingRiskFlow from analyzeBatteryAging.risk to determineLowBattery.risk;\n\t\taction determineLowBattery { in batteryLevel: BatteryLevel; in risk: Risk; out lowBatteryState: LowBatteryState; }\n\t\tsuccession flow lowBatteryFlow from determineLowBattery.lowBatteryState to analyzePersistence.lowBatteryState;\n\t\taction analyzePersistence { in lowBatteryState: LowBatteryState; out persistenceDuration: PersistenceDuration; }\n\t\tsuccession flow shutdownFlow from analyzePersistence.persistenceDuration to triggerShutdown.persistenceDuration;\n\t\taction triggerShutdown { in persistenceDuration: PersistenceDuration; out shutdown: ShutdownSignal; }\n\t\taction assignSeverityLevel { in failureType: String; out severity: SeverityLevel; }\n\t\tsuccession flow severityFlow from analyzeBatteryAging.severity to riskAlertPort.severity;\n\t}\n}",
    "package 'StructuralDecomposition' {\n\tattribute def Subsystem;\n\tattribute def Component;\n\tattribute def InterfaceDefinition;\n\tattribute def VerificationResult;\n\tport def DecompositionPort {\n\t\tout subsystems: Subsystem;\n\t\tout components: Component;\n\t}\n\tport def InterfacePort {\n\t\tout interfaceDef: InterfaceDefinition;\n\t}\n\tport def VerificationPort {\n\t\tout verification: VerificationResult;\n\t}\n\tpart context {\n\t\tpart topLevelSystem {\n\t\t\tport decompositionPort: DecompositionPort;\n\t\t\tperform decomposeSystem {\n\t\t\t\tout subsystems = decompositionPort.subsystems;\n\t\t\t\tout components = decompositionPort.components;\n\t\t\t}\n\t\t}\n\t\tinterface systemToSubsystems connect topLevelSystem.decompositionPort to subsystems.decompositionPort {\n\t\t\tref flow references decomposeSystem.subsystemsFlow\n\t\t\t\tfrom source.subsystems to target.subsystems;\n\t\t\tref flow references decomposeSystem.componentsFlow\n\t\t\t\tfrom source.components to target.components;\n\t\t}\n\t\tpart subsystems {\n\t\t\tport decompositionPort: ~DecompositionPort;\n\t\t\tperform decomposeSystem {\n\t\t\t\tin subsystems = decompositionPort.subsystems;\n\t\t\t\tin components = decompositionPort.components;\n\t\t\t\tout interfaceDef = interfacePort.interfaceDef;\n\t\t\t}\n\t\t\tport interfacePort: InterfacePort;\n\t\t}\n\t\tinterface subsystemsToComponents connect subsystems.interfacePort to components.interfacePort {\n\t\t\tref flow references decomposeSystem.interfaceDefFlow\n\t\t\t\tfrom source.interfaceDef to target.interfaceDef;\n\t\t}\n\t\tpart components {\n\t\t\tport interfacePort: ~InterfacePort;\n\t\t\tperform defineInterfaces {\n\t\t\t\tin interfaceDef = interfacePort.interfaceDef;\n\t\t\t}\n\t\t}\n\t\tpart ivvTeam {\n\t\t\tport verificationPort: VerificationPort;\n\t\t\tperform verifyModularDesign {\n\t\t\t\tout verification = verificationPort.verification;\n\t\t\t}\n\t\t}\n\t\tinterface systemToIVV connect topLevelSystem.decompositionPort to ivvTeam.verificationPort {\n\t\t\tref flow references verifyModularDesign.systemStructureFlow\n\t\t\t\tfrom source.subsystems to target.verification;\n\t\t\tref flow references verifyModularDesign.interfaceFlow\n\t\t\t\tfrom source.components to target.verification;\n\t\t}\n\t}\n\taction decomposeSystem {\n\t\taction decomposeSystem { out subsystems: Subsystem; out components: Component; }\n\t\tsuccession flow subsystemsFlow from decomposeSystem.subsystems to systemToSubsystems.subsystems;\n\t\tsuccession flow componentsFlow from decomposeSystem.components to systemToSubsystems.components;\n\t}\n\taction defineInterfaces {\n\t\taction defineInterfaces { in subsystems: Subsystem; in components: Component; out interfaceDef: InterfaceDefinition; }\n\t\tsuccession flow interfaceDefFlow from defineInterfaces.interfaceDef to subsystemsToComponents.interfaceDef;\n\t}\n\taction verifyModularDesign {\n\t\taction verifyModularDesign { in subsystems: Subsystem; in components: Component; in interfaceDef: InterfaceDefinition; out verification: VerificationResult; }\n\t\tsuccession flow systemStructureFlow from decomposeSystem.subsystems to verifyModularDesign.subsystems;\n\t\tsuccession flow interfaceFlow from decomposeSystem.components to verifyModularDesign.components;\n\t}\n}",
    "package 'AutomotiveSystem' {\n\tattribute def SafetyAttribute;\n\tattribute def FunctionalAttribute;\n\tenum SafetyAttribute {\n\t\tMandatory;\n\t\tOptional;\n\t}\n\tenum FunctionalAttribute {\n\t\tFunctional;\n\t}\n\tport def SafetyPort {\n\t\tout safetyAttribute: SafetyAttribute;\n\t}\n\tport def FunctionalPort {\n\t\tout functionalAttribute: FunctionalAttribute;\n\t}\n\tpart context {\n\t\tpart automotiveSystemRoot {\n\t\t\tport functionalPort: FunctionalPort;\n\t\t\tperform decomposeSystem {\n\t\t\t\tout functionalAttribute = functionalPort.functionalAttribute;\n\t\t\t}\n\t\t}\n\t\tinterface rootToChassis connect automotiveSystemRoot.functionalPort to chassisSubsystem.functionalPort {\n\t\t\tref flow references decomposeSystem.functionalFlow;\n\t\t}\n\t\tinterface rootToPowertrain connect automotiveSystemRoot.functionalPort to powertrainSubsystem.functionalPort {\n\t\t\tref flow references decomposeSystem.functionalFlow;\n\t\t}\n\t\tinterface rootToInfotainment connect automotiveSystemRoot.functionalPort to infotainmentSubsystem.functionalPort {\n\t\t\tref flow references decomposeSystem.functionalFlow;\n\t\t}\n\t\tinterface rootToSafety connect automotiveSystemRoot.functionalPort to safetySubsystem.functionalPort {\n\t\t\tref flow references decomposeSystem.functionalFlow;\n\t\t}\n\t\tpart chassisSubsystem {\n\t\t\tport functionalPort: ~FunctionalPort;\n\t\t\tport safetyPort: SafetyPort;\n\t\t\tperform decomposeSystem.chassisDecomposition {\n\t\t\t\tin functionalAttribute = functionalPort.functionalAttribute;\n\t\t\t\tout safetyAttribute = safetyPort.safetyAttribute;\n\t\t\t}\n\t\t}\n\t\tinterface chassisToComponents connect chassisSubsystem.safetyPort to chassisSubsystem.seatBelt.safetyPort, chassisSubsystem.bumper.safetyPort {\n\t\t\tref flow references decomposeSystem.chassisDecomposition.safetyFlow;\n\t\t}\n\t\tpart powertrainSubsystem {\n\t\t\tport functionalPort: ~FunctionalPort;\n\t\t\tperform decomposeSystem.powertrainDecomposition {\n\t\t\t\tin functionalAttribute = functionalPort.functionalAttribute;\n\t\t\t}\n\t\t}\n\t\tinterface powertrainToComponents connect powertrainSubsystem.functionalPort to powertrainSubsystem.engineControl.functionalPort, powertrainSubsystem.transmission.functionalPort {\n\t\t\tref flow references decomposeSystem.powertrainDecomposition.functionalFlow;\n\t\t}\n\t\tpart infotainmentSubsystem {\n\t\t\tport functionalPort: ~FunctionalPort;\n\t\t\tperform decomposeSystem.infotainmentDecomposition {\n\t\t\t\tin functionalAttribute = functionalPort.functionalAttribute;\n\t\t\t}\n\t\t}\n\t\tinterface infotainmentToComponents connect infotainmentSubsystem.functionalPort to infotainmentSubsystem.headUnit.functionalPort, infotainmentSubsystem.display.functionalPort {\n\t\t\tref flow references decomposeSystem.infotainmentDecomposition.functionalFlow;\n\t\t}\n\t\tpart safetySubsystem {\n\t\t\tport functionalPort: ~FunctionalPort;\n\t\t\tport safetyPort: SafetyPort;\n\t\t\tperform decomposeSystem.safetyDecomposition {\n\t\t\t\tin functionalAttribute = functionalPort.functionalAttribute;\n\t\t\t\tout safetyAttribute = safetyPort.safetyAttribute;\n\t\t\t}\n\t\t}\n\t\tinterface safetyToComponents connect safetySubsystem.safetyPort to safetySubsystem.driverAirbag.safetyPort, safetySubsystem.absSystem.safetyPort {\n\t\t\tref flow references decomposeSystem.safetyDecomposition.safetyFlow;\n\t\t}\n\t\tpart seatBelt {\n\t\t\tport safetyPort: ~SafetyPort;\n\t\t\tattribute safetyAttribute: SafetyAttribute = Mandatory;\n\t\t}\n\t\tpart bumper {\n\t\t\tport safetyPort: ~SafetyPort;\n\t\t\tattribute safetyAttribute: SafetyAttribute = Mandatory;\n\t\t}\n\t\tpart driverAirbag {\n\t\t\tport safetyPort: ~SafetyPort;\n\t\t\tattribute safetyAttribute: SafetyAttribute = Optional;\n\t\t}\n\t\tpart absSystem {\n\t\t\tport safetyPort: ~SafetyPort;\n\t\t\tattribute safetyAttribute: SafetyAttribute = Optional;\n\t\t}\n\t\tpart engineControl {\n\t\t\tport functionalPort: ~FunctionalPort;\n\t\t}\n\t\tpart transmission {\n\t\t\tport functionalPort: ~FunctionalPort;\n\t\t}\n\t\tpart headUnit {\n\t\t\tport functionalPort: ~FunctionalPort;\n\t\t}\n\t\tpart display {\n\t\t\tport functionalPort: ~FunctionalPort;\n\t\t}\n\t}\n\taction decomposeSystem {\n\t\taction functionalFlow { out functionalAttribute: FunctionalAttribute; }\n\t\taction chassisDecomposition {\n\t\t\tin functionalAttribute;\n\t\t\taction safetyFlow { out safetyAttribute: SafetyAttribute; }\n\t\t}\n\t\taction powertrainDecomposition {\n\t\t\tin functionalAttribute;\n\t\t\taction functionalFlow { out functionalAttribute: FunctionalAttribute; }\n\t\t}\n\t\taction infotainmentDecomposition {\n\t\t\tin functionalAttribute;\n\t\t\taction functionalFlow { out functionalAttribute: FunctionalAttribute; }\n\t\t}\n\t\taction safetyDecomposition {\n\t\t\tin functionalAttribute;\n\t\t\taction safetyFlow { out safetyAttribute: SafetyAttribute; }\n\t\t}\n\t\tsuccession flow decomposeSystem.functionalFlow to chassisDecomposition.functionalAttribute;\n\t\tsuccession flow decomposeSystem.functionalFlow to powertrainDecomposition.functionalAttribute;\n\t\tsuccession flow decomposeSystem.functionalFlow to infotainmentDecomposition.functionalAttribute;\n\t\tsuccession flow decomposeSystem.functionalFlow to safetyDecomposition.functionalAttribute;\n\t}\n\taction listSafetyComponents {\n\t\taction collectMandatory {\n\t\t\tout component: String = \"seatBelt, bumper\";\n\t\t\tout status: SafetyAttribute = Mandatory;\n\t\t}\n\t\taction collectOptional {\n\t\t\tout component: String = \"driverAirbag, absSystem\";\n\t\t\tout status: SafetyAttribute = Optional;\n\t\t}\n\t\tsuccession flow collectMandatory.component to generateTableView.mandatoryComponents;\n\t\tsuccession flow collectOptional.component to generateTableView.optionalComponents;\n\t}\n\taction listNonSafetyComponents {\n\t\tout component: String = \"engineControl, transmission, headUnit, display\";\n\t}\n\taction generateTree {\n\t\tout structure: String = \"automotiveSystemRoot -> chassisSubsystem, powertrainSubsystem, infotainmentSubsystem, safetySubsystem -> [components]\";\n\t}\n\taction generateTableView {\n\t\tin mandatoryComponents: String;\n\t\tin optionalComponents: String;\n\t\tout table: String = \"Safety Components: {mandatoryComponents}, Non-Safety Components: {listNonSafetyComponents.component}\";\n\t}\n}",
    "package 'Automotive' {\n\tattribute def 扭矩;\n\tattribute def 扭矩单位 /* 注释: 物理量单位, 例如牛·米 */;\n\tport def 扭矩Port {\n\t\tout torque: 扭矩;\n\t}\n\tpart def 汽车 (Car);\n\tpart context {\n\t\tpart 汽车 (Car) {\n\t\t\tport 扭矩Port: 扭矩Port;\n\t\t\tperform generateTorqueRegion.generateTorque {\n\t\t\t\tout torque = 扭矩Port.torque;\n\t\t\t}\n\t\t}\n\t\tinterface 汽车To应用 connect 汽车.扭矩Port to 应用组件.扭矩Port {\n\t\t\tref flow references generateTorqueRegion.扭矩Flow\n\t\t\t\tfrom source.torque to target.torque;\n\t\t}\n\t\tpart 应用组件 {\n\t\t\tport 扭矩Port: ~扭矩Port;\n\t\t\tperform generateTorqueRegion.applyTorque {\n\t\t\t\tin torque = 扭矩Port.torque;\n\t\t\t}\n\t\t}\n\t}\n\taction generateTorqueRegion {\n\t\taction generateTorque { out torque: 扭矩; }\n\t\tsuccession flow 扭矩Flow from generateTorque.torque to applyTorque.torque;\n\t\taction applyTorque { in torque: 扭矩; }\n\t}\n}",
    "package 'AutomobileDocumentManagement' {  \n\tattribute def AutomobileInfo;  \n\tattribute def CarInfo;  \n\tattribute def PhysicalQuantity;  \n\tattribute def TorqueValue;  \n\tattribute def ExplanatoryDocument;  \n\tport def DocumentCmdPort {  \n\t\tout addDoc: AutomobileInfo;  \n\t\tout query: AutomobileInfo;  \n\t\tout archive: AutomobileInfo;  \n\t}  \n\tport def AliasCmdPort {  \n\t\tout carAlias: CarInfo;  \n\t}  \n\tport def QuantityPort {  \n\t\tout quantity: PhysicalQuantity;  \n\t}  \n\tport def TorquePort {  \n\t\tout torque: TorqueValue;  \n\t}  \n\tport def DocumentContentPort {  \n\t\tout content: ExplanatoryDocument;  \n\t}  \n\tpart context {  \n\t\tpart user {  \n\t\t\tport documentCmdPort: DocumentCmdPort;  \n\t\t\tport aliasCmdPort: AliasCmdPort;  \n\t\t\tperform manageDocuments.sendDocumentCmd {  \n\t\t\t\tout addDoc = documentCmdPort.addDoc;  \n\t\t\t\tout query = documentCmdPort.query;  \n\t\t\t\tout archive = documentCmdPort.archive;  \n\t\t\t}  \n\t\t\tperform manageAlias.sendCarAlias {  \n\t\t\t\tout carAlias = aliasCmdPort.carAlias;  \n\t\t\t}  \n\t\t}  \n\t\tinterface userToAutomobile connect user.documentCmdPort to automobile.documentCmdPort {  \n\t\t\tref flow references manageDocuments.addDocumentFlow  \n\t\t\t\tfrom source.addDoc to target.addDoc;  \n\t\t\tref flow references manageDocuments.queryFlow  \n\t\t\t\tfrom source.query to target.query;  \n\t\t\tref flow references manageDocuments.archiveFlow  \n\t\t\t\tfrom source.archive to target.archive;  \n\t\t}  \n\t\tinterface userToCar connect user.aliasCmdPort to car.aliasCmdPort {  \n\t\t\tref flow references manageAlias.aliasFlow  \n\t\t\t\tfrom source.carAlias to target.carAlias;  \n\t\t}  \n\t\tpart automobile {  \n\t\t\tport documentCmdPort: ~DocumentCmdPort;  \n\t\t\tport quantityPort: QuantityPort;  \n\t\t\tport torquePort: TorquePort;  \n\t\t\tperform manageDocuments.addDocument {  \n\t\t\t\tin addDoc = documentCmdPort.addDoc;  \n\t\t\t\tout quantity = quantityPort.quantity;  \n\t\t\t\tout torque = torquePort.torque;  \n\t\t\t}  \n\t\t\tperform manageDocuments.queryDocument {  \n\t\t\t\tin query = documentCmdPort.query;  \n\t\t\t\tout quantity = quantityPort.quantity;  \n\t\t\t\tout torque = torquePort.torque;  \n\t\t\t}  \n\t\t\tperform manageDocuments.archiveDocument {  \n\t\t\t\tin archive = documentCmdPort.archive;  \n\t\t\t}  \n\t\t\tperform managePhysicalQuantity.setStandard {  \n\t\t\t\tout quantity = quantityPort.quantity;  \n\t\t\t}  \n\t\t\tperform manageTorque.defineTorque {  \n\t\t\t\tout torque = torquePort.torque;  \n\t\t\t}  \n\t\t}  \n\t\tpart car {  \n\t\t\tport aliasCmdPort: ~AliasCmdPort;  \n\t\t\tport documentCmdPort: ~DocumentCmdPort;  \n\t\t\tinterface automobileToCar connect automobile.documentCmdPort to car.documentCmdPort {  \n\t\t\t\tref flow references manageAlias.aliasSyncFlow  \n\t\t\t\t\tfrom source.addDoc to target.addDoc;  \n\t\t\t\tref flow references manageAlias.aliasSyncFlow  \n\t\t\t\t\tfrom source.query to target.query;  \n\t\t\t\tref flow references manageAlias.aliasSyncFlow  \n\t\t\t\t\tfrom source.archive to target.archive;  \n\t\t\t}  \n\t\t\tperform manageAlias.syncAlias {  \n\t\t\t\tin carAlias = aliasCmdPort.carAlias;  \n\t\t\t\tout addDoc = documentCmdPort.addDoc;  \n\t\t\t\tout query = documentCmdPort.query;  \n\t\t\t\tout archive = documentCmdPort.archive;  \n\t\t\t}  \n\t\t}  \n\t\tpart physicalQuantityManager {  \n\t\t\tport quantityPort: ~QuantityPort;  \n\t\t\tperform managePhysicalQuantity.referenceStandard {  \n\t\t\t\tin quantity = quantityPort.quantity;  \n\t\t\t}  \n\t\t}  \n\t\tpart torqueManager {  \n\t\t\tport torquePort: ~TorquePort;  \n\t\t\tperform manageTorque.applyISQStandard {  \n\t\t\t\tin torque = torquePort.torque;  \n\t\t\t}  \n\t\t}  \n\t\tpart documentRepository {  \n\t\t\tport documentCmdPort: ~DocumentCmdPort;  \n\t\t\tport contentPort: DocumentContentPort;  \n\t\t\tperform manageDocuments.storeDocument {  \n\t\t\t\tin addDoc = documentCmdPort.addDoc;  \n\t\t\t\tout content = contentPort.content;  \n\t\t\t}  \n\t\t\tperform manageDocuments.retrieveDocument {  \n\t\t\t\tin query = documentCmdPort.query;  \n\t\t\t\tout content = contentPort.content;  \n\t\t\t}  \n\t\t\tperform manageDocuments.storeArchive {  \n\t\t\t\tin archive = documentCmdPort.archive;  \n\t\t\t}  \n\t\t}  \n\t}  \n\taction manageDocuments {  \n\t\taction sendDocumentCmd { out addDoc: AutomobileInfo; out query: AutomobileInfo; out archive: AutomobileInfo; }  \n\t\taction addDocument { in addDoc: AutomobileInfo; out quantity: PhysicalQuantity; out torque: TorqueValue; }  \n\t\taction queryDocument { in query: AutomobileInfo; out quantity: PhysicalQuantity; out torque: TorqueValue; }  \n\t\taction archiveDocument { in archive: AutomobileInfo; }  \n\t\taction storeDocument { in addDoc: AutomobileInfo; out content: ExplanatoryDocument; }  \n\t\taction retrieveDocument { in query: AutomobileInfo; out content: ExplanatoryDocument; }  \n\t\taction storeArchive { in archive: AutomobileInfo; }  \n\t\tsuccession flow addDocumentFlow from sendDocumentCmd.addDoc to addDocument.addDoc;  \n\t\tsuccession flow queryFlow from sendDocumentCmd.query to queryDocument.query;  \n\t\tsuccession flow archiveFlow from sendDocumentCmd.archive to archiveDocument.archive;  \n\t\tsuccession flow documentStorageFlow from addDocument.addDoc to storeDocument.addDoc;  \n\t\tsuccession flow documentRetrievalFlow from queryDocument.query to retrieveDocument.query;  \n\t\tsuccession flow archiveStorageFlow from archiveDocument.archive to storeArchive.archive;  \n\t}  \n\taction managePhysicalQuantity {  \n\t\taction setStandard { out quantity: PhysicalQuantity; }  \n\t\taction referenceStandard { in quantity: PhysicalQuantity; }  \n\t\tsuccession flow quantityFlow from setStandard.quantity to referenceStandard.quantity;  \n\t}  \n\taction manageTorque {  \n\t\taction defineTorque { out torque: TorqueValue; }  \n\t\taction applyISQStandard { in torque: TorqueValue; }  \n\t\tsuccession flow torqueFlow from defineTorque.torque to applyISQStandard.torque;  \n\t}  \n\taction manageAlias {  \n\t\taction sendCarAlias { out carAlias: CarInfo; }  \n\t\taction syncAlias { in carAlias: CarInfo; out addDoc: AutomobileInfo; out query: AutomobileInfo; out archive: AutomobileInfo; }  \n\t\taction aliasFlow { from sendCarAlias.carAlias to syncAlias.carAlias; }  \n\t}  \n}",
    "package 'AutomobileSystem' {\n\tattribute def Automobile;\n\tattribute def Car = Automobile;\n\tattribute def TorqueValue;\n\tattribute def Torque = TorqueValue;\n\tport def TorquePort {\n\t\tout torque: TorqueValue;\n\t}\n\tpart context {\n\t\tpart automobile {\n\t\t\talias Car;\n\t\t\tport torquePort: TorquePort;\n\t\t\tperform manageAutomobileData.receiveTorque {\n\t\t\t\tin torque = torquePort.torque;\n\t\t\t}\n\t\t}\n\t\tpart physicalQuantityImporter {\n\t\t\tport torquePort: ~TorquePort;\n\t\t\tperform manageAutomobileData.importTorque {\n\t\t\t\tout torque = torquePort.torque;\n\t\t\t}\n\t\t}\n\t\tinterface automobileToImporter connect automobile.torquePort to physicalQuantityImporter.torquePort {\n\t\t\tref flow references manageAutomobileData.torqueFlow\n\t\t\t\tfrom source.torque to target.torque;\n\t\t}\n\t}\n\taction manageAutomobileData {\n\t\taction importTorque { out torque: TorqueValue; }\n\t\tsuccession flow torqueFlow from importTorque.torque to receiveTorque.torque;\n\t\taction receiveTorque { in torque: TorqueValue; }\n\t}\n}",
    "package 'VehicleSystem' {\n    value type CylinderCount;\n    block def Vehicle;\n    block def Engine;\n    block def Cylinder;\n    \n    part context {\n        part smallVehicle {\n            part engine: Engine;\n            constraint c1: engine.cylinders->size() = 4;\n        }\n        part largeVehicle {\n            part engine: Engine;\n            constraint c2: engine.cylinders->size() = 6;\n        }\n    }\n    \n    block def Vehicle {\n        part engine: Engine;\n    }\n    \n    block def Engine {\n        part cylinders: Cylinder[4..6];\n    }\n}",
    "package 'FuelManagementSystem' {\n\tattribute def FuelSupply;\n\tattribute def FuelReturn;\n\tattribute def FuelTemperature;\n\tport def FuelSupplyPort {\n\t\tout fuelSupply : FuelSupply;\n\t}\n\tport def FuelReturnPort {\n\t\tout fuelReturn : FuelReturn;\n\t}\n\tport def TemperaturePort {\n\t\tout temperature : FuelTemperature;\n\t}\n\tpart context {\n\t\tpart fuelTank {\n\t\t\tport fuelSupplyPort: FuelSupplyPort;\n\t\t\tperform fuelManagementRegion.deliverFuel {\n\t\t\t\tout fuelSupply = fuelSupplyPort.fuelSupply;\n\t\t\t}\n\t\t}\n\t\tinterface fuelTankToInterface connect fuelTank.fuelSupplyPort to fuelInterfaces.fuelSupplyPort {\n\t\t\tref flow references fuelManagementRegion.fuelSupplyFlow\n\t\t\t\tfrom source.fuelSupply to target.fuelSupply;\n\t\t}\n\t\tinterface fuelInterfacesToEngine connect fuelInterfaces.fuelReturnPort to engine.fuelReturnPort {\n\t\t\tref flow references fuelManagementRegion.fuelReturnFlow\n\t\t\t\tfrom source.fuelReturn to target.fuelReturn;\n\t\t}\n\t\tpart fuelInterfaces {\n\t\t\tport fuelSupplyPort: ~FuelSupplyPort;\n\t\t\tport fuelReturnPort: ~FuelReturnPort;\n\t\t}\n\t\tpart engine {\n\t\t\tport fuelSupplyPort: FuelSupplyPort;\n\t\t\tport fuelReturnPort: FuelReturnPort;\n\t\t\tperform fuelManagementRegion.consumeFuel {\n\t\t\t\tin fuelSupply = fuelSupplyPort.fuelSupply;\n\t\t\t\tout fuelReturn = fuelReturnPort.fuelReturn;\n\t\t\t}\n\t\t}\n\t\tpart fuelManagementSystem {\n\t\t\tport temperaturePort: TemperaturePort;\n\t\t\tport fuelSupplyPort: FuelSupplyPort;\n\t\t\tport fuelReturnPort: FuelReturnPort;\n\t\t\tperform fuelManagementRegion.monitorTemperature {\n\t\t\t\tout temperature = temperaturePort.temperature;\n\t\t\t}\n\t\t\tperform fuelManagementRegion.manageFuelFlow {\n\t\t\t\tin temperature = temperaturePort.temperature;\n\t\t\t\tout fuelSupply = fuelSupplyPort.fuelSupply;\n\t\t\t\tout fuelReturn = fuelReturnPort.fuelReturn;\n\t\t\t}\n\t\t}\n\t}\n\taction fuelManagementRegion {\n\t\taction deliverFuel { out fuelSupply: FuelSupply; }\n\t\taction consumeFuel { in fuelSupply: FuelSupply; out fuelReturn: FuelReturn; }\n\t\tsuccession flow fuelSupplyFlow from manageFuelFlow.fuelSupply to deliverFuel.fuelSupply;\n\t\tsuccession flow fuelReturnFlow from manageFuelFlow.fuelReturn to consumeFuel.fuelReturn;\n\t\taction monitorTemperature { out temperature: FuelTemperature; }\n\t\tsuccession flow temperatureFlow from monitorTemperature.temperature to manageFuelFlow.temperature;\n\t\taction manageFuelFlow { \n\t\t\tin temperature: FuelTemperature; \n\t\t\tout fuelSupply: FuelSupply; \n\t\t\tout fuelReturn: FuelReturn; \n\t\t}\n\t}\n}",
    "package 'VehicleStructuralArchitecture' {\n\tattribute def Mass;\n\tattribute def SteeringAngle;\n\tpart def Vehicle {\n\t\tattribute mass: Mass;\n\t\tpart frontAxleAssembly: AxleAssembly;\n\t\tpart rearAxleAssembly: AxleAssembly;\n\t}\n\tpart def AxleAssembly {\n\t\tpart axle: Axle;\n\t\tpart leftWheel: Wheel;\n\t\tpart rightWheel: Wheel;\n\t}\n\tpart def Axle {\n\t}\n\tpart def FrontAxle extends Axle {\n\t\tattribute steeringAngle: SteeringAngle;\n\t}\n\tpart def RearAxle extends Axle {\n\t}\n\tpart def Wheel {\n\t}\n\tpart context {\n\t\tpart vehicle {\n\t\t\tpart frontAxleAssembly: AxleAssembly {\n\t\t\t\tpart axle: FrontAxle;\n\t\t\t\tpart leftWheel: Wheel;\n\t\t\t\tpart rightWheel: Wheel;\n\t\t\t};\n\t\t\tpart rearAxleAssembly: AxleAssembly {\n\t\t\t\tpart axle: RearAxle;\n\t\t\t\tpart leftWheel: Wheel;\n\t\t\t\tpart rightWheel: Wheel;\n\t\t\t};\n\t\t}\n\t}\n}"
]