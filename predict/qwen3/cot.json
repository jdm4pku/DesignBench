[
    "package VehicleSystem {\n  block Vehicle {\n    property mass : Number;\n    property currentStatus : Status;\n    part engine : Engine;\n    reference driver : Driver [0..1];\n  }\n\n  block Status {\n    property gearSetting : String;\n    property acceleratorPedalPosition : Number;\n  }\n\n  block Engine {\n  }\n\n  block Driver {\n  }\n}\n```",
    "package Vehicles {\n  class Vehicle\n  class Personnel\n  class Engine\n\n  class ManuallyOperatedVehicle : Vehicle {\n    driver: Personnel [1]\n  }\n\n  class PoweredVehicle : Vehicle {\n    engine: Engine [1]\n  }\n\n  class ManuallyOperatedPoweredVehicle : ManuallyOperatedVehicle, PoweredVehicle\n}\n```",
    "package VehicleStructure {\n  class VehicleComponent {\n  }\n\n  class Engine extends VehicleComponent {\n  }\n\n  class Transmission extends VehicleComponent {\n  }\n\n  class Wheel extends VehicleComponent {\n  }\n\n  class Vehicle {\n    part engine : Engine [1..1]\n    part transmission : Transmission [1..1]\n    part wheel : Wheel [4..4]\n  }\n}\n```",
    "package VehicleSystem {\n  class Vehicle {\n    part engine : Engine;\n  }\n\n  class Engine {\n    part functionalSubsystems : FunctionalSubsystems [1..1];\n  }\n\n  class FunctionalSubsystems {\n    part cylinders : Cylinder [1..*];\n  }\n\n  class SmallVehicle extends Vehicle {\n    redefines engine : SmallEngine;\n  }\n\n  class LargeVehicle extends Vehicle {\n    redefines engine : LargeEngine;\n  }\n\n  class SmallEngine extends Engine {\n    redefines functionalSubsystems : FunctionalSubsystems;\n    constraint SmallEngineCylindersConstraint {\n      self.functionalSubsystems.cylinders->size() = 4;\n    }\n  }\n\n  class LargeEngine extends Engine {\n    redefines functionalSubsystems : FunctionalSubsystems;\n    constraint LargeEngineCylindersConstraint {\n      self.functionalSubsystems.cylinders->size() = 6;\n    }\n  }\n\n  class Cylinder {\n  }\n}\n```",
    "enum Color {\n  Green,\n  Yellow,\n  Red\n}\n\nblock TrafficSignal {\n  color : Color;\n}\n\nblock AlwaysGreenTrafficSignal {\n  base TrafficSignal;\n  constraint color = Green;\n}\n```",
    "package InformationClassificationModel {\n  block InformationLevel {\n    name: String;\n    code: String;\n    color: String;\n  }\n\n  block GradeLevel {\n    grade: String;\n    points: Double;\n  }\n\n  value unclassified: InformationLevel {\n    name = \"Unclassified\";\n    code = \"uncl\";\n    color = \"green\";\n  }\n\n  value confidential: InformationLevel {\n    name = \"Confidential\";\n    code = \"conf\";\n    color = \"yellow\";\n  }\n\n  value secret: InformationLevel {\n    name = \"Secret\";\n    code = \"secr\";\n    color = \"red\";\n  }\n\n  value gradeA: GradeLevel {\n    grade = \"A\";\n    points = 4.0;\n  }\n\n  value gradeB: GradeLevel {\n    grade = \"B\";\n    points = 3.0;\n  }\n\n  value gradeC: GradeLevel {\n    grade = \"C\";\n    points = 2.0;\n  }\n\n  value gradeD: GradeLevel {\n    grade = \"D\";\n    points = 1.0;\n  }\n\n  value gradeF: GradeLevel {\n    grade = \"F\";\n    points = 0.0;\n  }\n}",
    "block Vehicle {\n  part engine : Engine;\n}\n\nblock Engine {\n  part cylinders : Cylinder[*];\n}\n\nblock SmallVehicle specializes Vehicle {\n  redef part engine : Engine;\n  constraint c1 : EngineCylinderConstraint;\n}\n\nblock EngineCylinderConstraint extends ConstraintBlock {\n  parameter numCylinders : Integer = 4;\n  constraint engine.cylinders.size() == numCylinders;\n}\n\nblock LargeVehicle specializes Vehicle {\n  redef part engine : Engine;\n  constraint c2 : EngineCylinderConstraint;\n}\n\nblock EngineCylinderConstraint for LargeVehicle {\n  parameter numCylinders : Integer = 6;\n}",
    "module VehicleModel {\n    block Vehicle {\n        part qualityAttributes : QualityAttributes;\n        part driver : Driver;\n        part fuelTank : FuelTank;\n    }\n\n    block QualityAttributes {\n        property reliability : String;\n        property performance : String;\n        property safety : String;\n    }\n\n    block Driver {\n        property name : String;\n        property licenseNumber : String;\n        property experienceLevel : Integer;\n    }\n\n    block FuelTank {\n        property capacity : Double;\n        property fuelType : Fuel;\n    }\n\n    block Fuel {\n        property type : String;\n        property energyDensity : Double;\n    }\n\n    block Personnel {\n        property role : String;\n        property id : String;\n        property assignedVehicles : Set<Vehicle>;\n    }\n\n    association VehicleDriverAssociation {\n        member end driver : Driver [1] owned by Vehicle [1];\n    }\n\n    association FuelTankFuelAssociation {\n        member end fuel : Fuel [1] owned by FuelTank [1];\n    }\n\n    association PersonnelVehicleAssociation {\n        member end vehicles : Vehicle [0..*] linked to Personnel [1];\n    }\n}\n```",
    "block WheelAssembly {\n  part wheelBearingUnit: WheelBearingUnit;\n  part tireAssembly: TireAssembly;\n}\n\nblock TireAssembly {\n  part tire: Tire;\n  part bead[2]: Bead;\n  part hub: Hub;\n  connector beadToRim[2] {\n    bead: Bead;\n    rim: Rim;\n  }\n}\n\nblock Hub {\n  part rim[2]: Rim;\n  part boltMountingHole[*]: BoltMountingHole;\n  part threadedHole[*]: ThreadedHole;\n  part boltConnection[*]: BoltConnection;\n  connector mountingToThreaded[*] {\n    boltMountingHole: BoltMountingHole;\n    threadedHole: ThreadedHole;\n  }\n}\n\nblock WheelBearingUnit {}\nblock Tire {}\nblock Bead {}\nblock Rim {}\nblock BoltMountingHole {}\nblock ThreadedHole {}\n\nconnector BoltConnection {\n  part mountingHole: BoltMountingHole;\n  part threadedHole: ThreadedHole;\n}\n```",
    "block FuelTankAssembly {\n  port supplyPort: FuelFlow;\n  port returnPort: FuelFlow;\n  port temperaturePort: TemperatureData;\n}\n\nblock Engine {\n  port supplyPort: FuelFlow;\n  port returnPort: FuelFlow;\n  port temperaturePort: TemperatureData;\n}\n\nblock FuelManagementSystem {\n  part fuelTank: FuelTankAssembly;\n  part engine: Engine;\n  port monitoringPort: TemperatureData;\n}\n\nflow FuelFlow {\n  // No properties defined for this example\n}\n\nflow TemperatureData {\n  // No properties defined for this example\n}\n\nsystem FuelManagementSystem {\n  part fuelTank: FuelTankAssembly;\n  part engine: Engine;\n  port monitoringPort: TemperatureData;\n\n  flow FuelFlow from fuelTank.supplyPort to engine.supplyPort;\n  flow FuelFlow from engine.returnPort to fuelTank.returnPort;\n  flow TemperatureData from fuelTank.temperaturePort to monitoringPort;\n  flow TemperatureData from engine.temperaturePort to monitoringPort;\n}\n```",
    "«class» Vehicle\n  mass: Mass = 1750 kg\n  frontAxle: «part» FrontAxle [1]\n  rearAxle: ««part»» RearAxle [1]\n«end class»\n\n«class» FrontAxle\n  mass: Mass\n  tires: ««part»» Tire [2] (ordered)\n«end class»\n\n«class» RearAxle\n  mass: Mass\n  tires: ««part»» Tire [2] (ordered)\n«end class»\n\n«class» Tire\n  mass: Mass\n«end class»\n\n«class» DedicatedFrontAxle : FrontAxle\n  steeringAngle: Angle\n  mass: Mass = 250 kg\n«end class»\n\n«class» Vehicle1_c1 : Vehicle\n  mass: Mass = 2000 kg\n  dedicatedFrontAxle: ««part»» DedicatedFrontAxle [1]\n  rearAxle: ««part»» RearAxle [1]\n«end class»\n\n«class» Mass\n«end class»\n\n«class» Angle\n«end class»",
    "model CouplingSystem {\n  block Vehicle {\n    reference hitchBall: CouplingHitch.ball;\n  }\n\n  block Trailer {\n    reference connector: CouplingHitch.connector;\n  }\n\n  block CouplingHitch {\n    part ball: Ball;\n    part connector: Connector;\n    connector BallToConnector(ball, connector);\n  }\n\n  block Ball {\n    // No properties needed for this example\n  }\n\n  block Connector {\n    // No properties needed for this example\n  }\n\n  block CouplingSystem {\n    part vehicle: Vehicle;\n    part trailer: Trailer;\n    part hitch: CouplingHitch;\n    connector VehicleToHitchBall(vehicle.hitchBall, hitch.ball);\n    connector TrailerToHitchConnector(trailer.connector, hitch.connector);\n  }\n}\n```",
    "module VehiclePowerTransmission {\n    interface ControlSignal {}\n    interface PowerPort {}\n    interface ClutchPort {}\n    interface RoadInterface {}\n\n    block Engine {\n        port fuelCommandPort: ControlSignal\n        port powerPort: PowerPort\n        port clutchPort: ClutchPort\n    }\n\n    block Transmission {\n        port clutchPort: ClutchPort\n        port powerPort: PowerPort\n    }\n\n    block Driveshaft {\n        port inputPowerPort: PowerPort\n        port outputPowerPort: PowerPort\n    }\n\n    block Differential {\n        port inputPowerPort: PowerPort\n        port leftHalfshaftPort: PowerPort\n        port rightHalfshaftPort: PowerPort\n    }\n\n    block RearAxleAssembly {\n        part differential: Differential\n        port leftHalfshaftPort: PowerPort\n        port rightHalfshaftPort: PowerPort\n        port roadInterfacePort: RoadInterface\n    }\n\n    block Wheel {\n        port halfshaftPort: PowerPort\n        port roadInterfacePort: RoadInterface\n    }\n\n    block VehiclePowerSystem {\n        part engine: Engine\n        part transmission: Transmission\n        part clutch: ClutchPort\n        part driveshaft: Driveshaft\n        part rearAxle: RearAxleAssembly\n        part leftWheel: Wheel\n        part rightWheel: Wheel\n\n        connector engineToTransmission {\n            engine.clutchPort -> transmission.clutchPort\n            engine.powerPort -> transmission.powerPort\n        }\n\n        connector transmissionToDriveshaft {\n            transmission.powerPort -> driveshaft.inputPowerPort\n        }\n\n        connector driveshaftToRearAxle {\n            driveshaft.outputPowerPort -> rearAxle.leftHalfshaftPort\n            driveshaft.outputPowerPort -> rearAxle.rightHalfshaftPort\n        }\n\n        connector rearAxleToDifferential {\n            rearAxle.leftHalfshaftPort -> rearAxle.differential.leftHalfshaftPort\n            rearAxle.rightHalfshaftPort -> rearAxle.differential.rightHalfshaftPort\n        }\n\n        connector differentialToWheels {\n            rearAxle.differential.leftHalfshaftPort -> leftWheel.halfshaftPort\n            rearAxle.differential.rightHalfshaftPort -> rightWheel.halfshaftPort\n        }\n\n        connector wheelsToRoad {\n            leftWheel.roadInterfacePort -> rearAxle.roadInterfacePort\n            rightWheel.roadInterfacePort -> rearAxle.roadInterfacePort\n        }\n    }\n}\n```",
    "sysml\ninterface InterfacePE;\n\ninterface InterfacePF;\n\nblock C1 {\n  port pb : InterfacePE;\n  port pc : InterfacePE;\n}\n\nblock C2 {\n  port pc : InterfacePE;\n  port pb : InterfacePE;\n}\n\nblock C3 {\n  port pd : InterfacePF;\n  port pf : InterfacePF;\n}\n\nblock C4 {\n  port pe : InterfacePF;\n  port pb : InterfacePF;\n}\n\nblock SubsystemB11 {\n  part c1 : C1;\n  part c2 : C2;\n  connect c1.pc to c2.pb;\n  bind c1.pb to InterfacePE;\n}\n\nblock SubsystemB12 {\n  part c3 : C3;\n  part c4 : C4;\n  connect c3.pf to c4.pb;\n  bind c3.pd to InterfacePF;\n}\n\nblock ModuleB21 {\n  part c1 : C1;\n  part c2 : C2;\n  part c3 : C3;\n  part c4 : C4;\n  connect c1.pb to c3.pd;\n  connect c2.pc to c4.pb;\n}\n\nblock ModuleB22 {\n  part c1 : C1;\n  part c2 : C2;\n  part c3 : C3;\n  part c4 : C4;\n  connect c1.pb to c4.pb;\n  connect c2.pc to c3.pd;\n}\n\nblock System {\n  part b11 : SubsystemB11;\n  part b12 : SubsystemB12;\n  part b21 : ModuleB21;\n  part b22 : ModuleB22;\n  connect b11.p1 to b12.p1;\n  connect b21.c1.pb to b22.c3.pd;\n  connect b21.c2.pc to b22.c4.pb;\n}\n```",
    "module AutomotivePowertrain {\n    block PowertrainSystem {\n        part engine: Engine;\n        part transmission: Transmission;\n        part driveshaft: Driveshaft;\n        part leftWheel: Wheel;\n        part rightWheel: Wheel;\n    }\n\n    block Engine {\n        port commandPort: CommandPort;\n        port torquePort: TorquePort;\n\n        behavior startStopControl: Function {\n            input startCommand: Boolean;\n            input stopCommand: Boolean;\n            output engineState: Boolean;\n        }\n\n        behavior generateTorque: Function {\n            input fuelCommand: Float;\n            input engineState: Boolean;\n            output engineTorque: Float;\n            constraint engineMustBeStarted: engineState == true;\n        }\n    }\n\n    block Transmission {\n        port inputTorquePort: TorquePort;\n        port outputTorquePort: TorquePort;\n\n        behavior amplifyTorque: Function {\n            input engineTorque: Float;\n            output amplifiedTorque: Float;\n        }\n    }\n\n    block Driveshaft {\n        port inputTorquePort: TorquePort;\n        port leftOutputPort: TorquePort;\n        port rightOutputPort: TorquePort;\n\n        behavior distributeTorque: Function {\n            input amplifiedTorque: Float;\n            output leftTorque: Float;\n            output rightTorque: Float;\n        }\n    }\n\n    block Wheel {\n        port drivingForcePort: ForcePort;\n\n        behavior applyDrivingForce: Function {\n            input torque: Float;\n            output drivingForce: Float;\n        }\n    }\n\n    block CommandPort {\n        feature startCommand: Boolean;\n        feature stopCommand: Boolean;\n        feature fuelCommand: Float;\n    }\n\n    block TorquePort {\n        feature torque: Float;\n    }\n\n    block ForcePort {\n        feature force: Float;\n    }\n\n    flow PowerFlow {\n        feature torque: Float;\n    }\n\n    flow CommandFlow {\n        feature startCommand: Boolean;\n        feature stopCommand: Boolean;\n        feature fuelCommand: Float;\n    }\n\n    constraintblock EngineConstraint {\n        constraint engineMustBeStarted: engineState == true;\n    }\n\n    constraintblock PowertrainConstraint {\n        constraint shutdownSuspendsPower: engineState == false implies drivingForce == 0;\n    }\n\n    model PowertrainModel {\n        part system: PowertrainSystem;\n\n        flow commandFlow: CommandFlow;\n        flow powerFlow: PowerFlow;\n\n        connection system.engine.commandPort <- commandFlow;\n        connection system.engine.torquePort -> system.transmission.inputTorquePort;\n        connection system.transmission.outputTorquePort -> system.driveshaft.inputTorquePort;\n        connection system.driveshaft.leftOutputPort -> system.leftWheel.drivingForcePort;\n        connection system.driveshaft.rightOutputPort -> system.rightWheel.drivingForcePort;\n\n        function system.engine.startStopControl {\n            commandFlow.startCommand -> system.engine.startStopControl.startCommand;\n            commandFlow.stopCommand -> system.engine.startStopControl.stopCommand;\n            system.engine.startStopControl.engineState -> system.engine.generateTorque.engineState;\n        }\n\n        function system.engine.generateTorque {\n            commandFlow.fuelCommand -> system.engine.generateTorque.fuelCommand;\n            system.engine.generateTorque.engineTorque -> powerFlow.torque;\n        }\n\n        function system.transmission.amplifyTorque {\n            powerFlow.torque -> system.transmission.amplifyTorque.engineTorque;\n            system.transmission.amplifyTorque.amplifiedTorque -> powerFlow.torque;\n        }\n\n        function system.driveshaft.distributeTorque {\n            powerFlow.torque -> system.driveshaft.distributeTorque.amplifiedTorque;\n            system.draveshaft.distributeTorque.leftTorque -> powerFlow.torque;\n            system.draveshaft.distributeTorque.rightTorque -> powerFlow.torque;\n        }\n\n        function system.leftWheel.applyDrivingForce {\n            powerFlow.torque -> system.leftWheel.applyDrivingForce.torque;\n            system.leftWheel.applyDrivingForce.drivingForce -> powerFlow.force;\n        }\n\n        function system.rightWheel.applyDrivingForce {\n            powerFlow.torque -> system.rightWheel.applyDrivingForce.torque;\n            system.rightWheel.applyDrivingForce.drivingForce -> powerFlow.force;\n        }\n\n        constraint system.engine.generateTorque.engineMustBeStarted;\n        constraint system.PowertrainConstraint.shutdownSuspendsPower;\n    }\n}\n```",
    "module AutomotivePowertrain {\n    block PowertrainControlSystem {\n        property fuelControlCommand : Boolean;\n        property stallSignal : Boolean;\n        property engineTorque : Real;\n        property amplifiedTorque : Real;\n        property transmittedTorque : Real;\n        property wheelTorque : Real;\n\n        part engine : Engine;\n        part torqueAmplifier : TorqueAmplifier;\n        part transmission : Transmission;\n        part driveWheels : DriveWheels;\n\n        behavior startEngine(fuelControlCommand : Boolean) : Boolean {\n            action startEngineAction {\n                if (fuelControlCommand) {\n                    return true;\n                } else {\n                    return false;\n                }\n            }\n        }\n\n        behavior generateTorque(engineRunning : Boolean) : Real {\n            action generateTorqueAction {\n                if (engineRunning) {\n                    engineTorque = 100.0; // Example torque value\n                    return engineTorque;\n                } else {\n                    return 0.0;\n                }\n            }\n        }\n\n        behavior amplifyTorque(inputTorque : Real) : Real {\n            action amplifyTorqueAction {\n                amplifiedTorque = inputTorque * 1.5; // Example amplification factor\n                return amplifiedTorque;\n            }\n        }\n\n        behavior transmitTorque(amplifiedTorque : Real) : Real {\n            action transmitTorqueAction {\n                transmittedTorque = amplifiedTorque * 0.9; // Example transmission loss\n                return transmittedTorque;\n            }\n        }\n\n        behavior distributeTorque(transmittedTorque : Real) : Real {\n            action distributeTorqueAction {\n                wheelTorque = transmittedTorque / 2.0; // Example distribution to two wheels\n                return wheelTorque;\n            }\n        }\n\n        behavior handleStall(stallDetected : Boolean) {\n            action handleStallAction {\n                if (stallDetected) {\n                    engine.stop();\n                    torqueAmplifier.disengage();\n                    transmission.neutral();\n                }\n            }\n        }\n    }\n\n    block Engine {\n        action start();\n        action stop();\n    }\n\n    block TorqueAmplifier {\n        action engage();\n        action disengage();\n    }\n\n    block Transmission {\n        action shiftGear(gear : Integer);\n        action neutral();\n    }\n\n    block DriveWheels {\n        action applyTorque(torque : Real);\n    }\n\n    constraint PowertrainConstraint {\n        engineTorque >= 0.0;\n        amplifiedTorque >= engineTorque;\n        transmittedTorque <= amplifiedTorque;\n        wheelTorque > 0.0 when transmittedTorque > 0.0;\n    }\n}\n```",
    "module PowertrainManagement {\n    block PowertrainManagementSystem {\n        property engine : Engine;\n        property transmission : Transmission;\n        property wheels : Wheel[*];\n        constraint energyEfficiency : EnergyEfficiencyConstraint;\n    }\n\n    block Engine {\n        function generateEngineTorque(fuelCommand : Real) returns (engineTorque : Real);\n    }\n\n    block Transmission {\n        function amplifyAndTransmitTorque(engineTorque : Real) returns (transmissionTorque : Real);\n    }\n\n    block Wheel {\n        function distributeTorqueToWheels(transmissionTorque : Real) returns (wheelTorque : Real);\n    }\n\n    constraint block EnergyEfficiencyConstraint {\n        // Constraint for energy efficiency improvement\n    }\n\n    signal EngineStartSignal;\n    signal EngineShutdownSignal;\n\n    behavior PowertrainControlBehavior {\n        stateMachine {\n            state EngineOn {\n                entry / engine.generateEngineTorque(driver.fuelCommand);\n                do / transmission.amplifyAndTransmitTorque(engine.engineTorque);\n                do / wheels.distributeTorqueToWheels(transmission.transmissionTorque);\n            }\n            state EngineOff {\n                exit / terminatePowerOutputProcess();\n            }\n            transition from EngineOff to EngineOn when (EngineStartSignal);\n            transition from EngineOn to EngineOff when (EngineShutdownSignal);\n        }\n    }\n\n    function terminatePowerOutputProcess();\n}\n```",
    "block Vehicle  \n  structuralFrame: StructuralFrame  \n  hitchBall: HitchBall  \nend  \n\nblock Trailer  \n  structuralFrame: StructuralFrame  \n  trailerCoupler: TrailerCoupler  \nend  \n\nblock HitchBall  \n  satisfies: PowerConnectionMechanism  \nend  \n\nblock TrailerCoupler  \n  satisfies: PowerConnectionMechanism  \nend  \n\nblock HitchingMechanism  \n  behavior: ConnectBehavior  \n  behavior: DisconnectBehavior  \nend  \n\nbehavior ConnectBehavior  \n  activity: ConnectProcess  \n    action: AttachCouplerToHitchBall  \n    action: EngagePowerCoupling  \n  end  \nend  \n\nbehavior DisconnectBehavior  \n  activity: DisconnectProcess  \n    action: DisengagePowerCoupling  \n    action: DetachCouplerFromHitchBall  \n  end  \nend  \n\nrequirementset PowerConnectionRequirements  \n  constraint: SafetyConstraint  \n    \"Connection must ensure electrical isolation during disengagement\"  \n  constraint: ReliabilityConstraint  \n    \"Mechanism must withstand 10,000 connection/disconnection cycles without failure\"  \n  constraint: FlexibilityConstraint  \n    \"System must support rapid connection/disconnection in 30 seconds or less\"  \n\n  requirement: SafeConnectionRequirement  \n    \"The system shall provide safe power coupling\"  \n    satisfies: SafetyConstraint  \n\n  requirement: ReliableOperationRequirement  \n    \"The system shall maintain reliable power transfer\"  \n    satisfies: ReliabilityConstraint  \n\n  requirement: FlexibleUsageRequirement  \n    \"The system shall allow flexible vehicle-trailer combinations\"  \n    satisfies: FlexibilityConstraint  \nend  \n\nblock StructuralFrame  \n  // Base structural block for both vehicle and trailer  \nend  \n\nblock PowerConnectionMechanism  \n  // Abstract block for power coupling interface  \nend",
    "block VehicleTrailerConnectionSystem\n  parts:\n    vehicle: Vehicle\n    trailer: Trailer\n  properties:\n    connectionStatus: Boolean\n  behaviors:\n    behavior: VehicleTrailerBehavior\nend VehicleTrailerConnectionSystem\n\nblock Vehicle\n  parts:\n    chassis: Chassis\n    towBall: TowBall\nend Vehicle\n\nblock Chassis\n  parts:\n    towBall: TowBall\nend Chassis\n\nblock TowBall\nend TowBall\n\nblock Trailer\n  parts:\n    trailerFrame: TrailerFrame\n    coupler: Coupler\nend Trailer\n\nblock TrailerFrame\n  parts:\n    coupler: Coupler\nend TrailerFrame\n\nblock Coupler\nend Coupler\n\nbehavior VehicleTrailerBehavior\n  operations:\n    connectTrailer: Boolean\n    disconnectTrailer: Boolean\n  steps:\n    connectStep: connectTrailer\n      action: vehicle.chassis.towBall.connect(trailer.trailerFrame.coupler)\n      post: connectionStatus = true\n    disconnectStep: disconnectTrailer\n      action: vehicle.chassis.towBall.disconnect(trailer.trailerFrame.coupler)\n      post: connectionStatus = false\nend VehicleTrailerBehavior\n\nconnector hitchConnector\n  ends:\n    vehicleEnd: TowBall\n    trailerEnd: Coupler\nend hitchConnector\n```",
    "model DynamicConnectionModel {\n  block Vehicle {\n    part chassis : Chassis;\n    part towBall : TowBallDevice;\n    connector hitchingConnector : ConnectableElementReference {\n      from towBall;\n      to trailer.coupler;\n      constraint secureLatch : SecureLatchConstraint;\n      constraint smoothSeparation : SmoothSeparationConstraint;\n    }\n    operation hitchTrailer() : Boolean;\n    operation unhitchTrailer() : Boolean;\n  }\n\n  block Trailer {\n    part chassis : Chassis;\n    part coupler : CouplerMechanism;\n    connector couplerConnection : ConnectableElementReference {\n      from coupler;\n      to vehicle.towBall;\n    }\n    operation engageCoupler() : Boolean;\n    operation disengageCoupler() : Boolean;\n  }\n\n  block Chassis {\n    // Base structure for both vehicle and trailer\n  }\n\n  block TowBallDevice {\n    // Physical tow ball component\n  }\n\n  block CouplerMechanism {\n    part internalStructure : InternalStructure;\n    operation engage(towBall : TowBallDevice) : Boolean;\n    operation disengage() : Boolean;\n  }\n\n  block InternalStructure {\n    // Structural components enabling engagement/disengagement\n  }\n\n  constraintBlock SecureLatchConstraint {\n    // Ensures secure connection between tow ball and coupler\n  }\n\n  constraintBlock SmoothSeparationConstraint {\n    // Ensures safe and smooth disconnection\n  }\n\n  relationship R1 : Composition {\n    from Vehicle to Chassis;\n    from Vehicle to TowBallDevice;\n    from Trailer to Chassis;\n    from Trailer to CouplerMechanism;\n    from CouplerMechanism to InternalStructure;\n  }\n\n  relationship R2 : Dependency {\n    from hitchingConnector to secureLatch;\n    from hitchingConnector to smoothSeparation;\n  }\n}",
    "module FuelSystemModel {\n    block FuelTank {\n        port supplyPort: FuelSupplyPort;\n        port returnPort: FuelReturnPort;\n    }\n\n    block Engine {\n        port supplyPort: FuelSupplyPort;\n        port returnPort: FuelReturnPort;\n    }\n\n    block FuelSystem {\n        part fuelTank: FuelTank;\n        part engine: Engine;\n\n        connector fuelSupplyConnector: fuelTank.supplyPort -> engine.supplyPort;\n        connector fuelReturnConnector: engine.returnPort -> fuelTank.returnPort;\n\n        property temperature: Real;\n        constraint temperatureConstraint: temperature <= 80.0;\n\n        property stability: Boolean;\n        property reliability: Boolean;\n    }\n\n    interface FuelSupplyPort {\n        action supplyFuel: (fuel: Real) -> (success: Boolean);\n    }\n\n    interface FuelReturnPort {\n        action returnFuel: (fuel: Real) -> (success: Boolean);\n    }\n\n    behavior FuelSupplyBehavior {\n        action supplyFuel {\n            input fuel: Real;\n            output success: Boolean;\n            success = true;\n        }\n\n        action returnFuel {\n            input fuel: Real;\n            output success: Boolean;\n            success = true;\n        }\n    }\n\n    constraintblock TemperatureConstraint {\n        constraint temperature <= 80.0;\n    }\n\n    constraintblock SystemStabilityConstraint {\n        constraint stability = true;\n    }\n\n    constraintblock SystemReliabilityConstraint {\n        constraint reliability = true;\n    }\n\n    apply FuelSystem.temperatureConstraint to FuelSystem;\n    apply SystemStabilityConstraint to FuelSystem;\n    apply SystemReliabilityConstraint to FuelSystem;\n}\n```",
    "model FuelDeliverySystem {\n  block Fuel {\n    flowProperty quantity : Flow<Mass> {\n      unit = 'kg';\n    };\n  };\n  block StorageTank {\n    part fuel : Fuel;\n    flowPort outputFuel : FlowPort<Mass> {\n      direction = out;\n      unit = 'kg';\n    };\n  };\n  block FuelPump {\n    part fuel : Fuel;\n    flowPort inputFuel : FlowPort<Mass> {\n      direction = in;\n      unit = 'kg';\n    };\n    flowPort outputFuel : FlowPort<Mass> {\n      direction = out;\n      unit = 'kg';\n    };\n  };\n  block VehicleFuelTank {\n    part fuel : Fuel;\n    property maxCapacity : Real {\n      unit = 'kg';\n    };\n    property currentLevel : Real {\n      unit = 'kg';\n    };\n    flowPort inputFuel : FlowPort<Mass> {\n      direction = in;\n      unit = 'kg';\n    };\n  };\n  block FuelDeliverySystem {\n    part storageTank : StorageTank;\n    part fuelPump : FuelPump;\n    part vehicleFuelTank : VehicleFuelTank;\n    flowConnection storageToPump : FlowConnection<Mass> {\n      source = storageTank.outputFuel;\n      target = fuelPump.inputFuel;\n    };\n    flowConnection pumpToVehicle : FlowConnection<Mass> {\n      source = fuelPump.outputFuel;\n      target = vehicleFuelTank.inputFuel;\n    };\n    constraint safeDelivery : Constraint {\n      expression = 'fuelPump.outputFuel.quantity <= vehicleFuelTank.maxCapacity - vehicleFuelTank.currentLevel';\n    };\n    constraint accurateDelivery : Constraint {\n      expression = 'fuelPump.outputFuel.quantity == storageTank.outputFuel.quantity - fuelPump.inputFuel.quantity';\n    };\n    requirement timelyDelivery : Requirement {\n      text = 'Fuel delivery must occur within 5 minutes of vehicle request';\n    };\n  };\n}",
    "package automobileAssembly\n{\n    import sysml.*;\n\n    block Vehicle\n    {\n    }\n\n    block Gearbox\n    {\n    }\n\n    block Engine\n    {\n    }\n\n    block VehicleWithGearbox\n    {\n        part gearbox : Gearbox;\n    }\n\n    block CompleteVehicle\n    {\n        part gearbox : Gearbox;\n        part engine : Engine;\n    }\n\n    activity VehicleAssemblyProcess\n    {\n        action InstallGearboxAction\n        {\n            in vehicle : Vehicle;\n            out vehicleWithGearbox : VehicleWithGearbox;\n        }\n\n        action InstallEngineAction\n        {\n            in vehicleWithGearbox : VehicleWithGearbox;\n            out completeVehicle : CompleteVehicle;\n        }\n\n        sequence\n        {\n            InstallGearboxAction;\n            InstallEngineAction;\n        }\n    }\n}\n```",
    "stateMachine VehicleAStateMachine {\n  state Off {\n    transition to: Starting {\n      trigger: startSignal, brakePedalPressed\n    }\n  }\n  state Starting {\n    transition to: Running {\n      trigger: vehicleOnSignal\n    }\n  }\n  state Running {\n    exit: applyParkingBrake\n    transition to: Degraded {\n      trigger: temperatureExceedsThreshold\n    }\n    transition to: HealthManagement {\n      trigger: healthCheckRequired\n    }\n  }\n  state Degraded {\n    entry: sendOverTemperatureSignal\n    transition to: Normal {\n      trigger: restoreToNormalSignal\n    }\n  }\n  state Maintenance {\n    transition to: Normal {\n      trigger: restoreToNormalSignal\n    }\n  }\n  state HealthManagement {\n    exit: resumeNormalOperation\n    transition to: Running {\n      trigger: healthCheckCompleted\n    }\n  }\n  state Normal {\n    transition to: Running {\n      trigger: vehicleOnSignal\n    }\n  }\n}",
    "package VehicleSystemModel {\n  block VehicleSystem {\n    vehicle: Vehicle;\n    controller: VehicleController;\n    fuel: String;\n    maintenanceInterval: Duration;\n    tempThreshold: Temperature;\n  }\n\n  block Vehicle {\n    stateMachine sm {\n      initial: InitialState;\n      shutdown: State;\n      normal: State;\n      degraded: State;\n\n      transition from initial to shutdown;\n\n      transition from shutdown to normal [brakePressed and startSignalReceived] / selfInspection(), powerSupply();\n\n      transition from normal to degraded [temperature > context.tempThreshold] / sendWarning(), switchToDegraded();\n\n      transition from degraded to normal [faultRecovered] / resumeNormalOperation();\n    }\n  }\n\n  block VehicleController {\n    behavior handleStart(StartSignal signal) {\n      // Logic to process start signal\n    }\n\n    behavior handleShutdown(ShutdownSignal signal) {\n      // Logic to process shutdown signal\n    }\n\n    behavior handleWarning(WarningSignal signal) {\n      // Logic to handle warning and coordinate with health management\n    }\n  }\n\n  block HealthManagement {\n    behavior performMaintenance() {\n      // Regular maintenance logic\n    }\n\n    behavior faultRecovery() {\n      // Fault recovery logic\n    }\n  }\n\n  signal StartSignal;\n  signal ShutdownSignal;\n  signal WarningSignal;\n  signal Temperature;\n  signal Duration;\n  signal BrakePressed;\n  signal FaultRecovered;\n}\n```",
    "package SpatiotemporalSimulation {\n    class Vehicle {\n        property mass : Real;\n        property position : String;\n        property velocity : Real;\n        property acceleration : Real;\n        property state : String;\n    }\n\n    class Road {\n        property slope : Real;\n        property frictionCoefficient : Real;\n    }\n\n    class Snapshot {\n        property time : Duration;\n        property vehicleState : String;\n        property roadState : String;\n        property position : String;\n        property velocity : Real;\n        property acceleration : Real;\n    }\n\n    class SimulationSystem {\n        property vehicle : Vehicle;\n        property road : Road;\n        property snapshots : List<Snapshot>;\n        behavior simulate {\n            parameter startTime : Duration;\n            parameter endTime : Duration;\n            parameter timeStep : Duration;\n            action recordSnapshots(startTime, endTime, timeStep) {\n                for (t in startTime to endTime step timeStep) {\n                    let snapshot = new Snapshot();\n                    snapshot.time = t;\n                    snapshot.vehicleState = vehicle.state;\n                    snapshot.roadState = road.state;\n                    snapshot.position = vehicle.position;\n                    snapshot.velocity = vehicle.velocity;\n                    snapshot.acceleration = vehicle.acceleration;\n                    snapshots.add(snapshot);\n                }\n            }\n        }\n    }\n\n    stateMachine VehicleState {\n        state On {\n            on entry do {\n                vehicle.state = \"On\";\n            }\n            transition to Off when (vehicle.acceleration == 0 and vehicle.velocity == 0);\n        }\n        state Off {\n            on entry do {\n                vehicle.state = \"Off\";\n            }\n            transition to On when (vehicle.acceleration > 0 or vehicle.velocity > 0);\n        }\n    }\n}\n```",
    "block Component1 {}\nblock Component2 {}\nblock Component3 {}\nblock Component4 {}\nblock Component5 {}\nblock Component6 {}\n\nblock SubsystemA {\n  part comp1 : Component1;\n  part comp2 : Component2;\n  part comp3 : Component3;\n}\n\nvariant SubsystemA.Configuration1 {\n  part comp1 : Component1;\n  part comp2 : Component2;\n}\n\nvariant SubsystemA.Configuration2 {\n  part comp2 : Component2;\n  part comp3 : Component3;\n}\n\nblock SubsystemB {\n  part comp4 : Component4;\n  part comp5 : Component5;\n  part comp6 : Component6;\n}\n\nvariant SubsystemB.Configuration1 {\n  part comp4 : Component4;\n  part comp5 : Component5;\n}\n\nvariant SubsystemB.Configuration2 {\n  part comp5 : Component5;\n  part comp6 : Component6;\n}\n\nblock Automobile {\n  part a : SubsystemA;\n  part b : SubsystemB;\n  constraint AutomobileConfigurationConstraint;\n}\n\nconstraint AutomobileConfigurationConstraint {\n  condition: if (a.configuration == SubsystemA.Configuration2) then (b.configuration == SubsystemB.Configuration1) else true;\n}\n\nvariant Automobile.ConfigurationA {\n  part a : SubsystemA.Configuration1;\n  part b : SubsystemB.Configuration1;\n}\n\nvariant Automobile.ConfigurationB {\n  part a : SubsystemA.Configuration2;\n  part b : SubsystemB.Configuration1;\n}\n```",
    "block System  \n  subsystemA: SubsystemA[*]  \n  subsystemB: SubsystemB[*]  \n  constraint: SystemConstraint  \n\n  connection subsystemA.p1 -> subsystemB.p2  \n  connection subsystemB.p1 -> subsystemA.p2  \n\nblock SubsystemA abstract  \n  part1: Part1[*]  \n  part2: Part2[*]  \n  part3: Part3  \n  part4: Part4[*]  \n  part6: Part6  \n\n  p1: Port  \n  p2: Port  \n\nblock SubsystemB abstract  \n  part1: Part1[*]  \n  part2: Part2[*]  \n  part5: Part5  \n  part4: Part4[*]  \n\n  p1: Port  \n  p2: Port  \n\nblock Part1  \nblock Part2  \nblock Part3  \n  p1: Port  \n\nblock Part4  \nblock Part5  \n  p2: Port  \n  behavior: Behavior variant  \n\nblock Part6  \n\nblock VehicleConfigA  \n  vehicleSystem: System  \n  vehicleSystem.subsystemA: SubsystemA  \n  vehicleSystem.subsystemB: SubsystemB  \n\n  vehicleSystem.subsystemA.part1: Part1[2]  \n  vehicleSystem.subsystemA.part2: Part2[1]  \n  vehicleSystem.subsystemA.part3: Part3  \n  vehicleSystem.subsystemA.part4: Part4[3]  \n  vehicleSystem.subsystemA.part6: Part6  \n\n  vehicleSystem.subsystemB.part1: Part1[1]  \n  vehicleSystem.subsystemB.part2: Part2[2]  \n  vehicleSystem.subsystemB.part5: Part5  \n  vehicleSystem.subsystemB.part4: Part4[2]  \n\n  vehicleSystem.subsystemA.p1 -> vehicleSystem.subsystemB.p2  \n  vehicleSystem.subsystemB.p1 -> vehicleSystem.subsystemA.p2  \n\n  vehicleSystem.subsystemB.part5.behavior = BehaviorVariant1  \n\nblock VehicleConfigB  \n  vehicleSystem: System  \n  vehicleSystem.subsystemA: SubsystemA  \n  vehicleSystem.subsystemB: SubsystemB  \n\n  vehicleSystem.subsystemA.part1: Part1[3]  \n  vehicleSystem.subsystemA.part2: Part2[2]  \n  vehicleSystem.subsystemA.part3: Part3  \n  vehicleSystem.subsystemA.part4: Part4[1]  \n  vehicleSystem.subsystemA.part6: Part6  \n\n  vehicleSystem.subsystemB.part1: Part1[2]  \n  vehicleSystem.subsystemB.part2: Part2[1]  \n  vehicleSystem.subsystemB.part5: Part5  \n  vehicleSystem.subsystemB.part4: Part4[4]  \n\n  vehicleSystem.subsystemA.p1 -> vehicleSystem.subsystemB.p2  \n  vehicleSystem.subsystemB.p1 -> vehicleSystem.subsystemA.p2  \n\n  vehicleSystem.subsystemB.part5.behavior = BehaviorVariant2  \n\nblock BehaviorVariant1 extends Behavior  \nblock BehaviorVariant2 extends Behavior  \n\nblock SystemConstraint  \n  constraint c1: subsystemA.part3.p1.size() == subsystemB.part5.p2.size()  \n  constraint c2: if subsystemB.part5.behavior == BehaviorVariant1 then subsystemA.part4.size() > 2 else true endif",
    "module VehicleConfiguration {\n    block VehicleConfigurationSystem {\n        part engine : Engine;\n        part transmission : Transmission;\n        part wheel : Wheel;\n        part userPreference : UserPreference;\n    }\n\n    block Engine {\n        property cylinderCount : Integer;\n    }\n\n    block Transmission {\n        property type : String;\n    }\n\n    block Wheel {\n        property rimWidth : String;\n    }\n\n    block UserPreference {\n        property performanceLevel : PerformanceLevel;\n    }\n\n    enumeration PerformanceLevel {\n        High;\n        Standard;\n    }\n\n    constraintblock HighPerformanceConstraint {\n        context VehicleConfigurationSystem\n        rule highPerformanceRule {\n            if (userPreference.performanceLevel = PerformanceLevel::High) then\n                engine.cylinderCount = 6;\n                transmission.type = \"Automatic\";\n                wheel.rimWidth = \"Wide\";\n            end if;\n        }\n    }\n\n    constraintblock StandardPerformanceConstraint {\n        context VehicleConfigurationSystem\n        rule standardPerformanceRule {\n            if (userPreference.performanceLevel = PerformanceLevel::Standard) then\n                engine.cylinderCount = 4;\n                transmission.type = \"Manual\";\n                wheel.rimWidth = \"Narrow\";\n            end if;\n        }\n    }\n\n    constraintblock CompatibilityConstraint {\n        context VehicleConfigurationSystem\n        rule componentCompatibility {\n            assert (engine.cylinderCount = 6 implies transmission.type = \"Automatic\");\n            assert (engine.cylinderCount = 4 implies transmission.type = \"Manual\");\n            assert (wheel.rimWidth = \"Wide\" implies transmission.type = \"Automatic\");\n            assert (wheel.rimWidth = \"Narrow\" implies transmission.type = \"Manual\");\n        }\n    }\n\n    apply VehicleConfigurationSystem::HighPerformanceConstraint;\n    apply VehicleConfigurationSystem::StandardPerformanceConstraint;\n    apply VehicleConfigurationSystem::CompatibilityConstraint;\n}\n```",
    "model AutomobileSystem {\n  block Vehicle {\n    property mass : Real;\n    property fuelStatus : FuelState;\n    part engine : Engine;\n    part transmission : Transmission;\n    interface driveInterface : DriveInterface;\n  }\n\n  block Engine {\n    port drivePort : DriveInterface;\n    action outputTorque() : Real;\n  }\n\n  block Transmission {\n    port drivePort : DriveInterface;\n    action transferTorque(torque : Real);\n  }\n\n  block DriveInterface {\n    property torque : Real;\n  }\n\n  enumeration FuelState {\n    Full;\n    Empty;\n  }\n\n  constraintBlock MassConstraint {\n    parameter maxMass : Real;\n    parameter actualMass : Real;\n    constraint actualMass <= maxMass;\n  }\n\n  constraintBlock FuelMassConstraint {\n    parameter maxMassFull : Real;\n    parameter maxMassEmpty : Real;\n    parameter actualMass : Real;\n    parameter fuelStatus : FuelState;\n    constraint if fuelStatus == Full then actualMass <= maxMassFull else actualMass <= maxMassEmpty;\n  }\n\n  constraintBlock PowertrainConstraint {\n    parameter engineTorque : Real;\n    parameter transmissionTorque : Real;\n    constraint engineTorque == transmissionTorque;\n  }\n\n  constraintBlock ReliabilityConstraint {\n    parameter minPerformance : Real;\n    parameter minDurability : Integer;\n    constraint performance >= minPerformance and durability >= minDurability;\n  }\n\n  requirement MassComplianceReq {\n    text \"Vehicle mass must not exceed maximum mass limitation\";\n    constraintBlock MassConstraint;\n    appliesTo Vehicle.mass;\n  }\n\n  requirement FuelMassComplianceReq {\n    text \"Vehicle must comply with mass requirements based on fuel status\";\n    constraintBlock FuelMassConstraint;\n    appliesTo Vehicle.mass, Vehicle.fuelStatus;\n  }\n\n  requirement PowertrainConnectionReq {\n    text \"Engine must output torque and transmission must receive equivalent torque through drive interface\";\n    constraintBlock PowertrainConstraint;\n    appliesTo Engine.drivePort.torque, Transmission.drivePort.torque;\n  }\n\n  requirement ReliabilityReq {\n    text \"Vehicle must maintain specified performance and durability throughout lifecycle\";\n    constraintBlock ReliabilityConstraint;\n    appliesTo Vehicle;\n  }\n\n  allocate MassComplianceReq to Vehicle;\n  allocate FuelMassComplianceReq to Vehicle;\n  allocate PowertrainConnectionReq to Engine, Transmission;\n  allocate ReliabilityReq to Vehicle;\n\n  validate MassComplianceReq using MassConstraint;\n  validate FuelMassComplianceReq using FuelMassConstraint;\n  validate PowertrainConnectionReq using PowertrainConstraint;\n  validate ReliabilityReq using ReliabilityConstraint;\n}\n```",
    "package VehicleMassCompliance {\n    block Vehicle {\n        property actualMass : Real {unit = 'kg'};\n    }\n\n    block WeighingEquipment {\n        function measureMass(vehicle: Vehicle): Real {\n            return vehicle.actualMass;\n        }\n    }\n\n    block TestOperator {\n        function operateEquipment(equipment: WeighingEquipment, vehicle: Vehicle): Real {\n            return equipment.measureMass(vehicle);\n        }\n    }\n\n    block VehicleMassComplianceSystem {\n        part weighingEquipment : WeighingEquipment;\n        part testOperator : TestOperator;\n        property actualMass : Real {unit = 'kg'};\n        property complianceStatus : Boolean;\n\n        constraintClause maxMassConstraint {\n            actualMass <= maxPermissibleMass;\n        }\n\n        valueSpecification maxPermissibleMass : Real = 2500.0 {unit = 'kg'};\n    }\n\n    behaviorDefinition TestVehicleMass {\n        parameter vehicle: Vehicle;\n        parameter maxPermissibleMass: Real {unit = 'kg'};\n        variable measuredMass: Real {unit = 'kg'};\n        variable isCompliant: Boolean;\n\n        loopStep testLoop {\n            step measureMassStep {\n                measuredMass = testOperator.operateEquipment(weighingEquipment, vehicle);\n            }\n\n            step compareMassStep {\n                isCompliant = (measuredMass <= maxPermissibleMass);\n            }\n\n            step determineComplianceStep {\n                if (isCompliant) {\n                    complianceStatus = true;\n                } else {\n                    complianceStatus = false;\n                }\n            }\n        }\n    }\n}\n```",
    "block SpigotBank\n  part spigot[*] : Spigot\nend SpigotBank\n\ninterface block HotWaterInterface\nend HotWaterInterface\n\ninterface block ColdWaterInterface\nend ColdWaterInterface\n\nblock Spigot\n  interface usage hotWater : HotWaterInterface\n  interface usage coldWater : ColdWaterInterface\n  part faucet : Faucet\n  connector hotWater -> faucet.hotInlet.hotWaterIn\n  connector coldWater -> faucet.coldInlet.coldWaterIn\nend Spigot\n\nblock Faucet\n  part hotInlet : FaucetInlet\n  part coldInlet : FaucetInlet\nend Faucet\n\nblock FaucetInlet\n  interface requirement hotWaterIn : HotWaterInterface\n  interface requirement coldWaterIn : ColdWaterInterface\nend FaucetInlet\n\nconstraint block ReliableWaterSupply\n  constraint c1 : \"Hot and cold water must be delivered without interruption\"\nend ReliableWaterSupply\n\nconstraint block SmoothTransmission\n  constraint c1 : \"Pipeline connections must ensure laminar flow with no turbulence\"\nend SmoothTransmission\n\napply SpigotBank to ReliableWaterSupply\napply Spigot to SmoothTransmission",
    "model VehicleQualityAnalysisSystem {\n  block Vehicle {\n    part engine: Engine;\n    part transmission: Transmission;\n    part frontAxle: FrontAxleAssembly;\n    part rearAxle: RearAxleAssembly;\n    property totalMass: Mass;\n    constraint totalMass = engine.mass + transmission.mass + frontAxle.mass + rearAxle.mass;\n  }\n\n  block Engine {\n    property mass: Mass;\n  }\n\n  block Transmission {\n    property mass: Mass;\n  }\n\n  block FrontAxleAssembly {\n    property mass: Mass;\n  }\n\n  block RearAxleAssembly {\n    property mass: Mass;\n  }\n\n  block QualityData {\n    property mass: Mass;\n  }\n\n  usecase library QualityAnalysisUCs {\n    usecase InputQualityData {\n      extend Vehicle {\n        action inputMassData(component: Component, mass: Mass);\n      }\n    }\n\n    usecase AggregateVehicleMass {\n      extend Vehicle {\n        action calculateTotalMass();\n      }\n    }\n  }\n\n  requirement library QualityAnalysisRequirements {\n    requirement MaxTotalMass {\n      parameter totalMass: Mass;\n      constraint totalMass <= 2000 kg;\n    }\n  }\n\n  activity library QualityAnalysisActivities {\n    activity GenerateAnalysisTasks {\n      input objective: String;\n      output tasks: List<AnalysisTask>;\n      action parseObjective(objective: String) returns tasks: List<AnalysisTask>;\n    }\n\n    activity FormulateAnalysisPlans {\n      input tasks: List<AnalysisTask>;\n      output plans: List<AnalysisPlan>;\n      action createPlan(task: AnalysisTask) returns plan: AnalysisPlan;\n    }\n  }\n\n  block AnalysisTask {\n    property description: String;\n    property requirements: List<Requirement>;\n  }\n\n  block AnalysisPlan {\n    property tasks: List<AnalysisTask>;\n    property timeline: Duration;\n  }\n\n  constraint block MassConstraint {\n    property vehicleMass: Mass;\n    constraint vehicleMass = sum(engine.mass, transmission.mass, frontAxle.mass, rearAxle.mass);\n  }\n}\n```",
    "module PowertrainConfigurationSystem {\n    class EngineStructure {\n        attribute numberOfCylinders : Integer;\n    }\n\n    class FourCylinderEngine extends EngineStructure {\n        part cylinder : Cylinder [4];\n        part piston : Piston [4];\n        part connectingRod : ConnectingRod [4];\n        part crankshaft : Crankshaft;\n    }\n\n    class SixCylinderEngine extends EngineStructure {\n        part cylinder : Cylinder [6];\n        part piston : Piston [6];\n        part connectingRod : ConnectingRod [6];\n        part crankshaft : Crankshaft;\n    }\n\n    class EngineAssemblyComponent {\n        part cylinder : Cylinder;\n        part piston : Piston;\n        part connectingRod : ConnectingRod;\n        part crankshaft : Crankshaft;\n    }\n\n    class EvaluationModel {\n        value power : Float;\n        value mass : Float;\n        value efficiency : Float;\n        value reliability : Float;\n        value cost : Float;\n    }\n\n    class MultiAttributeTradeOffAnalysis {\n        uses evaluationModel : EvaluationModel;\n        action analyzeEngineSchemes(engineSchemes : List<EngineStructure>) : Float;\n    }\n\n    class RecommendOptimalEngineSolution {\n        depends on tradeOffAnalysis : MultiAttributeTradeOffAnalysis;\n        action recommend(engineSchemes : List<EngineStructure>) : EngineStructure;\n    }\n\n    class DecisionExplanation {\n        value rationale : String;\n    }\n\n    class PowertrainSystem {\n        part engineStructure : EngineStructure;\n        part engineAssembly : EngineAssemblyComponent;\n        part tradeOffAnalysis : MultiAttributeTradeOffAnalysis;\n        part recommendation : RecommendOptimalEngineSolution;\n        part explanation : DecisionExplanation;\n\n        constraint evaluationConstraint {\n            evaluationModel.power > 0 and\n            evaluationModel.mass > 0 and\n            evaluationModel.efficiency between 0.0 and 1.0 and\n            evaluationModel.reliability between 0.0 and 1.0 and\n            evaluationModel.cost > 0\n        }\n    }\n}\n```",
    "model FuelEconomySystem {\n  block VehicleSystem {\n    property powertrain : Powertrain;\n    property load : Load;\n    property operatingConditions : OperatingConditions;\n    constraint fuelEconomyConstraint : FuelEconomyConstraint;\n  }\n\n  block Powertrain {\n    property efficiency : Double;\n    property type : String;\n  }\n\n  block Load {\n    property weight : Double @ unit 'lb';\n  }\n\n  block OperatingConditions {\n    property scenario : String;\n    property speedProfile : Double[*] @ unit 'mph';\n    property temperature : Double @ unit '°F';\n  }\n\n  constraintBlock FuelEconomyConstraint {\n    parameter urbanRange : Double @ unit 'mi/gal' = 25.0;\n    parameter highwayRange : Double @ unit 'mi/gal' = 30.0;\n    parameter testLoad : Double @ unit 'lb' = 1000.0;\n    parameter gallonVolume : Double @ unit 'in³' = 231.0;\n\n    constraint urbanRequirement : urbanRange <= vehicle.rangePerGallon(operatingConditions.scenario == 'urban', load.weight == testLoad);\n    constraint highwayRequirement : highwayRange <= vehicle.rangePerGallon(operatingConditions.scenario == 'highway', load.weight == testLoad);\n  }\n\n  function rangePerGallon(vehicle : VehicleSystem, operatingConditions : OperatingConditions, load : Load) : Double @ unit 'mi/gal' {\n    return (vehicle.powertrain.efficiency * operatingConditions.speedProfile.length) / (load.weight + vehicle.baseWeight);\n  }\n}\n```",
    "module VehicleDynamicsSimulation {  \n    block VehicleSystem {  \n        property mass : Real;  \n        property initialPosition : Real;  \n        property initialVelocity : Real;  \n        property powerData : List<Real>;  \n        property timeStep : Real;  \n    }  \n\n    block PowerInputHandler {  \n        property mass : Real;  \n        property initialPosition : Real;  \n        property initialVelocity : Real;  \n        property powerData : List<Real>;  \n    }  \n\n    block DynamicsCalculator {  \n        property mass : Real;  \n        property initialPosition : Real;  \n        property initialVelocity : Real;  \n        property powerData : List<Real>;  \n        property timeStep : Real;  \n        method calculateMotion() : List<Real> * List<Real> * List<Real> {  \n            var accelerationSequence : List<Real> := [];  \n            var velocityVariationSequence : List<Real> := [];  \n            var displacementSequence : List<Real> := [];  \n            var currentVelocity : Real := initialVelocity;  \n            var currentPosition : Real := initialPosition;  \n            for (i in 0 to size(powerData) - 1) do  \n                var power : Real := powerData[i];  \n                var acceleration : Real := power / (mass * currentVelocity);  \n                accelerationSequence.append(acceleration);  \n                currentVelocity := currentVelocity + acceleration * timeStep;  \n                velocityVariationSequence.append(currentVelocity - initialVelocity);  \n                currentPosition := currentPosition + currentVelocity * timeStep + 0.5 * acceleration * timeStep^2;  \n                displacementSequence.append(currentPosition - initialPosition);  \n            end for;  \n            return (accelerationSequence, velocityVariationSequence, displacementSequence);  \n        }  \n    }  \n\n    block DataOutputCollector {  \n        property accelerationSequence : List<Real>;  \n        property velocityVariationSequence : List<Real>;  \n        property displacementSequence : List<Real>;  \n    }  \n\n    relation PowerInputHandlerToDynamics {  \n        source : PowerInputHandler;  \n        target : DynamicsCalculator;  \n        mapping mass -> mass;  \n        mapping initialPosition -> initialPosition;  \n        mapping initialVelocity -> initialVelocity;  \n        mapping powerData -> powerData;  \n    }  \n\n    relation DynamicsToDataOutput {  \n        source : DynamicsCalculator;  \n        target : DataOutputCollector;  \n        mapping accelerationSequence -> accelerationSequence;  \n        mapping velocityVariationSequence -> velocityVariationSequence;  \n        mapping displacementSequence -> displacementSequence;  \n    }  \n}",
    "block VehicleSystem {\n  property totalMass : Real = 2500;\n  part frontAxleAssembly : FrontAxleAssembly;\n  part rearAxleAssembly : RearAxleAssembly;\n}\n\nblock FrontAxleAssembly {\n  property mass : Real = 150;\n  part frontWheel [2] : FrontWheel;\n  part frontAxle [1] : FrontAxle;\n}\n\nblock FrontAxle {\n  property mass : Real;\n  property steeringAngle : Real;\n}\n\nblock RearAxleAssembly {\n  property mass : Real = 250;\n  part rearWheel [2} : RearWheel;\n  part rearAxle [1} : RearAxle;\n}\n\nblock RearAxle {\n  property mass : Real;\n}",
    "package VehicleSafetySecurityModel {\n    block VehicleSystem {\n        part safetyFeatures : SafetyFeature[*];\n        part securityDevices : SecurityDevice[*];\n    }\n\n    block SafetyFeature {\n        part mandatoryFeatures : MandatorySafetyFeature[*];\n        part optionalFeatures : OptionalSafetyFeature[*];\n    }\n\n    block MandatorySafetyFeature {\n        part seatBelt : SeatBelt[1];\n        part bumper : Bumper[1];\n    }\n\n    block OptionalSafetyFeature {\n        part airbag : Airbag[0..1];\n        part antiLockBrakingSystem : AntiLockBrakingSystem[0..1];\n    }\n\n    block SecurityDevice {\n        part alarm : Alarm[1];\n        part keylessEntrySystem : KeylessEntrySystem[1];\n    }\n\n    usecase FilteringOrganizationSafetyComponents {\n        context: VehicleSystem;\n        preconditions: Components are categorized as safety or security;\n        postconditions: Components are filtered and organized by category;\n    }\n\n    usecase VisualizeSafetyConfigurations {\n        context: VehicleSystem;\n        preconditions: Safety features are organized;\n        postconditions: Safety configurations displayed in tree/table format;\n    }\n\n    requirement Functional_Req1 {\n        text: The system shall manage and display vehicle safety and security features;\n        constraint: safetyFeatures and securityDevices must be accessible;\n    }\n\n    requirement Functional_Req2 {\n        text: The system shall distinguish mandatory and optional safety features;\n        constraint: SeatBelt and Bumper must be present, Airbag and AntiLockBrakingSystem optional;\n    }\n\n    requirement NonFunctional_Req1 {\n        text: Safety and security configurations must be visualized in hierarchical/tree structures or tables;\n        constraint: visualizationFormat ∈ {tree, table};\n    }\n}\n```",
    "package LayeredSystem {\n    block ApplicationLayerBlock {\n        use ServiceLayerBlock;\n    }\n\n    block ServiceLayerBlock {\n        use DataLayerBlock;\n    }\n\n    block DataLayerBlock {\n        // Data layer implementation details\n    }\n\n    block System {\n        x : Integer;\n        y : Integer;\n        z : Integer;\n        application : ApplicationLayerBlock;\n        apply ZDependency;\n    }\n\n    constraint ZDependency {\n        param x : Integer;\n        param y : Integer;\n        param z : Integer;\n        z = x + y;\n    }\n\n    relationship R1 : ApplicationLayerBlock use ServiceLayerBlock;\n    relationship R2 : ServiceLayerBlock use DataLayerBlock;\n}\n```",
    "model PowertrainSystem {\n  function TorqueGenerationFunction {\n    output port torqueOut: FlowPort {\n      flow Torque {\n        value: Real > 0;\n      }\n    }\n  }\n\n  block Engine {\n    port torqueOut: FlowPort {\n      flow Torque {\n        value: Real > 0;\n      }\n    }\n  }\n\n  part engine: Engine;\n\n  allocation TorqueGenerationFunction -> engine;\n}",
    "function generateTorque: Function;\nfunction transmitPower: Function;\n\nblock System {\n  part torqueGenerator: TorqueGenerator;\n  part powertrain: Powertrain;\n  function generateTorque: Function;\n  function transmitPower: Function;\n  allocate generateTorque to torqueGenerator;\n  allocate transmitPower to powertrain;\n}\n\nblock TorqueGenerator {\n  function generateTorque: Function;\n  realize generateTorque;\n  allocate generateTorque to powertrain.engine;\n}\n\nblock Powertrain {\n  part engine: Engine;\n  function transmitPower: Function;\n  realize transmitPower;\n}\n\nblock Engine {\n  function generateTorque: Function;\n  realize generateTorque;\n}\n```",
    "block VehicleSafetyAntiTheftCatalogue {\n  parts {\n    safetyComponents: SafetyComponent;\n    antiTheftComponents: AntiTheftComponent;\n    bothComponents: BothComponent;\n  }\n}\n\nblock SafetyComponent {\n  parts {\n    mandatory: MandatorySafetyComponent;\n    optional: OptionalSafetyComponent;\n  }\n}\n\nblock MandatorySafetyComponent {\n  parts {\n    frontSeatBelts: FrontSeatBelts;\n    bumpers: Bumpers;\n  }\n}\n\nblock OptionalSafetyComponent {\n  parts {\n    driverAirbag: DriverAirbag;\n    abs: AntiLockBrakingSystem;\n  }\n}\n\nblock AntiTheftComponent {\n  parts {\n    alarmSystem: AlarmSystem;\n    keylessEntrySystem: KeylessEntrySystem;\n  }\n}\n\nblock BothComponent {\n  // Placeholder for components affecting both safety and anti-theft\n}\n\nblock FrontSeatBelts { }\nblock Bumpers { }\nblock DriverAirbag { }\nblock AntiLockBrakingSystem { }\nblock AlarmSystem { }\nblock KeylessEntrySystem { }\n\nrequirement MinimumSafetyComponents {\n  subject: VehicleSafetyAntiTheftCatalogue;\n  text: \"The vehicle must be equipped with front seat belts and bumpers as mandatory safety components.\";\n  coverage: safetyComponents.mandatory.frontSeatBelts, safetyComponents.mandatory.bumpers;\n}\n\nrequirement OptionalSafetyFeatures {\n  subject: VehicleSafetyAntiTheftCatalogue;\n  text: \"The driver’s airbag and anti-lock braking system are optional safety features and may be included based on specific configurations.\";\n  coverage: safetyComponents.optional.driverAirbag, safetyComponents.optional.abs;\n}\n\nrequirement SecurityComponents {\n  subject: VehicleSafetyAntiTheftCatalogue;\n  text: \"The vehicle must be equipped with an alarm system and a keyless entry system to enhance overall security.\";\n  coverage: antiTheftComponents.alarmSystem, antiTheftComponents.keylessEntrySystem;\n}\n\nrequirement BothSafetyAndAntiTheft {\n  subject: VehicleSafetyAntiTheftCatalogue;\n  text: \"Components that affect both safety and anti-theft must be included as per configuration requirements.\";\n  coverage: bothComponents;\n}",
    "package FuelSystemModel {\n    block FuelSystem {\n        part fuelTankAssembly: FuelTankAssembly;\n        part fuelConsumingUnit: FuelConsumingUnit;\n        part returnLine: ReturnLine;\n        apply SafetyConstraint;\n        apply EfficiencyConstraint;\n    }\n\n    block FuelTankAssembly {\n        part fuelPump: FuelPump;\n        part fuelTank: FuelTank;\n        port fuelOut: FlowPort<out, FuelFlow>;\n        port returnIn: FlowPort<in, FuelFlow>;\n        port temperatureOut: DataPort<out, FuelTemperatureData>;\n    }\n\n    block FuelPump {\n        port fuelOut: FlowPort<out, FuelFlow>;\n        port returnIn: FlowPort<in, FuelFlow>;\n    }\n\n    block FuelTank {\n        port returnIn: FlowPort<in, FuelFlow>;\n    }\n\n    block FuelConsumingUnit {\n        port fuelIn: FlowPort<in, FuelFlow>;\n        port returnOut: FlowPort<out, FuelFlow>;\n    }\n\n    block ReturnLine {\n        port fuelIn: FlowPort<in, FuelFlow>;\n        port fuelOut: FlowPort<out, FuelFlow>;\n    }\n\n    flow FuelFlow {\n        property fuelQuantity: Real;\n        property pressure: Real;\n    }\n\n    flow FuelTemperatureData {\n        property temperature: Real;\n        property timestamp: DateTime;\n    }\n\n    constraint SafetyConstraint {\n        context FuelSystem {\n            inv: fuelTankAssembly.fuelOut.fuelQuantity <= fuelTank.capacity;\n            inv: fuelConsumingUnit.fuelIn.pressure >= 3.0 and fuelConsumingUnit.fuelIn.pressure <= 5.0;\n        }\n    }\n\n    constraint EfficiencyConstraint {\n        context FuelSystem {\n            inv: fuelTankAssembly.returnIn.fuelQuantity / fuelPump.returnIn.fuelQuantity >= 0.9;\n            inv: fuelTankAssembly.temperatureOut.temperature <= 45.0;\n        }\n    }\n}\n```",
    "requirement SeatBelts {\n  text: \"The vehicle interior must be equipped with two seat belts, which are mandatory safety features.\";\n  constraint: required;\n  taggedValue: classification = \"safety\";\n}\n\nrequirement Airbag {\n  text: \"An airbag should be installed in the cockpit.\";\n  constraint: optional;\n  taggedValue: classification = \"safety\";\n}\n\nrequirement AntiTheftAlarm {\n  text: \"An anti-theft alarm device must be installed inside the vehicle to enhance security protection.\";\n  constraint: required;\n  taggedValue: classification = \"security\";\n}\n\nrequirement Bumper {\n  text: \"The vehicle body must be equipped with a bumper, which is a required safety component.\";\n  constraint: required;\n  taggedValue: classification = \"safety\";\n}\n\nrequirement KeylessEntry {\n  text: \"The vehicle must have a keyless entry system to improve security performance.\";\n  constraint: required;\n  taggedValue: classification = \"security\";\n}\n\nrequirement Wheels {\n  text: \"The chassis structure must be fitted with two wheels.\";\n  constraint: required;\n  taggedValue: classification = \"safety\";\n}\n\nrequirement AntiLockBrakingSystems {\n  text: \"The chassis structure should be equipped with two sets of anti-lock braking systems.\";\n  constraint: optional;\n  taggedValue: classification = \"safety\";\n}\n\nrequirement ComponentClassification {\n  text: \"All components related to safety and security are subject to identification and classification management by the system to ensure compliance with regulations regarding critical safety and security functions.\";\n  constraint: required;\n  taggedValue: classification = \"compliance\";\n}\n```",
    "module VehicleSafetySecurity {\n    block VehicleSafetyAndSecuritySystem {\n        part interior: Interior;\n        part bodyAssembly: BodyAssembly;\n        part safetyFeatures: SafetyFeatures;\n        part securityFeatures: SecurityFeatures;\n    }\n\n    block Interior {\n        part alarmSystem: AlarmSystem;\n        part seatBelts: SeatBelts;\n        part frontRowSeats: FrontRowSeats;\n        part driverAirbag: DriverAirbag;\n    }\n\n    block BodyAssembly {\n        part vehicleBody: VehicleBody;\n        part bumper: Bumper;\n        part keylessEntrySystem: KeylessEntrySystem;\n    }\n\n    block SafetyFeatures {\n        part seatBelts: SeatBelts;\n        part driverAirbag: DriverAirbag;\n        part bumper: Bumper;\n    }\n\n    block SecurityFeatures {\n        part alarmSystem: AlarmSystem;\n        part keylessEntrySystem: KeylessEntrySystem;\n    }\n\n    block AlarmSystem {}\n    block SeatBelts {}\n    block FrontRowSeats {}\n    block DriverAirbag {}\n    block VehicleBody {}\n    block Bumper {}\n    block KeylessEntrySystem {}\n}\n```",
    "«stereotype» SecurityClassification\nmeta stereotype SecurityClassification\n  ownedMember : classificationLevel : SecurityLevelEnum\nend\n\nenum SecurityLevelEnum\n  Unclassified\n  Confidential\n  Secret\nend\n\nconstraintblock SecurityClassificationConstraint\n  for (c : Component)\n    c.classificationLevel <> null\n    if c.classificationLevel = SecurityLevelEnum.Confidential then\n      c.ownedMember->exists(m | m.oclIsTypeOf(Property) and m.name = 'securityLabel')\n    end if\nend\n\ncomponent ClassifiedComponent\n  apply SecurityClassification\n    classificationLevel = SecurityLevelEnum.Confidential\n  end\n  property securityLabel : String\nend",
    "module AutomotiveSystem {  \n    block VCU {  \n        part busIF: BusIF;  \n        part sensorIF: SensorIF;  \n    }  \n\n    block ECU {  \n        part busIF: BusIF;  \n        part sensorIF: SensorIF;  \n    }  \n\n    block BusIF {  \n        port canPort: CANPort;  \n    }  \n\n    block SensorIF {  \n        port sensorDataPort: SensorDataPort;  \n    }  \n\n    block CANBus {  \n        port canInterface: CANPort;  \n    }  \n\n    connector VCU_to_CANBus {  \n        vcu: VCU.busIF.canPort <-> canbus: CANBus.canInterface;  \n    }  \n\n    connector ECU_to_CANBus {  \n        ecu: ECU.busIF.canPort <-> canbus: CANBus.canInterface;  \n    }  \n\n    interface CANPort {  \n        message: String;  \n        signal: Boolean;  \n    }  \n\n    interface SensorDataPort {  \n        data: Float;  \n        status: Enum;  \n    }  \n}",
    "package BloodGlucoseMeterSystem {\n    block BloodGlucoseMeterSystem {\n        part batteryMonitoringSystem: BatteryMonitoringSystem;\n        part emergencyResponseMechanism: EmergencyResponseMechanism;\n        constraint reliability: ReliabilityConstraint;\n        constraint safety: SafetyConstraint;\n    }\n\n    block BatteryMonitoringSystem {\n        function detectBatteryStatus: Boolean;\n        function alertUser: Void;\n        constraint batteryDetection: BatteryDetectionConstraint;\n    }\n\n    block EmergencyResponseMechanism {\n        function initiateEmergencyResponse: Void;\n        constraint emergencyResponse: EmergencyResponseConstraint;\n    }\n\n    constraint block ReliabilityConstraint {\n        property reliabilityLevel: String = \"High\";\n    }\n\n    constraint block SafetyConstraint {\n        property safetyLevel: String = \"High\";\n    }\n\n    constraint block BatteryDetectionConstraint {\n        property detectionThreshold: Double = 0.1;\n        property responseTime: Duration = \"5s\";\n    }\n\n    constraint block EmergencyResponseConstraint {\n        property responsePriority: String = \"Critical\";\n    }\n\n    requirements {\n        requirement R1 {\n            text: \"The system shall automatically detect battery status and alert the user when battery is depleted or cannot be charged.\";\n            appliesTo: BloodGlucoseMeterSystem;\n            constraint: batteryDetection;\n        }\n\n        requirement R2 {\n            text: \"The system shall implement preventive measures to avoid failure in blood glucose measurement due to battery issues.\";\n            appliesTo: BatteryMonitoringSystem;\n        }\n\n        requirement R3 {\n            text: \"The system shall have emergency response mechanisms to handle abnormalities in blood glucose measurement function.\";\n            appliesTo: EmergencyResponseMechanism;\n            constraint: emergencyResponse;\n        }\n\n        requirement R4 {\n            text: \"All system requirements shall be rigorously approved and managed for key risk scenarios to ensure patient safety.\";\n            appliesTo: BloodGlucoseMeterSystem;\n            constraint: reliability, safety;\n        }\n    }\n}\n```",
    "package ScientificConstants {\n    import SIUnit::*;\n    \n    value definition e : Real = 2.71828182845904523536;\n    value definition pi : Real = 3.14159265358979323846;\n    \n    package PhysicalConstants {\n        value definition speedOfLight : Real = 299792458.0 unit m/s;\n        value definition fineStructureConstant : Real = 0.0072973525664;\n        value definition electronMassOverProtonMass : Real = 0.000548579909070;\n    }\n    \n    package ScenarioConstants {\n        value definition standardGravity : Real = 9.80665 unit m/s²;\n        value definition amplifierGainModelX : Real = 20.5;\n    }\n}",
    "module AutomotiveTireSpec {\n  block Tire {\n    property manufacturer : String;\n    property rimDiameter : Real;\n    property width : Integer;\n  }\n\n  instance michelinTire : Tire = {\n    manufacturer: \"Michelin\",\n    rimDiameter: 18.0,\n    width: 245\n  };\n}",
    "unit kilogram = 1 kg;\nunit pound = 0.453592 kg as 1 lb;\nunit meter = 1 m;\nunit inch = 0.0254 m as 1 in;\nunit foot = 0.3048 m as 1 ft;\nunit millimeter = 0.001 m as 1 mm;\n\nblock Vehicle {\n  property mass : Real { unit kilogram } = 1200;\n  property length : Real { unit meter } = 4.82;\n  property frontWheels : FrontWheel[2];\n}\n\nblock FrontWheel {\n  property hub : WheelHub[1];\n  property tire : Tire[1];\n  property outerDiameter : Real { unit meter };\n  constraint WheelOuterDiameterConstraint {\n    outerDiameter = hub.diameter * 0.0254 + 2 * tire.height * 0.001;\n  }\n}\n\nblock WheelHub {\n  property diameter : Real { unit inch } = 18;\n  property width : Real { unit millimeter } = 245;\n}\n\nblock Tire {\n  property width : Real { unit millimeter } = 245;\n  property height : Real { unit millimeter };\n}\n```",
    "module PowertrainConfig {\n  block Engine {}\n  block FourCylinder extends Engine {}\n  block SixCylinder extends Engine {}\n\n  block Transmission {}\n  block Manual extends Transmission {}\n  block Automatic extends Transmission {}\n\n  block Vehicle {\n    property engine : Engine [1];\n    property transmission : Transmission [1];\n    property isHighPerformance : Boolean;\n\n    apply HighPerformanceEngineConstraint;\n    apply ValidCombinationConstraint;\n  }\n\n  constraintBlock HighPerformanceEngineConstraint {\n    if (self.isHighPerformance) then\n      self.engine.oclIsKindOf(SixCylinder)\n    else\n      self.engine.oclIsKindOf(FourCylinder)\n    endif\n  }\n\n  constraintBlock ValidCombinationConstraint {\n    (self.engine.oclIsKindOf(FourCylinder) and self.transmission.oclIsKindOf(Manual)) or\n    (self.engine.oclIsKindOf(SixCylinder) and self.transmission.oclIsKindOf(Automatic))\n  }\n}\n```",
    "value type Length {\n    unit: m, mm, in;\n}\n\nvalue type Mass {\n    unit: kg;\n}\n\nblock Car {\n    property mass : Mass = 1200 kg;\n    property length : Length = 4.82 m;\n    part wheelAssemblies : WheelAssembly[*];\n}\n\nblock WheelAssembly {\n    part wheel : Wheel;\n    part brakeDisc : BrakeDisc;\n    constraint brakeDiscDiameterConstraint : brakeDisc.diameter < wheel.outerDiameter;\n}\n\nblock Wheel {\n    part rim : Rim;\n    part tire : Tire;\n    property outerDiameter : Length;\n    constraint outerDiameterConstraint : outerDiameter = (rim.diameter * 25.4 mm/in) + 2 * tire.height;\n}\n\nblock Rim {\n    property diameter : Length = 18 in;\n}\n\nblock Tire {\n    property width : Length = 245 mm;\n    property height : Length = 45 mm;\n    property treadDepth : Length = 6.0 mm;\n    constraint treadDepthConstraint : treadDepth >= 3.5 mm;\n}\n\nblock BrakeDisc {\n    property radius : Length = 95 mm;\n    property diameter : Length;\n    constraint diameterConstraint : diameter = 2 * radius;\n}\n```",
    "block AutomotiveFuelSystem\n  part fuelTankAssembly : FuelTankAssembly\n  part engine : Engine\n  interface fuelDelivery : FuelDelivery\n  interface fuelReturn : FuelReturn\n  interface temperatureMonitoring : TemperatureMonitoring\n  requirement R1 : \"Fuel must circulate efficiently and safely among all components\"\n    constraint : \"Fuel delivery and return functions must meet vehicle requirements\"\n  requirement R2 : \"System must monitor and transmit fuel temperature information\"\n    constraint : \"Temperature data must be accurate and transmitted in real-time\"\n  satisfies R1 with fuelTankAssembly\n  satisfies R2 with temperatureMonitoring\nend AutomotiveFuelSystem\n\nblock FuelTankAssembly\n  part fuelTank : FuelTank\n  part fuelPump : FuelPump\n  interface outlet : FuelDelivery\n  interface returnInlet : FuelReturn\n  interface temperatureSensor : TemperatureMonitoring\n  action deliverFuel : FuelDelivery\n  action receiveReturn : FuelReturn\n  action monitorTemperature : TemperatureMonitoring\n  satisfies deliverFuel with fuelTank.outlet\n  satisfies receiveReturn with fuelTank.returnInlet\n  satisfies monitorTemperature with temperatureSensor\nend FuelTankAssembly\n\nblock FuelTank\n  property capacity : Integer\n  property material : String\n  interface outlet : FuelDelivery\n  interface returnInlet : FuelReturn\n  action deliverFuel : FuelDelivery\n  action receiveReturn : FuelReturn\nend FuelTank\n\nblock FuelPump\n  property flowRate : Real\n  property power : Real\n  action pumpFuel : FuelDelivery\n  action receiveReturn : FuelReturn\nend FuelPump\n\nblock Engine\n  interface fuelInlet : FuelDelivery\n  interface returnOutlet : FuelReturn\n  action consumeFuel : FuelDelivery\n  action returnFuel : FuelReturn\nend Engine\n\ninterface FuelDelivery\n  action deliver : Real\nend FuelDelivery\n\ninterface FuelReturn\n  action returnFuel : Real\nend FuelReturn\n\ninterface TemperatureMonitoring\n  action monitor : Real\nend TemperatureMonitoring",
    "package Units {\n  value type Meter;\n  value type Kilogram;\n  value type Second;\n  value type Ampere;\n  value type Kelvin;\n  value type Mole;\n  value type Candela;\n}\n\npackage ISQ {\n  import Units::*;\n  \n  value type Length {\n    unit: Meter;\n  }\n  \n  value type Mass {\n    unit: Kilogram;\n  }\n  \n  value type Time {\n    unit: Second;\n  }\n  \n  value type ElectricCurrent {\n    unit: Ampere;\n  }\n  \n  value type Temperature {\n    unit: Kelvin;\n  }\n  \n  value type AmountOfSubstance {\n    unit: Mole;\n  }\n  \n  value type LuminousIntensity {\n    unit: Candela;\n  }\n  \n  value type Speed {\n    unit: Meter / Second;\n  }\n  \n  value type Force {\n    unit: Kilogram * Meter / (Second^2);\n  }\n  \n  class PhysicalQuantityManager {\n    operation convertUnit(sourceUnit: Unit, targetUnit: Unit, value: Number): Number;\n    operation processQuantity(quantity: ValueSpecification): ValueSpecification;\n  }\n}",
    "package UnitSystemLibrary {\n    class Unit {\n        property name : String;\n        property symbol : String;\n        property system : String;\n    }\n\n    class Quantity {\n        property value : Real;\n        property unit : Unit;\n    }\n\n    class ConversionRule {\n        property sourceUnit : Unit;\n        property targetUnit : Unit;\n        property formula : String;\n    }\n\n    class ISQUnit : Unit {\n        constraint c1 : system = \"ISQ\";\n    }\n\n    class USCustomaryUnit : Unit {\n        constraint c1 : system = \"USCustomary\";\n    }\n\n    class LengthUnit : ISQUnit {\n        constraint c1 : name = \"Meter\";\n        constraint c2 : symbol = \"m\";\n    }\n\n    class MassUnit : ISQUnit {\n        constraint c1 : name = \"Kilogram\";\n        constraint c2 : symbol = \"kg\";\n    }\n\n    class TimeUnit : ISQUnit {\n        constraint c1 : name = \"Second\";\n        constraint c2 : symbol = \"s\";\n    }\n\n    class LengthUnitUS : USCustomaryUnit {\n        constraint c1 : name = \"Foot\";\n        constraint c2 : symbol = \"ft\";\n    }\n\n    class MassUnitUS : USCustomaryUnit {\n        constraint c1 : name = \"Pound\";\n        constraint c2 : symbol = \"lb\";\n    }\n\n    class TimeUnitUS : USCustomaryUnit {\n        constraint c1 : name = \"Hour\";\n        constraint c2 : symbol = \"hr\";\n    }\n\n    class LengthConversion : ConversionRule {\n        constraint c1 : sourceUnit = LengthUnit;\n        constraint c2 : targetUnit = LengthUnitUS;\n        constraint c3 : formula = \"value * 3.28084\";\n    }\n\n    class MassConversion : ConversionRule {\n        constraint c1 : sourceUnit = MassUnit;\n        constraint c2 : targetUnit = MassUnitUS;\n        constraint c3 : formula = \"value * 2.20462\";\n    }\n\n    class TimeConversion : ConversionRule {\n        constraint c1 : sourceUnit = TimeUnit;\n        constraint c2 : targetUnit = TimeUnitUS;\n        constraint c3 : formula = \"value / 3600\";\n    }\n}\n```",
    "model HeadlampTiltAdjustmentSystemModel\n  block HeadlampTiltAdjustmentSystem\n    property tiltAngle : Real {unit = 'degree'}\n    apply TiltAngleConstraint\n  end\n  constraintBlock TiltAngleConstraint\n    parameter lowerBound : Real = 50.0 {unit = 'degree'}\n    parameter upperBound : Real = 80.0 {unit = 'degree'}\n    assert self.tiltAngle >= lowerBound and self.tiltAngle <= upperBound\n  end\nend",
    "package CoreDataTypes {\n    enum StatusLevel {\n        Critical\n        Warning\n        Normal\n    }\n\n    enum Color {\n        Red\n        Yellow\n        Green\n    }\n\n    constraint NonNegativeConstraint {\n        parameter value : Number;\n        constraint value >= 0;\n    }\n\n    constraint StatusColorMapping {\n        parameter status : StatusLevel;\n        parameter color : Color;\n        constraint color == switch {\n            case status == StatusLevel::Critical: Color::Red\n            case status == StatusLevel::Warning: Color::Yellow\n            case status == StatusLevel::Normal: Color::Green\n        };\n    }\n\n    enum DiameterSize {\n        Small\n        Medium\n        Large\n    }\n\n    block Diameter {\n        property size : DiameterSize;\n        property diameterValue : Number;\n        constraint sizeDiameterConstraint {\n            parameter value : Number;\n            constraint value == switch {\n                case size == DiameterSize::Small: 60\n                case size == DiameterSize::Medium: 70\n                case size == DiameterSize::Large: 80\n            };\n        }\n    }\n\n    block System {\n        property unsignedInt : Number;\n        constraint unsignedIntConstraint : NonNegativeConstraint {\n            value <- unsignedInt;\n        }\n\n        property unsignedFloat : Number;\n        constraint unsignedFloatConstraint : NonNegativeConstraint {\n            value <- unsignedFloat;\n        }\n\n        property status : StatusLevel;\n        property color : Color;\n        constraint statusColorConstraint : StatusColorMapping {\n            status <- status;\n            color <- color;\n        }\n\n        property diameter : Diameter;\n        constraint defaultDiameter {\n            diameter.size = DiameterSize::Small;\n        }\n\n        property dateTime : DateTime;\n        property stringVal : String;\n        property booleanVal : Boolean;\n    }\n}\n```",
    "package SparePartsManagement {\n    class SparePart;\n    class Person;\n\n    «bag» class SparePartCollection {\n        item: SparePart[*];\n    }\n\n    «list» class IntegerList {\n        value: Integer[*];\n    }\n\n    «set» class StringSet {\n        content: String[*];\n    }\n\n    «orderedSet» class PersonnelOrderedSet {\n        member: Person[*];\n    }\n\n    «list» class ListOfPersonnelSets {\n        set: «set» Person[*][*];\n    }\n\n    «array» class RealArray {\n        {size=4}\n        element: Real[4];\n    }\n}\n```",
    "class Tire {\n  property manufacturer : String;\n  property rimDiameter : Float @unit 'inch';\n  property width : Integer @unit 'mm';\n  property installationPosition : Vector<Float> [0..1] @size 3;\n}\n```",
    "block SpacecraftTrajectoryRecorder {\n  referenceTime : String;\n  samples : Sample[*];\n}\n\nblock Sample {\n  time : Real @unit s;\n  position : Position;\n  velocity : Velocity;\n}\n\nblock Position {\n  x : Real @unit m;\n  y : Real @unit m;\n  z : Real @unit m;\n}\n\nblock Velocity {\n  x : Real @unit m/s;\n  y : Real @unit m/s;\n  z : Real @unit m/s;\n}",
    "model AlloyPropertyManagement {\n  class Material {\n    property atomicMass : Quantity<atomicMassUnit>;\n    property mechanicalProperties : MechanicalProperty[*];\n  }\n  class Metal extends Material {\n    property name : String;\n  }\n  class Alloy extends Material {\n    property name : String;\n    association composition {\n      property component : Material;\n      property massFraction : Quantity<unitless>;\n    }\n    property overallTensileStrength : Quantity<newtonPerSquareMillimeter>;\n  }\n  class MechanicalProperty {\n    property name : String;\n    property value : Quantity<unit>;\n    property unit : String;\n  }\n  class TensileStrength extends MechanicalProperty {\n    property unit : String = \"newtonPerSquareMillimeter\";\n  }\n  unit atomicMassUnit = \"u\";\n  unit newtonPerSquareMillimeter = \"N/mm²\";\n  unit unitless = \"\";\n  instance iron : Metal {\n    name = \"Iron\";\n    atomicMass = 55.845 u;\n    mechanicalProperties = [\n      instance tensileStrengthIron : TensileStrength {\n        name = \"Tensile Strength\";\n        value = 250 N/mm²;\n      }\n    ];\n  }\n  instance carbon : Metal {\n    name = \"Carbon\";\n    atomicMass = 12.011 u;\n    mechanicalProperties = [\n      instance tensileStrengthCarbon : TensileStrength {\n        name = \"Tensile Strength\";\n        value = 100 N/mm²;\n      }\n    ];\n  }\n  instance manganese : Metal {\n    name = \"Manganese\";\n    atomicMass = 54.938 u;\n    mechanicalProperties = [\n      instance tensileStrengthManganese : TensileStrength {\n        name = \"Tensile Strength\";\n        value = 300 N/mm²;\n      }\n    ];\n  }\n  instance steel980 : Alloy {\n    name = \"Steel 980\";\n    composition = [\n      instance componentIron : composition {\n        component = iron;\n        massFraction = 0.98 unitless;\n      },\n      instance componentCarbon : composition {\n        component = carbon;\n        massFraction = 0.01 unitless;\n      },\n      instance componentManganese : composition {\n        component = manganese;\n        massFraction = 0.01 unitless;\n      }\n    ];\n    overallTensileStrength = 450 N/mm²;\n  }\n}",
    "package MaterialsDB {\n    class EngineeringMaterial {\n        property atomicMass : Real;\n        property description : String;\n    }\n\n    class Metal extends EngineeringMaterial {\n        property crystalStructure : String;\n    }\n\n    class Alloy extends EngineeringMaterial {\n        property composition : List<MaterialComponent>;\n    }\n\n    class MaterialComponent {\n        property constituent : EngineeringMaterial;\n        property massFraction : Real;\n    }\n\n    enum Unit {\n        N_MM2\n        MPa\n        GPa\n        Pa\n    }\n\n    class MechanicalProperties {\n        property tensileStrength : Real;\n        property unit : Unit;\n    }\n\n    instance Steel_980 : Alloy {\n        atomicMass = 55.845;\n        description = \"High-strength steel\";\n        composition = [\n            instance IronComponent : MaterialComponent {\n                constituent = instance Iron : Metal {\n                    atomicMass = 55.845;\n                    crystalStructure = \"Body-Centered Cubic\";\n                };\n                massFraction = 0.96;\n            },\n            instance CarbonComponent : MaterialComponent {\n                constituent = instance Carbon : EngineeringMaterial {\n                    atomicMass = 12.011;\n                };\n                massFraction = 0.02;\n            },\n            instance ManganeseComponent : MaterialComponent {\n                constituent = instance Manganese : EngineeringMaterial {\n                    atomicMass = 54.938;\n                };\n                massFraction = 0.01;\n            }\n        ];\n        mechanicalProperties = instance Steel980_MechProps : MechanicalProperties {\n            tensileStrength = 980;\n            unit = N_MM2;\n        };\n    }\n}\n```",
    "model PubSubSystem {\n  block Producer {\n    port publishPort: MessagePort\n    property topic: Topic\n    property message: Message\n  }\n\n  block Server {\n    port publishIn: MessagePort\n    port subscribeOut: MessagePort\n    property topics: List<Topic>\n    property subscribers: List<Subscriber>\n    property messages: List<Message>\n\n    behavior publishBehavior {\n      action receiveMessage(msg: Message, topic: Topic) {\n        messages.add(msg)\n        for sub in subscribers where sub.subscribedTopics.contains(topic) {\n          send(sub.subscribeOut, msg)\n        }\n      }\n    }\n\n    behavior subscribeBehavior {\n      action registerSubscriber(sub: Subscriber, topic: Topic) {\n        if !sub.subscribedTopics.contains(topic) {\n          sub.subscribedTopics.add(topic)\n        }\n      }\n    }\n  }\n\n  block Subscriber {\n    port subscribePort: MessagePort\n    property subscribedTopics: List<Topic>\n  }\n\n  block Topic {\n    property name: String\n  }\n\n  block Message {\n    property content: String\n  }\n\n  interface MessagePort {\n    operation publish(msg: Message)\n    operation subscribe(topic: Topic)\n  }\n\n  part producer1: Producer\n  part server1: Server\n  part subscriber1: Subscriber\n  part topic1: Topic\n  part message1: Message\n\n  connect producer1.publishPort to server1.publishIn\n  connect server1.subscribeOut to subscriber1.subscribePort\n\n  server1.topics.add(topic1)\n  producer1.topic = topic1\n  subscriber1.subscribedTopics.add(topic1)\n  producer1.message = message1\n}\n```",
    "block VehicleFuelSystem\n  part fuelTankAssembly: FuelTankAssembly\n  part engine: Engine\n  part fuelSupplyLine: FuelLine\n  part fuelReturnLine: FuelLine\n  port supplyPort: FuelSupplyPort\n  port returnPort: FuelReturnPort\n  property fuelTemperature: Temperature\n  behavior monitorFuelTemperature\n    action monitor\n      output fuelTemperature: Temperature\n    end action\n    action transmit\n      input fuelTemperature: Temperature\n    end action\n  end behavior\nend block\n\nblock FuelTankAssembly\n  action supplyFuel\n    output fuel: Fuel\n  end action\nend block\n\nblock Engine\n  action returnUnusedFuel\n    input fuel: Fuel\n  end action\nend block\n\nblock FuelLine\n  property fuelFlow: Fuel\nend block\n\ninterface FuelSupplyPort\n  flow Fuel out\nend interface\n\ninterface FuelReturnPort\n  flow Fuel in\nend interface\n\nproperty Fuel: Flow\n  type Fuel\nend property\n\nproperty Temperature: Value\n  type Temperature\nend property",
    "module PublishSubscribe {\n    block Producer {\n        ownedOperation publish(topic: String, message: Message) {\n            return: Boolean;\n        }\n    }\n\n    block Consumer {\n        ownedOperation subscribe(topic: String) {\n            return: Boolean;\n        }\n        ownedOperation receiveMessage(message: Message) {\n            return: Boolean;\n        }\n    }\n\n    block Server {\n        part topics: Topic[*];\n        part consumers: Consumer[*];\n        ownedOperation handleSubscription(topic: String, consumer: Consumer) {\n            return: Boolean;\n        }\n        ownedOperation distributeMessage(topic: String, message: Message) {\n            return: Boolean;\n        }\n    }\n\n    block Topic {\n        property name: String;\n        part subscribers: Consumer[*];\n    }\n\n    block Message {\n        property content: String;\n        property topic: String;\n    }\n\n    activity PublishMessage {\n        input: topic: String, message: Message;\n        action publish(topic: String, message: Message) {\n            output: Boolean;\n        }\n        action distribute(topic: String, message: Message) {\n            output: Boolean;\n        }\n        action sendMessageToConsumer(message: Message, consumer: Consumer) {\n            output: Boolean;\n        }\n        flow publish -> distribute;\n        flow distribute -> sendMessageToConsumer;\n    }\n\n    activity SubscribeTopic {\n        input: topic: String, consumer: Consumer;\n        action subscribe(topic: String, consumer: Consumer) {\n            output: Boolean;\n        }\n        action handleSubscription(topic: String, consumer: Consumer) {\n            output: Boolean;\n        }\n        flow subscribe -> handleSubscription;\n    }\n}\n```",
    "package TransportationSystem {\n  block User {\n  }\n  stereotype Driver extends User {\n  }\n  stereotype Passenger extends User {\n  }\n  block Vehicle {\n    property fuelLevel : Float\n    property maxTankCapacity : Float\n    property driver : Driver\n    property passengers : Passenger[*] { multiplicity: 0..4 }\n    operation board(user : User) : Boolean\n    operation exit(user : User) : Boolean\n    stateMachine Operation {\n      state Operating {\n        do {\n          // Monitor fuel level and environmental factors\n        }\n      }\n      state Refueling {\n        do {\n          // Execute refueling process at gas station\n        }\n      }\n      transition Operating -> Refueling [fuelLevel < 0.1 * maxTankCapacity] {\n        // Initiate refueling when fuel is critically low\n      }\n      transition Refueling -> Operating [fuelLevel >= maxTankCapacity] {\n        // Resume operation after successful refueling\n      }\n    }\n  }\n  block GasStation {\n  }\n  block EnvironmentalFactors {\n    property weather : String\n    property roadConditions : String\n    property terrain : String\n  }\n  association VehicleEnvironmentalFactors {\n    member end vehicle : Vehicle[*]\n    member end factors : EnvironmentalFactors[*]\n  }\n}\n```",
    "block VehicleFuelManagementSystem\n  structure\n    part fuelTank: FuelTankAssembly\n    part engine: EngineUnit\n    connect fuelTank.fuelOutletPort to engine.fuelInletPort\n    connect engine.fuelOutletPort to fuelTank.fuelInletPort\n  end\nend\n\nblock FuelTankAssembly\n  port fuelOutletPort: FlowPort[FuelFlow] direction out\n  port fuelInletPort: FlowPort[FuelFlow] direction in\nend\n\nblock EngineUnit\n  port fuelInletPort: FlowPort[FuelFlow] direction in\n  port fuelOutletPort: FlowPort[FuelFlow] direction out\nend\n\nflow FuelFlow\n  parameter fuelTemperature: Real\nend",
    "model VehicleFuelSystemModel {\n  block VehicleFuelSystem {\n    part fuelTankAssembly: FuelTankAssembly;\n    part engine: Engine;\n    part fuelMonitoringSystem: FuelMonitoringSystem;\n  }\n\n  block FuelTankAssembly {\n    port supplyPort: FlowPort {\n      direction: out;\n      flow: FuelSupplyFlow;\n      data: FuelTemperatureData;\n    }\n    port returnPort: FlowPort {\n      direction: in;\n      flow: FuelReturnFlow;\n      data: FuelTemperatureData;\n    }\n  }\n\n  block Engine {\n    port supplyPort: FlowPort {\n      direction: in;\n      flow: FuelSupplyFlow;\n      data: FuelTemperatureData;\n    }\n    port returnPort: FlowPort {\n      direction: out;\n      flow: FuelReturnFlow;\n      data: FuelTemperatureData;\n    }\n  }\n\n  block FuelMonitoringSystem {\n    port tankTempPort: DataPort {\n      direction: in;\n      data: FuelTemperatureData;\n    }\n    port engineTempPort: DataPort {\n      direction: in;\n      data: FuelTemperatureData;\n    }\n  }\n\n  flow FuelSupplyFlow {\n    item fuel: Fuel;\n  }\n\n  flow FuelReturnFlow {\n    item fuel: Fuel;\n  }\n\n  data FuelTemperatureData {\n    property temperature: Real;\n  }\n\n  constraintblock ReliabilityConstraint {\n    constraint: \"Fuel flow must maintain 99.9% uptime under normal operating conditions\";\n  }\n\n  constraintblock SafetyConstraint {\n    constraint: \"Fuel pressure must not exceed 100 psi at any interface\";\n  }\n\n  constraintblock MonitoringConstraint {\n    constraint: \"Temperature data must be sampled at 1Hz and logged for 24 hours\";\n  }\n\n  requirementblock SystemRequirements {\n    requirement R1: \"Ensure efficient fuel supply and return with minimal pressure loss\";\n    requirement R2: \"Provide real-time fuel temperature monitoring for both supply and return paths\";\n    requirement R3: \"Maintain system reliability and safety per ISO 26262 standards\";\n  }\n\n  VehicleFuelSystem satisfies SystemRequirements;\n  VehicleFuelSystem applies ReliabilityConstraint, SafetyConstraint, MonitoringConstraint;\n}\n```",
    "module PhotoCaptureSystem {\n    block PhotoCaptureSystem {\n        part user : User;\n        part sceneSelection : SceneSelection;\n        part focusingProcess : FocusingProcess;\n        part intermediateImage : IntermediateImage;\n        part photoCaptureProcess : PhotoCaptureProcess;\n        part finalPhoto : FinalPhoto;\n\n        user.scene = sceneSelection.selectedScene;\n        focusingProcess.inputScene = sceneSelection.selectedScene;\n        intermediateImage = focusingProcess.outputImage;\n        photoCaptureProcess.inputImage = intermediateImage;\n        finalPhoto = photoCaptureProcess.outputPhoto;\n    }\n\n    block User {\n        property selectedScene : SceneSelection;\n    }\n\n    block SceneSelection {\n        property selectedScene : Scene;\n    }\n\n    block FocusingProcess {\n        input property inputScene : Scene;\n        output property outputImage : IntermediateImage;\n        behavior autoFocusBehavior : AutoFocusBehavior;\n    }\n\n    block PhotoCaptureProcess {\n        input property inputImage : IntermediateImage;\n        output property outputPhoto : FinalPhoto;\n        behavior capturePhotoBehavior : CapturePhotoBehavior;\n    }\n\n    block AutoFocusBehavior {\n        action performFocusing(inputScene : Scene) : IntermediateImage;\n    }\n\n    block CapturePhotoBehavior {\n        action capturePhoto(inputImage : IntermediateImage) : FinalPhoto;\n    }\n\n    constraint block AutomaticOperation {\n        constraint property noManualIntervention : Boolean = true;\n    }\n\n    requirement block SystemRequirements {\n        requirement automaticFocusing : Boolean = true;\n        requirement automaticCapture : Boolean = true;\n    }\n}\n```",
    "model PhotographyWorkflow {\n  block PhotographySystem {\n    part sceneSelection : SceneSelection;\n    part focusing : Focusing;\n    part shooting : Shooting;\n    part output : PhotographOutput;\n  }\n\n  block SceneSelection {\n    parameter scene : Scene;\n  }\n\n  block Focusing {\n    action focusAction {\n      input scene : Scene;\n      output intermediateImage : Image;\n    }\n  }\n\n  block Shooting {\n    action shootAction {\n      input focusedImage : Image;\n      output finalPhotograph : Photograph;\n    }\n  }\n\n  block PhotographOutput {\n    parameter finalPhotograph : Photograph;\n  }\n\n  block Image {\n    property clarity : Clarity;\n  }\n\n  block Photograph {\n    property quality : Quality;\n  }\n\n  activity WorkflowActivity {\n    step focusStep : Focusing.focusAction;\n    step shootStep : Shooting.shootAction;\n    input scene : Scene;\n    output finalPhotograph : Photograph;\n    flow focusStep.scene -> shootStep.focusedImage;\n    flow focusStep.intermediateImage -> shootStep.focusedImage;\n  }\n\n  constraint Constraint_ConsistentWorkflow {\n    assert PhotographySystem.focusing.focusAction.scene == WorkflowActivity.scene;\n    assert PhotographySystem.shooting.shootAction.finalPhotograph == WorkflowActivity.finalPhotograph;\n  }\n}",
    "model PhotographyWorkflowSystem {\n  block System {\n    part sceneSelector : SceneSelector;\n    part focusingProcess : FocusingProcess;\n    part imageGenerator : ImageGenerator;\n    part shootingProcess : ShootingProcess;\n    part photograph : Photograph;\n  }\n\n  block SceneSelector {\n    operation selectScene() : Scene;\n  }\n\n  block FocusingProcess {\n    input scene : Scene;\n    output focusedImage : Image;\n  }\n\n  block ImageGenerator {\n    input focusedImage : Image;\n    output generatedImage : Image;\n  }\n\n  block ShootingProcess {\n    input generatedImage : Image;\n    output photograph : Photograph;\n  }\n\n  block Scene {\n    property description : String;\n  }\n\n  block Image {\n    property data : ByteArray;\n    property quality : Integer;\n  }\n\n  block Photograph {\n    property imageData : Image;\n    property metadata : String;\n  }\n\n  activity Workflow {\n    step selectSceneStep : System.sceneSelector.selectScene();\n    step focusSceneStep : System.focusingProcess.focus(scene = selectSceneStep.result);\n    step generateImageStep : System.imageGenerator.generate(focusedImage = focusSceneStep.result);\n    step shootImageStep : System.shootingProcess.shoot(generatedImage = generateImageStep.result);\n    output System.photograph = shootImageStep.result;\n  }\n\n  constraint System.photograph.quality > 80;\n  constraint System.focusingProcess.focusedImage.quality = System.imageGenerator.generatedImage.quality;\n}\n```",
    "block PhotographyAutomationSystem  \n  part focusProcessor: FocusProcessor  \n  part shooter: Shooter  \n  behavior automatePhotography: Activity  \n    input scene: String  \n    output photograph: Image  \n    action focusProcessing: FocusProcessing  \n      input scene: String  \n      output focusedImage: Image  \n    action shootingOperation: ShootingOperation  \n      input image: Image  \n      output photograph: Image  \n    sequence  \n      focusProcessing(scene)  \n      shootingOperation(focusedImage)  \n    end sequence  \n  end behavior  \nend block  \n\nblock FocusProcessor  \n  behavior processFocus: Activity  \n    input scene: String  \n    output focusedImage: Image  \n  end behavior  \nend block  \n\nblock Shooter  \n  behavior performShooting: Activity  \n    input image: Image  \n    output photograph: Image  \n  end behavior  \nend block",
    "block PhotographyWorkflow\n  part scene: Scene\n  part focus: Focus\n  part image: Image\n  part shoot: Shoot\n  part picture: Picture\n  flow scene.out -> focus.in\n  flow focus.out -> image.in\n  flow image.out -> shoot.in\n  flow shoot.out -> picture.in\nend\n\nblock Scene\n  port out: SceneData\nend\n\nblock Focus\n  port in: SceneData\n  port out: ImageData\n  behavior focusBehavior\n    // Focus logic implementation\n  end\nend\n\nblock Image\n  port in: ImageData\n  port out: ImageData\nend\n\nblock Shoot\n  port in: ImageData\n  port out: PictureData\n  behavior shootBehavior\n    // Shoot logic implementation\n  end\nend\n\nblock Picture\n  port in: PictureData\nend",
    "block CameraSystem {\n  activity shootPhoto {\n    action selectScene\n    action focusScene\n    action checkFocusClarity {\n      output clearFocus : Boolean\n    }\n    action capturePhoto {\n      output finalImage : Image\n    }\n\n    controlFlow selectScene -> focusScene\n    controlFlow focusScene -> checkFocusClarity\n    controlFlow checkFocusClarity[clearFocus] -> capturePhoto when (clearFocus)\n  }\n\n  constraintBlock AutomatedShootingConstraint {\n    property automationLevel : String = \"Automatic\"\n  }\n\n  constraintBlock ImageQualityConstraint {\n    property clarity : String = \"Optimal\"\n    property quality : String = \"High\"\n  }\n\n  part shootingProcess : shootPhoto\n  part autoFocusConstraint : AutomatedShootingConstraint\n  part imageQuality : ImageQualityConstraint\n}\n```",
    "block PhotographySystem\n  behavior capturePhotoBehavior\n    action selectScene\n      input scene : Scene\n      output selectedScene : Scene\n    end selectScene\n\n    action performFocus\n      input scene : Scene\n      output focusedImage : Image\n    end performFocus\n\n    action generateImage\n      input focusedImage : Image\n      output generatedImage : Image\n    end generateImage\n\n    action evaluateFocusQuality\n      input generatedImage : Image\n      output isWellFocused : Boolean\n    end evaluateFocusQuality\n\n    action convertToPhotograph\n      input generatedImage : Image\n      output photograph : Photograph\n    end convertToPhotograph\n\n    action producePhoto\n      input photograph : Photograph\n      output finalPhoto : Photograph\n    end producePhoto\n\n    flow selectScene.scene -> selectScene.selectedScene\n    flow selectScene.selectedScene -> performFocus.scene\n    flow performFocus.focusedImage -> generateImage.focusedImage\n    flow generateImage.generatedImage -> evaluateFocusQuality.generatedImage\n    flow evaluateFocusQuality.isWellFocused -> if (isWellFocused) then convertToPhotograph.generatedImage\n    flow convertToPhotograph.photograph -> producePhoto.photograph\n  end capturePhotoBehavior\nend PhotographySystem\n```",
    "block PhotographyWorkflowSystem {\n  member SceneAcquirer: SceneAcquirer\n  member FocusFunction: FocusFunction\n  member ShootingOperation: ShootingOperation\n  member Display: Display\n\n  SceneAcquirer.sceneOut -> FocusFunction.sceneIn\n  FocusFunction.imageOut -> ShootingOperation.imageIn\n  ShootingOperation.photoOut -> Display.photoIn\n\n  constraint automaticIntegration: \n    SceneAcquirer, FocusFunction, ShootingOperation, Display are integrated to execute sequentially without user intervention\n}\n\nblock SceneAcquirer {\n  port sceneOut: Scene\n}\n\nblock FocusFunction {\n  port sceneIn: Scene\n  port imageOut: Image\n}\n\nblock ShootingOperation {\n  port imageIn: Image\n  port photoOut: Photograph\n}\n\nblock Display {\n  port photoIn: Photograph\n}\n\nbehavior takePhoto in PhotographyWorkflowSystem {\n  sequence {\n    action acquireScene using SceneAcquirer.sceneOut\n    action performFocus using FocusFunction.sceneIn, FocusFunction.imageOut\n    action generateImage using FocusFunction.imageOut\n    action executeShooting using ShootingOperation.imageIn, ShootingOperation.photoOut\n    action displayPhoto using Display.photoIn\n  }\n  constraint convenience: \n    takePhoto requires only a single user trigger\n  constraint smoothness: \n    steps are executed seamlessly with no manual intervention\n  constraint immediacy: \n    displayPhoto occurs immediately after executeShooting\n}\n```",
    "block AutomaticBrakingControlSystem  \n  brakePedalMonitor: BrakePedalMonitor  \n  tractionEvaluator: TractionEvaluator  \n  brakePressureAdjuster: BrakePressureAdjuster  \n  modulationFrequencyController: ModulationFrequencyController  \n\n  behavior activationBehavior: StateMachine  \n    state Start {  \n      entry: activateSystem()  \n    }  \n  end  \n\n  behavior brakingControlBehavior: Activity  \n    action detectBrakePressure: DetectBrakePressure  \n    action evaluateTraction: EvaluateTraction  \n    action adjustBrakePressure: AdjustBrakePressure  \n    action adjustModulationFrequency: AdjustModulationFrequency  \n\n    loop monitorAndRegulate: Loop  \n      do:  \n        detectBrakePressure  \n        evaluateTraction  \n        adjustBrakePressure  \n        adjustModulationFrequency  \n    end  \n  end  \nend  \n\nblock BrakePedalMonitor  \n  property brakePressure: BrakePressureType  \n  behavior detectBrakePressure: Action  \n    input brakePedalPosition: BrakePedalPositionType  \n    output brakePressure: BrakePressureType  \n  end  \nend  \n\nblock TractionEvaluator  \n  property roadAdhesion: RoadAdhesionType  \n  behavior evaluateTraction: Action  \n    input roadCondition: RoadConditionType  \n    output roadAdhesion: RoadAdhesionType  \n  end  \nend  \n\nblock BrakePressureAdjuster  \n  behavior adjustBrakePressure: Action  \n    input currentBrakePressure: BrakePressureType  \n    input evaluatedTraction: RoadAdhesionType  \n    output adjustedBrakePressure: BrakePressureType  \n  end  \nend  \n\nblock ModulationFrequencyController  \n  behavior adjustModulationFrequency: Action  \n    input currentModulationFrequency: FrequencyType  \n    input evaluatedTraction: RoadAdhesionType  \n    output adjustedModulationFrequency: FrequencyType  \n  end  \nend  \n\nconstraintblock SafeBrakingPerformance  \n  constraint safeBrakePressure: adjustedBrakePressure <= maxSafeBrakePressure  \n  constraint reliableOperation: systemAvailability >= 99.9%  \nend  \n\nconstraintblock DrivingComfort  \n  constraint smoothModulation: modulationFrequencyVariation <= 5%  \n  constraint pressureAdjustment: brakePressureAdjustmentRate <= 100kPa/s  \nend  \n\nvalue BrakePressureType: Real  \nvalue BrakePedalPositionType: Real  \nvalue RoadAdhesionType: Real  \nvalue RoadConditionType: String  \nvalue FrequencyType: Real  \nvalue SystemAvailabilityType: Real",
    "block BatteryChargingControlSystem  \n  property batteryLevelMonitor : BatteryLevelMonitor  \n  property chargingController : ChargingController  \n  property batteryLevel : BatteryLevel  \n  property chargingStatus : Boolean  \n\n  behavior monitorBatteryLevel : StateMachine  \n    state Charging  \n      on entry do:  \n        chargingController.startCharging()  \n    state NotCharging  \n      on entry do:  \n        chargingController.stopCharging()  \n    transition from Charging to NotCharging when batteryLevel >= 100%  \n    transition from NotCharging to Charging when batteryLevel < 100%  \n  end monitorBatteryLevel  \n\n  behavior ensureSafeCharging : Constraint  \n    require:  \n      batteryLevelMonitor.updateFrequency > 0s  \n      chargingController.maxCurrent <= 5A  \n  end ensureSafeCharging  \nend BatteryChargingControlSystem  \n\nblock BatteryLevelMonitor  \n  property batteryLevel : BatteryLevel  \n  behavior updateBatteryLevel : Activity  \n    input batteryVoltage : Real  \n    output batteryLevel : Real  \n    action calculateLevel(batteryVoltage)  \n  end updateBatteryLevel  \nend BatteryLevelMonitor  \n\nblock ChargingController  \n  property maxCurrent : Real  \n  behavior startCharging : Action  \n    do:  \n      enablePowerSupply(maxCurrent)  \n  end startCharging  \n\n  behavior stopCharging : Action  \n    do:  \n      disablePowerSupply()  \n  end stopCharging  \nend ChargingController  \n\nvalue type BatteryLevel  \n  unit: %  \n  min: 0  \n  max: 100  \nend BatteryLevel  \n\nrequirement SystemRequirements  \n  req1: BatteryChargingControlSystem shall monitor battery level in real-time with update frequency > 0s  \n  req2: BatteryChargingControlSystem shall automatically start charging when battery level < 100%  \n  req3: BatteryChargingControlSystem shall terminate charging when battery level >= 100% without manual intervention  \n  req4: ChargingController shall limit maximum charging current to <= 5A  \nend SystemRequirements",
    "block BatteryChargingSystem\n  property batteryLevel : Value<100> [0..1]\n  part chargingControl : Behavior<ChargingControlBehavior> [0..1]\n  part safetySystem : Behavior<SafetyControlBehavior> [0..1]\n  part terminationLogic : Behavior<TerminationLogicBehavior> [0..1]\nend\n\nvalue BatteryLevel\n  constraint BatteryLevelConstraint\n    satisfy batteryLevel >= 0 and batteryLevel <= 100\n  end\nend\n\nbehavior ChargingControlBehavior\n  action monitorBatteryLevel\n    input batteryLevel : BatteryLevel\n    output chargeStatus : Boolean\n    if batteryLevel < 100 then\n      chargeStatus = true\n    else\n      chargeStatus = false\n    end if\n  end\n\n  action replenishBattery\n    input chargeStatus : Boolean\n    if chargeStatus then\n      execute chargingProcess\n    end if\n  end\n\n  action chargingProcess\n    repeat\n      monitorBatteryLevel\n      if chargeStatus then\n        replenishBattery\n      else\n        break\n      end if\n    until batteryLevel >= 100\n  end\nend\n\nbehavior SafetyControlBehavior\n  action preventOvercharging\n    input batteryLevel : BatteryLevel\n    if batteryLevel > 100 then\n      terminateCharging\n    end if\n  end\nend\n\nbehavior TerminationLogicBehavior\n  action terminateCharging\n    stop chargingProcess\n    log \"Charging completed at 100% battery level\"\n  end\nend\n\nrequirement AutomationRequirement\n  text \"The system must operate fully automatically without manual intervention\"\n  allocatedTo BatteryChargingSystem\nend\n\nrequirement SafetyRequirement\n  text \"The system must prevent overcharging when battery level reaches 100%\"\n  allocatedTo SafetyControlBehavior\nend\n\nrequirement ReliabilityRequirement\n  text \"The system must ensure reliable full charging of the battery\"\n  allocatedTo BatteryChargingSystem\nend\n\nstate machine ChargingStateMachine\n  state Charging\n    on entry: startCharging\n    do: monitorBatteryLevel\n    when (batteryLevel >= 100) then\n      transition to Terminated\n    end\n  end\n\n  state Terminated\n    on entry: terminateCharging\n    do: log \"Charging terminated at 100% battery level\"\n    when (batteryLevel < 100) then\n      transition to Charging\n    end\n  end\nend\n\nallocation Allocation_BatteryChargingSystem\n  allocate BatteryChargingSystem to ChargingStateMachine\n  allocate ChargingControlBehavior to ChargingStateMachine.Charging\n  allocate TerminationLogicBehavior to ChargingStateMachine.Terminated\n  allocate SafetyControlBehavior to ChargingStateMachine\nend",
    "block CameraSystem  \n  part autofocusSubsystem: AutofocusSubsystem  \n  part imagingSubsystem: ImagingSubsystem  \n\n  behavior takePhoto: Activity  \n    input sceneSelection: Scene  \n    output highQualityPhoto: Photo  \n\n    step selectScene: SceneSelectionStep  \n      input scene: Scene  \n      output confirmedScene: Scene  \n\n    step obtainClearImage: ImageObtainmentStep  \n      input scene: Scene  \n      output clearImage: Image  \n      uses autofocusSubsystem  \n\n    step captureImage: ImageCaptureStep  \n      input clearImage: Image  \n      output rawPhoto: Photo  \n      uses imagingSubsystem  \n\n    step savePhoto: PhotoStorageStep  \n      input rawPhoto: Photo  \n      output savedPhoto: Photo  \n\n    constraint highQuality: PhotoQualityConstraint  \n      applies to highQualityPhoto  \n      value quality: QualityLevel = \"high\"  \n\nblock AutofocusSubsystem  \n  behavior focus: Behavior  \n    input scene: Scene  \n    output clearImage: Image  \n\nblock ImagingSubsystem  \n  behavior capture: Behavior  \n    input image: Image  \n    output photo: Photo  \n\nblock PhotoStorageSubsystem  \n  behavior save: Behavior  \n    input photo: Photo  \n    output savedPhoto: Photo  \n\nvalue type QualityLevel  \n  enumeration {  \n    low,  \n    medium,  \n    high  \n  }  \n\nvalue type Scene  \n  property name: String  \n\nvalue type Image  \n  property clarity: Boolean  \n  property realism: Boolean  \n\nvalue type Photo  \n  property quality: QualityLevel  \n  property content: Image",
    "module DigitalCameraSystem {\n    block DigitalCameraSystem {\n        part viewfinder : Viewfinder;\n        part focusingModule : FocusingModule;\n        part imagingModule : ImagingModule;\n    }\n\n    block Viewfinder {\n        action selectScene(scene : String) : Boolean;\n    }\n\n    block FocusingModule {\n        action autoFocus(scene : String) : Boolean;\n    }\n\n    block ImagingModule {\n        action captureImage(focusStatus : Boolean) : Photo;\n    }\n\n    constraint block ImageQualityConstraint {\n        property resolution : Integer {value = 12};\n        property sharpness : Integer {value = 9};\n    }\n\n    constraint block ProcessEfficiencyConstraint {\n        property timeToCapture : Duration {value = 0.5};\n    }\n\n    behavior DigitalCameraShootingBehavior {\n        activity shoot() {\n            action selectSceneAction : selectScene(scene);\n            action autoFocusAction : autoFocus(scene);\n            action captureImageAction : captureImage(autoFocusAction.focusStatus);\n\n            controlFlow selectSceneAction -> autoFocusAction;\n            controlFlow autoFocusAction -> captureImageAction;\n\n            apply ImageQualityConstraint to captureImageAction;\n            apply ProcessEfficiencyConstraint to shoot;\n        }\n    }\n\n    apply DigitalCameraShootingBehavior to DigitalCameraSystem;\n}\n```",
    "block VehicleSimulationSystem\n  property mass : Real\n  property initialPosition : Real\n  property initialVelocity : Real\n  property timeInterval : Real\n  property powerInputs : List<Real>\n  property trajectory : List<Real>\nend\n\nblock CalculateMotion\n  property currentVelocity : Real\n  property power : Real\n  property deltaTime : Real\n  property mass : Real\n  property newVelocity : Real\n  property newPosition : Real\nend\n\nbehavior simulateVehicleMotion\n  input mass : Real\n  input initialPosition : Real\n  input initialVelocity : Real\n  input timeInterval : Real\n  input powerInputs : List<Real>\n  output trajectory : List<Real>\n\n  action calculateMotionStep\n    input currentVelocity : Real\n    input power : Real\n    input deltaTime : Real\n    input mass : Real\n    output newVelocity : Real\n    output newPosition : Real\n  end\n\n  action main\n    var velocity = initialVelocity\n    var position = initialPosition\n    var path = List<Real>()\n    for (i in 0 to size(powerInputs) - 1) do\n      var p = powerInputs[i]\n      var v = calculateMotionStep(velocity, p, timeInterval, mass).newVelocity\n      var x = calculateMotionStep(velocity, p, timeInterval, mass).newPosition\n      velocity = v\n      position = x\n      path = append(path, x)\n    end\n    return path\n  end\nend\n```",
    "block CameraSystem\n  scene : Scene\n  image : Image\n  photo : Photo\n  screen : Screen\n\n  activity shootAndDisplay\n    parameter sceneInput : Scene\n    parameter photoOutput : Photo\n\n    action focusAction\n      input scene : Scene\n      output image : Image\n    end\n\n    action captureAction\n      input image : Image\n      output photo : Photo\n    end\n\n    action displayAction\n      input photo : Photo\n      output displayedPhoto : DisplayedPhoto\n    end\n\n    sceneInput -> focusAction.scene\n    focusAction.image -> captureAction.image\n    captureAction.photo -> photoOutput\n    captureAction.photo -> displayAction.photo\n  end\nend\n\ntype Scene\nend\n\ntype Image\nend\n\ntype Photo\nend\n\ntype DisplayedPhoto\nend\n\nblock Screen\nend\n```",
    "data type SceneSelection;\ndata type Image;\ndata type Picture;\n\nblock CameraSystem {\n  part viewPort;\n  part displayPort;\n  behavior processScene {\n    parameters {\n      input sceneSelection: SceneSelection;\n      output picture: Picture;\n    }\n    body {\n      focusImage = focus(sceneSelection);\n      capturedPicture = capture(focusImage);\n      display(displayPort, capturedPicture);\n    }\n  }\n}\n```",
    "enumeration SensorStatus {\n    Ready,\n    Idle,\n    Faulty\n}\n\nblock Sensor {\n    property status : SensorStatus\n}\n\nblock SensorManagementSystem {\n    property sensors : Set<Sensor>\n    \n    operation registerSensor(sensor : Sensor) : Boolean\n    operation monitorSensors() : Void\n    operation updateSensor(sensor : Sensor) : Void\n}\n\n-- Constraint to enforce automatic update when sensor is ready\nconstraint automaticUpdateConstraint {\n    context SensorManagementSystem\n    inv: sensors->select(s | s.status = SensorStatus::Ready)->forAll(s | updateSensor(s))\n}",
    "state machine VehicleStateControl {\n  initial state off {\n    transition to starting when startSignal;\n  }\n  state starting {\n    transition to on when powerOnSignal;\n    transition to off when shutdownSignal;\n  }\n  state on {\n    transition to off when shutdownSignal;\n  }\n}",
    "block VehicleStateController\n  stateMachine VehicleStateSM {\n    state Off {\n      initial\n    }\n    state Starting\n    state On\n    transition Off -> Starting {\n      trigger VehicleStartSignal\n    }\n    transition Starting -> On {\n      trigger VehicleOnSignal\n    }\n    transition On -> Off {\n      trigger VehicleOffSignal\n    }\n  }\nend VehicleStateController",
    "module PowerManagement {\n    block VehiclePowerSystem {\n        state machine PowerState {\n            state Off {\n                entry: cutOffPower();\n            }\n            state StartPhase {\n                entry: initiateStart();\n            }\n            state PoweredOn {\n                entry: startSelfDiagnosis();\n                entry: supplyPowerToFunctionalUnits();\n                exit: engageParkingBrake();\n                do: monitorPowerStatus();\n            }\n            transition Off->StartPhase {\n                trigger: StartCommand;\n            }\n            transition StartPhase->PoweredOn {\n                trigger: VehicleStartedSignal;\n            }\n            transition PoweredOn->Off {\n                trigger: ShutdownCommand;\n            }\n        }\n    }\n}\n```",
    "module VehicleControl {\n    block VehicleControlSystem {\n        flowPort startSignal : SignalPort<in, VehicleStartSignal>;\n        flowPort startedSignal : SignalPort<in, VehicleStartedSignal>;\n        flowPort shutdownSignal : SignalPort<in, VehicleShutdownSignal>;\n    }\n\n    signal VehicleStartSignal {\n        // No properties needed for this signal\n    }\n\n    signal VehicleStartedSignal {\n        // No properties needed for this signal\n    }\n\n    signal VehicleShutdownSignal {\n        // No properties needed for this signal\n    }\n\n    stateMachine VehicleState {\n        state shutdown {\n            on startSignal do {\n                transition to: startUp;\n            }\n        }\n\n        state startUp {\n            on startedSignal do {\n                transition to: running;\n            }\n        }\n\n        state running {\n            on shutdownSignal do {\n                transition to: shutdown;\n            }\n        }\n    }\n\n    apply VehicleState to VehicleControlSystem;\n}\n```",
    "block VehiclePowerManagementSystem {\n  stateMachine PowerStateSM {\n    state Off {\n      initial\n      exit when startSignal: StartSignal\n    }\n    state Start {\n      entry when startSignal: StartSignal\n      exit when onSignal: OnSignal\n    }\n    state On {\n      entry when onSignal: OnSignal\n      exit when offSignal: OffSignal\n    }\n    transition Off -> Start {\n      trigger startSignal: StartSignal\n    }\n    transition Start -> On {\n      trigger onSignal: OnSignal\n    }\n    transition On -> Off {\n      trigger offSignal: OffSignal\n    }\n  }\n  constraint promptTransitions {\n    // Transitions must occur within 500ms of signal receipt\n  }\n  part healthManagement: HealthManagementSystem\n}\n\nblock HealthManagementSystem {\n  // Reserved for future health monitoring capabilities\n}\n\nevent StartSignal\nevent OnSignal\nevent OffSignal",
    "module VehicleHealthMonitoring {\n    block VehicleHealthMonitoringSystem {\n        part temperatureSensor : TemperatureSensor;\n        part vehicleController : VehicleController;\n        part maintenanceScheduler : MaintenanceScheduler;\n        property currentTemperature : Real;\n        property maxAllowableTemperature : Real;\n        property healthStatus : HealthStatus;\n        property maintenanceSchedule : MaintenanceSchedule;\n    }\n\n    block TemperatureSensor {\n        behavior TemperatureMonitoringBehavior {\n            action senseTemperature() {\n                currentTemperature = readSensorValue();\n            }\n        }\n    }\n\n    block VehicleController {\n        behavior OverTemperatureHandling {\n            action sendOverTemperatureWarning() {\n                // Send warning logic\n            }\n        }\n    }\n\n    block MaintenanceScheduler {\n        property nextMaintenanceTime : Time;\n        behavior MaintenanceCycleManagement {\n            action scheduleMaintenance() {\n                nextMaintenanceTime = calculateNextMaintenance();\n            }\n            action updateMaintenanceCycle() {\n                nextMaintenanceTime = calculateNextMaintenance();\n            }\n        }\n    }\n\n    enumeration HealthStatus {\n        Normal,\n        Degraded,\n        Maintenance\n    }\n\n    constraint block MaintenanceDurationConstraint {\n        time 48HourConstraint : Time;\n        48HourConstraint = 48 * 3600; // 48 hours in seconds\n    }\n\n    state machine VehicleHealthState {\n        state Normal {\n            on temperatureExceeded do {\n                vehicleController.sendOverTemperatureWarning();\n                healthStatus = Degraded;\n            }\n            on maintenanceScheduled do {\n                healthStatus = Maintenance;\n            }\n        }\n        state Degraded {\n            on temperatureNormal do {\n                healthStatus = Normal;\n            }\n        }\n        state Maintenance {\n            on entry do {\n                maintenanceScheduler.scheduleMaintenance();\n            }\n            after 48HourConstraint do {\n                healthStatus = Normal;\n            }\n            on maintenanceCompleted do {\n                maintenanceScheduler.updateMaintenanceCycle();\n                healthStatus = Normal;\n            }\n        }\n    }\n\n    block TemperatureSensor {\n        event temperatureExceeded : Boolean;\n        event temperatureNormal : Boolean;\n        temperatureExceeded = currentTemperature > maxAllowableTemperature;\n        temperatureNormal = currentTemperature <= maxAllowableTemperature;\n    }\n\n    block MaintenanceScheduler {\n        event maintenanceScheduled : Boolean;\n        event maintenanceCompleted : Boolean;\n        maintenanceScheduled = currentTime >= nextMaintenanceTime;\n        maintenanceCompleted = maintenanceIsDone();\n    }\n}\n```",
    "block Server {\n  port requestPort: BehaviorPort {\n    operations: \n      startRequest: Operation { returnType: Void },\n      request: Operation { returnType: Void }\n  }\n  behavior: ServerStateMachine\n}\n\nstateMachine ServerStateMachine {\n  state off {\n    initial: true\n  }\n  state waiting {\n    transition to response on request\n    transition to off on dailyShutdown\n  }\n  state response {\n    transition to waiting on fiveMinuteDelay\n    transition to off on dailyShutdown\n  }\n  transition from off to waiting on startRequest\n}\n\ntimeEvent dailyShutdown: TimeEvent {\n  time: TimeConstraint { value: \"11:59:00\" }\n  duration: DurationConstraint { value: 1, unit: \"d\" }\n}\n\ntimeEvent fiveMinuteDelay: TimeEvent {\n  duration: DurationConstraint { value: 5, unit: \"m\" }\n}",
    "block VehicleControlSystem\n  port controllerPort : StartSignalSender\n  port powerPort : PowerOnSignalReceiver\n  stateMachine StartStopControl\n    state off\n      entry: applyParkingBrake()\n    state startProcess\n      entry: sendStartSignal(controllerPort)\n    state operating\n      entry: performSelfCheck(), supplyPower()\n      exit: applyParkingBrake()\n    transition off -> startProcess\n      trigger: startSignal\n    transition startProcess -> operating\n      trigger: powerPort.PowerOnSignal\n      guard: brakeDepressed\n    transition operating -> off\n      trigger: stopSignal\nend VehicleControlSystem\n\nevent StartSignal\nend StartSignal\n\nevent PowerOnSignal\nend PowerOnSignal\n\ninterface StartSignalSender\n  send: StartSignal\nend StartSignalSender\n\ninterface PowerOnSignalReceiver\n  receive: PowerOnSignal\nend PowerOnSignalReceiver",
    "module VehicleControlSystem {\n    block VehicleControlSystem {\n        flowPort startSignal : StartSignal;\n        flowPort brakePedal : BrakePedal;\n        flowPort vehicleOnSignal : VehicleOnSignal;\n        flowPort shutdownSignal : ShutdownSignal;\n        flowPort parkingBrake : ParkingBrake;\n        flowPort vehicleController : VehicleController;\n\n        stateMachine VehicleControlStateMachine {\n            state off {\n                entry: applyConstraint(parkingBrakeApplied);\n                exit: releaseConstraint(parkingBrakeApplied);\n                do: disablePowerSupply();\n            }\n            state startUp {\n                entry: initiateStartupSequence();\n                exit: completeStartupSequence();\n                do: monitorBrakeAndVehicleOn();\n            }\n            state started {\n                entry: performSelfCheck();\n                do: maintainPowerSupply();\n                exit: initiateShutdownSequence();\n            }\n            state shutdown {\n                entry: applyParkingBrake();\n                exit: releaseParkingBrake();\n                do: executeSafetyProtocols();\n            }\n\n            transition off -> startUp {\n                trigger: startSignal.received;\n                guard: systemIsOff();\n            }\n            transition startUp -> started {\n                trigger: brakePedal.depressed and vehicleOnSignal.received;\n                guard: startupConditionsMet();\n            }\n            transition started -> shutdown {\n                trigger: shutdownSignal.received;\n                guard: parkingBrakeApplied();\n            }\n            transition shutdown -> off {\n                trigger: shutdownComplete();\n            }\n        }\n\n        constraintClause parkingBrakeApplied {\n            context: VehicleControlSystem;\n            condition: parkingBrake.status == 'engaged';\n        }\n    }\n}\n```",
    "signal SetSpeedCommand {\n    speed: Real;\n}\n\nsignal FuelControlCommand {\n    fuelAmount: Real;\n}\n\nsignal ActualSpeed {\n    currentSpeed: Real;\n}\n\nblock Driver {\n    port commandPort: provides SetSpeedCommand;\n}\n\nblock CruiseController {\n    port setSpeedPort: requires SetSpeedCommand;\n    port speedPort: requires ActualSpeed;\n    port fuelPort: provides FuelControlCommand;\n}\n\nblock Speedometer {\n    port speedOutput: provides ActualSpeed;\n}\n\nblock Engine {\n    port fuelInput: requires FuelControlCommand;\n}\n\nblock Vehicle {\n    part driver: Driver;\n    part cruiseCtrl: CruiseController;\n    part speedo: Speedometer;\n    part engine: Engine;\n\n    connect driver.commandPort to cruiseCtrl.setSpeedPort;\n    connect speedo.speedOutput to cruiseCtrl.speedPort;\n    connect cruiseCtrl.fuelPort to engine.fuelInput;\n}\n```",
    "package CruiseControlSystem {\n\n    block CruiseControlSystem {\n        component cruiseController : CruiseController;\n        component speedometer : Speedometer;\n        component engineSystem : EngineSystem;\n\n        flowPort setSpeedCommand from cruiseController.setSpeedPort to driver;\n        flowPort currentSpeed from speedometer.speedPort to cruiseController.speedPort;\n        flowPort throttleCommand from cruiseController.throttlePort to engineSystem.throttlePort;\n    }\n\n    block CruiseController {\n        port setSpeedPort : SetSpeedCommand;\n        port speedPort : CurrentSpeed;\n        port throttlePort : ThrottleControlCommand;\n\n        behavior controlSpeed : Activity {\n            action receiveSetSpeedCommand(input setSpeed : SetSpeedCommand);\n            action acquireCurrentSpeed(input currentSpeed : CurrentSpeed);\n            action calculateSpeedDifference(input setSpeed : SetSpeedCommand, input currentSpeed : CurrentSpeed, output speedDiff : Float);\n            action generateThrottleCommand(input speedDiff : Float, output throttleCommand : ThrottleControlCommand);\n            action sendThrottleCommand(output throttleCommand : ThrottleControlCommand);\n        }\n    }\n\n    block Speedometer {\n        port speedPort : CurrentSpeed;\n    }\n\n    block EngineSystem {\n        port throttlePort : ThrottleControlCommand;\n    }\n\n    interface SetSpeedCommand {\n        receive(setSpeed : Float);\n    }\n\n    interface CurrentSpeed {\n        provide(speed : Float);\n    }\n\n    interface ThrottleControlCommand {\n        send(adjustment : Float);\n    }\n\n    data SetSpeedCommandData {\n        value : Float;\n    }\n\n    data ThrottleControlCommandData {\n        value : Float;\n    }\n\n    data CurrentSpeedData {\n        value : Float;\n    }\n\n    requirement drivingComfort {\n        text \"The system must maintain vehicle speed within ±2 km/h of the set speed to ensure driving comfort.\";\n    }\n\n    requirement safetyConstraint {\n        text \"The system must disengage cruise control if vehicle speed exceeds 120 km/h for safety compliance.\";\n    }\n}",
    "package CruiseControlModel {\n    data type Speed;\n    data type ThrottleCommand;\n\n    block Driver {\n        port setSpeedCommandPort: SetSpeedCommand {\n            operation sendSetSpeedCommand(speed: Speed);\n        }\n    }\n\n    block CruiseController {\n        port setSpeedCommandPort: SetSpeedCommand {\n            operation receiveSetSpeedCommand(speed: Speed);\n        }\n        port currentSpeedPort: CurrentSpeed {\n            operation receiveCurrentSpeed(speed: Speed);\n        }\n        port throttleCommandPort: ThrottleCommand {\n            operation sendThrottleCommand(command: ThrottleCommand);\n        }\n        property setSpeed: Speed;\n        property currentSpeed: Speed;\n        operation calculateThrottleCommand(setSpeed: Speed, currentSpeed: Speed): ThrottleCommand;\n    }\n\n    block Speedometer {\n        port currentSpeedPort: CurrentSpeed {\n            operation sendCurrentSpeed(speed: Speed);\n        }\n        operation getCurrentSpeed(): Speed;\n    }\n\n    block Engine {\n        port throttleCommandPort: ThrottleCommand {\n            operation receiveThrottleCommand(command: ThrottleCommand);\n        }\n        operation applyThrottleCommand(throttleCommand: ThrottleCommand);\n    }\n\n    interaction CruiseControlInteraction {\n        message setSpeedCommand from Driver to CruiseController over setSpeedCommandPort.sendSetSpeedCommand(setSpeed) to setSpeedCommandPort.receiveSetSpeedCommand(speed);\n        message currentSpeed from Speedometer to CruiseController over currentSpeedPort.sendCurrentSpeed(currentSpeed) to currentSpeedPort.receiveCurrentSpeed(speed);\n        message throttleCommand from CruiseController to Engine over throttleCommandPort.sendThrottleCommand(throttleCommand) to throttleCommandPort.receiveThrottleCommand(command);\n    }\n}\n```",
    "model CruiseControlSystemModel {\n  block CruiseControlSystem {\n    part driver: Driver;\n    part cruiseController: CruiseController;\n    part speedometer: Speedometer;\n    part engine: Engine;\n  }\n\n  block Driver {\n    behavior setSpeedCommand: SetSpeedCommand;\n  }\n\n  block CruiseController {\n    flowPort speedInput: in SpeedData;\n    flowPort throttleOutput: out ThrottleCommand;\n    behavior calculateThrottle: CalculateThrottle;\n  }\n\n  block Speedometer {\n    behavior senseSpeed: SenseSpeed;\n    flowPort speedOutput: out SpeedData;\n  }\n\n  block Engine {\n    flowPort throttleInput: in ThrottleCommand;\n    behavior adjustThrottle: AdjustThrottle;\n  }\n\n  item SpeedData {\n    value currentSpeed: Real;\n  }\n\n  item ThrottleCommand {\n    value throttlePosition: Real;\n  }\n\n  behavior SetSpeedCommand {\n    parameter desiredSpeed: Real;\n    output command: ThrottleCommand;\n  }\n\n  behavior CalculateThrottle {\n    input currentSpeed: Real;\n    input desiredSpeed: Real;\n    output throttlePosition: Real;\n    constraint performance: CruiseControlPerformance;\n  }\n\n  behavior SenseSpeed {\n    output speedData: SpeedData;\n  }\n\n  behavior AdjustThrottle {\n    input throttleCommand: ThrottleCommand;\n  }\n\n  constraintBlock CruiseControlPerformance {\n    property accuracy: Real;\n    property smoothness: Real;\n  }\n\n  activity CruiseControlWorkflow {\n    action receiveCommand: SetSpeedCommand;\n    action monitorSpeed: SenseSpeed;\n    action calculateThrottle: CalculateThrottle;\n    action applyThrottle: AdjustThrottle;\n\n    receiveCommand->monitorSpeed;\n    receiveCommand->calculateThrottle;\n    monitorSpeed->calculateThrottle;\n    calculateThrottle->applyThrottle;\n  }\n}\n```",
    "data SetSpeedCommand {\n    value : Real {unit = km/h};\n}\n\ndata ActualSpeed {\n    value : Real {unit = km/h};\n}\n\ndata FuelControlCommand {\n    value : Real;\n}\n\nblock CruiseControlInterface {\n    port setSpeedPort : SetSpeedCommand [out];\n}\n\nblock SpeedSensor {\n    port actualSpeedPort : ActualSpeed [out];\n}\n\nblock CruiseController {\n    port setSpeedPort : SetSpeedCommand [in];\n    port actualSpeedPort : ActualSpeed [in];\n    port fuelControlPort : FuelControlCommand [out];\n    \n    behavior maintainSpeed(setSpeed : SetSpeedCommand, actualSpeed : ActualSpeed) : FuelControlCommand {\n        // Compare set speed and actual speed\n        // Generate fuel control command\n    }\n}\n\nblock Engine {\n    port fuelControlPort : FuelControlCommand [in];\n}\n\nblock CruiseControlSystem {\n    part interface : CruiseControlInterface;\n    part sensor : SpeedSensor;\n    part controller : CruiseController;\n    part engine : Engine;\n    \n    interface.setSpeedPort -> controller.setSpeedPort;\n    sensor.actualSpeedPort -> controller.actualSpeedPort;\n    controller.fuelControlPort -> engine.fuelControlPort;\n}\n```",
    "model CruiseControlSystemModel\n  block CruiseControlSystem\n    driver: Driver\n    cruiseController: CruiseController\n    speedSensor: SpeedSensor\n    engineController: EngineController\n    engine: Engine\n\n    connect driver.setSpeedCommandOut to cruiseController.setSpeedCommandIn\n    connect speedSensor.realTimeSpeedOut to cruiseController.realTimeSpeedIn\n    connect cruiseController.fuelControlCommandOut to engineController.fuelControlCommandIn\n    connect engineController.fuelControlCommandOut to engine.fuelControlCommandIn\n  end CruiseControlSystem\n\n  block Driver\n    port setSpeedCommandOut: SetSpeedCommandInterface\n  end Driver\n\n  block CruiseController\n    port setSpeedCommandIn: SetSpeedCommandInterface\n    port realTimeSpeedIn: RealTimeSpeedInterface\n    port fuelControlCommandOut: FuelControlCommandInterface\n  end CruiseController\n\n  block SpeedSensor\n    port realTimeSpeedOut: RealTimeSpeedInterface\n  end SpeedSensor\n\n  block EngineController\n    port fuelControlCommandIn: FuelControlCommandInterface\n    port fuelControlCommandOut: FuelControlCommandInterface\n  end EngineController\n\n  block Engine\n    port fuelControlCommandIn: FuelControlCommandInterface\n  end Engine\n\n  interface SetSpeedCommandInterface\n    operation sendSetSpeedCommand(command: SetSpeedCommand)\n  end SetSpeedCommandInterface\n\n  interface RealTimeSpeedInterface\n    operation getRealTimeSpeed(speed: RealTimeSpeed)\n  end RealTimeSpeedInterface\n\n  interface FuelControlCommandInterface\n    operation sendFuelControlCommand(command: FuelControlCommand)\n  end FuelControlCommandInterface\n\n  value type SetSpeedCommand\n    speed: Double\n  end SetSpeedCommand\n\n  value type RealTimeSpeed\n    speed: Double\n  end RealTimeSpeed\n\n  value type FuelControlCommand\n    fuel: Double\n  end FuelControlCommand\nend model",
    "block Vehicle {\n  property lifecycle : VehicleLifecycle;\n}\n\nblock VehicleLifecycle {\n  property assembly : AssemblyStage;\n  property delivery : DeliveryStage;\n  property ownerships[*] : OwnershipStage;\n  property drivings[*] : DrivingStage;\n  property scrapping : ScrappingStage;\n}\n\nblock AssemblyStage {\n  // No specific properties required\n}\n\nblock DeliveryStage {\n  property deliveryDate : String;\n}\n\nblock OwnershipStage {\n  property ownerInfo : String;\n  property driving : DrivingStage[*];\n  property nextOwnership : OwnershipStage[0..1];\n}\n\nblock DrivingStage {\n  property driverName : String;\n  property ownership : OwnershipStage;\n}\n\nblock ScrappingStage {\n  property scrappingDate : String;\n  property details : String;\n}\n\nassociation VehicleLifecycleAssembly {\n  member end assembly : AssemblyStage;\n  member end lifecycle : VehicleLifecycle;\n}\n\nassociation VehicleLifecycleDelivery {\n  member end delivery : DeliveryStage;\n  member end lifecycle : VehicleLifecycle;\n}\n\nassociation VehicleLifecycleOwnership {\n  member end ownerships[*] : OwnershipStage;\n  member end lifecycle : VehicleLifecycle;\n}\n\nassociation OwnershipDriving {\n  member end driving[*] : DrivingStage;\n  member end ownership : OwnershipStage;\n}\n\nassociation OwnershipNextOwnership {\n  member end nextOwnership : OwnershipStage;\n  member end previousOwnership : OwnershipStage;\n}\n\nassociation VehicleLifecycleScrapping {\n  member end scrapping : ScrappingStage;\n  member end lifecycle : VehicleLifecycle;\n}",
    "block Vehicle {\n  attribute mass: Real;\n  part operationalStatus: OperationalStatus;\n  reference driver: Driver;\n  part wheels[*]: Wheel;\n}\n\nblock OperationalStatus {\n  attribute gear: String;\n  attribute acceleratorPedalPosition: Real;\n}\n\nblock Engine {\n  // No attributes specified\n}\n\nblock Wheel {\n  // No attributes specified\n}\n\nblock Driver {\n  // No attributes specified\n}\n\ninstance vehicle_1: Vehicle {\n  ownedInstance engine_1: Engine;\n  ownedInstance driver_1: Driver;\n  ownedInstance leftFrontWheel: Wheel {\n    timeSnapshot: 0;\n  };\n  ownedInstance rightFrontWheel: Wheel {\n    timeSnapshot: 1;\n  };\n}\n```",
    "package VehicleSystem {\n    class Vehicle {\n        property mass : Float;\n        property state : State;\n        property engine : Engine;\n        property driver : Driver;\n    }\n\n    class Engine {\n    }\n\n    class Driver {\n    }\n\n    class State {\n        property gear : Integer;\n        property accelerator : Float;\n    }\n\n    instance definition Vehicle_1 : Vehicle {\n        mass = 2000.0;\n        state = State_1;\n        engine = Engine_1;\n        driver = Driver_1;\n        behavior VehicleBehavior {\n            parameter mass : Float;\n            parameter gear : Integer;\n            parameter accelerator : Float;\n            timeline {\n                at 0.0 {\n                    mass = 2000.0;\n                    gear = 0;\n                    accelerator = 0.0;\n                }\n                at 1.0 {\n                    mass = 1500.0;\n                    gear = 2;\n                    accelerator = 0.5;\n                }\n            }\n        }\n    }\n\n    instance definition State_1 : State {\n        gear = 0;\n        accelerator = 0.0;\n    }\n\n    instance definition Engine_1 : Engine {\n    }\n\n    instance definition Driver_1 : Driver {\n    }\n}\n```",
    "block Driver {\n  name: String;\n}\n\nblock Engine {\n}\n\nblock Vehicle {\n  mass: Real;\n  gearPosition: String;\n  throttlePosition: Real;\n  engine: Engine;\n  driver: Driver;\n}\n\ninstanceSpecification Alice : Driver {\n  name = \"Alice\";\n}\n\ninstanceSpecification Bob : Driver {\n  name = \"Bob\";\n}\n\nstateMachine VehicleStateMachine for Vehicle {\n  state InitialState {\n    do {\n      behavior InitialBehavior {\n        set mass = 2000.0;\n        set gearPosition = \"Neutral\";\n        set throttlePosition = 0.0;\n        set driver = Alice;\n      }\n    }\n    transition to SecondState;\n  }\n  state SecondState {\n    do {\n      behavior SecondBehavior {\n        set mass = 1500.0;\n        set gearPosition = \"Second\";\n        set throttlePosition = 0.5;\n        set driver = Bob;\n      }\n    }\n  }\n}\n```",
    "value type MassValueType {\n  value: Real;\n}\n\nblock Component {\n  mass: MassValueType;\n}\n\nblock Body specializes Component {\n  // Body-specific properties if needed\n}\n\nblock Engine specializes Component {\n  // Engine-specific properties if needed\n}\n\nblock Transmission specializes Component {\n  // Transmission-specific properties if needed\n}\n\nblock Vehicle {\n  part: Body[*] body;\n  part: Engine[*] engine;\n  part: Transmission[*] transmission;\n  mass: MassValueType;\n  constraint: MassConstraint {\n    totalMass = mass;\n    partMasses = body.mass, engine.mass, transmission.mass;\n  }\n}\n\nconstraint block MassConstraint {\n  totalMass: MassValueType;\n  partMasses: MassValueType[*];\n  totalMass.value = sum(partMasses.value);\n}\n```",
    "block Component {\n  serialNumber: String\n  mass: Float\n  subcomponents: Component[*]\n}\n\nblock Vehicle {\n  VIN: String\n  ownMass: Float\n  engine: Component\n  transmission: Component\n  components: Component[*]\n  threshold: Float\n  totalMass: Float = ownMass + sum( (engine.ownedSubcomponents(mass >= threshold)).mass + (transmission.ownedSubcomponents(mass >= threshold)).mass + sum( components.ownedSubcomponents(mass >= threshold).mass ) )\n}",
    "module MassAggregationManagement {\n    class ObjectWithMass {\n        property simpleMass : Real;\n        property totalMass : Real;\n    }\n\n    class simpleThing : ObjectWithMass {\n        constraint totalMassConstraint {\n            totalMass = simpleMass;\n        }\n    }\n\n    class compositeThing : ObjectWithMass {\n        property part : ObjectWithMass[*];\n        constraint totalMassConstraint {\n            totalMass = simpleMass + sum(part.totalMass);\n        }\n    }\n}\n```",
    "package MassManagement {\n  value type Mass {\n    property value: Real;\n  }\n\n  class MassManagedObject {\n    property basicMass: Mass;\n    property subcomponents: MassManagedObject[*];\n    derived property totalMass: Mass = calculateTotalMass(massThreshold);\n  }\n\n  class MassManagementSystem {\n    property massThreshold: Mass;\n    property managedObjects: MassManagedObject[*];\n    behavior aggregateMass() returns Mass {\n      return sum(obj.calculateTotalMass(massThreshold) for obj in managedObjects if obj.calculateTotalMass(massThreshold) >= massThreshold);\n    }\n  }\n\n  behavior calculateTotalMass(threshold: Mass) returns Mass {\n    return basicMass.value + sum(sc.calculateTotalMass(threshold) for sc in subcomponents if sc.calculateTotalMass(threshold) >= threshold.value);\n  }\n}\n```",
    "module VehicleDynamicsModel {\n    block VehicleDynamicsSystem {\n        part powerCalc: PowerCalculation;\n        part accelerationCalc: AccelerationCalculation;\n        part speedCalc: SpeedCalculation;\n        part displacementCalc: DisplacementCalculation;\n    }\n\n    block PowerCalculation {\n        in wheelPower: Real;\n        in dragCoeff: Real;\n        in frictionCoeff: Real;\n        in mass: Real;\n        in speed: Real;\n        out availablePower: Real;\n    }\n\n    block AccelerationCalculation {\n        in effectivePower: Real;\n        in mass: Real;\n        in speed: Real;\n        out acceleration: Real;\n    }\n\n    block SpeedCalculation {\n        in acceleration: Real;\n        in initialSpeed: Real;\n        in time: Real;\n        out currentSpeed: Real;\n    }\n\n    block DisplacementCalculation {\n        in speed: Real;\n        in time: Real;\n        out position: Real;\n    }\n\n    function calculateAvailablePower {\n        in wheelPower: Real;\n        in dragCoeff: Real;\n        in frictionCoeff: Real;\n        in mass: Real;\n        in speed: Real;\n        out availablePower: Real;\n    }\n\n    function deduceAcceleration {\n        in effectivePower: Real;\n        in mass: Real;\n        in speed: Real;\n        out acceleration: Real;\n    }\n\n    function computeSpeedOverTime {\n        in acceleration: Real;\n        in initialSpeed: Real;\n        in time: Real;\n semantics {\n            currentSpeed = initialSpeed + acceleration * time;\n        }\n        out currentSpeed: Real;\n    }\n\n    function estimateDisplacement {\n        in speed: Real;\n        in time: Real;\n semantics {\n            position = speed * time;\n        }\n        out position: Real;\n    }\n\n    vehicleDynamicsSystem: VehicleDynamicsSystem {\n        acceleratorUses: accelerationCalc.uses(calculateAvailablePower);\n        speedUses: speedCalc.uses(deduceAcceleration);\n        displacementUses: displacementCalc.uses(computeSpeedOverTime);\n    }\n}\n```",
    "block VehicleDynamicsSimulation {\n  property aerodynamicDragCoefficient : Real;\n  property rollingResistanceCoefficient : Real;\n  property wheelEndOutputPower : Real;\n  property totalVehicleMass : Real;\n  property initialSpeed : Real;\n  property initialPosition : Real;\n  property timeStep : Real;\n  property gravity : Real = 9.81;\n}\n\nbehavior VehicleDynamicsSimulationBehavior {\n  variable currentSpeed : Real;\n  variable currentPosition : Real;\n  variable F_drag : Real;\n  variable F_rolling : Real;\n  variable drivingForce : Real;\n  variable netForce : Real;\n  variable acceleration : Real;\n  variable newSpeed : Real;\n  variable newPosition : Real;\n\n  do {\n    currentSpeed = initialSpeed;\n    currentPosition = initialPosition;\n    F_drag = 0.5 * aerodynamicDragCoefficient * currentSpeed^2;\n    F_rolling = rollingResistanceCoefficient * totalVehicleMass * gravity;\n    drivingForce = wheelEndOutputPower / currentSpeed;\n    netForce = drivingForce - (F_drag + F_rolling);\n    acceleration = netForce / totalVehicleMass;\n    newSpeed = currentSpeed + acceleration * timeStep;\n    newPosition = currentPosition + currentSpeed * timeStep + 0.5 * acceleration * timeStep^2;\n    currentSpeed = newSpeed;\n    currentPosition = newPosition;\n  }\n}\n\nstateMachine VehicleDynamicsSimulationStateMachine {\n  initial state Initial {\n    do {\n      currentSpeed = initialSpeed;\n      currentPosition = initialPosition;\n    }\n  }\n  state SimulationState {\n    do {\n      F_drag = 0.5 * aerodynamicDragCoefficient * currentSpeed^2;\n      F_rolling = rollingResistanceCoefficient * totalVehicleMass * gravity;\n      drivingForce = wheelEndOutputPower / currentSpeed;\n      netForce = drivingForce - (F_drag + F_rolling);\n      acceleration = netForce / totalVehicleMass;\n      newSpeed = currentSpeed + acceleration * timeStep;\n      newPosition = currentPosition + currentSpeed * timeStep + 0.5 * acceleration * timeStep^2;\n      currentSpeed = newSpeed;\n      currentPosition = newPosition;\n    }\n    transition to SimulationState;\n  }\n}\n```",
    "block VehicleDynamicsSystem\n  property mass : Real\n  property wheelPower : Real\n  property dragCoeff : Real\n  property rollingResCoeff : Real\n  property initialSpeed : Real\n  property initialPosition : Real\n  property timeStep : Real\n  property currentSpeed : Real\n  property currentPosition : Real\n  property acceleration : Real\n  property airDensity : Real\n  property frontalArea : Real\n  property gravity : Real\n\n  behavior computeDynamics : StateMachine\n    state Initial\n      on entry do\n        currentSpeed = initialSpeed\n        currentPosition = initialPosition\n      end\n    end\n\n    state Update\n      on entry do\n        acceleration = (wheelPower / currentSpeed - (0.5 * dragCoeff * airDensity * currentSpeed^2 * frontalArea + rollingResCoeff * mass * gravity)) / mass\n        currentSpeed = currentSpeed + acceleration * timeStep\n        currentPosition = currentPosition + currentSpeed * timeStep\n      end\n    end\n\n    transition Initial -> Update\n      when (timeStep > 0)\n    end\n\n    transition Update -> Update\n      when (timeStep > 0)\n    end\n  end\nend",
    "import sysml.units.SI;\n\nblock VehicleLongitudinalDynamics {\n  property initialPosition : Length;\n  property initialVelocity : Speed;\n  property mass : Mass;\n  property drivePower : Power;\n  property timeInterval : Duration;\n  property dragCoefficient : Dimensionless;\n  property frictionCoefficient : Dimensionless;\n  property frontalArea : Area;\n  property airDensity : Density;\n  property gravity : Acceleration;\n  property acceleration : Acceleration;\n  property finalVelocity : Speed;\n  property finalPosition : Length;\n\n  function calculateMotion() {\n    do {\n      let driveForce : Force = self.drivePower / self.initialVelocity;\n      let fDrag : Force = 0.5 * self.dragCoefficient * self.airDensity * self.frontalArea * self.initialVelocity^2;\n      let fFriction : Force = self.frictionCoefficient * self.mass * self.gravity;\n      let netForce : Force = driveForce - fDrag - fFriction;\n      self.acceleration = netForce / self.mass;\n      self.finalVelocity = self.initialVelocity + self.acceleration * self.timeInterval;\n      self.finalPosition = self.initialPosition + self.initialVelocity * self.timeInterval + 0.5 * self.acceleration * self.timeInterval^2;\n    };\n  }\n}\n```",
    "block Chassis\n  property mass : Real\nend Chassis\n\nblock Engine\n  property mass : Real\nend Engine\n\nblock Gearbox\n  property mass : Real\nend Gearbox\n\nblock Vehicle\n  part chassis : Chassis[1]\n  part engine : Engine[1]\n  part gearbox : Gearbox[1]\n  \n  property totalMass : Real = chassis.mass + engine.mass + gearbox.mass\n  constraint maxMassConstraint : totalMass <= 2500.0\n  \n  signal OverweightWarning\n  constraint warningConstraint : if totalMass > 2500.0 then emit(OverweightWarning)\nend Vehicle",
    "model VehicleMassBudget {\n  block Vehicle {\n    part: Chassis;\n    part: Engine;\n    part: Transmission;\n    mass: Real @kg;\n    totalMass: Real @kg = Chassis.mass + Engine.mass + Transmission.mass;\n    constraint: totalMass <= 2500 @kg;\n  }\n}\n```",
    "module VehicleMassCompliance {\n    block Vehicle {\n        part chassis: Chassis;\n        part engine: Engine;\n        part transmission: Transmission;\n        constraint totalMassConstraint: TotalMassConstraint;\n    }\n\n    block Chassis {\n        value mass: Real;\n    }\n\n    block Engine {\n        value mass: Real;\n    }\n\n    block Transmission {\n        value mass: Real;\n    }\n\n    constraintBlock TotalMassConstraint {\n        parameter totalMass: Real = chassis.mass + engine.mass + transmission.mass;\n        parameter massLimit: Real = 2500.0;\n        assert totalMass <= massLimit;\n    }\n}\n```",
    "model VehicleWeightManagement {\n  block VehicleSystem {\n    part chassis: Chassis;\n    part engine: Engine;\n    part transmission: Transmission;\n    part totalWeight: TotalWeight;\n    \n    derive chassis.weight + engine.weight + transmission.weight = totalWeight.value;\n    \n    constraint totalWeightConstraint: totalWeight.value <= 2500;\n  }\n  \n  block Chassis {\n    value weight: Real;\n  }\n  \n  block Engine {\n    value weight: Real;\n  }\n  \n  block Transmission {\n    value weight: Real;\n  }\n  \n  block TotalWeight {\n    value value: Real;\n  }\n  \n  behavior WarningBehavior {\n    message: String;\n  }\n  \n  action checkWeightLimit: Action {\n    if (totalWeight.value > 2500) {\n      call warningBehavior: WarningBehavior with message = \"Total weight exceeds regulatory limit of 2500 kg\";\n    }\n  }\n}\n```",
    "block Chassis\n  property mass : Real;\nend Chassis;\n\nblock Engine\n  property mass : Real;\nend Engine;\n\nblock Transmission\n  property mass : Real;\nend Transmission;\n\nblock Vehicle\n  part chassis : Chassis;\n  part engine : Engine;\n  part transmission : Transmission;\n  property totalMass : Real = chassis.mass + engine.mass + transmission.mass;\n  constraint totalMassConstraint : TotalMassConstraint;\n  constraint dynamicConstraint : DynamicConstraint;\nend Vehicle;\n\nconstraintblock TotalMassConstraint\n  parameter totalMass : Real;\n  formula totalMass <= 2500;\nend TotalMassConstraint;\n\nconstraintblock DynamicConstraint\n  parameter initialVelocity : Real;\n  parameter finalVelocity : Real;\n  parameter force : Real;\n  parameter time : Real;\n  parameter mass : Real;\n  formula mass > 0;\n  formula force * time = mass * (finalVelocity - initialVelocity);\nend DynamicConstraint;",
    "block Vehicle {\n    property nextMaintenanceTime : Duration;\n    property maintenanceInterval : Duration;\n    property maxAllowedTemperature : Temperature;\n    property status : Status;\n    property actualMaintenanceStartTime : Duration;\n}\n\nblock MaintenanceSchedule {\n    property vehicle : Vehicle;\n    property scheduledMaintenanceTime : Duration;\n}\n\nenumeration Status {\n    Healthy;\n    UnderMaintenance;\n}\n\nblock VehicleMaintenanceSystem {\n    part vehicle : Vehicle;\n    part schedule : MaintenanceSchedule;\n}\n\nconstraint ActualStartAfterScheduled {\n    context Vehicle\n    nextMaintenanceTime <= actualMaintenanceStartTime;\n}\n\nconstraint MaintenanceDurationLimit {\n    context Vehicle\n    actualMaintenanceStartTime + 48h >= nextMaintenanceTime + maintenanceInterval;\n}\n\nstateMachine VehicleHealthStateMachine {\n    state Healthy {\n        on entry: vehicle.status = Status::Healthy;\n        on exit: vehicle.actualMaintenanceStartTime = currentTime();\n    }\n    state UnderMaintenance {\n        on entry: vehicle.status = Status::UnderMaintenance;\n        on exit: vehicle.nextMaintenanceTime = vehicle.nextMaintenanceTime + vehicle.maintenanceInterval;\n    }\n    transition Healthy -> UnderMaintenance {\n        trigger: time(scheduledMaintenanceTime);\n        guard: currentTime() >= vehicle.nextMaintenanceTime;\n        effect: vehicle.actualMaintenanceStartTime = currentTime();\n        constraint: (currentTime() - vehicle.nextMaintenanceTime) <= 2s;\n    }\n    transition UnderMaintenance -> Healthy {\n        trigger: maintenanceCompleted;\n        effect: vehicle.status = Status::Healthy;\n        constraint: (exit(UnderMaintenance) - entry(UnderMaintenance)) <= 48h;\n    }\n}\n```",
    "module VehicleMassAndTorque {\n    block Vehicle {\n        part engine : Engine;\n        part clutch : Clutch;\n        part transmission : Transmission;\n        part fuel : Fuel;\n\n        parameter curbWeight : Real;\n        parameter fuelMass : Real;\n        parameter totalMass : Real = curbWeight + fuelMass;\n\n        constraint totalMass <= maxMassLimit;\n        constraint fuelMass > 0;\n    }\n\n    block Engine {\n        behavior torqueGeneration : ConstraintBehavior {\n            parameter speed : Real;\n            parameter torque : Real = f(speed);\n        }\n    }\n\n    block Clutch {\n        interface TorqueInterface {\n            parameter torque : Real;\n        }\n\n        port enginePort : TorqueInterface;\n        port transmissionPort : TorqueInterface;\n    }\n\n    block Transmission {\n        interface TorqueInterface {\n            parameter torque : Real;\n        }\n\n        port clutchPort : TorqueInterface;\n    }\n\n    block Fuel {\n        parameter mass : Real;\n    }\n\n    constraintBlock MassConstraint {\n        parameter maxMassLimit : Real;\n        constraint totalMass <= maxMassLimit;\n        constraint fuelMass > 0;\n    }\n\n    constraintBlock TorqueConstraint {\n        parameter speed : Real;\n        parameter torque : Real;\n        constraint torque = f(speed);\n    }\n}\n```",
    "package VehicleSystem {\n    constraint MaxVehicleMassConstraint {\n        parameter fullFuelMass: Real = 2000;\n        parameter emptyFuelMass: Real = 1500;\n        constraint fullFuelMass >= vehicle.dryMass + fuelTank.fullMass;\n        constraint emptyFuelMass >= vehicle.dryMass + fuelTank.emptyMass;\n    }\n\n    block Vehicle {\n        property dryMass: Real;\n        property fuelTank: FuelTank;\n        constraint maxMass: MaxVehicleMassConstraint;\n    }\n\n    block FuelTank {\n        property fullMass: Real;\n        property emptyMass: Real;\n    }\n\n    block Powertrain {\n        port engineTorqueOut: FlowPort<Real> {direction = out};\n        port transmissionTorqueIn: FlowPort<Real> {direction = in};\n        interface clutchInterface: ClutchInterface;\n    }\n\n    block Engine {\n        property speed: Real;\n        property torque: Real;\n        constraint torqueCurve: SpeedTorqueConstraint;\n    }\n\n    block Transmission {\n        property inputTorque: Real;\n    }\n\n    interface ClutchInterface {\n        port torqueTransfer: FlowPort<Real> {direction = both};\n    }\n\n    constraint SpeedTorqueConstraint {\n        parameter speed: Real;\n        parameter torque: Real;\n        constraint torque = lookupTable(speed, \"Table1_SpeedTorqueCurve\");\n    }\n\n    requirement SystemRequirements {\n        requirement massControl: \"Regulate vehicle mass to ensure safety and compliance with 2000 kg (full fuel) and 1500 kg (empty fuel) limits\";\n        requirement powertrainInterface: \"Ensure engine torque is transmitted to transmission via clutch interface\";\n        requirement powertrainPerformance: \"Engine must deliver torque according to speed-torque curve (Table 1)\";\n    }\n}\n```",
    "package VehicleModel {\n    block Vehicle {\n        property massWhenFueled : Real;\n        property massWhenEmpty : Real;\n        constraint c1 : MassConstraint;\n        constraint c2 : PowerInterfaceConstraint;\n    }\n\n    block Engine {\n        property torque : Real;\n        property speed : Real;\n        port clutchInterface : ClutchInterface;\n        constraint c3 : TorqueSpeedConstraint;\n        flow f1 : TorqueFlow;\n    }\n\n    block ClutchInterface {\n        flow f2 : TorqueFlow;\n    }\n\n    constraintBlock MassConstraint {\n        parameter massWhenFueled : Real;\n        parameter massWhenEmpty : Real;\n        constraint massWhenFueled <= 2000;\n        constraint massWhenEmpty <= 1500;\n    }\n\n    constraintBlock PowerInterfaceConstraint {\n        parameter torque : Real;\n        parameter speed : Real;\n        constraint torque > 0;\n        constraint speed > 0;\n    }\n\n    constraintBlock TorqueSpeedConstraint {\n        table t1 : TorqueSpeedTable;\n    }\n\n    table TorqueSpeedTable {\n        column Speed : Real;\n        column Torque : Real;\n        row 0.0 : 0.0;\n        row 1000.0 : 150.0;\n        row 2000.0 : 300.0;\n        row 3000.0 : 250.0;\n        row 4000.0 : 200.0;\n        row 5000.0 : 150.0;\n    }\n\n    flow TorqueFlow {\n        property torque : Real;\n    }\n\n    model SystemModel {\n        vehicle : Vehicle;\n        engine : Engine;\n        transmission : ClutchInterface;\n\n        satisfy vehicle.c1 by vehicle;\n        satisfy vehicle.c2 by engine;\n        satisfy engine.c3 by engine.t1;\n\n        constrain engine.torque by engine.f1;\n        constrain engine.speed by engine.f1;\n\n        connect engine.clutchInterface to transmission;\n    }\n}\n```",
    "module VehicleMassAndPowerModel {\n    block Vehicle {\n        part engine : Engine;\n        part gearbox : Gearbox;\n        constraint VehicleMassConstraint;\n    }\n\n    block Engine {\n        port clutchOut : ClutchInterface;\n        behavior torqueGeneration {\n            input speed : Real;\n            output torque : Real;\n            // Torque generation logic based on speed\n        }\n    }\n\n    block Gearbox {\n        port clutchIn : ClutchInterface;\n    }\n\n    block ClutchInterface {\n        flow torque : Real;\n    }\n\n    constraintblock VehicleMassConstraint {\n        parameter curbMass : Real;\n        parameter fuelMassFull : Real;\n        parameter fuelMassEmpty : Real;\n        parameter totalMassFull : Real = curbMass + fuelMassFull;\n        parameter totalMassEmpty : Real = curbMass + fuelMassEmpty;\n        assert totalMassFull <= 2000.0 @kg;\n        assert totalMassEmpty <= 1500.0 @kg;\n    }\n\n    constraintblock TorqueCharacteristics {\n        parameter engineTorque : Real;\n        parameter gearboxTorque : Real;\n        assert engineTorque == gearboxTorque;\n    }\n\n    // Apply TorqueCharacteristics constraint to clutch interface\n    apply ClutchInterface.TorqueCharacteristics;\n}",
    "module VehiclePerformanceAnalysis {\n    block Vehicle {\n        property curbWeight : Real;\n        property payload : Real;\n        property wheelDiameter : Real;\n        property transmissionEfficiency : Real;\n        property urbanFuelEconomy : Real;\n        property highwayFuelEconomy : Real;\n    }\n\n    value type DrivingCycleDataPoint {\n        time : Real;\n        position : Real;\n        speed : Real;\n    }\n\n    block DrivingCycle {\n        property dataPoints : List<DrivingCycleDataPoint>;\n    }\n\n    block VehiclePerformanceAnalysisSystem {\n        part vehicle : Vehicle;\n        part drivingCycle : DrivingCycle;\n\n        operation calculatePowerDemand() : Real {\n            // Implementation logic for power demand calculation\n        }\n\n        operation calculateAcceleration() : Real {\n            // Implementation logic for acceleration calculation\n        }\n\n        operation calculateSpeed() : Real {\n            // Implementation logic for speed calculation\n        }\n\n        operation calculatePosition() : Real {\n            // Implementation logic for position calculation\n        }\n\n        operation calculateFuelEconomy() : Real {\n            // Implementation logic for fuel economy calculation\n        }\n\n        operation verifyCompliance(targetFuelEconomy : Real) : Boolean {\n            // Implementation logic for compliance verification\n        }\n    }\n}\n```",
    "model VehicleFuelEconomySimulation {\n  block VehicleFuelEconomySimulationSystem {\n    part simulationEngine : SimulationEngine;\n    part scenarioManager : ScenarioManager;\n    part vehicleDynamicsAnalyzer : VehicleDynamicsAnalyzer;\n    part fuelEconomyCalculator : FuelEconomyCalculator;\n  }\n\n  block SimulationEngine {\n    behavior runSimulation : RunSimulationActivity;\n  }\n\n  block ScenarioManager {\n    part urbanScenario : DrivingScenario;\n    part highwayScenario : DrivingScenario;\n  }\n\n  block DrivingScenario {\n    value trajectory : TrajectoryProfile;\n    value speedVariation : SpeedProfile;\n  }\n\n  block VehicleDynamicsAnalyzer {\n    behavior calculateAcceleration : CalculateAccelerationActivity;\n    behavior calculateEnergyConsumption : CalculateEnergyConsumptionActivity;\n  }\n\n  block FuelEconomyCalculator {\n    behavior estimateEnginePower : EstimateEnginePowerActivity;\n    behavior determineFuelConsumption : DetermineFuelConsumptionActivity;\n    value fuelEconomy : FuelEconomyMetric;\n  }\n\n  block VehicleParameters {\n    value curbWeight : Weight;\n    value load : Weight;\n    value wheelDiameter : Length;\n    value transmissionEfficiency : Efficiency;\n  }\n\n  value type Weight {\n    unit kg;\n  }\n\n  value type Length {\n    unit m;\n  }\n\n  value type Efficiency {\n    unit dimensionless;\n  }\n\n  value type TrajectoryProfile {\n    unit km;\n  }\n\n  value type SpeedProfile {\n    unit km/h;\n  }\n\n  value type FuelEconomyMetric {\n    unit L/100km;\n  }\n\n  activity RunSimulationActivity {\n    input vehicleParams : VehicleParameters;\n    input drivingScenario : DrivingScenario;\n    output fuelEconomyResult : FuelEconomyMetric;\n    output complianceStatus : Boolean;\n    \n    action analyzeWheelPower {\n      input vehicleParams : VehicleParameters;\n      input drivingScenario : DrivingScenario;\n      output wheelPower : Power;\n    }\n    \n    action calculateAcceleration {\n      input wheelPower : Power;\n      input vehicleParams : VehicleParameters;\n      output acceleration : Acceleration;\n    }\n    \n    action calculateEnergyConsumption {\n      input acceleration : Acceleration;\n      input vehicleParams : VehicleParameters;\n      output energyConsumption : Energy;\n    }\n    \n    action estimateEnginePower {\n      input energyConsumption : Energy;\n      input vehicleParams : VehicleParameters;\n      output enginePower : Power;\n    }\n    \n    action determineFuelConsumption {\n      input enginePower : Power;\n      input drivingScenario : DrivingScenario;\n      output fuelEconomy : FuelEconomyMetric;\n    }\n    \n    action checkCompliance {\n      input fuelEconomy : FuelEconomyMetric;\n      output compliance : Boolean;\n    }\n    \n    flow analyzeWheelPower -> calculateAcceleration;\n    flow calculateAcceleration -> calculateEnergyConsumption;\n    flow calculateEnergyConsumption -> estimateEnginePower;\n    flow estimateEnginePower -> determineFuelConsumption;\n    flow determineFuelConsumption -> checkCompliance;\n  }\n\n  constraint block FuelEconomyRequirement {\n    constraint fuelEconomy > 30 * (1.60934 / 100) / 0.264172; // 30 mpg converted to L/100km\n  }\n}\n```",
    "model EngineSelectionAnalysis {\n  class Engine {\n    property power : Real;\n    property mass : Real;\n    property efficiency : Real;\n    property cost : Real;\n  }\n\n  class FourCylinderEngine extends Engine {\n  }\n\n  class SixCylinderEngine extends Engine {\n  }\n\n  class EvaluationFunction {\n    method evaluate(power : Real, mass : Real, efficiency : Real, cost : Real) : Real {\n      return (0.4 * power) + (0.2 * efficiency) - (0.15 * mass) - (0.25 * cost);\n    }\n  }\n\n  class EngineSelection {\n    method selectOptimalEngine(engines : List<Engine>, evaluator : EvaluationFunction) : Engine {\n      var bestScore : Real = -Infinity;\n      var bestEngine : Engine = null;\n      for (engine in engines) {\n        var score : Real = evaluator.evaluate(engine.power, engine.mass, engine.efficiency, engine.cost);\n        if (score > bestScore) {\n          bestScore = score;\n          bestEngine = engine;\n        }\n      }\n      return bestEngine;\n    }\n  }\n\n  class EngineCandidate {\n    property engine : Engine;\n    property evaluationScore : Real;\n  }\n\n  class EngineRecommendation {\n    method generateRecommendation(candidates : List<EngineCandidate>) : Engine {\n      return candidates.sortBy(candidate => -candidate.evaluationScore).head.engine;\n    }\n  }\n}\n```",
    "block Vehicle\n  property curbWeight : Real\nend Vehicle\n\nblock CurbWeightConstraint\n  constraint maxCurbWeight : Real = 2500.0\n  constraint unit : String = \"kg\"\nend CurbWeightConstraint\n\nactivity VehicleCurbWeightCheckProcess\n  action CollectWeightData\n    out port rawWeightData : FlowItem<RawWeightData>\n  end CollectWeightData\n\n  action ProcessWeightData\n    in port rawWeightData : FlowItem<RawWeightData>\n    out port processedWeightData : FlowItem<ProcessedWeightData>\n  end ProcessWeightData\n\n  action EvaluateWeightCompliance\n    in port processedWeightData : FlowItem<ProcessedWeightData>\n    in port weightConstraint : CurbWeightConstraint\n    out port evaluationResult : FlowItem<ComplianceStatus>\n  end EvaluateWeightCompliance\n\n  flowItem RawWeightData\n    property weight : Real\n    property unit : String\n  end RawWeightData\n\n  flowItem ProcessedWeightData\n    property weight : Real\n    property unit : String\n  end ProcessedWeightData\n\n  flowItem ComplianceStatus\n    property status : Boolean\n    property message : String\n  end ComplianceStatus\n\n  sequence\n    CollectWeightData\n    ProcessWeightData\n    EvaluateWeightCompliance\n  end sequence\n\n  constraintBlock WeightComparisonConstraint\n    valueSpec maxWeight : Real = 2500.0\n    valueSpec unit : String = \"kg\"\n    constraintExpression \n      processedWeightData.weight <= maxWeight\n  end WeightComparisonConstraint\nend VehicleCurbWeightCheckProcess",
    "block MassVerificationSystem  \n  part vehicle: Vehicle  \n  part weighingEquipment: WeighingEquipment  \n  part massVerificationUnit: MassVerificationUnit  \n\nblock Vehicle  \n  property actualMass: MassValue  \n  property qualificationStatus: Boolean  \nend  \n\nblock WeighingEquipment  \n  property measuredMass: MassValue  \n  behavior measureMass: Activity  \n    input vehicle: Vehicle  \n    output measuredMass: MassValue  \n  end  \nend  \n\nblock MassVerificationUnit  \n  property massLimit: MassValue = 2500 kg  \n  behavior verifyMass: Activity  \n    input measuredMass: MassValue  \n    output qualificationStatus: Boolean  \n    action compareMass:  \n      if (measuredMass <= massLimit) then  \n        qualificationStatus = true  \n      else  \n        qualificationStatus = false  \n      end  \n  end  \nend  \n\nvalue MassValue  \n  unit kg  \n  value 2500  \nend  \n\nconstraint IndependentVerification  \n  applies to MassVerificationSystem  \n  each vehicle must be processed independently by massVerificationUnit  \nend",
    "package TransportationSystem {\n    block TransportationSystem {\n        driver: Driver;\n        passengers: Passenger[*] {size <= 4};\n        property safetyConstraint: Constraint {appliesTo: TransportationSystem};\n        property sustainabilityConstraint: Constraint {appliesTo: TransportationSystem};\n        property infrastructureCompatibilityConstraint: Constraint {appliesTo: TransportationSystem};\n    }\n\n    block Driver {\n        property userInterface: UserInterface;\n    }\n\n    block Passenger {\n        property comfortSettings: ComfortSettings;\n    }\n\n    function TransportFunction {\n        parameter startPoint: Location {direction: in};\n        parameter destination: Location {direction: in};\n        parameter transportationResult: TransportationResult {direction: out};\n    }\n\n    function UserEntryExitFunction {\n        parameter entryProcess: EntryProcess {direction: in};\n        parameter exitProcess: ExitProcess {direction: in};\n        parameter smoothness: Boolean {direction: out};\n    }\n\n    function EnvironmentalIntegrationFunction {\n        parameter environmentalFactors: EnvironmentalFactors {direction: in};\n        parameter safetyAssessment: SafetyAssessment {direction: out};\n    }\n\n    function InfrastructureCompatibilityFunction {\n        parameter gasStationInterface: GasStationInterface {direction: in};\n        parameter compatibilityStatus: Boolean {direction: out};\n    }\n\n    function RideExperienceFunction {\n        parameter convenienceFeatures: ConvenienceFeatures {direction: in};\n        parameter userSatisfaction: SatisfactionLevel {direction: out};\n    }\n\n    function DailyTransportationSupportFunction {\n        parameter transportationTask: TransportationTask {direction: in};\n        parameter taskCompletion: Boolean {direction: out};\n    }\n\n    requirement TransportationRequirement {\n        id: \"TR-001\";\n        text: \"The system shall provide safe and comfortable transportation for driver and up to four passengers.\";\n    }\n\n    requirement EntryExitRequirement {\n        id: \"TR-002\";\n        text: \"The system shall ensure simple and smooth user entry and exit processes.\";\n    }\n\n    requirement EnvironmentalSafetyRequirement {\n        id: \"TR-003\";\n        text: \"The system shall integrate surrounding environmental factors to ensure journey safety and sustainability.\";\n    }\n\n    requirement InfrastructureCompatibilityRequirement {\n        id: \"TR-004\";\n        text: \"The system shall be compatible with related infrastructure such as gas stations.\";\n    }\n\n    requirement UserCentricRequirement {\n        id: \"TR-005\";\n        text: \"The system shall prioritize human needs with a focus on ride experience and daily transportation task assistance.\";\n    }\n\n    constraint SafetyConstraint {\n        id: \"SC-001\";\n        text: \"All transportation operations must comply with ISO 26262 safety standards.\";\n    }\n\n    constraint SustainabilityConstraint {\n        id: \"SC-002\";\n        text: \"The system must minimize environmental impact through energy-efficient operations.\";\n    }\n\n    constraint PassengerCapacityConstraint {\n        id: \"SC-003\";\n        text: \"Maximum passenger capacity including driver shall not exceed 4 individuals.\";\n    }\n}",
    "model TransportationSystemModel {  \n    block TransportationSystem {  \n        driver : Driver  \n        passengers : Passenger[*]  \n        constraint passengers.size() <= 4  \n    }  \n\n    block Driver {  \n        extends Participant  \n    }  \n\n    block Passenger {  \n        extends Participant  \n    }  \n\n    block Participant {  \n        // Base properties for all participants  \n    }  \n\n    use case EnterVehicle {  \n        context TransportationSystem  \n        primary actor Driver  \n        secondary actor Passenger  \n        description \"Users enter the vehicle before starting the journey.\"  \n    }  \n\n    use case OperateVehicle {  \n        context TransportationSystem  \n        primary actor Driver  \n        description \"Driver operates the vehicle considering environmental conditions.\"  \n        constraint \"Environmental conditions (e.g., weather, road) must be accounted for during operation.\"  \n    }  \n\n    use case RefuelVehicle {  \n        context TransportationSystem  \n        primary actor Driver  \n        description \"Driver refuels the vehicle at a gas station to ensure a smooth journey.\"  \n        condition \"Triggered when fuel level is insufficient for remaining distance.\"  \n    }  \n\n    use case ExitVehicle {  \n        context TransportationSystem  \n        primary actor Driver  \n        secondary actor Passenger  \n        description \"Users exit the vehicle upon arrival at the destination.\"  \n    }  \n\n    use case TransportUsers {  \n        context TransportationSystem  \n        primary actor Driver  \n        secondary actor Passenger  \n        description \"Comprehensive transportation from start to destination.\"  \n        include EnterVehicle  \n        include OperateVehicle  \n        include RefuelVehicle  \n        include ExitVehicle  \n    }  \n\n    requirement SafetyRequirement {  \n        text \"The system must ensure safety for all participants during entry, operation, refueling, and exit.\"  \n    }  \n\n    requirement CapacityRequirement {  \n        text \"The system must support a driver and up to four passengers simultaneously.\"  \n    }  \n\n    requirement RefuelingRequirement {  \n        text \"The system must allow refueling at gas stations to maintain uninterrupted transportation.\"  \n    }  \n\n    requirement EnvironmentalAdaptationRequirement {  \n        text \"The system must operate effectively under varying environmental conditions (e.g., weather, road quality).\"  \n    }  \n\n    requirement InteractionSimplicityRequirement {  \n        text \"Interactions between driver, passengers, and the vehicle must be simple and convenient for daily use.\"  \n    }  \n}",
    "module VehicleConfiguration {\n    block Vehicle {\n        part engine : Engine;\n        part transmission : Transmission;\n    }\n\n    block Engine {\n        property cylinderCount : Integer { \n            constraint CylinderCountConstraint;\n        }\n        property cylinderDiameter : Integer { \n            constraint CylinderDiameterConstraint;\n        }\n    }\n\n    block Transmission {\n        property type : String { \n            constraint TransmissionTypeConstraint;\n        }\n    }\n\n    constraintblock CylinderCountConstraint {\n        context Engine\n        inv: self.cylinderCount = 4 or self.cylinderCount = 6;\n    }\n\n    constraintblock CylinderDiameterConstraint {\n        context Engine\n        inv: self.cylinderDiameter = 70 or self.cylinderDiameter = 100;\n    }\n\n    constraintblock TransmissionTypeConstraint {\n        context Vehicle\n        inv: if self.transmission.type = 'manual' then self.engine.cylinderCount = 4 else true endif;\n        inv: if self.engine.cylinderCount = 6 then self.transmission.type = 'automatic' else true endif;\n    }\n\n    variantmodel EngineVariants {\n        variantmember engine : Engine {\n            variantoption FourCylinderEngine : Engine {\n                constraint CylinderCountConstraint { value = 4 }\n            }\n            variantoption SixCylinderEngine : Engine {\n                constraint CylinderCountConstraint { value = 6 }\n            }\n        }\n    }\n\n    variantmodel TransmissionVariants {\n        variantmember transmission : Transmission {\n            variantoption ManualTransmission : Transmission {\n                constraint TransmissionTypeConstraint { value = 'manual' }\n            }\n            variantoption AutomaticTransmission : Transmission {\n                constraint TransmissionTypeConstraint { value = 'automatic' }\n            }\n        }\n    }\n\n    constraintblock VariantConstraint {\n        context Vehicle\n        inv: self.engineVariants.engine = FourCylinderEngine implies self.transmissionVariants.transmission = ManualTransmission;\n        inv: self.engineVariants.engine = SixCylinderEngine implies self.transmissionVariants.transmission = AutomaticTransmission;\n    }\n}\n```",
    "unit mm = 0.001 * m;\n\ntype Length = Real { unit mm };\n\nblock Cylinder {\n  value diameter : Length;\n  constraint diameterConstraint {\n    diameter in {70, 100};\n  }\n}\n\nblock Engine {\n  part Cylinders : Cylinder[*];\n  value cylinderCount : Integer;\n  value cylinderDiameter : Length;\n  constraint cylinderCountConstraint {\n    cylinderCount in {4, 6};\n  }\n  constraint cylinderDiameterConstraint {\n    cylinderDiameter in {70, 100};\n  }\n  constraint cylinderCountBinding {\n    size(Cylinders) = self.cylinderCount;\n  }\n  constraint diameterBinding {\n    for all c in Cylinders: c.diameter = self.cylinderDiameter;\n  }\n}\n```",
    "module AutomotiveConfiguration {\n    enum CylinderCountType {\n        Four,\n        Six\n    }\n\n    enum TransmissionType {\n        Manual,\n        Automatic\n    }\n\n    block Engine {\n        property cylinderCount : CylinderCountType\n        property cylinderDiameter : ValueInteger\n    }\n\n    block Transmission {\n        property transmissionType : TransmissionType\n    }\n\n    block Vehicle {\n        part engine : Engine\n        part transmission : Transmission\n        apply EngineTransmissionConstraint\n        apply CylinderDiameterConstraint\n    }\n\n    constraintblock EngineTransmissionConstraint {\n        apply constraint engineTransmissionConstraint : \n            (engine.cylinderCount = CylinderCountType::Four) implies (transmission.transmissionType = TransmissionType::Manual) and\n            (engine.cylinderCount = CylinderCountType::Six) implies (transmission.transmissionType = TransmissionType::Automatic)\n    }\n\n    constraintblock CylinderDiameterConstraint {\n        apply constraint diameterConstraint : \n            engine.cylinderDiameter = 70 or engine.cylinderDiameter = 100\n    }\n}",
    "valuetype MessageFormat\nvaluetype DataFormat\n\nblock SystemConstraint\n  parameters:\n    efficiency: Boolean = true\n    reliability: Boolean = true\n    compliance: Boolean = true\n\nblock ComputerSubSystem\n  properties:\n    messageFormat: MessageFormat\n    dataFormat: DataFormat\n\nblock StorageSubSystem\n  properties:\n    messageFormat: MessageFormat\n    dataFormat: DataFormat\n\nblock SystemAssembly\n  parts:\n    computer: ComputerSubSystem\n    storage: StorageSubSystem\n  apply SystemConstraint",
    "block LogicalPowertrain\n  part logicalTorqueGenerator : LogicalTorqueGenerator\nend LogicalPowertrain\n\nblock LogicalTorqueGenerator\n  behavior generateTorque : Behavior\nend LogicalTorqueGenerator\n\nblock PhysicalPowertrain\n  part physicalPowerUnit : PhysicalPowerUnit\nend PhysicalPowertrain\n\nblock PhysicalPowerUnit\n  part engine : Engine\n  behavior outputPower : Behavior\n  behavior generateTorque : Behavior\nend PhysicalPowerUnit\n\nblock Engine\n  // Physical implementation details\nend Engine\n\nsubstitution LogicalTorqueGeneratorSubstitution\n  source : LogicalTorqueGenerator\n  target : PhysicalPowerUnit\n  mapping logicalTorqueGenerator.generateTorque to physicalPowerUnit.generateTorque\nend LogicalTorqueGeneratorSubstitution\n\nrelationship RealizesPowerOutput\n  source : PhysicalPowerUnit.outputPower\n  target : LogicalPowertrain\nend RealizesPowerOutput\n\nrelationship RealizesTorqueGeneration\n  source : PhysicalPowerUnit.generateTorque\n  target : LogicalTorqueGenerator.generateTorque\nend RealizesTorqueGeneration",
    "block PowerTransmissionSystem {\n  part torqueGenerator : TorqueGenerator;\n  allocate (torqueGenerator) to (powertrain);\n}\n\nblock TorqueGenerator {\n  behavior generateTorque : Action;\n  realize (PowerDeliveryAndGeneration);\n}\n\nblock Powertrain {\n  part engine : Engine;\n  allocate (engine) to (generateTorque);\n}\n\nblock Engine {\n  behavior generateTorque : Action;\n}\n\ncapability PowerDeliveryAndGeneration {\n  action generateTorque;\n}\n```",
    "model VehicleFeatureAnnotationSystemModel {  \n  block VehicleFeatureAnnotationSystem {  \n    part interiorAssembly: InteriorAssembly;  \n    part bodyAssembly: BodyAssembly;  \n  }  \n\n  block InteriorAssembly {  \n    part seatBelt: SeatBelt;  \n    part frontSeat: FrontSeat;  \n    part driverAirbag: DriverAirbag;  \n    part alarmSystem: AlarmSystem;  \n  }  \n\n  block BodyAssembly {  \n    part bodyShell: BodyShell;  \n    part bumper: Bumper;  \n    part keylessEntryDevice: KeylessEntryDevice;  \n  }  \n\n  block SeatBelt {  \n    ref safetyFunction: SafetyFunction;  \n  }  \n\n  block DriverAirbag {  \n    ref safetyFunction: SafetyFunction;  \n  }  \n\n  block Bumper {  \n    ref safetyFunction: SafetyFunction;  \n  }  \n\n  block AlarmSystem {  \n    ref protectionFunction: ProtectionFunction;  \n  }  \n\n  block KeylessEntryDevice {  \n    ref protectionFunction: ProtectionFunction;  \n  }  \n\n  block SafetyFunction {  \n    behavior: \"Provides occupant restraint and impact absorption during collisions\";  \n  }  \n\n  block ProtectionFunction {  \n    behavior: \"Prevents unauthorized access and detects theft attempts\";  \n  }  \n}",
    "block ModelCenterInterface\n  operation sendData(data: Data) : Boolean\n  operation receiveResults(results: Data) : Boolean\nend\n\nblock VehicleSimulationSystem\n  property initialVelocity : Real\n  property initialPosition : Real\n  property acceleration : Real\n  property timeStep : Real\n  property finalVelocity : Real\n  property finalPosition : Real\n\n  behavior calculateVehicleDynamics\n    activity\n      parameter initialVelocity : Real\n      parameter initialPosition : Real\n      parameter acceleration : Real\n      parameter timeStep : Real\n      parameter finalVelocity : Real\n      parameter finalPosition : Real\n\n      action calculateFinalVelocity\n        OpaqueAction\n        input initialVelocity, acceleration, timeStep\n        output finalVelocity\n        body: finalVelocity = initialVelocity + acceleration * timeStep\n      end\n\n      action calculateFinalPosition\n        OpaqueAction\n        input initialVelocity, initialPosition, acceleration, timeStep\n        output finalPosition\n        body: finalPosition = initialPosition + initialVelocity * timeStep + 0.5 * acceleration * timeStep^2\n      end\n\n      action interfaceWithModelCenter\n        OpaqueAction\n        input finalVelocity, finalPosition\n        output modelCenterResults\n        body: modelCenterResults = ModelCenterInterface.sendData({velocity: finalVelocity, position: finalPosition})\n      end\n    end\n  end\nend\n```",
    "package SafetyComplianceModel {\n    block Car {\n        part interior: Interior;\n        part body: Body;\n        part wheelAssembly: WheelAssembly;\n    }\n\n    package SafetyFeatures {\n        block SeatBelt {\n            annotation @Safety;\n            isMandatory: true;\n        }\n\n        block DriverAirbag {\n            annotation @Safety;\n            isMandatory: false;\n        }\n\n        block Bumper {\n            annotation @Safety;\n            isMandatory: true;\n        }\n\n        block AntiLockBrakingSystem {\n            annotation @Safety;\n            isMandatory: false;\n        }\n    }\n\n    package MandatorySafetyFeatures {\n        block SeatBelt {\n            annotation @Safety;\n            isMandatory: true;\n        }\n\n        block Bumper {\n            annotation @Safety;\n            isMandatory: true;\n        }\n    }\n\n    block Interior {\n        part seatBelt: SafetyFeatures::SeatBelt [2];\n        part driverAirbag: SafetyFeatures::DriverAirbag;\n    }\n\n    block Body {\n        part bumper: SafetyFeatures::Bumper;\n    }\n\n    block WheelAssembly {\n        part wheel: Wheel [2];\n        part absSystem: SafetyFeatures::AntiLockBrakingSystem isOptional: true;\n    }\n\n    block Wheel {\n        // No safety annotations or mandatory flags\n    }\n\n    block KeylessEntrySystem {\n        // No safety annotations or mandatory flags\n    }\n}\n```",
    "module VehicleSafetyCompliance {\n  block Vehicle {\n    part interior: Interior;\n    part body: Body;\n    part chassis: Chassis;\n  }\n\n  block Interior {\n    part seatBelts: SeatBelt [2..2];\n    part driverAirbag: Airbag [0..1];\n  }\n\n  block Body {\n    part bumper: Bumper [1..1];\n    part keylessEntrySystem: KeylessEntry [0..1];\n  }\n\n  block Chassis {\n    part tires: Tire [4..4];\n    part abs: ABS [0..1];\n  }\n\n  block SafetyFeature {\n    property mandatory: Boolean;\n  }\n\n  constraint MandatorySafetyFeature {\n    apply to (feature: SafetyFeature) {\n      feature.mandatory = true;\n    }\n  }\n\n  constraint OptionalSafetyFeature {\n    apply to (feature: SafetyFeature) {\n      feature.mandatory = false;\n    }\n  }\n\n  block SeatBelt {\n    conforms to SafetyFeature;\n    apply MandatorySafetyFeature;\n  }\n\n  block Bumper {\n    conforms to SafetyFeature;\n    apply MandatorySafetyFeature;\n  }\n\n  block ABS {\n    conforms to SafetyFeature;\n    apply OptionalSafetyFeature;\n  }\n\n  block Airbag {\n    conforms to SafetyFeature;\n    apply OptionalSafetyFeature;\n  }\n\n  block KeylessEntry {\n    // Non-mandatory configuration, no safety feature constraint applied\n  }\n\n  block Tire {\n    conforms to SafetyFeature;\n    apply MandatorySafetyFeature;\n  }\n}",
    "package RiskManagementSystem {\n  block RiskScenario {\n    parts:\n      situations : List<Situation>\n      causes : List<Cause>\n      failures : List<Failure>\n      causalLinks : List<CausalLink>\n      impactLinks : List<ImpactLink>\n  }\n\n  block Situation {\n    name : String\n    description : String\n  }\n\n  block Cause {\n    probability : Float\n    description : String\n  }\n\n  block Failure {\n    severity : Integer\n    description : String\n  }\n\n  block CausalLink {\n    source : Cause\n    target : Situation\n  }\n\n  block ImpactLink {\n    source : Situation\n    target : Failure\n  }\n}",
    "package RiskMetadataModeling {\n  class Scenario {\n    property name : String;\n    property description : String;\n    property causes : Cause[*];\n    property failures : Failure[*];\n  }\n\n  class Cause {\n    property scenario : Scenario;\n    property probability : Float;\n    property description : String;\n  }\n\n  class Failure {\n    property scenario : Scenario;\n    property severity : Integer;\n    property description : String;\n  }\n\n  association CausalRelationship {\n    member end sourceScenario : Scenario[*] [1];\n    member end targetScenario : Scenario[*] [1];\n    property strength : Float;\n  }\n\n  class RiskScenario {\n    property name : String;\n    property description : String;\n    property componentScenarios : Scenario[*];\n    property componentCauses : Cause[*];\n    property componentFailures : Failure[*];\n  }\n}",
    "model RiskAnalysisSystem {\n  block Battery {\n    property level : Float;\n    property aging : Boolean;\n  }\n\n  block System {\n    part battery : Battery;\n    reference batteryLevelConstraint : BatteryLevelConstraint;\n    reference failureScenario : FailureScenario;\n\n    behavior monitorBatteryLevel {\n      action checkBatteryStatus {\n        if (battery.aging == true) {\n          riskScenario := failureScenario.identifyRisk(\"battery aging\", \"low battery level\");\n        }\n        if (battery.level < batteryLevelConstraint.minLevel) {\n          systemState := \"low battery\";\n          if (durationInLowBattery > 30 minutes) {\n            triggerShutdown();\n          }\n        }\n      }\n    }\n\n    stateMachine OperationalStates {\n      state NormalOperation {\n        on entry: systemState := \"normal\";\n      }\n      state LowBattery {\n        on entry: systemState := \"low battery\";\n        when (durationInLowBattery > 30 minutes) {\n          transition to: DeviceShutdown;\n        }\n      }\n      state DeviceShutdown {\n        on entry: systemState := \"shutdown\";\n        consequence := \"device shutdown\";\n      }\n    }\n\n    constraintBlock BatteryLevelConstraint {\n      property minLevel : Float;\n    }\n\n    enumeration SeverityLevel {\n      Low, Medium, High, Critical;\n    }\n\n    block FailureScenario {\n      property risk : String;\n      property consequence : String;\n      property severity : SeverityLevel;\n\n      function identifyRisk(riskCause : String, riskEffect : String) : String {\n        return riskCause + \" may lead to \" + riskEffect;\n      }\n\n      function assignSeverity(risk : String, consequence : String) : SeverityLevel {\n        if (consequence == \"device shutdown\") {\n          return Critical;\n        } else {\n          return Medium;\n        }\n      }\n    }\n  }\n}\n```",
    "model StructuralDecomposition {\n  block System {\n    part subsystemA: SubsystemA;\n    part subsystemB: SubsystemB;\n    connects subsystemA.interfaceA to subsystemB.interfaceB;\n  }\n\n  block SubsystemA {\n    part componentA1: ComponentA1;\n    part componentA2: ComponentA2;\n    connects componentA1.interfaceA1 to componentA2.interfaceA2;\n    provides interfaceA;\n  }\n\n  block SubsystemB {\n    part componentB1: ComponentB1;\n    part componentB2: ComponentB2;\n    connects componentB1.interfaceB1 to componentB2.interfaceB2;\n    requires interfaceB;\n  }\n\n  interfaceBlock interfaceA {\n    port p1: Port;\n  }\n\n  interfaceBlock interfaceB {\n    port p2: Port;\n  }\n\n  block ComponentA1 {\n    provides interfaceA1;\n  }\n\n  interfaceBlock interfaceA1 {\n    port p1: Port;\n  }\n\n  block ComponentA2 {\n    requires interfaceA2;\n  }\n\n  interfaceBlock interfaceA2 {\n    port p2: Port;\n  }\n\n  block ComponentB1 {\n    provides interfaceB1;\n  }\n\n  interfaceBlock interfaceB1 {\n    port p1: Port;\n  }\n\n  block ComponentB2 {\n    requires interfaceB2;\n  }\n\n  interfaceBlock interfaceB2 {\n    port p2: Port;\n  }\n}\n```",
    "stereotype SafetyComponent {\n  property mandatory : Boolean;\n  property optional : Boolean;\n}\n\nblock AutomotiveSystem {\n  part chassis : Chassis;\n  part powertrain : Powertrain;\n  part electrical : Electrical;\n  part interior : Interior;\n  interface topLevelInterface : TopLevelInterface;\n}\n\nblock Chassis {\n  part bumpers : Bumpers;\n  part suspension : Suspension;\n  part abs : ABS;\n  interface chassisInterface : ChassisInterface;\n}\n\nblock Bumpers {\n  interface mechanicalInterface : MechanicalInterface;\n  apply SafetyComponent { mandatory: true };\n}\n\nblock Suspension {\n  interface suspensionInterface : SuspensionInterface;\n}\n\nblock ABS {\n  interface brakeControlInterface : BrakeControlInterface;\n  apply SafetyComponent { optional: true };\n}\n\nblock Powertrain {\n  part engine : Engine;\n  part transmission : Transmission;\n  interface powertrainInterface : PowertrainInterface;\n}\n\nblock Engine {\n  interface engineInterface : EngineInterface;\n}\n\nblock Transmission {\n  interface transmissionInterface : TransmissionInterface;\n}\n\nblock Electrical {\n  part battery : Battery;\n  part ecu : ECU;\n  interface electricalInterface : ElectricalInterface;\n}\n\nblock Battery {\n  interface powerInterface : PowerInterface;\n}\n\nblock ECU {\n  interface controlInterface : ControlInterface;\n}\n\nblock Interior {\n  part seatBelts : SeatBelts;\n  part driverAirbag : DriverAirbag;\n  part passengerAirbag : PassengerAirbag;\n  part dashboard : Dashboard;\n  interface interiorInterface : InteriorInterface;\n}\n\nblock SeatBelts {\n  interface restraintInterface : SafetyInterface;\n  apply SafetyComponent { mandatory: true };\n}\n\nblock DriverAirbag {\n  interface airbagInterface : SafetyInterface;\n  apply SafetyComponent { optional: true };\n}\n\nblock PassengerAirbag {\n  interface airbagInterface : SafetyInterface;\n  apply SafetyComponent { optional: true };\n}\n\nblock Dashboard {\n  interface displayInterface : DisplayInterface;\n}\n\nblock TopLevelInterface {\n  interface chassisInterface : ChassisInterface;\n  interface powertrainInterface : PowertrainInterface;\n  interface electricalInterface : ElectricalInterface;\n  interface interiorInterface : InteriorInterface;\n}\n\nview HierarchyView as Tree {\n  AutomotiveSystem {\n    Chassis {\n      Bumpers;\n      Suspension;\n      ABS;\n    }\n    Powertrain {\n      Engine;\n      Transmission;\n    }\n    Electrical {\n      Battery;\n      ECU;\n    }\n    Interior {\n      SeatBelts;\n      DriverAirbag;\n      PassengerAirbag;\n      Dashboard;\n    }\n  }\n}\n\nview SafetyComponentsView as Table {\n  columns: Name, Status, Responsibility;\n  rows: \n    Bumpers { Status: \"Mandatory\", Responsibility: \"Impact absorption\" },\n    SeatBelts { Status: \"Mandatory\", Responsibility: \"Occupant restraint\" },\n    ABS { Status: \"Optional\", Responsibility: \"Brake control\" },\n    DriverAirbag { Status: \"Optional\", Responsibility: \"Collision protection\" },\n    PassengerAirbag { Status: \"Optional\", Responsibility: \"Collision protection\" };\n}\n\nview NonSafetyComponentsView as Table {\n  columns: Name, Responsibility;\n  rows: \n    Suspension { Responsibility: \"Vehicle stability\" },\n    Engine { Responsibility: \"Power generation\" },\n    Transmission { Responsibility: \"Power transfer\" },\n    Battery { Responsibility: \"Electrical power\" },\n    ECU { Responsibility: \"System control\" },\n    Dashboard { Responsibility: \"User interface\" };\n}\n```",
    "module AutomotiveDomain {\n  block 汽车 {\n    /* 核心组件，代表汽车系统。别名：汽车 (Car)，用于不同应用场景中的沟通和使用。 */\n    property torque : Real @unit N*m;\n    /* 扭矩是汽车动力输出的重要物理量，用于标准化表达汽车特性。 */\n  }\n}",
    "module DocumentManagementPlatform {\n    block Automobile {\n        property torque : Real @unit ISQ::TorqueValue;\n        operation enterDocument(doc : Document) : Boolean;\n        operation queryDocument(criteria : String) : Document[*];\n        operation archiveDocument(doc : Document) : Boolean;\n    }\n\n    alias Car for Automobile;\n\n    block Document {\n        property name : String;\n        property content : String;\n        property subject : Automobile;\n    }\n\n    constraint block UnitCompatibilityConstraint {\n        apply ISQ::TorqueValue;\n    }\n\n    block DocumentManagementSystem {\n        part automobile : Automobile;\n        part document : Document;\n        part unitConstraint : UnitCompatibilityConstraint;\n    }\n}\n```",
    "module AutomobileSystem {\n  class Automobile {\n    property torque : TorqueValue;\n  }\n  alias Car for Automobile;\n\n  type TorqueValue = Real;\n  alias Torque for TorqueValue;\n}",
    "package Vehicles {\n    enumeration VehicleSize {\n        Small,\n        Large,\n        Standard\n    }\n\n    class Vehicle {\n        property engine : Engine [1..1] {\n            direction: in\n        }\n        property size : VehicleSize [1..1] {\n            direction: in\n        }\n    }\n\n    class Engine {\n        property cylinders : Integer [4..6] {\n            direction: in\n        }\n    }\n\n    constraintblock CylinderConstraint {\n        context Vehicle\n        rule cylinderRule {\n            self.engine.cylinders = \n                if self.size = VehicleSize::Small then 4 \n                elif self.size = VehicleSize::Large then 6 \n                else (self.engine.cylinders >= 4 and self.engine.cylinders <= 6)\n        }\n    }\n}\n```",
    "block FuelFlowManagementSystem\n  part fuelTank: FuelTank\n  part engine: Engine\n  part fuelInterface: FuelInterface\n  part fuelReturnInterface: FuelInterface\n  flow fuelSupplyFlow: FuelFlow from fuelTank.fuelInterface to engine.fuelInterface\n  flow fuelReturnFlow: FuelFlow from engine.fuelReturnInterface to fuelTank.fuelReturnInterface\n  function fuelSupply: FuelSupply\n  function fuelReturn: FuelReturn\n  function fuelTemperatureMonitoring: FuelTemperatureMonitoring\n  port fuelTankPort: FuelInterface\n  port enginePort: FuelInterface\n  port fuelReturnPort: FuelInterface\n  constraint interfaceStandard: InterfaceStandard\nend FuelFlowManagementSystem\n\nblock FuelTank\n  port fuelOut: FuelInterface\n  port fuelIn: FuelInterface\nend FuelTank\n\nblock Engine\n  port fuelIn: FuelInterface\n  port fuelOut: FuelInterface\nend Engine\n\nblock FuelInterface\n  constraint standardized: InterfaceStandard\nend FuelInterface\n\nflow FuelFlow\n  property fuel: Fuel\n  property temperature: Temperature\nend FuelFlow\n\nfunction FuelSupply\n  behavior supplyBehavior: Behavior\nend FuelSupply\n\nfunction FuelReturn\n  behavior returnBehavior: Behavior\nend FuelReturn\n\nfunction FuelTemperatureMonitoring\n  behavior monitoringBehavior: Behavior\nend FuelTemperatureMonitoring\n\nconstraint InterfaceStandard\n  property reliability: Boolean\n  property safety: Boolean\nend InterfaceStandard\n\nbehavior supplyBehavior\n  stateMachine\n    state Idle\n    state Supplying\n  end stateMachine\nend supplyBehavior\n\nbehavior returnBehavior\n  stateMachine\n    state Idle\n    state Returning\n  end stateMachine\nend returnBehavior\n\nbehavior monitoringBehavior\n  activity\n    action monitorTemperature\n    action adjustFlow\n  end activity\nend monitoringBehavior",
    "class Vehicle {\n    mass: Float;\n    frontAxleAssembly: AxleAssembly;\n    rearAxleAssembly: AxleAssembly;\n}\n\nclass AxleAssembly {\n    axle: Axle;\n    wheels: Wheel[2] {ordered};\n}\n\nclass Axle;\n\nclass SteeringAxle extends Axle {\n    steeringAngle: Float;\n}\n\nclass Wheel {\n    name: String;\n}\n\nconstraint block VehicleMass {\n    mass: Float in {1750, 2000};\n}\n\nVehicle : VehicleMass;\nAxleAssembly.frontAxleAssembly.axle : SteeringAxle;\nAxleAssembly.rearAxleAssembly.axle : Axle;\nAxleAssembly.wheels[0] : Wheel {name = \"leftWheel\"};\nAxleAssembly.wheels[1] : Wheel {name = \"rightWheel\"};\n```"
]