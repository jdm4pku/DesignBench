[
    "module GearSettingEnum {\n    enum Park, Reverse, Neutral, Drive, First, Second, Third;\n}\n\nmodule VehicleStatus {\n    property gearSetting : GearSettingEnum;\n    property acceleratorPedalPosition : Float;\n}\n\nmodule Engine {\n    property mass : Float;\n    property status : VehicleStatus;\n}\n\nmodule Driver {\n    property name : String;\n    property experienceLevel : Integer;\n}\n\nmodule Vehicle {\n    property mass : Float;\n    property currentStatus : VehicleStatus;\n    part engine : Engine;\n    reference driver : Driver;\n}",
    "package VehicleModel {\n  block Vehicle\n  end Vehicle\n\n  block ManuallyOperatedVehicle\n    generalization Vehicle\n    property driver : Personnel [1..1]\n  end ManuallyOperatedVehicle\n\n  block PoweredVehicle\n    generalization Vehicle\n    part engine : Engine [1..1]\n  end PoweredVehicle\n\n  block ManuallyOperatedPoweredVehicle\n    generalization ManuallyOperatedVehicle\n    generalization PoweredVehicle\n  end ManuallyOperatedPoweredVehicle\n\n  block Personnel\n  end Personnel\n\n  block Engine\n  end Engine\n\n  association ManuallyOperatedVehicleDriver {\n    member end vehicle : ManuallyOperatedVehicle [1..1]\n    member end driver : Personnel [1..1]\n  }\n\n  association PoweredVehicleEngine {\n    member end vehicle : PoweredVehicle [1..1]\n    member end engine : Engine [1..1]\n  }\n}",
    "package VehicleStructure {\n  block VehicleComponent {\n  }\n\n  block Engine extends VehicleComponent {\n  }\n\n  block Transmission extends VehicleComponent {\n  }\n\n  block Wheel extends VehicleComponent {\n  }\n\n  block Vehicle {\n    part engine : Engine [1..1];\n    part transmission : Transmission [1..1];\n    part wheels : Wheel [4..4];\n  }\n}",
    "module VehicleSystem {\n  value Cylinders {\n    value : Integer;\n  }\n\n  class Vehicle {\n    part engine : Engine;\n  }\n\n  class SmallVehicle extends Vehicle {\n    redef part engine : SmallEngine;\n  }\n\n  class LargeVehicle extends Vehicle {\n    redef part engine : LargeEngine;\n  }\n\n  class Engine {\n    part cylinders : Cylinders;\n  }\n\n  class SmallEngine extends Engine {\n    redef part cylinders : Cylinders { value: 4 };\n  }\n\n  class LargeEngine extends Engine {\n    redef part cylinders : Cylinders { value: 6 };\n  }\n}",
    "enum ColorState {\n    green,\n    yellow,\n    red\n}\n\nblock TrafficSignal {\n    color: ColorState;\n}\n\nblock AlwaysGreenTrafficSignal specializes TrafficSignal {\n    color: ColorState = green;\n}\n\nblock TrafficSignalSystem {\n    signal: TrafficSignal;\n    alwaysGreenSignal: AlwaysGreenTrafficSignal;\n}",
    "model InformationAndGradeClassification\n    module InformationClassification\n        enum TrafficLightLevel {\n            Unclassified: code = \"uncl\", color = \"green\";\n            Confidential: code = \"conf\", color = \"yellow\";\n            Secret: code = \"secr\", color = \"red\";\n        }\n    end InformationClassification\n\n    module GradeClassification\n        enum GradeLevel {\n            A: points = 4.0;\n            B: points = 3.0;\n            C: points = 2.0;\n            D: points = 1.0;\n            F: points = 0.0;\n        }\n    end GradeClassification\nend InformationAndGradeClassification",
    "Vehicle : «block» {\n  engine : Engine [1];\n}\n\nEngine : «block» {\n  cylinders : Cylinder [4..6];\n}\n\nSmallEngine : «block» extends Engine {\n  redefines cylinders : Cylinder [4];\n}\n\nLargeEngine : «block» extends Engine {\n  redefines cylinders : Cylinder [6];\n}\n\nSmallVehicle : «block» extends Vehicle {\n  redefines engine : SmallEngine [1];\n}\n\nLargeVehicle : «block» extends Vehicle {\n  redefines engine : LargeEngine [1];\n}",
    "package VehicleModeling {\n  block Vehicle {\n    property name : String;\n    property driver : Driver;\n    property fuelTank : FuelTank;\n    property qualityAttributes : QualityAttribute[*];\n  }\n\n  block QualityAttribute {\n    property name : String;\n    property value : String;\n  }\n\n  block Driver {\n    property name : String;\n    property licenseNumber : String;\n  }\n\n  block FuelTank {\n    property capacity : Float;\n    property fuelType : Fuel;\n  }\n\n  block Fuel {\n    property type : String;\n    property energyDensity : Float;\n  }\n\n  block Personnel {\n    property name : String;\n    property role : String;\n  }\n}",
    "block WheelBearingUnit\nend WheelBearingUnit;\n\nblock Bead\nend Bead;\n\nblock Rim\nend Rim;\n\nblock Tire\n  part bead : Bead [2];\nend Tire;\n\nblock BoltMountingHole\nend BoltMountingHole;\n\nblock ThreadedHole\nend ThreadedHole;\n\nblock BoltConnection\n  reference boltMountingHole : BoltMountingHole;\n  reference threadedHole : ThreadedHole;\nend BoltConnection;\n\nblock Hub\n  part rim : Rim [2];\n  part boltMountingHole : BoltMountingHole [*];\n  part threadedHole : ThreadedHole [*];\n  part boltConnection : BoltConnection [*];\n  \n  connector c1 : boltMountingHole[*] -> threadedHole[*] via boltConnection[*];\nend Hub;\n\nblock WheelAssembly\n  part wheelBearingUnit : WheelBearingUnit;\n  part hub : Hub;\n  part tire : Tire;\n  \n  connector c1 : tire.bead[0] -> hub.rim[0];\n  connector c2 : tire.bead[1] -> hub.rim[1];\nend WheelAssembly;",
    "package FuelFlowManagement {\n  data type Fuel;\n  data type Temperature;\n\n  interface FuelSupplyInterface {\n    flow supplyFuel : Fuel;\n    data temperature : Temperature;\n  }\n\n  interface FuelReturnInterface {\n    flow returnFuel : Fuel;\n    data temperature : Temperature;\n  }\n\n  block FuelTankAssembly {\n    port supplyPort : FuelSupplyInterface {\n      supplyFuel : out;\n      temperature : in;\n    };\n    port returnPort : FuelReturnInterface {\n      returnFuel : in;\n      temperature : in;\n    };\n  }\n\n  block Engine {\n    port supplyPort : FuelSupplyInterface {\n      supplyFuel : in;\n      temperature : out;\n    };\n    port returnPort : FuelReturnInterface {\n      returnFuel : out;\n      temperature : out;\n    };\n  }\n\n  block FuelFlowManagementSystem {\n    part fuelTankAssembly : FuelTankAssembly;\n    part engine : Engine;\n    connect fuelTankAssembly.supplyPort to engine.supplyPort via FuelSupplyInterface;\n    connect engine.returnPort to fuelTankAssembly.returnPort via FuelReturnInterface;\n  }\n}",
    "module VehicleConfigurations {\n  package VehiclePkg {\n    block Vehicle {\n      property mass : Real = 1750;\n      part frontAxle : Axle[1];\n      part rearAxle : Axle[1];\n    }\n\n    block Axle {\n      property mass : Real = 300;\n      part tire : Tire[2] ordered;\n    }\n\n    block Tire {\n      property mass : Real = 25;\n    }\n\n    block DedicatedFrontAxle : Axle {\n      property steeringAngle : Real;\n      redefines mass = 350;\n    }\n\n    block VehicleConfigurationVariant {\n      variant membership frontAxle : DedicatedFrontAxle[1];\n      redefines mass = 2000;\n    }\n\n    instance specification vehicle1_c1 : VehicleConfigurationVariant {\n      part frontAxle : DedicatedFrontAxle {\n        attribute steeringAngle : 10;\n      }\n      part rearAxle : Axle {\n        redefines mass = 320;\n      }\n      part tires : Tire[4] {\n        redefines mass = 30;\n      }\n    }\n  }\n}",
    "block CouplingBall {}\nblock Connector {}\nblock CouplingHitch {\n  part ball : CouplingBall\n  part connector : Connector\n}\nblock Vehicle {\n  ref couplingHitch : CouplingHitch\n  ref couplingBall : CouplingBall @ couplingHitch.ball\n}\nblock Trailer {\n  ref couplingHitch : CouplingHitch\n  ref connector : Connector @ couplingHitch.connector\n}\nblock CouplingSystem {\n  part vehicle : Vehicle\n  part trailer : Trailer\n  part couplingHitch : CouplingHitch\n  bind vehicle.couplingHitch to couplingHitch\n  bind trailer.couplingHitch to couplingHitch\n}",
    "module VehiclePowerTransmissionSystem {\n  part engine : Engine;\n  part transmission : Transmission;\n  part driveshaft : Driveshaft;\n  part rearAxleAssembly : RearAxleAssembly;\n  part leftWheel : Wheel;\n  part rightWheel : Wheel;\n  part roadInterface : RoadInterface;\n\n  engine.fuelCommandPort -> FuelCommand;\n  engine.powerPort -> Power;\n  engine.clutchPort -> Clutch;\n\n  transmission.clutchPort <- engine.clutchPort;\n  transmission.powerPort <- engine.powerPort;\n  transmission.outputPowerPort -> Power;\n\n  driveshaft.inputPowerPort <- transmission.outputPowerPort;\n  driveshaft.outputPowerPort -> Power;\n\n  rearAxleAssembly.inputPowerPort <- driveshaft.outputPowerPort;\n  rearAxleAssembly.differential.leftHalfShaftPort -> HalfShaft;\n  rearAxleAssembly.differential.rightHalfShaftPort -> HalfShaft;\n\n  leftWheel.wheelPort <- rearAxleAssembly.differential.leftHalfShaftPort;\n  leftWheel.roadInterfacePort -> RoadInterface;\n\n  rightWheel.wheelPort <- rearAxleAssembly.differential.rightHalfShaftPort;\n  rightWheel.roadInterfacePort -> RoadInterface;\n\n  roadInterface <- leftWheel.roadInterfacePort;\n  roadInterface <- rightWheel.roadInterfacePort;\n}\n\ninterface block Engine {\n  in port fuelCommandPort : FuelCommand;\n  out port powerPort : Power;\n  out port clutchPort : Clutch;\n}\n\ninterface block Transmission {\n  in port clutchPort : Clutch;\n  in port powerPort : Power;\n  out port outputPowerPort : Power;\n}\n\ninterface block Driveshaft {\n  in port inputPowerPort : Power;\n  out port outputPowerPort : Power;\n}\n\ninterface block RearAxleAssembly {\n  in port inputPowerPort : Power;\n  part differential : Differential;\n}\n\ninterface block Differential {\n  out port leftHalfShaftPort : HalfShaft;\n  out port rightHalfShaftPort : HalfShaft;\n}\n\ninterface block Wheel {\n  in port wheelPort : HalfShaft;\n  out port roadInterfacePort : RoadInterface;\n}\n\ninterface block RoadInterface {\n  // Road interaction interface\n}\n\ninterface block Clutch {\n  // Clutch control and power interface\n}\n\ninterface block Power {\n  // Power transmission interface\n}\n\ninterface block FuelCommand {\n  // Fuel control command interface\n}\n\ninterface block HalfShaft {\n  // Half-shaft power transmission interface\n}",
    "module MultiArchitectureSystem {\n  interface pe : SignalInterface;\n  interface pf : SignalInterface;\n\n  block ComponentC1 {\n    port pb : pe;\n  }\n\n  block ComponentC2 {\n    port pc : pe;\n  }\n\n  block ComponentC3 {\n    port pd : pf;\n  }\n\n  block ComponentC4 {\n    port pg : pf;\n  }\n\n  block SubsystemB11 {\n    part c1 : ComponentC1;\n    part c2 : ComponentC2;\n    connection connC1C2 : SignalConnection from c1.pb to c2.pc;\n  }\n\n  block SubsystemB12 {\n    part c3 : ComponentC3;\n    part c4 : ComponentC4;\n    connection connC3C4 : SignalConnection from c3.pd to c4.pg;\n  }\n\n  block System1 {\n    part b11 : SubsystemB11;\n    part b12 : SubsystemB12;\n    connection connB11B12 : SignalConnection from b11.c1.pb to b12.c3.pd;\n  }\n\n  block ModuleB21 {\n    part c1 : ComponentC1;\n    part c2 : ComponentC2;\n    part c3 : ComponentC3;\n    part c4 : ComponentC4;\n    connection connC1C2 : SignalConnection from c1.pb to c2.pc;\n    connection connC3C4 : SignalConnection from c3.pd to c4.pg;\n  }\n\n  block ModuleB22 {\n    part c1 : ComponentC1;\n    part c2 : ComponentC2;\n    part c3 : ComponentC3;\n    part c4 : ComponentC4;\n    connection connC1C3 : SignalConnection from c1.pb to c3.pd;\n    connection connC2C4 : SignalConnection from c2.pc to c4.pg;\n  }\n\n  block System2 {\n    part b21 : ModuleB21;\n    part b22 : ModuleB22;\n  }\n}",
    "model AutomotivePowertrainSystemModel {\n  block AutomotivePowertrainSystem {\n    part engine : Engine\n    part transmission : Transmission\n    part driveshaft : Driveshaft\n    part leftWheel : Wheel\n    part rightWheel : Wheel\n    part controller : Controller\n  }\n\n  block Engine {\n    property isRunning : Boolean\n    property fuelCommand : Real\n    property torqueOutput : Real\n\n    activity startEngine() {\n      action set isRunning = true\n      action generateTorque()\n    }\n\n    activity stopEngine() {\n      action set isRunning = false\n      action set torqueOutput = 0\n    }\n\n    activity generateTorque() {\n      if (isRunning) {\n        action set torqueOutput = fuelCommand * 10  // Simplified torque generation\n      }\n    }\n  }\n\n  block Transmission {\n    property torqueInput : Real\n    property torqueOutput : Real\n    property amplificationRatio : Real = 2.5\n\n    activity amplifyTorque() {\n      action set torqueOutput = torqueInput * amplificationRatio\n    }\n  }\n\n  block Driveshaft {\n    property torqueInput : Real\n    property leftTorqueOutput : Real\n    property rightTorqueOutput : Real\n\n    activity distributeTorque() {\n      action set leftTorqueOutput = torqueInput / 2\n      action set rightTorqueOutput = torqueInput / 2\n    }\n  }\n\n  block Wheel {\n    property torqueInput : Real\n\n    activity applyTorque() {\n      action set drivingForce = torqueInput * 0.8  // Simplified force application\n    }\n  }\n\n  block Controller {\n    activity startPowertrain() {\n      action engine.startEngine()\n    }\n\n    activity shutdownPowertrain() {\n      action engine.stopEngine()\n    }\n\n    activity controlFuelCommand(command : Real) {\n      action set engine.fuelCommand = command\n    }\n  }\n\n  // Connectors\n  connector engineToTransmission {\n    source engine : Engine\n    target transmission : Transmission\n    mapping engine.torqueOutput -> transmission.torqueInput\n  }\n\n  connector transmissionToDriveshaft {\n    source transmission : Transmission\n    target driveshaft : Driveshaft\n    mapping transmission.torqueOutput -> driveshaft.torqueInput\n  }\n\n  connector driveshaftToLeftWheel {\n    source driveshaft : Driveshaft\n    target leftWheel : Wheel\n    mapping driveshaft.leftTorqueOutput -> leftWheel.torqueInput\n  }\n\n  connector driveshaftToRightWheel {\n    source driveshaft : Driveshaft\n    target rightWheel : Wheel\n    mapping driveshaft.rightTorqueOutput -> rightWheel.torqueInput\n  }\n\n  connector controllerToEngine {\n    source controller : Controller\n    target engine : Engine\n    mapping controller.controlFuelCommand -> engine.fuelCommand\n  }\n\n  connector controllerToSystem {\n    source controller : Controller\n    target system : AutomotivePowertrainSystem\n    mapping controller.startPowertrain -> system.engine.startEngine\n    mapping controller.shutdownPowertrain -> system.engine.stopEngine\n  }\n}",
    "enumeration EngineState {\n    Off,\n    Starting,\n    Running\n}\n\nblock PowertrainControlSystem {\n    property fuelControlCommand : Boolean\n    property stallSignal : Boolean\n    property engineState : EngineState\n    property generatedTorque : Float\n    property amplifiedTorque : Float\n    property transmittedTorque : Float\n    property distributedTorque : Float\n    property wheelTorque : Float\n\n    part engine : Engine\n    part torqueGeneration : TorqueGeneration\n    part torqueAmplification : TorqueAmplification\n    part transmission : Transmission\n    part distribution : Distribution\n    part driveWheels : DriveWheels\n\n    operation processFuelControlCommand() {\n        if (fuelControlCommand) {\n            engine.startEngine()\n            torqueGeneration.generateTorque()\n            torqueAmplification.amplifyTorque()\n            transmission.transmitTorque()\n            distribution.distributeTorque()\n            driveWheels.deliverPower()\n        }\n    }\n\n    operation haltOperations() {\n        if (stallSignal) {\n            engine.shutdownEngine()\n            torqueGeneration.haltTorqueGeneration()\n            torqueAmplification.haltTorqueAmplification()\n            transmission.haltTransmission()\n            distribution.haltDistribution()\n        }\n    }\n}\n\nblock Engine {\n    property state : EngineState\n\n    operation startEngine() {\n        state = EngineState.Starting\n        // Transition to Running after successful start\n    }\n\n    operation shutdownEngine() {\n        state = EngineState.Off\n    }\n}\n\nblock TorqueGeneration {\n    property inputFuelCommand : Boolean\n    property engineStateInput : EngineState\n    property outputTorque : Float\n\n    operation generateTorque() {\n        if (inputFuelCommand && engineStateInput == EngineState.Running) {\n            outputTorque = calculateTorqueBasedOnCommand()\n        }\n    }\n\n    operation haltTorqueGeneration() {\n        outputTorque = 0.0\n    }\n}\n\nblock TorqueAmplification {\n    property inputTorque : Float\n    property outputTorque : Float\n\n    operation amplifyTorque() {\n        outputTorque = inputTorque * amplificationFactor\n    }\n\n    operation haltTorqueAmplification() {\n        outputTorque = 0.0\n    }\n}\n\nblock Transmission {\n    property inputTorque : Float\n    property outputTorque : Float\n\n    operation transmitTorque() {\n        outputTorque = inputTorque\n    }\n\n    operation haltTransmission() {\n        outputTorque = 0.0\n    }\n}\n\nblock Distribution {\n    property inputTorque : Float\n    property outputTorque : Float\n\n    operation distributeTorque() {\n        outputTorque = inputTorque\n    }\n\n    operation haltDistribution() {\n        outputTorque = 0.0\n    }\n}\n\nblock DriveWheels {\n    property inputTorque : Float\n\n    operation deliverPower() {\n        wheelTorque = inputTorque\n    }\n}\n\nconstraint StallHandling {\n    context PowertrainControlSystem\n    stallSignal.implies(haltOperations())\n}\n\nconstraint TorqueFlow {\n    context PowertrainControlSystem\n    generatedTorque = torqueGeneration.outputTorque\n    amplifiedTorque = torqueAmplification.outputTorque\n    transmittedTorque = transmission.outputTorque\n    distributedTorque = distribution.outputTorque\n    wheelTorque = driveWheels.inputTorque\n}\n\nconstraint InputConnections {\n    context PowertrainControlSystem\n    torqueGeneration.inputFuelCommand = fuelControlCommand\n    torqueGeneration.engineStateInput = engine.state\n    torqueAmplification.inputTorque = generatedTorque\n    transmission.inputTorque = amplifiedTorque\n    distribution.inputTorque = transmittedTorque\n    driveWheels.inputTorque = distributedTorque\n}",
    "package VehiclePowertrainModel {\n    import SysML.Base;\n\n    value type FuelCommand;\n    value type Torque;\n\n    block Engine {\n        port startSignal : Boolean;\n        port fuelInput : FuelCommand;\n        port torqueOutput : Torque;\n\n        behavior generateTorque do {\n            if (startSignal) then\n                torqueOutput = computeTorque(fuelInput);\n            else\n                torqueOutput = 0;\n            end if;\n        }\n    }\n\n    block Transmission {\n        port inputTorque : Torque;\n        port outputTorque : Torque;\n\n        behavior amplifyTorque do {\n            outputTorque = inputTorque * amplificationFactor;\n        }\n    }\n\n    block Wheel {\n        port receivedTorque : Torque;\n    }\n\n    block VehiclePowertrainSystem {\n        part engine : Engine;\n        part transmission : Transmission;\n        part wheels : Wheel[4];\n\n        port engineStart : Boolean;\n        port engineShutdown : Boolean;\n        port driverFuelCommand : FuelCommand;\n\n        behavior PowertrainControlBehavior do {\n            if (engineStart) then\n                engine.startSignal = true;\n                engine.fuelInput = driverFuelCommand;\n                transmission.inputTorque = engine.torqueOutput;\n                transmission.amplifyTorque();\n                for (wheel in wheels) do\n                    wheel.receivedTorque = transmission.outputTorque / 4;\n                end for;\n            else if (engineShutdown) then\n                engine.startSignal = false;\n                for (wheel in wheels) do\n                    wheel.receivedTorque = 0;\n                end for;\n            end if;\n        }\n    }\n}",
    "module PowerConnectionSystemModel {\n    package system {\n        block PowerConnectionSystem {\n            part vehicle : Vehicle;\n            part trailer : Trailer;\n            part hitchingMechanism : HitchingMechanism;\n        }\n\n        block Vehicle {\n            part frame : VehicleFrame;\n            part hitchBall : HitchBall;\n        }\n\n        block Trailer {\n            part frame : TrailerFrame;\n            part trailerCoupler : TrailerCoupler;\n        }\n\n        block VehicleFrame {\n            // Structural frame of the vehicle\n        }\n\n        block TrailerFrame {\n            // Structural frame of the trailer\n        }\n\n        block HitchBall {\n            // Hitch ball installed on the vehicle frame\n        }\n\n        block TrailerCoupler {\n            // Trailer coupler installed on the trailer frame\n        }\n\n        block HitchingMechanism {\n            state machine {\n                state Disconnected {\n                    on entry do {\n                        // Initialize disconnection state\n                    }\n                }\n                state Connected {\n                    on entry do {\n                        // Initialize connection state\n                    }\n                }\n                transition from Disconnected to Connected on connect();\n                transition from Connected to Disconnected on disconnect();\n            }\n        }\n    }\n\n    package functions {\n        block PowerCouplingFunction {\n            function Connect {\n                // Function to safely connect trailer to vehicle\n            }\n            function Disconnect {\n                // Function to safely disconnect trailer from vehicle\n            }\n        }\n    }\n\n    package requirements {\n        constraint block SafetyConstraint {\n            // Ensures safe connection/disconnection operations\n        }\n\n        constraint block ReliabilityConstraint {\n            // Ensures reliable power coupling functionality\n        }\n\n        constraint block FlexibilityConstraint {\n            // Supports flexible combination/separation in various scenarios\n        }\n\n        requirement PowerConnectionRequirement {\n            satisfies: SafetyConstraint, ReliabilityConstraint, FlexibilityConstraint;\n        }\n    }\n\n    package constraints {\n        constraint block StructuralFrameConstraint {\n            // Independent structural frames for vehicle and trailer\n        }\n\n        constraint block CouplingInterfaceConstraint {\n            // Interface compatibility between hitch ball and trailer coupler\n        }\n    }\n\n    // Relationships\n    system::PowerConnectionSystem realizes functions::PowerCouplingFunction;\n    system::Vehicle has system::VehicleFrame;\n    system::Vehicle has system::HitchBall;\n    system::Trailer has system::TrailerFrame;\n    system::Trailer has system::TrailerCoupler;\n    system::HitchingMechanism satisfies constraints::StructuralFrameConstraint;\n    system::HitchingMechanism satisfies constraints::CouplingInterfaceConstraint;\n    system::PowerConnectionSystem satisfies requirements::PowerConnectionRequirement;\n}",
    "block Vehicle\n  part chassis : Chassis\n  part towBall : TowBall\nend Vehicle\n\nblock Trailer\n  part trailerFrame : TrailerFrame\n  part coupler : Coupler\nend Trailer\n\nblock Chassis\n  part towBall : TowBall\nend Chassis\n\nblock TowBall\nend TowBall\n\nblock Coupler\nend Coupler\n\nblock TrailerFrame\n  part coupler : Coupler\nend TrailerFrame\n\nblock ConnectionStatus\n  state machine\n    state Connected\n    state Disconnected\n  end state machine\nend ConnectionStatus\n\nblock VehicleTrailerSystem\n  part vehicle : Vehicle\n  part trailer : Trailer\n  value status : ConnectionStatus\n  behavior connect : ConnectBehavior\n  behavior disconnect : DisconnectBehavior\nend VehicleTrailerSystem\n\nbehavior ConnectBehavior\n  context : VehicleTrailerSystem\n  action\n    set vehicle.towBall.connected = true\n    set trailer.coupler.attached = true\n    transition status to Connected\n  end action\nend ConnectBehavior\n\nbehavior DisconnectBehavior\n  context : VehicleTrailerSystem\n  action\n    set vehicle.towBall.connected = false\n    set trailer.coupler.attached = false\n    transition status to Disconnected\n  end action\nend DisconnectBehavior",
    "module TrailerConnectionModel {\n    block Vehicle {\n        part chassis : Chassis;\n        part towBall : TowBall;\n    }\n\n    block Trailer {\n        part chassis : Chassis;\n        part coupler : Coupler;\n    }\n\n    block Chassis {\n    }\n\n    block TowBall {\n        port connectionPort : TowBallPort;\n    }\n\n    block Coupler {\n        part latch : Latch;\n        part releaseMechanism : ReleaseMechanism;\n        port connectionPort : CouplerPort;\n\n        internal {\n            connector latchConnector {\n                towBallPort : TowBallPort;\n                couplerPort : CouplerPort;\n                towBallPort -> latch;\n                couplerPort -> latch;\n            }\n\n            connector releaseConnector {\n                releaseMechanism -> latch;\n            }\n        }\n    }\n\n    block Latch {\n        state engaged;\n        state disengaged;\n        transition engage from disengaged to engaged;\n        transition disengage from engaged to disengaged;\n    }\n\n    block ReleaseMechanism {\n    }\n\n    block TowBallPort {\n    }\n\n    block CouplerPort {\n    }\n\n    constraintBlock SecureLatchConstraint {\n        context Latch;\n        constraint latchState : Latch.state == engaged when connected;\n    }\n\n    constraintBlock SmoothReleaseConstraint {\n        context Latch;\n        constraint latchState : Latch.state == disengaged when disconnected;\n    }\n\n    operation hitch {\n        input trailer : Trailer;\n        input vehicle : Vehicle;\n        action {\n            trailer.coupler.latch.engage();\n            trailer.coupler.connectionPort.connect(vehicle.towBall.connectionPort);\n        }\n    }\n\n    operation unhitch {\n        input trailer : Trailer;\n        input vehicle : Vehicle;\n        action {\n            trailer.coupler.latch.disengage();\n            trailer.coupler.connectionPort.disconnect(vehicle.towBall.connectionPort);\n        }\n    }\n}",
    "package FuelSystemModel {\n  flow FuelFlow {\n    property temperature : Float;\n  }\n\n  block FuelTankAssembly {\n    port supplyPort : FlowPort[FuelFlow] direction out;\n    port returnPort : FlowPort[FuelFlow] direction in;\n  }\n\n  block Engine {\n    port supplyPort : FlowPort[FuelFlow] direction in;\n    port returnPort : FlowPort[FuelFlow] direction out;\n  }\n\n  block FuelSystem {\n    part fuelTank : FuelTankAssembly;\n    part engine : Engine;\n\n    flow fuelTank.supplyPort -> engine.supplyPort;\n    flow engine.returnPort -> fuelTank.returnPort;\n  }\n}",
    "package FuelDeliverySystemModel {\n    import sysml.*;\n\n    valueType Volume = Real;\n\n    flow FuelFlow {\n        property quantity : Volume;\n    }\n\n    block StorageTank {\n        port out fuelOut : FlowPort[FuelFlow];\n        property fuelVolume : Volume;\n    }\n\n    block FuelPump {\n        port in fuelIn : FlowPort[FuelFlow];\n        port out fuelOut : FlowPort[FuelFlow];\n        property flowRate : Volume;\n    }\n\n    block VehicleFuelTank {\n        port in fuelIn : FlowPort[FuelFlow];\n        property maxCapacity : Volume;\n        property currentFuelLevel : Volume;\n    }\n\n    block FuelDeliverySystem {\n        part storageTank : StorageTank;\n        part fuelPump : FuelPump;\n        part vehicleFuelTank : VehicleFuelTank;\n\n        connector storageToPump : FlowPath[FuelFlow] {\n            sourcePort = storageTank.fuelOut;\n            targetPort = fuelPump.fuelIn;\n        }\n\n        connector pumpToVehicle : FlowPath[FuelFlow] {\n            sourcePort = fuelPump.fuelOut;\n            targetPort = vehicleFuelTank.fuelIn;\n        }\n\n        behavior deliverFuel(requestedAmount : Volume) {\n            if (storageTank.fuelVolume >= requestedAmount) {\n                fuelPump.quantity = requestedAmount;\n                vehicleFuelTank.currentFuelLevel += requestedAmount;\n                storageTank.fuelVolume -= requestedAmount;\n            } else {\n                error(\"Insufficient fuel in storage tank\");\n            }\n        }\n    }\n}",
    "package AutomobileAssembly {\n\nblock Vehicle {}\nblock Gearbox {}\nblock Engine {}\n\nblock VehicleWithoutGearboxAndEngine {\n  // Initial state: vehicle without gearbox and engine\n}\n\nblock VehicleWithGearbox {\n  part gearbox : Gearbox;\n  // State after gearbox installation\n}\n\nblock FullyAssembledVehicle {\n  part gearbox : Gearbox;\n  part engine : Engine;\n  // Final state: complete vehicle with both components\n}\n\nactivity AssemblyProcess {\n  input vehicle : VehicleWithoutGearboxAndEngine;\n  input gearbox : Gearbox;\n  input engine : Engine;\n  output vehicle : FullyAssembledVehicle;\n\n  action InstallGearbox {\n    input vehicle : VehicleWithoutGearboxAndEngine;\n    input gearbox : Gearbox;\n    output vehicle : VehicleWithGearbox;\n  }\n\n  action InstallEngine {\n    input vehicle : VehicleWithGearbox;\n    input engine : Engine;\n    output vehicle : FullyAssembledVehicle;\n  }\n\n  // Flow connections\n  vehicle -> InstallGearbox.vehicle;\n  gearbox -> InstallGearbox.gearbox;\n  InstallGearbox.vehicle -> InstallEngine.vehicle;\n  engine -> InstallEngine.engine;\n  InstallEngine.vehicle -> vehicle;\n}\n\n}",
    "package VehicleA {\n  class VehicleAStateMachine {\n    state Off {\n      initial\n    }\n    state Starting {\n      entry / startEngine()\n    }\n    state Running {\n      entry / performSelfChecks(), supplyPower()\n      exit / applyParkingBrake()\n      substate Normal {\n        initial\n        during / monitorTemperature()\n        when (temperature > safetyThreshold) transition to Degraded {\n          do / sendOverTemperatureSignal()\n        }\n      }\n      substate Degraded {\n        entry / switchToDegradedMode()\n        exit / sendRestoreToNormalSignal()\n      }\n      substate Maintenance {\n        entry / enterMaintenanceMode()\n      }\n    }\n    state Degraded {\n      entry / switchToDegradedMode()\n      exit / sendRestoreToNormalSignal()\n    }\n    state Maintenance {\n      entry / enterMaintenanceMode()\n    }\n    transition Off -> Starting {\n      when (brakePressed and startSignal) do / startEngine()\n    }\n    transition Starting -> Running {\n      when (vehicleOnSignal) do / engineStarts()\n    }\n    transition Running.Normal -> Running.Degraded {\n      when (temperature > safetyThreshold) do / sendOverTemperatureSignal()\n    }\n    transition Running.Degraded -> Running.Normal {\n      when (restoreToNormalSignal) do / restoreNormalOperation()\n    }\n    transition Running.Normal -> Running.Maintenance {\n      when (maintenanceRequired) do / enterMaintenanceMode()\n    }\n    transition Running.Maintenance -> Running.Normal {\n      when (maintenanceCompleted) do / exitMaintenanceMode()\n    }\n    transition Running -> Degraded {\n      when (temperature > safetyThreshold) do / sendOverTemperatureSignal()\n    }\n    transition Degraded -> Running.Normal {\n      when (restoreToNormalSignal) do / restoreNormalOperation()\n    }\n  }\n}",
    "model VehicleBehaviorSystem\n\n  block Vehicle\n    part powerSystem : PowerSystem\n    part healthManagement : HealthManagement\n    part temperatureSensor : TemperatureSensor\n    property fuelType : String\n    property maintenanceInterval : Duration\n    property tempThreshold : Temperature\n\n    port warningOut : WarningSignalPort\n\n    stateMachine VehicleStateMachine\n      state Shutdown\n        transition to Startup\n          when (brakePressed and startSignal)\n          do powerSystem.startup()\n          do powerSystem.selfInspection()\n          do powerSystem.powerSupply()\n      state Startup\n        transition to NormalOperation\n          when (powerSystem.isReady)\n      state NormalOperation\n        transition to DegradedMode\n          when (temperatureSensor.overheating)\n          do warningOut.send(overheatWarning)\n      state DegradedMode\n  end\n\n  block PowerSystem\n    operation startup()\n    operation selfInspection()\n    operation powerSupply()\n    property isReady : Boolean\n  end\n\n  block HealthManagement\n    operation performMaintenance()\n    operation faultRecovery()\n  end\n\n  block TemperatureSensor\n    property currentTemperature : Temperature\n    operation detectOverheating() : Boolean\n  end\n\n  block VehicleController\n    port warningIn : WarningSignalPort\n    operation processWarningSignal(signal : WarningSignal)\n      if (signal.severity == \"CRITICAL\") then\n        vehicle.switchToDegradedMode()\n      end if\n    end\n    operation startVehicle()\n      vehicle.powerSystem.startup()\n    end\n    operation shutdownVehicle()\n      vehicle.powerSystem.shutdown()\n    end\n  end\n\n  type WarningSignal\n    property severity : String\n  end\n\n  port WarningSignalPort\n    signal WarningSignal\n  end\n\nend",
    "package SpatiotemporalSimulation {\n  block Vehicle {\n    property mass : Real;\n    property position : Real;\n    property velocity : Real;\n    property acceleration : Real;\n    stateMachine VehicleState {\n      state On {}\n      state Driving {}\n      state Off {}\n      transition On to Driving {}\n      transition Driving to Off {}\n    }\n  }\n\n  block Road {\n    property slope : Real;\n    property surfaceFrictionCoefficient : Real;\n  }\n\n  block Snapshot {\n    property time : Real;\n    property vehicle : Vehicle;\n    property road : Road;\n  }\n\n  block Simulation {\n    property timeSeries : List<Snapshot>;\n  }\n}",
    "module AutomotiveConfigurations {\n  package root {\n    block Component1 {}\n    block Component2 {}\n    block Component3 {}\n    block Component4 {}\n    block Component5 {}\n    block Component6 {}\n\n    block SubsystemA {\n      isAbstract: true;\n      part component1 : Component1;\n      part component2 : Component2;\n      part component3 : Component3;\n    }\n\n    block ConfigA1 {\n      extends SubsystemA;\n      part component1 : Component1;\n      part component2 : Component2;\n    }\n\n    block ConfigA2 {\n      extends SubsystemA;\n      part component2 : Component2;\n      part component3 : Component3;\n    }\n\n    block SubsystemB {\n      isAbstract: true;\n      part component4 : Component4;\n      part component5 : Component5;\n      part component6 : Component6;\n    }\n\n    block ConfigB1 {\n      extends SubsystemB;\n      part component4 : Component4;\n      part component5 : Component5;\n    }\n\n    block ConfigB2 {\n      extends SubsystemB;\n      part component5 : Component5;\n      part component6 : Component6;\n    }\n\n    block Automobile {\n      part subsystemA : SubsystemA;\n      part subsystemB : SubsystemB;\n      constraint AutomobileConstraint;\n    }\n\n    constraintblock AutomobileConstraint {\n      context Automobile\n      inv: if self.subsystemA.oclIsKindOf(ConfigA2) then self.subsystemB.oclIsKindOf(ConfigB1) else true;\n    }\n\n    instancespecification ConfigurationA : Automobile {\n      subsystemA : ConfigA1;\n      subsystemB : ConfigB1;\n    }\n\n    instancespecification ConfigurationB : Automobile {\n      subsystemA : ConfigA2;\n      subsystemB : ConfigB1;\n    }\n  }\n}",
    "port p1;\nport p2;\n\nblock Part1 {}\nblock Part2 {}\nblock Part3 {\n    port p1 : p1;\n}\nblock Part4 {}\nblock Part5 {\n    port p2 : p2;\n    behavior variantBehavior : Behavior;\n}\nblock Part6 {}\n\nabstract block SubsystemA {\n    part part1 : Part1;\n    part part2 : Part2;\n    part part3 : Part3;\n    part part4 : Part4;\n}\n\nabstract block SubsystemB {\n    part part5 : Part5;\n    part part6 : Part6;\n}\n\nabstract block VehicleSystem {\n    part subsystemA : SubsystemA;\n    part subsystemB : SubsystemB;\n}\n\nblock VehicleConfigA specializes VehicleSystem {\n    part subsystemA : SubsystemA {\n        part part1 : Part1;\n        part part2 : Part2;\n        part part3 : Part3;\n        part part4 : Part4;\n    }\n    part subsystemB : SubsystemB {\n        part part5 : Part5 {\n            behavior variantBehavior : BehaviorA;\n        }\n        part part6 : Part6;\n    }\n    connect subsystemA.part3.p1 to subsystemB.part5.p2;\n}\n\nblock VehicleConfigB specializes VehicleSystem {\n    part subsystemA : SubsystemA {\n        part part1 : Part1;\n        part part3 : Part3;\n    }\n    part subsystemB : SubsystemB {\n        part part5 : Part5 {\n            behavior variantBehavior : BehaviorB;\n        }\n        part part6 : Part6;\n    }\n    connect subsystemA.part3.p1 to subsystemB.part5.p2;\n}\n\nconstraint block ConfigConstraint {\n    constraint subsystemA.part3.p1 must be connected to subsystemB.part5.p2;\n    constraint subsystemB.part5.variantBehavior must be one of BehaviorA, BehaviorB;\n}",
    "package VehicleConfiguration {\n\n    value type PerformanceRequirement {\n        enum High, Standard;\n    }\n\n    value type EngineType {\n        enum FourCylinder, SixCylinder;\n    }\n\n    value type TransmissionType {\n        enum Manual, Automatic;\n    }\n\n    value type WheelType {\n        enum Narrow, Wide;\n    }\n\n    block Engine {\n        property type : EngineType;\n    }\n\n    block Transmission {\n        property type : TransmissionType;\n    }\n\n    block Wheel {\n        property type : WheelType;\n    }\n\n    block VehicleModel {\n        property name : String;\n    }\n\n    block Vehicle {\n        property engine : Engine;\n        property transmission : Transmission;\n        property wheels : Wheel [4];\n        property performance : PerformanceRequirement;\n        property model : VehicleModel;\n\n        constraint HighPerformanceConstraint;\n        constraint StandardPerformanceConstraint;\n    }\n\n    constraint block HighPerformanceConstraint {\n        when (performance == High) {\n            assert (engine.type == SixCylinder);\n            assert (transmission.type == Automatic);\n            assert (wheels.type == Wide);\n        }\n    }\n\n    constraint block StandardPerformanceConstraint {\n        when (performance == Standard) {\n            assert (engine.type == FourCylinder);\n            assert (transmission.type == Manual);\n            assert (wheels.type == Narrow);\n        }\n    }\n\n}",
    "module AutomobileSystem {\n  block Vehicle {\n    property massGrade : MassGrade;\n    property actualMass : Mass;\n    property fuelStatus : FuelStatus;\n    part engine : Engine;\n    part transmission : Transmission;\n    part driveInterface : DriveInterface;\n  }\n\n  block Engine {\n    property torqueOutput : Torque;\n  }\n\n  block Transmission {\n    property receivedTorque : Torque;\n  }\n\n  block DriveInterface {\n    property torqueTransferEfficiency : Efficiency;\n  }\n\n  constraint block MaximumMassLimitation {\n    parameter maxMass : Mass;\n    parameter actualMass : Mass;\n    constraint actualMass <= maxMass;\n  }\n\n  constraint block FuelStatusConstraint {\n    parameter fuelState : FuelStatus;\n    constraint fuelState in {'full', 'empty'};\n  }\n\n  constraint block PowerTransferConstraint {\n    parameter engineTorque : Torque;\n    parameter transmissionTorque : Torque;\n    parameter efficiency : Efficiency;\n    constraint transmissionTorque = engineTorque * efficiency;\n  }\n\n  constraint block ReliabilityConstraint {\n    parameter lifespan : Time;\n    parameter durability : DurabilityRating;\n    constraint lifespan >= 100000 km and durability >= 8.5;\n  }\n\n  enumeration MassGrade {\n    Grade2000kg,\n    Grade2500kg\n  }\n\n  enumeration FuelStatus {\n    Full,\n    Empty\n  }\n\n  requirement MassComplianceRequirement {\n    text \"Vehicle actual mass must not exceed its assigned mass grade's maximum limitation.\";\n    verify using MaximumMassLimitation;\n    allocate to Vehicle.massGrade;\n  }\n\n  requirement FuelStateValidationRequirement {\n    text \"Vehicles must meet mass requirements in their specified fuel state (full or empty).\";\n    verify using FuelStatusConstraint;\n    allocate to Vehicle.fuelStatus;\n  }\n\n  requirement PowertrainFunctionalityRequirement {\n    text \"Engine torque must be effectively transferred to transmission via drive interface.\";\n    verify using PowerTransferConstraint;\n    allocate to Vehicle.driveInterface;\n  }\n\n  requirement ReliabilityPerformanceRequirement {\n    text \"Vehicles must maintain specified performance and durability metrics throughout lifecycle.\";\n    verify using ReliabilityConstraint;\n    allocate to Vehicle;\n  }\n\n  requirement diagram SystemRequirements {\n    decompose MassComplianceRequirement {\n      subrequirement Max2000kgCheck {\n        text \"Grade2000kg vehicles must enforce actualMass <= 2000 kg.\";\n        verify using MaximumMassLimitation { maxMass = 2000 kg };\n      }\n      subrequirement Max2500kgCheck {\n        text \"Grade2500kg vehicles must enforce actualMass <= 2500 kg.\";\n        verify using MaximumMassLimitation { maxMass = 2500 kg };\n      }\n    }\n\n    decompose FuelStateValidationRequirement {\n      subrequirement FullFuelCheck {\n        text \"Vehicles requiring full fuel state must validate actualMass at 2000 kg max when fully fueled.\";\n        verify using MaximumMassLimitation { maxMass = 2000 kg };\n        allocate to Vehicle[fullFuelModel];\n      }\n      subrequirement EmptyFuelCheck {\n        text \"Vehicles accepting empty fuel state must validate actualMass at 1800 kg min when unfueled.\";\n        verify using MaximumMassLimitation { maxMass = 1800 kg };\n        allocate to Vehicle[emptyFuelModel];\n      }\n    }\n\n    allocate PowertrainFunctionalityRequirement to Vehicle.engine and Vehicle.driveInterface and Vehicle.transmission;\n    allocate ReliabilityPerformanceRequirement to Vehicle;\n  }\n}",
    "model VehicleMassComplianceModel {  \n  value type Mass = Real {  \n    unit: kg;  \n  }  \n\n  enumeration ComplianceStatus {  \n    COMPLIANT;  \n    NON_COMPLIANT;  \n  }  \n\n  block Vehicle {  \n    property actualMass : Mass;  \n  }  \n\n  block WeighingEquipment {  \n    behavior measureMass : Behavior {  \n      input vehicle : Vehicle;  \n      output measuredMass : Mass;  \n    }  \n  }  \n\n  block TestOperator {  \n    behavior initiateTest : Behavior {  \n      input vehicle : Vehicle;  \n      output testResult : ComplianceStatus;  \n    }  \n  }  \n\n  block ComplianceCheckSystem {  \n    part equipment : WeighingEquipment;  \n    part operator : TestOperator;  \n    part vehicle : Vehicle;  \n\n    parameter maxPermissibleMass : Mass = 2500.0;  \n\n    behavior checkCompliance : Behavior {  \n      input vehicle : Vehicle;  \n      output result : ComplianceStatus;  \n      local measuredMass : Mass;  \n\n      do {  \n        measuredMass = equipment.measureMass(vehicle);  \n        if (measuredMass <= maxPermissibleMass) {  \n          result = ComplianceStatus.COMPLIANT;  \n        } else {  \n          result = ComplianceStatus.NON_COMPLIANT;  \n        }  \n      }  \n    }  \n  }  \n\n  requirement reqVehicleMassCompliance : Requirement {  \n    text: \"The actual mass of the vehicle must not exceed the maximum permissible mass of 2,500 kilograms.\";  \n    constraint: cVehicleMassCompliance;  \n  }  \n\n  constraint block cVehicleMassCompliance {  \n    parameter v : Vehicle;  \n    parameter m : Mass;  \n    condition: v.actualMass <= m;  \n  }  \n}",
    "block WaterPort\nend WaterPort\n\nblock SpigotBank\n  port hotWaterOutlet: WaterPort\n  port coldWaterOutlet: WaterPort\nend SpigotBank\n\nblock Spigot\n  port waterIn: WaterPort\n  port waterOut: WaterPort[*]\n  connect waterIn to waterOut\nend Spigot\n\nblock FaucetInlet\n  port waterIn: WaterPort\n  port waterOut: WaterPort\n  connect waterIn to waterOut\nend FaucetInlet\n\nblock Faucet\n  part hotInlet: FaucetInlet\n  part coldInlet: FaucetInlet\n  port hotWaterIn: WaterPort\n  port coldWaterIn: WaterPort\n  connect hotInlet.waterOut to hotWaterIn\n  connect coldInlet.waterOut to coldWaterIn\nend Faucet\n\nblock WaterSupplySystem\n  part spigotBank: SpigotBank\n  part hotSpigot: Spigot\n  part coldSpigot: Spigot\n  part faucets: Faucet[*]\n  connect spigotBank.hotWaterOutlet to hotSpigot.waterIn\n  connect spigotBank.coldWaterOutlet to coldSpigot.waterIn\n  connect hotSpigot.waterOut to faucets.hotInlet.waterIn\n  connect coldSpigot.waterOut to faucets.coldInlet.waterIn\nend WaterSupplySystem",
    "module VehicleQualityModel {\n    block Vehicle {\n        part engine : Engine;\n        part transmission : Transmission;\n        part frontAxle : FrontAxleAssembly;\n        part rearAxle : RearAxleAssembly;\n        property totalMass : Mass;\n    }\n\n    block Engine {\n        property mass : Mass;\n    }\n\n    block Transmission {\n        property mass : Mass;\n    }\n\n    block FrontAxleAssembly {\n        property mass : Mass;\n    }\n\n    block RearAxleAssembly {\n        property mass : Mass;\n    }\n\n    constraintBlock MassConstraint {\n        parameter engineMass : Mass = engine.mass;\n        parameter transmissionMass : Mass = transmission.mass;\n        parameter frontAxleMass : Mass = frontAxle.mass;\n        parameter rearAxleMass : Mass = rearAxle.mass;\n        parameter totalMass : Mass = vehicle.totalMass;\n        constraint totalMass = engineMass + transmissionMass + frontAxleMass + rearAxleMass;\n    }\n\n    useCaseLibrary QualityAnalysisUC {\n        useCase QualityAnalysisUseCase {\n            subject vehicle : Vehicle;\n            extends UseCase;\n        }\n    }\n\n    requirementBlock QualityAnalysisRequirements {\n        requirement TotalMassRequirement {\n            text \"Total vehicle mass must be calculated as the sum of all component masses.\";\n            satisfies useCase: QualityAnalysisUC.QualityAnalysisUseCase;\n        }\n        requirement ComponentMassRequirement {\n            text \"Each component must have defined mass properties for aggregation.\";\n            satisfies useCase: QualityAnalysisUC.QualityAnalysisUseCase;\n        }\n    }\n\n    block AnalysisTask {\n        property objective : String;\n        property components : List<Component>;\n        property results : Map<String, Value>;\n    }\n\n    constraintBlock RequirementsTrackingConstraint {\n        parameter task : AnalysisTask;\n        parameter req : QualityAnalysisRequirements.Requirement;\n        constraint task.objective satisfies req.text;\n    }\n\n    block QualityAnalysisPlan {\n        part task : AnalysisTask;\n        use QualityAnalysisUC.QualityAnalysisUseCase;\n        satisfies QualityAnalysisRequirements.TotalMassRequirement;\n        satisfies QualityAnalysisRequirements.ComponentMassRequirement;\n    }\n}",
    "model PowertrainConfigurationModel {\n  value block Power {\n    value : Real;\n  }\n\n  value block Mass {\n    value : Real;\n  }\n\n  value block Efficiency {\n    value : Real;\n  }\n\n  value block Reliability {\n    value : Real;\n  }\n\n  value block Cost {\n    value : Real;\n  }\n\n  block Cylinder {\n    part piston : Piston[1];\n    part connectingRod : ConnectingRod[1];\n  }\n\n  block Piston { }\n\n  block ConnectingRod { }\n\n  block Crankshaft { }\n\n  block EngineConfiguration {\n    part cylinders : Cylinder[*];\n    part crankshaft : Crankshaft[1];\n    power : Power;\n    mass : Mass;\n    efficiency : Efficiency;\n    reliability : Reliability;\n    cost : Cost;\n  }\n\n  block FourCylinderEngine specializes EngineConfiguration {\n    redef part cylinders : Cylinder[4];\n  }\n\n  block SixCylinderEngine specializes EngineConfiguration {\n    redef part cylinders : Cylinder[6];\n  }\n\n  constraint block EvaluationModel {\n    parameter power : Power;\n    parameter mass : Mass;\n    parameter efficiency : Efficiency;\n    parameter reliability : Reliability;\n    parameter cost : Cost;\n    parameter result : Real;\n    result = (power.value * 0.3) + (efficiency.value * 0.25) - (mass.value * 0.2) - (cost.value * 0.15) + (reliability.value * 0.1);\n  }\n\n  block TradeOffAnalysis {\n    method calculateEvaluation( engine : EngineConfiguration ) : Real {\n      return applyConstraint( EvaluationModel, engine.power, engine.mass, engine.efficiency, engine.reliability, engine.cost ).result;\n    }\n  }\n\n  block Explanation {\n    rationale : String;\n  }\n\n  block RecommendationSystem {\n    part tradeOffAnalyzer : TradeOffAnalysis[1];\n    part explanation : Explanation[1];\n    method recommendOptimalEngine( engines : EngineConfiguration[*] ) : EngineConfiguration {\n      var bestEngine : EngineConfiguration = engines[0];\n      var bestScore : Real = tradeOffAnalyzer.calculateEvaluation( bestEngine );\n      for ( engine in engines ) {\n        var score : Real = tradeOffAnalyzer.calculateEvaluation( engine );\n        if ( score > bestScore ) {\n          bestEngine = engine;\n          bestScore = score;\n        }\n      }\n      return bestEngine;\n    }\n  }\n}",
    "model FuelEconomySystem {\n  valueDefinition milesPerGallon : RealUnit = RealUnit::mi/gal;\n  valueDefinition pounds : RealUnit = RealUnit::lb;\n\n  enumeration DrivingScenario {\n    Urban;\n    Highway;\n  }\n\n  block Vehicle {\n    powertrain : Powertrain;\n    load : Mass;\n    fuelEconomy : FuelEconomy;\n  }\n\n  block Powertrain {\n    // Powertrain properties (generic representation)\n  }\n\n  block FuelEconomyTest {\n    drivingScenario : DrivingScenario;\n    testLoad : Mass;\n    result : FuelEconomy;\n  }\n\n  constraint UrbanFuelEconomyConstraint {\n    context FuelEconomyTest\n    self.drivingScenario = DrivingScenario::Urban implies self.result >= 25.0@milesPerGallon;\n  }\n\n  constraint HighwayFuelEconomyConstraint {\n    context FuelEconomyTest\n    self.drivingScenario = DrivingScenario::Highway implies self.result >= 30.0@milesPerGallon;\n  }\n\n  constraint TestLoadConstraint {\n    context FuelEconomyTest\n    self.testLoad = 1000.0@pounds;\n  }\n}",
    "block VehicleMass {\n  totalMass : Real {unit = 'kg'};\n}\n\nblock PowerSegment {\n  startTime : Real {unit = 's'};\n  endTime : Real {unit = 's'};\n  powerValue : Real {unit = 'W'};\n}\n\nblock TimeSeries {\n  time : Sequence(Real) {unit = 's'};\n  value : Sequence(Real);\n}\n\nblock VehicleSystem {\n  massParams : VehicleMass;\n  initialPosition : Real {unit = 'm'};\n  initialVelocity : Real {unit = 'm/s'};\n  powerSegments : Sequence(PowerSegment);\n  timeStep : Real {unit = 's'};\n  accelerationSequence : TimeSeries {unit = 'm/s^2'};\n  velocityVariationSequence : TimeSeries {unit = 'm/s'};\n  displacementSequence : TimeSeries {unit = 'm'};\n}\n\nconstraint LongitudinalDynamicsConstraint {\n  context VehicleSystem\n  inv: \n    accelerationSequence.value->forAll(i | i = powerSegments->at(i).powerValue / velocityVariationSequence.value->at(i) / massParams.totalMass) and\n    velocityVariationSequence.value->forAll(i | i = initialVelocity + accelerationSequence.value->at(i) * accelerationSequence.time->at(i)) and\n    displacementSequence.value->forAll(i | i = initialPosition + initialVelocity * accelerationSequence.time->at(i) + 0.5 * accelerationSequence.value->at(i) * (accelerationSequence.time->at(i))^2);\n}",
    "model VehicleModel {\n  block Vehicle {\n    property mass : Real = 2500.0 @unit 'kg';\n    part frontAxleAssembly : FrontAxleAssembly;\n    part rearAxleAssembly : RearAxleAssembly;\n  }\n\n  block FrontAxleAssembly {\n    property mass : Real = 150.0 @unit 'kg';\n    part frontWheel[2] : FrontWheel;\n    part frontAxle : FrontAxle;\n  }\n\n  block RearAxleAssembly {\n    property mass : Real = 250.0 @unit 'kg';\n    part rearWheel[2] : RearWheel;\n    part rearAxle : RearAxle;\n  }\n\n  block FrontAxle {\n    property mass : Real @unit 'kg';\n    property steeringAngle : Real @unit 'deg';\n  }\n\n  block RearAxle {\n    property mass : Real @unit 'kg';\n  }\n\n  block FrontWheel;\n\n  block RearWheel;\n}",
    "package VehicleSafetySecurityModel {\n  block VehicleSafetySecuritySystem {\n    part mandatorySafety: SafetyComponent[1];\n    part optionalSafety: OptionalSafetyComponent[0..1];\n    part security: SecurityComponent[1];\n    part filterFunction: FilterAndOrganizeFunction[1];\n    part visualizeFunction: VisualizeFunction[1];\n  }\n\n  abstract block SafetyComponent {\n    property isMandatory: Boolean;\n  }\n\n  block SeatBelt extends SafetyComponent {\n    isMandatory = true;\n  }\n\n  block Bumper extends SafetyComponent {\n    isMandatory = true;\n  }\n\n  abstract block OptionalSafetyComponent extends SafetyComponent {\n    isMandatory = false;\n  }\n\n  block Airbag extends OptionalSafetyComponent {\n  }\n\n  block AntiLockBrakingSystem extends OptionalSafetyComponent {\n  }\n\n  abstract block SecurityComponent {\n  }\n\n  block Alarm extends SecurityComponent {\n  }\n\n  block KeylessEntrySystem extends SecurityComponent {\n  }\n\n  block FilterAndOrganizeFunction {\n    method categorizeComponents(components: Set<Component>) returns (Map<String, Set<Component>>);\n  }\n\n  block VisualizeFunction {\n    method displayAsTree(components: Set<Component>) returns (String);\n    method displayAsTable(components: Set<Component>) returns (String);\n  }\n\n  block Component {\n  }\n\n  // Relationships\n  relationship R1: VehicleSafetySecuritySystem.ownedPart.mandatorySafety.type = SeatBelt;\n  relationship R2: VehicleSafetySecuritySystem.ownedPart.mandatorySafety.type = Bumper;\n  relationship R3: VehicleSafetySecuritySystem.ownedPart.optionalSafety.type = Airbag;\n  relationship R4: VehicleSafetySecuritySystem.ownedPart.optionalSafety.type = AntiLockBrakingSystem;\n  relationship R5: VehicleSafetySecuritySystem.ownedPart.security.type = Alarm;\n  relationship R6: VehicleSafetySecuritySystem.ownedPart.security.type = KeylessEntrySystem;\n}",
    "package LayeredSystemModel {\n  block ApplicationLayer {\n  }\n  block ServiceLayer {\n  }\n  block DataLayer {\n  }\n  block LayeredSystem {\n    application : ApplicationLayer;\n    service : ServiceLayer;\n    data : DataLayer;\n    x : Integer;\n    y : Integer;\n    z : Integer;\n    constraint zConstraint : ZConstraint;\n  }\n  constraint block ZConstraint {\n    context LayeredSystem;\n    x : Integer;\n    y : Integer;\n    z : Integer;\n    constraintClause z = x + y;\n  }\n  ApplicationLayer->ServiceLayer : dependency;\n  ServiceLayer->DataLayer : dependency;\n}",
    "model PowertrainTorqueModel {  \n  block PowertrainSystem {  \n    part engine : Engine;  \n    part transmission : Transmission;  \n    part driveshaft : Driveshaft;  \n    part wheels : Wheels;  \n  }  \n\n  block Engine {  \n    parameter torqueOutput : Flow<PhysicalQuantity> [0..1];  \n  }  \n\n  block Transmission {  \n    parameter torqueTransmission : Flow<PhysicalQuantity> [0..1];  \n  }  \n\n  block Driveshaft {  \n    parameter torqueTransfer : Flow<PhysicalQuantity> [0..1];  \n  }  \n\n  block Wheels {  \n    parameter torqueDelivery : Flow<PhysicalQuantity> [0..1];  \n  }  \n\n  function TorqueGenerationFunction {  \n    parameter torqueGenerated : Flow<PhysicalQuantity> [0..1];  \n  }  \n\n  constraint TorqueConstraint {  \n    parameter torqueValue : PhysicalQuantity;  \n    constraint torqueValue > 0;  \n  }  \n\n  allocate TorqueGenerationFunction to PowertrainSystem.engine;  \n\n  requirement TorqueGenerationRequirement {  \n    text \"Torque produced during operation must be greater than zero newton-meters to ensure driving capability.\";  \n    satisfy TorqueConstraint;  \n  }  \n}",
    "model PowerTransmissionModel\n  block PowerTransmissionSystem\n    logical: LogicalSystem\n    physical: PhysicalSystem\n  end PowerTransmissionSystem\n\n  block LogicalSystem\n    torqueGenerator: TorqueGenerator\n  end LogicalSystem\n\n  function TorqueGenerator\n    generateTorque: FunctionDefinition\n    providePower: FunctionDefinition\n  end TorqueGenerator\n\n  block PhysicalSystem\n    powertrain: Powertrain\n  end PhysicalSystem\n\n  block Powertrain\n    engine: Engine\n  end Powertrain\n\n  block Engine\n  end Engine\n\n  implementation TorqueGeneratorImpl of TorqueGenerator\n    implementedBy: Engine\n  end TorqueGeneratorImpl\nend PowerTransmissionModel",
    "model VehicleSafetyAntiTheftCatalogue {\n  package Stereotypes {\n    stereotype MandatorySafety;\n    stereotype Safety;\n    stereotype AntiTheft;\n    stereotype BothSafetyAndAntiTheft;\n  }\n\n  block FrontSeatBelts {\n    apply Stereotypes.MandatorySafety;\n  }\n\n  block Bumpers {\n    apply Stereotypes.MandatorySafety;\n  }\n\n  block DriversAirbag {\n    apply Stereotypes.Safety;\n  }\n\n  block AntiLockBrakingSystem {\n    apply Stereotypes.Safety;\n  }\n\n  block AlarmSystem {\n    apply Stereotypes.AntiTheft;\n  }\n\n  block KeylessEntrySystem {\n    apply Stereotypes.AntiTheft;\n  }\n}",
    "model FuelSystem  \n  block FuelSystem  \n    part fuelTankAssembly: FuelTankAssembly  \n    part fuelConsumingUnits: FuelConsumingUnit[*]  \n    flowPath fuelDeliveryPath: FuelTankAssembly.fuelOut -> FuelConsumingUnit.fuelIn  \n    flowPath fuelReturnPath: FuelConsumingUnit.fuelReturn -> FuelTankAssembly.returnIn  \n    part temperatureMonitor: FuelTemperatureMonitor  \n    flowPath temperatureDataPath: FuelTemperatureMonitor.temperatureOut -> DataTransmissionSystem.temperatureIn  \n  end FuelSystem  \n\n  block FuelTankAssembly  \n    part fuelTank: FuelTank  \n    part fuelPump: FuelPump  \n    flowPort fuelOut: FuelFlow (direction: out)  \n    flowPort returnIn: ReturnFuelFlow (direction: in)  \n    connector fuelPumpToTank: FuelPump.returnOut -> FuelTank.returnIn  \n    connector tankToPump: FuelTank.fuelOut -> FuelPump.fuelIn  \n  end FuelTankAssembly  \n\n  block FuelTank  \n    flowPort fuelOut: FuelFlow (direction: out)  \n    flowPort returnIn: ReturnFuelFlow (direction: in)  \n    property capacity: Real  \n    property currentLevel: Real  \n  end FuelTank  \n\n  block FuelPump  \n    flowPort fuelIn: FuelFlow (direction: in)  \n    flowPort fuelOut: FuelFlow (direction: out)  \n    flowPort returnOut: ReturnFuelFlow (direction: out)  \n    property pressure: Real  \n    property status: String  \n  end FuelPump  \n\n  block FuelConsumingUnit  \n    flowPort fuelIn: FuelFlow (direction: in)  \n    flowPort fuelReturn: ReturnFuelFlow (direction: out)  \n    property consumptionRate: Real  \n    property operationalStatus: String  \n  end FuelConsumingUnit  \n\n  block FuelTemperatureMonitor  \n    flowPort temperatureIn: TemperatureSensorSignal (direction: in)  \n    flowPort temperatureOut: TemperatureDataSignal (direction: out)  \n    property currentTemperature: Real  \n    property alarmThreshold: Real  \n  end FuelTemperatureMonitor  \n\n  interface FuelFlow  \n    data fuelPressure: Real  \n    data fuelVolume: Real  \n  end FuelFlow  \n\n  interface ReturnFuelFlow  \n    data returnVolume: Real  \n    data returnPressure: Real  \n  end ReturnFuelFlow  \n\n  interface TemperatureSensorSignal  \n    data temperatureValue: Real  \n  end TemperatureSensorSignal  \n\n  interface TemperatureDataSignal  \n    data temperatureReading: Real  \n    data timestamp: DateTime  \n  end TemperatureDataFlow  \n\n  flow FuelFlow  \n  end FuelFlow  \n\n  flow ReturnFuelFlow  \n  end ReturnFuelFlow  \n\n  data TemperatureDataFlow  \n  end TemperatureDataFlow  \nend FuelSystem",
    "module SafetySecurityModel {\n  block SafetySecurityCompliance {\n    // Constraint block for safety/security compliance\n  }\n\n  block SeatBelt {\n    apply SafetySecurityCompliance;\n  }\n\n  block Airbag {\n    apply SafetySecurityCompliance;\n  }\n\n  block AntiTheftAlarm {\n    apply SafetySecurityCompliance;\n  }\n\n  block Bumper {\n    apply SafetySecurityCompliance;\n  }\n\n  block KeylessEntrySystem {\n    apply SafetySecurityCompliance;\n  }\n\n  block Wheel {\n    apply SafetySecurityCompliance;\n  }\n\n  block AntiLockBrakingSystem {\n    apply SafetySecurityCompliance;\n  }\n\n  block Interior {\n    part seatBelts: SeatBelt[*2] {mandatory};\n    part antiTheftAlarm: AntiTheftAlarm[*1] {mandatory};\n  }\n\n  block Cockpit {\n    part airbag: Airbag[*1] {optional};\n  }\n\n  block Body {\n    part bumper: Bumper[*1] {mandatory};\n    part keylessEntrySystem: KeylessEntrySystem[*1] {mandatory};\n  }\n\n  block Chassis {\n    part wheels: Wheel[*2] {mandatory};\n    part antiLockBrakingSystems: AntiLockBrakingSystem[*2] {optional};\n  }\n\n  block Vehicle {\n    part interior: Interior[*1] {mandatory};\n    part cockpit: Cockpit[*1] {mandatory};\n    part body: Body[*1] {mandatory};\n    part chassis: Chassis[*1] {mandatory};\n  }\n}",
    "model VehicleSafetyAndSecurityComponentSystem {\n  part interior : Interior {\n    part alarmSystem : AlarmSystem;\n    part seatBelts : SeatBelts;\n    part frontRowSeats : FrontRowSeats;\n    part driverAirbag : DriverAirbag;\n  };\n  part bodyAssembly : BodyAssembly {\n    part vehicleBody : VehicleBody;\n    part bumper : Bumper;\n    part keylessEntrySystem : KeylessEntrySystem;\n  };\n  features {\n    safety : SafetyFeatures [1] {\n      reference seatBelts : SeatBelts = interior.seatBelts;\n      reference airbags : DriverAirbag = interior.driverAirbag;\n      reference bumper : Bumper = bodyAssembly.bumper;\n    };\n    security : SecurityFeatures [1] {\n      reference alarmSystem : AlarmSystem = interior.alarmSystem;\n      reference keylessEntrySystem : KeylessEntrySystem = bodyAssembly.keylessEntrySystem;\n    };\n  };\n}",
    "package InformationSecurityModel {\n  enumeration SecurityClassification {\n    Unclassified;\n    Confidential;\n    Secret;\n  }\n\n  class Component {\n    property securityLevel : SecurityClassification;\n    property classificationAttribute : String [applies when securityLevel == Confidential];\n  }\n}",
    "model AutomotiveECUModel {\n  interface BusIF {\n  }\n\n  interface SensorIF {\n  }\n\n  block VehicleStateData {\n  }\n\n  block EngineStateData {\n  }\n\n  block VCU {\n    ports: \n      busIF: BusIF,\n      sensorIF: SensorIF;\n  }\n\n  block ECU {\n    ports: \n      busIF: BusIF,\n      sensorIF: SensorIF;\n  }\n\n  block CANBus {\n    ports: \n      vcuBusIF: BusIF,\n      ecuBusIF: BusIF;\n  }\n\n  block AutomotiveECUSystem {\n    parts: \n      vcu: VCU,\n      ecu: ECU,\n      canBus: CANBus;\n\n    connect vcu.busIF to canBus.vcuBusIF;\n    connect ecu.busIF to canBus.ecuBusIF;\n\n    flow vcuToEcuFlow: vcu -> canBus -> ecu of VehicleStateData;\n    flow ecuToVcuFlow: ecu -> canBus -> vcu of EngineStateData;\n  }\n}",
    "package BloodGlucoseMeterSystemModel {\n    block BloodGlucoseMeterSystem {\n        part battery : Battery;\n        part batteryStatusMonitor : BatteryStatusMonitor;\n        part alertSystem : AlertSystem;\n        part measurementFunctionMonitor : MeasurementFunctionMonitor;\n        part emergencyResponse : EmergencyResponse;\n        part riskManagementSystem : RiskManagementSystem;\n\n        constraint batteryLevelConstraint : battery.batteryLevel >= 0.0 and battery.batteryLevel <= 1.0;\n        constraint chargingStatusConstraint : battery.chargingStatus in {Normal, Low, Depleted, Charging, CannotCharge};\n\n        requirement R1: When battery.batteryLevel < 0.1 or battery.chargingStatus = Depleted or battery.chargingStatus = CannotCharge, alertSystem must activateUserAlert;\n        requirement R2: measurementFunctionMonitor must detectAbnormalities and trigger emergencyResponse if abnormalities exist;\n        requirement R3: riskManagementSystem must implement managementMeasures for all keyRiskScenarios;\n    }\n\n    block Battery {\n        property batteryLevel : Float;\n        property chargingStatus : String;\n    }\n\n    block BatteryStatusMonitor {\n        reference monitoredBattery : Battery;\n        method checkBatteryStatus() : Boolean;\n    }\n\n    block AlertSystem {\n        method activateUserAlert() : Void;\n    }\n\n    block MeasurementFunctionMonitor {\n        method detectAbnormalities() : Boolean;\n    }\n\n    block EmergencyResponse {\n        method initiateEmergencyProcedure() : Void;\n    }\n\n    block RiskManagementSystem {\n        property keyRiskScenarios : List<String>;\n        property managementMeasures : List<String>;\n    }\n\n    constraintDefinition BatteryLevelConstraint {\n        parameter batteryLevel : Float;\n        constraint batteryLevel >= 0.0 and batteryLevel <= 1.0;\n    }\n\n    constraintDefinition ChargingStatusConstraint {\n        parameter chargingStatus : String;\n        constraint chargingStatus in {Normal, Low, Depleted, Charging, CannotCharge};\n    }\n\n    requirementDefinition BatteryAlertRequirement {\n        parameter batteryLevel : Float;\n        parameter chargingStatus : String;\n        constraint (batteryLevel < 0.1 or chargingStatus = \"Depleted\" or chargingStatus = \"CannotCharge\") implies activateUserAlert;\n    }\n\n    requirementDefinition MeasurementEmergencyResponseRequirement {\n        parameter abnormalitiesDetected : Boolean;\n        constraint abnormalitiesDetected implies initiateEmergencyProcedure;\n    }\n\n    requirementDefinition RiskManagementRequirement {\n        parameter keyRiskScenarios : List<String>;\n        parameter managementMeasures : List<String>;\n        constraint size(keyRiskScenarios) = size(managementMeasures);\n    }\n}",
    "module ScientificConstants {\n  import SI::*;\n  \n  module Mathematical {\n    parameter e : Real = 2.71828182845904523536;\n    parameter pi : Real = 3.14159265358979323846;\n  }\n  \n  module Physical {\n    parameter speedOfLight : Real = 299792458;\n    constraint speedOfLightConstraint { speedOfLight unit metrePerSecond; }\n    \n    parameter fineStructureConstant : Real = 7.2973525693e-3;\n    constraint fineStructureConstantConstraint { fineStructureConstant unit 1; }\n    \n    parameter electronProtonMassRatio : Real = 5.446169572901496e-4;\n    constraint electronProtonMassRatioConstraint { electronProtonMassRatio unit 1; }\n  }\n  \n  module ScenarioSpecific {\n    parameter gravitationalAcceleration : Real = 9.80665;\n    constraint gravitationalAccelerationConstraint { gravitationalAcceleration unit metrePerSecondSquared; }\n    \n    parameter amplifierGainCoefficient : Real = 100.5;\n    constraint amplifierGainCoefficientConstraint { amplifierGainCoefficient unit 1; }\n    note \"Applicable to Model X amplifier configurations\";\n  }\n}",
    "module AutomotiveTireModel {  \n  class Tire {  \n    manufacturer : String;  \n    rimDiameter : Real;  \n    width : Integer;  \n  }  \n  instance Tire frenchTireInstance {  \n    manufacturer = \"Michelin\";  \n    rimDiameter = 18.0;  \n    width = 245;  \n  }  \n}",
    "package AutomotiveComponentModel {\n  class Vehicle {\n    property mass: Mass = 1200 unit kg, 2645.55 unit lb;\n    property length: Length = 4.82 unit m, 15.8136 unit ft;\n    part frontWheels: FrontWheel[2];\n  }\n\n  class FrontWheel {\n    property hubDiameter: Length = 18 unit inch, 457.2 unit mm;\n    property width: Length = 245 unit mm, 9.6457 unit inch;\n    property outerDiameter: Length;\n    part tire: Tire;\n\n    derive outerDiameter: Length = hubDiameter * 25.4 + 2 * tire.tireHeight;\n  }\n\n  class Tire {\n    property tireHeight: Length;\n  }\n\n  unit kg = kilogram;\n  unit lb = pound-mass;\n  unit m = meter;\n  unit ft = foot;\n  unit inch = international-inch;\n  unit mm = millimeter;\n}",
    "module PowertrainModel {\n  block Engine {}\n  block Transmission {}\n  constraintblock HighPerformanceEngineConstraint {\n    context Powertrain\n    body self.isHighPerformance implies self.engine.oclIsKindOf(SixCylinderEngine)\n    and not self.isHighPerformance implies self.engine.oclIsKindOf(FourCylinderEngine)\n  }\n  constraintblock ValidCombinationConstraint {\n    context Powertrain\n    body (self.engine.oclIsKindOf(FourCylinderEngine) and self.transmission.oclIsKindOf(ManualTransmission))\n    or (self.engine.oclIsKindOf(SixCylinderEngine) and self.transmission.oclIsKindOf(AutomaticTransmission))\n  }\n  block FourCylinderEngine extends Engine {}\n  block SixCylinderEngine extends Engine {}\n  block ManualTransmission extends Transmission {}\n  block AutomaticTransmission extends Transmission {}\n  block Powertrain {\n    part engine : Engine;\n    part transmission : Transmission;\n    property isHighPerformance : Boolean;\n    constraint c1 : HighPerformanceEngineConstraint;\n    constraint c2 : ValidCombinationConstraint;\n  }\n}",
    "model AutomotiveSystem {\n\n  package AutomotiveSystem {\n\n    class Car {\n      mass: Mass = 1200 kg;\n      length: Length = 4.82 m;\n      wheelAssemblies: WheelAssembly[*];\n    }\n\n    class WheelAssembly {\n      brakeDisc: BrakeDisc[1];\n      wheel: Wheel[1];\n    }\n\n    class Wheel {\n      rim: Rim[1];\n      tire: Tire[1];\n      outerDiameter: Length;\n    }\n\n    class Rim {\n      diameter: Length = 18 in;\n    }\n\n    class Tire {\n      width: Length = 245 mm;\n      height: Length = 45 mm;\n      treadDepth: Length = 6.0 mm;\n    }\n\n    class BrakeDisc {\n      radius: Length = 95 mm;\n      diameter: Length;\n    }\n\n    constraintblock TreadDepthConstraint {\n      treadDepth: Length;\n      constraint c1: treadDepth >= 3.5 mm;\n    }\n\n    constraintblock WheelOuterDiameterConstraint {\n      rimDiameter: Length;\n      tireHeight: Length;\n      outerDiameter: Length;\n      constraint c1: outerDiameter = (rimDiameter * 25.4 mm) + 2 * tireHeight;\n    }\n\n    constraintblock BrakeDiscDiameterConstraint {\n      radius: Length;\n      diameter: Length;\n      constraint c1: diameter = 2 * radius;\n    }\n\n    constraintblock BrakeDiscFitmentConstraint {\n      brakeDiscDiameter: Length;\n      wheelOuterDiameter: Length;\n      constraint c1: brakeDiscDiameter < wheelOuterDiameter;\n    }\n\n    apply TreadDepthConstraint to Tire.treadDepth;\n\n    apply WheelOuterDiameterConstraint to Wheel {\n      rimDiameter -> Wheel.rim.diameter;\n      tireHeight -> Wheel.tire.height;\n      outerDiameter -> Wheel.outerDiameter;\n    }\n\n    apply BrakeDiscDiameterConstraint to BrakeDisc.diameter {\n      radius -> BrakeDisc.radius;\n      diameter -> BrakeDisc.diameter;\n    }\n\n    apply BrakeDiscFitmentConstraint to WheelAssembly {\n      brakeDiscDiameter -> WheelAssembly.brakeDisc.diameter;\n      wheelOuterDiameter -> WheelAssembly.wheel.outerDiameter;\n    }\n\n  }\n\n}",
    "model AutomotiveFuelSystemModel {\n  block AutomotiveFuelSystem {\n    part fuelTankAssembly : FuelTankAssembly;\n    part fuelTemperatureMonitor : FuelTemperatureMonitor;\n\n    port fuelSupplyPort : FuelSupplyInterface;\n    port fuelReturnPort : FuelReturnInterface;\n    port temperatureTransmissionPort : TemperatureTransmissionInterface;\n\n    feature fuelSupplyPort <<flow>> Fuel;\n    feature fuelReturnPort <<flow>> ReturnFuel;\n    feature temperatureTransmissionPort <<flow>> TemperatureSignal;\n\n    constraint fuelSupplyPort = fuelTankAssembly.fuelSupplyPort;\n    constraint fuelReturnPort = fuelTankAssembly.fuelReturnPort;\n    constraint temperatureTransmissionPort = fuelTemperatureMonitor.temperatureOutPort;\n  }\n\n  block FuelTankAssembly {\n    part fuelTank : FuelTank;\n    part fuelPump : FuelPump;\n\n    port fuelSupplyPort : FuelSupplyInterface;\n    port fuelReturnPort : FuelReturnInterface;\n\n    feature fuelSupplyPort <<flow>> Fuel;\n    feature fuelReturnPort <<flow>> ReturnFuel;\n\n    constraint fuelSupplyPort = fuelPump.fuelOutPort;\n    constraint fuelReturnPort = fuelPump.returnFuelInPort;\n  }\n\n  block FuelTank {\n    port fuelOutPort : FuelSupplyInterface;\n\n    feature fuelOutPort <<flow>> Fuel;\n  }\n\n  block FuelPump {\n    port fuelInPort : FuelSupplyInterface;\n    port fuelOutPort : FuelSupplyInterface;\n    port returnFuelInPort : FuelReturnInterface;\n    port temperatureOutPort : TemperatureTransmissionInterface;\n\n    feature fuelInPort <<flow>> Fuel;\n    feature fuelOutPort <<flow>> Fuel;\n    feature returnFuelInPort <<flow>> ReturnFuel;\n    feature temperatureOutPort <<flow>> TemperatureSignal;\n\n    constraint fuelInPort = fuelTank.fuelOutPort;\n    constraint fuelOutPort <<supply>> Engine;\n    constraint returnFuelInPort <<return>> Engine;\n  }\n\n  block FuelReturnInterface {\n    feature returnFuel <<flow>> ReturnFuel;\n  }\n\n  block TemperatureTransmissionInterface {\n    feature temperatureSignal <<flow>> TemperatureSignal;\n  }\n\n  block FuelSupplyInterface {\n    feature fuel <<flow>> Fuel;\n  }\n\n  flow Fuel {\n    property quantity : Real;\n    property pressure : Real;\n  }\n\n  flow ReturnFuel {\n    property quantity : Real;\n    property pressure : Real;\n  }\n\n  flow TemperatureSignal {\n    property temperature : Real;\n  }\n}",
    "package PhysicalQuantitySystemModel {\n  class PhysicalQuantitySystem {\n    property baseQuantities : BasePhysicalQuantity[*];\n    operation importQuantitySystem(quantities : BasePhysicalQuantity[*]) : Boolean;\n    operation addQuantity(quantity : BasePhysicalQuantity) : Boolean;\n    operation convertUnit(value : Real, fromUnit : Unit, toUnit : Unit) : Real;\n  }\n\n  abstract class BasePhysicalQuantity {\n    property name : String;\n    property symbol : String;\n    property baseUnit : Unit;\n    property derivedUnits : Unit[*];\n  }\n\n  class Length <|-- BasePhysicalQuantity {\n    property name : String = \"Length\";\n    property symbol : String = \"L\";\n  }\n\n  class Mass <|-- BasePhysicalQuantity {\n    property name : String = \"Mass\";\n    property symbol : String = \"M\";\n  }\n\n  class Time <|-- BasePhysicalQuantity {\n    property name : String = \"Time\";\n    property symbol : String = \"T\";\n  }\n\n  class ElectricCurrent <|-- BasePhysicalQuantity {\n    property name : String = \"Electric Current\";\n    property symbol : String = \"I\";\n  }\n\n  class Temperature <|-- BasePhysicalQuantity {\n    property name : String = \"Temperature\";\n    property symbol : String = \"Θ\";\n  }\n\n  class AmountOfSubstance <|-- BasePhysicalQuantity {\n    property name : String = \"Amount of Substance\";\n    property symbol : String = \"N\";\n  }\n\n  class LuminousIntensity <|-- BasePhysicalQuantity {\n    property name : String = \"Luminous Intensity\";\n    property symbol : String = \"J\";\n  }\n\n  class Unit {\n    property name : String;\n    property symbol : String;\n    property conversionFactor : Real;\n    property quantity : BasePhysicalQuantity;\n  }\n\n  class Meter <|-- Unit {\n    property name : String = \"Meter\";\n    property symbol : String = \"m\";\n    property conversionFactor : Real = 1.0;\n  }\n\n  class Kilogram <|-- Unit {\n    property name : String = \"Kilogram\";\n    property symbol : String = \"kg\";\n    property conversionFactor : Real = 1.0;\n  }\n\n  class Second <|-- Unit {\n    property name : String = \"Second\";\n    property symbol : String = \"s\";\n    property conversionFactor : Real = 1.0;\n  }\n\n  class Ampere <|-- Unit {\n    property name : String = \"Ampere\";\n    property symbol : String = \"A\";\n    property conversionFactor : Real = 1.0;\n  }\n\n  class Kelvin <|-- Unit {\n    property name : String = \"Kelvin\";\n    property symbol : String = \"K\";\n    property conversionFactor : Real = 1.0;\n  }\n\n  class Mole <|-- Unit {\n    property name : String = \"Mole\";\n    property symbol : String = \"mol\";\n    property conversionFactor : Real = 1.0;\n  }\n\n  class Candela <|-- Unit {\n    property name : String = \"Candela\";\n    property symbol : String = \"cd\";\n    property conversionFactor : Real = 1.0;\n  }\n\n  class Kilometer <|-- Unit {\n    property name : String = \"Kilometer\";\n    property symbol : String = \"km\";\n    property conversionFactor : Real = 1000.0;\n  }\n\n  association LengthBaseUnit {\n    member end baseUnit [1] : Meter {subsets BasePhysicalQuantity::baseUnit}\n    member end quantity [1] : Length {subsets Unit::quantity}\n  }\n\n  association MassBaseUnit {\n    member end baseUnit [1] : Kilogram {subsets BasePhysicalQuantity::baseUnit}\n    member end quantity [1] : Mass {subsets Unit::quantity}\n  }\n\n  association TimeBaseUnit {\n    member end baseUnit [1] : Second {subsets BasePhysicalQuantity::baseUnit}\n    member end quantity [1] : Time {subsets Unit::quantity}\n  }\n\n  association ElectricCurrentBaseUnit {\n    member end baseUnit [1] : Ampere {subsets BasePhysicalQuantity::baseUnit}\n    member end quantity [1] : ElectricCurrent {subsets Unit::quantity}\n  }\n\n  association TemperatureBaseUnit {\n    member end baseUnit [1] : Kelvin {subsets BasePhysicalQuantity::baseUnit}\n    member end quantity [1] : Temperature {subsets Unit::quantity}\n  }\n\n  association AmountOfSubstanceBaseUnit {\n    member end baseUnit [1] : Mole {subsets BasePhysicalQuantity::baseUnit}\n    member end quantity [1] : AmountOfSubstance {subsets Unit::quantity}\n  }\n\n  association LuminousIntensityBaseUnit {\n    member end baseUnit [1] : Candela {subsets BasePhysicalQuantity::baseUnit}\n    member end quantity [1] : LuminousIntensity {subsets Unit::quantity}\n  }\n\n  association DerivedUnits {\n    member end derivedUnit [0..*] : Unit {subsets BasePhysicalQuantity::derivedUnits}\n    member end quantity [1] : BasePhysicalQuantity {subsets Unit::quantity}\n  }\n}",
    "package UnitSystemLibrary {\n  «quantityKind» Length;\n  «quantityKind» Mass;\n  «quantityKind» Time;\n\n  package ISQ {\n    «unit» Meter : Length {\n      symbol: \"m\";\n      definition: \"The SI base unit of length.\";\n    }\n    «unit» Kilogram : Mass {\n      symbol: \"kg\";\n      definition: \"The SI base unit of mass.\";\n    }\n    «unit» Second : Time {\n      symbol: \"s\";\n      definition: \"The SI base unit of time.\";\n    }\n  }\n\n  package USCustomaryUnits {\n    «unit» Foot : Length {\n      symbol: \"ft\";\n      definition: \"A US customary unit of length.\";\n    }\n    «unit» Pound : Mass {\n      symbol: \"lb\";\n      definition: \"A US customary unit of mass.\";\n    }\n    «unit» Hour : Time {\n      symbol: \"hr\";\n      definition: \"A US customary unit of time.\";\n    }\n  }\n\n  package Conversions {\n    «conversion» MeterToFoot : ISQ::Meter -> USCustomaryUnits::Foot {\n      factor: 3.28084;\n      offset: 0.0;\n    }\n    «conversion» FootToMeter : USCustomaryUnits::Foot -> ISQ::Meter {\n      factor: 0.3048;\n      offset: 0.0;\n    }\n    «conversion» KilogramToPound : ISQ::Kilogram -> USCustomaryUnits::Pound {\n      factor: 2.20462;\n      offset: 0.0;\n    }\n    «conversion» PoundToKilogram : USCustomaryUnits::Pound -> ISQ::Kilogram {\n      factor: 0.453592;\n      offset: 0.0;\n    }\n    «conversion» SecondToHour : ISQ::Second -> USCustomaryUnits::Hour {\n      factor: 0.000277778;\n      offset: 0.0;\n    }\n    «conversion» HourToSecond : USCustomaryUnits::Hour -> ISQ::Second {\n      factor: 3600.0;\n      offset: 0.0;\n    }\n  }\n}",
    "package HeadlampTiltSystem {\n  import unit::SI::*;\n  import constant::Real::*;\n  \n  block HeadlampTiltAdjustmentKnob {\n    property beamTiltAngle : Real [unit: PlaneAngle::degree];\n    \n    apply BeamTiltAngleConstraint;\n  }\n  \n  constraint block BeamTiltAngleConstraint {\n    constraint clause BeamTiltAngleConstraintClause {\n      beamTiltAngle >= 50 * PlaneAngle::degree and beamTiltAngle <= 80 * PlaneAngle::degree;\n    }\n  }\n}",
    "module DataTypes {\n  constraint NonNegativeConstraint {\n    value >= 0\n  }\n\n  value UnsignedInteger {\n    value : Integer\n    constraint NonNegativeConstraint\n  }\n\n  value UnsignedFloat {\n    value : Real\n    constraint NonNegativeConstraint\n  }\n\n  enumeration StatusLevel {\n    Critical\n    Warning\n    Normal\n  }\n\n  enumeration Color {\n    Red\n    Yellow\n    Green\n  }\n\n  block StatusColor {\n    status : StatusLevel\n    color : Color\n    constraint StatusColorConstraint\n  }\n\n  constraint StatusColorConstraint {\n    switch (self.status) {\n      case Critical: self.color == Color::Red\n      case Warning: self.color == Color::Yellow\n      case Normal: self.color == Color::Green\n    }\n  }\n\n  enumeration SizeOption {\n    Small : 60\n    Medium : 70\n    Large : 80\n  }\n\n  block DiameterParameter {\n    size : SizeOption { default Small }\n    diameter : UnsignedFloat { unit mm }\n    constraint DiameterConstraint\n  }\n\n  constraint DiameterConstraint {\n    self.diameter.value == self.size.value\n  }\n}",
    "model CollectionManagementSystem\n  class System\n    spareParts : Bag<SparePart>\n    integerList : List<Integer>\n    stringSet : Set<String>\n    personnelOrderedSet : OrderedSet<Person>\n    personnelSets : List<Set<Person>>\n    realArray : Array<4, 4, Real>\n  end class System\n\n  class SparePart\n  end class SparePart\n\n  class Person\n  end class Person\nend model CollectionManagementSystem",
    "model TireModel {\n  import sysml::*;\n  import units::*;\n  \n  class Coordinate {\n    x : Float;\n    y : Float;\n    z : Float;\n  }\n  \n  class Tire {\n    manufacturerName : String;\n    rimDiameter : Float [unit inch];\n    tireWidth : Float [unit millimeter];\n    installationPosition : Coordinate [0..1];\n  }\n}",
    "module SpacecraftTrajectoryModel {\n    block TrajectoryRecordingSystem {\n        part liftoffTime : LiftoffTime;\n        part sampledData[*] : SampledData;\n    }\n\n    block LiftoffTime {\n        property time : String;\n        note \"Example UTC liftoff time: 22:42:32.924534 on August 23, 2020\";\n    }\n\n    block Position {\n        property x : Number @unit 'm';\n        property y : Number @unit 'm';\n        property z : Number @unit 'm';\n    }\n\n    block Velocity {\n        property x : Number @unit 'm/s';\n        property y : Number @unit 'm/s';\n        property z : Number @unit 'm/s';\n    }\n\n    block SampledData {\n        property time : Number @unit 's';\n        reference position : Position;\n        reference velocity : Velocity;\n    }\n}",
    "import unit::Unit;\n\nmodel AlloyPropertyModel {\n  class Substance {\n    property atomicMass : Real;\n  }\n\n  class Material : Substance {\n    property tensileStrength : Real;\n    property tensileStrengthUnit : Unit = unit::NPerSqMM;\n  }\n\n  class Metal : Material {\n  }\n\n  class Alloy : Material {\n    property parts : Part[*] = Substance;\n    property massFraction : Decimal[0..1] { \n      constraint: value >= 0 and value <= 1;\n    }\n  }\n\n  unit NPerSqMM as \"N/mm²\" = (unit::Newton / unit::SquareMillimeter);\n\n  instance iron : Metal {\n    atomicMass = 55.845;\n    tensileStrength = 250;\n  }\n\n  instance carbon : Metal {\n    atomicMass = 12.011;\n    tensileStrength = 100;\n  }\n\n  instance manganese : Metal {\n    atomicMass = 54.938;\n    tensileStrength = 150;\n  }\n\n  instance steel980 : Alloy {\n    parts = iron, carbon, manganese;\n    massFraction = 0.97, 0.008, 0.022;\n    tensileStrength = 980;\n  }\n}",
    "profile EngineeringMaterials {\n  package Materials {\n    class Material {\n      property atomicMass : DimensionalQuantity;\n      property mechanicalProperties : TensileStrength;\n    }\n\n    class Metal {\n      «extends» Material;\n    }\n\n    class Alloy {\n      «extends» Material;\n      composition : Composition[*];\n    }\n\n    class Composition {\n      property massFraction : Real;\n      «association» Alloy::composition . constituent : Material[1];\n    }\n\n    class TensileStrength {\n      «extends» DimensionalQuantity;\n    }\n\n    instance specification Steel_980 : Alloy {\n      atomicMass = 55.845 * unit::g_per_mol;\n      mechanicalProperties = 980 * unit::N_per_mm2;\n      composition[0].constituent = Iron;\n      composition[0].massFraction = 0.96;\n      composition[1].constituent = Carbon;\n      composition[1].massFraction = 0.025;\n      composition[2].constituent = Manganese;\n      composition[2].massFraction = 0.015;\n    }\n\n    instance specification Iron : Metal {\n      atomicMass = 55.845 * unit::g_per_mol;\n    }\n\n    instance specification Carbon : Material {\n      atomicMass = 12.01 * unit::g_per_mol;\n    }\n\n    instance specification Manganese : Material {\n      atomicMass = 54.94 * unit::g_per_mol;\n    }\n  }\n}",
    "package PubSubSystem {\n  block Server {\n    part topics : List<Topic>;\n    part subscriptions : Map<Topic, List<Consumer>>;\n    action addSubscription(consumer : Consumer, topic : Topic) {\n      if (subscriptions.containsKey(topic)) {\n        subscriptions.get(topic).add(consumer);\n      } else {\n        subscriptions.put(topic, List<Consumer>[consumer]);\n      }\n    }\n    action receiveMessage(message : Message, topic : Topic) {\n      for (subscriber in subscriptions.get(topic)) {\n        send message to subscriber.receiveMessage(message);\n      }\n    }\n  }\n\n  block Producer {\n    action publish(topic : Topic) returns Message;\n  }\n\n  block Consumer {\n    part server : Server;\n    action subscribe(topic : Topic) {\n      send (this, topic) to server.addSubscription(this, topic);\n    }\n    action receiveMessage(message : Message);\n  }\n\n  block Topic {\n    property name : String;\n  }\n\n  block Message {\n    property content : String;\n    property topic : Topic;\n  }\n}",
    "module FuelSystemModel {\n    block FuelSystem {\n        part fuelTank: FuelTankAssembly;\n        part engine: Engine;\n        part monitoringSystem: FuelMonitoringSystem;\n\n        flow FuelLineSupply from fuelTank.supplyPort to engine.fuelInPort;\n        flow FuelLineReturn from engine.fuelOutPort to fuelTank.returnPort;\n        valueFlow TemperatureSignal from monitoringSystem.temperaturePort;\n    }\n\n    block FuelTankAssembly {\n        port supplyPort: FlowPort direction out;\n        port returnPort: FlowPort direction in;\n    }\n\n    block Engine {\n        port fuelInPort: FlowPort direction in;\n        port fuelOutPort: FlowPort direction out;\n        port temperatureSensorPort: ValuePort direction out type TemperatureSignal;\n    }\n\n    block FuelMonitoringSystem {\n        port temperaturePort: ValuePort direction out type TemperatureSignal;\n    }\n\n    valueType Fuel {\n        property quantity: Real;\n    }\n\n    valueType TemperatureSignal {\n        property value: Real;\n    }\n\n    constraintBlock FuelLineConstraint {\n        property maxPressure: Real;\n        property maxTemperature: Real;\n    }\n\n    apply FuelLineConstraint to FuelLineSupply;\n    apply FuelLineConstraint to FuelLineReturn;\n}",
    "model PublishSubscribeSystemModel {  \n  block Producer {  \n    port publishPort: MessagePort<TopicMessage>  \n  }  \n\n  block Server {  \n    port receiveMessagePort: MessagePort<TopicMessage>  \n    port receiveSubscriptionPort: MessagePort<SubscriptionRequest>  \n    port deliverMessagePort: MessagePort<TopicMessage>  \n    part subscriptionManager: SubscriptionManager  \n  }  \n\n  block Consumer {  \n    port subscribePort: MessagePort<SubscriptionRequest>  \n    port receiveMessagePort: MessagePort<TopicMessage>  \n  }  \n\n  block SubscriptionManager {  \n    port subscriptionPort: MessagePort<SubscriptionRequest>  \n    port messagePort: MessagePort<TopicMessage>  \n  }  \n\n  data type TopicMessage {  \n    property topic: String  \n    property content: String  \n  }  \n\n  data type SubscriptionRequest {  \n    property topic: String  \n  }  \n\n  data type MessageFlow {  \n    property message: TopicMessage  \n  }  \n\n  data type SubscriptionFlow {  \n    property subscription: SubscriptionRequest  \n  }  \n\n  flow MessageDeliveryFlow {  \n    property message: TopicMessage  \n  }  \n\n  flow SubscriptionFlow {  \n    property subscription: SubscriptionRequest  \n  }  \n\n  relationship ServerProducerLink {  \n    source producer: Producer  \n    destination server: Server  \n    flow messageFlow: MessageFlow {  \n      sourcePort producer.publishPort  \n      destinationPort server.receiveMessagePort  \n    }  \n  }  \n\n  relationship ServerConsumerLink {  \n    source consumer: Consumer  \n    destination server: Server  \n    flow subscriptionFlow: SubscriptionFlow {  \n      sourcePort consumer.subscribePort  \n      destinationPort server.receiveSubscriptionPort  \n    }  \n    flow messageDeliveryFlow: MessageDeliveryFlow {  \n      sourcePort server.deliverMessagePort  \n      destinationPort consumer.receiveMessagePort  \n    }  \n  }  \n\n  relationship ServerSubscriptionManagerLink {  \n    source server: Server  \n    destination subscriptionManager: SubscriptionManager  \n    flow subscriptionFlow: SubscriptionFlow {  \n      sourcePort server.receiveSubscriptionPort  \n      destinationPort subscriptionManager.subscriptionPort  \n    }  \n    flow messageFlow: MessageFlow {  \n      sourcePort server.receiveMessagePort  \n      destinationPort subscriptionManager.messagePort  \n    }  \n  }  \n}",
    "model TransportationSystem {  \n  block Vehicle {  \n    property fuelLevel : Float { lowerBound = 0.0 }  \n    property maxTankCapacity : Float { lowerBound = 0.0 }  \n    constraint lowFuelConstraint : fuelLevel < 0.1 * maxTankCapacity  \n    part driver : Driver { multiplicity = 1 }  \n    part passengers : Passenger[*] { upperBound = 4 }  \n    part environmentalFactors : EnvironmentalFactors { multiplicity = 1 }  \n    operation boardUsers(driver : User, passengers : User[*])  \n    operation refuel()  \n    operation exitUsers()  \n  }  \n\n  block User {}  \n  block Driver extends User {}  \n  block Passenger extends User {}  \n  block EnvironmentalFactors {}  \n}",
    "module FuelManagementSystem {  \n  block System {  \n    part fuelTankAssembly : FuelTankAssembly;  \n    part engineUnit : EngineUnit;  \n\n    connect fuelTankAssembly.fuelOutlet to engineUnit.fuelInlet via FuelSupplyInterface;  \n    connect engineUnit.fuelReturnOutlet to fuelTankAssembly.fuelReturnInlet via FuelReturnInterface;  \n  }  \n\n  block FuelTankAssembly {  \n    port fuelOutlet [supplier] : FuelSupplyInterface;  \n    port fuelReturnInlet [client] : FuelReturnInterface;  \n  }  \n\n  block EngineUnit {  \n    port fuelInlet [client] : FuelSupplyInterface;  \n    port fuelReturnOutlet [supplier] : FuelReturnInterface;  \n  }  \n\n  interface FuelSupplyInterface {  \n    property fuelTemperature : Real {unit = \"K\"};  \n  }  \n\n  interface FuelReturnInterface {  \n    property fuelTemperature : Real {unit = \"K\"};  \n  }  \n}",
    "package VehicleFuelSystemModel {\n  flow Fuel;\n  end Fuel;\n\n  block FuelPort {\n    flow fuel: Fuel;\n    temperature: Real;\n  }\n\n  block FuelTankAssembly {\n    port fuelSupplyPort: FuelPort;\n    port fuelReturnPort: FuelPort;\n  }\n\n  block Engine {\n    port fuelSupplyPort: FuelPort;\n    port fuelReturnPort: FuelPort;\n  }\n\n  block VehicleFuelSystem {\n    part fuelTankAssembly: FuelTankAssembly;\n    part engine: Engine;\n    fuelTankAssembly.fuelSupplyPort -> engine.fuelSupplyPort;\n    engine.fuelReturnPort -> fuelTankAssembly.fuelReturnPort;\n    apply ReliabilityConstraint;\n    apply SafetyConstraint;\n    apply MonitoringConstraint;\n  }\n\n  constraintblock ReliabilityConstraint {\n    parameter fuelFlow: Flow(Fuel);\n    constraint fuelFlow.reliability >= 0.99;\n  }\n\n  constraintblock SafetyConstraint {\n    parameter fuelFlow: Flow(Fuel);\n    constraint fuelFlow.safetyRating == \"ISO_26262_ASIL_C\";\n  }\n\n  constraintblock MonitoringConstraint {\n    parameter temperature: Real;\n    constraint temperature.monitoringFrequency >= 10 Hz;\n  }\n}",
    "module PhotoCaptureSystemModel {\n    block PhotoCaptureSystem {\n        part userInterface : UserInterface;\n        part cameraModule : CameraModule;\n        part imageProcessingModule : ImageProcessingModule;\n    }\n\n    block UserInterface {\n        port sceneSelectionPort : SceneSelection;\n    }\n\n    block CameraModule {\n        port photoOutputPort : FinalPhoto;\n    }\n\n    block ImageProcessingModule {\n        part autoFocus : AutoFocusing;\n        part capture : PhotoCapture;\n    }\n\n    block AutoFocusing {\n        reference sceneInput : SceneSelection;\n        flow intermediateImage : IntermediateImage;\n    }\n\n    block PhotoCapture {\n        reference focusedImage : IntermediateImage;\n        flow finalPhoto : FinalPhoto;\n    }\n\n    flow SceneSelection {\n        item selectedScene : Scene;\n    }\n\n    flow IntermediateImage {\n        item focusedSceneData : ImageData;\n    }\n\n    flow FinalPhoto {\n        item capturedPhoto : Photo;\n    }\n\n    behavior usecase CapturePhoto {\n        trigger userInterface.sceneSelectionPort;\n        do {\n            when (sceneSelected) {\n                imageProcessingModule.autoFocus.execute();\n                imageProcessingModule.capture.execute();\n            }\n        }\n        output cameraModule.photoOutputPort;\n    }\n}",
    "block SceneSelectionAction\n  output SelectedScene : Scene\nend SceneSelectionAction\n\nblock FocusingAction\n  input selectedScene : Scene\n  output intermediateImage : IntermediateImage\nend FocusingAction\n\nblock ShootingAction\n  input focusedImage : IntermediateImage\n  output finalPhotograph : FinalPhotograph\nend ShootingAction\n\nblock IntermediateImage\nend IntermediateImage\n\nblock FinalPhotograph\nend FinalPhotograph\n\nblock PhotographySystem\n  part sceneSelection : SceneSelectionAction\n  part focusing : FocusingAction\n  part shooting : ShootingAction\n  part intermediateImage : IntermediateImage\n  part finalPhotograph : FinalPhotograph\n\n  flow sceneSelection.SelectedScene -> focusing.selectedScene\n  flow focusing.intermediateImage -> intermediateImage\n  flow intermediateImage -> shooting.focusedImage\n  flow shooting.finalPhotograph -> finalPhotograph\n\n  state machine workflow\n    state Focusing\n      do: focusing\n    end Focusing\n\n    state Shooting\n      do: shooting\n    end Shooting\n\n    transition initial -> Focusing\n    transition Focusing -> Shooting\n    transition Shooting -> final\n  end workflow\nend PhotographySystem",
    "block PhotographyWorkflowSystem\n  sceneSelection : SceneSelection\n  focusingProcess : FocusingProcess\n  shootingProcess : ShootingProcess\n  finalPhotograph : FinalPhotograph\n\n  flow sceneSelection.selectScene.selectedScene -> focusingProcess.performFocusing.scene\n  flow focusingProcess.performFocusing.focusedImage -> shootingProcess.performShooting.image\n  flow shootingProcess.performShooting.photograph -> finalPhotograph.producePhotograph.image\nend PhotographyWorkflowSystem\n\nblock SceneSelection\n  action selectScene\n    output selectedScene : Scene\n  end selectScene\nend SceneSelection\n\nblock FocusingProcess\n  action performFocusing\n    input scene : Scene\n    output focusedImage : Image\n  end performFocusing\nend FocusingProcess\n\nblock ShootingProcess\n  action performShooting\n    input image : Image\n    output photograph : Photograph\n  end performShooting\nend ShootingProcess\n\nblock FinalPhotograph\n  action producePhotograph\n    input image : Image\n    output photograph : Photograph\n  end producePhotograph\nend FinalPhotograph",
    "model AutomatedPhotographySystemModel {\n  block AutomatedPhotographySystem {\n    part focusProcessor: FocusProcessing;\n    part shooter: ShootingOperation;\n    input sceneInput: Scene;\n    output photographOutput: Photograph;\n    \n    connect sceneInput to focusProcessor.sceneInput;\n    connect focusProcessor.focusedImageOutput to shooter.focusedImageInput;\n    connect shooter.photographOutput to photographOutput;\n  }\n  \n  block FocusProcessing {\n    input sceneInput: Scene;\n    output focusedImageOutput: FocusedImage;\n  }\n  \n  block ShootingOperation {\n    input focusedImageInput: FocusedImage;\n    output photographOutput: Photograph;\n  }\n  \n  block User {\n    output sceneOutput: Scene;\n    input photographInput: Photograph;\n  }\n  \n  value type Scene;\n  value type FocusedImage;\n  value type Photograph;\n  \n  connect User.sceneOutput to AutomatedPhotographySystem.sceneInput;\n  connect AutomatedPhotographySystem.photographOutput to User.photographInput;\n}",
    "model PhotographyWorkflow {\n  block Scene {}\n  block Image {}\n  block Picture {}\n\n  activity PhotographyWorkflowActivity {\n    input scene : Scene;\n    output picture : Picture;\n\n    action Focus {\n      input scene : Scene;\n      output image : Image;\n    }\n\n    action Shoot {\n      input image : Image;\n      output picture : Picture;\n    }\n\n    flow Focus.image -> Shoot.image;\n  }\n}",
    "block PhotographySystem {\n  scene : Scene;\n  camera : Camera;\n}\n\nblock User {\n  photographySystem : PhotographySystem;\n  action selectScene : Scene;\n}\n\nblock Camera {\n  action performFocusing : Boolean;\n  action capturePhoto : Image;\n}\n\nactivity PhotographySystem::PhotographyWorkflow {\n  action selectSceneAction : User::selectScene;\n  action performFocusingAction : Camera::performFocusing;\n  action capturePhotoAction : Camera::capturePhoto;\n  action generateFinalImageAction : generateFinalImage;\n\n  controlFlow selectSceneAction -> performFocusingAction;\n  controlFlow performFocusingAction -> checkFocusClarityDecision;\n  controlFlow capturePhotoAction -> generateFinalImageAction;\n\n  decisionNode checkFocusClarityDecision : Boolean;\n  constraint checkFocusClarityDecision = performFocusingAction.output;\n\n  controlFlow checkFocusClarityDecision[true] -> capturePhotoAction;\n  controlFlow checkFocusClarityDecision[false] -> endNode;\n\n  finalNode endNode;\n}",
    "model PhotographySystemModel {\n   value Scene;\n   value FocusedImage;\n   value FocusQuality : Boolean;\n   value Photograph;\n\n   module SceneSelection {\n      port out Scene selectedScene;\n   }\n\n   module FocusingSystem {\n      port in Scene sceneInput;\n      port out FocusedImage focusedImage;\n   }\n\n   module ImageEvaluation {\n      port in FocusedImage imageInput;\n      port out FocusQuality qualityOutput;\n   }\n\n   module ShootingOperation {\n      port in FocusedImage imageInput;\n      port out Photograph photoOutput;\n   }\n\n   module PhotoOutput {\n      port in Photograph photoInput;\n   }\n\n   module PhotographySystem {\n      part sceneSelector : SceneSelection;\n      part focusingSystem : FocusingSystem;\n      part imageEvaluator : ImageEvaluation;\n      part shootingOperation : ShootingOperation;\n      part photoOutput : PhotoOutput;\n\n      sceneSelector.selectedScene -> focusingSystem.sceneInput;\n      focusingSystem.focusedImage -> imageEvaluator.imageInput;\n      shootingOperation.photoOutput -> photoOutput.photoInput;\n\n      behavior workflow : StateMachine {\n         initial transition to SceneSelectionState;\n\n         state SceneSelectionState {\n            on entry : start sceneSelector;\n            on exit : stop sceneSelector;\n            transition to FocusingState on sceneSelector.completed;\n         }\n\n         state FocusingState {\n            on entry : start focusingSystem;\n            on exit : stop focusingSystem;\n            transition to ImageEvaluationState on focusingSystem.completed;\n         }\n\n         state ImageEvaluationState {\n            on entry : start imageEvaluator;\n            on exit : stop imageEvaluator;\n            transition to ShootingOperationState if imageEvaluator.qualityOutput is true;\n            transition to FocusingState if imageEvaluator.qualityOutput is false;\n         }\n\n         state ShootingOperationState {\n            on entry : start shootingOperation;\n            on exit : stop shootingOperation;\n            transition to PhotoOutputState on shootingOperation.completed;\n         }\n\n         state PhotoOutputState {\n            on entry : start photoOutput;\n            on exit : stop photoOutput;\n            transition to final;\n         }\n      }\n   }\n}",
    "module PhotographyWorkflow {\n    block PhotographyWorkflowSystem {\n        part sceneAcquisition : SceneAcquisition;\n        part focusFunction : FocusFunction;\n        part shootingOperation : ShootingOperation;\n        part display : Display;\n\n        behavior takePhoto : TakePhotoBehavior;\n    }\n\n    block SceneAcquisition {\n        flowport outputScene : SceneData;\n    }\n\n    block FocusFunction {\n        flowport inputScene : SceneData;\n        flowport outputImage : FocusedImage;\n    }\n\n    block ShootingOperation {\n        flowport inputImage : FocusedImage;\n        flowport outputPhoto : Photograph;\n    }\n\n    block Display {\n        flowport inputPhoto : Photograph;\n        flowport outputDisplay : DisplayedPhoto;\n    }\n\n    data SceneData;\n    data FocusedImage;\n    data Photograph;\n    data DisplayedPhoto;\n\n    behavior TakePhotoBehavior {\n        step acquireScene : AcquireSceneStep;\n        step performFocus : PerformFocusStep;\n        step executeShoot : ExecuteShootStep;\n        step showPhoto : ShowPhotoStep;\n\n        flow acquireScene.outputScene -> performFocus.inputScene;\n        flow performFocus.outputImage -> executeShoot.inputImage;\n        flow executeShoot.outputPhoto -> showPhoto.inputPhoto;\n    }\n\n    step AcquireSceneStep {\n        action acquireScene : SceneAcquisition::outputScene;\n    }\n\n    step PerformFocusStep {\n        action focus : FocusFunction::outputImage;\n    }\n\n    step ExecuteShootStep {\n        action shoot : ShootingOperation::outputPhoto;\n    }\n\n    step ShowPhotoStep {\n        action display : Display::outputDisplay;\n    }\n}",
    "module AutomaticBrakingSystemModel {\n    block AutomaticBrakingSystem {\n        property keyStatus : VehicleKeyStatus;\n        property brakePedalStatus : BrakePedalStatus;\n        property roadAdhesion : RoadAdhesion;\n        property adjustedBrakePressure : AdjustedBrakePressure;\n        property modulationFrequency : ModulationFrequency;\n        behavior BrakingControlBehavior {\n            parameter keyStatus : VehicleKeyStatus;\n            parameter brakePedalStatus : BrakePedalStatus;\n            parameter roadAdhesion : RoadAdhesion;\n            parameter adjustedBrakePressure : AdjustedBrakePressure;\n            parameter modulationFrequency : ModulationFrequency;\n            body {\n                when (keyStatus.position = 'START') {\n                    loop {\n                        monitorBrakePedal(brakePedalStatus);\n                        monitorRoadAdhesion(roadAdhesion);\n                        if (brakePedalStatus.pressed and roadAdhesion.level < 0.5) {\n                            adjustedBrakePressure := brakePedalStatus.pressure * 0.8;\n                            modulationFrequency := 10 Hz;\n                        } else if (brakePedalStatus.pressed and roadAdhesion.level >= 0.5) {\n                            adjustedBrakePressure := brakePedalStatus.pressure;\n                            modulationFrequency := 5 Hz;\n                        } else {\n                            adjustedBrakePressure := 0;\n                            modulationFrequency := 0;\n                        }\n                        applyBrake(adjustedBrakePressure, modulationFrequency);\n                        wait(100 ms);\n                    }\n                }\n            }\n        }\n    }\n\n    block VehicleKeyStatus {\n        property position : String;\n    }\n\n    block BrakePedalStatus {\n        property pressed : Boolean;\n        property pressure : Real;\n    }\n\n    block RoadAdhesion {\n        property level : Real;\n    }\n\n    block AdjustedBrakePressure {\n        property value : Real;\n    }\n\n    block ModulationFrequency {\n        property value : Real;\n    }\n\n    constraintblock BrakingPerformanceConstraint {\n        inv: adjustedBrakePressure.value <= 1.2 * brakePedalStatus.pressure;\n        inv: modulationFrequency.value between 0 and 20;\n        inv: if roadAdhesion.level < 0.3 then adjustedBrakePressure.value < brakePedalStatus.pressure else adjustedBrakePressure.value = brakePedalStatus.pressure;\n    }\n}",
    "model BatteryChargingSystemModel {  \n  block Battery {  \n    property currentLevel : Float;  \n    property maxLevel : Float;  \n    constraint currentLevelConstraint : currentLevel >= 0 and currentLevel <= maxLevel;  \n  }  \n\n  block Charger {  \n    behavior startCharging() {  \n      action supplyCharge;  \n    }  \n\n    behavior stopCharging() {  \n      action terminateCharge;  \n    }  \n  }  \n\n  block ChargingControlSystem {  \n    part battery : Battery;  \n    part charger : Charger;  \n\n    behavior monitorBatteryLevel() {  \n      action checkLevel : if (battery.currentLevel < battery.maxLevel) then  \n        call charger.startCharging();  \n      else if (battery.currentLevel >= battery.maxLevel) then  \n        call charger.stopCharging();  \n      end if;  \n    }  \n\n    behavior automaticChargingControl() {  \n      action chargeLoop : while (true) do  \n        call monitorBatteryLevel();  \n        delay 1s;  \n      end while;  \n    }  \n\n    behavior chargingTerminationControl() {  \n      action safetyCheck : if (battery.currentLevel >= battery.maxLevel) then  \n        call charger.stopCharging();  \n      end if;  \n    }  \n  }  \n\n  constraint block BatteryLevelConstraint {  \n    parameter batteryLevel : Float;  \n    constraint batteryLevel >= 0 and batteryLevel <= 100%;  \n  }  \n}",
    "module BatteryChargingSystemModel {\n    block Battery {\n        property batteryLevel : Float {subset Range(0.0..100.0)}\n    }\n\n    block ChargingController {\n        stateMachine ChargingControlSM {\n            initial state Initial {\n                transition to: Charging\n            }\n\n            state Charging {\n                do {\n                    action replenishBattery\n                }\n                transition to: Terminated [batteryLevel >= 100.0]\n            }\n\n            state Terminated {\n                entry {\n                    action terminateCharging\n                }\n            }\n        }\n    }\n\n    block BatteryChargingSystem {\n        part battery : Battery\n        part controller : ChargingController\n\n        constraintClause automatedOperation {\n            ensure: \n                battery.batteryLevel < 100.0 implies controller.ChargingControlSM.current == ChargingControlSM::Charging\n                and\n                battery.batteryLevel >= 100.0 implies controller.ChargingControlSM.current == ChargingControlSM::Terminated\n        }\n\n        constraintClause overchargePrevention {\n            ensure: \n                not (battery.batteryLevel > 100.0 and controller.ChargingControlSM.current == ChargingControlSM::Charging)\n        }\n    }\n}",
    "package CameraSystemModel {\n    import SysML.*;\n\n    block CameraSystem {\n        property autofocusSubsys : AutofocusSubsystem;\n        property imagingSubsys : ImagingSubsystem;\n        property photos : Photo[*];\n\n        operation takePhoto(scene : String) : Photo {\n            var focusedImage : Image = autofocusSubsys.focusOnScene(scene);\n            var photo : Photo = imagingSubsys.captureImage(focusedImage);\n            photos.add(photo);\n            return photo;\n        }\n    }\n\n    block AutofocusSubsystem {\n        operation focusOnScene(scene : String) : Image {\n            // Logic to obtain clear and realistic image\n            return new Image();\n        }\n    }\n\n    block ImagingSubsystem {\n        operation captureImage(image : Image) : Photo {\n            // Logic to capture image as photograph\n            return new Photo();\n        }\n    }\n\n    block Photo {\n        property imageData : String;\n    }\n\n    block Image {\n        property data : String;\n    }\n}",
    "model DigitalCameraShootingProcess {  \n  block DigitalCameraSystem {  \n    part sceneSelector : SceneSelectionModule;  \n    part autoFocus : FocusModule;  \n    part imageGenerator : ImagingModule;  \n    part captureModule : ImagingModule;  \n\n    behavior shootProcess : ShootingBehavior;  \n  }  \n\n  block SceneSelectionModule {  \n    input selectedScene : String;  \n  }  \n\n  block FocusModule {  \n    input sceneInfo : String;  \n    output focusStatus : Boolean;  \n  }  \n\n  block ImagingModule {  \n    input focusStatus : Boolean;  \n    input sceneInfo : String;  \n    output generatedImage : Image;  \n    output finalPhoto : Photo;  \n  }  \n\n  block ShootingBehavior {  \n    step selectScene {  \n      input scene : String;  \n      output sceneSelected : Boolean;  \n    }  \n\n    step autoFocus {  \n      input sceneInfo : String;  \n      output focused : Boolean;  \n    }  \n\n    step generateImage {  \n      input focusedStatus : Boolean;  \n      input sceneData : String;  \n      output imageGenerated : Image;  \n    }  \n\n    step captureImage {  \n      input image : Image;  \n      output photoCaptured : Photo;  \n    }  \n  }  \n\n  constraintblock AutomationConstraint {  \n    constraint noManualFocus : FocusModule.focusStatus must be true automatically;  \n    constraint noManualCapture : ImagingModule.finalPhoto must be generated without user intervention;  \n  }  \n\n  constraintblock QualityConstraint {  \n    constraint highQualityOutput : ImagingModule.finalPhoto must satisfy qualityStandard;  \n  }  \n}",
    "module VehicleMotionModel {\n    package root {\n        value type PowerInputSequence {\n            sequence<Real> values;\n        }\n\n        value type OutputTrajectory {\n            sequence<Real> positions;\n        }\n\n        block VehicleSimulation {\n            property mass : Real;\n            property initialPosition : Real;\n            property initialVelocity : Real;\n            property timeInterval : Real;\n            property powerInputs : PowerInputSequence;\n            property outputTrajectory : OutputTrajectory;\n        }\n\n        block VehicleMotionConstraint {\n            parameter power : Real;\n            parameter mass : Real;\n            parameter timeInterval : Real;\n            parameter previousVelocity : Real;\n            parameter previousPosition : Real;\n            parameter currentVelocity : Real;\n            parameter currentPosition : Real;\n            parameter acceleration : Real;\n\n            constraint {\n                acceleration = power / (mass * previousVelocity);\n                currentVelocity = previousVelocity + acceleration * timeInterval;\n                currentPosition = previousPosition + currentVelocity * timeInterval;\n            }\n        }\n\n        block SimulationController {\n            parameter vehicle : VehicleSimulation;\n            parameter step : Integer;\n            parameter trajectory : OutputTrajectory;\n\n            constraint {\n                if (step == 0) {\n                    trajectory.positions[0] = vehicle.initialPosition;\n                } else {\n                    let prevVel = if (step == 1) then vehicle.initialVelocity else trajectory.positions[step-1] - trajectory.positions[step-2] / timeInterval;\n                    let prevPos = trajectory.positions[step-1];\n                    let power = vehicle.powerInputs.values[step-1];\n                    let timeInterval = vehicle.timeInterval;\n                    let mass = vehicle.mass;\n                    let motion = VehicleMotionConstraint {\n                        power = power,\n                        mass = mass,\n                        timeInterval = timeInterval,\n                        previousVelocity = prevVel,\n                        previousPosition = prevPos\n                    };\n                    trajectory.positions[step] = motion.currentPosition;\n                }\n            }\n        }\n    }\n}",
    "model CameraSystemModel {\n  block CameraSystem {\n    sceneInput : SceneInput;\n    focusingProcess : FocusingProcess;\n    imageCapture : ImageCapture;\n    photoDisplay : PhotoDisplay;\n    operation shoot() {\n      scene : Scene = sceneInput.inputScene();\n      image : Image = focusingProcess.focus(scene);\n      photo : Photo = imageCapture.capture(image);\n      photoDisplay.display(photo);\n    }\n  }\n\n  block SceneInput {\n    operation inputScene() : Scene;\n  }\n\n  block FocusingProcess {\n    operation focus(scene : Scene) : Image;\n  }\n\n  block ImageCapture {\n    operation capture(image : Image) : Photo;\n  }\n\n  block PhotoDisplay {\n    operation display(photo : Photo);\n  }\n\n  value type Scene;\n  value type Image;\n  value type Photo;\n}",
    "model CameraProcessingModel {\n  block CameraSystem {\n    port viewPort : ViewPort;\n    port displayPort : DisplayPort;\n    behavior CameraWorkflow;\n  }\n\n  block ViewPort;\n  block DisplayPort;\n\n  activity Focus {\n    input scene : Scene;\n    output image : Image;\n  }\n\n  activity Capture {\n    input image : Image;\n    output picture : Picture;\n  }\n\n  activity Display {\n    input picture : Picture;\n    output displayedPicture : DisplayedPicture;\n  }\n\n  activity CameraWorkflow {\n    input scene : Scene <- viewPort;\n    output displayedPicture : DisplayedPicture -> displayPort;\n\n    step focusStep : Focus;\n    step captureStep : Capture;\n    step displayStep : Display;\n\n    focusStep.scene <- scene;\n    captureStep.image <- focusStep.image;\n    displayStep.picture <- captureStep.picture;\n    displayedPicture <- displayStep.displayedPicture;\n  }\n\n  block Scene;\n  block Image;\n  block Picture;\n  block DisplayedPicture;\n}",
    "package SystemManagement {\n    enumeration SensorStatus {\n        Ready;\n        Updating;\n        Updated;\n    }\n\n    class Sensor {\n        attribute status : SensorStatus;\n        operation update() : Boolean;\n    }\n\n    class SensorManagementSystem {\n        part sensors : Sensor[*];\n        operation monitorSensors();\n        operation updateSensor(sensor : Sensor);\n    }\n\n    behavior monitorSensorsBehavior {\n        ownedParameter: \n            system : SensorManagementSystem;\n        ownedAction:\n            loop for (sensor in system.sensors) {\n                if (sensor.status == SensorStatus.Ready) {\n                    system.updateSensor(sensor);\n                }\n            }\n    }\n\n    behavior updateSensorBehavior {\n        ownedParameter: \n            system : SensorManagementSystem;\n            sensor : Sensor;\n        ownedAction:\n            sensor.status = SensorStatus.Updating;\n            // Perform update operation logic here\n            sensor.status = SensorStatus.Updated;\n    }\n\n    note on SensorManagementSystem::monitorSensors {\n        This operation is automatically executed to traverse and process all registered sensors.\n    }\n}",
    "model VehicleStateControl {\n  package states {\n    state off {\n      initial\n      transition to starting when vehicleStartSignal\n      transition to off when vehicleShutdownSignal\n    }\n    state starting {\n      transition to on when vehiclePowerOnSignal\n      transition to off when vehicleShutdownSignal\n    }\n    state on {\n      transition to off when vehicleShutdownSignal\n    }\n  }\n  package signals {\n    signal vehicleStartSignal\n    signal vehiclePowerOnSignal\n    signal vehicleShutdownSignal\n  }\n  bind states to signals {\n    off.vehicleStartSignal = signals.vehicleStartSignal\n    off.vehicleShutdownSignal = signals.vehicleShutdownSignal\n    starting.vehiclePowerOnSignal = signals.vehiclePowerOnSignal\n    starting.vehicleShutdownSignal = signals.vehicleShutdownSignal\n    on.vehicleShutdownSignal = signals.vehicleShutdownSignal\n  }\n}",
    "model VehicleStateManagementModel\n\n  block VehicleStateManagementSystem\n  end VehicleStateManagementSystem\n\n  signal VehicleStartSignal\n  end VehicleStartSignal\n\n  signal VehicleOnSignal\n  end VehicleOnSignal\n\n  signal VehicleOffSignal\n  end VehicleOffSignal\n\n  stateMachine VehicleStateMachine for VehicleStateManagementSystem\n    initial state initial\n      transition to: off\n    end initial\n\n    state off\n      transition to: starting when VehicleStartSignal\n    end off\n\n    state starting\n      transition to: on when VehicleOnSignal\n    end starting\n\n    state on\n      transition to: off when VehicleOffSignal\n    end on\n\n  end VehicleStateMachine\n\nend VehicleStateManagementModel",
    "model PowerManagementSystem {\n  package pms {\n    signal VehicleStartCommand;\n    signal VehicleStarted;\n    signal VehicleShutdownCommand;\n\n    state machine PowerState {\n      initial state Initial {\n        transition to Off;\n      }\n\n      state Off {\n        entry: cutOffPowerSupply();\n        transition to StartPhase when VehicleStartCommand;\n      }\n\n      state StartPhase {\n        entry: initiateStart();\n        transition to PoweredOn when VehicleStarted;\n      }\n\n      state PoweredOn {\n        entry: supplyPower(); startSelfDiagnosis();\n        do: maintainPowerSupply();\n        transition to Shutdown when VehicleShutdownCommand;\n      }\n\n      state Shutdown {\n        entry: executeSafetyOperations();\n        transition to Off;\n      }\n    }\n  }\n}",
    "package VehicleControlModel {\n  enumeration VehicleStatus {\n    shutdown,\n    startUp,\n    running;\n  }\n\n  signal vehicleStartSignal;\n  signal vehicleStartedSignal;\n  signal vehicleShutdownSignal;\n\n  block VehicleControlBlock {\n    property status : VehicleStatus;\n    ownedBehavior: VehicleControlStateMachine;\n  }\n\n  stateMachine VehicleControlStateMachine {\n    context: VehicleControlBlock;\n    initial: initial {\n      transition to: shutdown;\n    }\n    state shutdown {\n      on entry: status = VehicleStatus::shutdown;\n      transition to: startUp when: vehicleStartSignal;\n    }\n    state startUp {\n      on entry: status = VehicleStatus::startUp;\n      transition to: running when: vehicleStartedSignal;\n    }\n    state running {\n      on entry: status = VehicleStatus::running;\n      transition to: shutdown when: vehicleShutdownSignal;\n    }\n  }\n}",
    "model VehiclePowerManagement {\n  signal StartSignal;\n  signal OnSignal;\n  signal OffSignal;\n\n  block VehiclePowerManagementSystem {\n    part operatingState : OperatingState;\n    part healthState : HealthState;\n  }\n\n  stateMachine OperatingState {\n    initial state Off {\n    }\n    state Start {\n    }\n    state On {\n    }\n    transition Off -> Start when StartSignal;\n    transition Start -> On when OnSignal;\n    transition On -> Off when OffSignal;\n  }\n\n  block HealthState {\n  }\n}",
    "block VehicleHealthMonitoringSystem\n\n  stateMachine healthStatus {\n    initial state initial {\n      transition to: normal\n    }\n\n    state normal {\n      on entry: startMonitoringTemperature()\n      on entry: scheduleNextMaintenance()\n\n      transition to: degraded when: vehicleTemperature > maxAllowableTemperature {\n        action: sendOverTemperatureWarning()\n      }\n\n      transition to: maintenance when: maintenanceTimeReached {\n        action: updateNextCycleTime()\n      }\n    }\n\n    state degraded {\n      on entry: handleDegradedMode()\n\n      transition to: normal when: vehicleTemperature <= maxAllowableTemperature\n    }\n\n    state maintenance {\n      on entry: enterMaintenanceMode()\n\n      transition to: . when: maintenanceCompleted {\n        action: updateNextCycleTime()\n      }\n\n      transition to: normal after: 48h\n    }\n  }\n\nend VehicleHealthMonitoringSystem",
    "block Server {\n  part localClock : Clock;\n  port requestPort : RequestPort;\n}\n\nsignal StartCommand;\nsignal RequestMessage;\n\ninterface RequestPort {\n  receiveStartCommand : StartCommand;\n  receiveRequestMessage : RequestMessage;\n}\n\nblock Clock {\n  property time : Time;\n}\n\nstate machine ServerStateMachine {\n  state off {\n    on entry do {\n    }\n  }\n  state waiting {\n    on entry do {\n    }\n  }\n  state response {\n    on entry do {\n    }\n  }\n\n  initial transition to off;\n\n  transition off -> waiting {\n    trigger requestPort.receiveStartCommand;\n  }\n\n  transition waiting -> response {\n    trigger requestPort.receiveRequestMessage;\n  }\n\n  transition response -> waiting {\n    trigger after (5 min);\n  }\n\n  transition ServerStateMachine -> off {\n    trigger when (self.localClock.time == 11:59:00) every (1 day);\n  }\n}",
    "package VehicleControl {\n  block VehicleControlSystem {\n    stateMachine VehicleState {\n      initial state off {\n        entry / initializeSystem();\n      }\n      state startProcess {\n        entry / initiateStartSequence();\n        do / monitorBrakePedal();\n        transition to: operating [on powerOnSignal when brakeDepressed] {\n          action / sendStartToController();\n        }\n      }\n      state operating {\n        entry / performSelfCheck();\n        entry / supplyPower();\n        exit / applyParkingBrake();\n        transition to: off [on stopSignal] {\n          action / sendStopToController();\n        }\n      }\n    }\n  }\n}",
    "block VehicleControlSystem {\n  property vehicleStartSignal : Boolean;\n  property brakePedalDepressed : Boolean;\n  property vehicleOnSignal : Boolean;\n  property shutdownSignal : Boolean;\n  property startControlSignal : Boolean;\n  property parkingBrakeApplied : Boolean;\n\n  stateMachine VehicleControlStateMachine {\n    initial state Initial {\n      transition to: Off;\n    }\n    state Off {\n      transition to: StartUp when vehicleStartSignal;\n    }\n    state StartUp {\n      transition to: Started when (brakePedalDepressed and vehicleOnSignal) {\n        effect: startControlSignal = true;\n      }\n    }\n    state Started {\n      entry: performSelfCheck();\n      do: supplyPower();\n      transition to: Off when shutdownSignal {\n        effect: parkingBrakeApplied = true;\n      }\n    }\n  }\n}",
    "model CruiseControlSystemModel  \n  block Driver  \n    behavior activateCruiseControl  \n      event SetSpeedCommand(desiredSpeed: Float)  \n      output SetSpeedCommand  \n    end activateCruiseControl  \n  end Driver  \n\n  block CruiseController  \n    property setSpeedCommandPort: in SetSpeedCommand  \n    property actualSpeedPort: in ActualSpeedEvent  \n    property fuelCommandPort: out FuelControlCommand  \n\n    behavior processCommands  \n      event SetSpeedCommand(desiredSpeed: Float)  \n      event ActualSpeedEvent(actualSpeed: Float)  \n      output FuelControlCommand(fuelCommandValue: Float)  \n    end processCommands  \n  end CruiseController  \n\n  block Speedometer  \n    property speedPort: out ActualSpeedEvent  \n\n    behavior collectSpeed  \n      output ActualSpeedEvent(actualSpeed: Float)  \n    end collectSpeed  \n  end Speedometer  \n\n  block Engine  \n    property fuelCommandPort: in FuelControlCommand  \n\n    behavior adjustOutput  \n      event FuelControlCommand(fuelCommandValue: Float)  \n    end adjustOutput  \n  end Engine  \n\n  block Vehicle  \n    property cruiseController: CruiseController  \n    property speedometer: Speedometer  \n    property engine: Engine  \n  end Vehicle  \n\n  signal SetSpeedCommand  \n    parameter desiredSpeed: Float  \n  end SetSpeedCommand  \n\n  signal ActualSpeedEvent  \n    parameter actualSpeed: Float  \n  end ActualSpeedEvent  \n\n  signal FuelControlCommand  \n    parameter fuelCommandValue: Float  \n  end FuelControlCommand  \nend CruiseControlSystemModel",
    "block Driver\n  op sendSetSpeedCommand(speed : Real) : Void\nend\n\nblock CruiseController\n  setSpeed : Real\n  actualSpeed : Real\n  throttleCommand : Real\n  op receiveSetSpeed(speed : Real) : Void\n  op getActualSpeed() : Real\n  op sendThrottleCommand(command : Real) : Void\nend\n\nblock Speedometer\n  op getActualSpeed() : Real\nend\n\nblock EngineSystem\n  op adjustPowerOutput(command : Real) : Void\nend\n\ninteraction CruiseControlInteraction\n  driverInstance : Driver\n  cruiseControllerInstance : CruiseController\n  speedometerInstance : Speedometer\n  engineSystemInstance : EngineSystem\n\n  msg sendSetSpeedCommand from driverInstance to cruiseControllerInstance with speed = 60.0\n  msg receiveSetSpeed from cruiseControllerInstance to cruiseControllerInstance with speed = 60.0\n  msg getActualSpeed from cruiseControllerInstance to speedometerInstance\n  msg getActualSpeed from speedometerInstance to cruiseControllerInstance with speed = 55.0\n  msg sendThrottleCommand from cruiseControllerInstance to engineSystemInstance with command = 0.75\n  msg adjustPowerOutput from engineSystemInstance to engineSystemInstance with command = 0.75\nend",
    "module AutomotiveCruiseControl {\n    block Driver {\n        port setSpeedPort: SetSpeedCommand;\n    }\n\n    block CruiseController {\n        port commandInput: SetSpeedCommand;\n        port speedInput: CurrentSpeed;\n        port throttleOutput: ThrottleControlCommand;\n    }\n\n    block SpeedSensor {\n        port speedOutput: CurrentSpeed;\n    }\n\n    block Engine {\n        port throttleInput: ThrottleControlCommand;\n    }\n\n    block AutomotiveCruiseControlSystem {\n        part driver: Driver;\n        part controller: CruiseController;\n        part sensor: SpeedSensor;\n        part engine: Engine;\n\n        behavior interaction CruiseControlInteraction {\n            message setSpeedMsg: SetSpeedCommand sent from driver.setSpeedPort to controller.commandInput;\n            message getSpeedMsg: CurrentSpeed sent from controller.speedInput to sensor.speedOutput;\n            message throttleMsg: ThrottleControlCommand sent from controller.throttleOutput to engine.throttleInput;\n        }\n    }\n\n    interface SetSpeedCommand {\n        parameter targetSpeed: Real;\n    }\n\n    interface CurrentSpeed {\n        parameter actualSpeed: Real;\n    }\n\n    interface ThrottleControlCommand {\n        parameter throttlePosition: Real;\n    }\n}",
    "model CruiseControlSystemModel\n\n  block CruiseControlSystem\n    part driver : Driver\n    part cruiseController : CruiseController\n    part speedometer : Speedometer\n    part engine : Engine\n  end block\n\n  block Driver\n    action sendSetSpeedCommand : SetSpeedCommand\n  end block\n\n  block CruiseController\n    reference driverRef : Driver\n    reference speedometerRef : Speedometer\n    reference engineRef : Engine\n    behavior controlLogic : Activity\n  end block\n\n  block Speedometer\n    action provideCurrentSpeed : CurrentSpeed\n  end block\n\n  block Engine\n    action applyThrottle : ThrottleInstruction\n  end block\n\n  data SetSpeedCommand\n    value : Double\n  end data\n\n  data CurrentSpeed\n    value : Double\n    timestamp : DateTime\n  end data\n\n  data ThrottleInstruction\n    position : Double\n  end data\n\n  activity ControlLogicActivity\n    ownedBy CruiseController\n    parameter targetSpeed : Double\n    parameter currentSpeed : CurrentSpeed\n    parameter throttleInstruction : ThrottleInstruction\n\n    action receiveSetSpeedCommand\n      input driverCommand : SetSpeedCommand\n      output targetSpeed\n      behavior:\n        targetSpeed = driverCommand.value\n    end action\n\n    action monitorCurrentSpeed\n      output currentSpeed\n      behavior:\n        currentSpeed = speedometerRef.provideCurrentSpeed()\n    end action\n\n    action calculateThrottle\n      input targetSpeed : Double\n      input currentSpeed : CurrentSpeed\n      output throttleInstruction : ThrottleInstruction\n      behavior:\n        let speedError = targetSpeed - currentSpeed.value\n        throttleInstruction.position = adjustThrottleBasedOnError(speedError)\n    end action\n\n    action sendThrottleInstruction\n      input throttleInstruction : ThrottleInstruction\n      behavior:\n        engineRef.applyThrottle(throttleInstruction)\n    end action\n\n    flow:\n      receiveSetSpeedCommand(driverCommand) -> monitorCurrentSpeed()\n      monitorCurrentSpeed() -> calculateThrottle(targetSpeed, currentSpeed)\n      calculateThrottle() -> sendThrottleInstruction(throttleInstruction)\n  end activity\n\n  stateMachine CruiseControlStateMachine\n    ownedBy CruiseControlSystem\n    state Idle\n      on entry:\n        cruiseController.controlLogic.targetSpeed = 0.0\n    end state\n\n    state Active\n      on entry:\n        cruiseController.controlLogic.targetSpeed = driver.sendSetSpeedCommand.value\n    end state\n\n    state Adjusting\n      on entry:\n        cruiseController.controlLogic.calculateThrottle()\n    end state\n\n    transition Idle -> Active\n      event setSpeedCommandReceived\n    end transition\n\n    transition Active -> Adjusting\n      event speedAdjustmentNeeded\n    end transition\n\n    transition Adjusting -> Active\n      event speedStabilized\n    end transition\n  end stateMachine\n\n  package Requirements\n    requirement PromptCommandTransmission\n      subject: CruiseControlSystem\n      text: \"The system shall promptly collect and transmit the driver's speed setting request to the cruise controller.\"\n    end requirement\n\n    requirement RealTimeSpeedFeedback\n      subject: Speedometer\n      text: \"The speedometer shall provide real-time vehicle speed feedback to the cruise controller.\"\n    end requirement\n\n    requirement IntelligentThrottleAdjustment\n      subject: CruiseController\n      text: \"The cruise controller shall calculate and send throttle instructions to the engine to maintain the preset speed with accuracy and smoothness.\"\n    end requirement\n\n    requirement DriverConvenience\n      subject: CruiseControlSystem\n      text: \"The system shall ensure driver convenience and comfort during operation.\"\n    end requirement\n  end package\n\n  constraint ConstraintThrottleSmoothness\n    appliesTo: ThrottleInstruction\n    text: \"Throttle position changes shall be smooth and gradual to ensure driver comfort.\"\n  end constraint\n\n  constraint ConstraintSpeedAccuracy\n    appliesTo: CruiseController\n    text: \"The cruise controller shall maintain the vehicle speed within ±2% of the preset value under normal driving conditions.\"\n  end constraint\n\nend model",
    "module CruiseControlModel {\n  data SetSpeedCommand {\n    value : Float;\n  }\n\n  data ActualSpeed {\n    value : Float;\n  }\n\n  data FuelControlCommand {\n    percentage : Float;\n  }\n\n  block CruiseControlInterface {\n    port setSpeedOutput : SetSpeedCommand;\n  }\n\n  block CruiseController {\n    port setSpeedInput : SetSpeedCommand;\n    port actualSpeedInput : ActualSpeed;\n    port fuelControlOutput : FuelControlCommand;\n    behavior controlLogic {\n      input setSpeed : SetSpeedCommand;\n      input actualSpeed : ActualSpeed;\n      output fuelControl : FuelControlCommand;\n    }\n  }\n\n  block SpeedSensor {\n    port speedOutput : ActualSpeed;\n  }\n\n  block Engine {\n    port fuelControlInput : FuelControlCommand;\n  }\n\n  block CruiseControlSystem {\n    part interface : CruiseControlInterface;\n    part controller : CruiseController;\n    part sensor : SpeedSensor;\n    part engine : Engine;\n\n    flow interface.setSpeedOutput -> controller.setSpeedInput;\n    flow sensor.speedOutput -> controller.actualSpeedInput;\n    flow controller.fuelControlOutput -> engine.fuelControlInput;\n  }\n}",
    "block CruiseControlSystem\n  part cruiseController : CruiseController\n  part speedSensor : SpeedSensor\n  part engineController : EngineController\n  part engine : Engine\n\n  cruiseController.setSpeedCommandPort -> speedSensor.speedReadingPort : SetSpeedCommandMessage\n  speedSensor.speedReadingPort -> cruiseController.speedReadingPort : SpeedReadingMessage\n  cruiseController.fuelControlCommandPort -> engineController.fuelControlCommandPort : FuelControlCommandMessage\n  engineController.fuelControlCommandPort -> engine.fuelControlPort : FuelControlCommandMessage\nend\n\nblock CruiseController\n  in port setSpeedCommandPort : SetSpeedCommandMessage\n  out port speedReadingPort : SpeedReadingMessage\n  out port fuelControlCommandPort : FuelControlCommandMessage\nend\n\nblock SpeedSensor\n  in port speedReadingPort : SpeedReadingMessage\n  out port speedDataPort : SpeedReadingMessage\nend\n\nblock EngineController\n  in port fuelControlCommandPort : FuelControlCommandMessage\n  out port fuelControlCommandPort : FuelControlCommandMessage\nend\n\nblock Engine\n  in port fuelControlPort : FuelControlCommandMessage\nend\n\nmessage SetSpeedCommandMessage\nend\n\nmessage SpeedReadingMessage\nend\n\nmessage FuelControlCommandMessage\nend",
    "value Date {\n  property day : Integer;\n  property month : Integer;\n  property year : Integer;\n}\n\nenum ScrappingType {\n  Scrapping,\n  DeRegistration\n}\n\nblock Owner {\n  property name : String;\n  property contactInfo : String;\n}\n\nblock Driver {\n  property name : String;\n  property licenseNumber : String;\n}\n\nblock Delivery {\n  property date : Date;\n}\n\nblock DrivingOperation {\n  property date : Date;\n  part driver : Driver;\n}\n\nblock Ownership {\n  property startDate : Date;\n  property endDate : Date;\n  part owner : Owner;\n  part drivingOperations[*] : DrivingOperation;\n}\n\nblock Scrapping {\n  property date : Date;\n  property type : ScrappingType;\n}\n\nblock Vehicle {\n  part delivery : Delivery;\n  part ownership[*] : Ownership;\n  part scrapping : Scrapping[0..1];\n}",
    "module OperationalStatus {  \n  gearSetting: String  \n  acceleratorPedalPosition: Float  \n}  \n\nmodule Wheel {  \n  position: String  \n}  \n\nmodule Engine {  \n  // No attributes specified  \n}  \n\nmodule Driver {  \n  // No attributes specified (external reference)  \n}  \n\nmodule Vehicle {  \n  mass: Float  \n  operationalStatus: OperationalStatus  \n  engine: Engine  \n  driver: Driver @ ref  \n  wheels: [4] Wheel  \n}  \n\ninstance vehicle_1: Vehicle = {  \n  mass: 1500.0  \n  operationalStatus: {  \n    gearSetting: \"Drive\"  \n    acceleratorPedalPosition: 0.5  \n  }  \n  engine: Engine = {}  \n  driver: Driver @ ref  \n  wheels: [4] Wheel = {  \n    leftFrontWheel: Wheel @ 0s {  \n      position: \"Left Front\"  \n    }  \n    rightFrontWheel: Wheel @ 1s {  \n      position: \"Right Front\"  \n    }  \n  }  \n}",
    "module CompositeVehicleModel {\n  block Vehicle {\n    property mass : Float;\n    property state : VehicleState;\n    part engine : Engine;\n    part driver : Driver;\n  }\n\n  block VehicleState {\n    property gear : Integer;\n    property acceleratorPosition : Float;\n  }\n\n  block Engine {\n  }\n\n  block Driver {\n  }\n\n  instanceSpecification Vehicle_1 : Vehicle {\n    mass = 2000.0;\n    state : VehicleState {\n      gear = 0;\n      acceleratorPosition = 0.0;\n    };\n    engine : Engine;\n    driver : Driver;\n    stateMachine {\n      state InitialState {\n        mass = 2000.0;\n        state.gear = 0;\n        state.acceleratorPosition = 0.0;\n      }\n      state NextState {\n        mass = 1500.0;\n        state.gear = 2;\n        state.acceleratorPosition = 0.5;\n      }\n      transition InitialState -> NextState;\n    }\n  }\n}",
    "model VehicleModel {\n  class Vehicle {\n    property mass : Number;\n    property gear : GearPosition;\n    property throttlePedalPosition : Number;\n    property engine : Engine;\n    property driver : Driver;\n  }\n\n  class Driver {}\n  instance Alice : Driver;\n  instance Bob : Driver;\n\n  class Engine {}\n\n  enumeration GearPosition {\n    Neutral;\n    First;\n    Second;\n  }\n\n  vehicleStateMachine: StateMachine for Vehicle {\n    initial: State {\n      do: {\n        mass = 2000;\n        gear = Neutral;\n        throttlePedalPosition = 0;\n        driver = Alice;\n      }\n    }\n\n    timeSlice2: State {\n      do: {\n        mass = 1500;\n        gear = Second;\n        throttlePedalPosition = 0.5;\n        driver = Bob;\n      }\n    }\n\n    transition from initial to timeSlice2 {\n      when: (timeElapsed > 0);\n    }\n  }\n}",
    "package VehicleMassModel {\n  value type MassValueType {\n    unit: kg;\n  }\n\n  block Component {\n    property mass : MassValueType;\n  }\n\n  block SimpleComponent {\n    extends Component;\n    property mass : MassValueType;\n  }\n\n  block CompositeComponent {\n    extends Component;\n    property mass : MassValueType { derived; formula: self.baseMass + sum(self.parts.mass) }\n    property baseMass : MassValueType;\n    property parts : Component[*] { isComposite: true; }\n  }\n\n  block Vehicle {\n    extends CompositeComponent;\n    baseMass: 0 kg;\n    property engine : Engine;\n    property transmission : Transmission;\n    property body : Body;\n  }\n\n  block Engine {\n    extends SimpleComponent;\n    mass: 150 kg;\n  }\n\n  block Transmission {\n    extends SimpleComponent;\n    mass: 100 kg;\n  }\n\n  block Body {\n    extends CompositeComponent;\n    baseMass: 200 kg;\n    property doors : Door[2];\n    property frame : Frame;\n  }\n\n  block Door {\n    extends SimpleComponent;\n    mass: 20 kg;\n  }\n\n  block Frame {\n    extends SimpleComponent;\n    mass: 180 kg;\n  }\n}",
    "block Component {\n  serialNumber : String [1..1];\n  mass : Float [1..1];\n  parts : Component [*..*];\n  totalMass : Float [1..1] = self.mass + sum(self.parts.totalMass);\n}\n\nblock Vehicle specializes Component {\n  vin : String [1..1];\n  threshold : Float [1..1];\n  redef totalMass : Float [1..1] = self.mass + sum(self.parts->filter(c | c.mass >= self.threshold).totalMass);\n}\n\nconstraintBlock UniqueSerialNumber {\n  context Component;\n  inv: Component.allInstances()->forAll(c1, c2 | c1 <> c2 implies c1.serialNumber <> c2.serialNumber);\n}\n\nconstraintBlock UniqueVIN {\n  context Vehicle;\n  inv: Vehicle.allInstances()->forAll(v1, v2 | v1 <> v2 implies v1.vin <> v2.vin);\n}",
    "model MassAggregation {\n  unit Mass = kg;\n\n  class MassThing {\n    property simpleMass : Mass;\n    property totalMass : Mass;\n  }\n\n  class SimpleThing extends MassThing {\n    derive totalMass = simpleMass;\n  }\n\n  class CompositeThing extends MassThing {\n    part parts[*] : MassThing;\n    derive totalMass = simpleMass + sum(parts.totalMass);\n  }\n}",
    "model MassAggregationSystem {\n    class Object {\n        basicMass : Mass;\n        function calculateTotalMass() : Mass {\n            return basicMass;\n        }\n        function calculateFilteredTotalMass(threshold : Mass) : Mass {\n            if (basicMass >= threshold) then\n                return basicMass;\n            else\n                return 0;\n            endif\n        }\n    }\n\n    class CompositeObject : Object {\n        subcomponents : Object[*];\n        redefines function calculateTotalMass() : Mass {\n            return basicMass + sum(subcomponents.calculateTotalMass());\n        }\n        redefines function calculateFilteredTotalMass(threshold : Mass) : Mass {\n            return basicMass + sum(subcomponents.calculateFilteredTotalMass(threshold));\n        }\n    }\n}",
    "value DragCoefficient = Real\nvalue FrictionCoefficient = Real\nvalue Mass = Real\nvalue Speed = Real\nvalue Acceleration = Real\nvalue Position = Real\nvalue Power = Real\nvalue AirDensity = Real\nvalue FrontalArea = Real\nvalue Gravity = Real\nvalue Time = Real\n\nblock VehicleDynamicsSystem\n  wheelPower : Power\n  dragCoefficient : DragCoefficient\n  frictionCoefficient : FrictionCoefficient\n  mass : Mass\n  speed : Speed\n  acceleration : Acceleration\n  position : Position\n  airDensity : AirDensity\n  frontalArea : FrontalArea\n  gravity : Gravity\n  initialSpeed : Speed\n  initialPosition : Position\n  time : Time\nend VehicleDynamicsSystem\n\n«constraint» EffectivePowerConstraint\n  context VehicleDynamicsSystem\n  let F_drag : Real = 0.5 * dragCoefficient * airDensity * frontalArea * speed^2\n  let P_drag : Real = F_drag * speed\n  let F_friction : Real = frictionCoefficient * mass * gravity\n  let P_friction : Real = F_friction * speed\n  effectivePower = wheelPower - P_drag - P_friction\nend EffectivePowerConstraint\n\n«constraint» AccelerationConstraint\n  context VehicleDynamicsSystem\n  acceleration = effectivePower / (mass * speed) - (F_drag + F_friction) / mass\nend AccelerationConstraint\n\n«constraint» SpeedConstraint\n  context VehicleDynamicsSystem\n  speed = initialSpeed + acceleration * time\nend SpeedConstraint\n\n«constraint» PositionConstraint\n  context VehicleDynamicsSystem\n  position = initialPosition + initialSpeed * time + 0.5 * acceleration * time^2\nend PositionConstraint",
    "block VehicleDynamicsSimulation {\n  wheelEndOutputPower : Real;\n  totalVehicleMass : Real;\n  aerodynamicDragCoefficient : Real;\n  rollingResistanceCoefficient : Real;\n  gravity : Real = 9.81;\n}\n\nbehavior simulateStraightLineDriving {\n  input initialSpeed : Real;\n  input initialPosition : Real;\n  input timeStep : Time;\n\n  output newSpeed : Real;\n  output newPosition : Real;\n\n  currentSpeed : Real = initialSpeed;\n  currentPosition : Real = initialPosition;\n\n  aeroDragForce : Real = aerodynamicDragCoefficient * currentSpeed^2;\n  rollingForce : Real = rollingResistanceCoefficient * totalVehicleMass * gravity;\n  netForce : Real = (wheelEndOutputPower / currentSpeed) - (aeroDragForce + rollingForce);\n  acceleration : Real = netForce / totalVehicleMass;\n  newSpeed = currentSpeed + acceleration * timeStep;\n  newPosition = currentPosition + currentSpeed * timeStep;\n}",
    "block VehicleDrivingDynamicsSystem {\n  property vehicleMass : Real;\n  property wheelPower : Real;\n  property aerodynamicDragCoefficient : Real;\n  property rollingResistanceCoefficient : Real;\n  property initialSpeed : Real;\n  property initialPosition : Real;\n  property speed : Real;\n  property position : Real;\n  property acceleration : Real;\n  property displacement : Real;\n\n  constraint c1 : VehicleDynamicsConstraint {\n    vehicleMass <- self.vehicleMass;\n    wheelPower <- self.wheelPower;\n    aerodynamicDragCoefficient <- self.aerodynamicDragCoefficient;\n    rollingResistanceCoefficient <- self.rollingResistanceCoefficient;\n    initialSpeed <- self.initialSpeed;\n    initialPosition <- self.initialPosition;\n    speed <- self.speed;\n    position <- self.position;\n    acceleration <- self.acceleration;\n    displacement <- self.displacement;\n  }\n}\n\nconstraint block VehicleDynamicsConstraint {\n  parameter vehicleMass : Real;\n  parameter wheelPower : Real;\n  parameter aerodynamicDragCoefficient : Real;\n  parameter rollingResistanceCoefficient : Real;\n  parameter initialSpeed : Real;\n  parameter initialPosition : Real;\n  parameter speed : Real;\n  parameter position : Real;\n  parameter acceleration : Real;\n  parameter time : Real;\n  parameter displacement : Real;\n\n  equation\n    acceleration = (wheelPower / speed) / vehicleMass - (aerodynamicDragCoefficient * speed^2) / vehicleMass - rollingResistanceCoefficient * 9.81;\n    speed = initialSpeed + integral(acceleration, time);\n    position = initialPosition + integral(speed, time);\n    displacement = position - initialPosition;\n}",
    "module VehicleDynamicSystemModel {\n    block VehicleDynamicSystem {\n        property initialPosition : Length;\n        property initialVelocity : Velocity;\n        property mass : Mass;\n        property drivePower : Power;\n        property timeInterval : Time;\n        property dragCoefficient : Dimensionless;\n        property frictionCoefficient : Dimensionless;\n        property airDensity : Density;\n        property frontalArea : Area;\n        property acceleration : Acceleration;\n        property finalVelocity : Velocity;\n        property finalPosition : Length;\n    }\n\n    constraintBlock LongitudinalDynamicConstraint {\n        import VehicleDynamicSystem.*;\n        constrainedValues {\n            driveForce = drivePower / initialVelocity;\n            airResistance = 0.5 * dragCoefficient * airDensity * frontalArea * initialVelocity^2;\n            frictionForce = frictionCoefficient * mass * 9.81;\n            netForce = driveForce - airResistance - frictionForce;\n            acceleration = netForce / mass;\n            finalVelocity = initialVelocity + acceleration * timeInterval;\n            finalPosition = initialPosition + initialVelocity * timeInterval + 0.5 * acceleration * timeInterval^2;\n        }\n    }\n}",
    "model VehicleMassManagement {\n  block Chassis {\n    property mass : Real;\n  }\n\n  block Engine {\n    property mass : Real;\n  }\n\n  block Gearbox {\n    property mass : Real;\n  }\n\n  block Vehicle {\n    part chassis : Chassis;\n    part engine : Engine;\n    part gearbox : Gearbox;\n    property totalMass : Real;\n  }\n\n  constraint TotalMassConstraint {\n    parameter chassisMass : Real = chassis.mass;\n    parameter engineMass : Real = engine.mass;\n    parameter gearboxMass : Real = gearbox.mass;\n    parameter totalMass : Real = chassisMass + engineMass + gearboxMass;\n  }\n\n  constraint OverweightWarningConstraint {\n    parameter totalMass : Real;\n    parameter warning : Boolean = if totalMass > 2500 then true else false;\n  }\n\n  requirement MaxVehicleMassRequirement {\n    parameter maxMass : Real = 2500;\n    parameter warning : Boolean;\n    condition: totalMass <= maxMass or warning;\n  }\n}",
    "model VehicleMassConstraint {\n  package VehicleSystem {\n    block Vehicle {\n      part chassis : Chassis;\n      part engine : Engine;\n      part transmission : Transmission;\n      property totalMass : Real {\n        derived;\n        unit kg;\n        formula totalMass = chassis.mass + engine.mass + transmission.mass;\n      }\n    }\n\n    block Chassis {\n      property mass : Real {\n        unit kg;\n      }\n    }\n\n    block Engine {\n      property mass : Real {\n        unit kg;\n      }\n    }\n\n    block Transmission {\n      property mass : Real {\n        unit kg;\n      }\n    }\n\n    constraint block MaxVehicleMassConstraint {\n      param vehicle : Vehicle;\n      constraint vehicle.totalMass <= 2500.0 kg;\n    }\n\n    requirement block VehicleMassRequirement {\n      constraint MaxVehicleMassConstraint;\n    }\n  }\n}",
    "value type MassType = Float;\n\nblock Chassis\n  property mass : MassType;\nend Chassis;\n\nblock Engine\n  property mass : MassType;\nend Engine;\n\nblock Transmission\n  property mass : MassType;\nend Transmission;\n\nblock Vehicle\n  property chassis : Chassis;\n  property engine : Engine;\n  property transmission : Transmission;\nend Vehicle;\n\nconstraint block VehicleMassConstraint\n  parameter chassisMass : MassType = self.chassis.mass;\n  parameter engineMass : MassType = self.engine.mass;\n  parameter transmissionMass : MassType = self.transmission.mass;\n  parameter totalMass : MassType = chassisMass + engineMass + transmissionMass;\n  constraint totalMass <= 2500.0;\nend VehicleMassConstraint;",
    "module VehicleWeightManagement {\n    block Chassis {\n        property weight : Real {unit = 'kg'};\n    }\n\n    block Engine {\n        property weight : Real {unit = 'kg'};\n    }\n\n    block Transmission {\n        property weight : Real {unit = 'kg'};\n    }\n\n    block VehicleSystem {\n        part chassis : Chassis;\n        part engine : Engine;\n        part transmission : Transmission;\n        property totalWeight : Real = chassis.weight + engine.weight + transmission.weight {unit = 'kg'};\n        constraint totalWeightConstraint : totalWeight <= 2500.0;\n    }\n\n    constraintBlock TotalWeightConstraint {\n        context VehicleSystem;\n        constraint totalWeightConstraint : self.totalWeight <= 2500.0\n            message 'Total weight of chassis, engine, and transmission exceeds regulatory limit of 2,500 kg. Design adjustments required for compliance.';\n    }\n}",
    "module VehicleModel {\n    block Chassis {\n        property mass : Real;\n    }\n\n    block Engine {\n        property mass : Real;\n    }\n\n    block Transmission {\n        property mass : Real;\n    }\n\n    block Vehicle {\n        parts {\n            chassis : Chassis;\n            engine : Engine;\n            transmission : Transmission;\n        }\n        property totalMass : Real = chassis.mass + engine.mass + transmission.mass;\n    }\n\n    constraintBlock TotalMassConstraint {\n        property totalMass : Real;\n        constraint totalMass <= 2500;\n    }\n\n    constraintBlock DynamicConstraint {\n        property initialVelocity : Real;\n        property finalVelocity : Real;\n        property mass : Real;\n        property appliedForce : Real;\n        property time : Real;\n        constraint mass > 0;\n        constraint appliedForce = mass * (finalVelocity - initialVelocity) / time;\n    }\n\n    vehicle : Vehicle;\n    apply TotalMassConstraint to vehicle {\n        bind totalMass to vehicle.totalMass;\n    }\n    apply DynamicConstraint to vehicle {\n        bind initialVelocity to vehicle.initialVelocity;\n        bind finalVelocity to vehicle.finalVelocity;\n        bind mass to vehicle.totalMass;\n        bind appliedForce to vehicle.appliedForce;\n        bind time to vehicle.time;\n    }\n}",
    "module MaintenanceManagement {\n    import Temporal::TemporalValue;\n    import Temporal::Duration;\n    import Temporal::Time;\n    import Temporal::TemporalConstraint;\n    import Temporal::DurationConstraint;\n    import SysML::StructuredClassifiers::ValueSpecification;\n\n    enumeration HealthStatus {\n        Healthy,\n        UnderMaintenance\n    }\n\n    block Vehicle {\n        property nextMaintenanceTime : TemporalValue;\n        property maintenanceInterval : Duration;\n        property maxTemperature : Temperature;\n        property status : HealthStatus;\n        property actualMaintenanceStartTime : TemporalValue;\n    }\n\n    constraintblock MaintenanceStartConstraint {\n        parameter scheduledTime : TemporalValue;\n        parameter actualStart : TemporalValue;\n        constraint actualStart > scheduledTime;\n    }\n\n    constraintblock MaintenanceTimingConstraint {\n        parameter healthyEnd : TemporalValue;\n        parameter maintenanceStart : TemporalValue;\n        constraint (maintenanceStart - healthyEnd) <= 2s;\n    }\n\n    constraintblock MaintenanceDurationConstraint {\n        parameter start : TemporalValue;\n        parameter end : TemporalValue;\n        constraint (end - start) <= 48h;\n    }\n\n    constraintblock MaintenanceIntervalConstraint {\n        parameter currentNextMaintenance : TemporalValue;\n        parameter interval : Duration;\n        parameter newNextMaintenance : TemporalValue;\n        constraint newNextMaintenance = currentNextMaintenance + interval;\n    }\n\n    constraintblock HealthStatusConstraint {\n        parameter status : HealthStatus;\n        constraint status = HealthStatus::Healthy;\n    }\n\n    stateMachine VehicleStateMachine {\n        state Healthy {\n            exit when (Time.now >= Vehicle.nextMaintenanceTime);\n            on exit {\n                Vehicle.status = HealthStatus::UnderMaintenance;\n            }\n        }\n\n        state UnderMaintenance {\n            entry when (Vehicle.status = HealthStatus::UnderMaintenance);\n            entry {\n                MaintenanceStartConstraint::actualStart = Vehicle.actualMaintenanceStartTime;\n                MaintenanceTimingConstraint::healthyEnd = Time.previousStateEndTime;\n                MaintenanceTimingConstraint::maintenanceStart = Vehicle.actualMaintenanceStartTime;\n                MaintenanceDurationConstraint::start = Vehicle.actualMaintenanceStartTime;\n                MaintenanceDurationConstraint::end = Time.now;\n            }\n\n            exit when (Time.now - Vehicle.actualMaintenanceStartTime >= maintenanceInterval);\n            on exit {\n                Vehicle.status = HealthStatus::Healthy;\n                MaintenanceIntervalConstraint::currentNextMaintenance = Vehicle.nextMaintenanceTime;\n                MaintenanceIntervalConstraint::interval = Vehicle.maintenanceInterval;\n                MaintenanceIntervalConstraint::newNextMaintenance = Vehicle.nextMaintenanceTime;\n                HealthStatusConstraint::status = Vehicle.status;\n            }\n        }\n    }\n\n    value 2Seconds : ValueSpecification {\n        value = 2s;\n    }\n\n    value 48Hours : ValueSpecification {\n        value = 48h;\n    }\n}",
    "module VehicleModel {\n    block Vehicle {\n        parts: \n            engine : Engine;\n            transmission : Transmission;\n            clutch : Clutch;\n        properties:\n            curbWeight : Real;\n            fuelMass : Real;\n            totalMass : Real;\n        constraints:\n            totalMass = curbWeight + fuelMass;\n            totalMass <= maxMass;\n            fuelMass > 0;\n    }\n\n    block Engine {\n        ports:\n            outputTorque : Clutch;\n        properties:\n            speed : Real;\n            torque : Real;\n        constraints:\n            torque = f(speed); // Torque as a function of speed per curve\n    }\n\n    block Transmission {\n        ports:\n            inputTorque : Clutch;\n        properties:\n            receivedTorque : Real;\n        constraints:\n            receivedTorque = inputTorque.torque;\n    }\n\n    flow Clutch {\n        properties:\n            torque : Real;\n    }\n\n    constraint maxMass {\n        value: Real;\n    }\n}",
    "module VehicleMassControl {\n  type Mass = Real;\n  type Torque = Real;\n  type Speed = Real;\n\n  block Vehicle {\n    property dryMass : Mass;\n    property fuelMass : Mass;\n  }\n\n  block Engine {\n    property torqueOutput : Torque;\n    port enginePort : ClutchInterface;\n  }\n\n  block Transmission {\n    port transmissionPort : ClutchInterface;\n  }\n\n  interface ClutchInterface {\n    property torque : Torque;\n  }\n\n  constraint FullFuelMassConstraint {\n    let totalMass = self.dryMass + self.fuelMass;\n    totalMass <= 2000;\n  }\n\n  constraint EmptyFuelMassConstraint {\n    let totalMass = self.dryMass + self.fuelMass;\n    totalMass <= 1500;\n  }\n\n  constraint TorqueTransmissionConstraint {\n    self.enginePort.torque = self.torqueOutput;\n  }\n\n  constraint SpeedTorqueCurveConstraint {\n    self.torqueOutput = lookupTable(self.engineSpeed, Table1);\n  }\n\n  apply FullFuelMassConstraint to Vehicle;\n  apply EmptyFuelMassConstraint to Vehicle;\n  apply TorqueTransmissionConstraint to Engine;\n  apply SpeedTorqueCurveConstraint to Engine;\n\n  table Table1 {\n    engineSpeed : Speed;\n    torque : Torque;\n  }\n}",
    "package VehicleSystemModel {\n  block Vehicle {\n    property emptyMass : Mass;\n    property fueledMass : Mass;\n    constraint c1 : MassConstraint;\n  }\n\n  block Engine {\n    property generatedTorque : Torque;\n    property speed : Speed;\n    port clutchOut : ClutchInterface;\n    constraint c2 : TorqueSpeedConstraint;\n  }\n\n  block ClutchInterface {\n    port torqueIn : Torque;\n    port torqueOut : Torque;\n  }\n\n  block TransmissionSystem {\n    port clutchIn : ClutchInterface;\n  }\n\n  constraint block MassConstraint {\n    constraint emptyMass <= 1500 kg;\n    constraint fueledMass <= 2000 kg;\n  }\n\n  constraint block TorqueSpeedConstraint {\n    constraint generatedTorque = f(speed) [note: \"Torque must vary with speed according to performance table specifications\"];\n  }\n\n  flow Torque {\n    unit Nm;\n  }\n\n  flow Speed {\n    unit rpm;\n  }\n\n  flow Mass {\n    unit kg;\n  }\n\n  vehicle : Vehicle;\n  engine : Engine;\n  transmission : TransmissionSystem;\n\n  vehicle.fueledMass = 2000 kg;\n  vehicle.emptyMass = 1500 kg;\n\n  engine.clutchOut->transmission.clutchIn;\n}",
    "package MyModel {\n  block Vehicle {\n    property curbMass : Mass;\n    property fuelMass : Mass;\n  }\n\n  block Engine {\n    property torque : Torque;\n    property speed : Speed;\n  }\n\n  block Clutch {\n    port inputTorque : Torque;\n    port outputTorque : Torque;\n  }\n\n  block Gearbox {\n    port inputTorque : Torque;\n  }\n\n  constraint FullTankMassConstraint {\n    parameters:\n      curbMass : Mass;\n      fuelMass : Mass;\n    expression:\n      curbMass + fuelMass <= 2000 kg;\n  }\n\n  constraint EmptyTankMassConstraint {\n    parameters:\n      curbMass : Mass;\n      fuelMass : Mass;\n    expression:\n      curbMass + fuelMass <= 1500 kg;\n  }\n\n  constraint EngineTorqueConstraint {\n    parameters:\n      speed : Speed;\n      torque : Torque;\n    expression:\n      torque = f(speed); // Torque characteristics as a function of speed\n  }\n\n  constraint ClutchTorqueTransmissionConstraint {\n    parameters:\n      inputTorque : Torque;\n      outputTorque : Torque;\n    expression:\n      inputTorque = outputTorque;\n  }\n}",
    "package VehicleDynamicAnalysisSystem {\n  value type CurbWeight : Real;\n  value type Payload : Real;\n  value type WheelDiameter : Real;\n  value type TransmissionEfficiency : Real;\n  value type FuelEconomyUrban : Real;\n  value type FuelEconomyHighway : Real;\n  value type TimeStamp : Real;\n  value type Position : Real;\n  value type Speed : Real;\n  value type Power : Real;\n  value type Acceleration : Real;\n  value type FuelEconomyTarget : Real;\n\n  block Vehicle {\n    property curbWeight : CurbWeight;\n    property payload : Payload;\n    property wheelDiameter : WheelDiameter;\n    property transmissionEfficiency : TransmissionEfficiency;\n    property fuelEconomyUrban : FuelEconomyUrban;\n    property fuelEconomyHighway : FuelEconomyHighway;\n  }\n\n  block DrivingCycle {\n    property timeStamps : Sequence<TimeStamp>;\n    property positions : Sequence<Position>;\n    property speeds : Sequence<Speed>;\n  }\n\n  block PerformanceAnalyzer {\n    property vehicle : Reference<Vehicle>;\n    property drivingCycle : Reference<DrivingCycle>;\n    property requiredEnginePower : Power;\n    property accelerationProfile : Sequence<Acceleration>;\n    property fuelEconomy : FuelEconomyUrban;\n    property complianceStatus : Boolean;\n\n    operation calculateRequiredEnginePower() : Power {\n      // Calculation logic based on vehicle mass, acceleration, and efficiency\n    }\n\n    operation calculateAccelerationProfile() : Sequence<Acceleration> {\n      // Derive acceleration from speed and position data over time\n    }\n\n    operation calculateFuelEconomy() : FuelEconomyUrban {\n      // Compute fuel economy using driving cycle and vehicle parameters\n    }\n\n    constraint FuelEconomyConstraint {\n      check(calculateFuelEconomy() >= FuelEconomyTarget);\n    }\n  }\n\n  block VehicleDynamicAnalysisSystem {\n    property vehicle : Vehicle;\n    property drivingCycle : DrivingCycle;\n    property analyzer : PerformanceAnalyzer;\n\n    dependency analyzer.vehicle <- vehicle;\n    dependency analyzer.drivingCycle <- drivingCycle;\n    satisfy analyzer.FuelEconomyConstraint <- drivingCycle;\n  }\n}",
    "package FuelEconomySimulation {\n\n  block Vehicle {\n    property curbWeight : Real {unit = 'kg'};\n    property load : Real {unit = 'kg'};\n    property wheelDiameter : Real {unit = 'm'};\n    property transmissionEfficiency : Real {unit = '%'};\n  }\n\n  block DrivingScenario {\n    property speedProfile : Real {unit = 'km/h'};\n    property roadType : String;\n    property duration : Real {unit = 's'};\n  }\n\n  block SimulationAnalysis {\n    part vehicle : Vehicle;\n    part drivingScenario : DrivingScenario;\n    part wheelPowerCalculator : WheelPowerCalculator;\n    part vehicleDynamicsAnalyzer : VehicleDynamicsAnalyzer;\n    part enginePowerEstimator : EnginePowerEstimator;\n    part fuelConsumptionCalculator : FuelConsumptionCalculator;\n    property fuelEconomy : Real {unit = 'L/100km'};\n  }\n\n  block WheelPowerCalculator {\n    property wheelPower : Real {unit = 'kW'};\n  }\n\n  block VehicleDynamicsAnalyzer {\n    property acceleration : Real {unit = 'm/s^2'};\n    property energyConsumption : Real {unit = 'kWh'};\n  }\n\n  block EnginePowerEstimator {\n    property enginePower : Real {unit = 'kW'};\n  }\n\n  block FuelConsumptionCalculator {\n    property fuelConsumption : Real {unit = 'L/100km'};\n  }\n\n  constraint FuelEconomyConstraint {\n    formula (235.214583 / fuelEconomy) > 30;\n  }\n\n  verify SimulationAnalysis satisfies FuelEconomyConstraint;\n\n}",
    "package EngineSelectionModel {\n    enumeration CylinderType {\n        FourCylinder;\n        SixCylinder;\n    }\n\n    class Engine {\n        property type : CylinderType;\n        property power : Real;\n        property mass : Real;\n        property efficiency : Real;\n        property cost : Real;\n    }\n\n    function block UnifiedEvaluationFunction {\n        parameter power : Real { direction = in };\n        parameter mass : Real { direction = in };\n        parameter efficiency : Real { direction = in };\n        parameter cost : Real { direction = in };\n        parameter evaluationResult : Real { direction = out };\n    }\n\n    class EngineSelectionSystem {\n        property candidateEngines : Engine[*];\n        property evaluationFunction : UnifiedEvaluationFunction;\n        property optimalEngine : Engine;\n\n        constraint optimalEngine = select_max(candidateEngines, evaluationFunction.evaluationResult);\n    }\n}",
    "module VehicleWeightCheck {\n    value type CurbWeight : Real;\n    value type MaxCurbWeight : Real = 2500.0;\n    enumeration EvaluationResult {\n        Qualified,\n        Unqualified\n    }\n\n    block DataCollectionStep {\n        port actualWeightOut : FlowPort(CurbWeight) direction=out;\n    }\n\n    block DataProcessingStep {\n        port actualWeightIn : FlowPort(CurbWeight) direction=in;\n        port processedWeightOut : FlowPort(CurbWeight) direction=out;\n    }\n\n    block EvaluationStep {\n        port processedWeightIn : FlowPort(CurbWeight) direction=in;\n        port evaluationResultOut : FlowPort(EvaluationResult) direction=out;\n        constraint weightConstraint : processedWeightIn.value <= MaxCurbWeight.value;\n    }\n\n    block CurbWeightCheckProcess {\n        part dataCollection : DataCollectionStep;\n        part dataProcessing : DataProcessingStep;\n        part evaluation : EvaluationStep;\n        flow dataCollection.actualWeightOut -> dataProcessing.actualWeightIn;\n        flow dataProcessing.processedWeightOut -> evaluation.processedWeightIn;\n    }\n\n    block VehicleWeightCheckSystem {\n        part checkProcess : CurbWeightCheckProcess;\n        port resultPort : FlowPort(EvaluationResult) direction=out;\n        flow checkProcess.evaluation.evaluationResultOut -> resultPort;\n    }\n}",
    "package MassVerificationSystem {\n\n    value type MassValue : Real {\n        unit = kg;\n    }\n\n    block Vehicle {\n        property actualMass : MassValue;\n    }\n\n    block WeighingEquipment {\n        // No properties required for this example\n    }\n\n    block MassVerificationUnit {\n        property upperMassLimit : MassValue = 2500;\n        property weighingEquipment : WeighingEquipment;\n        constraint c1 : actualMass <= upperMassLimit;\n    }\n\n    block MassVerificationSystem {\n        property vehicle : Vehicle;\n        property massVerificationUnit : MassVerificationUnit;\n    }\n\n}",
    "package TransportationSystem {\n  block SharedVehicleSystem {\n    property driver : Person;\n    property passengers[*] : Person;\n    constraint extensibility for passengers: 0..4;\n    property vehicle : Vehicle;\n    property accessSystem : VehicleAccess;\n    property safetySustainability : SafetyAndSustainability;\n    property infrastructureCompat : InfrastructureCompatibility;\n    property rideExperience : RideExperience;\n\n    SharedVehicleSystem::driver : Person;\n    SharedVehicleSystem::passengers[*] : Person;\n    SharedVehicleSystem::vehicle : Vehicle;\n    SharedVehicleSystem::accessSystem : VehicleAccess;\n    SharedVehicleSystem::safetySustainability : SafetyAndSustainability;\n    SharedVehicleSystem::infrastructureCompat : InfrastructureCompatibility;\n    SharedVehicleSystem::rideExperience : RideExperience;\n\n    constraint driverAndPassengersCapacity: passengers.size() <= 4;\n    constraint safeOperation: safetySustainability.safetyConstraint;\n    constraint sustainableOperation: safetySustainability.sustainabilityConstraint;\n    constraint infrastructureSupport: infrastructureCompat.gasStationCompatibility;\n    constraint smoothAccess: accessSystem.smoothEntryExit;\n    constraint humanCentricExperience: rideExperience.convenience and rideExperience.comfort;\n  }\n\n  block Vehicle {\n    property capacity : Integer;\n    property safetyFeatures : SafetyFeatures;\n    property fuelType : String;\n\n    constraint capacityConstraint: capacity >= 1 and capacity <= 5;\n    constraint fuelCompatibility: fuelType in {\"Gasoline\", \"Electric\", \"Hybrid\"};\n  }\n\n  block VehicleAccess {\n    property entryExitMechanism : String;\n    constraint smoothEntryExit: entryExitMechanism in {\"Automatic doors\", \"Manual doors\", \"Roof access\"};\n  }\n\n  block SafetyAndSustainability {\n    property safetyConstraint : Boolean;\n    property sustainabilityConstraint : Boolean;\n    constraint safetyConstraint: safetyConstraint = true;\n    constraint sustainabilityConstraint: sustainabilityConstraint = true;\n  }\n\n  block InfrastructureCompatibility {\n    property gasStationCompatibility : Boolean;\n    constraint gasStationCompatibility: gasStationCompatibility = true;\n  }\n\n  block RideExperience {\n    property convenience : Boolean;\n    property comfort : Boolean;\n    constraint convenience: convenience = true;\n    constraint comfort: comfort = true;\n  }\n\n  block Person {\n    property role : String;\n    constraint roleConstraint: role in {\"Driver\", \"Passenger\"};\n  }\n\n  relationship R1 : SharedVehicleSystem has Vehicle;\n  relationship R2 : SharedVehicleSystem has VehicleAccess;\n  relationship R3 : SharedVehicleSystem has SafetyAndSustainability;\n  relationship R4 : SharedVehicleSystem has InfrastructureCompatibility;\n  relationship R5 : SharedVehicleSystem has RideExperience;\n  relationship R6 : SharedVehicleSystem has Person as driver;\n  relationship R7 : SharedVehicleSystem has Person as passengers;\n}",
    "package TransportationSystem {\n    block Driver {\n        // Driver properties and behaviors\n    }\n\n    block Passenger {\n        // Passenger properties and behaviors\n    }\n\n    block Vehicle {\n        property passengers : Passenger[*..4]\n        property fuelLevel : Float\n        property capacity : Integer = 4\n        property safetyFeatures : String\n    }\n\n    block EnvironmentalConditions {\n        property weather : String\n        property roadStatus : String\n    }\n\n    block GasStation {\n        // Gas station properties and behaviors\n    }\n\n    block TransportationProcess {\n        property enterVehicle : EnterVehicle\n        property operateVehicle : OperateVehicle\n        property refuel : Refuel\n        property exitVehicle : ExitVehicle\n\n        constraint c1 {\n            passengers.size() <= capacity\n        }\n\n        constraint c2 {\n            fuelLevel >= 0 and fuelLevel <= 100\n        }\n\n        sequence s1 {\n            enterVehicle\n            operateVehicle\n            when (fuelLevel < 20) then refuel\n            exitVehicle\n        }\n    }\n\n    block EnterVehicle {\n        relate driver : Driver to vehicle : Vehicle\n        relate passengers : Passenger[*..4] to vehicle\n    }\n\n    block OperateVehicle {\n        relate driver : Driver to vehicle : Vehicle\n        relate vehicle to environmentalConditions : EnvironmentalConditions\n    }\n\n    block Refuel {\n        relate vehicle : Vehicle to gasStation : GasStation\n    }\n\n    block ExitVehicle {\n        relate driver : Driver to vehicle : Vehicle\n        relate passengers : Passenger[*..4] to vehicle\n    }\n\n    requirement req1 {\n        constraint: The vehicle shall safely transport a driver and up to four passengers from start to destination.\n        satisfies: Vehicle.safetyFeatures\n    }\n\n    requirement req2 {\n        constraint: The driver shall be able to operate the vehicle under all environmental conditions.\n        relatesTo: EnvironmentalConditions\n    }\n\n    requirement req3 {\n        constraint: The vehicle shall support refueling at gas stations when fuel level is low.\n        satisfies: Refuel\n    }\n\n    requirement req4 {\n        constraint: Entry and exit processes shall be simple and convenient for all participants.\n        relatesTo: EnterVehicle, ExitVehicle\n    }\n}",
    "model VehicleConfiguration {\n\n  class Engine {\n    abstract property cylinders : Cylinder[*];\n  }\n\n  class FourCylinderEngine extends Engine {\n    property cylinders : Cylinder[4];\n  }\n\n  class SixCylinderEngine extends Engine {\n    property cylinders : Cylinder[6];\n  }\n\n  class Transmission {\n    abstract property type : String;\n  }\n\n  class ManualTransmission extends Transmission {\n    type : String = \"Manual\";\n  }\n\n  class AutomaticTransmission extends Transmission {\n    type : String = \"Automatic\";\n  }\n\n  class Cylinder {\n    property diameter : Real constrainedBy CylinderDiameterConstraint;\n  }\n\n  constraintblock CylinderDiameterConstraint {\n    parameter diameter : Real;\n    when (diameter <> 70 and diameter <> 100) then\n      false;\n  }\n\n  constraintblock EngineTransmissionConstraint {\n    parameter engine : Engine;\n    parameter transmission : Transmission;\n    when (transmission.oclIsKindOf(ManualTransmission) and not engine.oclIsKindOf(FourCylinderEngine)) then\n      false;\n    when (engine.oclIsKindOf(SixCylinderEngine) and not transmission.oclIsKindOf(AutomaticTransmission)) then\n      false;\n  }\n\n  class Vehicle {\n    property engine : Engine[1] constrainedBy EngineTransmissionConstraint;\n    property transmission : Transmission[1] constrainedBy EngineTransmissionConstraint;\n  }\n\n}",
    "package EngineModel {\n  value type CylinderCount : Integer {\n    allowedValues: 4, 6\n  }\n\n  value type CylinderDiameter : Length {\n    allowedValues: 70 mm, 100 mm\n  }\n\n  block Cylinder {\n    property diameter : CylinderDiameter\n  }\n\n  block Engine {\n    property cylinderCount : CylinderCount\n    property cylinderDiameter : CylinderDiameter\n    part cylinders : Cylinder[*] {\n      diameter <- cylinderDiameter\n    }\n  }\n\n  variant FourCylinderEngine : Engine {\n    constraint: cylinderCount = 4\n  }\n\n  variant SixCylinderEngine : Engine {\n    constraint: cylinderCount = 6\n  }\n}",
    "module AutomotiveConfiguration {\n  block Engine {\n    property cylinders : Integer;\n    property diameter : Length @unit mm;\n  }\n\n  block Transmission {\n  }\n\n  block FourCylinderEngine specializes Engine {\n    constraint c1: self.cylinders = 4;\n  }\n\n  block SixCylinderEngine specializes Engine {\n    constraint c1: self.cylinders = 6;\n  }\n\n  block ManualTransmission specializes Transmission {\n  }\n\n  block AutomaticTransmission specializes Transmission {\n  }\n\n  block Vehicle {\n    part engine : Engine;\n    part transmission : Transmission;\n    constraint EngineTransmissionConstraint {\n      if engine.isKindOf(FourCylinderEngine) then\n        transmission.isKindOf(ManualTransmission)\n      else if engine.isKindOf(SixCylinderEngine) then\n        transmission.isKindOf(AutomaticTransmission)\n      else\n        false\n      end if;\n    }\n    constraint CylinderDiameterConstraint {\n      engine.diameter in {70, 100};\n    }\n  }\n}",
    "model SystemModel {\n  block SoftwareDesign {\n    part messageFormat : MessageFormat;\n    part dataFormat : DataFormat;\n  }\n\n  block MessageFormat {\n  }\n\n  block DataFormat {\n  }\n\n  block ComputerSubsystem {\n    part softwareDesign : SoftwareDesign;\n    constraint c1 : ComputerConstraint {\n      note \"must utilize and integrate all functions specified in the software design\";\n    }\n  }\n\n  block StorageSubsystem {\n    part messageFormat : MessageFormat;\n    part dataFormat : DataFormat;\n    constraint c2 : StorageConstraint {\n      note \"must be compatible with the message and data formats defined by the software design\";\n    }\n  }\n\n  block SystemAssembly {\n    part computerSubsystem : ComputerSubsystem;\n    part storageSubsystem : StorageSubsystem;\n    part softwareDesign : SoftwareDesign;\n    constraint c3 : SystemConstraint {\n      note \"software and hardware must work together seamlessly to ensure efficient, reliable, and compliant processes of information storage, transmission, and processing\";\n    }\n  }\n}",
    "model PowertrainModel {\n  block PowertrainSystem {\n    part logicalLayer : LogicalLayer;\n    part physicalLayer : PhysicalLayer;\n    allocate logicalLayer.torqueGenerator to physicalLayer.powerUnit;\n  }\n\n  block LogicalLayer {\n    part torqueGenerator : TorqueGenerator;\n  }\n\n  block TorqueGenerator {\n    behavior convertPowerToTorque : Behavior;\n  }\n\n  block PhysicalLayer {\n    part powerUnit : PowerUnit;\n  }\n\n  block PowerUnit {\n    behavior outputPower : Behavior;\n    behavior generateTorque : Behavior;\n    generateTorque satisfy /PowertrainModel/LogicalLayer/TorqueGenerator/convertPowerToTorque;\n  }\n}",
    "block System {\n  part powertrain : Powertrain;\n}\n\nblock LogicalSystem {\n  part torqueGenerator : TorqueGenerator;\n}\n\nblock TorqueGenerator {\n  action generateTorque;\n}\n\nblock Powertrain {\n  part engine : Engine;\n}\n\nblock Engine {\n  action generateTorque;\n}\n\nallocation LogicalSystemAllocation : LogicalSystem -> System.powertrain;\n\nallocation TorqueGeneratorAllocation : LogicalSystem.torqueGenerator -> Powertrain.engine;\n\nallocation GenerateTorqueAllocation : TorqueGenerator.generateTorque -> Engine.generateTorque;",
    "module VehicleFeatureAnnotationSystem {\n  block Vehicle {\n    part interior : InteriorAssembly;\n    part body : BodyAssembly;\n  }\n\n  block InteriorAssembly {\n    part seatBelts : SeatBelts;\n    part frontSeats : FrontSeats;\n    part driverAirbag : DriverAirbag;\n    part alarmSystem : AlarmSystem;\n  }\n\n  block BodyAssembly {\n    part bodyShell : BodyShell;\n    part bumpers : Bumpers;\n    part keylessEntryDevice : KeylessEntryDevice;\n  }\n\n  block SeatBelts;\n  block FrontSeats;\n  block DriverAirbag;\n  block AlarmSystem;\n  block BodyShell;\n  block Bumpers;\n  block KeylessEntryDevice;\n\n  function SafetyFunction;\n  function SecurityFunction;\n\n  relation FunctionRealization from SeatBelts to SafetyFunction;\n  relation FunctionRealization from DriverAirbag to SafetyFunction;\n  relation FunctionRealization from Bumpers to SafetyFunction;\n  relation FunctionRealization from AlarmSystem to SecurityFunction;\n  relation FunctionRealization from KeylessEntryDevice to SecurityFunction;\n\n  constraint module Constraints {\n    constraint clause AutomotiveSafety : \"The system must ensure automotive safety standards are met.\";\n    constraint clause Protection : \"The system must provide protection for occupants and components.\";\n    constraint clause UserConvenience : \"The system must enhance user convenience in vehicle operation.\";\n    constraint clause PropertySecurity : \"The system must prevent unauthorized access and theft.\";\n  }\n\n  apply Constraints.AutomotiveSafety to SafetyFunction;\n  apply Constraints.Protection to SafetyFunction;\n  apply Constraints.PropertySecurity to SecurityFunction;\n  apply Constraints.UserConvenience to KeylessEntryDevice;\n}",
    "import sysml::*;\nimport ModelCenter::*;\n\nblock VehicleDynamicSimulationSystem {\n    property initialVelocity : Real;\n    property initialPosition : Real;\n    property acceleration : Real;\n    property timeStep : Duration;\n    property finalVelocity : Real;\n    property finalPosition : Real;\n\n    part physicalModel : PhysicalModel;\n    part modelCenterTool : ModelCenterIntegration;\n\n    behavior simulateVehicleDynamics : FunctionBehavior {\n        input initialVelocity : Real;\n        input initialPosition : Real;\n        input acceleration : Real;\n        input timeStep : Duration;\n        output finalVelocity : Real;\n        output finalPosition : Real;\n\n        action calculateDynamics {\n            finalVelocity = initialVelocity + acceleration * timeStep;\n            finalPosition = initialPosition + initialVelocity * timeStep + 0.5 * acceleration * timeStep^2;\n        }\n    }\n\n    constraint dataTransferConstraint : DataConstraint {\n        ensure (initialVelocity == physicalModel.initialVelocity \n                and initialPosition == physicalModel.initialPosition \n                and acceleration == physicalModel.acceleration \n                and timeStep == physicalModel.timeStep);\n    }\n\n    constraint resultOutputConstraint : DataConstraint {\n        ensure (finalVelocity == physicalModel.finalVelocity \n                and finalPosition == physicalModel.finalPosition);\n    }\n}\n\nblock PhysicalModel {\n    property initialVelocity : Real;\n    property initialPosition : Real;\n    property acceleration : Real;\n    property timeStep : Duration;\n    property finalVelocity : Real;\n    property finalPosition : Real;\n\n    behavior computeDynamics : FunctionBehavior {\n        input initialVelocity : Real;\n        input initialPosition : Real;\n        input acceleration : Real;\n        input timeStep : Duration;\n        output finalVelocity : Real;\n        output finalPosition : Real;\n\n        action applyEquationsOfMotion {\n            finalVelocity = initialVelocity + acceleration * timeStep;\n            finalPosition = initialPosition + initialVelocity * timeStep + 0.5 * acceleration * timeStep^2;\n        }\n    }\n}\n\nblock ModelCenterIntegration {\n    operation runSimulation(\n        input initialVelocity : Real,\n        input initialPosition : Real,\n        input acceleration : Real,\n        input timeStep : Duration\n    ) : Void {\n        action execute {\n            // Integration logic with ModelCenter tool\n            // Returns computed finalVelocity and finalPosition via output parameters\n        }\n    }\n}",
    "model CarSafetyCompliance {\n  package SafetyFeatures {\n    class SeatBelt @Safety {}\n    class Bumper @Safety {}\n    class AntiLockBrakingSystem @Safety {}\n    class DriversAirbag @Safety {}\n  }\n\n  package MandatorySafetyFeatures {\n    class SeatBelt @Safety { isMandatory = true }\n    class Bumper @Safety { isMandatory = true }\n  }\n\n  class Car {\n    interior: Interior;\n    body: Body;\n    wheelAssembly: WheelAssembly;\n  }\n\n  class Interior {\n    seatBelts: SeatBelt[2];\n    driversAirbag: DriversAirbag[0..1];\n  }\n\n  class Body {\n    bumper: Bumper;\n  }\n\n  class WheelAssembly {\n    wheels: Wheel[2];\n    abs: AntiLockBrakingSystem[0..1];\n  }\n\n  class Wheel {}\n  class KeylessEntrySystem {}\n}",
    "package VehicleSafetyCompliance {\n  stereotype SafetyFeature {\n    isMandatory : Boolean;\n  }\n\n  block VehicleInterior {\n    part seatBelt : SeatBelt [2];\n    apply SafetyFeature to seatBelt {\n      isMandatory = true;\n    }\n\n    part driverAirbag : DriverAirbag [0..1];\n    apply SafetyFeature to driverAirbag {\n      isMandatory = false;\n    }\n  }\n\n  block VehicleBody {\n    part bumper : Bumper [1];\n    apply SafetyFeature to bumper {\n      isMandatory = true;\n    }\n\n    part keylessEntrySystem : KeylessEntrySystem [0..1];\n    apply SafetyFeature to keylessEntrySystem {\n      isMandatory = false;\n    }\n  }\n\n  block ChassisSystem {\n    part tire : Tire [4..4];\n    apply SafetyFeature to tire {\n      isMandatory = true;\n    }\n\n    part abs : AntiLockBrakingSystem [0..1];\n    apply SafetyFeature to abs {\n      isMandatory = false;\n    }\n  }\n\n  block VehicleSafetyComplianceSystem {\n    part interior : VehicleInterior;\n    part body : VehicleBody;\n    part chassis : ChassisSystem;\n  }\n}",
    "package RiskManagement {\n  class RiskScenario {\n    name : String;\n    description : String;\n    situations : Situation[*] { subsets RiskScenario::ownedElements; }\n    causalLinks : CausalLink[*] { subsets RiskScenario::ownedElements; }\n    ownedElements : Element[*] { union; }\n  }\n\n  class Situation {\n    name : String;\n    description : String;\n    riskScenario : RiskScenario;\n    causes : Cause[*] { subsets Situation::ownedElements; }\n    failures : Failure[*] { subsets Situation::ownedElements; }\n    outgoingLinks : CausalLink[*];\n    incomingLinks : CausalLink[*];\n    ownedElements : Element[*] { union; }\n  }\n\n  class Cause {\n    name : String;\n    description : String;\n    probability : String;\n    situation : Situation;\n    ownedElements : Element[*] { union; }\n  }\n\n  class Failure {\n    name : String;\n    description : String;\n    severityLevel : String;\n    situation : Situation;\n    ownedElements : Element[*] { union; }\n  }\n\n  class CausalLink {\n    name : String;\n    description : String;\n    source : Situation;\n    target : Situation;\n    riskScenario : RiskScenario;\n    ownedElements : Element[*] { union; }\n  }\n\n  association RiskScenarioOwnsSituations {\n    member end RiskScenario::situations : Situation[*];\n    member end Situation::riskScenario : RiskScenario;\n  }\n\n  association RiskScenarioOwnsCausalLinks {\n    member end RiskScenario::causalLinks : CausalLink[*];\n    member end CausalLink::riskScenario : RiskScenario;\n  }\n\n  association SituationOwnsCauses {\n    member end Situation::causes : Cause[*];\n    member end Cause::situation : Situation;\n  }\n\n  association SituationOwnsFailures {\n    member end Situation::failures : Failure[*];\n    member end Failure::situation : Situation;\n  }\n\n  association CausalLinkSource {\n    member end CausalLink::source : Situation;\n    member end Situation::outgoingLinks : CausalLink[*];\n  }\n\n  association CausalLinkTarget {\n    member end CausalLink::target : Situation;\n    member end Situation::incomingLinks : CausalLink[*];\n  }\n}",
    "package RiskMetadataModel {\n  class RiskElement {\n    property name : String;\n    property description : String;\n  }\n\n  class Scenario extends RiskElement {\n    // No additional properties\n  }\n\n  class Cause extends RiskElement {\n    property probability : Real;\n  }\n\n  class Failure extends RiskElement {\n    property severity : Integer;\n  }\n\n  association CausalRelationship {\n    member end source : Scenario [1];\n    member end target : Scenario [1];\n  }\n\n  class RiskScenario {\n    property name : String;\n    property description : String;\n    property elements : RiskElement[*];\n    property relationships : CausalRelationship[*];\n  }\n\n  // Define inheritance relationships\n  Scenario <<generalization>> : RiskElement;\n  Cause <<generalization>> : RiskElement;\n  Failure <<generalization>> : RiskElement;\n}",
    "block Battery {\n  property batteryLevel : Float;\n}\n\nblock BatteryAging {\n  property probabilityOfFailure : Float;\n}\n\nblock LowBattery {\n  property duration : Duration;\n}\n\nblock DeviceShutdown {\n  property consequence : String;\n}\n\nblock FailureScenario {\n  property failureCause : BatteryAging;\n  property consequence : DeviceShutdown;\n  property severity : SeverityLevel;\n}\n\nenumeration SeverityLevel {\n  High;\n  Medium;\n  Low;\n}\n\nblock BatteryMonitoringSystem {\n  part battery : Battery;\n  part batteryAging : BatteryAging;\n  part lowBattery : LowBattery;\n  part deviceShutdown : DeviceShutdown;\n  part failureScenario : FailureScenario;\n  part severityLevel : SeverityLevel;\n\n  constraint batteryLevelConstraint : battery.batteryLevel <= batteryAging.probabilityOfFailure;\n  constraint lowBatteryThreshold : battery.batteryLevel < minThreshold implies lowBattery.duration > 0;\n  constraint shutdownCondition : lowBattery.duration > maxDuration implies deviceShutdown.consequence = \"device shutdown\";\n  constraint severityAssignment : if (failureScenario.severity = High) then alertUsers() else if (failureScenario.severity = Medium) then logWarning() else if (failureScenario.severity = Low) then monitorContinuously();\n}\n\nstate machine BatteryMonitoringStateMachine {\n  state NormalOperation {\n    on entry do {\n      monitorBatteryLevel();\n    }\n  }\n  state LowBattery {\n    entry / checkLowBattery();\n    exit / handleLowBatteryExit();\n    after (prolongedDuration) do {\n      transition to: DeviceShutdown;\n    }\n  }\n  state DeviceShutdown {\n    entry / initiateShutdown();\n  }\n}\n\nrelationship BatteryAgingLeadsToLowBattery {\n  source : BatteryAging;\n  target : LowBattery;\n  property agingImpact : Float;\n}\n\nrelationship LowBatteryLeadsToDeviceShutdown {\n  source : LowBattery;\n  target : DeviceShutdown;\n  property durationThreshold : Duration;\n}",
    "module SystemDecomposition {\n  block TopLevelSystem {\n    part subSystemA : SubSystemA;\n  }\n\n  block SubSystemA {\n    part component1 : Component1;\n    part component2 : Component2;\n  }\n\n  block Component1 {\n    port inputPort : InputInterface [in];\n    port outputPort : OutputInterface [out];\n  }\n\n  block Component2 {\n    port outputPort : OutputInterface [out];\n    port controlPort : ControlInterface [in];\n  }\n\n  interface InputInterface {\n    property signal : SignalType;\n  }\n\n  interface OutputInterface {\n    property data : DataType;\n  }\n\n  interface ControlInterface {\n    property command : CommandType;\n  }\n\n  constraintClause StructuralIntegrityConstraint {\n    verify: \n      allFunctionsCovered and \n      allInterfacesDefined and \n      modularDesignVerified;\n  }\n}",
    "package AutomotiveSystemModel {\n    stereotype SafetyComponent {\n        property mandatory : Boolean\n    }\n\n    interface MechanicalInterface {}\n    interface ElectricalInterface {}\n    interface SafetyInterface {}\n\n    component AutomotiveSystem {\n        parts: \n            chassis : ChassisSubsystem,\n            powertrain : PowertrainSubsystem,\n            electrical : ElectricalSubsystem,\n            occupantSafety : OccupantSafetySubsystem\n    }\n\n    component ChassisSubsystem {\n        parts: \n            bumper : BumperComponent,\n            seatBelt : SeatBeltComponent,\n            suspension : SuspensionComponent\n    }\n\n    component BumperComponent {\n        apply SafetyComponent {mandatory = true}\n        provides: bumperInterface : MechanicalInterface\n    }\n\n    component SeatBeltComponent {\n        apply SafetyComponent {mandatory = true}\n        provides: seatBeltInterface : MechanicalInterface\n        provides: safetyInterface : SafetyInterface\n    }\n\n    component SuspensionComponent {\n        provides: suspensionInterface : MechanicalInterface\n    }\n\n    component PowertrainSubsystem {\n        parts: \n            engine : EngineComponent,\n            transmission : TransmissionComponent\n    }\n\n    component EngineComponent {\n        provides: engineInterface : MechanicalInterface\n    }\n\n    component TransmissionComponent {\n        provides: transmissionInterface : MechanicalInterface\n    }\n\n    component ElectricalSubsystem {\n        parts: \n            battery : BatteryComponent,\n            ecu : ECUComponent\n    }\n\n    component BatteryComponent {\n        provides: powerInterface : ElectricalInterface\n    }\n\n    component ECUComponent {\n        provides: controlInterface : ElectricalInterface\n    }\n\n    component OccupantSafetySubsystem {\n        parts: \n            driverAirbag : DriverAirbagComponent,\n            abs : ABSComponent\n    }\n\n    component DriverAirbagComponent {\n        apply SafetyComponent {mandatory = false}\n        provides: airbagInterface : SafetyInterface\n    }\n\n    component ABSComponent {\n        apply SafetyComponent {mandatory = false}\n        provides: brakingInterface : SafetyInterface\n    }\n\n    viewpoint StructuralViewpoint {\n        view StructuralView {\n            tree {\n                AutomotiveSystem\n            }\n        }\n    }\n\n    viewpoint SafetyViewpoint {\n        view SafetyTableView {\n            table {\n                columns: \n                    name : String,\n                    type : String,\n                    mandatory : Boolean\n                rows: \n                    BumperComponent : \"BumperComponent\", true,\n                    SeatBeltComponent : \"SeatBeltComponent\", true,\n                    DriverAirbagComponent : \"DriverAirbagComponent\", false,\n                    ABSComponent : \"ABSComponent\", false\n            }\n        }\n    }\n\n    viewpoint NonSafetyViewpoint {\n        view NonSafetyTableView {\n            table {\n                columns: \n                    name : String,\n                    type : String\n                rows: \n                    SuspensionComponent : \"SuspensionComponent\",\n                    EngineComponent : \"EngineComponent\",\n                    TransmissionComponent : \"TransmissionComponent\",\n                    BatteryComponent : \"BatteryComponent\",\n                    ECUComponent : \"ECUComponent\"\n            }\n        }\n    }\n}",
    "model AutomotiveDomainModel {\n  comment \"此系统模型旨在为汽车领域中的基本概念和元素提供标准化定义和注释。模型核心组件为汽车，包含别名定义和物理量关联，确保特性表达的一致性。\"\n\n  block 汽车 {\n    alias 汽车 (Car)\n    comment \"汽车是汽车领域的核心组件，别名'汽车 (Car)'用于多语言场景下的通用标识。\"\n\n    property 扭矩 : Real {\n      unit N·m\n      comment \"扭矩是描述动力系统输出能力的关键物理量，单位为牛顿米 (N·m)，用于标准化动力传输特性。\"\n    }\n  }\n}",
    "module DocumentManagementPlatform {\n  block Automobile {\n    alias Car\n    property torque : PhysicalQuantities.ISQStandard.TorqueValue\n    property explanatoryDocument : Document\n  }\n\n  block Document {\n    property subject : Automobile\n    property content : String\n  }\n\n  module PhysicalQuantities {\n    block PhysicalQuantity {\n      // Base class for all physical quantities\n    }\n\n    block TorqueValue {\n      extends PhysicalQuantity\n      // Specific properties for torque values\n    }\n\n    block ISQStandard {\n      // Standard definition for International System of Quantities\n    }\n  }\n}",
    "model Automobile {\n    alias Car for Automobile;\n    import PhysicalQuantities::*;\n    alias Torque for TorqueValue;\n\n    block Automobile {\n        property torqueParameters : VehicleTorqueParameters;\n    }\n\n    block VehicleTorqueParameters {\n        property torqueValue : Torque;\n    }\n}",
    "value VehicleSize {\n  small,\n  large,\n  standard\n}\n\nblock Engine {\n  property cylinders : Integer;\n}\n\nblock Vehicle {\n  property size : VehicleSize;\n  property engine : Engine;\n  constraint CylinderConstraint(vehicleSize <- size, cylinderCount <- engine.cylinders);\n}\n\nconstraintblock CylinderConstraint {\n  parameter vehicleSize : VehicleSize;\n  parameter cylinderCount : Integer;\n  rule cylinderRule {\n    if (vehicleSize == VehicleSize.small) then\n      cylinderCount = 4;\n    elif (vehicleSize == VehicleSize.large) then\n      cylinderCount = 6;\n    else\n      cylinderCount >= 4 and cylinderCount <= 6;\n    end if;\n  }\n}",
    "model FuelManagementSystemModel {\n  block FuelTank {\n    port fuelOut : FuelInterface;\n  }\n\n  block Engine {\n    port fuelIn : FuelInterface;\n  }\n\n  block FuelInterface {\n    port fuelIn : Flow<in>;\n    port fuelOut : Flow<out>;\n  }\n\n  block FuelManagementSystem {\n    part fuelTank : FuelTank;\n    part engine : Engine;\n    part fuelInterface : FuelInterface;\n\n    constraint Clause1 : fuelInterface must be standardized to ensure reliability and safety;\n\n    behavior manageFuelFlow {\n      parameter fuelFlow : Flow<out>;\n      parameter returnFlow : Flow<in>;\n\n      action transferFuel {\n        input fuelFlow;\n        output returnFlow;\n      }\n    }\n\n    behavior monitorFuelTemperature {\n      parameter fuelTemperature : Value<in>;\n\n      action checkTemperature {\n        input fuelTemperature;\n      }\n    }\n\n    connection between fuelTank.fuelOut and fuelInterface.fuelIn;\n    connection between fuelInterface.fuelOut and engine.fuelIn;\n  }\n}",
    "model VehicleStructuralArchitecture {\n  block Vehicle {\n    property mass : Float {unit = kg};\n    part frontAxleAssembly : AxleAssembly;\n    part rearAxleAssembly : AxleAssembly;\n  }\n\n  block AxleAssembly {\n    part axle : Axle;\n    part wheels : Wheel[*] {ordered, unique, size 2};\n  }\n\n  block Axle {}\n\n  block FrontAxle extends Axle {\n    property steeringAngle : Float {unit = degree};\n  }\n\n  block RearAxle extends Axle {}\n\n  block Wheel {\n    property name : String;\n  }\n\n  instanceSpecification vehicle1 : Vehicle {\n    mass = 1750;\n    frontAxleAssembly : AxleAssembly {\n      axle : FrontAxle {\n        steeringAngle = 30;\n      };\n      wheels = [Wheel {name = \"Left Front\"}, Wheel {name = \"Right Front\"}];\n    };\n    rearAxleAssembly : AxleAssembly {\n      axle : RearAxle {};\n      wheels = [Wheel {name = \"Left Rear\"}, Wheel {name = \"Right Rear\"}];\n    };\n  };\n\n  instanceSpecification vehicle2 : Vehicle {\n    mass = 2000;\n    frontAxleAssembly : AxleAssembly {\n      axle : FrontAxle {};\n      wheels = [Wheel {name = \"Left Front\"}, Wheel {name = \"Right Front\"}];\n    };\n    rearAxleAssembly : AxleAssembly {\n      axle : RearAxle {};\n      wheels = [Wheel {}, Wheel {}];\n    };\n  };\n}"
]